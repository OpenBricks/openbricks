diff -r 448a43f59a37 Makefile
--- a/Makefile	Sun Apr 30 17:12:20 2006 +0200
+++ b/Makefile	Sun Apr 30 17:14:32 2006 +0200
@@ -125,6 +125,10 @@ COMMON_LIBS = libmpcodecs/libmpcodecs.a 
               $(FONTCONFIG_LIB) \
               $(ENCA_LIB) \
 
+ifeq ($(LIBMPDVDNAV),yes)
+COMMON_LIBS += libmpdvdnav/libmpdvdnav.a
+endif
+
 CFLAGS = $(OPTFLAGS) -I. \
          $(CACA_INC) \
          $(CDPARANOIA_INC) \
@@ -190,6 +194,9 @@ PARTS += libmpdvdkit2
 PARTS += libmpdvdkit2
 else
 endif
+ifeq ($(LIBMPDVDNAV),yes)
+PARTS += libmpdvdnav
+endif
 ifeq ($(GUI),yes)
 PARTS += Gui
 endif
@@ -249,6 +256,9 @@ ifeq ($(DVDKIT2),yes)
 ifeq ($(DVDKIT2),yes)
 COMMON_DEPS += libmpdvdkit2/libmpdvdkit.a
 endif
+ifeq ($(LIBMPDVDNAV),yes)
+COMMON_DEPS += libmpdvdnav/libmpdvdnav.a
+endif
 
 ifeq ($(GUI),yes)
 COMMON_DEPS += Gui/libgui.a
@@ -269,6 +279,9 @@ libaf/libaf.a:
 
 libmpdvdkit2/libmpdvdkit.a:
 	$(MAKE) -C libmpdvdkit2
+
+libmpdvdnav/libmpdvdnav.a:
+	$(MAKE) -C libmpdvdnav
 
 loader/libloader.a:
 	$(MAKE) -C loader
diff -r 448a43f59a37 cfg-common.h
--- a/cfg-common.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/cfg-common.h	Sun Apr 30 17:14:32 2006 +0200
@@ -32,6 +32,23 @@
 	{"dvdnav", "-dvdnav is deprecated, use dvdnav:// instead.\n", CONF_TYPE_PRINT, 0, 0, 1, NULL},
 	{"skipopening", &dvd_nav_skip_opening, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"noskipopening", &dvd_nav_skip_opening, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+#ifdef USE_MPDVDNAV
+	{"mlang", &dvdmenu_lang, CONF_TYPE_STRING, 0, 0, 0, NULL},
+	{"dvdnav-menutype", &dvdnav_menutype, CONF_TYPE_INT, CONF_RANGE|CONF_GLOBAL, 0, 2, NULL},
+	{"dvdnav-color-spu", &dvdnav_color_spu, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"dvdnav-nocolor-spu", &dvdnav_color_spu, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+	{"dvdnav-force-menu", &dvdnav_force_menu, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"dvdnav-noforce-menu", &dvdnav_force_menu, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+//	{"dvdnav-skipintro", &dvdnav_skipintro, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+//	{"dvdnav-noskipintro", &dvdnav_skipintro, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+#ifdef USE_MPDVDNAV_TRACE
+	{"dvdnav-trace", &dvdnav_trace, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"dvdnav-notrace", &dvdnav_trace, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+#else
+	{"dvdnav-trace", "MPlayer was compiled without dvdnav trace support.\n", CONF_TYPE_PRINT, CONF_NOCFG, 0, 0, NULL},
+	{"dvdnav-notrace", "MPlayer was compiled without dvdnav trace support.\n", CONF_TYPE_PRINT, CONF_NOCFG, 0, 0, NULL},
+#endif
+#endif
 #endif
 #ifdef USE_DVDREAD
 	{"dvd-device", &dvd_device,  CONF_TYPE_STRING, 0, 0, 0, NULL}, 
diff -r 448a43f59a37 configure
--- a/configure	Sun Apr 30 17:12:20 2006 +0200
+++ b/configure	Sun Apr 30 17:14:32 2006 +0200
@@ -1586,8 +1586,8 @@ _ladspa=auto
 _ladspa=auto
 _xmms=no
 _have_dvd=no
-# dvdnav disabled, it does not work
-#_dvdnav=no
+_dvdnav=no
+_dvdnav_trace=yes
 _dvdread=auto
 _dvdkit=auto
 _xanim=auto
@@ -1810,9 +1810,10 @@ for ac_option do
   --disable-dvdread)	_dvdread=no	;;
   --enable-mpdvdkit)	_dvdkit=yes	;;
   --disable-mpdvdkit)	_dvdkit=no	;;
-# dvdnav disabled, it does not work
-#  --enable-dvdnav)	_dvdnav=yes	;;
-#  --disable-dvdnav)	_dvdnav=no	;;
+  --enable-dvdnav)	_dvdnav=yes	;;
+  --disable-dvdnav)	_dvdnav=no	;;
+  --enable-dvdnav-trace) 	_dvdnav_trace=yes	;;
+  --disable-dvdnav-trace)	_dvdnav_trace=no	;;
   --enable-xanim)	_xanim=yes	;;
   --disable-xanim)	_xanim=no	;;
   --enable-real)	_real=yes	;;
@@ -5139,6 +5140,25 @@ fi
 #   _noinputmodules="dvdnav $_noinputmodules"
 # fi
 # echores "$_dvdnav"
+echocheck "DVDNAV support"
+if test "$_dvdnav" = yes ; then
+  _largefiles=yes
+  _def_dvdnav='#define USE_DVDNAV 1'
+  _def_mpdvdnav='#define USE_MPDVDNAV 1'
+if test "$_dvdnav_trace" = yes ; then
+  _def_mpdvdnav_trace='#define USE_MPDVDNAV_TRACE 1'
+  _inputmodules="dvdnav(dvdnav-trace) $_inputmodules"
+else
+  _inputmodules="dvdnav $_inputmodules"
+fi
+  _dvdnav_version='0110'
+  _def_dvdnav_version="#define DVDNAVVERSION $_dvdnav_version"
+  _def_dvdnav_sversion="#define DVDNAVSVERSION \"0.1.10\""
+  echores "yes"
+else
+  _noinputmodules="dvdnav $_noinputmodules"
+fi
+echores "$_dvdnav"
 
 echocheck "cdparanoia"
 if test "$_cdparanoia" = auto ; then
@@ -7347,6 +7367,7 @@ DVDREAD = $_dvdread
 DVDREAD = $_dvdread
 DVDREAD_LIB = $_ld_dvdread
 DVDKIT2 = $_dvdkit
+LIBMPDVDNAV = $_dvdnav
 SDL_INC = $_inc_sdl
 W32_DEP = $_dep_win32
 W32_LIB = $_ld_win32
@@ -7729,6 +7750,9 @@ int setenv(const char *name, const char 
 /* DVD navigation support using libdvdnav */
 $_def_dvdnav
 $_def_dvdnav_version
+$_def_dvdnav_sversion
+$_def_mpdvdnav
+$_def_mpdvdnav_trace
 
 /* Define this to enable MPEG 1/2 image postprocessing (requires a FAST CPU!) */
 #define MPEG12_POSTPROC 1
diff -r 448a43f59a37 help/help_mp-en.h
--- a/help/help_mp-en.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/help/help_mp-en.h	Sun Apr 30 17:14:32 2006 +0200
@@ -24,6 +24,10 @@ static char help_text[]=
 #ifdef USE_DVDREAD
 " dvd://<titleno>  play DVD title from device instead of plain file\n"
 " -alang/-slang    select DVD audio/subtitle language (by 2-char country code)\n"
+#ifdef USE_MPDVDNAV
+" -mlang           select DVD menu language (by 2-char country code)\n"
+" -dvdnav-menutype set DVD menu button type: 0: spu (default), 1: simple box, 2: spu & simple box\n"
+#endif
 #endif
 " -ss <position>   seek to given (seconds or hh:mm:ss) position\n"
 " -nosound         do not play sound\n"
@@ -1816,3 +1820,160 @@ static char help_text[]=
 // libvo/vo_xv.c
 
 #define MSGTR_LIBVO_XV_DrawFrameCalled "[VO_XV] draw_frame() called!!!!!!\n"
+
+// mpdvdnav - gui
+#define MSGTR_MENU_DVDNAV "DVDNAV"
+#define MSGTR_MENU_PlayDVDNAV "Play DVDNAV..."
+#define MSGTR_MENU_MenuDVDNAV "Main DVD Menu"
+
+// mpdvdnav
+
+#define MSGTR_MPDVDNAV_StopEvent "DVDNAV Event: STOP!\n"
+#define MSGTR_MPDVDNAV_WaitEvent "DVDNAV Event: Wait\n"
+#define MSGTR_MPDVDNAV_StillFrameEvent "DVDNAV Event: Still frame\n"
+#define MSGTR_MPDVDNAV_VtsChangeEvent "DVDNAV Event: Vts change\n"
+#define MSGTR_MPDVDNAV_CellChangeEvent "DVDNAV Event: Cell change\n"
+#define MSGTR_MPDVDNAV_SpuClutChangeEvent "DVDNAV Event: Spu clut change\n"
+#define MSGTR_MPDVDNAV_HighlightEvent "DVDNAV Event: Highlight\n"
+#define MSGTR_MPDVDNAV_NavPacketEvent "DVDNAV Event: Nav packet\n"
+
+#define MSGTR_MPDVDNAV_StillFrameDecodeError "Still frame decode error\n"
+#define MSGTR_MPDVDNAV_StillSkip "Dvdnav still skip\n"
+#define MSGTR_MPDVDNAV_CellN "cellN      : %i\n"
+#define MSGTR_MPDVDNAV_PgN "pgN        : %d\n"
+#define MSGTR_MPDVDNAV_CellLength "cell_length: %d\n"
+#define MSGTR_MPDVDNAV_PgLength "pg_lenght  : %d\n"
+#define MSGTR_MPDVDNAV_PgcLength "pgc_lenght : %d\n"
+#define MSGTR_MPDVDNAV_CellStart "cell_start : %d\n"
+#define MSGTR_MPDVDNAV_PgStart "pg_start   : %d\n"
+#define MSGTR_MPDVDNAV_Title "DVDNAV new title: %i\n"
+#define MSGTR_MPDVDNAV_Part  "DVDNAV new part: %i\n"
+#define MSGTR_MPDVDNAV_Aspect43 "Aspect 4/3\n"
+#define MSGTR_MPDVDNAV_Aspect169 "Aspect 16/9\n"
+#define MSGTR_MPDVDNAV_AspectOther "Aspect ? (%i)\n"
+#define MSGTR_MPDVDNAV_AudioID "DVDNAV new audio ID: %i\n"
+#define MSGTR_MPDVDNAV_DvdSubID "DVDNAV new dvdsub ID: %i\n"
+#define MSGTR_MPDVDNAV_Len "DVDNAV len: %i\n"
+#define MSGTR_MPDVDNAV_ReadInStillActive "%s: got a stream_read while I should be asleep!\n"
+#define MSGTR_MPDVDNAV_ErrorGetNextBlock "Error getting next block from DVD (%s)\n"
+#define MSGTR_MPDVDNAV_ErrorStreamRead "DVDNAV stream read error: %s\n"
+#define MSGTR_MPDVDNAV_ErrorSeek "DVDNAV stream seek error: %s (%llx)\n"
+#define MSGTR_MPDVDNAV_ErrorNav "DVDNAV navigation error: %s\n"
+#define MSGTR_MPDVDNAV_NoColorSpu "Color SPU does not support this vo!\n"
+
+// ----------------------- libmpdvdnav error -----------------------
+// libmpdvdnav - dvdnav.c
+#define MSGTR_LIBMPDVDNAV_Err_ErrorInitialisingTheDVDVM "Error initialising the DVD VM."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorStartingTheVM "Error starting the VM / opening the DVD device."
+#define MSGTR_LIBMPDVDNAV_Err_PassedANullPointer "Passed a NULL pointer."
+#define MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted "Virtual DVD machine not started."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorRestartingTheVM "Error restarting the VM."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket "Error reading NAV packet."
+#define MSGTR_LIBMPDVDNAV_Err_ExpectedNAVPacketButNoneFound "Expected NAV packet but none found."
+#define MSGTR_LIBMPDVDNAV_Err_UnknownDomainWhenChangingVTS "Unknown domain when changing VTS."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket "Error reading NAV packet."
+#define MSGTR_LIBMPDVDNAV_Err_AttemptingToReadWithoutOpeningFile "Attempting to read without opening file."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorReadingFromDVD "Error reading from DVD."
+#define MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC "No current PGC."
+#define MSGTR_LIBMPDVDNAV_Err_PassedAnInvalidAngleNumber "Passed an invalid angle number."
+// libmpdvdnav - searching.c
+#define MSGTR_LIBMPDVDNAV_Err_CannotSeekInAStillFrame "Cannot seek in a still frame."
+#define MSGTR_LIBMPDVDNAV_Err_RequestToSeekBehindEnd "Request to seek behind end."
+#define MSGTR_LIBMPDVDNAV_Err_RequestToSeekBeforeStart "Request to seek before start."
+#define MSGTR_LIBMPDVDNAV_Err_IllegalSeekMode "Illegal seek mode."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorWhenSeeking "Error when seeking."
+#define MSGTR_LIBMPDVDNAV_Err_SkipToPreviousChapterFailed "Skip to previous chapter failed."
+#define MSGTR_LIBMPDVDNAV_Err_SkipToTopChapterFailed "Skip to top chapter failed."
+#define MSGTR_LIBMPDVDNAV_Err_SkipToNextChapterFailed "Skip to next chapter failed."
+#define MSGTR_LIBMPDVDNAV_Err_NoSuchMenuOrMenuNotReachable "No such menu or menu not reachable."
+#define MSGTR_LIBMPDVDNAV_Err_NewPositionNotYetDetermined "New position not yet determined."
+// libmpdvdnav - highlight.c
+#define MSGTR_LIBMPDVDNAV_Err_BadVMState "Bad VM state."
+// libmpdvdnav - settings.c
+#define MSGTR_LIBMPDVDNAV_Err_PassedIllegalLanguageCode "Passed illegal language code."
+
+// ----------------------- libmpdvdnav -----------------------------
+// libmpdvdnav - dvdnav.c
+#define MSGTR_LIBMPDVDNAV_Using "libdvdnav: Using dvdnav version %s from http://dvd.sf.net\n"
+#define MSGTR_LIBMPDVDNAV_Demux_error "libdvdnav: demux error! %02x %02x %02x (should be 0x000001) \n"
+#define MSGTR_LIBMPDVDNAV_ErrorOpeningVtsDomain "Error opening vtsN=%i, domain=%i.\n"
+// libmpdvdnav - highlight.c
+#define MSGTR_LIBMPDVDNAV_NoCurrentPGC "No current PGC.\n"
+#define MSGTR_LIBMPDVDNAV_NotInAMenu "Not in a menu.\n"
+#define MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft "This NAV has already been left.\n"
+#define MSGTR_LIBMPDVDNAV_ButtonDoesNotExist "Button does not exist.\n"
+#define MSGTR_LIBMPDVDNAV_TitleOutOfRange "Title out of range.\n"
+#define MSGTR_LIBMPDVDNAV_PartOutOfRange "Part out of range.\n"
+#define MSGTR_LIBMPDVDNAV_NotImplementedYet "Not implemented yet.\n"
+#define MSGTR_LIBMPDVDNAV_NotInATitleOrMenu "Not in a title or menu.\n"
+// libmpdvdnav - navigation.c
+#define MSGTR_LIBMPDVDNAV_PassedANullPointer "Passed a NULL pointer.\n"
+#define MSGTR_LIBMPDVDNAV_VirtualDVDMachineNotStarted "Virtual DVD machine not started.\n"
+#define MSGTR_LIBMPDVDNAV_BadVMState "Bad VM state.\n"
+#define MSGTR_LIBMPDVDNAV_PassedATitleNumberOutOfRange "Passed a title number out of range.\n"
+// libmpdvdnav - read_cache.c
+#define MSGTR_LIBMPDVDNAV_PreCacheDVDReadReallocHappened "pre_cache DVD read realloc happened\n"
+#define MSGTR_LIBMPDVDNAV_PreCacheDVDReadMalloc "pre_cache DVD read malloc %d blocks\n"
+#define MSGTR_LIBMPDVDNAV_PreCachingWasImpossible "pre_caching was impossible, no cache chunk available\n"
+#define MSGTR_LIBMPDVDNAV_ReadCacheSectorInfo "libdvdnav: sector=%d, start_sector=%d, last_sector=%d\n"
+#define MSGTR_LIBMPDVDNAV_ReadCacheReadAheadSize "libdvdnav: read_ahead_size=%d, size=%d\n"
+#define MSGTR_LIBMPDVDNAV_CacheMissOnSector "cache miss on sector %d\n"
+// libmpdvdnav - remap.c
+#define MSGTR_LIBMPDVDNAV_UnableToFindMapFile "libdvdnav: Unable to find map file '%s'\n"
+#define MSGTR_LIBMPDVDNAV_IgnoringMapLine "libdvdnav: Ignoring map line (%d): %s\n"
+#define MSGTR_LIBMPDVDNAV_RemapInfo "libdvdnav: %s: domain %d, title %d, program %d, start %lx, next %lx\n"
+#define MSGTR_LIBMPDVDNAV_RedirectedTo "libdvdnav: Redirected to %lx\n"
+// libmpdvdnav - searching.c
+#define MSGTR_LIBMPDVDNAV_UnknownDomainForSeeking "libdvdnav: Error: Unknown domain for seeking.\n"
+#define MSGTR_LIBMPDVDNAV_CouldNotLocateBlock "libdvdnav: Could not locate block\n"
+#define MSGTR_LIBMPDVDNAV_AdmapNotLocated "libdvdnav: admap not located\n"
+#define MSGTR_LIBMPDVDNAV_ErrorWhenSeeking "libdvdnav: Error when seeking\n"
+#define MSGTR_LIBMPDVDNAV_FIXMEImplementSeekingToLocation "libdvdnav: FIXME: Implement seeking to location %u\n"
+#define MSGTR_LIBMPDVDNAV_PreviousChapterFailed "libdvdnav: previous chapter failed.\n"
+#define MSGTR_LIBMPDVDNAV_TopChapterFailed "libdvdnav: top chapter failed.\n"
+#define MSGTR_LIBMPDVDNAV_NextChapterFailed "libdvdnav: next chapter failed.\n"
+#define MSGTR_LIBMPDVDNAV_SearchChapterFailed "libdvdnav: search chapter failed.\n"
+// libmpdvdnav - decoder.c
+#define MSGTR_LIBMPDVDNAV_BadCallToVMGetbits "libdvdnav: Bad call to vm_getbits. Parameter out of range\n"
+#define MSGTR_LIBMPDVDNAV_SuspectedRCERegionProtection "libdvdnav: Suspected RCE Region Protection!!!\n"
+#define MSGTR_LIBMPDVDNAV_EvalCompareInvalidComparisonCode "libdvdnav: eval_compare: Invalid comparison code\n"
+#define MSGTR_LIBMPDVDNAV_UnknownInstrution "libdvdnav: Unknown Instruction!\n"
+#define MSGTR_LIBMPDVDNAV_WarningUnknownComman "libdvdnav: WARNING: Unknown Command=%x\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCWarningUnknownBits "libdvdnav: decoder.c: [WARNING, unknown bits:"
+#define MSGTR_LIBMPDVDNAV_DecoderCButton "libdvdnav: %s (button %d)\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCButton2 "libdvdnav: %s %d (button %d)\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCVtsTitleMenu "libdvdnav: %s vts %d title %d menu %d\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCResumeCell "libdvdnav: %s resume cell %d\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCResumeCell2 "libdvdnav: %s %d resume cell %d\n"
+// libmpdvdnav - vm.c
+#define MSGTR_LIBMPDVDNAV_VmCDVDTitle "libdvdnav: DVD Title: "
+#define MSGTR_LIBMPDVDNAV_VmCDVDSerialNumber "\nlibdvdnav: DVD Serial Number: "
+#define MSGTR_LIBMPDVDNAV_VmCDVDTitleAlternative "\nlibdvdnav: DVD Title (Alternative): "
+#define MSGTR_LIBMPDVDNAV_VmCCantReadNameBlock "libdvdnav: Can't read name block. Probably not a DVD-ROM device.\n"
+#define MSGTR_LIBMPDVDNAV_VmCCantSeekToBlock "libdvdnav: Can't seek to block %u\n"
+#define MSGTR_LIBMPDVDNAV_VmCNameOpenFailed "NAME OPEN FAILED\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoOpenVTSIFailed "libdvdnav: ifoOpenVTSI failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadVTSPTTSRPTFailed "libdvdnav: ifoRead_VTS_PTT_SRPT failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadPGCITFailed "libdvdnav: ifoRead_PGCIT failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadPGCIUTFailed "libdvdnav: ifoRead_PGCI_UT failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadVOBUADMAPVtsiFailed "libdvdnav: ifoRead_VOBU_ADMAP vtsi failed - CRASHING\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadTITLEVOBUADMAPVtsiFailed "libdvdnav: ifoRead_TITLE_VOBU_ADMAP vtsi failed - CRASHING\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmFaildToOpenReadTheDVD "libdvdnav: vm: faild to open/read the DVD\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmFaildToReadVIDEOTSIFO "libdvdnav: vm: faild to read VIDEO_TS.IFO\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadFPPGCFailed "libdvdnav: vm: ifoRead_FP_PGC failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadTTSRPTFailed "libdvdnav: vm: ifoRead_TT_SRPT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadPGCIUTFailed "libdvdnav: vm: ifoRead_PGCI_UT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadPRLMAITFailed "libdvdnav: vm: ifoRead_PTL_MAIT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadVTSATRTFailed "libdvdnav: vm: ifoRead_VTS_ATRT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadVOBUADMAPVgmiFailed "libdvdnav: vm: ifoRead_VOBU_ADMAP vgmi failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCDVDDiskReportsItselfWithRegionMask "libdvdnav: DVD disk reports itself with Region mask 0x%08x. Regions:"
+#define MSGTR_LIBMPDVDNAV_VmCChapterNotFound "libdvdnav: chapter NOT FOUND!\n"
+#define MSGTR_LIBMPDVDNAV_VmCInvalidAngleBlock "libdvdnav: Invalid angle block\n"
+#define MSGTR_LIBMPDVDNAV_VmCInvalidBlockMode "libdvdnav: Invalid? Cell block_mode (%d), block_type (%d)\n"
+#define MSGTR_LIBMPDVDNAV_VmCCellIsInBlockButDidNotEnter "libdvdnav: Cell is in block but did not enter at first cell!\n"
+#define MSGTR_LIBMPDVDNAV_VmCTryingToResumeWithoutAnyResume "libdvdnav: trying to resume without any resume info set\n"
+#define MSGTR_LIBMPDVDNAV_VmCRandomOrShuffleTitlesAreNotHandledYet "libdvdnav: RANDOM or SHUFFLE titles are NOT handled yet.\n"
+#define MSGTR_LIBMPDVDNAV_VmCGetPGCNFailed "libdvdnav: get_PGCN failed. Was trying to find pgcN in domain %d\n"
+#define MSGTR_LIBMPDVDNAV_VmCPgciUtHandleIsNULL "libdvdnav: *** pgci_ut handle is NULL ***\n"
+#define MSGTR_LIBMPDVDNAV_VmCLanguageNotFound "libdvdnav: Language '%c%c' not found, using '%c%c' instead\n"
+#define MSGTR_LIBMPDVDNAV_VmCMenuLanguagesAvailable "libdvdnav: Menu Languages available: "
diff -r 448a43f59a37 libmenu/menu.c
--- a/libmenu/menu.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmenu/menu.c	Sun Apr 30 17:14:32 2006 +0200
@@ -20,6 +20,7 @@
 #include "m_option.h"
 #include "m_struct.h"
 #include "menu.h"
+#include "libvo/video_out.h"
 
 #include "input/input.h"
 #include "input/joystick.h"
@@ -270,7 +271,7 @@ void menu_read_key(menu_t* menu,int cmd)
 
 ///////////////////////////// Helpers ////////////////////////////////////
 
-typedef void (*draw_alpha_f)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+typedef void (*draw_alpha_f)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
 
 inline static draw_alpha_f get_draw_alpha(uint32_t fmt) {
   switch(fmt) {
@@ -408,7 +409,7 @@ void menu_draw_text(mp_image_t* mpi,char
   while (*txt) {
     int c=get_next_char(&txt);
     if ((font=vo_font->font[c])>=0 && (x + vo_font->width[c] <= mpi->w) && (y + vo_font->pic_a[font]->h <= mpi->h))
-      draw_alpha(vo_font->width[c], vo_font->pic_a[font]->h,
+      draw_alpha(vo_font->width[c], vo_font->pic_a[font]->h,DEST_PLANES_Y,
 		 vo_font->pic_b[font]->bmp+vo_font->start[c],
 		 vo_font->pic_a[font]->bmp+vo_font->start[c],
 		 vo_font->pic_a[font]->w,
@@ -578,7 +579,7 @@ void menu_draw_text_full(mp_image_t* mpi
       if(font >= 0) {
  	int cs = (vo_font->pic_a[font]->h - vo_font->height) / 2;
 	if ((sx + vo_font->width[c] < xmax)  &&  (sy + vo_font->height < ymax) )
-	  draw_alpha(vo_font->width[c], vo_font->height,
+	  draw_alpha(vo_font->width[c], vo_font->height, DEST_PLANES_Y,
 		     vo_font->pic_b[font]->bmp+vo_font->start[c] +
 		     cs * vo_font->pic_a[font]->w,
 		     vo_font->pic_a[font]->bmp+vo_font->start[c] +
@@ -686,7 +687,7 @@ void menu_draw_box(mp_image_t* mpi,unsig
     char pic[stride*h],pic_alpha[stride*h];
     memset(pic,g,stride*h);
     memset(pic_alpha,alpha,stride*h);
-    draw_alpha(w,h,pic,pic_alpha,stride,
+    draw_alpha(w,h,DEST_PLANES_Y,pic,pic_alpha,stride,
                mpi->planes[0] + y * mpi->stride[0] + x * (mpi->bpp>>3),
                mpi->stride[0]);
   }
diff -r 448a43f59a37 libmpcodecs/Makefile
--- a/libmpcodecs/Makefile	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpcodecs/Makefile	Sun Apr 30 17:14:32 2006 +0200
@@ -71,6 +71,7 @@ VIDEO_SRCS_OPT=vd_divx4.c \
                vd_xvid4.c \
                vd_xvid.c \
                vd_zrmjpeg.c \
+               vd_videostill.c \
 
 ifeq ($(CONFIG_LIBAVCODEC),yes)
 VIDEO_SRCS_OPT+=vd_ffmpeg.c
diff -r 448a43f59a37 libmpcodecs/vd.c
--- a/libmpcodecs/vd.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpcodecs/vd.c	Sun Apr 30 17:14:32 2006 +0200
@@ -154,10 +154,15 @@ int mpcodecs_config_vo(sh_video_t *sh, i
         mp_msg(MSGT_DECVIDEO,MSGL_WARN, MSGTR_CodecDidNotSet);
     /* XXX: HACK, if sh->disp_* aren't set,
      * but we have w and h, set them :: atmos */
+#ifdef USE_MPDVDNAV
+    if(w) sh->disp_w=w;
+    if(h) sh->disp_h=h;
+#else
     if(!sh->disp_w && w)
         sh->disp_w=w;
     if(!sh->disp_h && h)
         sh->disp_h=h;
+#endif
 
     if(!sh->disp_w || !sh->disp_h)
 	return 0;
diff -r 448a43f59a37 libmpcodecs/vd.h
--- a/libmpcodecs/vd.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpcodecs/vd.h	Sun Apr 30 17:14:32 2006 +0200
@@ -24,6 +24,7 @@ extern int vd_use_slices;
 #define VDCTRL_SET_EQUALIZER 6 /* set color options (brightness,contrast etc) */
 #define VDCTRL_GET_EQUALIZER 7 /* get color options (brightness,contrast etc) */
 #define VDCTRL_RESYNC_STREAM 8 /* seeking */
+#define VDCTRL_RESET	9
 
 // callbacks:
 int mpcodecs_config_vo(sh_video_t *sh, int w, int h, unsigned int preferred_outfmt);
diff -r 448a43f59a37 libmpcodecs/vd_libmpeg2.c
--- a/libmpcodecs/vd_libmpeg2.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpcodecs/vd_libmpeg2.c	Sun Apr 30 17:14:32 2006 +0200
@@ -52,6 +52,9 @@ static int control(sh_video_t *sh,int cm
 	    (*((int*)arg)) == IMGFMT_422P)
 	    return CONTROL_TRUE;
 	return CONTROL_FALSE;
+    case VDCTRL_RESET:
+	mpeg2_reset(mpeg2dec,(*((int*)arg)));
+	return CONTROL_TRUE;
     }
     
     return CONTROL_UNKNOWN;
@@ -139,6 +142,9 @@ static mp_image_t* decode(sh_video_t *sh
     mpeg2dec->decoder.convert_id=NULL;
     
     if(len<=0) return NULL; // skipped null frame
+#ifdef USE_MPDVDNAV
+    sh->enable_mpeg2_reset=0;
+#endif
     
     // append extra 'end of frame' code:
     ((char*)data+len)[0]=0;
@@ -171,16 +177,39 @@ static mp_image_t* decode(sh_video_t *sh
 	    break;
 	case STATE_SEQUENCE:
 	    // video parameters inited/changed, (re)init libvo:
+#ifdef USE_MPDVDNAV
+	    sh->enable_mpeg2_reset=1;
+#endif
 	    if (info->sequence->width >> 1 == info->sequence->chroma_width &&
 		info->sequence->height >> 1 == info->sequence->chroma_height) {
+#ifdef USE_MPDVDNAV
+//printf("lock: %i w:%i (%i) h: %i (%i) fmt: %i (%i) \n",sh->config_lock,sh->config_w,info->sequence->picture_width,
+//    sh->config_h,info->sequence->picture_height,sh->config_outfmt,IMGFMT_YV12);
+		if (sh->config_lock && sh->config_w==info->sequence->picture_width &&
+		    sh->config_h ==info->sequence->picture_height && sh->config_outfmt == IMGFMT_YV12) break;
+#endif
 		if(!mpcodecs_config_vo(sh,
 				       info->sequence->picture_width,
 				       info->sequence->picture_height, IMGFMT_YV12)) return 0;
+#ifdef USE_MPDVDNAV
+		if(sh->config_lock) {sh->config_w=info->sequence->picture_width;
+		    sh->config_h=info->sequence->picture_height; sh->config_outfmt=IMGFMT_YV12;}
+#endif
 	    } else if (info->sequence->width >> 1 == info->sequence->chroma_width &&
 		info->sequence->height == info->sequence->chroma_height) {
+#ifdef USE_MPDVDNAV
+//printf("lock: %i w:%i (%i) h: %i (%i) fmt: %i (%i) \n",sh->config_lock,sh->config_w,info->sequence->picture_width,
+//    sh->config_h,info->sequence->picture_height,sh->config_outfmt,IMGFMT_422P);
+		if (sh->config_lock && sh->config_w==info->sequence->picture_width &&
+		    sh->config_h ==info->sequence->picture_height && sh->config_outfmt == IMGFMT_422P) break;
+#endif
 		if(!mpcodecs_config_vo(sh,
 				       info->sequence->picture_width,
 				       info->sequence->picture_height, IMGFMT_422P)) return 0;
+#ifdef USE_MPDVDNAV
+		if(sh->config_lock) {sh->config_w=info->sequence->picture_width;
+		    sh->config_h=info->sequence->picture_height; sh->config_outfmt=IMGFMT_422P;}
+#endif
 	    } else return 0;
 	    break;
 	case STATE_PICTURE:
diff -r 448a43f59a37 libmpcodecs/vf.c
--- a/libmpcodecs/vf.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpcodecs/vf.c	Sun Apr 30 17:14:32 2006 +0200
@@ -318,12 +318,18 @@ mp_image_t* vf_get_image(vf_instance_t* 
     if(mpi->width!=w2 || mpi->height!=h){
 //	printf("vf.c: MPI parameters changed!  %dx%d -> %dx%d   \n", mpi->width,mpi->height,w2,h);
 	if(mpi->flags&MP_IMGFLAG_ALLOCATED){
+#ifdef USE_MPDVDNAV
+		// need to re-allocate buffer memory:
+		free(mpi->planes[0]);
+		mpi->flags&=~MP_IMGFLAG_ALLOCATED;
+#else
 	    if(mpi->width<w2 || mpi->height<h){
 		// need to re-allocate buffer memory:
 		free(mpi->planes[0]);
 		mpi->flags&=~MP_IMGFLAG_ALLOCATED;
 		mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n");
 	    }
+#endif
 //	} else {
 	} {
 	    mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;
diff -r 448a43f59a37 libmpcodecs/vf_expand.c
--- a/libmpcodecs/vf_expand.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpcodecs/vf_expand.c	Sun Apr 30 17:14:32 2006 +0200
@@ -82,7 +82,7 @@ static void remove_func(int x0,int y0, i
     // TODO  clear left and right side of the image if needed
 }
 
-static void draw_func(int x0,int y0, int w,int h,unsigned char* src, unsigned char *srca, int stride){
+static void draw_func(int x0,int y0, int w,int h,int dp,unsigned char* src, unsigned char *srca, int stride){
     unsigned char* dst;
     if(!vo_osd_changed_flag && vf->dmpi->planes[0]==vf->priv->fb_ptr){
 	// ok, enough to update the area inside the video, leave the black bands
@@ -110,19 +110,19 @@ static void draw_func(int x0,int y0, int
     switch(vf->dmpi->imgfmt){
     case IMGFMT_BGR15:
     case IMGFMT_RGB15:
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR16:
     case IMGFMT_RGB16:
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR24:
     case IMGFMT_RGB24:
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR32:
     case IMGFMT_RGB32:
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_YV12:
     case IMGFMT_I420:
@@ -131,13 +131,13 @@ static void draw_func(int x0,int y0, int
     case IMGFMT_IF09:
     case IMGFMT_Y800:
     case IMGFMT_Y8:
-	vo_draw_alpha_yv12(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_yv12(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_YUY2:
-	vo_draw_alpha_yuy2(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_UYVY:
-	vo_draw_alpha_yuy2(w,h,src,srca,stride,dst+1,vf->dmpi->stride[0]);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,dst+1,vf->dmpi->stride[0]);
 	break;
     }
 }
diff -r 448a43f59a37 libmpdemux/Makefile
--- a/libmpdemux/Makefile	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/Makefile	Sun Apr 30 17:14:32 2006 +0200
@@ -23,11 +23,14 @@ SRCS += cdda.c \
         cddb.c \
         cdinfo.c \
         cue_read.c \
-        dvdnav_stream.c \
+        stream_dvdnav.c \
         parse_es.c \
         parse_mp4.c \
         yuv4mpeg.c \
         yuv4mpeg_ratio.c \
+
+#	dvdnav_stream replaced: stream_dvdnav
+#        dvdnav_stream.c \
 
 # Stream readers/writers
 SRCS += stream.c \
diff -r 448a43f59a37 libmpdemux/demux_avi.c
--- a/libmpdemux/demux_avi.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/demux_avi.c	Sun Apr 30 17:14:32 2006 +0200
@@ -898,7 +898,7 @@ static demuxer_t* demux_open_hack_avi(de
       stream_t* s;
       demuxer_t  *od;
       s = new_ds_stream(demuxer->audio);
-      od = new_demuxer(s,DEMUXER_TYPE_OGG,-1,-2,-2,NULL);
+      od = new_demuxer(s,DEMUXER_TYPE_OGG,-1,-2,-2,NULL,0);
       if(!demux_ogg_open(od)) {
         mp_msg( MSGT_DEMUXER,MSGL_ERR,MSGTR_ErrorOpeningOGGDemuxer);
         free_stream(s);
diff -r 448a43f59a37 libmpdemux/demux_mpg.c
--- a/libmpdemux/demux_mpg.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/demux_mpg.c	Sun Apr 30 17:14:32 2006 +0200
@@ -754,6 +754,7 @@ void demux_seek_mpg(demuxer_t *demuxer,f
 	  int i;
           if(sh_audio && !d_audio->eof && d_video->pts && d_audio->pts){
 	    float a_pts=d_audio->pts;
+	  if((float)sh_audio->i_bps==0.0f) break;
             a_pts+=(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
 	    if(d_video->pts>a_pts){
 	      skip_audio_frame(sh_audio);  // sync audio
@@ -860,6 +861,24 @@ int demux_mpg_control(demuxer_t *demuxer
             *((int*)arg) = demuxer->audio->id;
             return DEMUXER_CTRL_OK;
 
+	case DEMUXER_CTRL_SET_TIME_PTS: {
+	      if (demuxer->movi_end==0)
+		{
+		mpg_d->final_pts = 0.0;
+		mpg_d->has_valid_timestamps = 0;
+		return DEMUXER_CTRL_OK;
+		}
+              mpg_d->final_pts=*((float *)arg);
+	      if (mpg_d->final_pts==0.0)
+		{
+		mpg_d->final_pts = 0.0;
+		mpg_d->has_valid_timestamps = 0;
+		return DEMUXER_CTRL_OK;
+		}
+	      mpg_d->has_valid_timestamps = 1;
+	      return DEMUXER_CTRL_OK;
+	      }
+
 	default:
 	    return DEMUXER_CTRL_NOTIMPL;
     }
diff -r 448a43f59a37 libmpdemux/demux_ogg.c
--- a/libmpdemux/demux_ogg.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/demux_ogg.c	Sun Apr 30 17:14:32 2006 +0200
@@ -1378,7 +1378,7 @@ demuxer_t* init_avi_with_ogg(demuxer_t* 
 
   // Create the ds_stream and the ogg demuxer
   s = new_ds_stream(demuxer->audio);
-  od = new_demuxer(s,DEMUXER_TYPE_OGG,0,-2,-2,NULL);
+  od = new_demuxer(s,DEMUXER_TYPE_OGG,0,-2,-2,NULL,0);
 
   /// Add the header packets in the ogg demuxer audio stream
   // Initial header
diff -r 448a43f59a37 libmpdemux/demux_rtp.cpp
--- a/libmpdemux/demux_rtp.cpp	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/demux_rtp.cpp	Sun Apr 30 17:14:32 2006 +0200
@@ -241,7 +241,7 @@ extern "C" demuxer_t* demux_open_rtp(dem
   if (demux_is_multiplexed_rtp_stream(demuxer)) {
     stream_t* s = new_ds_stream(demuxer->video);
     demuxer_t* od = demux_open(s, DEMUXER_TYPE_UNKNOWN,
-			       audio_id, video_id, dvdsub_id, NULL);
+			       audio_id, video_id, dvdsub_id, NULL, 0);
     demuxer = new_demuxers_demuxer(od, od, od);
   }
 
diff -r 448a43f59a37 libmpdemux/demuxer.c
--- a/libmpdemux/demuxer.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/demuxer.c	Sun Apr 30 17:14:32 2006 +0200
@@ -16,6 +16,9 @@
 #include "libvo/fastmemcpy.h"
 
 #include "stream.h"
+#ifdef USE_MPDVDNAV
+#include "stream_dvdnav.h"
+#endif
 #include "demuxer.h"
 #include "stheader.h"
 #include "mf.h"
@@ -147,7 +150,7 @@ demux_stream_t* new_demuxer_stream(struc
   ds->pos=0;
   ds->dpos=0;
   ds->pack_no=0;
-//---------------
+//----------------
   ds->packs=0;
   ds->bytes=0;
   ds->first=ds->last=ds->current=NULL;
@@ -182,7 +185,7 @@ static demuxer_desc_t* get_demuxer_desc_
 }
 
 
-demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename){
+demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename,int hideerrmess){
   demuxer_t *d=malloc(sizeof(demuxer_t));
   memset(d,0,sizeof(demuxer_t));
   d->stream=stream;
@@ -195,6 +198,7 @@ demuxer_t* new_demuxer(stream_t *stream,
   d->video=new_demuxer_stream(d,v_id);
   d->sub=new_demuxer_stream(d,s_id);
   d->type=type;
+  d->hide_packs_err_mess=hideerrmess;
   if(type)
     if (!(d->desc = get_demuxer_desc_from_type(type)))
       mp_msg(MSGT_DEMUXER,MSGL_ERR,"BUG! Invalid demuxer type in new_demuxer(), big troubles ahead.");
@@ -253,6 +257,13 @@ sh_video_t* new_sh_video(demuxer_t *demu
         if (!demux_aid_vid_mismatch)
           mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_VIDEO_ID=%d\n", id);
     }
+#ifdef USE_MPDVDNAV
+  ((sh_video_t*)demuxer->v_streams[id])->config_lock=0;
+  ((sh_video_t*)demuxer->v_streams[id])->config_w=0;
+  ((sh_video_t*)demuxer->v_streams[id])->config_h=0;
+  ((sh_video_t*)demuxer->v_streams[id])->config_outfmt=0;
+  ((sh_video_t*)demuxer->v_streams[id])->enable_mpeg2_reset=0;
+#endif
     return demuxer->v_streams[id];
 }
 
@@ -372,13 +383,15 @@ int ds_fill_buffer(demux_stream_t *ds){
       return 1; //ds->buffer_size;
     }
     if(demux->audio->packs>=MAX_PACKS || demux->audio->bytes>=MAX_PACK_BYTES){
+      if (!(demux->hide_packs_err_mess)) {
       mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_TooManyAudioInBuffer,demux->audio->packs,demux->audio->bytes);
-      mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI);
+        mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI); }
       break;
     }
     if(demux->video->packs>=MAX_PACKS || demux->video->bytes>=MAX_PACK_BYTES){
+      if (!(demux->hide_packs_err_mess)) {
       mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_TooManyVideoInBuffer,demux->video->packs,demux->video->bytes);
-      mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI);
+        mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI);}
       break;
     }
     if(!demux_fill_buffer(demux,ds)){
@@ -641,7 +654,7 @@ int extension_parsing=1; // 0=off 1=mixe
 
 static demuxer_t* demux_open_stream(stream_t *stream, int file_format,
                     int force, int audio_id, int video_id, int dvdsub_id,
-                    char* filename) {
+                    char* filename,int hideerrmess) {
 
 //int file_format=(*file_format_ptr);
 
@@ -658,7 +671,7 @@ int i;
 // If somebody requested a demuxer check it
 if (file_format) {
   if ((demuxer_desc = get_demuxer_desc_from_type(file_format))) {
-    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename);
+    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename, hideerrmess);
     if (demuxer_desc->check_file) {
       fformat = demuxer_desc->check_file(demuxer);
       if (force)
@@ -672,7 +685,7 @@ if (file_format) {
           // Format changed after check, recurse
           free_demuxer(demuxer);
           return demux_open_stream(stream, fformat, force,
-                   audio_id, video_id, dvdsub_id, filename);
+                   audio_id, video_id, dvdsub_id, filename, hideerrmess);
         }
       } else {
         // Check failed for forced demuxer, quit
@@ -689,7 +702,7 @@ if (demuxer)
 // Test demuxers with safe file checks
 for (i = 0; (demuxer_desc = demuxer_list[i]); i++) {
   if (demuxer_desc->safe_check) {
-    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename);
+    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename, hideerrmess);
     if ((fformat = demuxer_desc->check_file(demuxer)) != 0) {
       if (fformat == demuxer_desc->type) {
         mp_msg(MSGT_DEMUXER, MSGL_INFO, MSGTR_Detected_XXX_FileFormat, demuxer_desc->shortdesc);
@@ -701,7 +714,7 @@ for (i = 0; (demuxer_desc = demuxer_list
         // Format changed after check, recurse
         free_demuxer(demuxer);
         demuxer=demux_open_stream(stream, fformat, force,
-                  audio_id, video_id, dvdsub_id, filename);
+                  audio_id, video_id, dvdsub_id, filename, hideerrmess);
         if(demuxer) return demuxer; // done!
         file_format = DEMUXER_TYPE_UNKNOWN;
       }
@@ -724,7 +737,7 @@ if(file_format==DEMUXER_TYPE_UNKNOWN && 
   if(file_format!=DEMUXER_TYPE_UNKNOWN){
     // we like recursion :)
     demuxer=demux_open_stream(stream, file_format, force,
-              audio_id, video_id, dvdsub_id, filename);
+              audio_id, video_id, dvdsub_id, filename, hideerrmess);
     if(demuxer) return demuxer; // done!
     file_format=DEMUXER_TYPE_UNKNOWN; // continue fuzzy guessing...
     mp_msg(MSGT_DEMUXER,MSGL_V,"demuxer: continue fuzzy content-based format guessing...\n");
@@ -734,7 +747,7 @@ if(file_format==DEMUXER_TYPE_UNKNOWN && 
 // Try detection for all other demuxers
 for (i = 0; (demuxer_desc = demuxer_list[i]); i++) {
   if (!demuxer_desc->safe_check && demuxer_desc->check_file) {
-    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename);
+    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename, hideerrmess);
     if ((fformat = demuxer_desc->check_file(demuxer)) != 0) {
       if (fformat == demuxer_desc->type) {
         mp_msg(MSGT_DEMUXER, MSGL_INFO, MSGTR_Detected_XXX_FileFormat, demuxer_desc->shortdesc);
@@ -746,7 +759,7 @@ for (i = 0; (demuxer_desc = demuxer_list
         // Format changed after check, recurse
         free_demuxer(demuxer);
         demuxer=demux_open_stream(stream, fformat, force,
-                  audio_id, video_id, dvdsub_id, filename);
+                  audio_id, video_id, dvdsub_id, filename, hideerrmess);
         if(demuxer) return demuxer; // done!
         file_format = DEMUXER_TYPE_UNKNOWN;
       }
@@ -799,7 +812,7 @@ extern float stream_cache_min_percent;
 extern float stream_cache_min_percent;
 extern float stream_cache_seek_min_percent;
 
-demuxer_t* demux_open(stream_t *vs,int file_format,int audio_id,int video_id,int dvdsub_id,char* filename){
+demuxer_t* demux_open(stream_t *vs,int file_format,int audio_id,int video_id,int dvdsub_id,char* filename,int hideerrmess){
   stream_t *as = NULL,*ss = NULL;
   demuxer_t *vd,*ad = NULL,*sd = NULL;
   int afmt =DEMUXER_TYPE_UNKNOWN,sfmt = DEMUXER_TYPE_UNKNOWN ;
@@ -844,7 +857,7 @@ demuxer_t* demux_open(stream_t *vs,int f
 
   vd = demux_open_stream(vs, demuxer_type ? demuxer_type : file_format,
          demuxer_force, audio_stream ? -2 : audio_id, video_id,
-         sub_stream ? -2 : dvdsub_id, filename);
+         sub_stream ? -2 : dvdsub_id, filename, hideerrmess);
   if(!vd) {
     if(as) free_stream(as);
     if(ss) free_stream(ss);
@@ -852,7 +865,7 @@ demuxer_t* demux_open(stream_t *vs,int f
   }
   if(as) {
     ad = demux_open_stream(as, audio_demuxer_type ? audio_demuxer_type : afmt,
-           audio_demuxer_force, audio_id, -2, -2, audio_stream);
+           audio_demuxer_force, audio_id, -2, -2, audio_stream, hideerrmess);
     if(!ad) {
       mp_msg(MSGT_DEMUXER,MSGL_WARN,MSGTR_OpeningAudioDemuxerFailed,audio_stream);
       free_stream(as);
@@ -862,7 +875,7 @@ demuxer_t* demux_open(stream_t *vs,int f
   }
   if(ss) {
     sd = demux_open_stream(ss, sub_demuxer_type ? sub_demuxer_type : sfmt,
-           sub_demuxer_force, -2, -2, dvdsub_id, sub_stream);
+           sub_demuxer_force, -2, -2, dvdsub_id, sub_stream, hideerrmess);
     if(!sd) {
       mp_msg(MSGT_DEMUXER,MSGL_WARN,MSGTR_OpeningSubtitlesDemuxerFailed,sub_stream);
       free_stream(ss);
@@ -978,6 +991,11 @@ char* demux_info_get(demuxer_t *demuxer,
 
 int demux_control(demuxer_t *demuxer, int cmd, void *arg) {
 
+    switch (cmd) {
+      case DEMUXER_CTRL_SETHIDEPACKSERR:
+        demuxer->hide_packs_err_mess=*((int*)arg);
+        return DEMUXER_CTRL_OK;
+      }
     if (demuxer->desc->control)
       return demuxer->desc->control(demuxer,cmd,arg);
 
@@ -1023,3 +1041,16 @@ int demuxer_switch_audio(demuxer_t *demu
       index = demuxer->audio->id;
     return index;
 }
+
+void demuxer_set_hidemess(demuxer_t *demuxer, int hideflg)
+{
+    demux_control(demuxer, DEMUXER_CTRL_SETHIDEPACKSERR,(void *)&hideflg);
+    return;
+}
+
+void demuxer_update_time_pts(demuxer_t *demuxer, float final_pts, off_t endpos) {
+demuxer->stream->start_pos=0;
+demuxer->stream->end_pos=endpos;
+demuxer->movi_end=endpos;
+demux_control(demuxer, DEMUXER_CTRL_SET_TIME_PTS,(void *)&final_pts);
+}
diff -r 448a43f59a37 libmpdemux/demuxer.h
--- a/libmpdemux/demuxer.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/demuxer.h	Sun Apr 30 17:14:32 2006 +0200
@@ -73,6 +73,9 @@
 #define DEMUXER_CTRL_GET_PERCENT_POS 11
 #define DEMUXER_CTRL_SWITCH_AUDIO 12
 
+#define DEMUXER_CTRL_SETHIDEPACKSERR 13
+#define DEMUXER_CTRL_SET_TIME_PTS 14
+
 // Holds one packet/frame/whatever
 typedef struct demux_packet_st {
   int len;
@@ -168,6 +171,13 @@ typedef struct demuxer_st {
   demux_stream_t *audio; // audio buffer/demuxer
   demux_stream_t *video; // video buffer/demuxer
   demux_stream_t *sub;   // dvd subtitle buffer/demuxer
+// --------------
+  int max_video_packs;
+  int max_video_bytes;
+  int max_audio_packs;
+  int max_audio_bytes;
+  int hide_packs_err_mess;
+// --------------
 
   // stream headers:
   void* a_streams[MAX_A_STREAMS]; // audio streams (sh_audio_t)
@@ -239,7 +249,7 @@ inline static void free_demux_packet(dem
 }
 
 demux_stream_t* new_demuxer_stream(struct demuxer_st *demuxer,int id);
-demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename);
+demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename,int hideerrmess);
 void free_demuxer_stream(demux_stream_t *ds);
 void free_demuxer(demuxer_t *demuxer);
 
@@ -303,7 +313,7 @@ static inline int avi_stream_id(unsigned
   return a*10+b;
 }
 
-demuxer_t* demux_open(stream_t *stream,int file_format,int aid,int vid,int sid,char* filename);
+demuxer_t* demux_open(stream_t *stream,int file_format,int aid,int vid,int sid,char* filename,int hideerrmess);
 int demux_seek(demuxer_t *demuxer,float rel_seek_secs,float audio_delay,int flags);
 demuxer_t*  new_demuxers_demuxer(demuxer_t* vd, demuxer_t* ad, demuxer_t* sd);
 
@@ -345,3 +355,7 @@ extern int demuxer_type_by_filename(char
 
 extern void demuxer_help(void);
 extern int get_demuxer_type_from_name(char *demuxer_name, int *force);
+
+void demuxer_set_hidemess(demuxer_t *demuxer, int hideflg);
+
+void demuxer_update_time_pts(demuxer_t *demuxer, float final_pts, off_t endpos);
diff -r 448a43f59a37 libmpdemux/stheader.h
--- a/libmpdemux/stheader.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/stheader.h	Sun Apr 30 17:14:32 2006 +0200
@@ -84,6 +84,13 @@ typedef struct {
   void* ImageDesc; // for quicktime codecs
   // codec-specific:
   void* context;   // codec-specific stuff (usually HANDLE or struct pointer)
+#ifdef USE_MPDVDNAV
+  int config_lock;
+  int config_w;
+  int config_h;
+  unsigned int config_outfmt;
+  int enable_mpeg2_reset;
+#endif
 } sh_video_t;
 
 // demuxer.c:
diff -r 448a43f59a37 libmpdemux/stream.c
--- a/libmpdemux/stream.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/stream.c	Sun Apr 30 17:14:32 2006 +0200
@@ -115,7 +115,7 @@ stream_info_t* auto_open_streams[] = {
   &stream_info_dvd,
 #endif
 #ifdef USE_DVDNAV
-  &stream_info_dvdnav;
+  &stream_info_dvdnav,
 #endif
 
   &stream_info_null,
diff -r 448a43f59a37 libmpdemux/stream.h
--- a/libmpdemux/stream.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/stream.h	Sun Apr 30 17:14:32 2006 +0200
@@ -292,19 +292,25 @@ extern int dvd_angle;
 extern int dvd_angle;
 //#endif
 
+extern int dvbin_param_on;
+
 extern char * audio_stream;
 
-#ifdef USE_DVDNAV
-#include "dvdnav_stream.h"
-#endif
 
 #ifdef USE_DVDREAD
 
 #ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
 #include "libmpdvdkit2/dvd_reader.h"
 #include "libmpdvdkit2/ifo_types.h"
 #include "libmpdvdkit2/ifo_read.h"
 #include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
 #else
 #include <dvdread/dvd_reader.h>
 #include <dvdread/ifo_types.h>
@@ -351,6 +357,10 @@ int dvd_sid_from_lang(stream_t *stream, 
 int dvd_sid_from_lang(stream_t *stream, unsigned char* lang);
 int dvd_chapter_from_cell(dvd_priv_t *dvd,int title,int cell);
 
+//#ifdef USE_MPDVDNAV
+//#include "stream_dvdnav.h"
+//#endif
+
 #endif
 							    
 #endif // __STREAM_H
diff -r 448a43f59a37 libmpdemux/test.c
--- a/libmpdemux/test.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libmpdemux/test.c	Sun Apr 30 17:14:32 2006 +0200
@@ -69,7 +69,7 @@ int file_format=DEMUXER_TYPE_UNKNOWN;
   if(stream_cache_size)
       stream_enable_cache(stream,stream_cache_size,0,0);
 
-  demuxer=demux_open(stream,file_format,-1,-1,-1,NULL);
+  demuxer=demux_open(stream,file_format,-1,-1,-1,NULL,0);
   if(!demuxer){
 	printf("Cannot open demuxer\n");
 	exit(1);
diff -r 448a43f59a37 libvo/mga_common.c
--- a/libvo/mga_common.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/mga_common.c	Sun Apr 30 17:14:32 2006 +0200
@@ -28,20 +28,20 @@ static uint32_t               drwBorderW
 #endif
 static uint32_t               drwcX,drwcY,dwidth,dheight;
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     uint32_t bespitch = (mga_vid_config.src_width + 31) & ~31;
     x0+=mga_vid_config.src_width*(vo_panscan_x>>1)/(vo_dwidth+vo_panscan_x);
     switch(mga_vid_config.format){
     case MGA_VID_FORMAT_YV12:
     case MGA_VID_FORMAT_IYUV:
     case MGA_VID_FORMAT_I420:
-        vo_draw_alpha_yv12(w,h,src,srca,stride,vid_data+bespitch*y0+x0,bespitch);
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,vid_data+bespitch*y0+x0,bespitch);
         break;
     case MGA_VID_FORMAT_YUY2:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,vid_data+2*(bespitch*y0+x0),2*bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,vid_data+2*(bespitch*y0+x0),2*bespitch);
         break;
     case MGA_VID_FORMAT_UYVY:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,vid_data+2*(bespitch*y0+x0)+1,2*bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,vid_data+2*(bespitch*y0+x0)+1,2*bespitch);
         break;
     }
 }
diff -r 448a43f59a37 libvo/osd.c
--- a/libvo/osd.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/osd.c	Sun Apr 30 17:14:32 2006 +0200
@@ -11,6 +11,7 @@
 #include <inttypes.h>
 #include "cpudetect.h"
 #include "mangle.h"
+#include "video_out.h"
 
 #if defined(ARCH_X86) || defined(ARCH_X86_64)
 #define CAN_COMPILE_X86_ASM
@@ -101,152 +102,152 @@ static const unsigned long long mask24hl
 
 #endif //CAN_COMPILE_X86_ASM
 
-void vo_draw_alpha_yv12(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
-#ifdef RUNTIME_CPUDETECT
-#ifdef CAN_COMPILE_X86_ASM
-	// ordered by speed / fastest first
-	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_yv12_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_yv12_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_yv12_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-	else
-		vo_draw_alpha_yv12_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_yv12_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#else //RUNTIME_CPUDETECT
-#ifdef HAVE_MMX2
-		vo_draw_alpha_yv12_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_3DNOW)
-		vo_draw_alpha_yv12_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_MMX)
-		vo_draw_alpha_yv12_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_yv12_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_yv12_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#endif //!RUNTIME_CPUDETECT
-}
-
-void vo_draw_alpha_yuy2(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
-#ifdef RUNTIME_CPUDETECT
-#ifdef CAN_COMPILE_X86_ASM
-	// ordered by speed / fastest first
-	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_yuy2_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_yuy2_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_yuy2_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-	else
-		vo_draw_alpha_yuy2_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_yuy2_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#else //RUNTIME_CPUDETECT
-#ifdef HAVE_MMX2
-		vo_draw_alpha_yuy2_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_3DNOW)
-		vo_draw_alpha_yuy2_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_MMX)
-		vo_draw_alpha_yuy2_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_yuy2_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_yuy2_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#endif //!RUNTIME_CPUDETECT
-}
-
-void vo_draw_alpha_uyvy(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
-#ifdef RUNTIME_CPUDETECT
-#ifdef CAN_COMPILE_X86_ASM
-	// ordered by speed / fastest first
-	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_uyvy_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_uyvy_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_uyvy_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-	else
-		vo_draw_alpha_uyvy_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_uyvy_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#else //RUNTIME_CPUDETECT
-#ifdef HAVE_MMX2
-		vo_draw_alpha_uyvy_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_3DNOW)
-		vo_draw_alpha_uyvy_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_MMX)
-		vo_draw_alpha_uyvy_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_uyvy_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_uyvy_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#endif //!RUNTIME_CPUDETECT
-}
-
-void vo_draw_alpha_rgb24(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
-#ifdef RUNTIME_CPUDETECT
-#ifdef CAN_COMPILE_X86_ASM
-	// ordered by speed / fastest first
-	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_rgb24_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_rgb24_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_rgb24_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-	else
-		vo_draw_alpha_rgb24_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_rgb24_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#else //RUNTIME_CPUDETECT
-#ifdef HAVE_MMX2
-		vo_draw_alpha_rgb24_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_3DNOW)
-		vo_draw_alpha_rgb24_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_MMX)
-		vo_draw_alpha_rgb24_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_rgb24_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_rgb24_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#endif //!RUNTIME_CPUDETECT
-}
-
-void vo_draw_alpha_rgb32(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
-#ifdef RUNTIME_CPUDETECT
-#ifdef CAN_COMPILE_X86_ASM
-	// ordered by speed / fastest first
-	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_rgb32_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_rgb32_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_rgb32_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-	else
-		vo_draw_alpha_rgb32_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_rgb32_C(w, h, src, srca, srcstride, dstbase, dststride);
-#endif
-#else //RUNTIME_CPUDETECT
-#ifdef HAVE_MMX2
-		vo_draw_alpha_rgb32_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_3DNOW)
-		vo_draw_alpha_rgb32_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined (HAVE_MMX)
-		vo_draw_alpha_rgb32_MMX(w, h, src, srca, srcstride, dstbase, dststride);
-#elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_rgb32_X86(w, h, src, srca, srcstride, dstbase, dststride);
-#else
-		vo_draw_alpha_rgb32_C(w, h, src, srca, srcstride, dstbase, dststride);
+void vo_draw_alpha_yv12(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+#ifdef RUNTIME_CPUDETECT
+#ifdef CAN_COMPILE_X86_ASM
+	// ordered by speed / fastest first
+	if(gCpuCaps.hasMMX2)
+		vo_draw_alpha_yv12_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.has3DNow)
+		vo_draw_alpha_yv12_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.hasMMX)
+		vo_draw_alpha_yv12_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else
+		vo_draw_alpha_yv12_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_yv12_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#else //RUNTIME_CPUDETECT
+#ifdef HAVE_MMX2
+		vo_draw_alpha_yv12_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_3DNOW)
+		vo_draw_alpha_yv12_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_MMX)
+		vo_draw_alpha_yv12_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined(ARCH_X86) || defined(ARCH_X86_64)
+		vo_draw_alpha_yv12_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_yv12_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#endif //!RUNTIME_CPUDETECT
+}
+
+void vo_draw_alpha_yuy2(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+#ifdef RUNTIME_CPUDETECT
+#ifdef CAN_COMPILE_X86_ASM
+	// ordered by speed / fastest first
+	if(gCpuCaps.hasMMX2)
+		vo_draw_alpha_yuy2_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.has3DNow)
+		vo_draw_alpha_yuy2_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.hasMMX)
+		vo_draw_alpha_yuy2_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else
+		vo_draw_alpha_yuy2_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_yuy2_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#else //RUNTIME_CPUDETECT
+#ifdef HAVE_MMX2
+		vo_draw_alpha_yuy2_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_3DNOW)
+		vo_draw_alpha_yuy2_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_MMX)
+		vo_draw_alpha_yuy2_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined(ARCH_X86) || defined(ARCH_X86_64)
+		vo_draw_alpha_yuy2_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_yuy2_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#endif //!RUNTIME_CPUDETECT
+}
+
+void vo_draw_alpha_uyvy(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+#ifdef RUNTIME_CPUDETECT
+#ifdef CAN_COMPILE_X86_ASM
+	// ordered by speed / fastest first
+	if(gCpuCaps.hasMMX2)
+		vo_draw_alpha_uyvy_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.has3DNow)
+		vo_draw_alpha_uyvy_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.hasMMX)
+		vo_draw_alpha_uyvy_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else
+		vo_draw_alpha_uyvy_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_uyvy_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#else //RUNTIME_CPUDETECT
+#ifdef HAVE_MMX2
+		vo_draw_alpha_uyvy_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_3DNOW)
+		vo_draw_alpha_uyvy_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_MMX)
+		vo_draw_alpha_uyvy_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined(ARCH_X86) || defined(ARCH_X86_64)
+		vo_draw_alpha_uyvy_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_uyvy_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#endif //!RUNTIME_CPUDETECT
+}
+
+void vo_draw_alpha_rgb24(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+#ifdef RUNTIME_CPUDETECT
+#ifdef CAN_COMPILE_X86_ASM
+	// ordered by speed / fastest first
+	if(gCpuCaps.hasMMX2)
+		vo_draw_alpha_rgb24_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.has3DNow)
+		vo_draw_alpha_rgb24_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.hasMMX)
+		vo_draw_alpha_rgb24_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else
+		vo_draw_alpha_rgb24_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_rgb24_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#else //RUNTIME_CPUDETECT
+#ifdef HAVE_MMX2
+		vo_draw_alpha_rgb24_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_3DNOW)
+		vo_draw_alpha_rgb24_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_MMX)
+		vo_draw_alpha_rgb24_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined(ARCH_X86) || defined(ARCH_X86_64)
+		vo_draw_alpha_rgb24_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_rgb24_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#endif //!RUNTIME_CPUDETECT
+}
+
+void vo_draw_alpha_rgb32(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+#ifdef RUNTIME_CPUDETECT
+#ifdef CAN_COMPILE_X86_ASM
+	// ordered by speed / fastest first
+	if(gCpuCaps.hasMMX2)
+		vo_draw_alpha_rgb32_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.has3DNow)
+		vo_draw_alpha_rgb32_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else if(gCpuCaps.hasMMX)
+		vo_draw_alpha_rgb32_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+	else
+		vo_draw_alpha_rgb32_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_rgb32_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#endif
+#else //RUNTIME_CPUDETECT
+#ifdef HAVE_MMX2
+		vo_draw_alpha_rgb32_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_3DNOW)
+		vo_draw_alpha_rgb32_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined (HAVE_MMX)
+		vo_draw_alpha_rgb32_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#elif defined(ARCH_X86) || defined(ARCH_X86_64)
+		vo_draw_alpha_rgb32_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
+#else
+		vo_draw_alpha_rgb32_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!RUNTIME_CPUDETECT
 }
@@ -297,8 +298,10 @@ void vo_draw_alpha_init(void){
 	}
 }
 
-void vo_draw_alpha_rgb15(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb15(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y :
     for(y=0;y<h;y++){
         register unsigned short *dst = (unsigned short*) dstbase;
         register int x;
@@ -327,10 +330,67 @@ void vo_draw_alpha_rgb15(int w,int h, un
         dstbase+=dststride;
     }
     return;
-}
-
-void vo_draw_alpha_rgb16(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+  case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                r=(((r*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                g=(((g*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                b=(((b*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  }
+}
+
+void vo_draw_alpha_rgb16(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y :
     for(y=0;y<h;y++){
         register unsigned short *dst = (unsigned short*) dstbase;
         register int x;
@@ -358,5 +418,60 @@ void vo_draw_alpha_rgb16(int w,int h, un
         dstbase+=dststride;
     }
     return;
-}
-
+  case DEST_PLANES_RB :
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                r=(((r*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G :
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                g=(((g*srca[x])>>6)+src[x])>>2;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR :
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                b=(((b*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  }
+}
+
diff -r 448a43f59a37 libvo/osd.h
--- a/libvo/osd.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/osd.h	Sun Apr 30 17:14:32 2006 +0200
@@ -7,13 +7,13 @@
 
 extern void vo_draw_alpha_init(void); // build tables
 
-extern void vo_draw_alpha_yv12(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_yuy2(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_uyvy(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb24(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb32(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb15(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb16(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_yv12(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_yuy2(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_uyvy(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb24(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb32(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb15(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb16(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
 
 #endif
 
diff -r 448a43f59a37 libvo/osd_template.c
--- a/libvo/osd_template.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/osd_template.c	Sun Apr 30 17:14:32 2006 +0200
@@ -27,7 +27,7 @@
 #define EMMS     "emms"
 #endif
 
-static inline void RENAME(vo_draw_alpha_yv12)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_yv12)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #if defined(FAST_OSD) && !defined(HAVE_MMX)
     w=w>>1;
@@ -93,7 +93,7 @@ static inline void RENAME(vo_draw_alpha_
     return;
 }
 
-static inline void RENAME(vo_draw_alpha_yuy2)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_yuy2)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #if defined(FAST_OSD) && !defined(HAVE_MMX)
     w=w>>1;
@@ -160,7 +160,7 @@ static inline void RENAME(vo_draw_alpha_
     return;
 }
 
-static inline void RENAME(vo_draw_alpha_uyvy)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_uyvy)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
   int y;
 #if defined(FAST_OSD)
   w=w>>1;
@@ -184,8 +184,11 @@ static inline void RENAME(vo_draw_alpha_
   }
 }
 
-static inline void RENAME(vo_draw_alpha_rgb24)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_rgb24)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+
+switch (dp) {
+ case DEST_PLANES_Y:
     for(y=0;y<h;y++){
         register unsigned char *dst = dstbase;
         register int x;
@@ -286,13 +289,61 @@ static inline void RENAME(vo_draw_alpha_
 	asm volatile(EMMS:::"memory");
 #endif
     return;
+ case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register unsigned char *dst = dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dst[0]=((dst[0]*srca[x])>>8)+src[x];
+            }
+            dst+=3; // 24bpp
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register unsigned char *dst = dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dst[1]=((dst[1]*srca[x])>>8)+src[x];
+            }
+            dst+=3; // 24bpp
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register unsigned char *dst = dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dst[2]=((dst[2]*srca[x])>>8)+src[x];
+            }
+            dst+=3; // 24bpp
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ }
 }
 
-static inline void RENAME(vo_draw_alpha_rgb32)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_rgb32)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #ifdef WORDS_BIGENDIAN
     dstbase++;
 #endif
+switch (dp) {
+ case DEST_PLANES_Y:
     for(y=0;y<h;y++){
         register int x;
 #if defined(ARCH_X86) || defined(ARCH_X86_64)
@@ -442,4 +493,44 @@ static inline void RENAME(vo_draw_alpha_
 	asm volatile(EMMS:::"memory");
 #endif
     return;
+ case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dstbase[4*x+0]=(((dstbase[4*x+0]*srca[x])>>8)+src[x])&0xff;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dstbase[4*x+1]=(((dstbase[4*x+1]*srca[x])>>8)+src[x])&0xff;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dstbase[4*x+2]=(((dstbase[4*x+2]*srca[x])>>8)+src[x])&0xff;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ }
 }
diff -r 448a43f59a37 libvo/sub.c
--- a/libvo/sub.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/sub.c	Sun Apr 30 17:14:32 2006 +0200
@@ -69,6 +69,16 @@ int sub_bg_color=0; /* subtitles backgro
 int sub_bg_color=0; /* subtitles background color */
 int sub_bg_alpha=0;
 int sub_justify=0;
+#ifdef USE_MPDVDNAV
+uint16_t  dvdnav_sx=0;
+uint16_t  dvdnav_ex=0;
+uint16_t  dvdnav_sy=0;
+uint16_t  dvdnav_ey=0;
+int	  dvdnav_show=0;
+unsigned char dvdnav_image=0x7f;
+unsigned char dvdnav_alpha=0x7f;
+
+#endif
 
 // return the real height of a char:
 static inline int get_height(int c,int h){
@@ -131,11 +141,12 @@ static void alloc_buf(mp_osd_obj_t* obj)
 }
 
 // renders the buffer
-inline static void vo_draw_text_from_buffer(mp_osd_obj_t* obj,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+inline static void vo_draw_text_from_buffer(mp_osd_obj_t* obj,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
     if (obj->allocated > 0) {
 	draw_alpha(obj->bbox.x1,obj->bbox.y1,
 		   obj->bbox.x2-obj->bbox.x1,
 		   obj->bbox.y2-obj->bbox.y1,
+		   DEST_PLANES_Y,
 		   obj->bitmap_buffer,
 		   obj->alpha_buffer,
 		   obj->stride);
@@ -178,6 +189,52 @@ inline static void vo_update_text_osd(mp
           x+=vo_font->width[c]+vo_font->charspace;
         }
 }
+
+#ifdef USE_DVDNAV
+#ifdef USE_MPDVDNAV
+#undef max
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#undef min
+#define min(x,y) ((x) < (y) ? (x) : (y))
+
+void dvdnav_box_area(int sx, int sy, int ex, int ey, int show, unsigned char image, unsigned char alpha)
+{
+  dvdnav_sx=min(sx,ex);
+  dvdnav_ex=max(sx,ex);
+  dvdnav_sy=min(sy,ey);
+  dvdnav_ey=max(sy,ey);
+  dvdnav_show=show;
+  dvdnav_image=image;
+  dvdnav_alpha=alpha;
+}
+
+
+inline static void vo_update_dvdnav(mp_osd_obj_t* obj,int dxs,int dys){
+
+unsigned char * bitmap_buffer;
+unsigned char * alpha_buffer;
+int len;
+int stride;
+
+if (dvdnav_show)
+    {
+    obj->bbox.x1=obj->x=dvdnav_sx;
+    obj->bbox.y1=obj->y=dvdnav_sy;
+    obj->bbox.x2=dvdnav_ex;
+    obj->bbox.y2=dvdnav_ey;
+    alloc_buf(obj);
+    len = obj->stride*(obj->bbox.y2-obj->bbox.y1);
+//printf("dvdnav box image: %x alpha: %x \n",dvdnav_image,dvdnav_alpha);
+    memset(obj->bitmap_buffer,dvdnav_image,len);
+    memset(obj->alpha_buffer,dvdnav_alpha,len);
+    obj->flags|=OSDFLAG_BBOX|OSDFLAG_VISIBLE|OSDFLAG_CHANGED;
+    }
+    else
+    obj->flags&=~OSDFLAG_VISIBLE;
+}
+
+#endif
+#endif
 
 int vo_osd_progbar_type=-1;
 int vo_osd_progbar_value=100;   // 0..256
@@ -723,7 +780,7 @@ inline static void vo_update_spudec_sub(
   obj->flags |= OSDFLAG_BBOX;
 }
 
-inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, unsigned char* src, unsigned char* srca, int stride))
+inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, int dp, unsigned char* src, unsigned char* srca, int stride))
 {
   spudec_draw_scaled(vo_spudec, obj->dxs, obj->dys, draw_alpha);
 }
@@ -809,6 +866,14 @@ int vo_update_osd(int dxs,int dys){
         int vis=obj->flags&OSDFLAG_VISIBLE;
 	obj->flags&=~OSDFLAG_BBOX;
 	switch(obj->type){
+#ifdef USE_DVDNAV
+#ifdef USE_MPDVDNAV
+	case OSDTYPE_DVDNAV:
+	    vo_update_dvdnav(obj,dxs,dys);
+	    obj->flags|=OSDFLAG_CHANGED;
+	    break;
+#endif
+#endif
 	case OSDTYPE_SUBTITLE:
 	    vo_update_text_sub(obj,dxs,dys);
 	    break;
@@ -876,6 +941,11 @@ void vo_init_osd(void){
     new_osd_obj(OSDTYPE_SUBTITLE);
     new_osd_obj(OSDTYPE_PROGBAR);
     new_osd_obj(OSDTYPE_SPU);
+#ifdef USE_DVDNAV
+#ifdef USE_MPDVDNAV
+    new_osd_obj(OSDTYPE_DVDNAV);
+#endif
+#endif
 #ifdef HAVE_FREETYPE
     force_load_font = 1;
 #endif
@@ -901,7 +971,7 @@ void vo_remove_text(int dxs,int dys,void
     }
 }
 
-void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
     mp_osd_obj_t* obj=vo_osd_list;
     vo_update_osd(dxs,dys);
     while(obj){
@@ -911,6 +981,11 @@ void vo_draw_text(int dxs,int dys,void (
 	case OSDTYPE_SPU:
 	    vo_draw_spudec_sub(obj, draw_alpha); // FIXME
 	    break;
+#ifdef USE_DVDNAV
+#ifdef USE_MPDVDNAV
+	case OSDTYPE_DVDNAV:
+#endif
+#endif
 	case OSDTYPE_OSD:
 	case OSDTYPE_SUBTITLE:
 	case OSDTYPE_PROGBAR:
diff -r 448a43f59a37 libvo/sub.h
--- a/libvo/sub.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/sub.h	Sun Apr 30 17:14:32 2006 +0200
@@ -10,6 +10,12 @@ typedef struct mp_osd_bbox_s {
 #define OSDTYPE_SUBTITLE 2
 #define OSDTYPE_PROGBAR 3
 #define OSDTYPE_SPU 4
+#ifdef USE_DVDNAV
+#ifdef USE_MPDVDNAV
+#define OSDTYPE_DVDNAV 5
+void dvdnav_box_area(int sx, int sy, int ex, int ey, int show, unsigned char image, unsigned char alpha);
+#endif
+#endif
 
 #define OSDFLAG_VISIBLE 1
 #define OSDFLAG_CHANGED 2
@@ -51,7 +57,7 @@ typedef struct mp_osd_obj_s {
 #if 0
 
 // disable subtitles:
-static inline void vo_draw_text_osd(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+static inline void vo_draw_text_osd(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
 }
 
 #else
@@ -110,7 +116,7 @@ extern float spu_gaussvar;
 //extern void vo_draw_text_osd(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
 //extern void vo_draw_text_progbar(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
 //extern void vo_draw_text_sub(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 extern void vo_remove_text(int dxs,int dys,void (*remove)(int x0,int y0, int w,int h));
 
 void vo_init_osd(void);
diff -r 448a43f59a37 libvo/vesa_lvo.c
--- a/libvo/vesa_lvo.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vesa_lvo.c	Sun Apr 30 17:14:32 2006 +0200
@@ -233,50 +233,51 @@ void     vlvo_flip_page(void)
   }	
 }
 
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
   UNUSED(x0);
   UNUSED(y0);
   UNUSED(w);
   UNUSED(h);
+  UNUSED(dp);
   UNUSED(src);
   UNUSED(srca);
   UNUSED(stride);
 }
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
     uint32_t bespitch = /*(*/mga_vid_config.src_width;// + 15) & ~15;
     switch(mga_vid_config.format){
     case IMGFMT_BGR15:
     case IMGFMT_RGB15:
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
 	break;
     case IMGFMT_BGR16:
     case IMGFMT_RGB16:
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
 	break;
     case IMGFMT_BGR24:
     case IMGFMT_RGB24:
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,lvo_mem+3*(y0*bespitch+x0),3*bespitch);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,lvo_mem+3*(y0*bespitch+x0),3*bespitch);
 	break;
     case IMGFMT_BGR32:
     case IMGFMT_RGB32:
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,lvo_mem+4*(y0*bespitch+x0),4*bespitch);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,lvo_mem+4*(y0*bespitch+x0),4*bespitch);
 	break;
     case IMGFMT_YV12:
     case IMGFMT_IYUV:
     case IMGFMT_I420:
-        vo_draw_alpha_yv12(w,h,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
         break;
     case IMGFMT_YUY2:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+2*(bespitch*y0+x0),bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+2*(bespitch*y0+x0),bespitch);
         break;
     case IMGFMT_UYVY:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+2*(bespitch*y0+x0)+1,bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+2*(bespitch*y0+x0)+1,bespitch);
         break;
     default:
-        draw_alpha_null(x0,y0,w,h,src,srca,stride);
+        draw_alpha_null(x0,y0,w,h,dp,src,srca,stride);
     }
 }
 
diff -r 448a43f59a37 libvo/video_out.h
--- a/libvo/video_out.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/video_out.h	Sun Apr 30 17:14:32 2006 +0200
@@ -74,6 +74,11 @@ typedef struct {
   int w,h;
 } mp_win_t;
 
+#define VOCTRL_YUVSPU_SUPPORT 28
+#define VOCTRL_RGBSPU_SUPPORT 29
+#define VOCTRL_BGRSPU_SUPPORT 30
+#define VOCTRL_YUYSPU_SUPPORT 31
+
 #define VO_TRUE		1
 #define VO_FALSE	0
 #define VO_ERROR	-1
@@ -85,6 +90,15 @@ typedef struct {
 #define VOFLAG_SWSCALE		0x04
 #define VOFLAG_FLIPPING		0x08
 #define VOFLAG_XOVERLAY_SUB_VO  0x10000
+
+// dest planes (draw_alpha)
+#define	DEST_PLANES_Y		0
+#define DEST_PLANES_U		1
+#define DEST_PLANES_V		2
+#define DEST_PLANES_RB		3
+#define DEST_PLANES_G		4
+#define DEST_PLANES_BR		5
+#define DEST_PLANES_YUYV	6
 
 typedef struct vo_info_s
 {
diff -r 448a43f59a37 libvo/vo_aa.c
--- a/libvo/vo_aa.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_aa.c	Sun Apr 30 17:14:32 2006 +0200
@@ -531,7 +531,7 @@ uninit(void) {
 }
 
 #ifdef USE_OSD
-static void draw_alpha(int x,int y, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x,int y, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     int i,j;
     for (i = 0; i < h; i++) {
 	for (j = 0; j < w; j++) {
diff -r 448a43f59a37 libvo/vo_dfbmga.c
--- a/libvo/vo_dfbmga.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_dfbmga.c	Sun Apr 30 17:14:32 2006 +0200
@@ -922,7 +922,7 @@ query_format( uint32_t format )
 }
 
 static void
-vo_draw_alpha_alut44( int w, int h,
+vo_draw_alpha_alut44( int w, int h, int dp,
                     unsigned char* src,
                     unsigned char *srca,
                     int srcstride,
@@ -953,6 +953,7 @@ static void
 static void
 draw_alpha( int x0, int y0,
             int w, int h,
+	    int dp,
             unsigned char *src,
 	    unsigned char *srca,
             int stride )
@@ -977,38 +978,47 @@ draw_alpha( int x0, int y0,
 
      switch (subframe_format) {
      case DSPF_ALUT44:
-          vo_draw_alpha_alut44( w, h, src, srca, stride,
+          vo_draw_alpha_alut44( w, h, dp, src, srca, stride,
                                 ((uint8_t *) dst) + pitch * y0 + x0,
                               pitch );
           break;
      case DSPF_RGB32:
      case DSPF_ARGB:
-	  vo_draw_alpha_rgb32( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb32( w, h, dp, src, srca, stride,
 			       (( uint8_t *) dst) + pitch * y0 + 4 * x0,
                                pitch );
 	  break;
      case DSPF_RGB24:
-	  vo_draw_alpha_rgb24( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb24( w, h, dp, src, srca, stride,
 			       ((uint8_t *) dst) + pitch * y0 + 3 * x0,
                                pitch );
 	  break;
      case DSPF_RGB16:
-	  vo_draw_alpha_rgb16( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb16( w, h, dp, src, srca, stride,
 			       ((uint8_t *) dst) + pitch * y0 + 2 * x0,
                                pitch );
 	  break;
      case DSPF_ARGB1555:
-	  vo_draw_alpha_rgb15( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb15( w, h, dp, src, srca, stride,
 			       ((uint8_t *) dst) + pitch * y0 + 2 * x0,
                                pitch );
 	  break;
      case DSPF_YUY2:
-	  vo_draw_alpha_yuy2( w, h, src, srca, stride,
+	switch (dp) {
+	    case DEST_PLANES_Y:
+	    vo_draw_alpha_yuy2( w, h, dp, src, srca, stride,
 			      ((uint8_t *) dst) + pitch * y0 + 2 * x0,
                               pitch );
 	  break;
+	    case DEST_PLANES_YUYV:
+	    vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + 2 * x0,
+                              pitch );
+	    break;
+	    }
+	  break;
      case DSPF_UYVY:
-	  vo_draw_alpha_yuy2( w, h, src, srca, stride,
+	  vo_draw_alpha_yuy2( w, h, dp, src, srca, stride,
 			      ((uint8_t *) dst) + pitch * y0 + 2 * x0 + 1,
                               pitch );
 	  break;
@@ -1018,9 +1028,33 @@ draw_alpha( int x0, int y0,
 #endif
      case DSPF_I420:
      case DSPF_YV12:
-	  vo_draw_alpha_yv12( w, h, src, srca, stride,
+	switch (dp) {
+	  case DEST_PLANES_Y:
+	    vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
 			      ((uint8_t *) dst) + pitch * y0 + x0,
                               pitch );
+	  break;
+	  case DEST_PLANES_U:
+	    if (subframe_format==DSPF_YV12)
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * in_height,
+                              pitch );
+		else
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * (in_height+in_height/2),
+                              pitch );
+	    break;
+	  case DEST_PLANES_V:
+	    if (subframe_format==DSPF_YV12)
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * (in_height+in_height/2),
+                              pitch );
+		else
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * in_height,
+                              pitch );
+	    break;
+	  }
 	  break;
      }
 
@@ -1416,6 +1450,18 @@ control( uint32_t request, void *data, .
 
                return get_equalizer( data, value );
           }
+    case VOCTRL_YUVSPU_SUPPORT:
+		if (subframe_format==DSPF_I420 || subframe_format==DSPF_YV12) return VO_TRUE;
+		return VO_FALSE;
+    case VOCTRL_YUYSPU_SUPPORT:
+		if (subframe_format==DSPF_YUY2) return VO_TRUE;
+		return VO_FALSE;
+    case VOCTRL_RGBSPU_SUPPORT:
+		if (subframe_format==DSPF_RGB32 || subframe_format==DSPF_ARGB || subframe_format==DSPF_RGB24 ||
+			subframe_format==DSPF_RGB16 || subframe_format==DSPF_ARGB1555) return VO_TRUE;
+		return VO_FALSE;
+    case VOCTRL_BGRSPU_SUPPORT:
+		return VO_FALSE;
      }
 
      return VO_NOTIMPL;
diff -r 448a43f59a37 libvo/vo_dga.c
--- a/libvo/vo_dga.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_dga.c	Sun Apr 30 17:14:32 2006 +0200
@@ -227,7 +227,7 @@ static unsigned int scale_srcW = 0,
 
 //---------------------------------------------------------
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride)
 {
 
@@ -243,19 +243,19 @@ static void draw_alpha(int x0, int y0, i
     {
 
         case 32:
-            vo_draw_alpha_rgb32(w, h, src, srca, stride, d + 4 * offset,
+            vo_draw_alpha_rgb32(w, h, dp, src, srca, stride, d + 4 * offset,
                                 4 * buffer_stride);
             break;
         case 24:
-            vo_draw_alpha_rgb24(w, h, src, srca, stride, d + 3 * offset,
+            vo_draw_alpha_rgb24(w, h, dp, src, srca, stride, d + 3 * offset,
                                 3 * buffer_stride);
             break;
         case 15:
-            vo_draw_alpha_rgb15(w, h, src, srca, stride, d + 2 * offset,
+            vo_draw_alpha_rgb15(w, h, dp, src, srca, stride, d + 2 * offset,
                                 2 * buffer_stride);
             break;
         case 16:
-            vo_draw_alpha_rgb16(w, h, src, srca, stride, d + 2 * offset,
+            vo_draw_alpha_rgb16(w, h, dp, src, srca, stride, d + 2 * offset,
                                 2 * buffer_stride);
             break;
     }
@@ -982,6 +982,14 @@ static int control(uint32_t request, voi
             return get_image(data);
         case VOCTRL_QUERY_FORMAT:
             return query_format(*((uint32_t *) data));
+        case VOCTRL_YUVSPU_SUPPORT:
+            return VO_FALSE;
+        case VOCTRL_RGBSPU_SUPPORT:
+            return VO_FALSE;
+        case VOCTRL_BGRSPU_SUPPORT:
+            if(HW_MODE.vdm_mplayer_depth==32 || HW_MODE.vdm_mplayer_depth==24 ||
+               HW_MODE.vdm_mplayer_depth==15 || HW_MODE.vdm_mplayer_depth==16) return VO_TRUE;
+            return VO_FALSE;
     }
     return VO_NOTIMPL;
 }
diff -r 448a43f59a37 libvo/vo_directfb2.c
--- a/libvo/vo_directfb2.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_directfb2.c	Sun Apr 30 17:14:32 2006 +0200
@@ -1445,6 +1445,20 @@ static int control(uint32_t request, voi
     
 	return(directfb_get_video_eq(data, value));
       }
+    case VOCTRL_YUVSPU_SUPPORT:
+	if (pixel_format==DSPF_I420 || pixel_format==DSPF_YV12) return VO_TRUE;
+	return VO_FALSE;
+    case VOCTRL_RGBSPU_SUPPORT:
+	if (pixel_format==DSPF_RGB32 || pixel_format==DSPF_ARGB || pixel_format==DSPF_RGB24 ||
+		pixel_format==DSPF_RGB16) return VO_TRUE;
+#if DIRECTFBVERSION > 915
+	if (pixel_format==DSPF_ARGB1555) return VO_TRUE;
+#else
+	if (pixel_format==DSPF_RGB15) return VO_TRUE;
+#endif
+	return VO_FALSE;
+    case VOCTRL_BGRSPU_SUPPORT:
+	return VO_FALSE;
   };
   return VO_NOTIMPL;
 }
@@ -1458,7 +1472,7 @@ static int draw_frame(uint8_t *src[])
 
 // hopefully will be removed soon
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
         void *dst;
@@ -1477,35 +1491,51 @@ static void draw_alpha(int x0, int y0, i
 	switch(pixel_format) {
                 case DSPF_RGB32:
                 case DSPF_ARGB:
-                        vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 4*x0,pitch);
+                        vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 4*x0,pitch);
                         break;
 
                 case DSPF_RGB24:
-                        vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 3*x0,pitch);
+                        vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 3*x0,pitch);
                         break;
 
                 case DSPF_RGB16:
-                        vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
+                        vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
                         break;
 #if DIRECTFBVERSION > 915
                 case DSPF_ARGB1555:
 #else
                 case DSPF_RGB15:
 #endif
-                        vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
+                        vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
                         break;
 
 		case DSPF_YUY2:
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0,pitch);
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0,pitch);
 		break;
 
         	case DSPF_UYVY:
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0 + 1,pitch);
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0 + 1,pitch);
 		break;
 
         	case DSPF_I420:
 		case DSPF_YV12:
-    			vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 1*x0,pitch);
+		  switch (dp) {
+		    case DEST_PLANES_Y:
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 1*x0,pitch);
+			break;
+		    case DEST_PLANES_U:
+			if (pixel_format==DSPF_YV12)
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/4 + pitch*y0 + 1*x0,pitch);
+			    else
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/2 + pitch*y0 + 1*x0,pitch);
+		        break;
+		    case DEST_PLANES_V:
+			if (pixel_format==DSPF_YV12)
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/2 + pitch*y0 + 1*x0,pitch);
+			    else
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/4 + pitch*y0 + 1*x0,pitch);
+		        break;
+		    }
 		break;
 		}
 
diff -r 448a43f59a37 libvo/vo_directx.c
--- a/libvo/vo_directx.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_directx.c	Sun Apr 30 17:14:32 2006 +0200
@@ -82,7 +82,7 @@ static RECT last_rect = {0xDEADC0DE, 0xD
 static RECT last_rect = {0xDEADC0DE, 0xDEADC0DE, 0xDEADC0DE, 0xDEADC0DE};
 
 extern void mplayer_put_key(int code);              //let mplayer handel the keyevents 
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 extern int vidmode;
 
 /*****************************************************************************
@@ -140,37 +140,62 @@ static vo_info_t info =
 
 LIBVO_EXTERN(directx)
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
+    uint8_t *d;
+    uint32_t uvstride=dstride/2;
     switch(image_format) {
     case IMGFMT_YV12 :
     case IMGFMT_I420 :
 	case IMGFMT_IYUV :
 	case IMGFMT_YVU9 :
-    	vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) image) + dstride*y0 + x0,dstride);
+	    switch (dp) {
+		case DEST_PLANES_Y:
+		    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + dstride*y0 + x0,dstride);
+		    break;
+		case DEST_PLANES_U:
+		    if(image_format == IMGFMT_YV12)
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*y0 + x0,uvstride);
+			else
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*(image_height/2) + uvstride*y0 + x0,uvstride);
+		    break;
+		case DEST_PLANES_V:
+		    if(image_format == IMGFMT_YV12)
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*(image_height/2) + uvstride*y0 + x0,uvstride);
+			else
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*y0 + x0,uvstride);
+		    break;
+		}
 	break;
 	case IMGFMT_YUY2 :
-	    vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) image)+ dstride*y0 + 2*x0 ,dstride);
+	    switch (dp) {
+		case DEST_PLANES_Y:
+		    vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) image)+ dstride*y0 + 2*x0 ,dstride);
+		    break;
+		case DEST_PLANES_YUYV:
+		    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image)+ dstride*y0 + 2*x0 ,dstride);
+		    break;
+		}
     break;
     case IMGFMT_UYVY :
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) image) + dstride*y0 + 2*x0 + 1,dstride);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) image) + dstride*y0 + 2*x0 + 1,dstride);
     break;
 	case IMGFMT_RGB15:	
     case IMGFMT_BGR15:
-		vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
+		vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
     break;
     case IMGFMT_RGB16:
 	case IMGFMT_BGR16:
-        vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
     break;
     case IMGFMT_RGB24:
 	case IMGFMT_BGR24:
-        vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
+        vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
     break;
     case IMGFMT_RGB32:
 	case IMGFMT_BGR32:
-        vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
+        vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
     break;
     }
 }
@@ -1596,6 +1621,25 @@ static int control(uint32_t request, voi
 		va_end(ap);
 		return color_ctrl_get(data, value);
 	}
+	case VOCTRL_YUVSPU_SUPPORT: {
+		if (image_format==IMGFMT_YV12 || image_format==IMGFMT_I420 ||
+		    image_format==IMGFMT_IYUV || image_format==IMGFMT_YVU9) return VO_TRUE;
+		return VO_FALSE;
+	}
+	case VOCTRL_YUYSPU_SUPPORT: {
+		if (image_format==IMGFMT_YUY2) return VO_TRUE;
+		return VO_FALSE;
+	}
+	case VOCTRL_RGBSPU_SUPPORT: {
+		if (image_format==IMGFMT_RGB15 || image_format==IMGFMT_RGB16 ||
+		    image_format==IMGFMT_RGB32) return VO_TRUE;
+		return VO_FALSE;
+	}
+	case VOCTRL_BGRSPU_SUPPORT: {
+		if (image_format==IMGFMT_BGR15 || image_format==IMGFMT_BGR16 ||
+		    image_format==IMGFMT_BGR32) return VO_TRUE;
+		return VO_FALSE;
+	}
     case VOCTRL_RESET:
         last_rect.left = 0xDEADC0DE;   // reset window position cache
         // fall-through intended
diff -r 448a43f59a37 libvo/vo_dxr3.c
--- a/libvo/vo_dxr3.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_dxr3.c	Sun Apr 30 17:14:32 2006 +0200
@@ -677,7 +677,7 @@ static int config(uint32_t width, uint32
 	return 0;
 }
 
-static void draw_alpha(int x, int y, int w, int h, unsigned char* src, unsigned char *srca, int srcstride)
+static void draw_alpha(int x, int y, int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride)
 {
 #ifdef SPU_SUPPORT
 	unsigned char *buf = &osdpicbuf[(y * osdpicbuf_w) + x];
diff -r 448a43f59a37 libvo/vo_fbdev.c
--- a/libvo/vo_fbdev.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_fbdev.c	Sun Apr 30 17:14:32 2006 +0200
@@ -562,7 +562,7 @@ static int fb_line_len;
 static int fb_line_len;
 static int fb_xres;
 static int fb_yres;
-static void (*draw_alpha_p)(int w, int h, unsigned char *src,
+static void (*draw_alpha_p)(int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride, unsigned char *dst,
 		int dstride);
 
@@ -1053,14 +1053,14 @@ static int query_format(uint32_t format)
 	return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	unsigned char *dst;
 
 	dst = center + fb_line_len * y0 + fb_pixel_size * x0;
 
-	(*draw_alpha_p)(w, h, src, srca, stride, dst, fb_line_len);
+	(*draw_alpha_p)(w, h, dp, src, srca, stride, dst, fb_line_len);
 }
 
 static int draw_frame(uint8_t *src[]) { return 1; }
@@ -1174,6 +1174,13 @@ static int control(uint32_t request, voi
     return get_image(data);
   case VOCTRL_QUERY_FORMAT:
     return query_format(*((uint32_t*)data));
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (fb_bpp == 32 || fb_bpp==24 || fb_bpp==16 || fb_bpp==15) return VO_TRUE;
+    return VO_FALSE;
   }
 
 #ifdef CONFIG_VIDIX
diff -r 448a43f59a37 libvo/vo_fbdev2.c
--- a/libvo/vo_fbdev2.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_fbdev2.c	Sun Apr 30 17:14:32 2006 +0200
@@ -79,7 +79,7 @@ static int fb_bpp;		// 32: 32  24: 24  1
 static int fb_bpp;		// 32: 32  24: 24  16: 16  15: 15
 static size_t fb_size; // size of frame_buffer
 static int fb_line_len; // length of one line in bytes
-static void (*draw_alpha_p)(int w, int h, unsigned char *src,
+static void (*draw_alpha_p)(int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride, unsigned char *dst,
 		int dstride);
 
@@ -317,7 +317,7 @@ static int query_format(uint32_t format)
 	return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	unsigned char *dst;
@@ -330,7 +330,7 @@ static void draw_alpha(int x0, int y0, i
 	dst = next_frame + (in_width * y0 + x0) * fb_pixel_size;
 	dstride = in_width * fb_pixel_size;
 #endif
-	(*draw_alpha_p)(w, h, src, srca, stride, dst, dstride);
+	(*draw_alpha_p)(w, h, dp, src, srca, stride, dst, dstride);
 }
 
 static void draw_osd(void)
@@ -403,6 +403,13 @@ static int control(uint32_t request, voi
   switch (request) {
   case VOCTRL_QUERY_FORMAT:
     return query_format(*((uint32_t*)data));
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (fb_bpp == 32 || fb_bpp==24 || fb_bpp==16 || fb_bpp==15) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
 }
diff -r 448a43f59a37 libvo/vo_gl2.c
--- a/libvo/vo_gl2.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_gl2.c	Sun Apr 30 17:14:32 2006 +0200
@@ -84,7 +84,7 @@ static int      use_glFinish;
 static int      use_glFinish;
 
 static void (*draw_alpha_fnc)
-                 (int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+                 (int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 
 
 /* The squares that are tiled to make up the game screen polygon */
@@ -573,23 +573,23 @@ static void resize(int *x,int *y){
   glLoadIdentity();
 }
 
-static void draw_alpha_32(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb32(w,h,src,srca,stride,ImageData+4*(y0*image_width+x0),4*image_width);
-}
-
-static void draw_alpha_24(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb24(w,h,src,srca,stride,ImageData+3*(y0*image_width+x0),3*image_width);
-}
-
-static void draw_alpha_16(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb16(w,h,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
-}
-
-static void draw_alpha_15(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb15(w,h,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
-}
-
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha_32(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,ImageData+4*(y0*image_width+x0),4*image_width);
+}
+
+static void draw_alpha_24(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,ImageData+3*(y0*image_width+x0),3*image_width);
+}
+
+static void draw_alpha_16(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
+}
+
+static void draw_alpha_15(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
+}
+
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 }
 
 #ifdef GL_WIN32
@@ -1133,6 +1133,13 @@ static int control(uint32_t request, voi
       return vo_x11_get_equalizer(data, value);
     }
 #endif
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (image_bpp==15 || image_bpp==16 || image_bpp==24 || image_bpp==32) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
 }
diff -r 448a43f59a37 libvo/vo_macosx.m
--- a/libvo/vo_macosx.m	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_macosx.m	Sun Apr 30 17:14:32 2006 +0200
@@ -78,17 +78,17 @@ LIBVO_EXTERN(macosx)
 LIBVO_EXTERN(macosx)
 
 extern void mplayer_put_key(int code);
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
-
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src, unsigned char *srca, int stride)
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src, unsigned char *srca, int stride)
 {
 	switch (image_format)
 	{
 		case IMGFMT_RGB32:
-			vo_draw_alpha_rgb32(w,h,src,srca,stride,image_data+4*(y0*image_width+x0),4*image_width);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,image_data+4*(y0*image_width+x0),4*image_width);
 			break;
 		case IMGFMT_YUY2:
-			vo_draw_alpha_yuy2(w,h,src,srca,stride,image_data + (x0 + y0 * image_width) * 2,image_width*2);
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,image_data + (x0 + y0 * image_width) * 2,image_width*2);
 			break;
 	}
 }
diff -r 448a43f59a37 libvo/vo_quartz.c
--- a/libvo/vo_quartz.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_quartz.c	Sun Apr 30 17:14:32 2006 +0200
@@ -129,7 +129,7 @@ enum
 #include "osdep/keycodes.h"
 
 extern void mplayer_put_key(int code);
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 
 //PROTOTYPE/////////////////////////////////////////////////////////////////
 static OSStatus KeyEventHandler(EventHandlerCallRef nextHandler, EventRef event, void *userData);
@@ -194,23 +194,23 @@ static inline int convert_key(UInt32 key
     }
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src, unsigned char *srca, int stride)
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src, unsigned char *srca, int stride)
 {
 	switch (image_format)
 	{
 		case IMGFMT_RGB32:
-			vo_draw_alpha_rgb32(w,h,src,srca,stride,image_data+4*(y0*imgRect.right+x0),4*imgRect.right);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,image_data+4*(y0*imgRect.right+x0),4*imgRect.right);
 			break;
 		case IMGFMT_YV12:
 		case IMGFMT_IYUV:
 		case IMGFMT_I420:
-			vo_draw_alpha_yv12(w,h,src,srca,stride, ((char*)P) + P->componentInfoY.offset + x0 + y0 * imgRect.right, imgRect.right);
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride, ((char*)P) + P->componentInfoY.offset + x0 + y0 * imgRect.right, imgRect.right);
 			break;
 		case IMGFMT_UYVY:
-			vo_draw_alpha_uyvy(w,h,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
+			vo_draw_alpha_uyvy(w,h,dp,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
 			break;
 		case IMGFMT_YUY2:
-			vo_draw_alpha_yuy2(w,h,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
 			break;
 	}
 }
diff -r 448a43f59a37 libvo/vo_sdl.c
--- a/libvo/vo_sdl.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_sdl.c	Sun Apr 30 17:14:32 2006 +0200
@@ -286,7 +286,7 @@ static void expand_rect(SDL_Rect* rect, 
  *
  **/
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 	struct sdl_priv_s *priv = &sdl_priv;
 	
     if(priv->osd_has_changed) {
@@ -327,16 +327,43 @@ static void draw_alpha(int x0,int y0, in
 		case IMGFMT_YV12:  
 		case IMGFMT_I420:
         	case IMGFMT_IYUV:
-            vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+		    switch (dp) {
+			case DEST_PLANES_Y :
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+			    break;
+			case DEST_PLANES_U :
+			    SDL_OVR_LOCK(-1)
+			    if (priv->format==IMGFMT_YV12)
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[1]))+priv->overlay->pitches[1]*y0+x0,priv->overlay->pitches[1]);
+				else
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[2]))+priv->overlay->pitches[2]*y0+x0,priv->overlay->pitches[2]);
+			    SDL_OVR_UNLOCK
+			    break;
+			case DEST_PLANES_V :
+			    SDL_OVR_LOCK(-1)
+			    if (priv->format==IMGFMT_YV12)
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[2]))+priv->overlay->pitches[2]*y0+x0,priv->overlay->pitches[2]);
+				else
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[1]))+priv->overlay->pitches[1]*y0+x0,priv->overlay->pitches[1]);
+			    SDL_OVR_UNLOCK
+			    break;
+			}
 		break;
 		case IMGFMT_YUY2:
         	case IMGFMT_YVYU:
                 x0 *= 2;
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+		switch (dp) {
+		    case DEST_PLANES_Y :
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+			break;
+		    case DEST_PLANES_YUYV :
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+			break;
+		    }
 		break;	
         	case IMGFMT_UYVY:
                 x0 *= 2;
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+    			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
 		break;
 
 		default:
@@ -345,19 +372,19 @@ static void draw_alpha(int x0,int y0, in
 		switch(priv->format) {
 		case IMGFMT_RGB15:
 		case IMGFMT_BGR15:
-    			vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB16:
 		case IMGFMT_BGR16:
-    			vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB24:
 		case IMGFMT_BGR24:
-    			vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB32:
 		case IMGFMT_BGR32:
-    			vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		}
         }
@@ -366,19 +393,19 @@ static void draw_alpha(int x0,int y0, in
 		switch(priv->format) {
 		case IMGFMT_RGB15:
 		case IMGFMT_BGR15:
-    			vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB16:
 		case IMGFMT_BGR16:
-    			vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB24:
 		case IMGFMT_BGR24:
-    			vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB32:
 		case IMGFMT_BGR32:
-    			vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		}
         }
@@ -1729,6 +1756,18 @@ static int control(uint32_t request, voi
 	mp_msg(MSGT_VO,MSGL_DBG2, "SDL: Set fullscreen mode\n"); }
     }
     return VO_TRUE;
+  case VOCTRL_YUVSPU_SUPPORT:
+    if (priv->format == IMGFMT_YV12 || priv->format == IMGFMT_I420 || priv->format==IMGFMT_IYUV) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_YUYSPU_SUPPORT:
+    if (priv->format==IMGFMT_YUY2) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    if (priv->mode == RGB) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (priv->mode == BGR) return VO_TRUE;
+    return VO_FALSE;
   }
 
   return VO_NOTIMPL;
diff -r 448a43f59a37 libvo/vo_svga.c
--- a/libvo/vo_svga.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_svga.c	Sun Apr 30 17:14:32 2006 +0200
@@ -55,7 +55,7 @@ TODO:
 
 
 static int query_format(uint32_t format);
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride);
 static uint32_t get_image(mp_image_t *mpi);
 
@@ -384,6 +384,13 @@ static int control(uint32_t request, voi
 
       return vidix_control(request, data, value);
     }
+    case VOCTRL_YUVSPU_SUPPORT:
+        return VO_FALSE;
+    case VOCTRL_RGBSPU_SUPPORT:
+	if (mode_bpp==32 || mode_bpp==24 || mode_bpp==16 || mode_bpp==15) return VO_TRUE;
+	return VO_FALSE;
+    case VOCTRL_BGRSPU_SUPPORT:
+	return VO_FALSE;
     }
     return vidix_control(request, data);
   }
@@ -684,13 +691,13 @@ vga_modeinfo * vminfo;
   return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride) {
   char* base;
 
   if( mp_msg_test(MSGT_VO,MSGL_DBG3) )
-    mp_msg(MSGT_VO,MSGL_DBG3, "vo_svga: draw_alpha(x0=%d,y0=%d,w=%d,h=%d,src=%p,srca=%p,stride=%d\n",
-           x0,y0,w,h,src,srca,stride);
+    mp_msg(MSGT_VO,MSGL_DBG3, "vo_svga: draw_alpha(x0=%d,y0=%d,w=%d,h=%d,dp=%d,src=%p,srca=%p,stride=%d\n",
+           x0,y0,w,h,dp,src,srca,stride);
   if(!blackbar_osd) {
     //drawing in the image, so place the stuff there
     x0+=x_pos;
@@ -702,16 +709,16 @@ static void draw_alpha(int x0, int y0, i
   base=PageStore[cpage].vbase + y0*mode_stride + x0*modeinfo->bytesperpixel;
   switch (mode_bpp) {
     case 32: 
-      vo_draw_alpha_rgb32(w, h, src, srca, stride, base, mode_stride);
+      vo_draw_alpha_rgb32(w, h, dp, src, srca, stride, base, mode_stride);
       break;
     case 24: 
-      vo_draw_alpha_rgb24(w, h, src, srca, stride, base, mode_stride);
+      vo_draw_alpha_rgb24(w, h, dp, src, srca, stride, base, mode_stride);
       break;
     case 16:
-      vo_draw_alpha_rgb16(w, h, src, srca, stride, base, mode_stride);
+      vo_draw_alpha_rgb16(w, h, dp, src, srca, stride, base, mode_stride);
       break;
     case 15:
-      vo_draw_alpha_rgb15(w, h, src, srca, stride, base, mode_stride);
+      vo_draw_alpha_rgb15(w, h, dp, src, srca, stride, base, mode_stride);
       break;
   }
 }
diff -r 448a43f59a37 libvo/vo_tdfxfb.c
--- a/libvo/vo_tdfxfb.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_tdfxfb.c	Sun Apr 30 17:14:32 2006 +0200
@@ -82,6 +82,9 @@ static voodoo_yuv_reg *reg_YUV;
 static voodoo_yuv_reg *reg_YUV;
 static struct YUV_plane *YUV;
 static void (*alpha_func)(), (*alpha_func_double)();
+static int support_yuv = VO_FALSE;
+static int support_rgb = VO_FALSE;
+static int support_bgr = VO_FALSE;
 
 static int preinit(const char *arg)
 {
@@ -233,18 +236,21 @@ static int config(uint32_t width, uint32
 		screendepth = 2;
 		vid_voodoo_format = VOODOO_BLT_FORMAT_16;
 		alpha_func_double = vo_draw_alpha_rgb16;
+		support_rgb = VO_TRUE;
 		break;
 
 	case 24:
 		screendepth = 3;
 		vid_voodoo_format = VOODOO_BLT_FORMAT_24;
 		alpha_func_double = vo_draw_alpha_rgb24;
+		support_rgb = VO_TRUE;
 		break;
 
 	case 32:
 		screendepth = 4;
 		vid_voodoo_format = VOODOO_BLT_FORMAT_32;
 		alpha_func_double = vo_draw_alpha_rgb32;
+		support_rgb = VO_TRUE;
 		break;
 
 	default:
@@ -262,6 +268,7 @@ static int config(uint32_t width, uint32
 	switch(in_format) {
 	case IMGFMT_YV12:
 	case IMGFMT_I420:
+//		support_yuv = VO_TRUE;
 	case IMGFMT_IYUV:
 	case IMGFMT_YUY2:
 		break;
@@ -271,18 +278,21 @@ static int config(uint32_t width, uint32
 	case IMGFMT_BGR16:
 		in_voodoo_format = VOODOO_BLT_FORMAT_16;
 		alpha_func = vo_draw_alpha_rgb16;
+		support_rgb = VO_TRUE;
 		break;
 
 	case IMGFMT_BGR24:
 		in_depth = 3;
 		in_voodoo_format = VOODOO_BLT_FORMAT_24;
 		alpha_func = vo_draw_alpha_rgb24;
+		support_rgb = VO_TRUE;
 		break;
 
 	case IMGFMT_BGR32:
 		in_depth = 4;
 		in_voodoo_format = VOODOO_BLT_FORMAT_32;
 		alpha_func = vo_draw_alpha_rgb32;
+		support_rgb = VO_TRUE;
 		break;
 
 	default:
@@ -324,19 +334,19 @@ static int config(uint32_t width, uint32
 }
 
 /* Double-buffering draw_alpha */
-static void draw_alpha_double(int x, int y, int w, int h, unsigned char *src,
+static void draw_alpha_double(int x, int y, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	char *dst = (char *)vidpage + ((y + vidy) * screenwidth + x + vidx) * screendepth;
-	alpha_func_double(w, h, src, srca, stride, dst, screenwidth * screendepth);
+	alpha_func_double(w, h, dp, src, srca, stride, dst, screenwidth * screendepth);
 }
 
 /* Single-buffering draw_alpha */
-static void draw_alpha(int x, int y, int w, int h, unsigned char *src,
+static void draw_alpha(int x, int y, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	char *dst = (char *)inpage + (y * in_width + x) * in_depth;
-	alpha_func(w, h, src, srca, stride, dst, in_width * in_depth);
+	alpha_func(w, h, dp, src, srca, stride, dst, in_width * in_depth);
 }
 
 static void draw_osd(void)
@@ -503,6 +513,12 @@ static int control(uint32_t request, voi
 	case VOCTRL_FULLSCREEN:
 		setup_screen(!vo_fs);
 		return 0;
+        case VOCTRL_YUVSPU_SUPPORT:
+            return support_yuv;
+        case VOCTRL_RGBSPU_SUPPORT:
+	    return support_rgb;
+        case VOCTRL_BGRSPU_SUPPORT:
+	    return support_bgr;
 	}
 
 	return VO_NOTIMPL;
diff -r 448a43f59a37 libvo/vo_vesa.c
--- a/libvo/vo_vesa.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_vesa.c	Sun Apr 30 17:14:32 2006 +0200
@@ -46,6 +46,7 @@
 #include "vosub_vidix.h"
 #endif
 #include "mp_msg.h"
+#include "help_mp.h"
 
 #include "postproc/swscale.h"
 #include "libmpcodecs/vf_scale.h"
@@ -107,7 +108,7 @@ static unsigned video_mode; /* selected 
 static unsigned video_mode; /* selected video mode for playback */
 static struct VesaModeInfoBlock video_mode_info;
 static int flip_trigger = 0;
-static void (*draw_alpha_fnc)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void (*draw_alpha_fnc)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 
 /* multibuffering */
 uint8_t*  video_base; /* should be never changed */
@@ -295,7 +296,7 @@ static int draw_slice(uint8_t *image[], 
 /* Please comment it out if you want have OSD within movie */
 /*#define OSD_OUTSIDE_MOVIE 1*/
 
-static void draw_alpha_32(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_32(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -305,10 +306,10 @@ static void draw_alpha_32(int x0,int y0,
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb32(w,h,src,srca,stride,dga_buffer+4*(y0*dstride+x0),4*dstride);
-}
-
-static void draw_alpha_24(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+   vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,dga_buffer+4*(y0*dstride+x0),4*dstride);
+}
+
+static void draw_alpha_24(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -318,10 +319,10 @@ static void draw_alpha_24(int x0,int y0,
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb24(w,h,src,srca,stride,dga_buffer+3*(y0*dstride+x0),3*dstride);
-}
-
-static void draw_alpha_16(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+   vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,dga_buffer+3*(y0*dstride+x0),3*dstride);
+}
+
+static void draw_alpha_16(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -331,10 +332,10 @@ static void draw_alpha_16(int x0,int y0,
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb16(w,h,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
-}
-
-static void draw_alpha_15(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+   vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
+}
+
+static void draw_alpha_15(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -344,15 +345,16 @@ static void draw_alpha_15(int x0,int y0,
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb15(w,h,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
-}
-
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+   vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
+}
+
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
   UNUSED(x0);
   UNUSED(y0);
   UNUSED(w);
   UNUSED(h);
+  UNUSED(dp);
   UNUSED(src);
   UNUSED(srca);
   UNUSED(stride);
@@ -1096,6 +1098,14 @@ static int control(uint32_t request, voi
   switch (request) {
   case VOCTRL_QUERY_FORMAT:
     return query_format(*((uint32_t*)data));
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (dstFourcc == IMGFMT_BGR15 || dstFourcc == IMGFMT_BGR16 || dstFourcc == IMGFMT_BGR24 ||
+	    dstFourcc == IMGFMT_BGR32 || dstFourcc == IMGFMT_BGR16) return VO_TRUE;
+    return VO_FALSE;
   }
 
 #ifdef CONFIG_VIDIX
diff -r 448a43f59a37 libvo/vo_x11.c
--- a/libvo/vo_x11.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_x11.c	Sun Apr 30 17:14:32 2006 +0200
@@ -42,6 +42,7 @@ int XShmGetEventBase(Display *);
 #include "postproc/swscale_internal.h"       //FIXME
 #include "postproc/rgb2rgb.h"
 #include "libmpcodecs/vf_scale.h"
+#include "help_mp.h"
 
 #include "mp_msg.h"
 #include "help_mp.h"
@@ -61,7 +62,7 @@ LIBVO_EXTERN(x11)
 LIBVO_EXTERN(x11)
 /* private prototypes */
 static void Display_Image(XImage * myximage, unsigned char *ImageData);
-static void (*draw_alpha_fnc) (int x0, int y0, int w, int h,
+static void (*draw_alpha_fnc) (int x0, int y0, int w, int h, int dp,
                                unsigned char *src, unsigned char *srca,
                                int stride);
 
@@ -106,39 +107,39 @@ static void check_events()
 
 }
 
-static void draw_alpha_32(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_32(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb32(w, h, src, srca, stride,
+    vo_draw_alpha_rgb32(w, h, dp, src, srca, stride,
                         ImageData + 4 * (y0 * image_width + x0),
                         4 * image_width);
 }
 
-static void draw_alpha_24(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_24(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb24(w, h, src, srca, stride,
+    vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
                         ImageData + 3 * (y0 * image_width + x0),
                         3 * image_width);
 }
 
-static void draw_alpha_16(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_16(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb16(w, h, src, srca, stride,
+    vo_draw_alpha_rgb16(w, h, dp, src, srca, stride,
                         ImageData + 2 * (y0 * image_width + x0),
                         2 * image_width);
 }
 
-static void draw_alpha_15(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_15(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb15(w, h, src, srca, stride,
+    vo_draw_alpha_rgb15(w, h, dp, src, srca, stride,
                         ImageData + 2 * (y0 * image_width + x0),
                         2 * image_width);
 }
 
-static void draw_alpha_null(int x0, int y0, int w, int h,
+static void draw_alpha_null(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
@@ -796,6 +797,14 @@ static int control(uint32_t request, voi
                 vo_x11_clearwindow(mDisplay, vo_window);
             }
             return VO_TRUE;
+        case VOCTRL_YUVSPU_SUPPORT:
+            return VO_FALSE;
+        case VOCTRL_RGBSPU_SUPPORT:
+	    return VO_FALSE;
+        case VOCTRL_BGRSPU_SUPPORT:
+	    if (out_format == IMGFMT_BGR15 || out_format == IMGFMT_BGR16 ||
+		out_format == IMGFMT_BGR24 || out_format == IMGFMT_BGR32) return VO_TRUE;
+	    return VO_FALSE;
     }
     return VO_NOTIMPL;
 }
diff -r 448a43f59a37 libvo/vo_xv.c
--- a/libvo/vo_xv.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_xv.c	Sun Apr 30 17:14:32 2006 +0200
@@ -92,47 +92,83 @@ static uint32_t dwidth, dheight;
 static uint32_t dwidth, dheight;
 static uint32_t max_width = 0, max_height = 0; // zero means: not set
 
-static void (*draw_alpha_fnc) (int x0, int y0, int w, int h,
+static int support_yuvspu = VO_FALSE;
+static int support_yuyspu = VO_FALSE;
+
+static void (*draw_alpha_fnc) (int x0, int y0, int w, int h, int dp,
                                unsigned char *src, unsigned char *srca,
                                int stride);
 
-static void draw_alpha_yv12(int x0, int y0, int w, int h,
+static void draw_alpha_yv12(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+    switch (dp)  {
+	case DEST_PLANES_U:  {
+    x0 += image_width/2 * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                       xvimage[current_buf]->data +
+                       xvimage[current_buf]->offsets[1] +
+                       xvimage[current_buf]->pitches[1] * y0 + x0,
+                       xvimage[current_buf]->pitches[1]);
+	  break; }
+	case DEST_PLANES_V:  {
+    x0 += image_width/2 * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                       xvimage[current_buf]->data +
+                       xvimage[current_buf]->offsets[2] +
+                       xvimage[current_buf]->pitches[2] * y0 + x0,
+                       xvimage[current_buf]->pitches[2]);
+	  break; }
+	case DEST_PLANES_Y: {
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yv12(w, h, src, srca, stride,
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + x0,
                        xvimage[current_buf]->pitches[0]);
 }
-
-static void draw_alpha_yuy2(int x0, int y0, int w, int h,
+	}
+
+}
+
+static void draw_alpha_yuy2(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+  switch (dp) {
+    case DEST_PLANES_Y:
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yuy2(w, h, src, srca, stride,
+    vo_draw_alpha_yuy2(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
                        xvimage[current_buf]->pitches[0]);
-}
-
-static void draw_alpha_uyvy(int x0, int y0, int w, int h,
+    break;
+    case DEST_PLANES_YUYV:
+    x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                       xvimage[current_buf]->data +
+                       xvimage[current_buf]->offsets[0] +
+                       xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
+                       xvimage[current_buf]->pitches[0]);
+    break;
+    }
+}
+
+static void draw_alpha_uyvy(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yuy2(w, h, src, srca, stride,
+    vo_draw_alpha_yuy2(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + 2 * x0 + 1,
                        xvimage[current_buf]->pitches[0]);
 }
 
-static void draw_alpha_null(int x0, int y0, int w, int h,
+static void draw_alpha_null(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
@@ -387,11 +423,13 @@ static int config(uint32_t width, uint32
     {
         case IMGFMT_YV12:
         case IMGFMT_I420:
+	    support_yuvspu = VO_TRUE;
         case IMGFMT_IYUV:
             draw_alpha_fnc = draw_alpha_yv12;
             break;
         case IMGFMT_YUY2:
         case IMGFMT_YVYU:
+	    support_yuyspu = VO_TRUE;
             draw_alpha_fnc = draw_alpha_yuy2;
             break;
         case IMGFMT_UYVY:
@@ -1003,6 +1041,14 @@ static int control(uint32_t request, voi
         case VOCTRL_ONTOP:
             vo_x11_ontop();
             return VO_TRUE;
+        case VOCTRL_YUVSPU_SUPPORT:
+            return support_yuvspu;
+        case VOCTRL_RGBSPU_SUPPORT:
+	    return VO_FALSE;
+        case VOCTRL_BGRSPU_SUPPORT:
+	    return VO_FALSE;
+        case VOCTRL_YUYSPU_SUPPORT:
+            return support_yuyspu;
     }
     return VO_NOTIMPL;
 }
diff -r 448a43f59a37 libvo/vo_xvmc.c
--- a/libvo/vo_xvmc.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_xvmc.c	Sun Apr 30 17:14:32 2006 +0200
@@ -84,12 +84,12 @@ static int free_element;
 static int free_element;
 
 
-static void (*draw_osd_fnc)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void (*draw_osd_fnc)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 static void (*clear_osd_fnc)(int x0,int y0, int w,int h);
 static void (*init_osd_fnc)(void);
 
-static void   draw_osd_AI44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
-static void   draw_osd_IA44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void   draw_osd_AI44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
+static void   draw_osd_IA44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 static void   clear_osd_subpic(int x0,int y0, int w,int h);
 static void   init_osd_yuv_pal(void);
 
@@ -875,7 +875,7 @@ int rez;
    subpicture_alloc = 1;
 }
 
-static void draw_osd_IA44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_osd_IA44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 int ox,oy;
 int rez;
 
@@ -895,7 +895,7 @@ int rez;
    }
 }
 
-static void draw_osd_AI44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_osd_AI44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 int ox,oy;
 int rez;
    if(  mp_msg_test(MSGT_VO,MSGL_DBG4) )
diff -r 448a43f59a37 libvo/vo_yuv4mpeg.c
--- a/libvo/vo_yuv4mpeg.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vo_yuv4mpeg.c	Sun Apr 30 17:14:32 2006 +0200
@@ -179,25 +179,37 @@ static void swap_fields(uint8_t *ptr, co
 	}
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride) {
 	switch (using_format)
 	{
     	case IMGFMT_YV12:
-	    	vo_draw_alpha_yv12(w, h, src, srca, stride, 
+	    switch (dp) {
+		case DEST_PLANES_Y:
+		    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
 				       image + y0 * image_width + x0, image_width);
+			break;
+		case DEST_PLANES_U:
+		    if (image_u) vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+				image_u + y0 * image_width + x0, image_width);
+		    break;
+		case DEST_PLANES_V:
+		    if (image_v) vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+				image_v + y0 * image_width + x0, image_width);
+		    break;
+		}
 			break;
 		
 		case IMGFMT_BGR|24:
 		case IMGFMT_RGB|24:
 			if (config_interlace != Y4M_ILACE_BOTTOM_FIRST)
-				vo_draw_alpha_rgb24(w, h, src, srca, stride,
+				vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
 						rgb_buffer + (y0 * image_width + x0) * 3, image_width * 3);
 			else
 			{
 				swap_fields (rgb_buffer, image_height, image_width * 3);
 
-				vo_draw_alpha_rgb24(w, h, src, srca, stride,
+				vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
 						rgb_buffer + (y0 * image_width  + x0) * 3, image_width * 3);
 				
 				swap_fields (rgb_buffer, image_height, image_width * 3);
@@ -543,6 +555,15 @@ static int control(uint32_t request, voi
     return query_format(*((uint32_t*)data));
   case VOCTRL_DUPLICATE_FRAME:
     return write_last_frame();
+  case VOCTRL_YUVSPU_SUPPORT:
+    if (using_format==IMGFMT_YV12) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    if (using_format==IMGFMT_RGB|24) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (using_format==IMGFMT_BGR|24) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
 }
diff -r 448a43f59a37 libvo/vosub_vidix.c
--- a/libvo/vosub_vidix.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/libvo/vosub_vidix.c	Sun Apr 30 17:14:32 2006 +0200
@@ -283,7 +283,7 @@ void     vidix_flip_page(void)
   }	
 }
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
     uint32_t apitch,bespitch;
     void *lvo_mem;
@@ -297,36 +297,55 @@ static void draw_alpha(int x0,int y0, in
     case IMGFMT_IF09:
     case IMGFMT_Y8:
     case IMGFMT_Y800:
+	switch (dp) {
+	  case DEST_PLANES_Y:
 	bespitch = (vidix_play.src.w + apitch) & (~apitch);
-        vo_draw_alpha_yv12(w,h,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+           vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+	  break;
+	  case DEST_PLANES_U:
+	     lvo_mem = vidix_mem + vidix_play.offsets[next_frame] + vidix_play.offset.u;
+	     vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+dstrides.u*y0/4+x0,dstrides.u/2);
+	  break;
+	  case DEST_PLANES_V:
+	     lvo_mem = vidix_mem + vidix_play.offsets[next_frame] + vidix_play.offset.v;
+	     vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+dstrides.v*y0/4+x0,dstrides.v/2);
+	  break;
+	  }
         break;
     case IMGFMT_YUY2:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+bespitch*y0+2*x0,bespitch);
+	switch (dp) {
+	case DEST_PLANES_Y:
+          vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+2*x0,bespitch);
+	  break;
+	case DEST_PLANES_YUYV:
+           vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+	  break;
+	  }
         break;
     case IMGFMT_UYVY:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+bespitch*y0+2*x0+1,bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+2*x0+1,bespitch);
         break;
     case IMGFMT_RGB32:
     case IMGFMT_BGR32:
 	bespitch = (vidix_play.src.w*4 + apitch) & (~apitch);
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,lvo_mem+y0*bespitch+4*x0,bespitch);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+4*x0,bespitch);
         break;
     case IMGFMT_RGB24:
     case IMGFMT_BGR24:
 	bespitch = (vidix_play.src.w*3 + apitch) & (~apitch);
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,lvo_mem+y0*bespitch+3*x0,bespitch);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+3*x0,bespitch);
         break;
     case IMGFMT_RGB16:
     case IMGFMT_BGR16:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
         break;
     case IMGFMT_RGB15:
     case IMGFMT_BGR15:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
         break;
     default:
 	return;
@@ -512,7 +531,7 @@ int      vidix_init(unsigned src_width,u
 	    next_frame = i;
 	    memset(vidix_mem + vidix_play.offsets[i], 0x80,
 		vidix_play.frame_size);
-	    draw_alpha(0, 0, image_width, image_height, tmp, tmpa, image_width);
+	    draw_alpha(0, 0, image_width, image_height, DEST_PLANES_Y, tmp, tmpa, image_width);
 	}
 	free(tmp);
 	free(tmpa);
@@ -700,6 +719,16 @@ uint32_t vidix_control(uint32_t request,
 
     return VO_TRUE;
   }
+  case VOCTRL_YUVSPU_SUPPORT:
+    if((vidix_play.fourcc==IMGFMT_YV12 || vidix_play.fourcc==IMGFMT_YV12 || vidix_play.fourcc==IMGFMT_IYUV ||
+	vidix_play.fourcc==IMGFMT_I420 || vidix_play.fourcc==IMGFMT_YVU9 || vidix_play.fourcc==IMGFMT_IF09 ||
+	vidix_play.fourcc==IMGFMT_Y8 || vidix_play.fourcc==IMGFMT_Y800) &&
+	!(vidix_play.flags & VID_PLAY_INTERLEAVED_UV)) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_YUYSPU_SUPPORT:
+    if((vidix_play.fourcc==IMGFMT_YUY2) &&
+	!(vidix_play.flags & VID_PLAY_INTERLEAVED_UV)) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
   // WARNING: we drop extra parameters (...) here!
diff -r 448a43f59a37 mencoder.c
--- a/mencoder.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/mencoder.c	Sun Apr 30 17:14:32 2006 +0200
@@ -50,6 +50,9 @@
 #include "parser-mecmd.h"
 
 #include "libmpdemux/stream.h"
+#ifdef USE_MPDVDNAV
+#include "libmpdemux/stream_dvdnav.h"
+#endif
 #include "libmpdemux/demuxer.h"
 #include "libmpdemux/stheader.h"
 #include "libmpdemux/mp3_hdr.h"
@@ -63,6 +66,9 @@
 #include "libmpcodecs/mp_image.h"
 #include "libmpcodecs/dec_audio.h"
 #include "libmpcodecs/dec_video.h"
+#ifdef USE_MPDVDNAV
+#include "libmpcodecs/vd_videostill.h"
+#endif
 #include "libmpcodecs/vf.h"
 
 // for MPEGLAYER3WAVEFORMAT:
@@ -495,7 +501,7 @@ if (frameno_filename) {
 if (frameno_filename) {
   stream2=open_stream(frameno_filename,0,&i);
   if(stream2){
-    demuxer2=demux_open(stream2,DEMUXER_TYPE_AVI,-1,-1,-2,NULL);
+    demuxer2=demux_open(stream2,DEMUXER_TYPE_AVI,-1,-1,-2,NULL,0);
     if(demuxer2) mp_msg(MSGT_MENCODER, MSGL_INFO, MSGTR_UsingPass3ControlFile, frameno_filename);
     else mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_FormatNotRecognized);
   }
@@ -574,7 +580,7 @@ if(stream->type==STREAMTYPE_DVD){
   if(demuxer2) audio_id=-2; /* do NOT read audio packets... */
 
   //demuxer=demux_open(stream,file_format,video_id,audio_id,dvdsub_id);
-  demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename);
+  demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename,0);
   if(!demuxer){
     mp_msg(MSGT_DEMUXER, MSGL_FATAL, MSGTR_FormatNotRecognized);
     mp_msg(MSGT_DEMUXER, MSGL_FATAL, MSGTR_CannotOpenDemuxer);
diff -r 448a43f59a37 mplayer.c
--- a/mplayer.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/mplayer.c	Sun Apr 30 17:14:32 2006 +0200
@@ -68,7 +68,19 @@ extern int mp_input_win32_slave_cmd_func
 #include "codec-cfg.h"
 
 #ifdef USE_DVDNAV
+#ifdef USE_MPDVDNAV
+#include <libmpdemux/stream_dvdnav.h>
+
+int dvdnav_wait = 0;
+int dvdnav_still = 0;
+int dvdnav_decodeok = 0;
+int dvdnav_seek_counter = 0;
+int dvdnav_menu_visible = 0;
+int dvdnav_color_spu_flg = -1;
+unsigned int dvdnav_activate_timer = 0;
+#else
 #include <dvdnav.h>
+#endif
 #endif
 
 #include "edl.h"
@@ -191,6 +203,9 @@ static int max_framesize=0;
 
 #include "libmpcodecs/dec_audio.h"
 #include "libmpcodecs/dec_video.h"
+#ifdef USE_MPDVDNAV
+#include "libmpcodecs/vd_videostill.h"
+#endif
 #include "libmpcodecs/mp_image.h"
 #include "libmpcodecs/vf.h"
 #include "libmpcodecs/vd.h"
@@ -400,6 +415,8 @@ static int nortc;
 static int nortc;
 static char* rtc_device;
 #endif
+
+short sw_muted = 0; ///< Stores whether switch stream is currently is muted mode.
 
 edl_record_ptr edl_records = NULL; ///< EDL entries memory area
 edl_record_ptr next_edl_record = NULL; ///< only for traversing edl_records
@@ -1573,7 +1590,7 @@ static int mp_property_volume(m_option_t
         return M_PROPERTY_NOT_IMPLEMENTED;
     }
 
-    if (edl_muted) return M_PROPERTY_DISABLED;
+    if (edl_muted || sw_muted) return M_PROPERTY_DISABLED;
     user_muted = 0;
 
     switch(action) {
@@ -1605,14 +1622,14 @@ static int mp_property_mute(m_option_t* 
     
     switch(action) {
     case M_PROPERTY_SET:
-        if(edl_muted) return M_PROPERTY_DISABLED;
+        if(edl_muted || sw_muted) return M_PROPERTY_DISABLED;
         if(!arg) return 0;
         if((!!*(int*)arg) != mixer.muted)
             mixer_mute(&mixer);
         return 1;
     case M_PROPERTY_STEP_UP:
     case M_PROPERTY_STEP_DOWN:
-        if(edl_muted) return M_PROPERTY_DISABLED;
+        if(edl_muted || sw_muted) return M_PROPERTY_DISABLED;
         mixer_mute(&mixer);
         return 1;
     case M_PROPERTY_PRINT:
@@ -1962,6 +1979,12 @@ static int mp_property_sub(m_option_t* p
         if (vo_spudec && dvdsub_id >= 0) {
             char lang[3] = "\0\0\0";
             int code = 0;
+#ifdef USE_MPDVDNAV
+	    if(stream->type==STREAMTYPE_DVDNAV)
+	      code = dvdnav_lang_from_sid((dvdnav_priv_t*)(stream->priv),
+		    dvdsub_id);
+	    else
+#endif
             code = dvd_lang_from_sid(stream, dvdsub_id);
             if (code) {
                 lang[0] = code >> 8;
@@ -2029,6 +2052,12 @@ static int mp_property_sub(m_option_t* p
         if (d_dvdsub) {
 #ifdef USE_DVDREAD
             if (vo_spudec && stream->type == STREAMTYPE_DVD) {
+                d_dvdsub->id = dvdsub_id;
+                spudec_reset(vo_spudec);
+            }
+#endif
+#ifdef USE_MPDVDNAV
+            if (vo_spudec && stream->type == STREAMTYPE_DVDNAV) {
                 d_dvdsub->id = dvdsub_id;
                 spudec_reset(vo_spudec);
             }
@@ -2075,6 +2104,15 @@ static int mp_property_sub(m_option_t* p
         d_dvdsub->id = dvdsub_id;
         spudec_reset(vo_spudec);
     }
+#endif
+#ifdef USE_MPDVDNAV
+    if (vo_spudec && stream->type == STREAMTYPE_DVDNAV &&
+	    dvdsub_id < 0 && reset_spu)
+      {
+      dvdsub_id = -2;
+      d_dvdsub->id = dvdsub_id;
+      spudec_reset(vo_spudec);
+      }
 #endif
 
     return 1;
@@ -3108,7 +3146,12 @@ if(stream_cache_size>0){
 //============ Open DEMUXERS --- DETECT file type =======================
 current_module="demux_open";
 
-demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename);
+#ifdef USE_MPDVDNAV
+if (stream->type==STREAMTYPE_DVDNAV)
+  demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename,1);
+  else
+#endif
+demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename,0);
 
 // HACK to get MOV Reference Files working
 
@@ -3266,7 +3309,7 @@ while(sh_audio && !sh_video && bg_video)
     mp_msg(MSGT_CPLAYER,MSGL_ERR, "Couldn't open the stream for back ground video: %s\n",bg_video);
     break;
   }
-  bg_demuxer = demux_open(bg_s,bg_file_format,-2,video_id,dvdsub_id,bg_video);
+  bg_demuxer = demux_open(bg_s,bg_file_format,-2,video_id,dvdsub_id,bg_video, 0);
   if(!bg_demuxer) {
     mp_msg(MSGT_DEMUXER,MSGL_ERR,"Failed to open background video\n");
     free_stream(bg_s);
@@ -3345,7 +3388,11 @@ demux_info_print(demuxer);
 
 //================== Read SUBTITLES (DVD & TEXT) ==========================
 if(vo_spudec==NULL && sh_video &&
-     (stream->type==STREAMTYPE_DVD || demuxer->type==DEMUXER_TYPE_MATROSKA)){
+     (stream->type==STREAMTYPE_DVD || demuxer->type==DEMUXER_TYPE_MATROSKA
+#ifdef USE_MPDVDNAV
+      || stream->type==STREAMTYPE_DVDNAV
+#endif
+      )){
 
 if (spudec_ifo) {
   unsigned int palette[16], width, height;
@@ -3357,9 +3404,12 @@ if (spudec_ifo) {
 #ifdef USE_DVDNAV
 if (vo_spudec==NULL && stream->type==STREAMTYPE_DVDNAV) {
   current_module="spudec_init_dvdnav";
-  vo_spudec=spudec_new_scaled(dvdnav_stream_get_palette((dvdnav_priv_t*)(stream->priv)),
-			    sh_video->disp_w, sh_video->disp_h);
-}
+  vo_spudec=spudec_new_scaled(
+	dvdnav_stream_get_palette((dvdnav_priv_t*)(stream->priv)),
+	sh_video->disp_w,
+	sh_video->disp_h);
+}
+if (dvdsub_id>=0 && stream->type==STREAMTYPE_DVDNAV) dvdnav_go_spu=2;
 #endif
 
 #ifdef USE_DVDREAD
@@ -3747,6 +3797,25 @@ mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_Star
 #ifdef USE_DVDNAV
 if (stream->type==STREAMTYPE_DVDNAV) {
   dvdnav_stream_fullstart((dvdnav_priv_t *)stream->priv);
+#ifdef USE_MPDVDNAV
+  dvdnav_set_language(
+	(dvdnav_priv_t *)stream->priv, dvdsub_lang, audio_lang, NULL);
+  clearsmpi(); /* clear correct still image */
+if(stream->type==STREAMTYPE_DVDNAV)
+  {
+  current_module="dvdnav lang->id";
+  if(audio_lang && audio_id==-1)
+    audio_id=dvdnav_aid_from_lang((dvdnav_priv_t*)(stream->priv),audio_lang);
+  if (sh_audio && audio_id>=0) dvdnav_go_audio=1;
+  if(dvdsub_lang && dvdsub_id==-2) dvdsub_id=-1;
+  if(dvdsub_lang && dvdsub_id==-1)
+    dvdsub_id=dvdnav_sid_from_lang((dvdnav_priv_t*)(stream->priv),dvdsub_lang);
+  if (dvdsub_id>=0) dvdnav_go_spu=1;
+  global_sub_indices[SUB_SOURCE_DEMUX] = global_sub_size; // the global # of the first demux-specific sub.
+  global_sub_size += dvdnav_number_of_subs((dvdnav_priv_t*)(stream->priv));
+  current_module=NULL;
+  }
+#endif
 }
 #endif
 
@@ -3833,6 +3902,9 @@ if(!sh_video) {
   vo_pts=sh_video->timer*90000.0;
   vo_fps=sh_video->fps;
 
+#ifdef USE_MPDVDNAV
+if (stream->type==STREAMTYPE_DVDNAV && dvdnav_still) frame_time_remaining=0;
+#endif
   if(!frame_time_remaining){
     //--------------------  Decode a frame: -----------------------
     vdecode_time=video_time_usage;
@@ -3841,6 +3913,30 @@ if(!sh_video) {
 	int in_size;
 	// get it!
 	current_module="video_read_frame";
+#ifdef USE_MPDVDNAV
+        in_size=video_read_frame(sh_video,&next_frame_time,&start,force_fps);
+	if (stream->type==STREAMTYPE_DVDNAV)
+	  {
+	  if (dvdnav_reallyeof((dvdnav_priv_t*)(stream->priv)))
+	    {
+	    eof=1;
+	    break;
+	    }
+	  if (in_size<0)
+	    {
+	    sh_video->num_frames++;
+	    sh_video->num_frames_decoded++;
+	    sh_video->pts+=next_frame_time;
+	    }
+	  sh_video->config_lock=1;
+	  } else {
+	  if(in_size<0)
+	    {
+	    eof=1;
+	    break;
+	    }
+	  }
+#else
         in_size=video_read_frame(sh_video,&next_frame_time,&start,force_fps);
 	if(in_size<0){
 	  if(bg_demuxer) {
@@ -3852,6 +3948,7 @@ if(!sh_video) {
 	    eof=1;
 	  break;
 	}
+#endif
 	if(in_size>max_framesize) max_framesize=in_size; // stats
 	sh_video->timer+=frame_time;
 	if(sh_audio) sh_audio->delay-=frame_time;
@@ -3877,6 +3974,21 @@ if(!sh_video) {
 	// decode:
 	current_module="decode_video";
 //	printf("Decode! %p  %d  \n",start,in_size);
+#ifdef USE_MPDVDNAV
+	if (stream->type==STREAMTYPE_DVDNAV)
+	  {
+	  dvdnav_decodeok=0;
+	  blit_frame=decode_video_still(sh_video,start,in_size,drop_frame,
+		MP_NOPTS_VALUE,1);
+	  if (!blit_frame && in_size>0)
+	    {
+	    if (vd_mpeg2_reset(sh_video,0))
+	      blit_frame=decode_video_still(sh_video,start,in_size,drop_frame,
+		    MP_NOPTS_VALUE,1);
+	    }
+	  if (blit_frame && in_size>0) dvdnav_decodeok=1;
+	  } else
+#endif
 	blit_frame=decode_video(sh_video,start,in_size,drop_frame, MP_NOPTS_VALUE);
 	break;
     }
@@ -4269,8 +4381,10 @@ if(step_sec>0) {
 }
 
 #ifdef USE_DVDNAV
+#ifndef USE_MPDVDNAV
 if (stream->type==STREAMTYPE_DVDNAV && dvd_nav_still)
     dvdnav_stream_sleeping((dvdnav_priv_t*)stream->priv);
+#endif
 #endif
 
 //================= EDL =========================================
@@ -4298,6 +4412,450 @@ if (stream->type==STREAMTYPE_DVDNAV && d
    }
   }
  }
+
+#ifdef USE_MPDVDNAV
+current_module="dvdnav_event";
+if (stream->type==STREAMTYPE_DVDNAV)
+  {
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.stop)
+    {
+    eof=1;
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_MPDVDNAV_StopEvent);
+    } else {
+  int nav_menu = 0;
+
+  if (demuxer->audio->sh && !sh_audio)	// Hot init audio
+    {
+    d_audio=demuxer->audio;
+    sh_audio=d_audio->sh;
+    sh_audio->ds=d_audio;
+
+    current_module="hot init_audio_codec";
+    if(!init_best_audio_codec(sh_audio,audio_codec_list,audio_fm_list))
+      sh_audio=d_audio->sh=NULL; // failed to init :(
+      else
+      inited_flags|=INITED_ACODEC;
+//================ SETUP AUDIO ==========================
+
+    if(sh_audio){
+    //const ao_info_t *info=audio_out->info;
+      current_module="hot af_preinit";
+      ao_data.samplerate=force_srate;
+      ao_data.channels=0;
+      ao_data.format=audio_output_format;
+#if 1
+      // first init to detect best values
+      if(!preinit_audio_filters(sh_audio,
+	    // input:
+            (int)(sh_audio->samplerate*playback_speed),
+	    sh_audio->channels, sh_audio->sample_format,
+	    // output:
+	    &ao_data.samplerate, &ao_data.channels, &ao_data.format)){
+          mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_AudioFilterChainPreinitError);
+          exit_player(MSGTR_Exit_error);
+      }
+#endif
+    current_module="hot ao2_init";
+      if(!(audio_out=init_best_audio_out(audio_driver_list,
+	  0, // plugin flag
+          ao_data.samplerate,
+	  ao_data.channels,
+      ao_data.format,0))){
+        // FAILED:
+	mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CannotInitAO);
+        uninit_player(INITED_ACODEC); // close codec
+	sh_audio=d_audio->sh=NULL; // -> nosound
+      } else {
+	// SUCCESS:
+        inited_flags|=INITED_AO;
+	mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "AO: [%s] %dHz %dch %s (%d bytes per sample)\n",
+            audio_out->info->short_name,
+	    ao_data.samplerate,
+	    ao_data.channels,
+            af_fmt2str_short(ao_data.format),
+	    af_fmt2bits(ao_data.format)/8 );
+        mp_msg(MSGT_CPLAYER,MSGL_V,
+	    "AO: Description: %s\nAO: Author: %s\n",
+	    audio_out->info->name,
+	    audio_out->info->author);
+        if(strlen(audio_out->info->comment) > 0)
+	  mp_msg(MSGT_CPLAYER,MSGL_V,
+	    "AO: Comment: %s\n",
+	    audio_out->info->comment);
+        // init audio filters:
+#if 1
+        current_module="hot af_init";
+	if(!build_afilter_chain(sh_audio, &ao_data)) {
+          mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_NoMatchingFilter);
+	}
+#endif
+      }
+    mixer.audio_out = audio_out;
+    mixer.volstep = volstep;
+    }
+  }
+  if (!sh_audio)
+    {
+    demuxer->audio->id=-1;
+    }	// force hot add audio
+  if (dvdnav_seek_counter && vd_decode_mp_preserve())
+    dvdnav_seek_counter=1;
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.wait)
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_WaitEvent);
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.still_frame)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_StillFrameEvent);
+    ds_free_packs(demuxer->audio);
+    ds_free_packs(demuxer->video);
+//    if (dvdnav_decodeok) dvdnav_seek_counter=1;
+    dvdnav_still=1;				// still mode on
+    }
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.vts_change)
+    {
+    dvdnav_still=0;				// still mode off
+    dvdnav_activate_timer=0;			// clear activate timer
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_VtsChangeEvent);
+    if (((dvdnav_priv_t*)(stream->priv))->vts_domain)
+      {
+      audio_id=((dvdnav_priv_t*)(stream->priv))->alang;		// set new audio id
+      if (((dvdnav_priv_t*)(stream->priv))->slang==128)
+        {
+	dvdsub_id=-2;
+	d_dvdsub->id = dvdsub_id;
+	} else {
+	dvdsub_id=((dvdnav_priv_t*)(stream->priv))->slang;
+	d_dvdsub->id = dvdsub_id;
+	}
+      }		// set new sub id
+    dvdnav_seek_counter=5;
+#ifdef HAVE_NEW_GUI
+    if ( use_gui ) guiGetEvent( guiSetStream,(char *)stream );
+#endif
+    }
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.cell_change)
+    {
+    dvdnav_still=0;				// still mode off
+    dvdnav_activate_timer=0;			// clear activate timer
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_CellChangeEvent);
+
+    if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain))
+      {
+      if (((dvdnav_priv_t*)(stream->priv))->event.cell_really_change)
+        dvdnav_seek_counter=5;
+      } else {
+      if (((dvdnav_priv_t*)(stream->priv))->lasttitle!=
+	    ((dvdnav_priv_t*)(stream->priv))->title)
+	{
+	dvdnav_seek_counter=2;
+	audio_id=((dvdnav_priv_t*)(stream->priv))->alang;		// set new audio id
+	if (((dvdnav_priv_t*)(stream->priv))->slang==128)
+	  {
+	  dvdsub_id=-2;
+	  d_dvdsub->id = dvdsub_id;
+	  } else {
+	  dvdsub_id=((dvdnav_priv_t*)(stream->priv))->slang;
+	  d_dvdsub->id = dvdsub_id;
+	  }
+	}		// set new sub id
+      }
+    ((dvdnav_priv_t*)(stream->priv))->lasttitle=
+	    ((dvdnav_priv_t*)(stream->priv))->title;
+    ((dvdnav_priv_t*)(stream->priv))->lastpart=
+	    ((dvdnav_priv_t*)(stream->priv))->part;
+    ((dvdnav_priv_t*)(stream->priv))->old_vts_domain=
+	    ((dvdnav_priv_t*)(stream->priv))->vts_domain;
+    nav_menu=1;
+#ifdef HAVE_NEW_GUI
+    if ( use_gui ) guiGetEvent( guiSetStream,(char *)stream );
+#endif
+    }
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.spu_clut_change)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_SpuClutChangeEvent);
+    if (vo_spudec) {
+      spudec_update_palette(vo_spudec,
+		((dvdnav_priv_t*)(stream->priv))->event.spu_clut);
+      if(!((dvdnav_priv_t*)(stream->priv))->vts_domain &&
+		(dvdnav_menutype==DVDNAV_MENUTYPE_SPU ||
+		dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX))
+	{
+	spudec_dvdnav_palette(vo_spudec,
+		((dvdnav_priv_t*)(stream->priv))->event.spu_palette);
+	vo_osd_changed(OSDTYPE_SPU);
+	}
+      if (((dvdnav_priv_t*)(stream->priv))->vts_domain)
+        spudec_reset(vo_spudec);
+      }
+    nav_menu=1;
+    }
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.highlight)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_HighlightEvent);
+// dvdnav menu button update
+    nav_menu=1;
+    }
+  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.nav_packet)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_MPDVDNAV_NavPacketEvent);
+    if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain)) nav_menu=1;
+    }
+  ((dvdnav_priv_t*)(stream->priv))->lasttitle=
+	    ((dvdnav_priv_t*)(stream->priv))->title;
+  ((dvdnav_priv_t*)(stream->priv))->lastpart=
+	    ((dvdnav_priv_t*)(stream->priv))->part;
+  ((dvdnav_priv_t*)(stream->priv))->old_vts_domain=
+	    ((dvdnav_priv_t*)(stream->priv))->vts_domain;
+  d_video->eof=0;
+  d_audio->eof=0;
+  stream->eof=0;
+  demuxer->stream->eof=0;
+  demuxer->audio->eof=0;
+  demuxer->video->eof=0;
+
+// dvdnav event clear
+  dvdnav_event_clear((dvdnav_priv_t*)(stream->priv));
+  if (dvdnav_menu_visible && dvdnav_force_menu)
+    {
+    if (!vo_spudec || !spudec_visible(vo_spudec))
+      {
+      dvdnav_highlight_event_t highlight;
+      dvdnav_get_highlight((dvdnav_priv_t*)(stream->priv),&highlight,1);
+      dvdnav_box_area(highlight.sx,highlight.sy,highlight.ex,highlight.ey,
+	    1,0x7f,0x7f); /* set box button area & on */
+      vo_osd_changed(OSDTYPE_DVDNAV);
+      } else {
+      dvdnav_box_area(0,0,0,0,0,0x00,0x00);
+      vo_osd_changed(OSDTYPE_DVDNAV);
+      dvdnav_menu_visible=0;
+      }
+    }
+  if (dvdnav_activate_timer)
+    {
+// reset activate? (>1 sec)
+    if (GetTimer() > dvdnav_activate_timer + 1000000) nav_menu=1;
+    }
+  if (nav_menu)
+    {
+    if (dvdnav_color_spu_flg==-1)
+      {
+      dvdnav_color_spu_flg=0;
+      if (dvdnav_color_spu && video_out)
+	{
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_YUVSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_YUV;
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_YUYSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_YUY;
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_RGBSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_RGB;
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_BGRSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_BGR;
+	if (!dvdnav_color_spu_flg)
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_MPDVDNAV_NoColorSpu);
+	}
+      }
+    dvdnav_menu_visible=0;
+    if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain))
+      {
+// vts0 - set menu button
+      dvdnav_highlight_event_t highlight;
+      dvdnav_get_highlight((dvdnav_priv_t*)(stream->priv),&highlight,1);	/* get spu botton area & palette */
+      if (vo_spudec && (dvdnav_menutype==DVDNAV_MENUTYPE_SPU ||
+	    dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX))
+	{
+	if(d_dvdsub->id!=((dvdnav_priv_t*)(stream->priv))->menu_sid)
+	  {
+	  d_dvdsub->id=((dvdnav_priv_t*)(stream->priv))->menu_sid;
+	  spudec_reset(vo_spudec);
+	  }
+	spudec_dvdnav_mode(vo_spudec, 1, dvdnav_color_spu_flg);	/* spu menu button on */
+	spudec_dvdnav_area(vo_spudec,highlight.sx,highlight.sy,highlight.ex,
+		highlight.ey,highlight.palette); /* set spu button area & palette */
+	vo_osd_changed(OSDTYPE_SPU);
+	}
+	if (dvdnav_menutype==DVDNAV_MENUTYPE_BOX ||
+	    dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX)
+	{
+	dvdnav_box_area(highlight.sx,highlight.sy,highlight.ex,highlight.ey,
+		1,0x7f,0x7f); /* set box button area & on */
+	vo_osd_changed(OSDTYPE_DVDNAV);
+	}
+      if (dvdnav_menutype==DVDNAV_MENUTYPE_SPU && highlight.buttonN)
+        dvdnav_menu_visible=1;
+      } else {
+// reset spu info
+      global_sub_size = 0;
+      int i;
+      for (i = 0; i < SUB_SOURCES; i++)
+        global_sub_indices[i] = -1;
+//        global_sub_quiet_osd_hack = 1;
+      global_sub_indices[SUB_SOURCE_DEMUX] = global_sub_size; // the global # of the first demux-specific sub.
+      global_sub_size += dvdnav_number_of_subs((dvdnav_priv_t*)(stream->priv));
+      if (dvdnav_menutype==DVDNAV_MENUTYPE_BOX ||
+	dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX)
+	{
+	dvdnav_box_area(0,0,0,0,0,0x00,0x00);	/* nav box button off */
+	vo_osd_changed(OSDTYPE_DVDNAV);
+	}
+      spudec_dvdnav_mode(vo_spudec, 0, 0);	/* spu menu button off */
+      spudec_reset(vo_spudec);
+      }
+    }
+  if (dvdnav_seek_counter && (!((dvdnav_priv_t*)(stream->priv))->stillok))
+    {
+    sw_muted=1;
+    if (sh_audio && sw_muted != mixer.muted) mixer_mute(&mixer);
+    if (((dvdnav_priv_t*)(stream->priv))->aspect!=
+	    ((dvdnav_priv_t*)(stream->priv))->lastaspect && sh_video)
+      {
+      switch (((dvdnav_priv_t*)(stream->priv))->aspect)		/* set current ascpet */
+        {
+	case 0 :	// 4:3
+	  {
+#ifdef USE_MPDVDNAV_TRACE
+	  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: set aspect 4:3\n");
+#endif
+	  movie_aspect = (float) 4 / 3;
+	  mpcodecs_config_vo (sh_video, sh_video->disp_w, sh_video->disp_h, 0);
+	  break;
+	  }
+        case 3 :	// FIXME: 16:9???
+	case 2 :	// 16:9
+	  {
+#ifdef USE_MPDVDNAV_TRACE
+        if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: set aspect 16:9\n");
+#endif
+	movie_aspect = (float) 16 / 9;
+	mpcodecs_config_vo (sh_video, sh_video->disp_w, sh_video->disp_h, 0);
+	break;
+	}
+      default:
+        {
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: unknow aspect %i\n",
+		((dvdnav_priv_t*)(stream->priv))->aspect);
+#endif
+	break;
+	}
+      }
+    ((dvdnav_priv_t*)(stream->priv))->lastaspect=
+	    ((dvdnav_priv_t*)(stream->priv))->aspect;
+    }
+    if (sh_audio)
+      {
+      audio_id=((dvdnav_priv_t*)(stream->priv))->alang;
+      int v = demuxer_switch_audio(demuxer, audio_id);
+      } // switch audio channel
+    rel_seek_secs = 0.00;
+    abs_seek_pos = 0;
+    if(sh_video) sh_video->pts=0.0f;
+    ((dvdnav_priv_t*)(stream->priv))->lockseek=1;
+    if(demux_seek(demuxer,rel_seek_secs,0.0,abs_seek_pos))
+      {	// demuxer reset???
+      rel_seek_secs = 0.00;
+      abs_seek_pos = 0;
+      if(sh_video)
+	{
+	current_module="seek_video_reset";
+	resync_video_stream(sh_video);
+	if(vo_config_count) video_out->control(VOCTRL_RESET,NULL);
+	sh_video->pts=0.0f;
+	sh_video->num_frames=0;
+	sh_video->num_frames_decoded=0;
+	sh_video->timer=0.0f;
+	sh_video->stream_delay=0.0f;
+	frame_time_remaining=0;
+	audio_delay=0.0f;
+	sh_video->timer=0;
+	audio_delay += sh_video->stream_delay;
+	}
+      if(sh_audio)
+        {
+	audio_delay -= sh_audio->stream_delay;
+	sh_audio->delay=-audio_delay;
+	current_module="seek_audio_reset";
+	audio_out->reset();
+	resync_audio_stream(sh_audio);
+	} // stop audio, throwing away buffered data
+      if(vo_spudec) spudec_reset(vo_spudec);
+      }
+    current_module="demuxer_update_time_pts";
+    if (((dvdnav_priv_t*)(stream->priv))->vts_domain)
+      {
+      demuxer_update_time_pts(demuxer,
+		((dvdnav_priv_t*)(stream->priv))->final_pts,
+		((dvdnav_priv_t*)(stream->priv))->tlen*2048);
+      } else {
+      demuxer_update_time_pts(demuxer, 0.0, 0);
+      }
+    ((dvdnav_priv_t*)(stream->priv))->lockseek=0;
+    }
+  if (dvdnav_seek_counter) dvdnav_seek_counter--; else sw_muted=0;
+#ifdef HAVE_NEW_GUI
+  if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain) && sh_video)
+    {
+    dvdnav_window_orig_width=sh_video->disp_w;		/* set original video window size */
+    dvdnav_window_orig_height=sh_video->disp_h;		/* required on calculate mouse position */
+    dvdnav_mouse((dvdnav_priv_t*)(stream->priv));	/* process mouse positon: set menu button */
+    }
+#endif
+// play to new title
+  if (dvdnav_go_title>0)
+    {
+    dvdnav_title_play((dvdnav_t*)((dvdnav_priv_t*)(stream->priv))->dvdnav,
+	    dvdnav_go_title);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_audio=
+	    dvdnav_go_spu=0;
+    }
+// play to new chapter
+  if (dvdnav_go_part>0)
+    {
+    dvdnav_part_play((dvdnav_t*)((dvdnav_priv_t*)(stream->priv))->dvdnav,
+	    ((dvdnav_priv_t*)(stream->priv))->title, dvdnav_go_part);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_audio=
+	    dvdnav_go_spu=0;
+    }
+// go main DVD menu
+  if (dvdnav_go_menu>0)
+    {
+    dvdnav_menu_call((dvdnav_t*)((dvdnav_priv_t*)(stream->priv))->dvdnav,
+	    DVD_MENU_Root);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_audio=
+	    dvdnav_go_spu=0;
+    }
+  if (dvdnav_go_menu_force)
+    {
+    dvdnav_menu_force((dvdnav_priv_t*)(stream->priv));	/* go main menu with skip intro */
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_menu_force=
+	    dvdnav_go_audio=dvdnav_go_spu=0;
+    }
+// switch audio channel
+  if (dvdnav_go_audio)
+    {
+    if (sh_audio) demuxer_switch_audio(demuxer, audio_id);
+    dvdnav_go_audio=0;
+    }
+// switch spu subtitle
+  if (dvdnav_go_spu)
+    {
+    d_dvdsub->id = dvdsub_id;
+    if (vo_spudec)
+      {
+      spudec_reset(vo_spudec);
+      dvdnav_go_spu--;
+      }
+    }
+  }
+}
+
+#endif
 
 //================= Keyboard events, SEEKing ====================
 
@@ -4919,6 +5477,7 @@ if (stream->type==STREAMTYPE_DVDNAV && d
           /* be silent about this one */
                 break;
           }
+#ifndef USE_MPDVDNAV
       case DVDNAV_HIGHLIGHT: {
           dvdnav_highlight_event_t *hevent = (dvdnav_highlight_event_t*)(dvdnav_event->details);
           if (!hevent) {
@@ -4957,6 +5516,7 @@ if (stream->type==STREAMTYPE_DVDNAV && d
             usec_sleep(1000); /* 1ms */
           }
           dvdnav_stream_sleep(dvdnav_priv,still_event->length);
+//    	  dvdnav_still_skip(dvdnav_priv->dvdnav); // don't let dvdnav stall on this image
         break;
         }
       case DVDNAV_STOP: {
@@ -5022,6 +5582,7 @@ if (stream->type==STREAMTYPE_DVDNAV && d
                 d_audio->id=dvdsub_id=aid_temp;
                 if(sh_audio) resync_audio_stream(sh_audio);
         }
+        if(sh_audio) resync_audio_stream(sh_audio);
 
         break;
       }
@@ -5066,8 +5627,8 @@ if (stream->type==STREAMTYPE_DVDNAV && d
         mp_msg(MSGT_FIXME, MSGL_FIXME, MSGTR_DvdnavNavSeekDone);
         break;
         }
+#endif
       }
-
       // free the dvdnav event
       free(dvdnav_event->details);
       free(dvdnav_event);
@@ -5075,10 +5636,32 @@ if (stream->type==STREAMTYPE_DVDNAV && d
     }
     case MP_CMD_DVDNAV: {
       dvdnav_priv_t * dvdnav_priv=(dvdnav_priv_t*)stream->priv;
-
       /* ignore these events if we're not in dvd_nav mode */
       if (stream->type != STREAMTYPE_DVDNAV) break;
-
+#ifdef USE_MPDVDNAV
+      switch (cmd->args[0].v.i) {
+        case MP_CMD_DVDNAV_SELECT:
+	  if (vo_spudec && (dvdnav_menutype==DVDNAV_MENUTYPE_SPU ||
+	    dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX))
+	    {
+	    dvdnav_highlight_event_t highlight;
+	    dvdnav_get_highlight((dvdnav_priv_t*)(stream->priv),&highlight,2);	/* get spu botton area & palette */
+	    spudec_dvdnav_area(vo_spudec,highlight.sx,highlight.sy,highlight.ex,
+		highlight.ey,highlight.palette); /* set spu button area & palette */
+	    vo_osd_changed(OSDTYPE_SPU);
+	    dvdnav_activate_timer=GetTimer();
+	    }
+        case MP_CMD_DVDNAV_UP:
+        case MP_CMD_DVDNAV_DOWN:
+        case MP_CMD_DVDNAV_LEFT:
+        case MP_CMD_DVDNAV_RIGHT:
+        case MP_CMD_DVDNAV_MENU:
+	  dvdnav_menu_action(dvdnav_priv, cmd->args[0].v.i);
+	  break;
+        default:
+//          mp_msg(MSGT_CPLAYER, MSGL_V, "Weird DVD Nav cmd %d\n",cmd->args[0].v.i);
+          break; }
+#else
       switch (cmd->args[0].v.i) {
         case MP_CMD_DVDNAV_UP:
           dvdnav_upper_button_select(dvdnav_priv->dvdnav);
@@ -5103,6 +5686,7 @@ if (stream->type==STREAMTYPE_DVDNAV && d
           mp_msg(MSGT_CPLAYER, MSGL_V, "Weird DVD Nav cmd %d\n",cmd->args[0].v.i);
           break;
       }
+#endif
       break;
     }
 #endif /* USE_DVDNAV */
@@ -5221,7 +5805,7 @@ while (next_edl_record)
     next_edl_record = next_edl_record->next;
 
 }
-if ((user_muted | edl_muted) != mixer.muted) mixer_mute(&mixer);
+if ((user_muted | edl_muted | sw_muted) != mixer.muted) mixer_mute(&mixer);
 
   rel_seek_secs=0;
   abs_seek_pos=0;
@@ -5229,6 +5813,11 @@ if ((user_muted | edl_muted) != mixer.mu
   current_module=NULL;
   loop_seek=0;
 }
+#ifdef USE_EDL
+if (sh_audio && !user_muted && !edl_muted && !sw_muted && mixer.muted) mixer_mute(&mixer);
+#else
+if (sh_audio && sw_muted != mixer.muted) mixer_mute(&mixer);
+#endif
 
 #ifdef HAVE_NEW_GUI
       if(use_gui){
@@ -5326,6 +5915,14 @@ if(vo_config_count && vo_spudec) {
   }
   
   /* detect wether the sub has changed or not */
+#ifdef USE_MPDVDNAV
+ /* still image now process data, because next frame reseek: delete read spu packet */
+  if(stream->type==STREAMTYPE_DVDNAV)
+    {
+    if(dvdnav_still || !((dvdnav_priv_t*)(stream->priv))->vts_domain)
+	spudec_heartbeat(vo_spudec,90000*sh_video->timer);
+    }
+#endif
   if(spudec_changed(vo_spudec))
     vo_osd_changed(OSDTYPE_SPU);
   current_module=NULL;
diff -r 448a43f59a37 spudec.c
--- a/spudec.c	Sun Apr 30 17:12:20 2006 +0200
+++ b/spudec.c	Sun Apr 30 17:14:32 2006 +0200
@@ -91,6 +91,53 @@ typedef struct {
   int spu_changed;
   unsigned int forced_subs_only;     /* flag: 0=display all subtitle, !0 display only forced subtitles */
   unsigned int is_forced_sub;         /* true if current subtitle is a forced subtitle */
+#ifdef USE_MPDVDNAV
+  packet_t *last_packet;
+  unsigned int widthuv, heightuv, strideuv;
+  unsigned int start_coluv, end_coluv;
+  unsigned int start_rowuv, end_rowuv;
+  size_t image_sizeuv;
+  size_t scaled_image_sizeuv;
+  size_t image_sizeyuy;
+
+  unsigned int scaled_frame_widthuv, scaled_frame_heightuv;
+  unsigned int scaled_start_coluv, scaled_start_rowuv;
+  unsigned int scaled_widthuv, scaled_heightuv, scaled_strideuv;
+  unsigned char *scaled_imageu;
+  unsigned char *scaled_imagev;
+  unsigned char *scaled_aimageuv;
+
+  unsigned int hpalette[4];
+  unsigned int halpha[4];
+  unsigned int hcuspal[4];
+
+  unsigned char *imageu;		/* u value from yUv */
+  unsigned char *imagev;		/* v value from yuV*/
+  unsigned char *aimageuv;		/* alpha with uv*/
+  unsigned char *imageyuy;		/* yuy2 */
+  unsigned char *aimageyuy;		/* alpha with yuy2*/
+  unsigned int strideyuy;
+
+  int dvdnav_color_spu;		/* flag: 0 = grayscale SPU, 1 = YUV color SPU 2 = RGB 3 = BGR */
+
+  int dvdnav_menu;		/* flag: 0=normal subtitle, 1=dvdnav menu */
+  unsigned int dvdnav_sx;	/* dvdnav menu item box */
+  unsigned int dvdnav_ex;
+  unsigned int dvdnav_sy;
+  unsigned int dvdnav_ey;
+  unsigned int dvdnav_modify;	/* dvdnav menu item box is modify */
+  uint32_t     dvdnav_palette;	/* dvdnav menu button palette */
+  unsigned int dvdnav_x0;	/* dvdnav menu item draw_alpha coordinates */
+  unsigned int dvdnav_y0;
+  unsigned int dvdnav_w;
+  unsigned int dvdnav_h;
+  unsigned char *dvdnav_image;	/* dvdnav menu item image */
+  unsigned char *dvdnav_aimage;	/* dvdnav menu item alpha */
+  unsigned int dvdnav_stride;
+  unsigned int dvdnav_allocated;
+  unsigned int dvdnav_scalex;
+  unsigned int dvdnav_scaley;
+#endif
 } spudec_handle_t;
 
 static void spudec_queue_packet(spudec_handle_t *this, packet_t *packet)
@@ -210,11 +257,138 @@ static inline void spudec_cut_image(spud
   } else {
     mp_msg(MSGT_SPUDEC, MSGL_FATAL, "Fatal: update_spu: malloc requested %d bytes\n", 2 * this->stride * this->height);
   }
-}
+#ifdef USE_MPDVDNAV
+  unsigned char *imageu;
+  unsigned char *imagev;
+  switch (this->dvdnav_color_spu) {
+    case DVDNAV_SPU_YUV:
+    case DVDNAV_SPU_YUY:
+      for (fy = 0; fy < this->image_sizeuv && !this->aimageuv[fy]; fy++);
+      for (ly = this->strideuv * this->heightuv-1;
+        ly && !this->aimageuv[ly]; ly--);
+      first_y = fy / this->strideuv;
+      last_y = ly / this->strideuv;
+      this->start_rowuv += first_y;
+      // Some subtitles trigger this condition
+      if (last_y + 1 > first_y ) {
+	  this->heightuv = last_y - first_y +1;
+        } else {
+	  this->heightuv = 0;
+	  this->image_sizeuv = 0;
+	  return;
+        }
+      //  printf("new h %d new start %d (sz %d st %d)---\n\n", this->height, this->start_row, this->image_size, this->stride);
+      imageu = malloc(3 * this->strideuv * this->heightuv);
+      if(imageu){
+        this->image_sizeuv = this->strideuv * this->heightuv;
+        imagev = imageu + this->image_sizeuv;
+        aimage = imagev + this->image_sizeuv;
+        memcpy(imageu, this->imageu + this->strideuv * first_y,
+	    this->image_sizeuv);
+        memcpy(imagev, this->imagev + this->strideuv * first_y,
+	    this->image_sizeuv);
+        memcpy(aimage, this->aimageuv + this->strideuv * first_y,
+	    this->image_sizeuv);
+        free(this->imageu);
+        this->imageu = imageu;
+        this->imagev = imagev;
+        this->aimageuv = aimage;
+        } else {
+          mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+	    "Fatal: update_spu: malloc requested %d bytes\n",
+	    3 * this->strideuv * this->height);
+        }
+      break;
+    case DVDNAV_SPU_RGB:
+    case DVDNAV_SPU_BGR:
+      this->image_sizeuv = this->stride * this->height;
+      imageu = malloc(2 * this->stride * this->height);
+      if(imageu){
+        imagev = imageu + this->image_size;
+        memcpy(imageu, this->imageu + this->stride * first_y, this->image_size);
+        memcpy(imagev, this->imagev + this->stride * first_y, this->image_size);
+        free(this->imageu);
+        this->imageu = imageu;
+        this->imagev = imagev;
+        this->aimageuv = NULL;
+      } else {
+        mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+	    "Fatal: update_spu: malloc requested %d bytes\n",
+	    2 * this->stride * this->height);
+      }
+      break;
+    }
+#endif
+}
+
+#ifdef USE_MPDVDNAV
+void spu_yuv_to_rgb(unsigned int y,unsigned int u,unsigned int v,
+    unsigned int *r,unsigned int *g,unsigned int *b)
+{
+int ty,tu,tv;
+int tr,tg,tb;
+ty=y;tv=u;tu=v;
+tr = (298*(ty-16)+408*(tv-128))/256;
+tg = (298*(ty-16)-100*(tu-128)-208*(tv-128))/256;
+tb = (298*(ty-16)+516*(tu-128))/256;
+if(tr>255) tr=255; if(tr<0) tr=0;
+if(tg>255) tg=255; if(tg<0) tg=0;
+if(tb>255) tb=255; if(tb<0) tb=0;
+*r=tr; *g=tg; *b=tb;
+return;
+}
+
+static void spudec_process_fill(spudec_handle_t *this, int x, int y, int len,
+    unsigned char color, unsigned char coloru, unsigned char colorv,
+    unsigned char alpha)
+{
+unsigned int corrx, corry, corrl;
+if (this->stride-x-len<0) return;
+if (len<0) return;
+switch (this->dvdnav_color_spu)
+  {
+  case DVDNAV_SPU_YUV:
+  case DVDNAV_SPU_YUY:
+    corry=y & 0x01;
+    corrx=x & 0x01;
+    corrl=len & 0x01;
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    memset(this->imageu + (y-corry)/2 * this->strideuv + (x+corrx)/2, coloru,
+	(len-corrl)/2);
+    memset(this->imagev + (y-corry)/2 * this->strideuv + (x+corrx)/2, colorv,
+	(len-corrl)/2);
+    memset(this->aimageuv + (y-corry)/2 * this->strideuv + (x+corrx)/2, alpha,
+	(len-corrl)/2);
+    break;
+  case DVDNAV_SPU_RGB:
+  case DVDNAV_SPU_BGR:
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->imageu + y * this->stride + x, coloru, len);
+    memset(this->imagev + y * this->stride + x, colorv, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    break;
+  default:
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    break;
+}
+}
+#endif
 
 static void spudec_process_data(spudec_handle_t *this, packet_t *packet)
 {
   unsigned int cmap[4], alpha[4];
+#ifdef USE_MPDVDNAV
+  unsigned int thpalette[4], thalpha[4];
+  unsigned int hcmap[4], halpha[4];
+  unsigned int cmapu[4], cmapv[4];
+  unsigned int hcmapu[4], hcmapv[4];
+  unsigned int control_start;
+  unsigned int current_nibble[2];
+  unsigned int ty,tu,tv,tr,tg,tb;
+  int deinterlace_oddness;
+#endif
   unsigned int i, x, y;
 
   this->scaled_frame_width = 0;
@@ -226,6 +400,20 @@ static void spudec_process_data(spudec_h
   this->height = packet->height;
   this->width = packet->width;
   this->stride = packet->stride;
+#ifdef USE_MPDVDNAV
+  this->strideuv = packet->stride;
+  control_start = packet->control_start;
+  current_nibble[0]=packet->current_nibble[0];
+  current_nibble[1]=packet->current_nibble[1];
+  deinterlace_oddness=packet->deinterlace_oddness;
+
+  this->start_coluv = packet->start_col/2;
+  this->end_coluv = packet->end_col/2;
+  this->start_rowuv = packet->start_row/2;
+  this->end_rowuv = packet->end_row/2;
+  this->heightuv = packet->height/2+1;
+  this->widthuv = packet->width/2+1;
+#endif
   for (i = 0; i < 4; ++i) {
     alpha[i] = mkalpha(packet->alpha[i]);
     if (alpha[i] == 0)
@@ -241,7 +429,93 @@ static void spudec_process_data(spudec_h
 	cmap[i] = 256 - alpha[i];
     }
   }
-
+#ifdef USE_MPDVDNAV
+  if (this->dvdnav_menu)
+    for (i = 0; i < 4; ++i) {	/* use button palette */
+      thalpha[i]=(this->dvdnav_palette >> ((3-i)*4)) & 0x0f;
+      thpalette[i]=(this->dvdnav_palette >> (16+(3-i)*4)) & 0x0f;
+      halpha[i] = mkalpha(thalpha[i]);
+      hcmap[i] = ((this->global_palette[thpalette[i]] >> 16) & 0xff);
+      if (alpha[i] == 0) {cmap[i] = 0; cmapu[i] = 0; cmapv[i] = 0;} else {
+        if (cmap[i] + alpha[i] > 255)
+	  cmap[i] = 256 - alpha[i];
+	  switch (this->dvdnav_color_spu) {
+	    case DVDNAV_SPU_YUV:
+	    case DVDNAV_SPU_YUY:
+	      cmap[i] = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);	// Y
+	      cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	      cmapu[i] = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);	// u
+	      cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	      cmapv[i] = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);	// v
+	      cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_RGB:
+	      ty = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      cmap[i] = tr;
+	      cmapu[i] = tg;
+	      cmapv[i] = tb;
+	      cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	      cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	      cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_BGR:
+	      ty = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      cmap[i] = tb;
+	      cmapu[i] = tg;
+	      cmapv[i] = tr;
+	      cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	      cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	      cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+	      break;
+	    }
+	  }
+      if (halpha[i] == 0) {hcmap[i] = 0; hcmapu[i] = 0; hcmapv[i] = 0;} else {
+        if (hcmap[i] + halpha[i] > 255)
+	  hcmap[i] = 256 - halpha[i];
+	  switch (this->dvdnav_color_spu) {
+	    case DVDNAV_SPU_YUV:
+	    case DVDNAV_SPU_YUY:
+              hcmap[i] = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+	      hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+              hcmapu[i] = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+	      hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+              hcmapv[i] = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	      hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_RGB:
+              ty = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      hcmap[i] = tr;
+	      hcmapu[i] = tg;
+	      hcmapv[i] = tb;
+	      hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+	      hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+	      hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_BGR:
+              ty = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      hcmap[i] = tb;
+	      hcmapu[i] = tg;
+	      hcmapv[i] = tr;
+	      hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+	      hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+	      hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+	      break;
+	    }
+	}
+      }
+#endif
   if (this->image_size < this->stride * this->height) {
     if (this->image != NULL) {
       free(this->image);
@@ -255,6 +529,59 @@ static void spudec_process_data(spudec_h
   }
   if (this->image == NULL)
     return;
+#ifdef USE_MPDVDNAV
+if(this->dvdnav_menu && this->dvdnav_color_spu)
+  {
+  if (this->imageyuy)
+    {
+    free(this->imageyuy);
+    this->imageyuy=NULL;
+    this->aimageyuy=NULL;
+    }
+  if (this->dvdnav_color_spu==DVDNAV_SPU_YUV ||
+	this->dvdnav_color_spu==DVDNAV_SPU_YUY)
+    {
+    if (this->image_sizeuv < this->strideuv * this->heightuv)
+      {
+      if (this->imageu != NULL)
+        {
+        free(this->imageu);
+        this->image_sizeuv = 0;
+        }
+      this->imageu = malloc(3 * this->strideuv * this->heightuv);
+      if (this->imageu)
+        {
+        this->image_sizeuv = this->strideuv * this->heightuv;
+        this->imagev = this->imageu + this->image_sizeuv;
+        this->aimageuv = this->imagev + this->image_sizeuv;
+	}
+      }
+    memset(this->imageu,0,3 * this->strideuv * this->heightuv);
+    } else {
+    if (this->image_sizeuv < this->stride * this->height)
+      {
+      if (this->imageu != NULL)
+	{
+	free(this->imageu);
+	this->image_sizeuv = 0;
+        }
+      this->imageu = malloc(2 * this->stride * this->height);
+      if (this->imageu)
+        {
+        this->image_sizeuv = this->stride * this->height;
+        this->imagev = this->imageu + this->image_sizeuv;
+        this->aimageuv = this->imagev + this->image_sizeuv;
+	}
+      }
+    memset(this->imageu,0,2 * this->stride * this->height);
+    }
+  if (this->imageu == NULL) return;
+  } else {
+  if (this->imageu) free(this->imageu);
+  this->imageu=NULL;
+  this->image_sizeuv=0;
+  }
+#endif
 
   /* Kludge: draw_alpha needs width multiple of 8. */
   if (this->width < this->stride)
@@ -289,8 +616,91 @@ static void spudec_process_data(spudec_h
     if (len > this->width - x || len == 0)
       len = this->width - x;
     /* FIXME have to use palette and alpha map*/
+#ifdef USE_MPDVDNAV
+    if (this->dvdnav_menu)
+      {
+      if (this->start_row+y>=this->dvdnav_sy &&
+	    this->start_row+y<=this->dvdnav_ey)
+	{
+	if (this->start_col+x>=this->dvdnav_sx &&
+		this->start_col+x+len<=this->dvdnav_ex)
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    len,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	else if(this->start_col+x<this->dvdnav_sx &&
+		this->start_col+x+len>this->dvdnav_sx &&
+		this->start_col+x+len<=this->dvdnav_ex)
+	  {
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    this->dvdnav_sx-this->start_col-x,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_sx-this->start_col,
+		    y,
+		    len+this->start_col+x-this->dvdnav_sx,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	  }
+	else if(this->start_col+x<this->dvdnav_sx &&
+		this->start_col+x+len>this->dvdnav_sx &&
+		this->start_col+x+len>this->dvdnav_ex)
+	  {
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    this->dvdnav_sx-this->start_col-x,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_sx-this->start_col,
+		    y,
+		    this->dvdnav_ex-this->dvdnav_sx,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_ex-this->start_col,
+		    y,
+		    x+len+this->start_col-this->dvdnav_ex,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  }
+	else if(this->start_col+x>=this->dvdnav_sx &&
+		this->start_col+x<this->dvdnav_ex &&
+		this->start_col+x+len>this->dvdnav_ex)
+	  {
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    this->dvdnav_ex-this->start_col-x,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_ex-this->start_col,
+		    y,
+		    len+this->start_col+x-this->dvdnav_ex,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  }
+	  else
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    len,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	} else
+	spudec_process_fill(this,
+		    x,
+		    y,
+		    len,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+      }
+      else
+      {
+      memset(this->image + y * this->stride + x, cmap[color], len);
+      memset(this->aimage + y * this->stride + x, alpha[color], len);
+      }
+#else
     memset(this->image + y * this->stride + x, cmap[color], len);
     memset(this->aimage + y * this->stride + x, alpha[color], len);
+#endif
     x += len;
     if (x >= this->width) {
       next_line(packet);
@@ -298,7 +708,14 @@ static void spudec_process_data(spudec_h
       ++y;
     }
   }
+#ifdef USE_MPDVDNAV
+  packet->control_start = control_start;
+  packet->current_nibble[0]=current_nibble[0];
+  packet->current_nibble[1]=current_nibble[1];
+  packet->deinterlace_oddness=deinterlace_oddness;
+#endif
   spudec_cut_image(this);
+//printf("spudec_process_data: w: %i h: %i end\n",this->height,this->width);
 }
 
 
@@ -377,6 +794,9 @@ static void spudec_process_control(spude
 	end_pts = UINT_MAX;
 	display = 1;
 	this->is_forced_sub=~0; // current subtitle is forced
+#ifdef USE_MPDVDNAV
+	mp_msg(MSGT_CPLAYER,MSGL_DBG2,"spu packet cmd=00\n");
+#endif
 	break;
       case 0x01:
 	/* Start display */
@@ -385,6 +805,9 @@ static void spudec_process_control(spude
 	end_pts = UINT_MAX;
 	display = 1;
 	this->is_forced_sub=0;
+#ifdef USE_MPDVDNAV
+	mp_msg(MSGT_CPLAYER,MSGL_DBG2,"spu packet cmd=01\n");
+#endif
 	break;
       case 0x02:
 	/* Stop display */
@@ -583,6 +1006,7 @@ void spudec_reset(void *this)	// called 
   spu->now_pts = 0;
   spu->end_pts = 0;
   spu->packet_size = spu->packet_offset = 0;
+//  if (spu->last_packet) {printf("free4\n");spudec_free_packet(spu->last_packet); spu->last_packet=NULL;}
 }
 
 void spudec_heartbeat(void *this, unsigned int pts100)
@@ -590,6 +1014,9 @@ void spudec_heartbeat(void *this, unsign
   spudec_handle_t *spu = (spudec_handle_t*) this;
   spu->now_pts = pts100;
 
+#ifdef USE_MPDVDNAV
+  if(spu->queue_head) spu->queue_head->start_pts=0;
+#endif
   while (spu->queue_head != NULL && pts100 >= spu->queue_head->start_pts) {
     packet_t *packet = spudec_dequeue_packet(spu);
     spu->start_pts = packet->start_pts;
@@ -597,17 +1024,35 @@ void spudec_heartbeat(void *this, unsign
     if (spu->auto_palette)
       compute_palette(spu, packet);
     spudec_process_data(spu, packet);
+#ifdef USE_MPDVDNAV
+    if (spu->dvdnav_menu)
+      {
+      if(spu->last_packet)
+	{
+	spudec_free_packet(spu->last_packet);
+	}
+      spu->last_packet=packet;
+      } else
+#endif
     spudec_free_packet(packet);
     spu->spu_changed = 1;
   }
 }
 
+
 int spudec_visible(void *this){
     spudec_handle_t *spu = (spudec_handle_t *)this;
+#ifdef USE_MPDVDNAV
+    if(!spu) return 0;
+    if (spu->dvdnav_menu && spu->height > 0)
+      {
+      if(spu->height>0) spu->end_pts=UINT_MAX;
+      return 1;
+      }
+#endif
     int ret=(spu->start_pts <= spu->now_pts &&
 	     spu->now_pts < spu->end_pts &&
 	     spu->height > 0);
-//    printf("spu visible: %d  \n",ret);
     return ret;
 }
 
@@ -619,12 +1064,92 @@ void spudec_set_forced_subs_only(void * 
   }
 }
 
-void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
 {
     spudec_handle_t *spu = (spudec_handle_t *)this;
     if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts && spu->image)
     {
-	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+#ifdef USE_MPDVDNAV
+    if (spu->dvdnav_menu)
+      {	/* spu menu mode? */
+      switch (spu->dvdnav_color_spu)
+	{
+	case DVDNAV_SPU_YUV:
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_Y,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	  draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_U,
+		    spu->imageu,
+		    spu->aimageuv,
+		    spu->strideuv);
+	  draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_V,
+		    spu->imagev,
+		    spu->aimageuv,
+		    spu->strideuv);
+	  break;
+	case DVDNAV_SPU_YUY:
+	  if (!spu->imageyuy) spudec_create_yuy(spu,0);
+	  if (spu->imageyuy) draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width*2,
+		    spu->height/2,
+		    DEST_PLANES_YUYV,
+		    spu->imageyuy,
+		    spu->aimageyuy,
+		    spu->strideyuy);
+	  break;
+	case DVDNAV_SPU_RGB:
+	case DVDNAV_SPU_BGR:
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width, spu->height,
+		    DEST_PLANES_BR,
+		    spu->imagev,
+		    spu->aimage,
+		    spu->stride);
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_G,
+		    spu->imageu,
+		    spu->aimage,
+		    spu->stride);
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_RB,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	  break;
+	default:
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_Y,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	}
+      } else
+#endif
+	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,DEST_PLANES_Y,
 		   spu->image, spu->aimage, spu->stride);
 	spu->spu_changed = 0;
     }
@@ -736,6 +1261,121 @@ static void scale_image(int x, int y, sc
   }
 }
 
+#ifdef USE_MPDVDNAV
+static void scale_image_uv(int x, int y, scale_pixel* table_x,
+	scale_pixel* table_y, spudec_handle_t * spu)
+{
+  int alpha[4];
+  int coloru[4];
+  int colorv[4];
+  unsigned int scale[4];
+  int base = table_y[y].position * spu->strideuv + table_x[x].position;
+  int scaled = y * spu->scaled_strideuv + x;
+  alpha[0] = canon_alpha(spu->aimageuv[base]);
+  alpha[1] = canon_alpha(spu->aimageuv[base + 1]);
+  alpha[2] = canon_alpha(spu->aimageuv[base + spu->strideuv]);
+  alpha[3] = canon_alpha(spu->aimageuv[base + spu->strideuv + 1]);
+  coloru[0] = spu->imageu[base];
+  coloru[1] = spu->imageu[base + 1];
+  coloru[2] = spu->imageu[base + spu->strideuv];
+  coloru[3] = spu->imageu[base + spu->strideuv + 1];
+  colorv[0] = spu->imagev[base];
+  colorv[1] = spu->imagev[base + 1];
+  colorv[2] = spu->imagev[base + spu->strideuv];
+  colorv[3] = spu->imagev[base + spu->strideuv + 1];
+// FIXME: color hack!!!
+//  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
+//  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
+//  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
+//  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
+  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * 0x100;
+  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * 0x100;
+  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * 0x100;
+  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * 0x100;
+  spu->scaled_imageu[scaled] =
+	(coloru[0] * scale[0] +
+	coloru[1] * scale[1] +
+	coloru[2] * scale[2] +
+	coloru[3] * scale[3])>>24;
+  spu->scaled_imagev[scaled] =
+	(colorv[0] * scale[0] +
+	colorv[1] * scale[1] +
+	colorv[2] * scale[2] +
+	colorv[3] * scale[3])>>24;
+  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
+  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
+  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
+  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
+  spu->scaled_aimageuv[scaled] =
+	(scale[0] + scale[1] + scale[2] + scale[3]) >> 16;
+  if (spu->scaled_aimageuv[scaled]){
+    spu->scaled_aimageuv[scaled] = 256 - spu->scaled_aimageuv[scaled];
+    if(spu->scaled_aimageuv[scaled] + spu->scaled_imageu[scaled] > 255)
+      spu->scaled_imageu[scaled] = 256 - spu->scaled_aimageuv[scaled];
+    if(spu->scaled_aimageuv[scaled] + spu->scaled_imagev[scaled] > 255)
+      spu->scaled_imagev[scaled] = 256 - spu->scaled_aimageuv[scaled];
+  }
+}
+
+static void scale_image_rgb(int x, int y, scale_pixel* table_x, scale_pixel* table_y, spudec_handle_t * spu)
+{
+  int alpha[4];
+  int colorr[4];
+  int colorg[4];
+  int colorb[4];
+  unsigned int scale[4];
+  int base = table_y[y].position * spu->stride + table_x[x].position;
+  int scaled = y * spu->scaled_stride + x;
+  alpha[0] = canon_alpha(spu->aimage[base]);
+  alpha[1] = canon_alpha(spu->aimage[base + 1]);
+  alpha[2] = canon_alpha(spu->aimage[base + spu->stride]);
+  alpha[3] = canon_alpha(spu->aimage[base + spu->stride + 1]);
+  colorr[0] = spu->image[base];
+  colorr[1] = spu->image[base + 1];
+  colorr[2] = spu->image[base + spu->stride];
+  colorr[3] = spu->image[base + spu->stride + 1];
+  colorg[0] = spu->imageu[base];
+  colorg[1] = spu->imageu[base + 1];
+  colorg[2] = spu->imageu[base + spu->stride];
+  colorg[3] = spu->imageu[base + spu->stride + 1];
+  colorb[0] = spu->imagev[base];
+  colorb[1] = spu->imagev[base + 1];
+  colorb[2] = spu->imagev[base + spu->stride];
+  colorb[3] = spu->imagev[base + spu->stride + 1];
+  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
+  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
+  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
+  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
+  spu->scaled_image[scaled] =
+	(colorr[0] * scale[0] +
+	colorr[1] * scale[1] +
+	colorr[2] * scale[2] +
+	colorr[3] * scale[3])>>24;
+  spu->scaled_imageu[scaled] =
+	(colorg[0] * scale[0] +
+	colorg[1] * scale[1] +
+	colorg[2] * scale[2] +
+	colorg[3] * scale[3])>>24;
+  spu->scaled_imagev[scaled] =
+	(colorb[0] * scale[0] +
+	colorb[1] * scale[1] +
+	colorb[2] * scale[2] +
+	colorb[3] * scale[3])>>24;
+  spu->scaled_aimage[scaled] =
+	(scale[0] + scale[1] + scale[2] + scale[3]) >> 16;
+  if (spu->scaled_aimage[scaled]){
+    spu->scaled_aimage[scaled] = 256 - spu->scaled_aimage[scaled];
+    if(spu->scaled_aimage[scaled] + spu->scaled_image[scaled] > 255)
+      spu->scaled_image[scaled] = 256 - spu->scaled_aimage[scaled];
+    if(spu->scaled_aimage[scaled] + spu->scaled_imageu[scaled] > 255)
+      spu->scaled_imageu[scaled] = 256 - spu->scaled_aimage[scaled];
+    if(spu->scaled_aimage[scaled] + spu->scaled_imagev[scaled] > 255)
+      spu->scaled_imagev[scaled] = 256 - spu->scaled_aimage[scaled];
+  }
+}
+
+#endif
+
 void sws_spu_image(unsigned char *d1, unsigned char *d2, int dw, int dh, int ds,
 	unsigned char *s1, unsigned char *s2, int sw, int sh, int ss)
 {
@@ -762,11 +1402,208 @@ void sws_spu_image(unsigned char *d1, un
 	sws_freeContext(ctx);
 }
 
-void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+#ifdef USE_MPDVDNAV
+void spudec_create_yuy(void *this, int spu_scaled)
+{
+spudec_handle_t *spu = this;
+unsigned char *dptr;
+unsigned char *daptr;
+unsigned char *sptry;
+unsigned char *sptru;
+unsigned char *sptrv;
+unsigned char *saptr;
+unsigned char *saptruv;
+int y,x;
+
+if (spu_scaled) {
+  spu->strideyuy=spu->scaled_stride*2;
+  spu->imageyuy=malloc(spu->strideyuy*(spu->height+2)*2);
+  memset(spu->imageyuy,0,spu->strideyuy*(spu->height+2)*2);
+  spu->aimageyuy=spu->imageyuy+spu->strideyuy*spu->scaled_height;
+  for(y=0;y<spu->scaled_height;y++) {
+    dptr=spu->imageyuy+y*spu->strideyuy;
+    daptr=spu->aimageyuy+y*spu->strideyuy;
+    sptry=spu->image+y*spu->scaled_stride;
+    sptru=spu->imageu+y/2*spu->scaled_strideuv;
+    sptrv=spu->imagev+y/2*spu->scaled_strideuv;
+    saptr=spu->aimage+y*spu->scaled_stride;
+    saptruv=spu->aimageuv+y/2*spu->scaled_strideuv;
+    for(x=0;x<spu->scaled_widthuv-1;x++) {
+      *dptr++=*sptry++;
+      *dptr++=*sptrv++;
+      *dptr++=*sptry++;
+      *dptr++=*sptru++;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv++;
+      } }
+  } else {
+  spu->strideyuy=spu->stride*2;
+  spu->imageyuy=malloc(spu->strideyuy*(spu->height+2)*2);
+  memset(spu->imageyuy,0,spu->strideyuy*(spu->height+2)*2);
+  spu->aimageyuy=spu->imageyuy+spu->strideyuy*spu->height;
+  for(y=0;y<spu->height;y++) {
+    dptr=spu->imageyuy+y*spu->strideyuy;
+    daptr=spu->aimageyuy+y*spu->strideyuy;
+    sptry=spu->image+y*spu->stride;
+    sptru=spu->imageu+y/2*spu->strideuv;
+    sptrv=spu->imagev+y/2*spu->strideuv;
+    saptr=spu->aimage+y*spu->stride;
+    saptruv=spu->aimageuv+y/2*spu->strideuv;
+    for(x=0;x<spu->widthuv-1;x++) {
+      *dptr++=*sptry++;
+      *dptr++=*sptrv++;
+      *dptr++=*sptry++;
+      *dptr++=*sptru++;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv++;
+      } }
+  }
+}
+
+void sws_spu_image_uv(unsigned char *du, unsigned char *dv, unsigned char *d2,
+	int dw, int dh, int ds, unsigned char *su, unsigned char *sv,
+	unsigned char *s2, int sw, int sh, int ss)
+{
+struct SwsContext *ctx;
+static SwsFilter filter;
+static int firsttime = 1;
+static float oldvar;
+int i;
+
+if (!firsttime && oldvar != spu_gaussvar) sws_freeVec(filter.lumH);
+if (firsttime)
+    {
+    filter.lumH = filter.lumV =
+	filter.chrH = filter.chrV = sws_getGaussianVec(spu_gaussvar, 3.0);
+    sws_normalizeVec(filter.lumH, 1.0);
+    firsttime = 0;
+    oldvar = spu_gaussvar;
+    }
+
+ctx=sws_getContext(sw, sh, IMGFMT_Y800, dw, dh, IMGFMT_Y800, SWS_GAUSS, &filter, NULL, NULL);
+sws_scale(ctx,&su,&ss,0,sh,&du,&ds);
+sws_scale(ctx,&sv,&ss,0,sh,&dv,&ds);
+for (i=ss*sh-1; i>=0; i--)
+  if (!s2[i]) s2[i] = 255; //else s2[i] = 1;
+sws_scale(ctx,&s2,&ss,0,sh,&d2,&ds);
+for (i=ds*dh-1; i>=0; i--)
+  if (d2[i]==0) d2[i] = 1;
+  else if (d2[i]==255) d2[i] = 0;
+sws_freeContext(ctx);
+}
+
+void sws_spu_image_rgb(unsigned char *dr, unsigned char *dg, unsigned char *db,
+	unsigned char *d2, int dw, int dh, int ds,
+	unsigned char *sr,unsigned char *sg,unsigned char *sb,
+	unsigned char *s2, int sw, int sh, int ss)
+{
+struct SwsContext *ctx;
+static SwsFilter filter;
+static int firsttime = 1;
+static float oldvar;
+int i;
+
+if (!firsttime && oldvar != spu_gaussvar) sws_freeVec(filter.lumH);
+if (firsttime)
+    {
+    filter.lumH = filter.lumV =
+	filter.chrH = filter.chrV = sws_getGaussianVec(spu_gaussvar, 3.0);
+    sws_normalizeVec(filter.lumH, 1.0);
+    firsttime = 0;
+    oldvar = spu_gaussvar;
+    }
+
+ctx=sws_getContext(sw, sh, IMGFMT_Y800, dw, dh, IMGFMT_Y800, SWS_GAUSS, &filter, NULL, NULL);
+sws_scale(ctx,&sr,&ss,0,sh,&dr,&ds);
+sws_scale(ctx,&sg,&ss,0,sh,&dg,&ds);
+sws_scale(ctx,&sb,&ss,0,sh,&db,&ds);
+for (i=ss*sh-1; i>=0; i--) if (!s2[i]) s2[i] = 255; //else s2[i] = 1;
+sws_scale(ctx,&s2,&ss,0,sh,&d2,&ds);
+for (i=ds*dh-1; i>=0; i--)
+    if (d2[i]==0) d2[i] = 1;
+    else if (d2[i]==255) d2[i] = 0;
+sws_freeContext(ctx);
+}
+
+#undef max
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#undef min
+#define min(x,y) ((x) < (y) ? (x) : (y))
+
+void spudec_dvdnav_mode(void *this, int mode, int cflg)
+{		/* set/clear spu menu mode */
+spudec_handle_t *spu = (spudec_handle_t *)this;
+if (!spu) return;
+spu->dvdnav_menu=mode;
+spu->dvdnav_color_spu=cflg;
+if (!spu->dvdnav_menu && spu->last_packet)
+  {
+  spudec_free_packet(spu->last_packet);
+  spu->last_packet=NULL;
+  }
+return;
+}
+
+void spudec_dvdnav_area(void *this, uint16_t sx, uint16_t sy, uint16_t ex,
+	uint16_t ey, uint32_t palette)
+{
+spudec_handle_t *spu = this;
+if (!spu) return;
+if (spu->dvdnav_sx==min(sx,ex) &&
+	spu->dvdnav_ex==max(sx,ex) &&
+	spu->dvdnav_sy==min(sy,ey) &&
+	spu->dvdnav_ey==max(sy,ey) &&
+	spu->dvdnav_palette==palette) return;
+spu->dvdnav_sx=min(sx,ex);		/* set spu button area, palette & on */
+spu->dvdnav_ex=max(sx,ex);
+spu->dvdnav_sy=min(sy,ey);
+spu->dvdnav_ey=max(sy,ey);
+spu->dvdnav_palette=palette;
+spu->dvdnav_modify=1;
+if (spu->dvdnav_menu && spu->last_packet)
+  {
+  if (spu->auto_palette)
+    compute_palette(spu, spu->last_packet);
+  spudec_process_data(spu, spu->last_packet);
+  }
+return;
+}
+
+void spudec_dvdnav_palette(void *this, uint32_t palette)
+{
+spudec_handle_t *spu = this;
+if (!spu) return;
+spu->dvdnav_palette=palette;		/* set spu button palette */
+return;
+}
+#endif
+
+void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
 {
   spudec_handle_t *spu = (spudec_handle_t *)me;
   scale_pixel *table_x;
   scale_pixel *table_y;
+#ifdef USE_MPDVDNAV
+  if (spu->dvdnav_menu) {
+    switch (spu->dvdnav_color_spu)
+      {
+      case DVDNAV_SPU_YUV:
+      case DVDNAV_SPU_YUY:
+        spudec_draw_scaled_yuv(me,dxs,dys,draw_alpha);
+	return;
+	break;
+      case DVDNAV_SPU_RGB:
+      case DVDNAV_SPU_BGR:
+        spudec_draw_scaled_rgb(me,dxs,dys,draw_alpha);
+	return;
+	break;
+      }
+    }
+#endif
 
   if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
 
@@ -779,7 +1616,7 @@ void spudec_draw_scaled(void *me, unsign
 	|| (spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
       if (spu->image)
       {
-	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,DEST_PLANES_Y,
 		   spu->image, spu->aimage, spu->stride);
 	spu->spu_changed = 0;
       }
@@ -1086,7 +1923,7 @@ nothing_to_do:
 	  break;
 	}
 	draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
-		   spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
+		    DEST_PLANES_Y,spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
 	spu->spu_changed = 0;
       }
     }
@@ -1097,6 +1934,1217 @@ nothing_to_do:
         spu->start_pts, spu->end_pts, spu->now_pts);
   }
 }
+
+#ifdef USE_MPDVDNAV
+void spudec_draw_scaled_yuv(void *me, unsigned int dxs, unsigned int dys,
+	void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
+{
+  spudec_handle_t *spu = (spudec_handle_t *)me;
+  scale_pixel *table_x;
+  scale_pixel *table_y;
+  unsigned int scalex = 0;
+  unsigned int scaley = 0;
+
+  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
+
+    // check if only forced subtitles are requested
+    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){
+	return;}
+
+    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 ||
+	    spu->orig_frame_height == 0 ||
+	    (spu->orig_frame_width == dxs && spu->orig_frame_height == dys)))
+      {
+      if (spu->image)
+	{
+	if (spu->dvdnav_color_spu==DVDNAV_SPU_YUY) {
+	  if (!spu->imageyuy) spudec_create_yuy(spu,0);
+	  if (spu->imageyuy) draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width*2,
+		    spu->heightuv*2,
+		    DEST_PLANES_YUYV,
+		    spu->imageyuy,
+		    spu->aimageyuy,
+		    spu->strideyuy);
+	  } else {
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_Y,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	  if(spu->dvdnav_color_spu && spu->imageu && spu->aimageuv)
+	    draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_U,
+		    spu->imageu,
+		    spu->aimageuv,
+		    spu->strideuv);
+	  if(spu->dvdnav_color_spu && spu->imagev && spu->aimageuv)
+	    draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_V,
+		    spu->imagev,
+		    spu->aimageuv,
+		    spu->strideuv);
+  }
+	spu->spu_changed = 0;
+}
+    } else {
+      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys)
+	{	/* Resizing is needed */
+	/* scaled_x = scalex * x / 0x100
+	   scaled_y = scaley * y / 0x100
+	   order of operations is important because of rounding. */
+	scalex = 0x100 * dxs / spu->orig_frame_width;
+	scaley = 0x100 * dys / spu->orig_frame_height;
+
+	spu->scaled_start_col = spu->start_col * scalex / 0x100;
+	spu->scaled_start_row = spu->start_row * scaley / 0x100;
+	spu->scaled_width = spu->width * scalex / 0x100;
+	spu->scaled_height = spu->height * scaley / 0x100;
+	spu->scaled_start_coluv = spu->start_coluv * scalex / 0x100;
+	spu->scaled_start_rowuv = spu->start_rowuv * scaley / 0x100;
+	spu->scaled_widthuv = spu->widthuv * scalex / 0x100;
+	spu->scaled_heightuv = spu->heightuv * scaley / 0x100;
+	/* Kludge: draw_alpha needs width multiple of 8 */
+	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
+	spu->scaled_strideuv = (spu->scaled_widthuv + 7) & ~7;
+	if (spu->scaled_image_size < spu->scaled_stride *
+		(spu->scaled_height+2))
+{
+	  if (spu->scaled_image)
+	    {
+	    free(spu->scaled_image);
+	    spu->scaled_image_size = 0;
+}
+	  spu->scaled_image = malloc(2 * spu->scaled_stride *
+		(spu->scaled_height+2));
+	  if (spu->scaled_image)
+{
+	    memset(spu->scaled_image,0,
+		    2 * spu->scaled_stride * (spu->scaled_height+2));
+	    spu->scaled_image_size = spu->scaled_stride *
+		    (spu->scaled_height+2);
+	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
+}
+	}
+	if (spu->scaled_image_sizeuv < spu->scaled_strideuv *
+		(spu->scaled_heightuv+2))
+{
+	  if (spu->scaled_imageu)
+	    {
+	    free(spu->scaled_imageu);
+	    spu->scaled_image_sizeuv = 0;
+	    }
+	  spu->scaled_imageu = malloc(3 * spu->scaled_strideuv *
+		(spu->scaled_height+2));
+	  if (spu->scaled_imageu)
+	    {
+	    memset(spu->scaled_imageu,0,3 * spu->scaled_strideuv *
+		    (spu->scaled_height+2));
+	    spu->scaled_image_sizeuv = spu->scaled_strideuv *
+		    (spu->scaled_heightuv+2);
+	    spu->scaled_imagev = spu->scaled_imageu +
+		    spu->scaled_image_sizeuv;
+	    spu->scaled_aimageuv = spu->scaled_imagev +
+		    spu->scaled_image_sizeuv;
+	    }
+	}
+	if (spu->scaled_image) {
+	  unsigned int x, y;
+	  if (spu->scaled_width <= 1 || spu->scaled_height <= 1) {
+	    goto nothing_to_do;
+	    }
+	  if (spu->scaled_widthuv <= 1 || spu->scaled_heightuv <= 1) {
+	    goto nothing_to_do;
+	    }
+	switch(spu_aamode&15)
+	  {
+	  case 4:
+	    sws_spu_image(spu->scaled_image, spu->scaled_aimage,
+		  spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+		  spu->image, spu->aimage, spu->width, spu->height, spu->stride);
+	    sws_spu_image_uv(spu->scaled_imageu, spu->scaled_imagev,
+		  spu->scaled_aimageuv, spu->scaled_widthuv,
+		  spu->scaled_heightuv, spu->scaled_strideuv,
+		  spu->imageu, spu->imagev, spu->aimageuv,
+		  spu->widthuv, spu->heightuv, spu->strideuv);
+	    break;
+	  case 3:
+	    table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
+	    table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
+	    if (!table_x || !table_y)
+	      {
+	      mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+		    "Fatal: spudec_draw_scaled: calloc failed\n");
+	      }
+	    scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
+	    scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
+	    for (y = 0; y < spu->scaled_height; y++)
+	      for (x = 0; x < spu->scaled_width; x++)
+		scale_image(x, y, table_x, table_y, spu);
+	    free(table_x);
+	    free(table_y);
+	    table_x = calloc(spu->scaled_widthuv, sizeof(scale_pixel));
+	    table_y = calloc(spu->scaled_heightuv, sizeof(scale_pixel));
+	    if (!table_x || !table_y) {
+	      mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+		    "Fatal: spudec_draw_scaled: calloc failed\n");
+	      }
+	    scale_table(0, 0, spu->widthuv - 1, spu->scaled_widthuv - 1,
+		table_x);
+	    scale_table(0, 0, spu->heightuv - 1, spu->scaled_heightuv - 1,
+		table_y);
+	    for (y = 0; y < spu->scaled_heightuv; y++)
+	      for (x = 0; x < spu->scaled_widthuv; x++)
+		scale_image_uv(x, y, table_x, table_y, spu);
+	    free(table_x);
+	    free(table_y);
+	    break;
+	  case 0:
+	  /* no antialiasing */
+	  for (y = 0; y < spu->scaled_height; ++y)
+	    {
+	    int unscaled_y = y * 0x100 / scaley;
+	    int strides = spu->stride * unscaled_y;
+	    int scaled_strides = spu->scaled_stride * y;
+	    for (x = 0; x < spu->scaled_width; ++x)
+	      {
+	      int unscaled_x = x * 0x100 / scalex;
+	      spu->scaled_image[scaled_strides + x] =
+		    spu->image[strides + unscaled_x];
+	      spu->scaled_aimage[scaled_strides + x] =
+		    spu->aimage[strides + unscaled_x];
+	      }
+	    }
+	  for (y = 0; y < spu->scaled_heightuv; ++y)
+	    {
+	    int unscaled_y = y * 0x100 / scaley;
+	    int strides = spu->strideuv * unscaled_y;
+	    int scaled_strides = spu->scaled_strideuv * y;
+	    for (x = 0; x < spu->scaled_widthuv; ++x)
+	      {
+	      int unscaled_x = x * 0x100 / scalex;
+	      spu->scaled_imageu[scaled_strides + x] =
+		    spu->imageu[strides + unscaled_x];
+	      spu->scaled_imagev[scaled_strides + x] =
+		    spu->imagev[strides + unscaled_x];
+	      spu->scaled_aimageuv[scaled_strides + x] =
+		    spu->aimageuv[strides + unscaled_x];
+	      }
+	    }
+	    break;
+	  case 1:
+	  {
+	    /* Intermediate antialiasing. */
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const unsigned int unscaled_top =
+		    y * spu->orig_frame_height / dys;
+	      unsigned int unscaled_bottom =
+		    (y + 1) * spu->orig_frame_height / dys;
+	      if (unscaled_bottom >= spu->height)
+		unscaled_bottom = spu->height - 1;
+	      for (x = 0; x < spu->scaled_width; ++x)
+	        {
+		const unsigned int unscaled_left =
+			x * spu->orig_frame_width / dxs;
+		unsigned int unscaled_right =
+			(x + 1) * spu->orig_frame_width / dxs;
+		unsigned int color = 0;
+		unsigned int alpha = 0;
+		unsigned int walkx, walky;
+		unsigned int base, tmp;
+		if (unscaled_right >= spu->width)
+		  unscaled_right = spu->width - 1;
+		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx)
+		    {
+		    base = walky * spu->stride + walkx;
+		    tmp = canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		    }
+		base = y * spu->scaled_stride + x;
+		spu->scaled_image[base] = alpha ? color / alpha : 0;
+		spu->scaled_aimage[base] =
+		  alpha * (1 + unscaled_bottom - unscaled_top) *
+		  (1 + unscaled_right - unscaled_left);
+		/* spu->scaled_aimage[base] =
+		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	    for (y = 0; y < spu->scaled_heightuv; ++y) {
+	      const unsigned int unscaled_top = y *
+		    (spu->orig_frame_height/2) / (dys/2);
+	      unsigned int unscaled_bottom = (y + 1) *
+		    (spu->orig_frame_height/2) / (dys/2);
+	      if (unscaled_bottom >= spu->heightuv)
+		unscaled_bottom = spu->heightuv - 1;
+	      for (x = 0; x < spu->scaled_widthuv; ++x) {
+		const unsigned int unscaled_left = x *
+			(spu->orig_frame_width/2) / (dxs/2);
+		unsigned int unscaled_right = (x + 1) *
+			(spu->orig_frame_width/2) / (dxs/2);
+		unsigned int coloru = 0;
+		unsigned int colorv = 0;
+		unsigned int alpha = 0;
+		unsigned int walkx, walky;
+		unsigned int base, tmp;
+		if (unscaled_right >= spu->widthuv)
+		  unscaled_right = spu->widthuv - 1;
+		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx)
+		    {
+		    base = walky * spu->strideuv + walkx;
+		    tmp = canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		    }
+		base = y * spu->scaled_strideuv + x;
+		spu->scaled_imageu[base] = alpha ? coloru / alpha : 0;
+		spu->scaled_imagev[base] = alpha ? colorv / alpha : 0;
+		spu->scaled_aimageuv[base] =
+		  alpha * (1 + unscaled_bottom - unscaled_top) *
+		  (1 + unscaled_right - unscaled_left);
+		/* spu->scaled_aimage[base] =
+		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+		if (spu->scaled_aimageuv[base]) {
+		  spu->scaled_aimageuv[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimageuv[base];
+		}
+	      }
+	    }
+	  }
+	  break;
+	  case 2:
+	  {
+	    /* Best antialiasing.  Very slow. */
+	    /* Any pixel (x, y) represents pixels from the original
+	       rectangular region comprised between the columns
+	       unscaled_y and unscaled_y + 0x100 / scaley and the rows
+	       unscaled_x and unscaled_x + 0x100 / scalex
+
+	       The original rectangular region that the scaled pixel
+	       represents is cut in 9 rectangular areas like this:
+
+	       +---+-----------------+---+
+	       | 1 |        2        | 3 |
+	       +---+-----------------+---+
+	       |   |                 |   |
+	       | 4 |        5        | 6 |
+	       |   |                 |   |
+	       +---+-----------------+---+
+	       | 7 |        8        | 9 |
+	       +---+-----------------+---+
+
+	       The width of the left column is at most one pixel and
+	       it is never null and its right column is at a pixel
+	       boundary.  The height of the top row is at most one
+	       pixel it is never null and its bottom row is at a
+	       pixel boundary. The width and height of region 5 are
+	       integral values.  The width of the right column is
+	       what remains and is less than one pixel.  The height
+	       of the bottom row is what remains and is less than
+	       one pixel.
+
+	       The row above 1, 2, 3 is unscaled_y.  The row between
+	       1, 2, 3 and 4, 5, 6 is top_low_row.  The row between 4,
+	       5, 6 and 7, 8, 9 is (unsigned int)unscaled_y_bottom.
+	       The row beneath 7, 8, 9 is unscaled_y_bottom.
+
+	       The column left of 1, 4, 7 is unscaled_x.  The column
+	       between 1, 4, 7 and 2, 5, 8 is left_right_column.  The
+	       column between 2, 5, 8 and 3, 6, 9 is (unsigned
+	       int)unscaled_x_right.  The column right of 3, 6, 9 is
+	       unscaled_x_right. */
+	    const double inv_scalex = (double) 0x100 / scalex;
+	    const double inv_scaley = (double) 0x100 / scaley;
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const double unscaled_y = y * inv_scaley;
+	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
+	      const unsigned int top_low_row = MIN(unscaled_y_bottom, unscaled_y + 1.0);
+	      const double top = top_low_row - unscaled_y;
+	      const unsigned int height = unscaled_y_bottom > top_low_row
+		? (unsigned int) unscaled_y_bottom - top_low_row
+		: 0;
+	      const double bottom = unscaled_y_bottom > top_low_row
+		? unscaled_y_bottom - floor(unscaled_y_bottom)
+		: 0.0;
+	      for (x = 0; x < spu->scaled_width; ++x) {
+		const double unscaled_x = x * inv_scalex;
+		const double unscaled_x_right = unscaled_x + inv_scalex;
+		const unsigned int left_right_column =
+			MIN(unscaled_x_right, unscaled_x + 1.0);
+		const double left = left_right_column - unscaled_x;
+		const unsigned int width = unscaled_x_right > left_right_column
+		  ? (unsigned int) unscaled_x_right - left_right_column
+		  : 0;
+		const double right = unscaled_x_right > left_right_column
+		  ? unscaled_x_right - floor(unscaled_x_right)
+		  : 0.0;
+		double color = 0.0;
+		double alpha = 0.0;
+		double tmp;
+		unsigned int base;
+		/* Now use these informations to compute a good alpha,
+                   and lightness.  The sum is on each of the 9
+                   region's surface and alpha and lightness.
+
+		  transformed alpha = sum(surface * alpha) / sum(surface)
+		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
+		*/
+		/* 1: top left part */
+		base = spu->stride * (unsigned int) unscaled_y;
+		tmp = left * top *
+		    canon_alpha(spu->aimage[base + (unsigned int) unscaled_x]);
+		alpha += tmp;
+		color += tmp * spu->image[base + (unsigned int) unscaled_x];
+		/* 2: top center part */
+		if (width > 0) {
+		  unsigned int walkx;
+		  for (walkx = left_right_column;
+			walkx < (unsigned int) unscaled_x_right;
+			++walkx)
+		    {
+		    base = spu->stride * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		  }
+		}
+		/* 3: top right part */
+		if (right > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y +
+			(unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  color += tmp * spu->image[base];
+		}
+		/* 4: center left part */
+		if (height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->stride * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		  }
+		}
+		/* 5: center part */
+		if (width > 0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    unsigned int walkx;
+		    base = spu->stride * walky;
+		    for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimage[base + walkx]);
+		      alpha += tmp;
+		      color += tmp * spu->image[base + walkx];
+		    }
+		  }
+		}
+		/* 6: center right part */
+		if (right > 0.0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->stride * walky +
+			    (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		  }
+		}
+		/* 7: bottom left part */
+		if (bottom > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  color += tmp * spu->image[base];
+		}
+		/* 8: bottom center part */
+		if (width > 0 && bottom > 0.0) {
+		  unsigned int walkx;
+		  base = spu->stride * (unsigned int) unscaled_y_bottom;
+		  for (walkx = left_right_column;
+			walkx < (unsigned int) unscaled_x_right;
+			++walkx)
+		    {
+		    tmp = /* 1.0 * */ bottom *
+			canon_alpha(spu->aimage[base + walkx]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base + walkx];
+		  }
+		}
+		/* 9: bottom right part */
+		if (right > 0.0 && bottom > 0.0) {
+		  base = spu->stride * (unsigned int)
+			unscaled_y_bottom + (unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  color += tmp * spu->image[base];
+		}
+		/* Finally mix these transparency and brightness information suitably */
+		base = spu->scaled_stride * y + x;
+		spu->scaled_image[base] = alpha > 0 ? color / alpha : 0;
+		spu->scaled_aimage[base] = alpha * scalex * scaley / 0x10000;
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	    for (y = 0; y < spu->scaled_heightuv; ++y) {
+	      const double unscaled_y = y * inv_scaley;
+	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
+	      const unsigned int top_low_row =
+			MIN(unscaled_y_bottom, unscaled_y + 1.0);
+	      const double top = top_low_row - unscaled_y;
+	      const unsigned int height = unscaled_y_bottom > top_low_row
+		? (unsigned int) unscaled_y_bottom - top_low_row
+		: 0;
+	      const double bottom = unscaled_y_bottom > top_low_row
+		? unscaled_y_bottom - floor(unscaled_y_bottom)
+		: 0.0;
+	      for (x = 0; x < spu->scaled_widthuv; ++x) {
+		const double unscaled_x = x * inv_scalex;
+		const double unscaled_x_right = unscaled_x + inv_scalex;
+		const unsigned int left_right_column =
+			MIN(unscaled_x_right, unscaled_x + 1.0);
+		const double left = left_right_column - unscaled_x;
+		const unsigned int width = unscaled_x_right > left_right_column
+		  ? (unsigned int) unscaled_x_right - left_right_column
+		  : 0;
+		const double right = unscaled_x_right > left_right_column
+		  ? unscaled_x_right - floor(unscaled_x_right)
+		  : 0.0;
+		double coloru = 0.0;
+		double colorv = 0.0;
+		double alpha = 0.0;
+		double tmp;
+		unsigned int base;
+		/* Now use these informations to compute a good alpha,
+                   and lightness.  The sum is on each of the 9
+                   region's surface and alpha and lightness.
+
+		  transformed alpha = sum(surface * alpha) / sum(surface)
+		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
+		*/
+		/* 1: top left part */
+		base = spu->strideuv * (unsigned int) unscaled_y;
+		tmp = left * top *
+		    canon_alpha(spu->aimageuv[base + (unsigned int) unscaled_x]);
+		alpha += tmp;
+		coloru += tmp * spu->imageu[base + (unsigned int) unscaled_x];
+		colorv += tmp * spu->imagev[base + (unsigned int) unscaled_x];
+		/* 2: top center part */
+		if (width > 0) {
+		  unsigned int walkx;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx)
+		    {
+		    base = spu->strideuv * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		  }
+		}
+		/* 3: top right part */
+		if (right > 0.0) {
+		  base = spu->strideuv * (unsigned int) unscaled_y +
+			(unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(spu->aimageuv[base]);
+		  alpha += tmp;
+		  coloru += tmp * spu->imageu[base];
+		  colorv += tmp * spu->imagev[base];
+		}
+		/* 4: center left part */
+		if (height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->strideuv * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		  }
+		}
+		/* 5: center part */
+		if (width > 0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    unsigned int walkx;
+		    base = spu->strideuv * walky;
+		    for (walkx = left_right_column;
+			walkx < (unsigned int) unscaled_x_right;
+			++walkx)
+		    {
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimageuv[base + walkx]);
+		      alpha += tmp;
+		      coloru += tmp * spu->imageu[base + walkx];
+		      colorv += tmp * spu->imagev[base + walkx];
+		    }
+		  }
+		}
+		/* 6: center right part */
+		if (right > 0.0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->strideuv * walky +
+			    (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		  }
+		}
+		/* 7: bottom left part */
+		if (bottom > 0.0) {
+		  base = spu->strideuv * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(spu->aimageuv[base]);
+		  alpha += tmp;
+		  coloru += tmp * spu->imageu[base];
+		  colorv += tmp * spu->imagev[base];
+		}
+		/* 8: bottom center part */
+		if (width > 0 && bottom > 0.0) {
+		  unsigned int walkx;
+		  base = spu->strideuv * (unsigned int) unscaled_y_bottom;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		    tmp = /* 1.0 * */ bottom * canon_alpha(spu->aimageuv[base + walkx]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base + walkx];
+		    colorv += tmp * spu->imagev[base + walkx];
+		  }
+		}
+		/* 9: bottom right part */
+		if (right > 0.0 && bottom > 0.0) {
+		  base = spu->strideuv * (unsigned int) unscaled_y_bottom +
+			(unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(spu->aimageuv[base]);
+		  alpha += tmp;
+		  coloru += tmp * spu->imageu[base];
+		  colorv += tmp * spu->imagev[base];
+		}
+		/* Finally mix these transparency and brightness information suitably */
+		base = spu->scaled_strideuv * y + x;
+		spu->scaled_imageu[base] = alpha > 0 ? coloru / alpha : 0;
+		spu->scaled_imagev[base] = alpha > 0 ? colorv / alpha : 0;
+		spu->scaled_aimageuv[base] = alpha * scalex * scaley / 0x10000;
+		if (spu->scaled_aimageuv[base]) {
+		  spu->scaled_aimageuv[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimageuv[base];
+		}
+	      }
+	    }
+	  }
+	  }
+nothing_to_do:
+	  /* Kludge: draw_alpha needs width multiple of 8. */
+	  if (spu->scaled_width < spu->scaled_stride)
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      memset(spu->scaled_aimage + y * spu->scaled_stride +
+		    spu->scaled_width, 0,
+		    spu->scaled_stride - spu->scaled_width);
+	    }
+	  spu->scaled_frame_width = dxs;
+	  spu->scaled_frame_height = dys;
+	  if (spu->scaled_widthuv < spu->scaled_strideuv)
+	    for (y = 0; y < spu->scaled_heightuv; ++y) {
+	      memset(spu->scaled_aimageuv + y * spu->scaled_stride +
+		    spu->scaled_widthuv, 0,
+		    spu->scaled_strideuv - spu->scaled_widthuv);
+	    }
+	  spu->scaled_frame_widthuv = dxs/2;
+	  spu->scaled_frame_heightuv = dys/2;
+	}
+      }
+      if (spu->scaled_image){
+        switch (spu_alignment) {
+        case 0:
+          spu->scaled_start_row = dys*sub_pos/100;
+	  if (spu->scaled_start_row + spu->scaled_height > dys)
+	    spu->scaled_start_row = dys - spu->scaled_height;
+          spu->scaled_start_rowuv = (dys/2)*sub_pos/100;
+	  if (spu->scaled_start_rowuv + spu->scaled_heightuv > (dys/2))
+	    spu->scaled_start_rowuv = (dys/2) - spu->scaled_heightuv;
+	  break;
+	case 1:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height/2;
+          if (sub_pos < 50) {
+	    if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+	  } else {
+	    if (spu->scaled_start_row + spu->scaled_height > dys)
+	      spu->scaled_start_row = dys - spu->scaled_height;
+	  }
+          spu->scaled_start_rowuv = (dys/2)*sub_pos/100 - spu->scaled_heightuv/2;
+          if (sub_pos < 50) {
+	    if (spu->scaled_start_rowuv < 0) spu->scaled_start_rowuv = 0;
+	  } else {
+	    if (spu->scaled_start_rowuv + spu->scaled_heightuv > (dys/2))
+	      spu->scaled_start_rowuv = (dys/2) - spu->scaled_heightuv;
+	  }
+	  break;
+        case 2:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height;
+	  if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+          spu->scaled_start_rowuv = (dys/2)*sub_pos/100 - spu->scaled_heightuv;
+	  if (spu->scaled_start_rowuv < 0) spu->scaled_start_rowuv = 0;
+	  break;
+	}
+	if (spu->dvdnav_color_spu==DVDNAV_SPU_YUY) {
+	  if (!spu->imageyuy) spudec_create_yuy(spu,1);
+	  if (spu->imageyuy) draw_alpha(spu->scaled_start_col,
+		    spu->scaled_start_row,
+		    spu->scaled_width*2,
+		    spu->scaled_height,
+		    DEST_PLANES_YUYV,
+		    spu->imageyuy,
+		    spu->aimageyuy,
+		    spu->strideyuy);
+	  } else {
+	  draw_alpha(spu->scaled_start_col,
+		    spu->scaled_start_row,
+		    spu->scaled_width,
+		    spu->scaled_height,
+		    DEST_PLANES_Y,
+		    spu->scaled_image,
+		    spu->scaled_aimage,
+		    spu->scaled_stride);
+	  draw_alpha(spu->scaled_start_coluv,
+		    spu->scaled_start_rowuv,
+		    spu->scaled_widthuv,
+		    spu->scaled_heightuv,
+		    DEST_PLANES_U,
+		    spu->scaled_imageu,
+		    spu->scaled_aimageuv,
+		    spu->scaled_strideuv);
+	  draw_alpha(spu->scaled_start_coluv,
+		    spu->scaled_start_rowuv,
+		    spu->scaled_widthuv,
+		    spu->scaled_heightuv,
+		    DEST_PLANES_V,
+		    spu->scaled_imagev,
+		    spu->scaled_aimageuv,
+		    spu->scaled_strideuv);
+	  }
+	spu->spu_changed = 0;
+      }
+    }
+  }
+  else
+  {
+    mp_msg(MSGT_SPUDEC,MSGL_DBG2,
+	"SPU not displayed: start_pts=%d  end_pts=%d  now_pts=%d\n",
+        spu->start_pts, spu->end_pts, spu->now_pts);
+  }
+}
+
+void spudec_draw_scaled_rgb(void *me, unsigned int dxs, unsigned int dys,
+	void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
+{
+  spudec_handle_t *spu = (spudec_handle_t *)me;
+  scale_pixel *table_x;
+  scale_pixel *table_y;
+  unsigned int scalex = 0;
+  unsigned int scaley = 0;
+
+  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
+
+    // check if only forced subtitles are requested
+    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){
+	return;
+    }
+
+    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 ||
+	spu->orig_frame_height == 0 ||
+	(spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
+      if (spu->image)
+      {
+      draw_alpha(spu->start_col,
+		spu->start_row,
+		spu->width,
+		spu->height,
+		DEST_PLANES_RB,
+		spu->image,
+		spu->aimage,
+		spu->stride);
+      draw_alpha(spu->start_col,
+		spu->start_row,
+		spu->width,
+		spu->height,
+		DEST_PLANES_G,
+		spu->imageu,
+		spu->aimage,
+		spu->stride);
+      draw_alpha(spu->start_col,
+		spu->start_row,
+		spu->width,
+		spu->height,
+		DEST_PLANES_BR,
+		spu->imagev,
+		spu->aimage,
+		spu->stride);
+      spu->spu_changed = 0;
+      }
+    }
+    else {
+      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys) {	/* Resizing is needed */
+	/* scaled_x = scalex * x / 0x100
+	   scaled_y = scaley * y / 0x100
+	   order of operations is important because of rounding. */
+	scalex = 0x100 * dxs / spu->orig_frame_width;
+	scaley = 0x100 * dys / spu->orig_frame_height;
+
+	spu->scaled_start_col = spu->start_col * scalex / 0x100;
+	spu->scaled_start_row = spu->start_row * scaley / 0x100;
+	spu->scaled_width = spu->width * scalex / 0x100;
+	spu->scaled_height = spu->height * scaley / 0x100;
+	/* Kludge: draw_alpha needs width multiple of 8 */
+	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
+	if (spu->scaled_image_size < spu->scaled_stride * spu->scaled_height) {
+	  if (spu->scaled_image) {
+	    free(spu->scaled_image);
+	  if (spu->scaled_imageu)
+	    free(spu->scaled_imageu);
+	    spu->scaled_image_size = 0;
+	  }
+	  spu->scaled_image = malloc(2 * spu->scaled_stride * spu->scaled_height);
+	  spu->scaled_imageu = malloc(3 * spu->scaled_stride * spu->scaled_height);
+	  if (spu->scaled_image) {
+	    spu->scaled_image_size = spu->scaled_stride * spu->scaled_height;
+	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
+	  }
+	  if (spu->scaled_imageu) {
+	    spu->scaled_imagev = spu->scaled_imageu + spu->scaled_image_size;
+	  }
+	}
+	if (spu->scaled_image) {
+	  unsigned int x, y;
+	  if (spu->scaled_width <= 1 || spu->scaled_height <= 1) {
+	    goto nothing_to_do;
+	  }
+	  switch(spu_aamode&15) {
+	  case 4:
+	  sws_spu_image_rgb(spu->scaled_image,spu->scaled_imageu,
+		    spu->scaled_imagev, spu->scaled_aimage,
+		    spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+		    spu->image, spu->imageu, spu->imagev, spu->aimage,
+		    spu->width, spu->height, spu->stride);
+	  break;
+	  case 3:
+	  table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
+	  table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
+	  if (!table_x || !table_y) {
+	    mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+		    "Fatal: spudec_draw_scaled: calloc failed\n");
+	  }
+	  scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
+	  scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
+	  for (y = 0; y < spu->scaled_height; y++)
+	    for (x = 0; x < spu->scaled_width; x++)
+	      scale_image_rgb(x, y, table_x, table_y, spu);
+	  free(table_x);
+	  free(table_y);
+	  break;
+	  case 0:
+	  /* no antialiasing */
+	  for (y = 0; y < spu->scaled_height; ++y) {
+	    int unscaled_y = y * 0x100 / scaley;
+	    int strides = spu->stride * unscaled_y;
+	    int scaled_strides = spu->scaled_stride * y;
+	    for (x = 0; x < spu->scaled_width; ++x) {
+	      int unscaled_x = x * 0x100 / scalex;
+	      spu->scaled_image[scaled_strides + x] =
+		    spu->image[strides + unscaled_x];
+	      spu->scaled_imageu[scaled_strides + x] =
+		    spu->imageu[strides + unscaled_x];
+	      spu->scaled_imagev[scaled_strides + x] =
+		    spu->imagev[strides + unscaled_x];
+	      spu->scaled_aimage[scaled_strides + x] =
+		    spu->aimage[strides + unscaled_x];
+	    }
+	  }
+	  break;
+	  case 1:
+	  {
+	    /* Intermediate antialiasing. */
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const unsigned int unscaled_top = y *
+			spu->orig_frame_height / dys;
+	      unsigned int unscaled_bottom = (y + 1) *
+			spu->orig_frame_height / dys;
+	      if (unscaled_bottom >= spu->height)
+		unscaled_bottom = spu->height - 1;
+	      for (x = 0; x < spu->scaled_width; ++x) {
+		const unsigned int unscaled_left = x *
+			    spu->orig_frame_width / dxs;
+		unsigned int unscaled_right = (x + 1) *
+			    spu->orig_frame_width / dxs;
+		unsigned int colorr = 0;
+		unsigned int colorg = 0;
+		unsigned int colorb = 0;
+		unsigned int alpha = 0;
+		unsigned int walkx, walky;
+		unsigned int base, tmp;
+		if (unscaled_right >= spu->width)
+		  unscaled_right = spu->width - 1;
+		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx) {
+		    base = walky * spu->stride + walkx;
+		    tmp = canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		base = y * spu->scaled_stride + x;
+		spu->scaled_image[base] = alpha ? colorr / alpha : 0;
+		spu->scaled_imageu[base] = alpha ? colorg / alpha : 0;
+		spu->scaled_imagev[base] = alpha ? colorb / alpha : 0;
+		spu->scaled_aimage[base] =
+		  alpha * (1 + unscaled_bottom - unscaled_top) * (1 + unscaled_right - unscaled_left);
+		/* spu->scaled_aimage[base] =
+		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	  }
+	  break;
+	  case 2:
+	  {
+	    /* Best antialiasing.  Very slow. */
+	    /* Any pixel (x, y) represents pixels from the original
+	       rectangular region comprised between the columns
+	       unscaled_y and unscaled_y + 0x100 / scaley and the rows
+	       unscaled_x and unscaled_x + 0x100 / scalex
+
+	       The original rectangular region that the scaled pixel
+	       represents is cut in 9 rectangular areas like this:
+
+	       +---+-----------------+---+
+	       | 1 |        2        | 3 |
+	       +---+-----------------+---+
+	       |   |                 |   |
+	       | 4 |        5        | 6 |
+	       |   |                 |   |
+	       +---+-----------------+---+
+	       | 7 |        8        | 9 |
+	       +---+-----------------+---+
+
+	       The width of the left column is at most one pixel and
+	       it is never null and its right column is at a pixel
+	       boundary.  The height of the top row is at most one
+	       pixel it is never null and its bottom row is at a
+	       pixel boundary. The width and height of region 5 are
+	       integral values.  The width of the right column is
+	       what remains and is less than one pixel.  The height
+	       of the bottom row is what remains and is less than
+	       one pixel.
+
+	       The row above 1, 2, 3 is unscaled_y.  The row between
+	       1, 2, 3 and 4, 5, 6 is top_low_row.  The row between 4,
+	       5, 6 and 7, 8, 9 is (unsigned int)unscaled_y_bottom.
+	       The row beneath 7, 8, 9 is unscaled_y_bottom.
+
+	       The column left of 1, 4, 7 is unscaled_x.  The column
+	       between 1, 4, 7 and 2, 5, 8 is left_right_column.  The
+	       column between 2, 5, 8 and 3, 6, 9 is (unsigned
+	       int)unscaled_x_right.  The column right of 3, 6, 9 is
+	       unscaled_x_right. */
+	    const double inv_scalex = (double) 0x100 / scalex;
+	    const double inv_scaley = (double) 0x100 / scaley;
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const double unscaled_y = y * inv_scaley;
+	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
+	      const unsigned int top_low_row =
+			MIN(unscaled_y_bottom, unscaled_y + 1.0);
+	      const double top = top_low_row - unscaled_y;
+	      const unsigned int height = unscaled_y_bottom > top_low_row
+		? (unsigned int) unscaled_y_bottom - top_low_row
+		: 0;
+	      const double bottom = unscaled_y_bottom > top_low_row
+		? unscaled_y_bottom - floor(unscaled_y_bottom)
+		: 0.0;
+	      for (x = 0; x < spu->scaled_width; ++x) {
+		const double unscaled_x = x * inv_scalex;
+		const double unscaled_x_right = unscaled_x + inv_scalex;
+		const unsigned int left_right_column =
+			MIN(unscaled_x_right, unscaled_x + 1.0);
+		const double left = left_right_column - unscaled_x;
+		const unsigned int width = unscaled_x_right > left_right_column
+		  ? (unsigned int) unscaled_x_right - left_right_column
+		  : 0;
+		const double right = unscaled_x_right > left_right_column
+		  ? unscaled_x_right - floor(unscaled_x_right)
+		  : 0.0;
+		double colorr = 0.0;
+		double colorg = 0.0;
+		double colorb = 0.0;
+		double alpha = 0.0;
+		double tmp;
+		unsigned int base;
+		/* Now use these informations to compute a good alpha,
+                   and lightness.  The sum is on each of the 9
+                   region's surface and alpha and lightness.
+
+		  transformed alpha = sum(surface * alpha) / sum(surface)
+		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
+		*/
+		/* 1: top left part */
+		base = spu->stride * (unsigned int) unscaled_y;
+		tmp = left * top * canon_alpha(spu->aimage[base + (unsigned int) unscaled_x]);
+		alpha += tmp;
+		colorr += tmp * spu->image[base + (unsigned int) unscaled_x];
+		colorg += tmp * spu->imageu[base + (unsigned int) unscaled_x];
+		colorb += tmp * spu->imagev[base + (unsigned int) unscaled_x];
+		/* 2: top center part */
+		if (width > 0) {
+		  unsigned int walkx;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		    base = spu->stride * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		}
+		/* 3: top right part */
+		if (right > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y +
+			    (unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  colorr += tmp * spu->image[base];
+		  colorg += tmp * spu->imageu[base];
+		  colorb += tmp * spu->imagev[base];
+		}
+		/* 4: center left part */
+		if (height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			    walky < (unsigned int) unscaled_y_bottom;
+			    ++walky) {
+		    base = spu->stride * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		}
+		/* 5: center part */
+		if (width > 0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			    walky < (unsigned int) unscaled_y_bottom;
+			    ++walky) {
+		    unsigned int walkx;
+		    base = spu->stride * walky;
+		    for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimage[base + walkx]);
+		      alpha += tmp;
+		      colorr += tmp * spu->image[base + walkx];
+		      colorg += tmp * spu->imageu[base + walkx];
+		      colorb += tmp * spu->imagev[base + walkx];
+		    }
+		  }
+		}
+		/* 6: center right part */
+		if (right > 0.0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+				walky < (unsigned int) unscaled_y_bottom;
+				++walky) {
+		    base = spu->stride * walky + (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		}
+		/* 7: bottom left part */
+		if (bottom > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  colorr += tmp * spu->image[base];
+		  colorg += tmp * spu->imageu[base];
+		  colorb += tmp * spu->imagev[base];
+		}
+		/* 8: bottom center part */
+		if (width > 0 && bottom > 0.0) {
+		  unsigned int walkx;
+		  base = spu->stride * (unsigned int) unscaled_y_bottom;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		    tmp = /* 1.0 * */ bottom * canon_alpha(spu->aimage[base + walkx]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base + walkx];
+		    colorg += tmp * spu->imageu[base + walkx];
+		    colorb += tmp * spu->imagev[base + walkx];
+		  }
+		}
+		/* 9: bottom right part */
+		if (right > 0.0 && bottom > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  colorr += tmp * spu->image[base];
+		  colorg += tmp * spu->imageu[base];
+		  colorb += tmp * spu->imagev[base];
+		}
+		/* Finally mix these transparency and brightness information suitably */
+		base = spu->scaled_stride * y + x;
+		spu->scaled_image[base] = alpha > 0 ? colorr / alpha : 0;
+		spu->scaled_imageu[base] = alpha > 0 ? colorg / alpha : 0;
+		spu->scaled_imagev[base] = alpha > 0 ? colorb / alpha : 0;
+		spu->scaled_aimage[base] = alpha * scalex * scaley / 0x10000;
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	  }
+	  }
+nothing_to_do:
+	  /* Kludge: draw_alpha needs width multiple of 8. */
+	  if (spu->scaled_width < spu->scaled_stride)
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      memset(spu->scaled_aimage + y * spu->scaled_stride +
+			spu->scaled_width, 0,
+			spu->scaled_stride - spu->scaled_width);
+	    }
+	  spu->scaled_frame_width = dxs;
+	  spu->scaled_frame_height = dys;
+	}
+      }
+      if (spu->scaled_image){
+        switch (spu_alignment) {
+        case 0:
+          spu->scaled_start_row = dys*sub_pos/100;
+	  if (spu->scaled_start_row + spu->scaled_height > dys)
+	    spu->scaled_start_row = dys - spu->scaled_height;
+	  break;
+	case 1:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height/2;
+          if (sub_pos < 50) {
+	    if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+	  } else {
+	    if (spu->scaled_start_row + spu->scaled_height > dys)
+	      spu->scaled_start_row = dys - spu->scaled_height;
+	  }
+	  break;
+        case 2:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height;
+	  if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+	  break;
+	}
+	draw_alpha(spu->scaled_start_col,
+		spu->scaled_start_row,
+		spu->scaled_width,
+		spu->scaled_height,
+		DEST_PLANES_RB,
+		spu->scaled_image,
+		spu->scaled_aimage,
+		spu->scaled_stride);
+	draw_alpha(spu->scaled_start_col,
+		spu->scaled_start_row,
+		spu->scaled_width,
+		spu->scaled_height,
+		DEST_PLANES_G,
+		spu->scaled_imageu,
+		spu->scaled_aimage,
+		spu->scaled_stride);
+	draw_alpha(spu->scaled_start_col,
+		spu->scaled_start_row,
+		spu->scaled_width,
+		spu->scaled_height,
+		DEST_PLANES_BR,
+		spu->scaled_imagev,
+		spu->scaled_aimage,
+		spu->scaled_stride);
+	spu->spu_changed = 0;
+      }
+    }
+  }
+  else
+  {
+    mp_msg(MSGT_SPUDEC,MSGL_DBG2,
+	"SPU not displayed: start_pts=%d  end_pts=%d  now_pts=%d\n",
+        spu->start_pts, spu->end_pts, spu->now_pts);
+  }
+}
+#endif
 
 void spudec_update_palette(void * this, unsigned int *palette)
 {
@@ -1170,6 +3218,23 @@ void spudec_free(void *this)
 	free(spu->scaled_image);
     if (spu->image)
       free(spu->image);
+#ifdef USE_MPDVDNAV
+    if (spu->dvdnav_image)
+      free(spu->dvdnav_image);
+    if (spu->dvdnav_aimage)
+      free(spu->dvdnav_aimage);
+
+    if (spu->imageu)
+      free(spu->imageu);
+    if (spu->imageyuy)
+      free(spu->imageyuy);
+    spu->imageyuy=NULL;
+    if (spu->scaled_imageu)
+	free(spu->scaled_imageu);
+
+    if (spu->last_packet) {spudec_free_packet(spu->last_packet); spu->last_packet=NULL;}
+    spu->dvdnav_allocated = 0;
+#endif
     free(spu);
   }
 }
diff -r 448a43f59a37 spudec.h
--- a/spudec.h	Sun Apr 30 17:12:20 2006 +0200
+++ b/spudec.h	Sun Apr 30 17:14:32 2006 +0200
@@ -5,8 +5,32 @@
 
 void spudec_heartbeat(void *this, unsigned int pts100);
 void spudec_assemble(void *this, unsigned char *packet, unsigned int len, unsigned int pts100);
-void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
-void spudec_draw_scaled(void *this, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+#ifdef USE_MPDVDNAV
+#define DVDNAV_SPU_YUV	1
+#define DVDNAV_SPU_RGB	2
+#define DVDNAV_SPU_BGR	3
+#define DVDNAV_SPU_YUY	4
+
+void spu_yuv_to_rgb(unsigned int y,unsigned int u,unsigned int v,
+    unsigned int *r,unsigned int *g,unsigned int *b);
+void spudec_dvdnav_mode(void *this, int mode, int cflg);
+void spudec_dvdnav_area(void *this, uint16_t sx, uint16_t sy,
+    uint16_t ex, uint16_t ey, uint32_t palette);
+void spudec_dvdnav_palette(void *this, uint32_t palette);
+int spudec_dvdnav_menu_box(void *this, int scaled, unsigned int scalex,
+    unsigned int scaley);
+void spudec_new_scaled_yuv(unsigned int *palette, unsigned int frame_width,
+    unsigned int frame_height);
+void spudec_new_scaled_rgb(unsigned int *palette, unsigned int frame_width,
+    unsigned int frame_height);
+void spudec_draw_scaled_yuv(void *me, unsigned int dxs, unsigned int dys,
+    void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled_rgb(void *me, unsigned int dxs, unsigned int dys,
+    void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_create_yuy(void *this, int spu_scaled);
+#endif
+void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled(void *this, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 void spudec_update_palette(void *this, unsigned int *palette);
 void *spudec_new_scaled(unsigned int *palette, unsigned int frame_width, unsigned int frame_height);
 void *spudec_new_scaled_vobsub(unsigned int *palette, unsigned int *cuspal, unsigned int custom, unsigned int frame_width, unsigned int frame_height);
@@ -18,7 +42,7 @@ void spudec_set_hw_spu(void *this, vo_fu
 void spudec_set_hw_spu(void *this, vo_functions_t *hw_spu);
 int spudec_changed(void *this);
 void spudec_calc_bbox(void *me, unsigned int dxs, unsigned int dys, unsigned int* bbox);
-void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 void spudec_set_forced_subs_only(void * const this, const unsigned int flag);
 #endif
 
diff -r 448a43f59a37 libmpcodecs/vd_videostill.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpcodecs/vd_videostill.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,117 @@
+#include "config.h"
+
+#include <stdio.h>
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "mp_msg.h"
+#include "help_mp.h"
+
+#include "osdep/timer.h"
+#include "osdep/shmem.h"
+
+#include "stream.h"
+#include "demuxer.h"
+#include "parse_es.h"
+
+#include "codec-cfg.h"
+
+#include "libvo/video_out.h"
+
+#include "stheader.h"
+#include "vd.h"
+#include "vf.h"
+
+#include "dec_video.h"
+
+#ifdef DYNAMIC_PLUGINS
+#include <dlfcn.h>
+#endif
+
+#ifdef USE_MPDVDNAV_TRACE
+extern int dvdnav_trace;
+#endif
+
+#include "libvo/fastmemcpy.h"
+mp_image_t *smpi=NULL;
+int mp_preserve=0;
+
+extern double video_time_usage;
+extern double vout_time_usage;
+
+extern vd_functions_t* mpvdec; // FIXME!
+
+#include "cpudetect.h"
+
+void clearsmpi(void) {smpi=NULL;}
+
+int vd_mpeg2_reset(sh_video_t *sh_video, int full_reset)
+{
+#ifdef USE_MPDVDNAV
+if (!mpvdec) return 0;
+if (!sh_video->enable_mpeg2_reset) return 0;
+mpvdec->control(sh_video, VDCTRL_RESET, &full_reset);
+return 1;
+#else
+return 0;
+#endif
+}
+
+int vd_decode_mp_preserve(void) {return mp_preserve;}
+
+int decode_video_still(sh_video_t *sh_video,unsigned char *start,
+    int in_size,int drop_frame, double pts, int enable_still){
+vf_instance_t* vf;
+mp_image_t *mpi=NULL;
+unsigned int t=GetTimer();
+unsigned int t2;
+double tt;
+int ret;
+
+if (in_size>=0 || !enable_still)
+    //if(!(sh_video->ds->flags&1) || sh_video->ds->pack_no<5)
+    mpi=mpvdec->decode(sh_video, start, in_size, drop_frame);
+//------------------------ frame decoded. --------------------
+
+#ifdef ARCH_X86
+	// some codecs are broken, and doesn't restore MMX state :(
+	// it happens usually with broken/damaged files.
+    if(gCpuCaps.has3DNow){
+	__asm __volatile ("femms\n\t":::"memory");
+    }
+    else if(gCpuCaps.hasMMX){
+	__asm __volatile ("emms\n\t":::"memory");
+    }
+#endif
+
+mp_preserve=0;
+if (in_size>=0 && mpi && enable_still)
+  {
+  smpi=mpi;		/* It will use copy_mpi() or other solution? */
+  if (mpi) mp_preserve=mpi->flags & MP_IMGFLAG_PRESERVE;
+  }
+if (in_size<0 && enable_still && smpi)
+  {
+  mpi=smpi;
+  }
+
+
+t2=GetTimer();t=t2-t;
+tt = t*0.000001f;
+video_time_usage+=tt;
+
+if(!mpi || (drop_frame && !(enable_still && in_size<0))) return 0; // error / skipped frame
+//vo_draw_image(video_out,mpi);
+vf=sh_video->vfilter;
+ret = vf->put_image(vf,mpi, pts); // apply video filters and call the leaf vo/ve
+if(ret>0) vf->control(vf,VFCTRL_DRAW_OSD,NULL);
+
+    t2=GetTimer()-t2;
+    tt=t2*0.000001f;
+    vout_time_usage+=tt;
+
+return ret;
+}
diff -r 448a43f59a37 libmpcodecs/vd_videostill.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpcodecs/vd_videostill.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,8 @@
+#ifndef __VD_VIDEOSTILL_H_
+#define __VD_VIDEOSTILL_H_
+
+extern void clearsmpi(void);
+extern int vd_mpeg2_reset(sh_video_t *sh_video, int force_reset);
+extern int decode_video_still(sh_video_t *sh_video,unsigned char *start,int in_size,int drop_frame, double pts,int enable_still);
+extern int vd_decode_mp_preserve(void);
+#endif
diff -r 448a43f59a37 libmpdemux/stream_dvdnav.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdemux/stream_dvdnav.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,1113 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvdnav.c,v 1.63 2004/01/31 17:12:58 jcdutton Exp $
+ *
+ */
+
+/*
+ * tvs Attila (Attila, Otvos) created it with the libdvdnav-0.1.10.
+ * Useful links:
+ * SourceForge.net: DVD tools for Linux
+ * http://sourceforge.net/projects/dvd/
+ */
+
+#include "config.h"
+
+#ifdef USE_MPDVDNAV		// enable dvdnav support?
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include "mp_msg.h"
+#include "../libmpdemux/stream.h"
+#include "help_mp.h"
+#include "osdep/timer.h"
+#include "input/input.h"
+#include "stream.h"
+#include "stream_dvdnav.h"
+#include "libvo/video_out.h"
+#include "spudec.h"
+#include "m_option.h"
+#include "m_struct.h"
+#include "libmpdvdnav/dvdnav_internal.h"
+
+#define TRACE	// enable trace messages print, usage: -dvdnav-trace options
+//#define LOG_DEBUG
+
+int dvd_nav_skip_opening = 0;
+int dvd_nav_still = 0;
+int dvdnav_menutype = 0;
+int dvdnav_continue_play = 0;
+int dvdnav_go_title = 0;
+int dvdnav_go_part = 0;
+int dvdnav_go_menu = 0;
+int dvdnav_go_menu_force = 0;
+int dvdnav_go_audio = 0;
+int dvdnav_go_spu = 0;
+int dvdnav_trace = 0;
+int dvdnav_force_menu = 0;
+int dvdnav_skipintro = 0;
+int dvdnav_color_spu = 1;
+char* dvdmenu_lang = NULL;
+
+extern char* dvd_device;
+extern int audio_id;
+extern int dvdsub_id;
+extern char* audio_lang;
+extern char* dvdsub_lang;
+
+#ifdef HAVE_NEW_GUI
+int	dvdnav_window_width=0;
+int	dvdnav_window_height=0;
+int	dvdnav_window_orig_width=0;
+int	dvdnav_window_orig_height=0;
+int	dvdnav_mouse_x=0;
+int	dvdnav_mouse_y=0;
+int	dvdnav_mouse_orig_x=0;
+int	dvdnav_mouse_orig_y=0;
+int	dvdnav_mouse_button=0;
+int	dvdnav_mouse_set=0;
+#endif
+
+off_t	eventnum=0;
+
+int cellxx=0;
+
+static struct stream_priv_s {
+  int track;
+  char* device;
+} stream_priv_dflts = {
+  1,
+  NULL
+};
+
+#define ST_OFF(f) M_ST_OFF(struct stream_priv_s,f)
+/// URL definition
+static m_option_t stream_opts_fields[] = {
+  { NULL, NULL, 0, 0, 0, 0,  NULL }
+};
+static struct m_struct_st stream_opts = {
+  "dvd",
+  sizeof(struct stream_priv_s),
+  &stream_priv_dflts,
+  stream_opts_fields
+};
+
+
+#ifndef _MSC_VER
+#include <sys/param.h>
+#include <sys/fcntl.h>
+#else
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 255
+#endif
+#endif /* _MSC_VER */
+
+int dvdnav_seek(dvdnav_priv_t * dvdnav_priv, off_t newpos,stream_t *s)
+{
+if (dvdnav_priv->lockseek) return 0;
+if (dvdnav_sector_search(dvdnav_priv->dvdnav, newpos, SEEK_SET)!=
+	DVDNAV_STATUS_OK) {
+  if (!newpos) mp_msg(MSGT_CPLAYER,MSGL_ERR,
+	MSGTR_MPDVDNAV_ErrorSeek,dvdnav_err_to_string(dvdnav_priv->dvdnav),
+	newpos );
+  return 0;
+  }
+return 1;
+}
+
+static int seek(stream_t *s, off_t newpos)
+{
+off_t seekpos;
+
+mp_msg(MSGT_CPLAYER,MSGL_DBG2,"DVDNAV seek pos: %llx\n",newpos);
+dvdnav_priv_t* dvdnav_priv=s->priv;
+int domain_vts=dvdnav_priv->vts_domain;
+if(newpos!=s->pos) {
+  if (!domain_vts)
+    mp_msg(MSGT_CPLAYER,MSGL_V,"Cannot seek in DVDNAV streams yet!\n");
+    else {
+    seekpos=newpos/2048;
+    if (dvdnav_seek((dvdnav_priv_t*)s->priv,seekpos,s)) s->pos=newpos; }
+    }
+if (newpos==0) {
+  ((dvdnav_priv_t*)(s->priv))->stillcounter=0;
+  ((dvdnav_priv_t*)(s->priv))->waitcounter=0;
+  ((dvdnav_priv_t*)(s->priv))->lockstillcounter=0;}
+return 1;
+}
+
+unsigned int * dvdnav_stream_get_palette(dvdnav_priv_t * dvdnav_priv)
+{
+if (!dvdnav_priv) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv\n",
+	__FUNCTION__);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv->dvdnav\n",
+	__FUNCTION__);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav->vm) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv->dvdnav->vm\n",
+	__FUNCTION__);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav->vm->state.pgc) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv->dvdnav->vm->state.pgc\n",
+	__FUNCTION__);
+  return NULL;
+  }
+return dvdnav_priv->dvdnav->vm->state.pgc->palette;
+}
+
+int dvdnav_menu_action(dvdnav_priv_t * dvdnav_priv, int action)
+{
+pci_t* pnavpci;
+dsi_t* pnavdsi;
+uint32_t buttonN;
+pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+pnavdsi = dvdnav_get_current_nav_dsi( dvdnav_priv->dvdnav );
+dvdnav_status_t nav_status;
+if (!dvdnav_priv) return 0;
+switch (action) {
+  case MP_CMD_DVDNAV_UP:
+    nav_status = dvdnav_upper_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd up");
+#endif
+    break;
+  case MP_CMD_DVDNAV_DOWN:
+    nav_status = dvdnav_lower_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd down");
+#endif
+    break;
+  case MP_CMD_DVDNAV_LEFT:
+    nav_status = dvdnav_left_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd left");
+#endif
+    break;
+  case MP_CMD_DVDNAV_RIGHT:
+    nav_status = dvdnav_right_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd right");
+#endif
+    break;
+  case MP_CMD_DVDNAV_MENU:
+    dvdnav_wait_still_clear(dvdnav_priv->dvdnav);
+    dvdnav_priv->cell_timer=0;
+    dvdnav_priv->one_cell_timer=0;
+    dvdnav_priv->stillflg=0;
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: menu action: Menu Root\n");
+#endif
+    dvdnav_button_select_auto_action( dvdnav_priv->dvdnav, 0);
+    nav_status = dvdnav_menu_call(dvdnav_priv->dvdnav,DVD_MENU_Root);
+    break;
+  case MP_CMD_DVDNAV_SELECT:
+    dvdnav_wait_still_clear(dvdnav_priv->dvdnav);
+    dvdnav_priv->cell_timer=0;
+    dvdnav_priv->one_cell_timer=0;
+    dvdnav_priv->stillflg=0;
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: menu action: Menu Select\n");
+#endif
+    dvdnav_button_select_auto_action( dvdnav_priv->dvdnav, 0);
+    nav_status = dvdnav_button_activate(dvdnav_priv->dvdnav, pnavpci);
+    break;
+  default:
+    return 0;
+  }
+if (nav_status == DVDNAV_STATUS_ERR) {mp_msg(MSGT_CPLAYER, MSGL_WARN,
+	MSGTR_MPDVDNAV_ErrorNav,
+	dvdnav_err_to_string(dvdnav_priv->dvdnav));
+    return 0;}
+return 1;
+}
+
+int dvdnav_menu_force(dvdnav_priv_t * dvdnav_priv)
+{
+return 1;
+}
+
+void dvdnav_stream_fullstart(dvdnav_priv_t * dvdnav_priv)
+{
+if (dvdnav_priv && !dvdnav_priv->started) {
+//    dvdnav_stream_reset(dvdnav_priv);
+  dvdnav_priv->started=1; }
+dvdnav_event_clear(dvdnav_priv);
+dvdnav_priv->stillcounter=0;
+dvdnav_priv->waitcounter=0;
+dvdnav_priv->lockstillcounter=0;
+}
+
+int dvdnav_reallyeof(dvdnav_priv_t * dvdnav_priv)
+{
+if (!dvdnav_priv) return 1;
+return dvdnav_priv->stopflg;
+}
+
+void dvdnav_set_language(dvdnav_priv_t *dvdnav_priv, char *alang,
+    char *slang, char *mlang)	/* set nav languages */
+{
+if (slang) {
+  if (dvdnav_spu_language_select(dvdnav_priv->dvdnav, slang ) !=
+      DVDNAV_STATUS_OK)	/* FIXME: don't work! */
+    mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting spu languages: %s\n",
+      dvdnav_err_to_string(dvdnav_priv->dvdnav)); }
+if (alang) {
+  if (dvdnav_audio_language_select(dvdnav_priv->dvdnav, alang ) !=
+      DVDNAV_STATUS_OK)	/* FIXME: don't work! */
+    mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting audio languages: %s\n",
+      dvdnav_err_to_string(dvdnav_priv->dvdnav)); }
+if (mlang) {
+  if (dvdnav_menu_language_select(dvdnav_priv->dvdnav, dvdmenu_lang ) !=
+    DVDNAV_STATUS_OK)
+  mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting menu languages: %s\n",
+    dvdnav_err_to_string(dvdnav_priv->dvdnav)); }
+return;
+}
+
+int dvdnav_lang_from_sid(dvdnav_priv_t *dvdnav_priv, int id)
+{
+if (!dvdnav_priv) return 0;
+if (id >= dvdnav_priv->nr_of_subtitles) return 0;
+return dvdnav_priv->subtitles[id].language;
+}
+
+int dvdnav_sid_from_lang(dvdnav_priv_t *dvdnav_priv, unsigned char* lang)
+{
+if (!dvdnav_priv) return 0;
+int code,i;
+while(lang && strlen(lang)>=2) {
+  code=lang[1]|(lang[0]<<8);
+  for(i=0;i<dvdnav_priv->nr_of_subtitles;i++) {
+    if(dvdnav_priv->subtitles[i].language==code) {
+      mp_msg(MSGT_OPEN,MSGL_V,MSGTR_DVDsubtitleChannel, i, lang[0],lang[1]);
+      return i;}
+    }
+  lang+=2; 
+  while (lang[0]==',' || lang[0]==' ') ++lang;
+  }
+mp_msg(MSGT_OPEN,MSGL_WARN,MSGTR_DVDnoMatchingSubtitle);
+return -1;
+}
+
+int dvdnav_aid_from_lang(dvdnav_priv_t *dvdnav_priv, unsigned char* lang)
+{
+if (!dvdnav_priv) return 0;
+int code,i;
+while(lang && strlen(lang)>=2) {
+  code=lang[1]|(lang[0]<<8);
+  for(i=0;i<dvdnav_priv->nr_of_channels;i++) {
+    if(dvdnav_priv->audio_streams[i].language==code) {
+      mp_msg(MSGT_OPEN,MSGL_V,MSGTR_DVDaudioChannel,
+	    dvdnav_priv->audio_streams[i].id, lang[0],lang[1]);
+      return dvdnav_priv->audio_streams[i].id;}
+    }
+  lang+=2; 
+  while (lang[0]==',' || lang[0]==' ') ++lang;
+  }
+mp_msg(MSGT_OPEN,MSGL_WARN,MSGTR_DVDnoMatchingAudio);
+return -1;
+}
+
+int dvdnav_number_of_subs(dvdnav_priv_t *dvdnav_priv)
+{
+if (!dvdnav_priv) return -1;
+return dvdnav_priv->nr_of_subtitles;
+}
+
+static void stream_dvdnav_close(stream_t *s)
+{
+free_dvdnav_stream((dvdnav_priv_t*)s->priv);
+}
+
+void dvdnav_event_clear(dvdnav_priv_t * dvdnav_priv)
+{
+memset(&(dvdnav_priv->event),0,sizeof(stream_dvdnav_event_t));
+return;
+}
+
+void dvdnav_get_highlight(dvdnav_priv_t *dvdnav_priv,
+    dvdnav_highlight_event_t *highlight_event,
+    int display_mode)
+{
+pci_t* pnavpci;
+int button_number = -1;
+int b_mode = 0;
+if (!dvdnav_priv) return;
+if (!dvdnav_priv->dvdnav) return;
+if (!highlight_event) return;
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav ))) return;
+dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &(highlight_event->buttonN));
+highlight_event->display=display_mode; /* show */
+if (highlight_event->display==2) b_mode=1;	/* activate */
+if (highlight_event->buttonN > 0 && pnavpci->hli.hl_gi.btn_ns > 0 &&
+	highlight_event->display) {
+    for (button_number = 0; button_number < pnavpci->hli.hl_gi.btn_ns;
+	    button_number++) {
+        btni_t *btni = &(pnavpci->hli.btnit[button_number]);
+        if(highlight_event->buttonN==button_number+1) {
+	    highlight_event->sx=min(btni->x_start,btni->x_end);
+	    highlight_event->ex=max(btni->x_start,btni->x_end);
+	    highlight_event->sy=min(btni->y_start,btni->y_end);
+	    highlight_event->ey=max(btni->y_start,btni->y_end);
+	    if (btni->btn_coln==0) highlight_event->palette=0;
+		else
+		highlight_event->palette=
+		    pnavpci->hli.btn_colit.btn_coli[btni->btn_coln-1][b_mode];
+	    }
+	}
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_DBG2,
+	"dvdnav: get highlight (%i:%i-%i:%i #%i)\n",
+	highlight_event->sx,
+	highlight_event->sy,
+	highlight_event->ex,
+	highlight_event->ey,
+	highlight_event->buttonN);
+#endif
+    } else {	/* hide button or none button */
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_DBG2,
+	"dvdnav: get highlight hide\n");
+#endif
+    highlight_event->sx=0;
+    highlight_event->ex=0;
+    highlight_event->sy=0;
+    highlight_event->ey=0;
+    highlight_event->palette=0;
+    highlight_event->buttonN=0; }
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdna_get_highlight");
+#endif
+return;
+}
+
+void dvdnav_get_button_palette(dvdnav_priv_t *dvdnav_priv,uint32_t *palette)	/* get button palette */
+{
+pci_t* pnavpci;
+int button_number;
+int buttonN;
+int b_mode = 0;
+if (!dvdnav_priv) return;
+if (!dvdnav_priv->dvdnav) return;
+if (!palette) return;
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav )))
+  return;
+dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &buttonN);	/* get current button ID */
+if (pnavpci->hli.hl_gi.btn_ns) {	/* is buttons */
+    for (button_number = 0; button_number < pnavpci->hli.hl_gi.btn_ns;
+	    button_number++) {
+        btni_t *btni = &(pnavpci->hli.btnit[button_number]);
+        if(buttonN==button_number+1) {					/* current button? */
+	    if (btni->btn_coln==0) *palette=0;
+		else *palette=
+		    pnavpci->hli.btn_colit.btn_coli[btni->btn_coln-1][b_mode];
+	    }
+	}
+    }
+if (*palette==0)	/* if none current button? */
+    {
+    btni_t *btni = &(pnavpci->hli.btnit[0]);
+    if (btni->btn_coln==0) *palette=0;
+	else *palette=
+	    pnavpci->hli.btn_colit.btn_coli[btni->btn_coln-1][b_mode];
+    }
+return;
+}
+
+void dvdnav_print_buttons(dvdnav_priv_t *dvdnav_priv, char* txt)
+{
+#ifdef USE_MPDVDNAV_TRACE
+if( !mp_msg_test(MSGT_CPLAYER,MSGL_DBG2) ) return; 
+pci_t* pnavpci;
+int button_number;
+int buttonN;
+int b_mode = 0;
+if (!dvdnav_priv) return;
+if (!dvdnav_priv->dvdnav) return;
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav )))
+  return;
+dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &buttonN);	/* get current button ID */
+if (pnavpci->hli.hl_gi.btn_ns) {	/* is buttons */
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav: buttons number: %d (%s)\n",
+	pnavpci->hli.hl_gi.btn_ns,
+	txt);
+  for (button_number = 0; button_number < pnavpci->hli.hl_gi.btn_ns;
+	    button_number++) {
+    btni_t *btni = &(pnavpci->hli.btnit[button_number]);
+    if(buttonN==button_number+1) {					/* current button? */
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav: *buttons: #%d (%d:%d,%d:%d)\n",
+	button_number,
+	btni->x_start,
+	btni->y_start,
+	btni->x_end,
+	btni->y_end);
+    } else {
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav:  buttons: #%d (%d:%d,%d:%d)\n",
+	button_number,
+	btni->x_start,
+	btni->y_start,
+	btni->x_end,
+	btni->y_end);
+	}
+    }
+  } else {
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav: buttons number: no buttons (%s)\n",
+	txt);
+  }
+#endif
+return;
+}
+
+
+#ifdef HAVE_NEW_GUI
+void dvdnav_mouse(dvdnav_priv_t * dvdnav_priv)
+{
+pci_t* pnavpci;
+if (dvdnav_mouse_set!=1) return;
+dvdnav_mouse_set=2;		// Lock mouse event
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav )))
+  return;
+if (dvdnav_window_orig_width>0 &&
+    dvdnav_window_orig_height>0 &&
+    dvdnav_window_width>0 &&
+    dvdnav_window_height>0) {
+    // Calculate original mouse position (if scaled window)
+  dvdnav_mouse_orig_x=
+	dvdnav_mouse_x*dvdnav_window_orig_width/dvdnav_window_width;
+  dvdnav_mouse_orig_y=
+	dvdnav_mouse_y*dvdnav_window_orig_height/dvdnav_window_height;
+  } else {
+  dvdnav_mouse_orig_x=dvdnav_mouse_x;
+  dvdnav_mouse_orig_y=dvdnav_mouse_y; }
+if (pnavpci->hli.hl_gi.btn_ns) {	/* is buttons */
+    dvdnav_mouse_select(dvdnav_priv->dvdnav, pnavpci,
+	dvdnav_mouse_orig_x,
+	dvdnav_mouse_orig_y); /* mouse position select */
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_mouse_button) dvdnav_print_buttons(dvdnav_priv,
+	"dvdnav_mouse");
+#endif
+  if (dvdnav_mouse_button) dvdnav_menu_action(dvdnav_priv,
+	MP_CMD_DVDNAV_SELECT); }	/* mouse button event */
+dvdnav_mouse_set=0;
+dvdnav_mouse_button=0;
+return;
+}
+#endif
+
+#define FIRST_AC3_AID 128
+#define FIRST_DTS_AID 136
+#define FIRST_MPG_AID 0
+#define FIRST_PCM_AID 160
+
+int dvdnav_stream_read(dvdnav_priv_t * dvdnav_priv, unsigned char *buf,
+    int *len,stream_dvdnav_event_t *event)
+{
+int eventid = DVDNAV_NOP;
+
+if (!len) return -1;
+*len=-1;
+if (!dvdnav_priv) return -1;
+if (!buf) return -1;
+if (dvdnav_priv->stopflg) return -1;
+
+if (dvd_nav_still) {
+  mp_msg(MSGT_CPLAYER,MSGL_DBG2,
+  MSGTR_MPDVDNAV_ReadInStillActive,
+  __FUNCTION__);
+  *len=0;
+  return -1;
+  }
+if (dvdnav_get_next_block(dvdnav_priv->dvdnav,buf,&eventid,len)!=
+    DVDNAV_STATUS_OK) {
+  mp_msg(MSGT_CPLAYER,MSGL_ERR,
+	MSGTR_MPDVDNAV_ErrorGetNextBlock,
+	dvdnav_err_to_string(dvdnav_priv->dvdnav) );
+  *len=-1;
+  }
+  else if (eventid!=DVDNAV_BLOCK_OK) {
+    switch (eventid) {
+#if 0
+      case DVDNAV_NOP : {
+	event->eventflag.nop=1;
+	event->eventflag.isevent=1;
+	break; }
+#endif
+      case DVDNAV_STILL_FRAME: {
+	event->eventflag.still_frame=1;
+	event->eventflag.isevent=1;
+	dvdnav_priv->stillflg=1;
+	dvdnav_priv->stillok=0;
+	dvdnav_still_event_t *still_event = (dvdnav_still_event_t*)(buf);
+	event->still_length=still_event->length;
+	unsigned int end_time=0;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: still frame (%x)\n",
+	    event->still_length);
+#endif
+	if (still_event->length==0x01)		// FIXME: TIME HACK
+	  {
+	  pci_t* pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+	  end_time=(pnavpci->pci_gi.e_eltm.hour*3600+
+	    pnavpci->pci_gi.e_eltm.minute*60+
+	    pnavpci->pci_gi.e_eltm.second)*1000000;
+#ifdef USE_MPDVDNAV_TRACE
+	  if (dvdnav_trace) {
+	    float et=end_time;
+	    et=et/1000000;
+	    mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		    "dvdnav: still wait time %8.3f sec (form pci_t) hack:(\n",
+		    et);
+	    }
+#endif
+	  }
+	if (event->still_length==0xff) {
+	  if (dvdnav_priv->stillcounter<DVDNAV_MAX_STILL_FRAME)
+	    dvdnav_still_back(dvdnav_priv->dvdnav);
+	    else
+	    dvdnav_priv->stillok=1;
+	  } else {
+	  if (end_time==0) end_time=still_event->length*1000000;
+	  if (!dvdnav_priv->cell_timer) {
+	    dvdnav_priv->cell_timer = GetTimer();
+	    dvdnav_priv->one_cell_timer = dvdnav_priv->cell_timer;
+	    }
+	  unsigned int now = GetTimer();
+#ifdef USE_MPDVDNAV_TRACE
+	  if (dvdnav_trace) {
+	    float pt=now-dvdnav_priv->cell_timer;
+	    pt=pt/1000000;
+	    float et=end_time;
+	    et=et/1000000;
+	    mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: remains time %8.3f sec\n",
+		et-pt);
+	    }
+#endif
+	  if (now-dvdnav_priv->cell_timer<end_time) {	// cell play time end?
+	    dvdnav_button_select_auto_action( dvdnav_priv->dvdnav, 1);
+	  if (dvdnav_priv->stillcounter<DVDNAV_MAX_STILL_FRAME)
+	    dvdnav_still_back(dvdnav_priv->dvdnav);
+	    else
+	    dvdnav_priv->stillok=1; // don't let dvdnav stall on this image
+	  } else {
+	  dvdnav_still_skip(dvdnav_priv->dvdnav);
+	  dvdnav_priv->cell_timer=0;
+	  dvdnav_priv->one_cell_timer=0;}
+	  }
+	break; }
+      case DVDNAV_SPU_STREAM_CHANGE : {
+	event->eventflag.spu_stream_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_spu_stream_change_event_t *spu_stream_change_event =
+	    (dvdnav_spu_stream_change_event_t*)(buf);
+	event->spu_physical_wide=
+	    spu_stream_change_event->physical_wide;
+	event->spu_physical_letterbox=
+	    spu_stream_change_event->physical_letterbox;
+	event->spu_physical_pan_scan=
+	    spu_stream_change_event->physical_pan_scan;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: spu stream change\n");
+#endif
+	break; }
+      case DVDNAV_AUDIO_STREAM_CHANGE : {
+	event->eventflag.audio_stream_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_audio_stream_change_event_t *audio_stream_change_event =
+	    (dvdnav_audio_stream_change_event_t*)(buf);
+	event->audio_physical=
+	    audio_stream_change_event->physical;
+	event->audio_logical=
+	    audio_stream_change_event->logical;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: audio stream change\n");
+#endif
+	break; }
+      case DVDNAV_VTS_CHANGE : {
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: vts change\n");
+#endif
+	event->eventflag.vts_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_vts_change_event_t *vts_change_event =
+	    (dvdnav_vts_change_event_t*)(buf);
+	event->vts_old_vtsN=vts_change_event->old_vtsN;
+	event->vts_old_domain=vts_change_event->old_domain;
+	event->vts_new_vtsN=vts_change_event->new_vtsN;
+	event->vts_new_domain=vts_change_event->new_domain;
+	dvdnav_get_position(dvdnav_priv->dvdnav,
+	    &(dvdnav_priv->tpos),
+	    &(dvdnav_priv->tlen));
+	if (!dvdnav_priv->vts_domain)
+	  dvdnav_priv->cell_timer=GetTimer();
+	  else
+	  dvdnav_priv->cell_timer=0;
+	event->cell_really_change=1;
+	dvdnav_priv->one_cell_timer=dvdnav_priv->cell_timer;
+	dvdnav_priv->stillok=0;
+	dvdnav_priv->stillflg=0;
+	dvdnav_priv->stillcounter=0;
+	dvdnav_priv->waitcounter=0;
+	dvdnav_priv->lockstillcounter=0;
+	break; }
+      case DVDNAV_CELL_CHANGE : {
+	event->eventflag.cell_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_cell_change_event_t *cell_change_event =
+	    (dvdnav_cell_change_event_t*)(buf);
+	event->cell_cellN=cell_change_event->cellN;
+	event->cell_pgN=cell_change_event->pgN;
+	event->cell_cell_length=cell_change_event->cell_length;
+	event->cell_pg_length=cell_change_event->pg_length;
+	event->cell_pgc_length=cell_change_event->pgc_length;
+	event->cell_cell_start=cell_change_event->cell_start;
+	event->cell_pg_start=cell_change_event->pg_start;
+	int pgcN = 0;
+	dvdnav_get_pgc(dvdnav_priv->dvdnav, &pgcN);
+// get dvdnav audio setting
+	uint8_t alang=dvdnav_get_active_audio_stream(dvdnav_priv->dvdnav);
+	dvdnav_priv->alang=
+	    128+dvdnav_get_active_audio_stream(dvdnav_priv->dvdnav);
+// get dvdnav spu settings
+	dvdnav_priv->slang=dvdnav_get_active_spu_stream(dvdnav_priv->dvdnav);
+// get dvdnav aspect settings
+	dvdnav_priv->aspect=dvdnav_get_video_aspect(dvdnav_priv->dvdnav);
+// setting dvdnav info
+	dvdnav_priv->vts_domain=dvdnav_is_domain_vts(dvdnav_priv->dvdnav);
+	dvdnav_get_position(dvdnav_priv->dvdnav,
+	    &(dvdnav_priv->tpos),
+	    &(dvdnav_priv->tlen));
+	dvdnav_get_number_of_titles(dvdnav_priv->dvdnav,
+	    &(dvdnav_priv->titles_nr));
+	dvdnav_priv->part=0;
+	dvdnav_priv->title=0;
+	event->cell_really_change=0;
+	if (dvdnav_priv->cell_cellN!=event->cell_cellN ||
+		dvdnav_priv->cell_pgN!=event->cell_pgN ||
+		dvdnav_priv->cell_pgcN!=pgcN)	// really cell change?
+	  {
+	  event->cell_really_change=1;
+	  dvdnav_priv->stillcounter=0;
+	  dvdnav_priv->waitcounter=0;
+	  dvdnav_priv->lockstillcounter=0;
+	  }
+	if (event->cell_really_change)
+	  {
+	  dvdnav_priv->stillok=0;
+	  dvdnav_priv->cell_timer=GetTimer();
+	  dvdnav_priv->one_cell_timer=dvdnav_priv->cell_timer;
+	  dvdnav_priv->stillflg=0;
+	  dvdnav_priv->stillcounter=0;
+	  dvdnav_priv->waitcounter=0;
+	  dvdnav_priv->lockstillcounter=0;
+	  }
+	if (!(dvdnav_priv->vts_domain)) {
+	  dvdnav_priv->chapters_nr=0;
+	  dvdnav_priv->menu_sid=
+		dvdnav_get_active_spu_stream(dvdnav_priv->dvdnav);
+	  dvdnav_priv->final_pts=0.0;
+	  } else {
+	  dvdnav_priv->final_pts = cell_change_event->cell_length;
+	  dvdnav_priv->final_pts = dvdnav_priv->final_pts / 90000;
+	  dvdnav_current_title_info(dvdnav_priv->dvdnav,
+		&dvdnav_priv->title,
+		&dvdnav_priv->part);
+	  dvdnav_get_number_of_parts(dvdnav_priv->dvdnav,
+		dvdnav_priv->title,
+		&dvdnav_priv->chapters_nr);
+	  event->cell_really_change=1;
+
+	  uint32_t audio_id;
+	  audio_attr_t audio_attr;
+	  dvdnav_priv->nr_of_channels=0;
+	  int language;
+	  int i;
+	  for( i=0; i<8; i++) {
+	    if (-1!=(audio_id=audio_id=
+		dvdnav_get_audio_logical_stream(dvdnav_priv->dvdnav, i))) {
+	      dvdnav_get_audio_attr(dvdnav_priv->dvdnav, i, &audio_attr);
+	      language=0;
+	      if(audio_attr.lang_type==1)
+	        language=audio_attr.lang_code;
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].language=
+		    language;
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id=
+		    audio_id;
+	      switch (audio_attr.audio_format) {
+		case 0: // ac3
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_AC3_AID;
+		break;
+		case 6: // dts
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_DTS_AID;
+		break;
+		case 2: // mpeg layer 1/2/3
+		case 3: // mpeg2 ext
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_MPG_AID;
+		break;
+		case 4: // lpcm
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_PCM_AID;
+		break;
+		}
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].type=
+		    audio_attr.audio_format;
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].channels=
+		    audio_attr.channels;
+	      if (alang==i) dvdnav_priv->alang=
+		    dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id;
+	      dvdnav_priv->nr_of_channels++;
+	      }
+	    }
+	  dvdnav_priv->nr_of_subtitles=0;
+	  uint32_t sub_id;
+	  subp_attr_t subp_attr;
+	  for( i=0; i<32; i++)
+	    {
+	    if (-1!=(sub_id=dvdnav_get_spu_logical_stream(dvdnav_priv->dvdnav,
+		i))) {
+	      dvdnav_get_spu_attr(dvdnav_priv->dvdnav, i, &subp_attr);
+	      language=0;
+	      if(subp_attr.type==1) language=subp_attr.lang_code;
+	      dvdnav_priv->subtitles[dvdnav_priv->nr_of_subtitles].language=
+		    language;
+	      dvdnav_priv->subtitles[dvdnav_priv->nr_of_subtitles].id=
+		    sub_id;
+	      dvdnav_priv->nr_of_subtitles++;
+	      }
+	    }
+	  }
+	dvdnav_priv->cell_cellN=cell_change_event->cellN;
+	dvdnav_priv->cell_pgN=cell_change_event->pgN;
+	dvdnav_priv->cell_pgcN=pgcN;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: cell change\n");
+#endif
+	break; }
+      case DVDNAV_NAV_PACKET : {
+	event->eventflag.nav_packet=1;
+	event->eventflag.isevent=1;
+	pci_t* pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+	int buttonN;
+	if (pnavpci && pnavpci->hli.hl_gi.btn_ns) {
+	  dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &buttonN);	/* get current button ID */
+	  if (buttonN==0 || buttonN > pnavpci->hli.hl_gi.btn_ns)
+	    {
+	    dvdnav_button_select( dvdnav_priv->dvdnav , pnavpci, 1);
+#ifdef USE_MPDVDNAV_TRACE
+	    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: reset menu button number\n");
+#endif
+	    }
+	  }
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: nav packet\n");
+#endif
+#ifdef USE_MPDVDNAV_TRACE
+	dvdnav_print_buttons(dvdnav_priv,"highlight event");
+#endif
+	break; }
+      case DVDNAV_STOP: {
+        event->eventflag.stop=1;
+	event->eventflag.isevent=1;
+	dvdnav_priv->stopflg=1;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: stop\n");
+#endif
+	break; }
+      case DVDNAV_HIGHLIGHT : {
+	event->eventflag.highlight=1;
+	event->eventflag.isevent=1;
+	dvdnav_highlight_event_t *highlight_event =
+	    (dvdnav_highlight_event_t*)(buf);
+	event->hl_display=highlight_event->display;
+	/* libdvdnav v0.1.10: these fields are currently not set!! */
+	dvdnav_get_highlight(dvdnav_priv,highlight_event,1);
+	event->hl_palette=highlight_event->palette;
+	event->hl_sx=highlight_event->sx;
+	event->hl_sy=highlight_event->sy;
+	event->hl_ex=highlight_event->ex;
+	event->hl_ey=highlight_event->ey;
+	event->hl_pts=highlight_event->pts;
+	event->hl_buttonN=highlight_event->buttonN;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: highlight (%i:%i-%i:%i #%i)\n",
+	    event->hl_sx,
+	    event->hl_sy,
+	    event->hl_ex,
+	    event->hl_ey,
+	    event->hl_buttonN);
+#endif
+#ifdef USE_MPDVDNAV_TRACE
+	dvdnav_print_buttons(dvdnav_priv,"highlight event");
+#endif
+	break; }
+      case DVDNAV_SPU_CLUT_CHANGE: {
+	event->eventflag.spu_clut_change=1;
+	event->eventflag.isevent=1;
+	memcpy(event->spu_clut,buf,16*sizeof(uint32_t));
+	dvdnav_get_button_palette(dvdnav_priv,&(event->spu_palette));
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: spu clut change\n");
+#endif
+        break; }
+      case DVDNAV_HOP_CHANNEL : {
+	event->eventflag.hop_channel=1;
+	event->eventflag.isevent=1;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: hop channel\n");
+#endif
+	break; }
+      case DVDNAV_WAIT: {
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: wait\n");
+#endif
+        event->eventflag.wait=1;
+        event->eventflag.isevent=1;
+        int flag=0;
+        dvdnav_is_still_cell( dvdnav_priv->dvdnav , &flag);
+        if (!flag && dvdnav_priv->lockseek) {
+	  dvdnav_wait_back(dvdnav_priv->dvdnav);
+	  break; }
+	if (!dvdnav_priv->vts_domain && dvdnav_priv->cell_timer && !flag) {
+	pci_t* pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+	unsigned int end_time=(pnavpci->pci_gi.e_eltm.hour*3600+
+		pnavpci->pci_gi.e_eltm.minute*60+
+		pnavpci->pci_gi.e_eltm.second)*1000000;
+	unsigned int now = GetTimer();
+	float t;
+	t=now-dvdnav_priv->one_cell_timer;
+	dvdnav_priv->one_cell_timer=now;
+	t=t/1000000;
+	float rt=end_time-(now-dvdnav_priv->cell_timer);
+	rt=rt/1000000;
+	float et=end_time;
+	et=et/1000000;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: remains time %8.3f sec (%8.3f/%8.3f sec)\n",
+	    rt,et,t);
+#endif
+	if (t<2.00 && et>4.00) {				// correct cell play time?
+	  if (now-dvdnav_priv->cell_timer<end_time) {	// cell play time end?
+	    if (dvdnav_priv->waitcounter<DVDNAV_MAX_WAIT_FRAME)
+	      {
+	      dvdnav_wait_back(dvdnav_priv->dvdnav);
+	      dvdnav_priv->waitcounter++;
+	      }
+	    } else {
+	    dvdnav_priv->waitcounter=0;
+	    dvdnav_priv->cell_timer=0;
+	    dvdnav_priv->one_cell_timer=0;
+	    dvdnav_priv->back_from_timer=1;
+	    dvdnav_wait_still_clear(dvdnav_priv->dvdnav);
+	    }
+	  } else {
+	  dvdnav_wait_skip(dvdnav_priv->dvdnav);
+	  dvdnav_priv->waitcounter=0;
+	  dvdnav_priv->cell_timer=0;
+	  dvdnav_priv->one_cell_timer=0;
+	  }
+	} else {
+	dvdnav_wait_skip(dvdnav_priv->dvdnav);
+	if (!flag) {
+	  dvdnav_priv->cell_timer=0;
+	  dvdnav_priv->one_cell_timer=0;
+	  dvdnav_priv->waitcounter=0;
+	  }
+	}
+      break;
+      }
+    }
+  *len=0;
+  }
+return eventid;
+}
+
+
+static int fill_buffer(stream_t *s, char *but, int len)
+{
+int event;
+dvdnav_priv_t* dvdnav_priv=s->priv;
+len=0;
+while (len==0) /* grab all event until DVDNAV_BLOCK_OK (len=2048), DVDNAV_STOP or DVDNAV_STILL_FRAME */
+  {
+  if (-1==(event=dvdnav_stream_read(dvdnav_priv, s->buffer, &len,
+	    &(dvdnav_priv->event))) ||
+	len==-1)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,
+	"DVDNAV stream read error!\n");
+    return 0;
+    }
+  switch (event) {
+    case DVDNAV_STOP: return len; break; /* return eof */
+    case DVDNAV_STILL_FRAME: {
+      if (!dvdnav_priv->stillok) dvdnav_priv->stillcounter++;
+      dvdnav_priv->lockstillcounter++;
+      return len;
+      break; }/* return eof */
+    case DVDNAV_WAIT: {
+      if (dvdnav_priv->waitcounter>=DVDNAV_MAX_WAIT_FRAME) return len;
+      break;
+      }
+    }
+  if (dvdnav_priv->event.cell_really_change &&
+	dvdnav_priv->started &&
+	!dvdnav_priv->vts_domain) return len;
+  }
+mp_msg(MSGT_STREAM,MSGL_DBG2,"DVDNAV fill_buffer len: %d\n",len);
+return len;
+}
+
+dvdnav_priv_t * new_dvdnav_stream(char * filename, uint32_t titlenum)
+{
+char * title_str;
+dvdnav_priv_t *dvdnav_priv;
+if (!filename) return NULL;
+if (!(dvdnav_priv=(dvdnav_priv_t*)calloc(1,sizeof(*dvdnav_priv)))) return NULL;
+if (!(dvdnav_priv->filename=strdup(filename)))
+  {
+  free(dvdnav_priv);
+  return NULL;
+  }
+if(dvdnav_open(&(dvdnav_priv->dvdnav),dvdnav_priv->filename)!=
+    DVDNAV_STATUS_OK)
+  {
+  free(dvdnav_priv->filename);
+  free(dvdnav_priv);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav)
+  {
+  free(dvdnav_priv);
+  return NULL;
+  }
+/* turn on dvdnav caching */
+dvdnav_set_readahead_flag(dvdnav_priv->dvdnav,0);
+/* report the title?! */
+if (dvdmenu_lang)	// menu
+  {
+  if (dvdnav_menu_language_select(dvdnav_priv->dvdnav, dvdmenu_lang ) !=
+	DVDNAV_STATUS_OK)
+    mp_msg(MSGT_FIXME, MSGL_FIXME,
+	"Error on setting menu languages: %s\n",
+	dvdnav_err_to_string(dvdnav_priv->dvdnav));
+  }
+/* use title time length (default: part time length) */
+if (dvdnav_set_PGC_positioning_flag(dvdnav_priv->dvdnav, 1) !=
+	DVDNAV_STATUS_OK)
+  mp_msg(MSGT_FIXME, MSGL_FIXME,
+	"Error on setting pgc based: %s\n",
+	dvdnav_err_to_string(dvdnav_priv->dvdnav));
+dvdnav_event_clear(dvdnav_priv);
+if (titlenum>0) dvdnav_go_title=titlenum;
+dvdnav_priv->lastaspect=-1;
+return dvdnav_priv;
+}
+
+void free_dvdnav_stream(dvdnav_priv_t * dvdnav_priv)
+{
+if (!dvdnav_priv) return;
+dvdnav_close(dvdnav_priv->dvdnav);
+dvdnav_priv->dvdnav=NULL;
+free(dvdnav_priv);
+}
+
+
+static int open_s(stream_t *stream,int mode, void* opts, int* file_format)
+{
+struct stream_priv_s* p = (struct stream_priv_s*)opts;
+char *filename, *name;
+int event,len,tmplen=0;
+dvdnav_priv_t *dvdnav_priv;
+
+mp_msg(MSGT_OPEN,MSGL_INFO,"URL: %s\n", filename);
+filename = strdup(stream->url);
+name = (filename[9] == '\0') ? NULL : filename + 9;
+uint32_t titlenum=0;
+if (name) titlenum=atoi(name);	/* eg. mplayer dvdnav://1 */
+if (dvd_device)
+  {
+  if(!(dvdnav_priv=new_dvdnav_stream(dvd_device,titlenum)))
+    {
+    mp_msg(MSGT_OPEN,MSGL_ERR,MSGTR_CantOpenDVD,dvd_device);
+    return STREAM_UNSUPORTED;
+    }
+  } else {
+  if(!(dvdnav_priv=new_dvdnav_stream(DEFAULT_DVD_DEVICE,titlenum)))
+    {
+    mp_msg(MSGT_OPEN,MSGL_ERR,MSGTR_CantOpenDVD,dvd_device);
+    return STREAM_UNSUPORTED;
+    }
+  }
+stream->sector_size = 2048;
+stream->flags = STREAM_READ | STREAM_SEEK;
+stream->fill_buffer = fill_buffer;
+stream->seek = seek;
+stream->close = stream_dvdnav_close;
+stream->type = STREAMTYPE_DVDNAV;
+stream->priv=(void*)dvdnav_priv;
+return STREAM_OK;
+}
+
+stream_info_t stream_info_dvdnav = {
+  "DVDNAV stream",
+  "dvdnav",
+  "Otvos Attila",
+  "",
+  open_s,
+  { "dvdnav", NULL },
+  &stream_opts,
+  1 // Urls are an option string
+};
+
+#endif	// #ifdef USE_MPDVDNAV
diff -r 448a43f59a37 libmpdemux/stream_dvdnav.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdemux/stream_dvdnav.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvdnav.h,v 1.31 2003/06/09 15:17:44 mroi Exp $
+ *
+ */
+
+#ifndef __STREAM_DVDNAV_H_
+
+#ifdef USE_MPDVDNAV		// enable dvdnav support?
+
+#define __STREAM_DVDNAV_H_
+
+#ifdef USE_DVDREAD
+
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+#include "libmpdvdnav/dvdnav.h"
+
+extern int dvd_nav_skip_opening;
+extern int dvd_nav_still;
+extern int dvdnav_menutype;		/* dvdnav menu type: 0-SPU, 1-BOX, 2-SPU&BOX */
+extern int dvdnav_continue_play;
+extern int dvdnav_go_title;		/* dvdnav_title_play */
+extern int dvdnav_go_part;		/* dvdnav_part_play */
+extern int dvdnav_go_menu;		/* call main menu */
+extern int dvdnav_go_menu_force;	/* call force main menu with skip intro*/
+extern int dvdnav_go_audio;		/* dvdnav set new audio stream */
+extern int dvdnav_go_spu;		/* dbdnav set new spu stream */
+extern int dvdnav_force_menu;		/* force display menu with simple box */
+extern int dvdnav_skipintro;		/* skip intro before dvd menu */
+extern int dvdnav_color_spu;		/* enable color spu buttons */
+#ifdef USE_MPDVDNAV_TRACE
+extern int dvdnav_trace;		/* print trace messages (only devel)*/
+#endif
+extern char* dvdmenu_lang;		/* nav menu language */
+
+#ifdef HAVE_NEW_GUI
+extern int	dvdnav_window_width;
+extern int	dvdnav_window_height;
+extern int	dvdnav_window_orig_width;
+extern int	dvdnav_window_orig_height;
+extern int	dvdnav_mouse_x;
+extern int	dvdnav_mouse_y;
+extern int	dvdnav_mouse_button;
+extern int	dvdnav_mouse_set;
+#endif
+
+//#define DVDNAV_MAX_STILL_FRAME	5
+//#define DVDNAV_MAX_WAIT_FRAME	5
+#define DVDNAV_MAX_STILL_FRAME	5
+#define DVDNAV_MAX_WAIT_FRAME	5
+
+// dvdnav menu button types
+#define DVDNAV_MENUTYPE_SPU	0
+#define DVDNAV_MENUTYPE_BOX	1
+#define DVDNAV_MENUTYPE_SPU_BOX	2
+
+#undef max
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#undef min
+#define min(x,y) ((x) < (y) ? (x) : (y))
+
+typedef struct {
+  int event;             /* event number fromd dvdnav_events.h */
+  void * details;        /* event details */
+  int len;               /* bytes in details */
+} dvdnav_event_t;
+
+
+typedef struct stream_dvdnav_event_flg_st {
+    unsigned int nop : 1;			// 1
+    unsigned int still_frame : 1;		// 2
+    unsigned int spu_stream_change : 1;		// 3
+    unsigned int audio_stream_change : 1;	// 4
+    unsigned int vts_change : 1;		// 5
+    unsigned int cell_change : 1;		// 6
+    unsigned int nav_packet : 1;		// 7
+    unsigned int stop : 1;			// 8
+    unsigned int highlight : 1;			// 9
+    unsigned int spu_clut_change : 1;		// 10
+    unsigned int none1 : 1;
+    unsigned int hop_channel : 1;		// 12
+    unsigned int wait : 1;			// 13
+    unsigned int none2 : 2;
+    unsigned int isevent : 1;
+} stream_dvdnav_event_flg_t;
+
+
+typedef struct stream_dvdnav_event_st {
+stream_dvdnav_event_flg_t eventflag;
+off_t			eventid;
+// store dvdnav event parameters
+// DVDNAV_STILL_FRAME
+int 			still_length;
+// DVDNAV_SPU_STREAM_CHANGE
+int 			spu_physical_wide;
+int 			spu_physical_letterbox;
+int 			spu_physical_pan_scan;
+// DVDNAV_AUDIO_STREAM_CHANGE
+int 			audio_physical;
+int 			audio_logical;
+// DVDNAV_VTS_CHANGE
+int 			vts_old_vtsN;
+dvd_read_domain_t 	vts_old_domain;
+int 			vts_new_vtsN;
+dvd_read_domain_t 	vts_new_domain;
+// DVDNAV_CELL_CHANGE
+int 			cell_cellN;
+int 			cell_pgN;
+int64_t 		cell_cell_length;
+int64_t 		cell_pg_length;
+int64_t 		cell_pgc_length;
+int64_t 		cell_cell_start;
+int64_t 		cell_pg_start;
+int			cell_really_change;
+// DVDNAV_HIGHLIGHT
+int			hl_display;
+uint32_t		hl_palette;
+uint16_t		hl_sx,hl_sy,hl_ex,hl_ey;
+uint32_t		hl_pts;
+uint32_t		hl_buttonN;
+// DVDNAV_SPU_CLUT_CHANGE
+uint32_t 		spu_clut[16];
+uint32_t		spu_palette;
+} stream_dvdnav_event_t;
+
+
+
+typedef struct {
+ int id; // 0 - 31 mpeg; 128 - 159 ac3; 160 - 191 pcm
+ int language;
+ int type;
+ int channels;
+} nstream_language_t;
+
+typedef struct {
+    dvdnav_t			*dvdnav;		/* libdvdnav handle */
+    char			*filename;
+    int				started;		/* libdvdnav start */
+    int				stopflg;		/* libdvdnav stop event */
+    int 			vts_domain;		/* is vts domain flag */
+    int		   		old_vts_domain;		/* old vts domain flag */
+    uint32_t			tpos;			/* title pos */
+    uint32_t			tlen;			/* title length */
+    float			final_pts;		/* playback time */
+
+    int32_t 			title;			/* current title number */
+    int32_t 			part;			/* current chapter number */
+    int32_t			lasttitle;		/* last title number */
+    int32_t			lastpart;		/* last chapter number */
+
+    uint8_t  			alang;			/* current audio language */
+    uint8_t  			slang;			/* current spu language */
+    uint8_t			menu_sid;		/* current menu spu stream id */
+    uint8_t 			aspect;			/* current video aspect */
+    uint8_t			lastaspect;		/* last aspect */
+    uint32_t			titles_nr;		/* number of titles */
+    uint32_t			chapters_nr;		/* number of chapters in actual title */
+    int 			nr_of_channels;		/* number of audio channels */
+    nstream_language_t 		audio_streams[32]; 	/* audio properties */
+    int				nr_of_subtitles;	/* number of subtitles */
+    nstream_language_t 		subtitles[32];		/* subtitles properties */
+    stream_dvdnav_event_t	event;			/* dvdnav event storage st/ructure */
+    int				stillflg;		/* still frame mode */
+    int				stillcounter;
+    int				waitcounter;
+    int				lockstillcounter;
+    int				lockseek;		/* disable seek sector */
+    int				stillok;
+    unsigned int		cell_timer;		/* pgc cell timer */
+    unsigned int		one_cell_timer;		/* pgc only one cell timer */
+    int				back_from_timer;	/* if back from timer then nav_demux_seek required */
+
+    int				cell_cellN;		/* last cellN */
+    int				cell_pgN;		/* last pgN */
+    int				cell_pgcN;		/* last pgcN */
+    int				lock_pgN;		/* lock pgN */
+    int				lock_pgcN;		/* lock pgcN */
+} dvdnav_priv_t;
+
+// open new dvdnav stream
+dvdnav_priv_t * new_dvdnav_stream(char * filename, uint32_t titlenum);
+// read dvdnav block or event
+int dvdnav_stream_read(dvdnav_priv_t * dvdnav_priv, unsigned char *buf, 
+    int *len,stream_dvdnav_event_t *event);
+// clear all stored event
+void dvdnav_event_clear(dvdnav_priv_t * dvdnav_priv);
+// close and free dvdnav
+void free_dvdnav_stream(dvdnav_priv_t * dvdnav_priv);
+// get palette
+unsigned int * dvdnav_stream_get_palette(dvdnav_priv_t * dvdnav_priv);
+// call menu action UP,DOWN,LEFT,RIGHT,ACTIVATE & MENU
+int dvdnav_menu_action(dvdnav_priv_t * dvdnav_priv, int action);
+// go main menu with skip intro
+int dvdnav_menu_force(dvdnav_priv_t * dvdnav_priv);
+void dvdnav_stream_fullstart(dvdnav_priv_t *dvdnav_priv);
+// is dvdnav stop event?
+int dvdnav_reallyeof(dvdnav_priv_t * dvdnav_priv);
+// set languages
+void dvdnav_set_language(dvdnav_priv_t *dvdnav_priv, char* alang, 
+    char *slang, char *mlang);
+// get lang sid
+int dvdnav_lang_from_sid(dvdnav_priv_t * dvdnav_priv, int id);
+// get lang sid
+int dvdnav_sid_from_lang(dvdnav_priv_t * dvdnav_priv, unsigned char* lang);
+// get audio sid
+int dvdnav_aid_from_lang(dvdnav_priv_t * dvdnav_priv, unsigned char* lang);
+// get subtitles number
+int dvdnav_number_of_subs(dvdnav_priv_t * dvdnav_priv);
+// get highlight properties
+void dvdnav_get_highlight(dvdnav_priv_t *dvdnav_priv,
+    dvdnav_highlight_event_t *highlight_event,
+    int display_mode);
+// show menu button (dvdnav-trace)
+void dvdnav_print_buttons(dvdnav_priv_t *dvdnav_priv,char* txt);
+// get current button palette
+void dvdnav_get_button_palette(dvdnav_priv_t *dvdnav_priv,uint32_t *palette);
+#ifdef HAVE_NEW_GUI
+// hadler gmplayer mouse
+void dvdnav_mouse(dvdnav_priv_t * dvdnav_priv);
+#endif // HAVE_NEW_GUI
+#endif // USE_DVDREAD
+
+#endif // USE_MPDVDNAV
+#endif // __STREAM_DVDNAV_H_
diff -r 448a43f59a37 libmpdvdnav/Makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/Makefile	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,84 @@
+
+include ../config.mak
+
+SRCS = decoder.c \
+       dvdnav.c \
+       highlight.c \
+       navigation.c \
+       read_cache.c \
+       remap.c \
+       searching.c \
+       settings.c \
+       vm.c \
+       vmcmd.c
+
+OBJS = $(SRCS:.c=.o)
+
+LIB=libmpdvdnav
+
+.SUFFIXES: .c .o
+
+ifeq ($(OPTFLAGS),)
+OPTFLAGS = -mcpu=pentium -march=pentium -O4
+else
+OPTFLAGS += -DHAVE_MPLAYER
+endif
+
+#	 \ -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
+
+# -funroll-loops  removed, triggered gcc 3.0.4 (3.x?) bug
+CFLAGS= -I. -I.. $(OPTFLAGS) $(EXTRA_INC)\
+	-DSYS_LINUX -D__USE_UNIX98 -D_REENTRANT -D_GNU_SOURCE \
+	-DHAVE_DVDCSS_DVDCSS_H -DSTDC_HEADERS -DHAVE_LIMITS_H \
+	-DHAVE_ERRNO_H -DHAVE_INTTYPES_H -DHAVE_UNISTD_H \
+	-DHAVE_CONFIG_H \
+
+ifeq ($(TARGET_OS),CYGWIN)
+CFLAGS+=-DSYS_CYGWIN
+endif
+
+ifeq ($(TARGET_OS),Darwin)
+CFLAGS+=-D__DARWIN__
+endif
+
+INCLUDE = -I.. -I../loader $(CSS_INC) $(EXTRA_INC) $(LIBAV_INC)
+ifeq ($(DVDKIT2),yes)
+INCLUDE += -I../libmpdvdkit2 -I../../libmpdvdkit2
+else
+ifeq ($(DVDKIT),yes)
+INCLUDE += -I../libmpdvdkit -I../../libmpdvdkit
+endif
+endif
+
+.c.o:
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+all: $(LIB).a
+default: $(LIB).a
+
+$(LIB).a: $(OBJS)
+	$(AR) rc $(LIB).a $(OBJS)
+	$(RANLIB) $(LIB).a
+
+$(LIB).so: $(OBJS)
+	$(CC) -o $(LIB).so -shared -rdynamic $(OBJS)
+
+clean:
+	rm -f *.o *.a *~ *.so
+
+distclean: clean
+	rm -f .depend
+
+dep:    depend
+
+depend: .depend
+
+.depend: Makefile config.h
+	$(CC) -MM $(CFLAGS) $(SRCS) 1>.depend
+
+#
+# include dependency files if they exist
+#
+ifneq ($(wildcard .depend),)
+include .depend
+endif
diff -r 448a43f59a37 libmpdvdnav/config.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/config.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,2 @@
+/* Let it be for now*/
+#include "../config.h"
diff -r 448a43f59a37 libmpdvdnav/decoder.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/decoder.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,816 @@
+/*
+ * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
+ *               2002-2004 the dvdnav project
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is modified
+ * from a file originally part of the Ogle DVD player.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: decoder.c,v 1.2 2004/03/03 16:50:42 mroi Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <string.h>  /* For memset */
+
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+#include "dvdnav_internal.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+#ifdef USE_MPDVDNAV_TRACE
+extern int dvdnav_trace;
+#endif
+
+uint32_t vm_getbits(command_t *command, int32_t start, int32_t count) {
+  uint64_t result = 0;
+  uint64_t bit_mask = 0;
+  uint64_t examining = 0;
+  int32_t  bits;
+
+  if (count == 0) return 0;
+
+  if ( ((start - count) < -1) ||
+       (count > 32) ||
+       (start > 63) ||
+       (count < 0) ||
+       (start < 0) ) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_BadCallToVMGetbits);
+    abort();
+  }
+  /* all ones, please */
+  bit_mask = ~bit_mask;
+  bit_mask >>= 63 - start;
+  bits = start + 1 - count;
+  examining = ((bit_mask >> bits) << bits );
+  command->examined |= examining;
+  result = (command->instruction & bit_mask) >> bits;
+  return (uint32_t) result;
+}
+
+static uint16_t get_GPRM(registers_t* registers, uint8_t reg) {
+  if (registers->GPRM_mode[reg] & 0x01) {
+    struct timeval current_time, time_offset;
+    uint16_t result;
+    /* Counter mode */
+    /* mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Getting counter %d\n",reg);*/
+    gettimeofday(&current_time, NULL);
+    time_offset.tv_sec = current_time.tv_sec - registers->GPRM_time[reg].tv_sec;
+    time_offset.tv_usec = current_time.tv_usec - registers->GPRM_time[reg].tv_usec;
+    if (time_offset.tv_usec < 0) {
+      time_offset.tv_sec--;
+      time_offset.tv_usec += 1000000;
+    }
+    result = (uint16_t) (time_offset.tv_sec & 0xffff);
+    registers->GPRM[reg]=result;
+    return result;
+
+  } else {
+    /* Register mode */
+    return registers->GPRM[reg];
+  }
+
+}
+
+static void set_GPRM(registers_t* registers, uint8_t reg, uint16_t value) {
+  if (registers->GPRM_mode[reg] & 0x01) {
+    struct timeval current_time;
+    /* Counter mode */
+    /* mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Setting counter %d\n",reg); */
+    gettimeofday(&current_time, NULL);
+    registers->GPRM_time[reg] = current_time;
+    registers->GPRM_time[reg].tv_sec -= value;
+  }
+  registers->GPRM[reg] = value;
+}
+
+/* Eval register code, can either be system or general register.
+   SXXX_XXXX, where S is 1 if it is system register. */
+static uint16_t eval_reg(command_t* command, uint8_t reg) {
+  if(reg & 0x80) {
+    if ((reg & 0x1f) == 20) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_SuspectedRCERegionProtection);
+    }
+    return command->registers->SPRM[reg & 0x1f]; /*  FIXME max 24 not 32 */
+  } else {
+    return get_GPRM(command->registers, reg & 0x0f) ;
+  }
+}
+
+/* Eval register or immediate data.
+   AAAA_AAAA BBBB_BBBB, if immediate use all 16 bits for data else use
+   lower eight bits for the system or general purpose register. */
+static uint16_t eval_reg_or_data(command_t* command, int32_t imm, int32_t start) {
+  if(imm) { /*  immediate */
+    return vm_getbits(command, start, 16);
+  } else {
+    return eval_reg(command, vm_getbits(command, (start - 8), 8));
+  }
+}
+
+/* Eval register or immediate data.
+   xBBB_BBBB, if immediate use all 7 bits for data else use
+   lower four bits for the general purpose register number. */
+/* Evaluates gprm or data depending on bit, data is in byte n */
+static uint16_t eval_reg_or_data_2(command_t* command,
+				   int32_t imm, int32_t start) {
+  if(imm) /* immediate */
+    return vm_getbits(command, (start - 1), 7);
+  else
+    return get_GPRM(command->registers, (vm_getbits(command, (start - 4), 4)) );
+}
+
+
+/* Compare data using operation, return result from comparison.
+   Helper function for the different if functions. */
+static int32_t eval_compare(uint8_t operation, uint16_t data1, uint16_t data2) {
+  switch(operation) {
+    case 1:
+      return data1 & data2;
+    case 2:
+      return data1 == data2;
+    case 3:
+      return data1 != data2;
+    case 4:
+      return data1 >= data2;
+    case 5:
+      return data1 >  data2;
+    case 6:
+      return data1 <= data2;
+    case 7:
+      return data1 <  data2;
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_EvalCompareInvalidComparisonCode);
+  return 0;
+}
+
+
+/* Evaluate if version 1.
+   Has comparison data in byte 3 and 4-5 (immediate or register) */
+static int32_t eval_if_version_1(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+  if(op) {
+    return eval_compare(op, eval_reg(command, vm_getbits(command, 39, 8)),
+                            eval_reg_or_data(command, vm_getbits(command, 55, 1), 31));
+  }
+  return 1;
+}
+
+/* Evaluate if version 2.
+   This version only compares register which are in byte 6 and 7 */
+static int32_t eval_if_version_2(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+  if(op) {
+    return eval_compare(op, eval_reg(command, vm_getbits(command, 15, 8)),
+                            eval_reg(command, vm_getbits(command, 7, 8)));
+  }
+  return 1;
+}
+
+/* Evaluate if version 3.
+   Has comparison data in byte 2 and 6-7 (immediate or register) */
+static int32_t eval_if_version_3(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+  if(op) {
+    return eval_compare(op, eval_reg(command, vm_getbits(command, 47, 8)),
+                            eval_reg_or_data(command, vm_getbits(command, 55, 1), 15));
+  }
+  return 1;
+}
+
+/* Evaluate if version 4.
+   Has comparison data in byte 1 and 4-5 (immediate or register)
+   The register in byte 1 is only the lowe nibble (4 bits) */
+static int32_t eval_if_version_4(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+  if(op) {
+    return eval_compare(op, eval_reg(command, vm_getbits(command, 51, 4)),
+                            eval_reg_or_data(command, vm_getbits(command, 55, 1), 31));
+  }
+  return 1;
+}
+
+/* Evaluate special instruction.... returns the new row/line number,
+   0 if no new row and 256 if Break. */
+static int32_t eval_special_instruction(command_t* command, int32_t cond) {
+  int32_t line, level;
+
+  switch(vm_getbits(command, 51, 4)) {
+    case 0: /*  NOP */
+      line = 0;
+      return cond ? line : 0;
+    case 1: /*  Goto line */
+      line = vm_getbits(command, 7, 8);
+      return cond ? line : 0;
+    case 2: /*  Break */
+      /*  max number of rows < 256, so we will end this set */
+      line = 256;
+      return cond ? 256 : 0;
+    case 3: /*  Set temporary parental level and goto */
+      line = vm_getbits(command, 7, 8);
+      level = vm_getbits(command, 11, 4);
+      if(cond) {
+	/*  This always succeeds now, if we want real parental protection */
+	/*  we need to ask the user and have passwords and stuff. */
+	command->registers->SPRM[13] = level;
+      }
+      return cond ? line : 0;
+  }
+  return 0;
+}
+
+/* Evaluate link by subinstruction.
+   Return 1 if link, or 0 if no link
+   Actual link instruction is in return_values parameter */
+static int32_t eval_link_subins(command_t* command, int32_t cond, link_t *return_values) {
+  uint16_t button = vm_getbits(command, 15, 6);
+  uint8_t  linkop = vm_getbits(command, 4, 5);
+
+  if(linkop > 0x10)
+    return 0;    /*  Unknown Link by Sub-Instruction command */
+
+  /*  Assumes that the link_cmd_t enum has the same values as the LinkSIns codes */
+  return_values->command = linkop;
+  return_values->data1 = button;
+  return cond;
+}
+
+
+/* Evaluate link instruction.
+   Return 1 if link, or 0 if no link
+   Actual link instruction is in return_values parameter */
+static int32_t eval_link_instruction(command_t* command, int32_t cond, link_t *return_values) {
+  uint8_t op = vm_getbits(command, 51, 4);
+
+  switch(op) {
+    case 1:
+	return eval_link_subins(command, cond, return_values);
+    case 4:
+	return_values->command = LinkPGCN;
+	return_values->data1   = vm_getbits(command, 14, 15);
+	return cond;
+    case 5:
+	return_values->command = LinkPTTN;
+	return_values->data1 = vm_getbits(command, 9, 10);
+	return_values->data2 = vm_getbits(command, 15, 6);
+	return cond;
+    case 6:
+	return_values->command = LinkPGN;
+	return_values->data1 = vm_getbits(command, 6, 7);
+	return_values->data2 = vm_getbits(command, 15, 6);
+	return cond;
+    case 7:
+	return_values->command = LinkCN;
+	return_values->data1 = vm_getbits(command, 7, 8);
+	return_values->data2 = vm_getbits(command, 15, 6);
+	return cond;
+  }
+  return 0;
+}
+
+
+/* Evaluate a jump instruction.
+   returns 1 if jump or 0 if no jump
+   actual jump instruction is in return_values parameter */
+static int32_t eval_jump_instruction(command_t* command, int32_t cond, link_t *return_values) {
+
+  switch(vm_getbits(command, 51, 4)) {
+    case 1:
+      return_values->command = Exit;
+      return cond;
+    case 2:
+      return_values->command = JumpTT;
+      return_values->data1 = vm_getbits(command, 22, 7);
+      return cond;
+    case 3:
+      return_values->command = JumpVTS_TT;
+      return_values->data1 = vm_getbits(command, 22, 7);
+      return cond;
+    case 5:
+      return_values->command = JumpVTS_PTT;
+      return_values->data1 = vm_getbits(command, 22, 7);
+      return_values->data2 = vm_getbits(command, 41, 10);
+      return cond;
+    case 6:
+      switch(vm_getbits(command, 23, 2)) {
+        case 0:
+          return_values->command = JumpSS_FP;
+          return cond;
+        case 1:
+          return_values->command = JumpSS_VMGM_MENU;
+          return_values->data1 =  vm_getbits(command, 19, 4);
+          return cond;
+        case 2:
+          return_values->command = JumpSS_VTSM;
+          return_values->data1 =  vm_getbits(command, 31, 8);
+          return_values->data2 =  vm_getbits(command, 39, 8);
+          return_values->data3 =  vm_getbits(command, 19, 4);
+          return cond;
+        case 3:
+          return_values->command = JumpSS_VMGM_PGC;
+          return_values->data1 =  vm_getbits(command, 46, 15);
+          return cond;
+        }
+      break;
+    case 8:
+      switch(vm_getbits(command, 23, 2)) {
+        case 0:
+          return_values->command = CallSS_FP;
+          return_values->data1 = vm_getbits(command, 31, 8);
+          return cond;
+        case 1:
+          return_values->command = CallSS_VMGM_MENU;
+          return_values->data1 = vm_getbits(command, 19, 4);
+          return_values->data2 = vm_getbits(command, 31, 8);
+          return cond;
+        case 2:
+          return_values->command = CallSS_VTSM;
+          return_values->data1 = vm_getbits(command, 19, 4);
+          return_values->data2 = vm_getbits(command, 31, 8);
+          return cond;
+        case 3:
+          return_values->command = CallSS_VMGM_PGC;
+          return_values->data1 = vm_getbits(command, 46, 15);
+          return_values->data2 = vm_getbits(command, 31, 8);
+          return cond;
+      }
+      break;
+  }
+  return 0;
+}
+
+/* Evaluate a set sytem register instruction
+   May contain a link so return the same as eval_link */
+static int32_t eval_system_set(command_t* command, int32_t cond, link_t *return_values) {
+  int32_t i;
+  uint16_t data, data2;
+
+  switch(vm_getbits(command, 59, 4)) {
+    case 1: /*  Set system reg 1 &| 2 &| 3 (Audio, Subp. Angle) */
+      for(i = 1; i <= 3; i++) {
+        if(vm_getbits(command, 63 - ((2 + i)*8), 1)) {
+          data = eval_reg_or_data_2(command, vm_getbits(command, 60, 1), (47 - (i*8)));
+          if(cond) {
+            command->registers->SPRM[i] = data;
+          }
+        }
+      }
+      break;
+    case 2: /*  Set system reg 9 & 10 (Navigation timer, Title PGC number) */
+      data = eval_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+      data2 = vm_getbits(command, 23, 8); /*  ?? size */
+      if(cond) {
+	command->registers->SPRM[9] = data; /*  time */
+	command->registers->SPRM[10] = data2; /*  pgcN */
+      }
+      break;
+    case 3: /*  Mode: Counter / Register + Set */
+      data = eval_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+      data2 = vm_getbits(command, 19, 4);
+      if(vm_getbits(command, 23, 1)) {
+	command->registers->GPRM_mode[data2] |= 1; /* Set bit 0 */
+      } else {
+	command->registers->GPRM_mode[data2] &= ~ 0x01; /* Reset bit 0 */
+      }
+      if(cond) {
+        set_GPRM(command->registers, data2, data);
+      }
+      break;
+    case 6: /*  Set system reg 8 (Highlighted button) */
+      data = eval_reg_or_data(command, vm_getbits(command, 60, 1), 31); /*  Not system reg!! */
+      if(cond) {
+	command->registers->SPRM[8] = data;
+      }
+      break;
+  }
+  if(vm_getbits(command, 51, 4)) {
+    return eval_link_instruction(command, cond, return_values);
+  }
+  return 0;
+}
+
+
+/* Evaluate set operation
+   Sets the register given to the value indicated by op and data.
+   For the swap case the contents of reg is stored in reg2.
+*/
+static void eval_set_op(command_t* command, int32_t op, int32_t reg, int32_t reg2, int32_t data) {
+  const int32_t shortmax = 0xffff;
+  int32_t     tmp;
+  switch(op) {
+    case 1:
+      set_GPRM(command->registers, reg, data);
+      break;
+    case 2: /* SPECIAL CASE - SWAP! */
+      set_GPRM(command->registers, reg2, get_GPRM(command->registers, reg));
+      set_GPRM(command->registers, reg, data);
+      break;
+    case 3:
+      tmp = get_GPRM(command->registers, reg) + data;
+      if(tmp > shortmax) tmp = shortmax;
+      set_GPRM(command->registers, reg, (uint16_t)tmp);
+      break;
+    case 4:
+      tmp = get_GPRM(command->registers, reg) - data;
+      if(tmp < 0) tmp = 0;
+      set_GPRM(command->registers, reg, (uint16_t)tmp);
+      break;
+    case 5:
+      tmp = get_GPRM(command->registers, reg) * data;
+      if(tmp > shortmax) tmp = shortmax;
+      set_GPRM(command->registers, reg, (uint16_t)tmp);
+      break;
+    case 6:
+      if (data != 0) {
+        set_GPRM(command->registers, reg, (get_GPRM(command->registers, reg) / data) );
+      } else {
+        set_GPRM(command->registers, reg, 0xffff); /* Avoid that divide by zero! */
+      }
+      break;
+    case 7:
+      if (data != 0) {
+        set_GPRM(command->registers, reg, (get_GPRM(command->registers, reg) % data) );
+      } else {
+        set_GPRM(command->registers, reg, 0xffff); /* Avoid that divide by zero! */
+      }
+      break;
+    case 8: /* SPECIAL CASE - RND! Return numbers between 1 and data. */
+      set_GPRM(command->registers, reg, 1 + ((uint16_t) ((float) data * rand()/(RAND_MAX+1.0))) );
+      break;
+    case 9:
+      set_GPRM(command->registers, reg, (get_GPRM(command->registers, reg) & data) );
+      break;
+    case 10:
+      set_GPRM(command->registers, reg, (get_GPRM(command->registers, reg) | data) );
+      break;
+    case 11:
+      set_GPRM(command->registers, reg, (get_GPRM(command->registers, reg) ^ data) );
+      break;
+  }
+}
+
+/* Evaluate set instruction, combined with either Link or Compare. */
+static void eval_set_version_1(command_t* command, int32_t cond) {
+  uint8_t  op   = vm_getbits(command, 59, 4);
+  uint8_t  reg  = vm_getbits(command, 35, 4); /* FIXME: This is different from vmcmd.c!!! */
+  uint8_t  reg2 = vm_getbits(command, 19, 4);
+  uint16_t data = eval_reg_or_data(command, vm_getbits(command, 60, 1), 31);
+
+  if(cond) {
+    eval_set_op(command, op, reg, reg2, data);
+  }
+}
+
+
+/* Evaluate set instruction, combined with both Link and Compare. */
+static void eval_set_version_2(command_t* command, int32_t cond) {
+  uint8_t  op   = vm_getbits(command, 59, 4);
+  uint8_t  reg  = vm_getbits(command, 51, 4);
+  uint8_t  reg2 = vm_getbits(command, 35, 4); /* FIXME: This is different from vmcmd.c!!! */
+  uint16_t data = eval_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+
+  if(cond) {
+    eval_set_op(command, op, reg, reg2, data);
+  }
+}
+
+
+/* Evaluate a command
+   returns row number of goto, 0 if no goto, -1 if link.
+   Link command in return_values */
+static int32_t eval_command(uint8_t *bytes, registers_t* registers, link_t *return_values) {
+  int32_t cond, res = 0;
+  command_t command;
+  command.instruction =( (uint64_t) bytes[0] << 56 ) |
+        ( (uint64_t) bytes[1] << 48 ) |
+        ( (uint64_t) bytes[2] << 40 ) |
+        ( (uint64_t) bytes[3] << 32 ) |
+        ( (uint64_t) bytes[4] << 24 ) |
+        ( (uint64_t) bytes[5] << 16 ) |
+        ( (uint64_t) bytes[6] <<  8 ) |
+          (uint64_t) bytes[7] ;
+  command.examined = 0;
+  command.registers = registers;
+  memset(return_values, 0, sizeof(link_t));
+
+  switch(vm_getbits(&command, 63, 3)) { /* three first old_bits */
+    case 0: /*  Special instructions */
+      cond = eval_if_version_1(&command);
+      res = eval_special_instruction(&command, cond);
+      if(res == -1) {
+	mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_UnknownInstrution);
+	abort();
+      }
+      break;
+    case 1: /*  Link/jump instructions */
+      if(vm_getbits(&command, 60, 1)) {
+        cond = eval_if_version_2(&command);
+        res = eval_jump_instruction(&command, cond, return_values);
+      } else {
+        cond = eval_if_version_1(&command);
+        res = eval_link_instruction(&command, cond, return_values);
+      }
+      if(res)
+	res = -1;
+      break;
+    case 2: /*  System set instructions */
+      cond = eval_if_version_2(&command);
+      res = eval_system_set(&command, cond, return_values);
+      if(res)
+	res = -1;
+      break;
+    case 3: /*  Set instructions, either Compare or Link may be used */
+      cond = eval_if_version_3(&command);
+      eval_set_version_1(&command, cond);
+      if(vm_getbits(&command, 51, 4)) {
+	res = eval_link_instruction(&command, cond, return_values);
+      }
+      if(res)
+	res = -1;
+      break;
+    case 4: /*  Set, Compare -> Link Sub-Instruction */
+      eval_set_version_2(&command, /*True*/ 1);
+      cond = eval_if_version_4(&command);
+      res = eval_link_subins(&command, cond, return_values);
+      if(res)
+	res = -1;
+      break;
+    case 5: /*  Compare -> (Set and Link Sub-Instruction) */
+      /* FIXME: These are wrong. Need to be updated from vmcmd.c */
+      cond = eval_if_version_4(&command);
+      eval_set_version_2(&command, cond);
+      res = eval_link_subins(&command, cond, return_values);
+      if(res)
+	res = -1;
+      break;
+    case 6: /*  Compare -> Set, allways Link Sub-Instruction */
+      /* FIXME: These are wrong. Need to be updated from vmcmd.c */
+      cond = eval_if_version_4(&command);
+      eval_set_version_2(&command, cond);
+      res = eval_link_subins(&command, /*True*/ 1, return_values);
+      if(res)
+	res = -1;
+      break;
+    default: /* Unknown command */
+       mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_WarningUnknownComman, vm_getbits(&command, 63, 3));
+      abort();
+  }
+  /*  Check if there are bits not yet examined */
+
+  if(command.instruction & ~ command.examined) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCWarningUnknownBits);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO," %08llx", (command.instruction & ~ command.examined) );
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "]\n");
+  }
+
+  return res;
+}
+
+/* Evaluate a set of commands in the given register set (which is modified) */
+int32_t vmEval_CMD(vm_cmd_t commands[], int32_t num_commands,
+	       registers_t *registers, link_t *return_values) {
+  int32_t i = 0;
+  int32_t total = 0;
+
+#ifdef USE_MPDVDNAV_TRACE
+  /*  DEBUG */
+  if (dvdnav_trace) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Registers before transaction\n");
+  vm_print_registers( registers );
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Full list of commands to execute\n");
+  for(i = 0; i < num_commands; i++)
+    vm_print_cmd(i, &commands[i]);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: --------------------------------------------\n");
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Single stepping commands\n");}
+#endif
+
+  i = 0;
+  while(i < num_commands && total < 100000) {
+    int32_t line;
+
+#ifdef TRACE
+  if (dvdnav_trace) vm_print_cmd(i, &commands[i]);
+#endif
+
+    line = eval_command(&commands[i].bytes[0], registers, return_values);
+
+    if (line < 0) { /*  Link command */
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Registers after transaction\n");
+      vm_print_registers( registers );
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: eval: Doing Link/Jump/Call\n"); }
+#endif
+      return 1;
+    }
+
+    if (line > 0) /*  Goto command */
+      i = line - 1;
+    else /*  Just continue on the next line */
+      i++;
+
+    total++;
+  }
+
+  memset(return_values, 0, sizeof(link_t));
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Registers after transaction\n");
+  vm_print_registers( registers ); }
+#endif
+  return 0;
+}
+
+#ifdef USE_MPDVDNAV_TRACE
+
+static char *linkcmd2str(link_cmd_t cmd) {
+  switch(cmd) {
+  case LinkNoLink:
+    return "LinkNoLink";
+  case LinkTopC:
+    return "LinkTopC";
+  case LinkNextC:
+    return "LinkNextC";
+  case LinkPrevC:
+    return "LinkPrevC";
+  case LinkTopPG:
+    return "LinkTopPG";
+  case LinkNextPG:
+    return "LinkNextPG";
+  case LinkPrevPG:
+    return "LinkPrevPG";
+  case LinkTopPGC:
+    return "LinkTopPGC";
+  case LinkNextPGC:
+    return "LinkNextPGC";
+  case LinkPrevPGC:
+    return "LinkPrevPGC";
+  case LinkGoUpPGC:
+    return "LinkGoUpPGC";
+  case LinkTailPGC:
+    return "LinkTailPGC";
+  case LinkRSM:
+    return "LinkRSM";
+  case LinkPGCN:
+    return "LinkPGCN";
+  case LinkPTTN:
+    return "LinkPTTN";
+  case LinkPGN:
+    return "LinkPGN";
+  case LinkCN:
+    return "LinkCN";
+  case Exit:
+    return "Exit";
+  case JumpTT:
+    return "JumpTT";
+  case JumpVTS_TT:
+    return "JumpVTS_TT";
+  case JumpVTS_PTT:
+    return "JumpVTS_PTT";
+  case JumpSS_FP:
+    return "JumpSS_FP";
+  case JumpSS_VMGM_MENU:
+    return "JumpSS_VMGM_MENU";
+  case JumpSS_VTSM:
+    return "JumpSS_VTSM";
+  case JumpSS_VMGM_PGC:
+    return "JumpSS_VMGM_PGC";
+  case CallSS_FP:
+    return "CallSS_FP";
+  case CallSS_VMGM_MENU:
+    return "CallSS_VMGM_MENU";
+  case CallSS_VTSM:
+    return "CallSS_VTSM";
+  case CallSS_VMGM_PGC:
+    return "CallSS_VMGM_PGC";
+  case PlayThis:
+    return "PlayThis";
+  }
+  return "*** (bug)";
+}
+
+void vm_print_link(link_t value) {
+  char *cmd = linkcmd2str(value.command);
+
+  switch(value.command) {
+  case LinkNoLink:
+  case LinkTopC:
+  case LinkNextC:
+  case LinkPrevC:
+  case LinkTopPG:
+  case LinkNextPG:
+  case LinkPrevPG:
+  case LinkTopPGC:
+  case LinkNextPGC:
+  case LinkPrevPGC:
+  case LinkGoUpPGC:
+  case LinkTailPGC:
+  case LinkRSM:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCButton, cmd, value.data1);
+    break;
+  case LinkPGCN:
+  case JumpTT:
+  case JumpVTS_TT:
+  case JumpSS_VMGM_MENU: /*  == 2 -> Title Menu */
+  case JumpSS_VMGM_PGC:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: %s %d\n", cmd, value.data1);
+    break;
+  case LinkPTTN:
+  case LinkPGN:
+  case LinkCN:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCButton2, cmd, value.data1, value.data2);
+    break;
+  case Exit:
+  case JumpSS_FP:
+  case PlayThis: /*  Humm.. should we have this at all.. */
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: %s\n", cmd);
+    break;
+  case JumpVTS_PTT:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: %s %d:%d\n", cmd, value.data1, value.data2);
+    break;
+  case JumpSS_VTSM:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCVtsTitleMenu,
+	    cmd, value.data1, value.data2, value.data3);
+    break;
+  case CallSS_FP:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCResumeCell, cmd, value.data1);
+    break;
+  case CallSS_VMGM_MENU: /*  == 2 -> Title Menu */
+  case CallSS_VTSM:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCResumeCell2, cmd, value.data1, value.data2);
+    break;
+  case CallSS_VMGM_PGC:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCResumeCell2, cmd, value.data1, value.data2);
+    break;
+  }
+ }
+
+void vm_print_registers( registers_t *registers ) {
+  int32_t i;
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav:    #   ");
+  for(i = 0; i < 24; i++)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %2d |", i);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: SRPMS: ");
+  for(i = 0; i < 24; i++)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04x|", registers->SPRM[i]);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: GRPMS: ");
+  for(i = 0; i < 16; i++)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04x|", get_GPRM(registers, i) );
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: Gmode: ");
+  for(i = 0; i < 16; i++)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04x|", registers->GPRM_mode[i]);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: Gtime: ");
+  for(i = 0; i < 16; i++)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04lx|", registers->GPRM_time[i].tv_sec & 0xffff);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+}
+
+#endif
+
diff -r 448a43f59a37 libmpdvdnav/decoder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/decoder.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is modified
+ * from a file originally part of the Ogle DVD player.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: decoder.h,v 1.1 2004/01/11 21:43:13 mroi Exp $
+ *
+ */
+
+#ifndef DECODER_H_INCLUDED
+#define DECODER_H_INCLUDED
+
+#include <inttypes.h>
+#include <sys/time.h>
+
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+#include "dvdnav_internal.h"
+
+/* link command types */
+typedef enum {
+  LinkNoLink  = 0,
+
+  LinkTopC    = 1,
+  LinkNextC   = 2,
+  LinkPrevC   = 3,
+
+  LinkTopPG   = 5,
+  LinkNextPG  = 6,
+  LinkPrevPG  = 7,
+
+  LinkTopPGC  = 9,
+  LinkNextPGC = 10,
+  LinkPrevPGC = 11,
+  LinkGoUpPGC = 12,
+  LinkTailPGC = 13,
+
+  LinkRSM     = 16,
+
+  LinkPGCN,
+  LinkPTTN,
+  LinkPGN,
+  LinkCN,
+
+  Exit,
+
+  JumpTT, /* 22 */
+  JumpVTS_TT,
+  JumpVTS_PTT,
+
+  JumpSS_FP,
+  JumpSS_VMGM_MENU,
+  JumpSS_VTSM,
+  JumpSS_VMGM_PGC,
+
+  CallSS_FP, /* 29 */
+  CallSS_VMGM_MENU,
+  CallSS_VTSM,
+  CallSS_VMGM_PGC,
+
+  PlayThis
+} link_cmd_t;
+
+/* a link's data set */
+typedef struct {
+  link_cmd_t command;
+  uint16_t   data1;
+  uint16_t   data2;
+  uint16_t   data3;
+} link_t;
+
+/* the VM registers */
+typedef struct {
+  uint16_t SPRM[24];
+  uint16_t GPRM[16];
+  uint8_t  GPRM_mode[16];  /* Need to have some thing to indicate normal/counter mode for every GPRM */
+  struct timeval GPRM_time[16]; /* For counter mode */
+} registers_t;
+
+/* a VM command data set */
+typedef struct {
+  uint64_t instruction;
+  uint64_t examined;
+  registers_t *registers;
+} command_t;
+
+/* the big VM function, executing the given commands and writing
+ * the link where to continue, the return value indicates if a jump
+ * has been performed */
+int32_t vmEval_CMD(vm_cmd_t commands[], int32_t num_commands,
+	       registers_t *registers, link_t *return_values);
+
+/* extracts some bits from the command */
+uint32_t vm_getbits(command_t* command, int32_t start, int32_t count);
+
+#ifdef USE_MPDVDNAV_TRACE
+/* for debugging: prints a link in readable form */
+void vm_print_link(link_t value);
+
+/* for debugging: dumps VM registers */
+void vm_print_registers( registers_t *registers );
+#endif
+
+#endif /* DECODER_H_INCLUDED */
diff -r 448a43f59a37 libmpdvdnav/dvd_types.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/dvd_types.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2000, 2001 Bjrn Englund, Hkan Hjort
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is a modified
+ * file originally part of the Ogle DVD player project.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvd_types.h,v 1.7 2003/04/21 13:18:06 mroi Exp $
+ *
+ */
+
+/*
+ * Various useful structs and enums for DVDs.
+ */
+
+#ifndef DVD_H_INCLUDED
+#define DVD_H_INCLUDED
+
+#include <inttypes.h>
+
+
+/*
+ * DVD Menu ID
+ * (see dvdnav_menu_call())
+ */
+typedef enum {
+  /* When used in VTS domain, DVD_MENU_Escape behaves like DVD_MENU_Root,
+   * but from within a menu domain, DVD_MENU_Escape resumes playback. */
+  DVD_MENU_Escape     = 0,
+  DVD_MENU_Title      = 2,
+  DVD_MENU_Root       = 3,
+  DVD_MENU_Subpicture = 4,
+  DVD_MENU_Audio      = 5,
+  DVD_MENU_Angle      = 6,
+  DVD_MENU_Part       = 7
+} DVDMenuID_t;
+
+
+/*
+ * Structure containing info on highlight areas
+ * (see dvdnav_get_highlight_area())
+ */
+typedef struct {
+  uint32_t palette;     /* The CLUT entries for the highlight palette
+			   (4-bits per entry -> 4 entries) */
+  uint16_t sx,sy,ex,ey; /* The start/end x,y positions */
+  uint32_t pts;         /* Highlight PTS to match with SPU */
+
+  /* button number for the SPU decoder/overlaying engine */
+  uint32_t buttonN;
+} dvdnav_highlight_area_t;
+
+
+/* the following types are currently unused */
+
+#if 0
+
+/* Domain */
+typedef enum {
+  DVD_DOMAIN_FirstPlay,  /* First Play Domain */
+  DVD_DOMAIN_VMG,        /* Video Manager Domain */
+  DVD_DOMAIN_VTSMenu,    /* Video Title Set Menu Domain */
+  DVD_DOMAIN_VTSTitle,   /* Video Title Set Domain */
+  DVD_DOMAIN_Stop        /* Stop Domain */
+} DVDDomain_t;
+
+/* User operation permissions */
+typedef enum {
+  UOP_FLAG_TitleOrTimePlay            = 0x00000001,
+  UOP_FLAG_ChapterSearchOrPlay        = 0x00000002,
+  UOP_FLAG_TitlePlay                  = 0x00000004,
+  UOP_FLAG_Stop                       = 0x00000008,
+  UOP_FLAG_GoUp                       = 0x00000010,
+  UOP_FLAG_TimeOrChapterSearch        = 0x00000020,
+  UOP_FLAG_PrevOrTopPGSearch          = 0x00000040,
+  UOP_FLAG_NextPGSearch               = 0x00000080,
+  UOP_FLAG_ForwardScan                = 0x00000100,
+  UOP_FLAG_BackwardScan               = 0x00000200,
+  UOP_FLAG_TitleMenuCall              = 0x00000400,
+  UOP_FLAG_RootMenuCall               = 0x00000800,
+  UOP_FLAG_SubPicMenuCall             = 0x00001000,
+  UOP_FLAG_AudioMenuCall              = 0x00002000,
+  UOP_FLAG_AngleMenuCall              = 0x00004000,
+  UOP_FLAG_ChapterMenuCall            = 0x00008000,
+  UOP_FLAG_Resume                     = 0x00010000,
+  UOP_FLAG_ButtonSelectOrActivate     = 0x00020000,
+  UOP_FLAG_StillOff                   = 0x00040000,
+  UOP_FLAG_PauseOn                    = 0x00080000,
+  UOP_FLAG_AudioStreamChange          = 0x00100000,
+  UOP_FLAG_SubPicStreamChange         = 0x00200000,
+  UOP_FLAG_AngleChange                = 0x00400000,
+  UOP_FLAG_KaraokeAudioPresModeChange = 0x00800000,
+  UOP_FLAG_VideoPresModeChange        = 0x01000000
+} DVDUOP_t;
+
+/* Parental Level */
+typedef enum {
+  DVD_PARENTAL_LEVEL_1 = 1,
+  DVD_PARENTAL_LEVEL_2 = 2,
+  DVD_PARENTAL_LEVEL_3 = 3,
+  DVD_PARENTAL_LEVEL_4 = 4,
+  DVD_PARENTAL_LEVEL_5 = 5,
+  DVD_PARENTAL_LEVEL_6 = 6,
+  DVD_PARENTAL_LEVEL_7 = 7,
+  DVD_PARENTAL_LEVEL_8 = 8,
+  DVD_PARENTAL_LEVEL_None = 15
+} DVDParentalLevel_t;
+
+/* Language ID (ISO-639 language code) */
+typedef uint16_t DVDLangID_t;
+
+/* Country ID (ISO-3166 country code) */
+typedef uint16_t DVDCountryID_t;
+
+/* Register */
+typedef uint16_t DVDRegister_t;
+typedef enum {
+  DVDFalse = 0,
+  DVDTrue = 1
+} DVDBool_t;
+typedef DVDRegister_t DVDGPRMArray_t[16];
+typedef DVDRegister_t DVDSPRMArray_t[24];
+
+/* Navigation */
+typedef int DVDStream_t;
+typedef int DVDPTT_t;
+typedef int DVDTitle_t;
+
+/* Angle number (1-9 or default?) */
+typedef int DVDAngle_t;
+
+/* Timecode */
+typedef struct {
+  uint8_t Hours;
+  uint8_t Minutes;
+  uint8_t Seconds;
+  uint8_t Frames;
+} DVDTimecode_t;
+
+/* Subpicture stream number (0-31,62,63) */
+typedef int DVDSubpictureStream_t;
+
+/* Audio stream number (0-7, 15(none)) */
+typedef int DVDAudioStream_t;
+
+/* The audio application mode */
+typedef enum {
+  DVD_AUDIO_APP_MODE_None     = 0,
+  DVD_AUDIO_APP_MODE_Karaoke  = 1,
+  DVD_AUDIO_APP_MODE_Surround = 2,
+  DVD_AUDIO_APP_MODE_Other    = 3
+} DVDAudioAppMode_t;
+
+/* The audio format */
+typedef enum {
+  DVD_AUDIO_FORMAT_AC3       = 0,
+  DVD_AUDIO_FORMAT_MPEG1     = 1,
+  DVD_AUDIO_FORMAT_MPEG1_DRC = 2,
+  DVD_AUDIO_FORMAT_MPEG2     = 3,
+  DVD_AUDIO_FORMAT_MPEG2_DRC = 4,
+  DVD_AUDIO_FORMAT_LPCM      = 5,
+  DVD_AUDIO_FORMAT_DTS       = 6,
+  DVD_AUDIO_FORMAT_SDDS      = 7,
+  DVD_AUDIO_FORMAT_Other     = 8
+} DVDAudioFormat_t;
+
+/* Audio language extension */
+typedef enum {
+  DVD_AUDIO_LANG_EXT_NotSpecified       = 0,
+  DVD_AUDIO_LANG_EXT_NormalCaptions     = 1,
+  DVD_AUDIO_LANG_EXT_VisuallyImpaired   = 2,
+  DVD_AUDIO_LANG_EXT_DirectorsComments1 = 3,
+  DVD_AUDIO_LANG_EXT_DirectorsComments2 = 4
+} DVDAudioLangExt_t;
+
+/* Subpicture language extension */
+typedef enum {
+  DVD_SUBPICTURE_LANG_EXT_NotSpecified  = 0,
+  DVD_SUBPICTURE_LANG_EXT_NormalCaptions  = 1,
+  DVD_SUBPICTURE_LANG_EXT_BigCaptions  = 2,
+  DVD_SUBPICTURE_LANG_EXT_ChildrensCaptions  = 3,
+  DVD_SUBPICTURE_LANG_EXT_NormalCC  = 5,
+  DVD_SUBPICTURE_LANG_EXT_BigCC  = 6,
+  DVD_SUBPICTURE_LANG_EXT_ChildrensCC  = 7,
+  DVD_SUBPICTURE_LANG_EXT_Forced  = 9,
+  DVD_SUBPICTURE_LANG_EXT_NormalDirectorsComments  = 13,
+  DVD_SUBPICTURE_LANG_EXT_BigDirectorsComments  = 14,
+  DVD_SUBPICTURE_LANG_EXT_ChildrensDirectorsComments  = 15,
+} DVDSubpictureLangExt_t;
+
+/* Karaoke Downmix mode */
+typedef enum {
+  DVD_KARAOKE_DOWNMIX_0to0 = 0x0001,
+  DVD_KARAOKE_DOWNMIX_1to0 = 0x0002,
+  DVD_KARAOKE_DOWNMIX_2to0 = 0x0004,
+  DVD_KARAOKE_DOWNMIX_3to0 = 0x0008,
+  DVD_KARAOKE_DOWNMIX_4to0 = 0x0010,
+  DVD_KARAOKE_DOWNMIX_Lto0 = 0x0020,
+  DVD_KARAOKE_DOWNMIX_Rto0 = 0x0040,
+  DVD_KARAOKE_DOWNMIX_0to1 = 0x0100,
+  DVD_KARAOKE_DOWNMIX_1to1 = 0x0200,
+  DVD_KARAOKE_DOWNMIX_2to1 = 0x0400,
+  DVD_KARAOKE_DOWNMIX_3to1 = 0x0800,
+  DVD_KARAOKE_DOWNMIX_4to1 = 0x1000,
+  DVD_KARAOKE_DOWNMIX_Lto1 = 0x2000,
+  DVD_KARAOKE_DOWNMIX_Rto1 = 0x4000
+} DVDKaraokeDownmix_t;
+typedef int DVDKaraokeDownmixMask_t;
+
+/* Display mode */
+typedef enum {
+  DVD_DISPLAY_MODE_ContentDefault = 0,
+  DVD_DISPLAY_MODE_16x9 = 1,
+  DVD_DISPLAY_MODE_4x3PanScan = 2,
+  DVD_DISPLAY_MODE_4x3Letterboxed = 3
+} DVDDisplayMode_t;
+
+/* Audio attributes */
+typedef struct {
+  DVDAudioAppMode_t     AppMode;
+  DVDAudioFormat_t      AudioFormat;
+  DVDLangID_t           Language;
+  DVDAudioLangExt_t     LanguageExtension;
+  DVDBool_t             HasMultichannelInfo;
+  DVDAudioSampleFreq_t  SampleFrequency;
+  DVDAudioSampleQuant_t SampleQuantization;
+  DVDChannelNumber_t    NumberOfChannels;
+} DVDAudioAttributes_t;
+typedef int DVDAudioSampleFreq_t;
+typedef int DVDAudioSampleQuant_t;
+typedef int DVDChannelNumber_t;
+
+/* Subpicture attributes */
+typedef enum {
+  DVD_SUBPICTURE_TYPE_NotSpecified = 0,
+  DVD_SUBPICTURE_TYPE_Language     = 1,
+  DVD_SUBPICTURE_TYPE_Other        = 2
+} DVDSubpictureType_t;
+typedef enum {
+  DVD_SUBPICTURE_CODING_RunLength = 0,
+  DVD_SUBPICTURE_CODING_Extended  = 1,
+  DVD_SUBPICTURE_CODING_Other     = 2
+} DVDSubpictureCoding_t;
+typedef struct {
+  DVDSubpictureType_t    Type;
+  DVDSubpictureCoding_t  CodingMode;
+  DVDLangID_t            Language;
+  DVDSubpictureLangExt_t LanguageExtension;
+} DVDSubpictureAttributes_t;
+
+/* Video attributes */
+typedef struct {
+  DVDBool_t PanscanPermitted;
+  DVDBool_t LetterboxPermitted;
+  int AspectX;
+  int AspectY;
+  int FrameRate;
+  int FrameHeight;
+  DVDVideoCompression_t Compression;
+  DVDBool_t Line21Field1InGop;
+  DVDBool_t Line21Field2InGop;
+  int more_to_come;
+} DVDVideoAttributes_t;
+typedef int DVDVideoCompression_t;
+
+#endif
+
+#endif /* DVD_H_INCLUDED */
diff -r 448a43f59a37 libmpdvdnav/dvdnav.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/dvdnav.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,1156 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvdnav.c,v 1.63 2004/01/31 17:12:58 jcdutton Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+/*
+#define LOG_DEBUG
+*/
+
+#include "dvdnav_internal.h"
+#include "read_cache.h"
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/time.h>
+
+#include "remap.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+static dvdnav_status_t dvdnav_clear(dvdnav_t * this) {
+  /* clear everything except file, vm, mutex, readahead */
+
+  if (this->file) DVDCloseFile(this->file);
+  this->file = NULL;
+
+  memset(&this->pci,0,sizeof(this->pci));
+  memset(&this->dsi,0,sizeof(this->dsi));
+  this->last_cmd_nav_lbn = SRI_END_OF_CELL;
+
+  /* Set initial values of flags */
+  this->position_current.still = 0;
+  this->skip_still = 0;
+  this->sync_wait = 0;
+  this->sync_wait_skip = 0;
+  this->spu_clut_changed = 0;
+  this->started = 0;
+
+  dvdnav_read_cache_clear(this->cache);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_open(dvdnav_t** dest, const char *path) {
+  dvdnav_t *this;
+  struct timeval time;
+
+  /* Create a new structure */
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_Using, DVDNAVSVERSION);
+
+  (*dest) = NULL;
+  this = (dvdnav_t*)malloc(sizeof(dvdnav_t));
+  if(!this)
+    return DVDNAV_STATUS_ERR;
+  memset(this, 0, (sizeof(dvdnav_t) ) ); /* Make sure this structure is clean */
+
+  pthread_mutex_init(&this->vm_lock, NULL);
+  /* Initialise the error string */
+  printerr("");
+
+  /* Initialise the VM */
+  this->vm = vm_new_vm();
+  if(!this->vm) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorInitialisingTheDVDVM);
+    pthread_mutex_destroy(&this->vm_lock);
+    free(this);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!vm_reset(this->vm, path)) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorStartingTheVM);
+    pthread_mutex_destroy(&this->vm_lock);
+    vm_free_vm(this->vm);
+    free(this);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* Set the path. FIXME: Is a deep copy 'right' */
+  strncpy(this->path, path, MAX_PATH_LEN);
+
+  /* Pre-open and close a file so that the CSS-keys are cached. */
+  this->file = DVDOpenFile(vm_get_dvd_reader(this->vm), 0, DVD_READ_MENU_VOBS);
+
+  /* Start the read-ahead cache. */
+  this->cache = dvdnav_read_cache_new(this);
+
+  /* Seed the random numbers. So that the DVD VM Command rand()
+   * gives a different start value each time a DVD is played. */
+  gettimeofday(&time, NULL);
+  srand(time.tv_usec);
+
+  dvdnav_clear(this);
+
+  (*dest) = this;
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_close(dvdnav_t *this) {
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: close:called\n");
+#endif
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  if (this->file) {
+    DVDCloseFile(this->file);
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: close:file closing\n");
+#endif
+    this->file = NULL;
+  }
+
+  /* Free the VM */
+  if(this->vm)
+    vm_free_vm(this->vm);
+
+  pthread_mutex_destroy(&this->vm_lock);
+
+  /* We leave the final freeing of the entire structure to the cache,
+   * because we don't know, if there are still buffers out in the wild,
+   * that must return first. */
+  if(this->cache)
+    dvdnav_read_cache_free(this->cache);
+  else
+    free(this);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_reset(dvdnav_t *this) {
+  dvdnav_status_t result;
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: reset:called\n");
+#endif
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: reseting vm\n");
+#endif
+  if(!vm_reset(this->vm, NULL)) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorRestartingTheVM);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: clearing dvdnav\n");
+#endif
+  result = dvdnav_clear(this);
+
+  pthread_mutex_unlock(&this->vm_lock);
+  return result;
+}
+
+dvdnav_status_t dvdnav_path(dvdnav_t *this, const char** path) {
+
+  if(!this || !path) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*path) = this->path;
+
+  return DVDNAV_STATUS_OK;
+}
+
+const char* dvdnav_err_to_string(dvdnav_t *this) {
+
+  if(!this)
+    return "Hey! You gave me a NULL pointer you naughty person!";
+
+  return this->err_str;
+}
+
+/* converts a dvd_time_t to PTS ticks */
+static int64_t dvdnav_convert_time(dvd_time_t *time) {
+  int64_t result;
+  int64_t frames;
+
+  result  = (time->hour    >> 4  ) * 10 * 60 * 60 * 90000;
+  result += (time->hour    & 0x0f)      * 60 * 60 * 90000;
+  result += (time->minute  >> 4  )      * 10 * 60 * 90000;
+  result += (time->minute  & 0x0f)           * 60 * 90000;
+  result += (time->second  >> 4  )           * 10 * 90000;
+  result += (time->second  & 0x0f)                * 90000;
+
+  frames  = ((time->frame_u & 0x30) >> 4) * 10;
+  frames += ((time->frame_u & 0x0f)     )     ;
+
+  if (time->frame_u & 0x80)
+    result += frames * 3000;
+  else
+    result += frames * 3600;
+
+  return result;
+}
+
+/*
+ * Returns 1 if block contains NAV packet, 0 otherwise.
+ * Processes said NAV packet if present.
+ *
+ * Most of the code in here is copied from xine's MPEG demuxer
+ * so any bugs which are found in that should be corrected here also.
+ */
+static int32_t dvdnav_decode_packet(dvdnav_t *this, uint8_t *p, dsi_t *nav_dsi, pci_t *nav_pci) {
+  int32_t        bMpeg1 = 0;
+  uint32_t       nHeaderLen;
+  uint32_t       nPacketLen;
+  uint32_t       nStreamID;
+
+  if (p[3] == 0xBA) { /* program stream pack header */
+    int32_t nStuffingBytes;
+
+    bMpeg1 = (p[4] & 0x40) == 0;
+
+    if (bMpeg1) {
+      p += 12;
+    } else { /* mpeg2 */
+      nStuffingBytes = p[0xD] & 0x07;
+      p += 14 + nStuffingBytes;
+    }
+  }
+
+  if (p[3] == 0xbb) { /* program stream system header */
+    nHeaderLen = (p[4] << 8) | p[5];
+    p += 6 + nHeaderLen;
+  }
+
+  /* we should now have a PES packet here */
+  if (p[0] || p[1] || (p[2] != 1)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_Demux_error,p[0],p[1],p[2]);
+    return 0;
+  }
+
+  nPacketLen = p[4] << 8 | p[5];
+  nStreamID  = p[3];
+
+  nHeaderLen = 6;
+  p += nHeaderLen;
+
+  if (nStreamID == 0xbf) { /* Private stream 2 */
+#if 0
+    int32_t i;
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: nav packet=%u\n",p-p_start-6);
+    for(i=0;i<80;i++)
+      mp_msg(MSGT_FIXME,MSGL_FIXME, "%02x ",p[i-6]);
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "\n");
+#endif
+
+    if(p[0] == 0x00) {
+      navRead_PCI(nav_pci, p+1);
+    }
+
+    p += nPacketLen;
+
+    /* We should now have a DSI packet. */
+    if(p[6] == 0x01) {
+      nPacketLen = p[4] << 8 | p[5];
+      p += 6;
+      navRead_DSI(nav_dsi, p+1);
+    }
+    return 1;
+  }
+  return 0;
+}
+
+/* DSI is used for most angle stuff.
+ * PCI is used for only non-seemless angle stuff
+ */
+static int32_t dvdnav_get_vobu(dvdnav_t *this, dsi_t *nav_dsi, pci_t *nav_pci, dvdnav_vobu_t *vobu) {
+  uint32_t next;
+  int32_t angle, num_angle;
+
+  vobu->vobu_start = nav_dsi->dsi_gi.nv_pck_lbn; /* Absolute offset from start of disk */
+  vobu->vobu_length = nav_dsi->dsi_gi.vobu_ea; /* Relative offset from vobu_start */
+
+  /*
+   * If we're not at the end of this cell, we can determine the next
+   * VOBU to display using the VOBU_SRI information section of the
+   * DSI.  Using this value correctly follows the current angle,
+   * avoiding the doubled scenes in The Matrix, and makes our life
+   * really happy.
+   *
+   * vobu_next is an offset value, 0x3fffffff = SRI_END_OF_CELL
+   * DVDs are about 6 Gigs, which is only up to 0x300000 blocks
+   * Should really assert if bit 31 != 1
+   */
+
+#if 0
+  /* Old code -- may still be useful one day */
+  if(nav_dsi->vobu_sri.next_vobu != SRI_END_OF_CELL ) {
+    vobu->vobu_next = ( nav_dsi->vobu_sri.next_vobu & 0x3fffffff );
+  } else {
+    vobu->vobu_next = vobu->vobu_length;
+  }
+#else
+  /* Relative offset from vobu_start */
+  vobu->vobu_next = ( nav_dsi->vobu_sri.next_vobu & 0x3fffffff );
+#endif
+
+  vm_get_angle_info(this->vm, &angle, &num_angle);
+
+  /* FIMXE: The angle reset doesn't work for some reason for the moment */
+#if 0
+  if((num_angle < angle) && (angle != 1)) {
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: angle ends!\n");
+
+    /* This is to switch back to angle one when we
+     * finish with angles. */
+    dvdnav_angle_change(this, 1);
+  }
+#endif
+
+  if(num_angle != 0) {
+
+    if((next = nav_pci->nsml_agli.nsml_agl_dsta[angle-1]) != 0) {
+      if((next & 0x3fffffff) != 0) {
+	if(next & 0x80000000)
+	  vobu->vobu_next = - (int32_t)(next & 0x3fffffff);
+	else
+	  vobu->vobu_next = + (int32_t)(next & 0x3fffffff);
+      }
+    } else if((next = nav_dsi->sml_agli.data[angle-1].address) != 0) {
+      vobu->vobu_length = nav_dsi->sml_pbi.ilvu_ea;
+
+      if((next & 0x80000000) && (next != 0x7fffffff))
+	vobu->vobu_next =  - (int32_t)(next & 0x3fffffff);
+      else
+	vobu->vobu_next =  + (int32_t)(next & 0x3fffffff);
+    }
+  }
+
+  return 1;
+}
+
+/*
+ * These are the main get_next_block function which actually get the media stream video and audio etc.
+ *
+ * There are two versions: The second one is using the zero-copy read ahead cache and therefore
+ * hands out pointers targetting directly into the cache.
+ * The first one uses a memcopy to fill this cache block into the application provided memory.
+ * The benefit of this first one is that no special memory management is needed. The application is
+ * the only one responsible of allocating and freeing the memory associated with the pointer.
+ * The drawback is the additional memcopy.
+ */
+
+dvdnav_status_t dvdnav_get_next_block(dvdnav_t *this, uint8_t *buf,
+				      int32_t *event, int32_t *len) {
+  unsigned char *block;
+  dvdnav_status_t status;
+
+  block = buf;
+  status = dvdnav_get_next_cache_block(this, &block, event, len);
+  if (status == DVDNAV_STATUS_OK && block != buf) {
+    /* we received a block from the cache, copy it, so we can give it back */
+    memcpy(buf, block, DVD_VIDEO_LB_LEN);
+    dvdnav_free_cache_block(this, block);
+  }
+  return status;
+}
+
+dvdnav_status_t dvdnav_get_next_cache_block(dvdnav_t *this, uint8_t **buf,
+					    int32_t *event, int32_t *len) {
+  dvd_state_t *state;
+  int32_t result;
+
+  if(!this || !event || !len || !buf || !*buf) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+
+  if(!this->started) {
+    /* Start the VM */
+    vm_start(this->vm);
+    this->started = 1;
+  }
+
+  state = &(this->vm->state);
+  (*event) = DVDNAV_NOP;
+  (*len) = 0;
+
+  /* Check the STOP flag */
+  if(this->vm->stopped) {
+    vm_stop(this->vm);
+    (*event) = DVDNAV_STOP;
+    this->started = 0;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  vm_position_get(this->vm, &this->position_next);
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: POS-NEXT ");
+  vm_position_print(this->vm, &this->position_next);
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: POS-CUR  ");
+  vm_position_print(this->vm, &this->position_current);
+#endif
+
+  /* did we hop? */
+  if(this->position_current.hop_channel != this->position_next.hop_channel) {
+    (*event) = DVDNAV_HOP_CHANNEL;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: HOP_CHANNEL\n");
+#endif
+    if (this->position_next.hop_channel - this->position_current.hop_channel >= HOP_SEEK) {
+      int32_t num_angles = 0, current;
+
+      /* we seeked -> check for multiple angles */
+      vm_get_angle_info(this->vm, &current, &num_angles);
+      if (num_angles > 1) {
+        int32_t result, block;
+	/* we have to skip the first VOBU when seeking in a multiangle feature,
+	 * because it might belong to the wrong angle */
+	block = this->position_next.cell_start + this->position_next.block;
+	result = dvdnav_read_cache_block(this->cache, block, 1, buf);
+	if(result <= 0) {
+	  printerr(MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket);
+	  pthread_mutex_unlock(&this->vm_lock);
+	  return DVDNAV_STATUS_ERR;
+	}
+	/* Decode nav into pci and dsi. Then get next VOBU info. */
+	if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
+	  printerr(MSGTR_LIBMPDVDNAV_Err_ExpectedNAVPacketButNoneFound);
+	  pthread_mutex_unlock(&this->vm_lock);
+	  return DVDNAV_STATUS_ERR;
+	}
+	dvdnav_get_vobu(this, &this->dsi, &this->pci, &this->vobu);
+	/* skip to next, if there is a next */
+	if (this->vobu.vobu_next != SRI_END_OF_CELL) {
+	  this->vobu.vobu_start += this->vobu.vobu_next;
+	  this->vobu.vobu_next   = 0;
+	}
+	/* update VM state */
+	this->vm->state.blockN = this->vobu.vobu_start - this->position_next.cell_start;
+      }
+    }
+    this->position_current.hop_channel = this->position_next.hop_channel;
+    /* update VOBU info */
+    this->vobu.vobu_start  = this->position_next.cell_start + this->position_next.block;
+    this->vobu.vobu_next   = 0;
+    /* Make blockN == vobu_length to do expected_nav */
+    this->vobu.vobu_length = 0;
+    this->vobu.blockN      = 0;
+    this->sync_wait        = 0;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* Check the HIGHLIGHT flag */
+  if(this->position_current.button != this->position_next.button) {
+    dvdnav_highlight_event_t *hevent = (dvdnav_highlight_event_t *)*buf;
+
+    (*event) = DVDNAV_HIGHLIGHT;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: HIGHLIGHT\n");
+#endif
+    (*len) = sizeof(dvdnav_highlight_event_t);
+    hevent->display = 1;
+    hevent->buttonN = this->position_next.button;
+    this->position_current.button = this->position_next.button;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* Check the WAIT flag */
+  if(this->sync_wait) {
+    (*event) = DVDNAV_WAIT;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: WAIT\n");
+#endif
+    (*len) = 0;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* Check to see if we need to change the currently opened VOB */
+  if((this->position_current.vts != this->position_next.vts) ||
+     (this->position_current.domain != this->position_next.domain)) {
+    dvd_read_domain_t domain;
+    int32_t vtsN;
+    dvdnav_vts_change_event_t *vts_event = (dvdnav_vts_change_event_t *)*buf;
+
+    if(this->file) {
+      DVDCloseFile(this->file);
+      this->file = NULL;
+    }
+
+    vts_event->old_vtsN = this->position_current.vts;
+    vts_event->old_domain = this->position_current.domain;
+
+    /* Use the DOMAIN to find whether to open menu or title VOBs */
+    switch(this->position_next.domain) {
+    case FP_DOMAIN:
+    case VMGM_DOMAIN:
+      domain = DVD_READ_MENU_VOBS;
+      vtsN = 0;
+      break;
+    case VTSM_DOMAIN:
+      domain = DVD_READ_MENU_VOBS;
+      vtsN = this->position_next.vts;
+      break;
+    case VTS_DOMAIN:
+      domain = DVD_READ_TITLE_VOBS;
+      vtsN = this->position_next.vts;
+      break;
+    default:
+      printerr(MSGTR_LIBMPDVDNAV_Err_UnknownDomainWhenChangingVTS);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+
+    this->position_current.vts = this->position_next.vts;
+    this->position_current.domain = this->position_next.domain;
+    dvdnav_read_cache_clear(this->cache);
+    this->file = DVDOpenFile(vm_get_dvd_reader(this->vm), vtsN, domain);
+    vts_event->new_vtsN = this->position_next.vts;
+    vts_event->new_domain = this->position_next.domain;
+
+    /* If couldn't open the file for some reason, moan */
+    if(this->file == NULL) {
+      snprintf(this->err_str,MAX_ERR_LEN,MSGTR_LIBMPDVDNAV_ErrorOpeningVtsDomain, vtsN, domain);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+
+    /* File opened successfully so return a VTS change event */
+    (*event) = DVDNAV_VTS_CHANGE;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: VTS_CHANGE\n");
+#endif
+    (*len) = sizeof(dvdnav_vts_change_event_t);
+
+    this->spu_clut_changed = 1;
+    this->position_current.cell = -1; /* Force an update */
+    this->position_current.spu_channel = -1; /* Force an update */
+    this->position_current.audio_channel = -1; /* Force an update */;
+
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* Check if the cell changed */
+  if( (this->position_current.cell != this->position_next.cell) ||
+      (this->position_current.cell_restart != this->position_next.cell_restart) ||
+      (this->position_current.cell_start != this->position_next.cell_start) ) {
+    dvdnav_cell_change_event_t *cell_event = (dvdnav_cell_change_event_t *)*buf;
+    int32_t first_cell_nr, last_cell_nr, i;
+    dvd_state_t *state = &this->vm->state;
+
+    (*event) = DVDNAV_CELL_CHANGE;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: CELL_CHANGE\n");
+#endif
+    (*len) = sizeof(dvdnav_cell_change_event_t);
+
+    cell_event->cellN = state->cellN;
+    cell_event->pgN   = state->pgN;
+    cell_event->cell_length =
+      dvdnav_convert_time(&state->pgc->cell_playback[state->cellN-1].playback_time);
+
+    cell_event->pg_length = 0;
+    /* Find start cell of program. */
+    first_cell_nr = state->pgc->program_map[state->pgN-1];
+    /* Find end cell of program */
+    if(state->pgN < state->pgc->nr_of_programs)
+      last_cell_nr = state->pgc->program_map[state->pgN] - 1;
+    else
+      last_cell_nr = state->pgc->nr_of_cells;
+    for (i = first_cell_nr; i <= last_cell_nr; i++)
+      cell_event->pg_length +=
+        dvdnav_convert_time(&state->pgc->cell_playback[i - 1].playback_time);
+    cell_event->pgc_length = dvdnav_convert_time(&state->pgc->playback_time);
+
+    cell_event->cell_start = 0;
+    for (i = 1; i < state->cellN; i++)
+      cell_event->cell_start +=
+        dvdnav_convert_time(&state->pgc->cell_playback[i - 1].playback_time);
+
+    cell_event->pg_start = 0;
+    for (i = 1; i < state->pgc->program_map[state->pgN-1]; i++)
+      cell_event->pg_start +=
+        dvdnav_convert_time(&state->pgc->cell_playback[i - 1].playback_time);
+
+    this->position_current.cell         = this->position_next.cell;
+    this->position_current.cell_restart = this->position_next.cell_restart;
+    this->position_current.cell_start   = this->position_next.cell_start;
+    this->position_current.block        = this->position_next.block;
+
+    /* vobu info is used for mid cell resumes */
+    this->vobu.vobu_start               = this->position_next.cell_start + this->position_next.block;
+    this->vobu.vobu_next                = 0;
+    /* Make blockN == vobu_length to do expected_nav */
+    this->vobu.vobu_length = 0;
+    this->vobu.blockN      = 0;
+
+    /* update the spu palette at least on PGC changes */
+    this->spu_clut_changed = 1;
+    this->position_current.spu_channel = -1; /* Force an update */
+    this->position_current.audio_channel = -1; /* Force an update */
+
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* has the CLUT changed? */
+  if(this->spu_clut_changed) {
+    (*event) = DVDNAV_SPU_CLUT_CHANGE;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_CLUT_CHANGE\n");
+#endif
+    (*len) = 16 * sizeof(uint32_t);
+    memcpy(*buf, &(state->pgc->palette), 16 * sizeof(uint32_t));
+    this->spu_clut_changed = 0;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* has the SPU channel changed? */
+  if(this->position_current.spu_channel != this->position_next.spu_channel) {
+    dvdnav_spu_stream_change_event_t *stream_change = (dvdnav_spu_stream_change_event_t *)*buf;
+
+    (*event) = DVDNAV_SPU_STREAM_CHANGE;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE\n");
+#endif
+    (*len) = sizeof(dvdnav_spu_stream_change_event_t);
+    stream_change->physical_wide      = vm_get_subp_active_stream(this->vm, 0);
+    stream_change->physical_letterbox = vm_get_subp_active_stream(this->vm, 1);
+    stream_change->physical_pan_scan  = vm_get_subp_active_stream(this->vm, 2);
+    this->position_current.spu_channel = this->position_next.spu_channel;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE stream_id_wide=%d\n",stream_change->physical_wide);
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE stream_id_letterbox=%d\n",stream_change->physical_letterbox);
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE stream_id_pan_scan=%d\n",stream_change->physical_pan_scan);
+#endif
+    if (stream_change->physical_wide != -1 &&
+        stream_change->physical_letterbox != -1 &&
+        stream_change->physical_pan_scan != -1) {
+#ifdef LOG_DEBUG
+      mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE returning DVDNAV_STATUS_OK\n");
+#endif
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_OK;
+    }
+  }
+
+  /* has the audio channel changed? */
+  if(this->position_current.audio_channel != this->position_next.audio_channel) {
+    dvdnav_audio_stream_change_event_t *stream_change = (dvdnav_audio_stream_change_event_t *)*buf;
+
+    (*event) = DVDNAV_AUDIO_STREAM_CHANGE;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: AUDIO_STREAM_CHANGE\n");
+#endif
+    (*len) = sizeof(dvdnav_audio_stream_change_event_t);
+    stream_change->physical = vm_get_audio_active_stream( this->vm );
+    this->position_current.audio_channel = this->position_next.audio_channel;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: AUDIO_STREAM_CHANGE stream_id=%d returning DVDNAV_STATUS_OK\n",stream_change->physical);
+#endif
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* Check the STILLFRAME flag */
+  if(this->position_current.still != 0) {
+    dvdnav_still_event_t *still_event = (dvdnav_still_event_t *)*buf;
+
+    (*event) = DVDNAV_STILL_FRAME;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: STILL_FRAME\n");
+#endif
+    (*len) = sizeof(dvdnav_still_event_t);
+    still_event->length = this->position_current.still;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* Have we reached the end of a VOBU? */
+  if (this->vobu.blockN >= this->vobu.vobu_length) {
+
+    /* Have we reached the end of a cell? */
+    if(this->vobu.vobu_next == SRI_END_OF_CELL) {
+      /* End of Cell from NAV DSI info */
+#ifdef LOG_DEBUG
+      mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Still set to %x\n", this->position_next.still);
+#endif
+      this->position_current.still = this->position_next.still;
+
+      /* we are about to leave a cell, so a lot of state changes could occur;
+       * under certain conditions, the application should get in sync with us before this,
+       * otherwise it might show stills or menus too shortly */
+      if ((this->position_current.still || this->pci.hli.hl_gi.hli_ss) && !this->sync_wait_skip) {
+        this->sync_wait = 1;
+      } else {
+	if( this->position_current.still == 0 || this->skip_still ) {
+	  /* no active cell still -> get us to the next cell */
+	  vm_get_next_cell(this->vm);
+	  this->position_current.still = 0; /* still gets activated at end of cell */
+	  this->skip_still = 0;
+	  this->sync_wait_skip = 0;
+	}
+      }
+      /* handle related state changes in next iteration */
+      (*event) = DVDNAV_NOP;
+      (*len) = 0;
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_OK;
+    }
+
+    /* Perform remapping jump if necessary (this is always a
+     * VOBU boundary). */
+    if (this->vm->map) {
+      this->vobu.vobu_next = remap_block( this->vm->map,
+        this->vm->state.domain, this->vm->state.TTN_REG,
+        this->vm->state.pgN,
+        this->vobu.vobu_start, this->vobu.vobu_next);
+    }
+
+    /* at the start of the next VOBU -> expecting NAV packet */
+    result = dvdnav_read_cache_block(this->cache, this->vobu.vobu_start + this->vobu.vobu_next, 1, buf);
+
+    if(result <= 0) {
+      printerr(MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+    /* Decode nav into pci and dsi. Then get next VOBU info. */
+    if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
+      printerr(MSGTR_LIBMPDVDNAV_Err_ExpectedNAVPacketButNoneFound);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+    /* We need to update the vm state->blockN with which VOBU we are in.
+     * This is so RSM resumes to the VOBU level and not just the CELL level.
+     */
+    this->vm->state.blockN = this->vobu.vobu_start - this->position_current.cell_start;
+
+    dvdnav_get_vobu(this, &this->dsi, &this->pci, &this->vobu);
+    this->vobu.blockN = 0;
+    /* Give the cache a hint about the size of next VOBU.
+     * This improves pre-caching, because the VOBU will almost certainly be read entirely.
+     */
+    dvdnav_pre_cache_blocks(this->cache, this->vobu.vobu_start+1, this->vobu.vobu_length+1);
+
+    /* release NAV menu filter, when we reach the same NAV packet again */
+    if (this->last_cmd_nav_lbn == this->pci.pci_gi.nv_pck_lbn)
+      this->last_cmd_nav_lbn = SRI_END_OF_CELL;
+
+    /* Successfully got a NAV packet */
+    (*event) = DVDNAV_NAV_PACKET;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: NAV_PACKET\n");
+#endif
+    (*len) = 2048;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  }
+
+  /* If we've got here, it must just be a normal block. */
+  if(!this->file) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_AttemptingToReadWithoutOpeningFile);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->vobu.blockN++;
+  result = dvdnav_read_cache_block(this->cache, this->vobu.vobu_start + this->vobu.blockN, 1, buf);
+  if(result <= 0) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorReadingFromDVD);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  (*event) = DVDNAV_BLOCK_OK;
+  (*len) = 2048;
+
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_title_string(dvdnav_t *this, const char **title_str) {
+
+  if(!this || !title_str) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*title_str) = this->vm->dvd_name;
+  return DVDNAV_STATUS_OK;
+}
+
+uint8_t dvdnav_get_video_aspect(dvdnav_t *this) {
+  uint8_t         retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  retval = (uint8_t)vm_get_video_aspect(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+uint8_t dvdnav_get_video_scale_permission(dvdnav_t *this) {
+  uint8_t         retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  retval = (uint8_t)vm_get_video_scale_permission(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+uint16_t dvdnav_audio_stream_to_lang(dvdnav_t *this, uint8_t stream) {
+  audio_attr_t  attr;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  attr = vm_get_audio_attr(this->vm, stream);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  if(attr.lang_type != 1)
+    return 0xffff;
+
+  return attr.lang_code;
+}
+
+uint16_t dvdnav_spu_stream_to_lang(dvdnav_t *this, uint8_t stream) {
+  subp_attr_t  attr;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  attr = vm_get_subp_attr(this->vm, stream);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  if(attr.type != 1)
+    return 0xffff;
+
+  return attr.lang_code;
+}
+
+int8_t dvdnav_get_audio_logical_stream(dvdnav_t *this, uint8_t audio_num) {
+  int8_t       retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return -1;
+  }
+  retval = vm_get_audio_stream(this->vm, audio_num);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_get_audio_attr(dvdnav_t *this, uint8_t audio_num, audio_attr_t *audio_attr) {
+  if(!this || !audio_attr) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return -1;
+  }
+  *audio_attr=vm_get_audio_attr(this->vm, audio_num);
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+#endif
+
+int8_t dvdnav_get_spu_logical_stream(dvdnav_t *this, uint8_t subp_num) {
+  int8_t       retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return -1;
+  }
+  retval = vm_get_subp_stream(this->vm, subp_num, 0);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_get_spu_attr(dvdnav_t *this, uint8_t audio_num, subp_attr_t *subp_attr) {
+  if(!this || !subp_attr) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return -1;
+  }
+  *subp_attr=vm_get_subp_attr(this->vm, audio_num);
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+#endif
+
+int8_t dvdnav_get_active_audio_stream(dvdnav_t *this) {
+  int8_t        retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return -1;
+  }
+  retval = vm_get_audio_active_stream(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+int8_t dvdnav_get_active_spu_stream(dvdnav_t *this) {
+  int8_t        retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return -1;
+  }
+  retval = vm_get_subp_active_stream(this->vm, 0);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+static int8_t dvdnav_is_domain(dvdnav_t *this, domain_t domain) {
+  int8_t        retval;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return -1;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return -1;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  retval = (this->vm->state.domain == domain);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval;
+}
+
+/* First Play domain. (Menu) */
+int8_t dvdnav_is_domain_fp(dvdnav_t *this) {
+  return dvdnav_is_domain(this, FP_DOMAIN);
+}
+/* Video management Menu domain. (Menu) */
+int8_t dvdnav_is_domain_vmgm(dvdnav_t *this) {
+  return dvdnav_is_domain(this, VMGM_DOMAIN);
+}
+/* Video Title Menu domain (Menu) */
+int8_t dvdnav_is_domain_vtsm(dvdnav_t *this) {
+  return dvdnav_is_domain(this, VTSM_DOMAIN);
+}
+/* Video Title domain (playing movie). */
+int8_t dvdnav_is_domain_vts(dvdnav_t *this) {
+  return dvdnav_is_domain(this, VTS_DOMAIN);
+}
+
+/* Generally delegate angle information handling to VM */
+dvdnav_status_t dvdnav_angle_change(dvdnav_t *this, int32_t angle) {
+  int32_t num, current;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  vm_get_angle_info(this->vm, &current, &num);
+  /* Set angle SPRM if valid */
+  if((angle > 0) && (angle <= num)) {
+    this->vm->state.AGL_REG = angle;
+  } else {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedAnInvalidAngleNumber);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_angle_info(dvdnav_t *this, int32_t *current_angle,
+				      int32_t *number_of_angles) {
+  if(!this || !current_angle || !number_of_angles) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  vm_get_angle_info(this->vm, current_angle, number_of_angles);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+pci_t* dvdnav_get_current_nav_pci(dvdnav_t *this) {
+  if(!this) return 0;
+  return &this->pci;
+}
+
+dsi_t* dvdnav_get_current_nav_dsi(dvdnav_t *this) {
+  if(!this) return 0;
+  return &this->dsi;
+}
+
+uint32_t dvdnav_get_next_still_flag(dvdnav_t *this) {
+  if(!this) return -1;
+  return this->position_next.still;
+}
+
diff -r 448a43f59a37 libmpdvdnav/dvdnav.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/dvdnav.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,692 @@
+/*
+ * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvdnav.h,v 1.31 2003/06/09 15:17:44 mroi Exp $
+ *
+ */
+
+/*
+ * This is the main header file applications should include if they want
+ * to access dvdnav functionality.
+ */
+
+#ifndef DVDNAV_H_INCLUDED
+#define DVDNAV_H_INCLUDED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+#include "dvdnav_events.h"
+#include "dvd_types.h"
+
+
+/*********************************************************************
+ * dvdnav data types                                                 *
+ *********************************************************************/
+
+/*
+ * Opaque data-type can be viewed as a 'DVD handle'. You should get
+ * a pointer to a dvdnav_t from the dvdnav_open() function.
+ * Never call free() on the pointer, you have to give it back with
+ * dvdnav_close().
+ */
+typedef struct dvdnav_s dvdnav_t;
+
+/* Status as reported by most of libdvdnav's functions */
+typedef int32_t dvdnav_status_t;
+
+/*
+ * Unless otherwise stated, all functions return DVDNAV_STATUS_OK if
+ * they succeeded, otherwise DVDNAV_STATUS_ERR is returned and the error may
+ * be obtained by calling dvdnav_err_to_string().
+ */
+#define DVDNAV_STATUS_ERR 0
+#define DVDNAV_STATUS_OK  1
+
+
+/*********************************************************************
+ * initialisation & housekeeping functions                           *
+ *********************************************************************/
+
+/*
+ * These functions allow you to open a DVD device and associate it
+ * with a dvdnav_t.
+ */
+
+/*
+ * Attempts to open the DVD drive at the specified path and pre-cache
+ * the CSS-keys. libdvdread is used to access the DVD, so any source
+ * supported by libdvdread can be given with "path". Currently,
+ * libdvdread can access: DVD drives, DVD image files, DVD file-by-file
+ * copies.
+ *
+ * The resulting dvdnav_t handle will be written to *dest.
+ */
+dvdnav_status_t dvdnav_open(dvdnav_t **dest, const char *path);
+
+/*
+ * Closes a dvdnav_t previously opened with dvdnav_open(), freeing any
+ * memory associated with it.
+ */
+dvdnav_status_t dvdnav_close(dvdnav_t *self);
+
+/*
+ * Resets the DVD virtual machine and cache buffers.
+ */
+dvdnav_status_t dvdnav_reset(dvdnav_t *self);
+
+/*
+ * Fills a pointer with a value pointing to a string describing
+ * the path associated with an open dvdnav_t. It assigns *path to NULL
+ * on error.
+ */
+dvdnav_status_t dvdnav_path(dvdnav_t *self, const char **path);
+
+/*
+ * Returns a human-readable string describing the last error.
+ */
+const char* dvdnav_err_to_string(dvdnav_t *self);
+
+
+/*********************************************************************
+ * changing and reading DVD player characteristics                   *
+ *********************************************************************/
+
+/*
+ * These functions allow you to manipulate the various global characteristics
+ * of the DVD playback engine.
+ */
+
+/*
+ * Sets the region mask (bit 0 set implies region 1, bit 1 set implies
+ * region 2, etc) of the virtual machine. Generally you will only need to set
+ * this if you are playing RCE discs which query the virtual machine as to its
+ * region setting.
+ *
+ * This has _nothing_ to do with the region setting of the DVD drive.
+ */
+dvdnav_status_t dvdnav_set_region_mask(dvdnav_t *self, int32_t region_mask);
+
+/*
+ * Returns the region mask (bit 0 set implies region 1, bit 1 set implies
+ * region 2, etc) of the virtual machine.
+ *
+ * This has _nothing_ to do with the region setting of the DVD drive.
+ */
+dvdnav_status_t dvdnav_get_region_mask(dvdnav_t *self, int32_t *region_mask);
+
+/*
+ * Specify whether read-ahead caching should be used. You may not want this if your
+ * decoding engine does its own buffering.
+ *
+ * The default read-ahead cache does not use an additional thread for the reading
+ * (see read_cache.c for a threaded cache, but note that this code is currently
+ * unmaintained). It prebuffers on VOBU level by reading ahead several buffers
+ * on every read request. The speed of this prebuffering has been optimized to
+ * also work on slow DVD drives.
+ *
+ * If in addition you want to prevent memcpy's to improve performance, have a look
+ * at dvdnav_get_next_cache_block().
+ */
+dvdnav_status_t dvdnav_set_readahead_flag(dvdnav_t *self, int32_t read_ahead_flag);
+
+/*
+ * Query whether read-ahead caching/buffering will be used.
+ */
+dvdnav_status_t dvdnav_get_readahead_flag(dvdnav_t *self, int32_t *read_ahead_flag);
+
+/*
+ * Specify whether the positioning works PGC or PG based.
+ * Programs (PGs) on DVDs are similar to Chapters and a program chain (PGC)
+ * usually covers a whole feature. This affects the behaviour of the
+ * functions dvdnav_get_position() and dvdnav_sector_search(). See there.
+ * Default is PG based positioning.
+ */
+dvdnav_status_t dvdnav_set_PGC_positioning_flag(dvdnav_t *self, int32_t pgc_based_flag);
+
+/*
+ * Query whether positioning is PG or PGC based.
+ */
+dvdnav_status_t dvdnav_get_PGC_positioning_flag(dvdnav_t *self, int32_t *pgc_based_flag);
+
+
+/*********************************************************************
+ * reading data                                                      *
+ *********************************************************************/
+
+/*
+ * These functions are used to poll the playback enginge and actually get data
+ * off the DVD.
+ */
+
+/*
+ * Attempts to get the next block off the DVD and copies it into the buffer 'buf'.
+ * If there is any special actions that may need to be performed, the value
+ * pointed to by 'event' gets set accordingly.
+ *
+ * If 'event' is DVDNAV_BLOCK_OK then 'buf' is filled with the next block
+ * (note that means it has to be at /least/ 2048 bytes big). 'len' is
+ * then set to 2048.
+ *
+ * Otherwise, buf is filled with an appropriate event structure and
+ * len is set to the length of that structure.
+ *
+ * See the dvdnav_events.h header for information on the various events.
+ */
+dvdnav_status_t dvdnav_get_next_block(dvdnav_t *self, uint8_t *buf,
+				      int32_t *event, int32_t *len);
+
+/*
+ * This basically does the same as dvdnav_get_next_block. The only difference is
+ * that it avoids a memcopy, when the requested block was found in the cache.
+ * I such a case (cache hit) this function will return a different pointer than
+ * the one handed in, pointing directly into the relevant block in the cache.
+ * Those pointers must _never_ be freed but instead returned to the library via
+ * dvdnav_free_cache_block().
+ */
+dvdnav_status_t dvdnav_get_next_cache_block(dvdnav_t *self, uint8_t **buf,
+					    int32_t *event, int32_t *len);
+
+/*
+ * All buffers which came from the internal cache (when dvdnav_get_next_cache_block()
+ * returned a buffer different from the one handed in) have to be freed with this
+ * function. Although handing in other buffers not from the cache doesn't cause any harm.
+ */
+dvdnav_status_t dvdnav_free_cache_block(dvdnav_t *self, unsigned char *buf);
+
+/*
+ * If we are currently in a still-frame this function skips it.
+ *
+ * See also the DVDNAV_STILL_FRAME event.
+ */
+dvdnav_status_t dvdnav_still_skip(dvdnav_t *self);
+
+#ifdef USE_MPDVDNAV
+/*
+ * If we are currently in a still-frame this function repeat it.
+ *
+ * See also the DVDNAV_STILL_FRAME event.
+ */
+dvdnav_status_t dvdnav_still_back(dvdnav_t *self);
+/*
+ * Clear wait flags and repeat current cell.
+ */
+dvdnav_status_t dvdnav_wait_back(dvdnav_t *self);
+/*
+ * Clear wait & still flags
+ */
+dvdnav_status_t dvdnav_wait_still_clear(dvdnav_t *self);
+/*
+ * Wheather the still event will be in the current cell?
+ */
+dvdnav_status_t dvdnav_is_still_cell(dvdnav_t *self, int *flag);
+#endif
+
+/*
+ * If we are currently in WAIT state, that is: the application is required to
+ * wait for its fifos to become empty, calling this signals libdvdnav that this
+ * is achieved and that it can continue.
+ *
+ * See also the DVDNAV_WAIT event.
+ */
+dvdnav_status_t dvdnav_wait_skip(dvdnav_t *self);
+
+/*
+ * Returns the still time from the currently playing cell.
+ * The still time is given in seconds with 0xff meaning an indefinite still.
+ *
+ * This function can be used to detect still frames before they are reached.
+ * Some players might need this to prepare for a frame to be shown for a
+ * longer time than usual.
+ */
+uint32_t dvdnav_get_next_still_flag(dvdnav_t *self);
+
+/*
+ * Stops playback. The next event obtained with one of the get_next_block
+ * functions will be a DVDNAV_STOP event.
+ *
+ * It is not required to call this before dvdnav_close().
+ */
+dvdnav_status_t dvdnav_stop(dvdnav_t *self);
+
+
+/*********************************************************************
+ * title/part navigation                                             *
+ *********************************************************************/
+
+/*
+ * Returns the number of titles on the disk.
+ */
+dvdnav_status_t dvdnav_get_number_of_titles(dvdnav_t *self, int32_t *titles);
+
+/*
+ * Returns the number of parts within the given title.
+ */
+dvdnav_status_t dvdnav_get_number_of_parts(dvdnav_t *self, int32_t title, int32_t *parts);
+
+/*
+ * Plays the specified title of the DVD from its beginning (that is: part 1).
+ */
+dvdnav_status_t dvdnav_title_play(dvdnav_t *self, int32_t title);
+
+/*
+ * Plays the specified title, starting from the specified part.
+ */
+dvdnav_status_t dvdnav_part_play(dvdnav_t *self, int32_t title, int32_t part);
+
+/*
+ * Play the specified amount of parts of the specified title of
+ * the DVD then STOP.
+ *
+ * Currently unimplemented!
+ */
+dvdnav_status_t dvdnav_part_play_auto_stop(dvdnav_t *self, int32_t title,
+					   int32_t part, int32_t parts_to_play);
+
+/*
+ * Play the specified title starting from the specified time.
+ *
+ * Currently unimplemented!
+ */
+dvdnav_status_t dvdnav_time_play(dvdnav_t *self, int32_t title,
+				 uint64_t time);
+
+/*
+ * Stop playing the current position and jump to the specified menu.
+ *
+ * See also DVDMenuID_t from libdvdread
+ */
+dvdnav_status_t dvdnav_menu_call(dvdnav_t *self, DVDMenuID_t menu);
+
+/*
+ * Return the title number and part currently being played.
+ * A title of 0 indicates, we are in a menu. In this case, part
+ * is set to the current menu's ID.
+ */
+dvdnav_status_t dvdnav_current_title_info(dvdnav_t *self, int32_t *title,
+					  int32_t *part);
+
+/*
+ * Return the current position (in blocks) within the current
+ * title and the length (in blocks) of said title.
+ *
+ * Current implementation is wrong and likely to behave unpredictably!
+ * Use is discouraged!
+ */
+dvdnav_status_t dvdnav_get_position_in_title(dvdnav_t *self,
+					     uint32_t *pos,
+					     uint32_t *len);
+
+/*
+ * This function is only available for compatibility reasons.
+ *
+ * Stop playing the current position and start playback of the current title
+ * from the specified part.
+ */
+dvdnav_status_t dvdnav_part_search(dvdnav_t *self, int32_t part);
+
+
+/*********************************************************************
+ * program chain/program navigation                                  *
+ *********************************************************************/
+
+/*
+ * Stop playing the current position and start playback from the last
+ * VOBU boundary before the given sector. The sector number is not
+ * meant to be an absolute physical DVD sector, but a relative sector
+ * in the current program. This function cannot leave the current
+ * program and will fail, if asked to do so.
+ *
+ * If program chain based positioning is enabled
+ * (see dvdnav_set_PGC_positioning_flag()), this will seek to the relative
+ * sector inside the current program chain.
+ *
+ * 'origin' can be one of SEEK_SET, SEEK_CUR, SEEK_END as defined in
+ * fcntl.h.
+ */
+dvdnav_status_t dvdnav_sector_search(dvdnav_t *self,
+				     uint64_t offset, int32_t origin);
+
+/*
+ * Stop playing the current position and start playback of the title
+ * from the specified timecode.
+ *
+ * Currently unimplemented!
+ */
+dvdnav_status_t dvdnav_time_search(dvdnav_t *self,
+				   uint64_t time);
+
+/*
+ * Stop playing current position and play the "GoUp"-program chain.
+ * (which generally leads to the title menu or a higer-level menu).
+ */
+dvdnav_status_t dvdnav_go_up(dvdnav_t *self);
+
+/*
+ * Stop playing the current position and start playback at the
+ * previous program (if it exists).
+ */
+dvdnav_status_t dvdnav_prev_pg_search(dvdnav_t *self);
+
+/*
+ * Stop playing the current position and start playback at the
+ * first program.
+ */
+dvdnav_status_t dvdnav_top_pg_search(dvdnav_t *self);
+
+/*
+ * Stop playing the current position and start playback at the
+ * next program (if it exists).
+ */
+dvdnav_status_t dvdnav_next_pg_search(dvdnav_t *self);
+
+/*
+ * Return the current position (in blocks) within the current
+ * program and the length (in blocks) of current program.
+ *
+ * If program chain based positioning is enabled
+ * (see dvdnav_set_PGC_positioning_flag()), this will return the
+ * relative position in and the length of the current program chain.
+ */
+dvdnav_status_t dvdnav_get_position(dvdnav_t *self, uint32_t *pos,
+				    uint32_t *len);
+
+#ifdef USE_MPDVDNAV
+/*
+ * Get current PGC number
+ */
+dvdnav_status_t dvdnav_get_pgc(dvdnav_t *self, int *pg_num);
+#endif
+
+/*********************************************************************
+ * menu highlights                                                   *
+ *********************************************************************/
+
+/*
+ * Most functions related to highlights take a NAV PCI packet as a parameter.
+ * While you can get the such a packet from libdvdnav, for players with internal
+ * FIFOs, this will result in errors, because due to the FIFO length, libdvdnav will
+ * be ahead in the stream compared to what the user is seeing on screen.
+ * Therefore, player applications who have a NAV packet available, which is
+ * better in sync with the actual playback should always pass this one to these
+ * functions.
+ */
+
+/*
+ * Get the currently highlighted button
+ * number (1..36) or 0 if no button is highlighted.
+ */
+dvdnav_status_t dvdnav_get_current_highlight(dvdnav_t *self, int32_t *button);
+
+/*
+ * Returns the Presentation Control Information (PCI) structure associated
+ * with the current position.
+ *
+ * Read the general notes above.
+ * See also libdvdreads nav_types.h for definition of pci_t.
+ */
+pci_t* dvdnav_get_current_nav_pci(dvdnav_t *self);
+
+/*
+ * Returns the DSI (data search information) structure associated
+ * with the current position.
+ *
+ * Read the general notes above.
+ * See also libdvdreads nav_types.h for definition of dsi_t.
+ */
+dsi_t* dvdnav_get_current_nav_dsi(dvdnav_t *self);
+
+#ifdef USE_MPDVDNAV
+/*
+ * Enable & disable auto action mode
+ */
+dvdnav_status_t dvdnav_button_select_auto_action(dvdnav_t *self, int mode);
+#endif
+/*
+ * Get the area associated with a certain button.
+ */
+dvdnav_status_t dvdnav_get_highlight_area(pci_t *nav_pci , int32_t button, int32_t mode,
+					  dvdnav_highlight_area_t *highlight);
+
+/*
+ * Move button highlight around as suggested by function name (e.g. with arrow keys).
+ */
+dvdnav_status_t dvdnav_upper_button_select(dvdnav_t *self, pci_t *pci);
+dvdnav_status_t dvdnav_lower_button_select(dvdnav_t *self, pci_t *pci);
+dvdnav_status_t dvdnav_right_button_select(dvdnav_t *self, pci_t *pci);
+dvdnav_status_t dvdnav_left_button_select(dvdnav_t *self, pci_t *pci);
+
+/*
+ * Activate ("press") the currently highlighted button.
+ */
+dvdnav_status_t dvdnav_button_activate(dvdnav_t *self, pci_t *pci);
+
+/*
+ * Highlight a specific button.
+ */
+dvdnav_status_t dvdnav_button_select(dvdnav_t *self, pci_t *pci, int32_t button);
+
+/*
+ * Activate ("press") specified button.
+ */
+dvdnav_status_t dvdnav_button_select_and_activate(dvdnav_t *self, pci_t *pci, int32_t button);
+
+/*
+ * Activate (press) a button and execute specified command.
+ */
+dvdnav_status_t dvdnav_button_activate_cmd(dvdnav_t *self, int32_t button, vm_cmd_t *cmd);
+
+/*
+ * Select button at specified video frame coordinates.
+ */
+dvdnav_status_t dvdnav_mouse_select(dvdnav_t *self, pci_t *pci, int32_t x, int32_t y);
+
+/*
+ * Activate ("press") button at specified video frame coordinates.
+ */
+dvdnav_status_t dvdnav_mouse_activate(dvdnav_t *self, pci_t *pci, int32_t x, int32_t y);
+
+
+/*********************************************************************
+ * languages                                                         *
+ *********************************************************************/
+
+/*
+ * The language codes expected by these functions are two character
+ * codes as defined in ISO639.
+ */
+
+/*
+ * Set which menu language we should use per default.
+ */
+dvdnav_status_t dvdnav_menu_language_select(dvdnav_t *self,
+					   char *code);
+
+/*
+ * Set which audio language we should use per default.
+ */
+dvdnav_status_t dvdnav_audio_language_select(dvdnav_t *self,
+					    char *code);
+
+/*
+ * Set which spu language we should use per default.
+ */
+dvdnav_status_t dvdnav_spu_language_select(dvdnav_t *self,
+					  char *code);
+
+
+/*********************************************************************
+ * obtaining stream attributes                                       *
+ *********************************************************************/
+
+/*
+ * Return a string describing the title of the DVD.
+ * This is an ID string encoded on the disc by the author. In many cases
+ * this is a descriptive string such as `THE_MATRIX' but sometimes is sigularly
+ * uninformative such as `PDVD-011421'. Some DVD authors even forget to set this,
+ * so you may also read the default of the authoring software they used, like
+ * `DVDVolume'.
+ */
+dvdnav_status_t dvdnav_get_title_string(dvdnav_t *self, const char **title_str);
+
+/*
+ * Get video aspect code.
+ * The aspect code does only change on VTS boundaries.
+ * See the DVDNAV_VTS_CHANGE event.
+ *
+ * 0 -- 4:3, 2 -- 16:9
+ */
+uint8_t dvdnav_get_video_aspect(dvdnav_t *self);
+
+/*
+ * Get video scaling permissions.
+ * The scaling permission does only change on VTS boundaries.
+ * See the DVDNAV_VTS_CHANGE event.
+ *
+ * bit0 set = deny letterboxing, bit1 set = deny pan&scan
+ */
+uint8_t dvdnav_get_video_scale_permission(dvdnav_t *self);
+
+/*
+ * Converts a *logical* audio stream id into language code
+ * (returns 0xffff if no such stream).
+ */
+uint16_t dvdnav_audio_stream_to_lang(dvdnav_t *self, uint8_t stream);
+
+/*
+ * Converts a *logical* subpicture stream id into country code
+ * (returns 0xffff if no such stream).
+ */
+uint16_t dvdnav_spu_stream_to_lang(dvdnav_t *self, uint8_t stream);
+
+/*
+ * Converts a *physical* (MPEG) audio stream id into a logical stream number.
+ */
+int8_t dvdnav_get_audio_logical_stream(dvdnav_t *self, uint8_t audio_num);
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_get_audio_attr(dvdnav_t *self, uint8_t audio_mum, audio_attr_t *audio_attr);
+
+int8_t dvdnav_get_active_audio_stream(dvdnav_t *self);
+#endif
+
+/*
+ * Converts a *physical* (MPEG) subpicture stream id into a logical stream number.
+ */
+int8_t dvdnav_get_spu_logical_stream(dvdnav_t *self, uint8_t subp_num);
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_get_spu_attr(dvdnav_t *self, uint8_t audio_mum, subp_attr_t *subp_attr);
+
+int8_t dvdnav_get_active_spu_stream(dvdnav_t *self);
+#endif
+
+/*
+ * Get active audio stream.
+ */
+int8_t dvdnav_get_active_audio_stream(dvdnav_t *self);
+
+/*
+ * Get active spu stream.
+ */
+int8_t dvdnav_get_active_spu_stream(dvdnav_t *self);
+
+
+/*********************************************************************
+ * multiple angles                                                   *
+ *********************************************************************/
+
+/*
+ * The libdvdnav library abstracts away the difference between seamless and
+ * non-seamless angles. From the point of view of the programmer you just set the
+ * angle number and all is well in the world. You will always see only the
+ * selected angle coming from the get_next_block functions.
+ *
+ * Note:
+ * It is quite possible that some tremendously strange DVD feature might change the
+ * angle number from under you. Generally you should always view the results from
+ * dvdnav_get_angle_info() as definitive only up to the next time you call
+ * dvdnav_get_next_block().
+ */
+
+/*
+ * Sets the current angle. If you try to follow a non existant angle
+ * the call fails.
+ */
+dvdnav_status_t dvdnav_angle_change(dvdnav_t *self, int32_t angle);
+
+/*
+ * Returns the current angle and number of angles present.
+ */
+dvdnav_status_t dvdnav_get_angle_info(dvdnav_t *self, int32_t *current_angle,
+				      int32_t *number_of_angles);
+
+/*********************************************************************
+ * domain queries                                                    *
+ *********************************************************************/
+
+/*
+ * Are we in the First Play domain?
+ */
+int8_t dvdnav_is_domain_fp(dvdnav_t *self);
+
+/*
+ * Are we in the Video management Menu domain?
+ */
+int8_t dvdnav_is_domain_vmgm(dvdnav_t *self);
+
+/*
+ * Are we in the Video Title Menu domain?
+ */
+int8_t dvdnav_is_domain_vtsm(dvdnav_t *self);
+
+/*
+ * Are we in the Video Title Set domain?
+ */
+int8_t dvdnav_is_domain_vts(dvdnav_t *self);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* DVDNAV_H_INCLUDED */
diff -r 448a43f59a37 libmpdvdnav/dvdnav_events.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/dvdnav_events.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvdnav_events.h,v 1.12 2003/04/27 01:26:18 jcdutton Exp $
+ *
+ */
+
+/*
+ * This header defines events and event types
+ */
+
+#ifndef DVDNAV_EVENTS_H_INCLUDED
+#define DVDNAV_EVENTS_H_INCLUDED
+
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+
+/*
+ * DVDNAV_BLOCK_OK
+ *
+ * A regular data block from the DVD has been returned.
+ * This one should be demuxed and decoded for playback.
+ */
+#define DVDNAV_BLOCK_OK			 0
+
+
+/*
+ * DVDNAV_NOP
+ *
+ * Just ignore this.
+ */
+#define DVDNAV_NOP			 1
+
+
+/*
+ * DVDNAV_STILL_FRAME
+ *
+ * We have reached a still frame. The player application should wait
+ * the amount of time specified by the still's length while still handling
+ * user input to make menus and other interactive stills work.
+ * The last delivered frame should be kept showing.
+ * Once the still has timed out, call dvdnav_skip_still().
+ * A length of 0xff means an infinite still which has to be skipped
+ * indirectly by some user interaction.
+ */
+#define DVDNAV_STILL_FRAME		 2
+
+typedef struct {
+  /* The length (in seconds) the still frame should be displayed for,
+   * or 0xff if infinite. */
+  int length;
+} dvdnav_still_event_t;
+
+
+/*
+ * DVDNAV_SPU_STREAM_CHANGE
+ *
+ * Inform the SPU decoding/overlaying engine to switch SPU channels.
+ */
+#define DVDNAV_SPU_STREAM_CHANGE	 3
+
+typedef struct {
+  /* The physical (MPEG) stream number for widescreen SPU display.
+   * Use this, if you blend the SPU on an anamorphic image before
+   * unsqueezing it. */
+  int physical_wide;
+
+  /* The physical (MPEG) stream number for letterboxed display.
+   * Use this, if you blend the SPU on an anamorphic image after
+   * unsqueezing it. */
+  int physical_letterbox;
+
+  /* The physical (MPEG) stream number for pan&scan display.
+   * Use this, if you blend the SPU on an anamorphic image after
+   * unsqueezing it the pan&scan way. */
+  int physical_pan_scan;
+
+  /* The logical (DVD) stream number. */
+  int logical;
+} dvdnav_spu_stream_change_event_t;
+
+
+/*
+ * DVDNAV_AUDIO_STREAM_CHANGE
+ *
+ * Inform the audio decoder to switch channels.
+ */
+#define DVDNAV_AUDIO_STREAM_CHANGE	 4
+
+typedef struct {
+  /* The physical (MPEG) stream number. */
+  int physical;
+
+  /* The logical (DVD) stream number. */
+  int logical;
+} dvdnav_audio_stream_change_event_t;
+
+
+/*
+ * DVDNAV_VTS_CHANGE
+ *
+ * Some status information like video aspect and video scale permissions do
+ * not change inside a VTS. Therefore this event can be used to query such
+ * information only when necessary and update the decoding/displaying
+ * accordingly.
+ */
+#define DVDNAV_VTS_CHANGE		 5
+
+typedef struct {
+  int old_vtsN;                 /* the old VTS number */
+  dvd_read_domain_t old_domain; /* the old domain */
+  int new_vtsN;                 /* the new VTS number */
+  dvd_read_domain_t new_domain; /* the new domain */
+} dvdnav_vts_change_event_t;
+
+
+/*
+ * DVDNAV_CELL_CHANGE
+ *
+ * Some status information like the current Title and Part numbers do not
+ * change inside a cell. Therefore this event can be used to query such
+ * information only when necessary and update the decoding/displaying
+ * accordingly.
+ * Some useful information for accurate time display is also reported
+ * together with this event.
+ */
+#define DVDNAV_CELL_CHANGE		 6
+
+typedef struct {
+  int     cellN;       /* the new cell number */
+  int     pgN;         /* the current program number */
+  int64_t cell_length; /* the length of the current cell in PTS ticks */
+  int64_t pg_length;   /* the length of the current program in PTS ticks */
+  int64_t pgc_length;  /* the length of the current program chain in PTS ticks */
+  int64_t cell_start;  /* the start time of the current cell relatively to the PGC in PTS ticks */
+  int64_t pg_start;    /* the start time of the current PG relatively to the PGC in PTS ticks */
+} dvdnav_cell_change_event_t;
+
+
+/*
+ * DVDNAV_NAV_PACKET
+ *
+ * NAV packets are useful for various purposes. They define the button
+ * highlight areas and VM commands of DVD menus, so they should in any
+ * case be sent to the SPU decoder/overlaying engine for the menus to work.
+ * NAV packets also provide a way to detect PTS discontinuities, because
+ * they carry the start and end PTS values for the current VOBU.
+ * (pci.vobu_s_ptm and pci.vobu_e_ptm) Whenever the start PTS of the
+ * current NAV does not match the end PTS of the previous NAV, a PTS
+ * discontinuity has occured.
+ * NAV packets can also be used for time display, because they are
+ * timestamped relatively to the current Cell.
+ */
+#define DVDNAV_NAV_PACKET		 7
+
+
+/*
+ * DVDNAV_STOP
+ *
+ * Applications should end playback here. A subsequent dvdnav_get_next_block()
+ * call will restart the VM from the beginning of the DVD.
+ */
+#define DVDNAV_STOP			 8
+
+
+/*
+ * DVDNAV_HIGHLIGHT
+ *
+ * The current button highlight changed. Inform the overlaying engine to
+ * highlight a different button. Please note, that at the moment only mode 1
+ * highlights are reported this way. That means, when the button highlight
+ * has been moved around by some function call, you will receive an event
+ * telling you the new button. But when a button gets activated, you have
+ * to handle the mode 2 highlighting (that is some different colour the
+ * button turns to on activation) in your application.
+ */
+#define DVDNAV_HIGHLIGHT		 9
+
+typedef struct {
+  /* highlight mode: 0 - hide, 1 - show, 2 - activate, currently always 1 */
+  int display;
+
+  /* FIXME: these fields are currently not set */
+  uint32_t palette;     /* The CLUT entries for the highlight palette
+			   (4-bits per entry -> 4 entries) */
+  uint16_t sx,sy,ex,ey; /* The start/end x,y positions */
+  uint32_t pts;         /* Highlight PTS to match with SPU */
+
+  /* button number for the SPU decoder/overlaying engine */
+  uint32_t buttonN;
+} dvdnav_highlight_event_t;
+
+
+/*
+ * DVDNAV_SPU_CLUT_CHANGE
+ *
+ * Inform the SPU decoder/overlaying engine to update its colour lookup table.
+ * The CLUT is given as 16 uint32_t's in the buffer.
+ */
+#define DVDNAV_SPU_CLUT_CHANGE		10
+
+
+/*
+ * DVDNAV_HOP_CHANNEL
+ *
+ * A non-seamless operation has been performed. Applications can drop all
+ * their internal fifo's content, which will speed up the response.
+ */
+#define DVDNAV_HOP_CHANNEL		12
+
+
+/*
+ * DVDNAV_WAIT
+ *
+ * We have reached a point in DVD playback, where timing is critical.
+ * Player application with internal fifos can introduce state
+ * inconsistencies, because libdvdnav is always the fifo's length
+ * ahead in the stream compared to what the application sees.
+ * Such applications should wait until their fifos are empty
+ * when they receive this type of event.
+ * Once this is achieved, call dvdnav_skip_wait().
+ */
+#define DVDNAV_WAIT			13
+
+
+#endif /* DVDNAV_EVENTS_H_INCLUDED */
diff -r 448a43f59a37 libmpdvdnav/dvdnav_internal.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/dvdnav_internal.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: dvdnav_internal.h,v 1.12 2004/02/13 19:16:17 mroi Exp $
+ *
+ */
+
+#ifndef DVDNAV_INTERNAL_H_INCLUDED
+#define DVDNAV_INTERNAL_H_INCLUDED
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <limits.h>
+#include <string.h>
+
+#ifdef WIN32
+
+/* workaround for objidl.h */
+#undef STREAM_SEEK
+/* pthread_mutex_* wrapper for win32 */
+#include <windows.h>
+#include <process.h>
+typedef CRITICAL_SECTION pthread_mutex_t;
+#define pthread_mutex_init(a, b) InitializeCriticalSection(a)
+#define pthread_mutex_lock(a)    EnterCriticalSection(a)
+#define pthread_mutex_unlock(a)  LeaveCriticalSection(a)
+#define pthread_mutex_destroy(a)
+
+/* replacement gettimeofday implementation */
+#include <sys/timeb.h>
+static inline int gettimeofday( struct timeval *tv, void *tz )
+{
+  struct timeb t;
+  ftime( &t );
+  tv->tv_sec = t.time;
+  tv->tv_usec = t.millitm * 1000;
+  return 0;
+}
+#include <io.h> /* read() */
+#define lseek64 _lseeki64
+#define STREAM_SEEK (STREAM_SEEK_BW|STREAM_SEEK_FW)
+
+#else
+
+#include <pthread.h>
+
+#endif /* WIN32 */
+
+/* Uncomment for VM command tracing */
+/* #define TRACE */
+
+#include "decoder.h"
+#include "dvdnav.h"
+#include "vm.h"
+#include "vmcmd.h"
+
+/* where should libdvdnav write its messages (stdout/stderr) */
+#define MSG_OUT stdout
+
+/* Maximum length of an error string */
+#define MAX_ERR_LEN 255
+
+/* Use the POSIX PATH_MAX if available */
+#ifdef PATH_MAX
+#define MAX_PATH_LEN PATH_MAX
+#else
+#define MAX_PATH_LEN 255 /* Arbitrary */
+#endif
+
+#ifndef DVD_VIDEO_LB_LEN
+#define DVD_VIDEO_LB_LEN 2048
+#endif
+
+typedef struct read_cache_s read_cache_t;
+
+/*
+ * These are defined here because they are
+ * not in ifo_types.h, they maybe one day
+ */
+
+#ifndef audio_status_t
+typedef struct {
+#ifdef WORDS_BIGENDIAN
+  unsigned int available     : 1;
+  unsigned int zero1         : 4;
+  unsigned int stream_number : 3;
+  uint8_t zero2;
+#else
+  uint8_t zero2;
+  unsigned int stream_number : 3;
+  unsigned int zero1         : 4;
+  unsigned int available     : 1;
+#endif
+} ATTRIBUTE_PACKED audio_status_t;
+#endif
+
+#ifndef spu_status_t
+typedef struct {
+#ifdef WORDS_BIGENDIAN
+  unsigned int available               : 1;
+  unsigned int zero1                   : 2;
+  unsigned int stream_number_4_3       : 5;
+  unsigned int zero2                   : 3;
+  unsigned int stream_number_wide      : 5;
+  unsigned int zero3                   : 3;
+  unsigned int stream_number_letterbox : 5;
+  unsigned int zero4                   : 3;
+  unsigned int stream_number_pan_scan  : 5;
+#else
+  unsigned int stream_number_pan_scan  : 5;
+  unsigned int zero4                   : 3;
+  unsigned int stream_number_letterbox : 5;
+  unsigned int zero3                   : 3;
+  unsigned int stream_number_wide      : 5;
+  unsigned int zero2                   : 3;
+  unsigned int stream_number_4_3       : 5;
+  unsigned int zero1                   : 2;
+  unsigned int available               : 1;
+#endif
+} ATTRIBUTE_PACKED spu_status_t;
+#endif
+
+typedef struct dvdnav_vobu_s {
+  int32_t vobu_start;  /* Logical Absolute. MAX needed is 0x300000 */
+  int32_t vobu_length;
+  int32_t blockN;      /* Relative offset */
+  int32_t vobu_next;   /* Relative offset */
+} dvdnav_vobu_t;
+
+/** The main DVDNAV type **/
+
+struct dvdnav_s {
+  /* General data */
+  char        path[MAX_PATH_LEN]; /* Path to DVD device/dir */
+  dvd_file_t *file;               /* Currently opened file */
+
+  /* Position data */
+  vm_position_t position_next;
+  vm_position_t position_current;
+  dvdnav_vobu_t vobu;
+
+  /* NAV data */
+  pci_t pci;
+  dsi_t dsi;
+  uint32_t last_cmd_nav_lbn;      /* detects when a command is issued on an already left NAV */
+
+  /* Flags */
+  int skip_still;                 /* Set when skipping a still */
+  int sync_wait;                  /* applications should wait till they are in sync with us */
+  int sync_wait_skip;             /* Set when skipping wait state */
+  int spu_clut_changed;           /* The SPU CLUT changed */
+  int started;                    /* vm_start has been called? */
+  int use_read_ahead;             /* 1 - use read-ahead cache, 0 - don't */
+  int pgc_based;                  /* positioning works PGC based instead of PG based */
+
+  /* VM */
+  vm_t *vm;
+  pthread_mutex_t vm_lock;
+
+  /* Read-ahead cache */
+  read_cache_t *cache;
+
+  /* Errors */
+  char err_str[MAX_ERR_LEN];
+};
+
+/** USEFUL MACROS **/
+
+#ifdef __GNUC__
+#define printerrf(format, args...) snprintf(this->err_str, MAX_ERR_LEN, format, ## args);
+#else
+#ifdef _MSC_VER
+#define printerrf(str) snprintf(this->err_str, MAX_ERR_LEN, str);
+#else
+#define printerrf(...) snprintf(this->err_str, MAX_ERR_LEN, __VA_ARGS__);
+#endif /* WIN32 */
+#endif
+#define printerr(str) strncpy(this->err_str, str, MAX_ERR_LEN);
+
+#endif /* DVDNAV_INTERNAL_H_INCLUDED */
diff -r 448a43f59a37 libmpdvdnav/highlight.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/highlight.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: highlight.c,v 1.32 2004/01/20 01:22:24 jcdutton Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include <assert.h>
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+#include "dvdnav_internal.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+#ifdef USE_MPDVDNAV_TRACE
+extern int dvdnav_trace;
+#endif
+
+/*
+#define BUTTON_TESTING
+*/
+
+#ifdef BUTTON_TESTING
+
+#include "nav_print.h"
+
+
+
+static void print_time(dvd_time_t *dtime) {
+  const char *rate;
+
+  assert((dtime->hour>>4) < 0xa && (dtime->hour&0xf) < 0xa);
+  assert((dtime->minute>>4) < 0x7 && (dtime->minute&0xf) < 0xa);
+  assert((dtime->second>>4) < 0x7 && (dtime->second&0xf) < 0xa);
+  assert((dtime->frame_u&0xf) < 0xa);
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"%02x:%02x:%02x.%02x",
+         dtime->hour,
+         dtime->minute,
+         dtime->second,
+         dtime->frame_u & 0x3f);
+  switch((dtime->frame_u & 0xc0) >> 6) {
+  case 1:
+    rate = "25.00";
+    break;
+  case 3:
+    rate = "29.97";
+    break;
+  default:
+    rate = "(please send a bug report)";
+    break;
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO," @ %s fps", rate);
+}
+
+static void nav_print_PCI_GI(pci_gi_t *pci_gi) {
+  int32_t i;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: pci_gi:\n");
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nv_pck_lbn    0x%08x\n", pci_gi->nv_pck_lbn);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_cat      0x%04x\n", pci_gi->vobu_cat);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_uop_ctl  0x%08x\n", *(uint32_t*)&pci_gi->vobu_uop_ctl);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_s_ptm    0x%08x\n", pci_gi->vobu_s_ptm);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_e_ptm    0x%08x\n", pci_gi->vobu_e_ptm);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_se_e_ptm 0x%08x\n", pci_gi->vobu_se_e_ptm);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: e_eltm        ");
+  print_time(&pci_gi->e_eltm);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n");
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_isrc     \"");
+  for(i = 0; i < 32; i++) {
+    char c = pci_gi->vobu_isrc[i];
+    if((c >= ' ') && (c <= '~'))
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,"%c", c);
+    else
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,".");
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"\"\n");
+}
+
+static void nav_print_NSML_AGLI(nsml_agli_t *nsml_agli) {
+  int32_t i, j = 0;
+
+  for(i = 0; i < 9; i++)
+    j |= nsml_agli->nsml_agl_dsta[i];
+  if(j == 0)
+    return;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nsml_agli:\n");
+  for(i = 0; i < 9; i++)
+    if(nsml_agli->nsml_agl_dsta[i])
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nsml_agl_c%d_dsta  0x%08x\n", i + 1,
+             nsml_agli->nsml_agl_dsta[i]);
+}
+
+static void nav_print_HL_GI(hl_gi_t *hl_gi, int32_t *btngr_ns, int32_t *btn_ns) {
+
+  if((hl_gi->hli_ss & 0x03) == 0)
+    return;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hl_gi:\n");
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli_ss        0x%01x\n", hl_gi->hli_ss & 0x03);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli_s_ptm     0x%08x\n", hl_gi->hli_s_ptm);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli_e_ptm     0x%08x\n", hl_gi->hli_e_ptm);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_se_e_ptm  0x%08x\n", hl_gi->btn_se_e_ptm);
+
+  *btngr_ns = hl_gi->btngr_ns;
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr_ns      %d\n",  hl_gi->btngr_ns);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 1, hl_gi->btngr1_dsp_ty);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 2, hl_gi->btngr2_dsp_ty);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 3, hl_gi->btngr3_dsp_ty);
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_ofn       %d\n", hl_gi->btn_ofn);
+  *btn_ns = hl_gi->btn_ns;
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_ns        %d\n", hl_gi->btn_ns);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nsl_btn_ns    %d\n", hl_gi->nsl_btn_ns);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: fosl_btnn     %d\n", hl_gi->fosl_btnn);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: foac_btnn     %d\n", hl_gi->foac_btnn);
+}
+
+static void nav_print_BTN_COLIT(btn_colit_t *btn_colit) {
+  int32_t i, j;
+
+  j = 0;
+  for(i = 0; i < 6; i++)
+    j |= btn_colit->btn_coli[i/2][i&1];
+  if(j == 0)
+    return;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_colit:\n");
+  for(i = 0; i < 3; i++)
+    for(j = 0; j < 2; j++)
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_cqoli %d  %s_coli:  %08x\n",
+             i, (j == 0) ? "sl" : "ac",
+             btn_colit->btn_coli[i][j]);
+}
+
+static void nav_print_BTNIT(btni_t *btni_table, int32_t btngr_ns, int32_t btn_ns) {
+  int32_t i, j, k;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btnit:\n");
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr_ns: %i\n", btngr_ns);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_ns: %i\n", btn_ns);
+
+  if(btngr_ns == 0)
+    return;
+
+  for(i = 0; i < btngr_ns; i++) {
+    for(j = 0; j < (36 / btngr_ns); j++) {
+      if(j < btn_ns) {
+        btni_t *btni = &btni_table[(36 / btngr_ns) * i + j];
+
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: group %d btni %d:  ", i+1, j+1);
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"btn_coln %d, auto_action_mode %d\n",
+               btni->btn_coln, btni->auto_action_mode);
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: coords   (%d, %d) .. (%d, %d)\n",
+               btni->x_start, btni->y_start, btni->x_end, btni->y_end);
+
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: up %d, ", btni->up);
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"down %d, ", btni->down);
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"left %d, ", btni->left);
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"right %d\n", btni->right);
+        for(k = 0; k < 8; k++) {
+          mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: %02x ", btni->cmd.bytes[k]);
+        }
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,, "| ");
+#ifdef USE_MPDVDNAV_TRACE
+        if (dvdnav_trace) vm_print_mnemonic(&btni->cmd);
+#endif
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n");
+      }
+    }
+  }
+}
+
+static void nav_print_HLI(hli_t *hli) {
+  int32_t btngr_ns = 0, btn_ns = 0;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli:\n");
+  nav_print_HL_GI(&hli->hl_gi, & btngr_ns, & btn_ns);
+  nav_print_BTN_COLIT(&hli->btn_colit);
+  nav_print_BTNIT(hli->btnit, btngr_ns, btn_ns);
+}
+
+void nav_print_PCI(pci_t *pci) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: pci packet:\n");
+  nav_print_PCI_GI(&pci->pci_gi);
+  nav_print_NSML_AGLI(&pci->nsml_agli);
+  nav_print_HLI(&pci->hli);
+}
+
+#endif
+
+
+/* Highlighting API calls */
+
+dvdnav_status_t dvdnav_get_current_highlight(dvdnav_t *this, int32_t *button) {
+
+  if(!this || !button) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* Simply return the appropriate value based on the SPRM */
+  if(((*button) = this->position_current.button) == -1)
+    (*button) = this->vm->state.HL_BTNN_REG >> 10;
+
+  return DVDNAV_STATUS_OK;
+}
+
+static btni_t *get_current_button(dvdnav_t *this, pci_t *pci) {
+  int32_t button = 0;
+
+  if(!this || !pci) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return NULL;
+  }
+  if(!pci->hli.hl_gi.hli_ss) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+    return NULL;
+  }
+  if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+    return NULL;
+  }
+
+  button = this->vm->state.HL_BTNN_REG >> 10;
+#ifdef BUTTON_TESTING
+  nav_print_PCI(pci);
+#endif
+
+  return &(pci->hli.btnit[button-1]);
+}
+
+static dvdnav_status_t button_auto_action(dvdnav_t *this, pci_t *pci) {
+#ifdef USE_MPDVDNAV
+  if (this->vm->auto_action_mode) return DVDNAV_STATUS_OK;
+#endif
+  if (get_current_button(this, pci)->auto_action_mode)
+    return dvdnav_button_activate(this, pci);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_upper_button_select(dvdnav_t *this, pci_t *pci) {
+  btni_t *button_ptr;
+
+  if(!(button_ptr = get_current_button(this, pci)))
+    return DVDNAV_STATUS_ERR;
+
+  dvdnav_button_select(this, pci, button_ptr->up);
+  return button_auto_action(this, pci);
+}
+
+dvdnav_status_t dvdnav_lower_button_select(dvdnav_t *this, pci_t *pci) {
+  btni_t *button_ptr;
+
+  if(!(button_ptr = get_current_button(this, pci)))
+    return DVDNAV_STATUS_ERR;
+
+  dvdnav_button_select(this, pci, button_ptr->down);
+  return button_auto_action(this, pci);
+}
+
+dvdnav_status_t dvdnav_right_button_select(dvdnav_t *this, pci_t *pci) {
+  btni_t *button_ptr;
+
+  if(!(button_ptr = get_current_button(this, pci)))
+    return DVDNAV_STATUS_ERR;
+
+  dvdnav_button_select(this, pci, button_ptr->right);
+  return button_auto_action(this, pci);
+}
+
+dvdnav_status_t dvdnav_left_button_select(dvdnav_t *this, pci_t *pci) {
+  btni_t *button_ptr;
+
+  if(!(button_ptr = get_current_button(this, pci)))
+    return DVDNAV_STATUS_ERR;
+
+  dvdnav_button_select(this, pci, button_ptr->left);
+  return button_auto_action(this, pci);
+}
+
+dvdnav_status_t dvdnav_get_highlight_area(pci_t *nav_pci , int32_t button, int32_t mode,
+					  dvdnav_highlight_area_t *highlight) {
+  btni_t *button_ptr;
+
+#ifdef BUTTON_TESTING
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Button get_highlight_area %i\n", button);
+#endif
+
+  if(!nav_pci->hli.hl_gi.hli_ss)
+    return DVDNAV_STATUS_ERR;
+  if((button <= 0) || (button > nav_pci->hli.hl_gi.btn_ns))
+    return DVDNAV_STATUS_ERR;
+
+
+  button_ptr = &nav_pci->hli.btnit[button-1];
+
+  highlight->sx = button_ptr->x_start;
+  highlight->sy = button_ptr->y_start;
+  highlight->ex = button_ptr->x_end;
+  highlight->ey = button_ptr->y_end;
+  if(button_ptr->btn_coln != 0) {
+    highlight->palette = nav_pci->hli.btn_colit.btn_coli[button_ptr->btn_coln-1][mode];
+  } else {
+    highlight->palette = 0;
+  }
+  highlight->pts = nav_pci->hli.hl_gi.hli_s_ptm;
+  highlight->buttonN = button;
+#ifdef BUTTON_TESTING
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: highlight: Highlight area is (%u,%u)-(%u,%u), display = %i, button = %u\n",
+               button_ptr->x_start, button_ptr->y_start,
+               button_ptr->x_end, button_ptr->y_end,
+               1,
+               button);
+#endif
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_button_activate(dvdnav_t *this, pci_t *pci) {
+  int32_t button;
+  btni_t *button_ptr = NULL;
+
+  if(!this || !pci) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!pci->hli.hl_gi.hli_ss) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+    return DVDNAV_STATUS_ERR;
+  }
+  pthread_mutex_lock(&this->vm_lock);
+
+  button = this->vm->state.HL_BTNN_REG >> 10;
+
+  if((button <= 0) || (button > pci->hli.hl_gi.btn_ns)) {
+    /* Special code to handle still menus with no buttons.
+     * The navigation is expected to report to the application that a STILL is
+     * underway. In turn, the application is supposed to report to the user
+     * that the playback is paused. The user is then expected to undo the pause,
+     * ie: hit play. At that point, the navigation should release the still and
+     * go to the next Cell.
+     * Explanation by Mathieu Lacage <mathieu_lacage@realmagic.fr>
+     * Code added by jcdutton.
+     */
+    if (this->position_current.still != 0) {
+      /* In still, but no buttons. */
+      vm_get_next_cell(this->vm);
+      this->position_current.still = 0;
+      this->sync_wait = 0;
+      this->last_cmd_nav_lbn = pci->pci_gi.nv_pck_lbn;
+      pthread_mutex_unlock(&this->vm_lock);
+      /* clear error message */
+      printerr("");
+      return DVDNAV_STATUS_OK;
+    }
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  button_ptr = get_current_button(this, pci);
+  /* Finally, make the VM execute the appropriate code and probably
+   * scedule a jump */
+#ifdef BUTTON_TESTING
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Evaluating Button Activation commands.\n");
+#endif
+  if(vm_exec_cmd(this->vm, &(button_ptr->cmd)) == 1) {
+    /* Command caused a jump */
+    this->vm->hop_channel++;
+    this->position_current.still = 0;
+    this->last_cmd_nav_lbn = pci->pci_gi.nv_pck_lbn;
+  }
+
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_button_activate_cmd(dvdnav_t *this, int32_t button, vm_cmd_t *cmd)
+{
+  if(!this || !cmd) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  /* make the VM execute the appropriate code and probably
+   * schedule a jump */
+#ifdef BUTTON_TESTING
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: dvdnav_button_activate_cmd: Evaluating Button Activation commands.\n");
+#endif
+  if(button > 0) {
+    this->vm->state.HL_BTNN_REG = (button << 10);
+    if(vm_exec_cmd(this->vm, cmd) == 1) {
+      /* Command caused a jump */
+      this->vm->hop_channel++;
+    }
+  }
+  /* Always remove still, because some still menus have no buttons. */
+  this->position_current.still = 0;
+  this->sync_wait = 0;
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_button_select(dvdnav_t *this, pci_t *pci, int32_t button) {
+
+  if(!this || !pci) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!pci->hli.hl_gi.hli_ss) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+    return DVDNAV_STATUS_ERR;
+  }
+
+#ifdef BUTTON_TESTING
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Button select %i\n", button);
+#endif
+
+  if((button <= 0) || (button > pci->hli.hl_gi.btn_ns)) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ButtonDoesNotExist);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->vm->state.HL_BTNN_REG = (button << 10);
+  this->position_current.button = -1; /* Force Highligh change */
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_button_select_and_activate(dvdnav_t *this, pci_t *pci,
+						  int32_t button) {
+  /* A trivial function */
+  if(dvdnav_button_select(this, pci, button) != DVDNAV_STATUS_ERR)
+    return dvdnav_button_activate(this, pci);
+  return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_mouse_select(dvdnav_t *this, pci_t *pci, int32_t x, int32_t y) {
+  int32_t button, cur_button;
+  int32_t best,dist,d;
+  int32_t mx,my,dx,dy;
+
+  if(!this || !pci) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!pci->hli.hl_gi.hli_ss) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  cur_button = this->vm->state.HL_BTNN_REG >> 10;
+
+  best = 0;
+  dist = 0x08000000; /* >> than  (720*720)+(567*567); */
+
+  /* Loop through all buttons */
+  for(button = 1; button <= pci->hli.hl_gi.btn_ns; button++) {
+    btni_t *button_ptr = &(pci->hli.btnit[button-1]);
+
+    if((x >= button_ptr->x_start) && (x <= button_ptr->x_end) &&
+       (y >= button_ptr->y_start) && (y <= button_ptr->y_end)) {
+      mx = (button_ptr->x_start + button_ptr->x_end)/2;
+      my = (button_ptr->y_start + button_ptr->y_end)/2;
+      dx = mx - x;
+      dy = my - y;
+      d = (dx*dx) + (dy*dy);
+      /* If the mouse is within the button and the mouse is closer
+       * to the center of this button then it is the best choice. */
+      if(d < dist) {
+        dist = d;
+        best = button;
+      }
+    }
+  }
+  /* As an efficiency measure, only re-select the button
+   * if it is different to the previously selected one. */
+  if (best != 0 && best != cur_button)
+    dvdnav_button_select(this, pci, best);
+
+  /* return DVDNAV_STATUS_OK only if we actually found a matching button */
+  return best ? DVDNAV_STATUS_OK : DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_mouse_activate(dvdnav_t *this, pci_t *pci, int32_t x, int32_t y) {
+  /* A trivial function */
+  if(dvdnav_mouse_select(this, pci, x,y) != DVDNAV_STATUS_ERR)
+    return dvdnav_button_activate(this, pci);
+  return DVDNAV_STATUS_ERR;
+}
diff -r 448a43f59a37 libmpdvdnav/libdvdnav_changes.diff
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/libdvdnav_changes.diff	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,3713 @@
+--- dvdnav.c	2004-01-31 18:12:58.000000000 +0100
++++ dvdnav.c	2006-04-05 16:03:09.000000000 +0200
+@@ -21,9 +21,13 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ /*
+ #define LOG_DEBUG
+@@ -31,7 +35,27 @@
+ 
+ #include "dvdnav_internal.h"
+ #include "read_cache.h"
+-#include "nav_read.h"
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
++#else
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
++#endif
+ 
+ #include <stdlib.h>
+ #include <stdio.h>
+@@ -39,6 +63,11 @@
+ 
+ #include "remap.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
+ static dvdnav_status_t dvdnav_clear(dvdnav_t * this) {
+   /* clear everything except file, vm, mutex, readahead */
+ 
+@@ -67,7 +96,7 @@
+   struct timeval time;
+   
+   /* Create a new structure */
+-  fprintf(MSG_OUT, "libdvdnav: Using dvdnav version %s from http://dvd.sf.net\n", VERSION);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_Using, DVDNAVSVERSION);
+ 
+   (*dest) = NULL;
+   this = (dvdnav_t*)malloc(sizeof(dvdnav_t));
+@@ -82,13 +111,13 @@
+   /* Initialise the VM */
+   this->vm = vm_new_vm();
+   if(!this->vm) {
+-    printerr("Error initialising the DVD VM.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorInitialisingTheDVDVM);
+     pthread_mutex_destroy(&this->vm_lock);
+     free(this);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!vm_reset(this->vm, path)) {
+-    printerr("Error starting the VM / opening the DVD device.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorStartingTheVM);
+     pthread_mutex_destroy(&this->vm_lock);
+     vm_free_vm(this->vm);
+     free(this);
+@@ -118,18 +147,18 @@
+ dvdnav_status_t dvdnav_close(dvdnav_t *this) {
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: close:called\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: close:called\n");
+ #endif
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   if (this->file) {
+     DVDCloseFile(this->file);
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: close:file closing\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: close:file closing\n");
+ #endif
+     this->file = NULL;
+   }
+@@ -155,26 +184,26 @@
+   dvdnav_status_t result;
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: reset:called\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: reset:called\n");
+ #endif
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   pthread_mutex_lock(&this->vm_lock); 
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: reseting vm\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: reseting vm\n");
+ #endif
+   if(!vm_reset(this->vm, NULL)) {
+-    printerr("Error restarting the VM.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorRestartingTheVM);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return DVDNAV_STATUS_ERR;
+   }
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: clearing dvdnav\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: clearing dvdnav\n");
+ #endif
+   result = dvdnav_clear(this);
+ 
+@@ -185,7 +214,7 @@
+ dvdnav_status_t dvdnav_path(dvdnav_t *this, const char** path) {
+ 
+   if(!this || !path) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -258,7 +287,7 @@
+ 
+   /* we should now have a PES packet here */
+   if (p[0] || p[1] || (p[2] != 1)) {
+-    fprintf(MSG_OUT, "libdvdnav: demux error! %02x %02x %02x (should be 0x000001) \n",p[0],p[1],p[2]);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_Demux_error,p[0],p[1],p[2]);
+     return 0;
+   }
+ 
+@@ -271,10 +300,10 @@
+   if (nStreamID == 0xbf) { /* Private stream 2 */
+ #if 0
+     int32_t i;
+-    fprintf(MSG_OUT, "libdvdnav: nav packet=%u\n",p-p_start-6);
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: nav packet=%u\n",p-p_start-6);
+     for(i=0;i<80;i++)
+-      fprintf(MSG_OUT, "%02x ",p[i-6]);
+-    fprintf(MSG_OUT, "\n");
++      mp_msg(MSGT_FIXME,MSGL_FIXME, "%02x ",p[i-6]);
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "\n");
+ #endif
+ 
+     if(p[0] == 0x00) {
+@@ -333,7 +362,7 @@
+   /* FIMXE: The angle reset doesn't work for some reason for the moment */
+ #if 0
+   if((num_angle < angle) && (angle != 1)) {
+-    fprintf(MSG_OUT, "libdvdnav: angle ends!\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: angle ends!\n");
+     
+     /* This is to switch back to angle one when we
+      * finish with angles. */
+@@ -395,7 +424,7 @@
+   int32_t result;
+ 
+   if(!this || !event || !len || !buf || !*buf) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -423,9 +452,9 @@
+   vm_position_get(this->vm, &this->position_next);
+   
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: POS-NEXT ");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: POS-NEXT ");
+   vm_position_print(this->vm, &this->position_next);
+-  fprintf(MSG_OUT, "libdvdnav: POS-CUR  ");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: POS-CUR  ");
+   vm_position_print(this->vm, &this->position_current);
+ #endif
+ 
+@@ -433,7 +462,7 @@
+   if(this->position_current.hop_channel != this->position_next.hop_channel) {
+     (*event) = DVDNAV_HOP_CHANNEL;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: HOP_CHANNEL\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: HOP_CHANNEL\n");
+ #endif
+     if (this->position_next.hop_channel - this->position_current.hop_channel >= HOP_SEEK) {
+       int32_t num_angles = 0, current;
+@@ -447,13 +476,13 @@
+ 	block = this->position_next.cell_start + this->position_next.block;
+ 	result = dvdnav_read_cache_block(this->cache, block, 1, buf);
+ 	if(result <= 0) {
+-	  printerr("Error reading NAV packet.");
++	  printerr(MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket);
+ 	  pthread_mutex_unlock(&this->vm_lock); 
+ 	  return DVDNAV_STATUS_ERR;
+ 	}
+ 	/* Decode nav into pci and dsi. Then get next VOBU info. */
+ 	if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
+-	  printerr("Expected NAV packet but none found.");
++	  printerr(MSGTR_LIBMPDVDNAV_Err_ExpectedNAVPacketButNoneFound);
+ 	  pthread_mutex_unlock(&this->vm_lock); 
+ 	  return DVDNAV_STATUS_ERR;
+ 	}
+@@ -485,7 +514,7 @@
+ 
+     (*event) = DVDNAV_HIGHLIGHT;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: HIGHLIGHT\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: HIGHLIGHT\n");
+ #endif
+     (*len) = sizeof(dvdnav_highlight_event_t);
+     hevent->display = 1;
+@@ -499,7 +528,7 @@
+   if(this->sync_wait) {
+     (*event) = DVDNAV_WAIT;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: WAIT\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: WAIT\n");
+ #endif
+     (*len) = 0;
+     pthread_mutex_unlock(&this->vm_lock);
+@@ -537,7 +566,7 @@
+       vtsN = this->position_next.vts; 
+       break;
+     default:
+-      printerr("Unknown domain when changing VTS.");
++      printerr(MSGTR_LIBMPDVDNAV_Err_UnknownDomainWhenChangingVTS);
+       pthread_mutex_unlock(&this->vm_lock); 
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -551,7 +580,7 @@
+ 
+     /* If couldn't open the file for some reason, moan */
+     if(this->file == NULL) {
+-      printerrf("Error opening vtsN=%i, domain=%i.", vtsN, domain);
++      snprintf(this->err_str,MAX_ERR_LEN,MSGTR_LIBMPDVDNAV_ErrorOpeningVtsDomain, vtsN, domain);
+       pthread_mutex_unlock(&this->vm_lock); 
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -559,7 +588,7 @@
+     /* File opened successfully so return a VTS change event */
+     (*event) = DVDNAV_VTS_CHANGE;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: VTS_CHANGE\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: VTS_CHANGE\n");
+ #endif
+     (*len) = sizeof(dvdnav_vts_change_event_t);
+ 
+@@ -582,7 +611,7 @@
+     
+     (*event) = DVDNAV_CELL_CHANGE;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: CELL_CHANGE\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: CELL_CHANGE\n");
+ #endif
+     (*len) = sizeof(dvdnav_cell_change_event_t);
+     
+@@ -639,7 +668,7 @@
+   if(this->spu_clut_changed) {
+     (*event) = DVDNAV_SPU_CLUT_CHANGE;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: SPU_CLUT_CHANGE\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_CLUT_CHANGE\n");
+ #endif
+     (*len) = 16 * sizeof(uint32_t);
+     memcpy(*buf, &(state->pgc->palette), 16 * sizeof(uint32_t));
+@@ -654,7 +683,7 @@
+ 
+     (*event) = DVDNAV_SPU_STREAM_CHANGE;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE\n");
+ #endif
+     (*len) = sizeof(dvdnav_spu_stream_change_event_t);
+     stream_change->physical_wide      = vm_get_subp_active_stream(this->vm, 0);
+@@ -662,15 +691,15 @@
+     stream_change->physical_pan_scan  = vm_get_subp_active_stream(this->vm, 2);
+     this->position_current.spu_channel = this->position_next.spu_channel;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE stream_id_wide=%d\n",stream_change->physical_wide);
+-    fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE stream_id_letterbox=%d\n",stream_change->physical_letterbox);
+-    fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE stream_id_pan_scan=%d\n",stream_change->physical_pan_scan);
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE stream_id_wide=%d\n",stream_change->physical_wide);
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE stream_id_letterbox=%d\n",stream_change->physical_letterbox);
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE stream_id_pan_scan=%d\n",stream_change->physical_pan_scan);
+ #endif
+     if (stream_change->physical_wide != -1 &&
+         stream_change->physical_letterbox != -1 &&
+         stream_change->physical_pan_scan != -1) {
+ #ifdef LOG_DEBUG
+-      fprintf(MSG_OUT, "libdvdnav: SPU_STREAM_CHANGE returning DVDNAV_STATUS_OK\n");
++      mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: SPU_STREAM_CHANGE returning DVDNAV_STATUS_OK\n");
+ #endif
+       pthread_mutex_unlock(&this->vm_lock); 
+       return DVDNAV_STATUS_OK;
+@@ -683,13 +712,13 @@
+     
+     (*event) = DVDNAV_AUDIO_STREAM_CHANGE;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: AUDIO_STREAM_CHANGE\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: AUDIO_STREAM_CHANGE\n");
+ #endif
+     (*len) = sizeof(dvdnav_audio_stream_change_event_t);
+     stream_change->physical = vm_get_audio_active_stream( this->vm );
+     this->position_current.audio_channel = this->position_next.audio_channel;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: AUDIO_STREAM_CHANGE stream_id=%d returning DVDNAV_STATUS_OK\n",stream_change->physical);
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: AUDIO_STREAM_CHANGE stream_id=%d returning DVDNAV_STATUS_OK\n",stream_change->physical);
+ #endif
+     pthread_mutex_unlock(&this->vm_lock); 
+     return DVDNAV_STATUS_OK;
+@@ -701,7 +730,7 @@
+ 
+     (*event) = DVDNAV_STILL_FRAME;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: STILL_FRAME\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: STILL_FRAME\n");
+ #endif
+     (*len) = sizeof(dvdnav_still_event_t);
+     still_event->length = this->position_current.still;
+@@ -716,7 +745,7 @@
+     if(this->vobu.vobu_next == SRI_END_OF_CELL) {
+       /* End of Cell from NAV DSI info */
+ #ifdef LOG_DEBUG
+-      fprintf(MSG_OUT, "libdvdnav: Still set to %x\n", this->position_next.still);
++      mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Still set to %x\n", this->position_next.still);
+ #endif
+       this->position_current.still = this->position_next.still;
+ 
+@@ -754,13 +783,13 @@
+     result = dvdnav_read_cache_block(this->cache, this->vobu.vobu_start + this->vobu.vobu_next, 1, buf);
+ 
+     if(result <= 0) {
+-      printerr("Error reading NAV packet.");
++      printerr(MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket);
+       pthread_mutex_unlock(&this->vm_lock); 
+       return DVDNAV_STATUS_ERR;
+     }
+     /* Decode nav into pci and dsi. Then get next VOBU info. */
+     if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
+-      printerr("Expected NAV packet but none found.");
++      printerr(MSGTR_LIBMPDVDNAV_Err_ExpectedNAVPacketButNoneFound);
+       pthread_mutex_unlock(&this->vm_lock); 
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -783,7 +812,7 @@
+     /* Successfully got a NAV packet */
+     (*event) = DVDNAV_NAV_PACKET;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: NAV_PACKET\n");
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: NAV_PACKET\n");
+ #endif
+     (*len) = 2048; 
+     pthread_mutex_unlock(&this->vm_lock); 
+@@ -792,7 +821,7 @@
+   
+   /* If we've got here, it must just be a normal block. */
+   if(!this->file) {
+-    printerr("Attempting to read without opening file.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_AttemptingToReadWithoutOpeningFile);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -800,7 +829,7 @@
+   this->vobu.blockN++;
+   result = dvdnav_read_cache_block(this->cache, this->vobu.vobu_start + this->vobu.blockN, 1, buf);
+   if(result <= 0) {
+-    printerr("Error reading from DVD.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_ErrorReadingFromDVD);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -814,7 +843,7 @@
+ dvdnav_status_t dvdnav_get_title_string(dvdnav_t *this, const char **title_str) {
+   
+   if(!this || !title_str) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -826,11 +855,11 @@
+   uint8_t         retval;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+ 
+@@ -845,11 +874,11 @@
+   uint8_t         retval;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+@@ -864,11 +893,11 @@
+   audio_attr_t  attr;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+@@ -886,11 +915,11 @@
+   subp_attr_t  attr;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+@@ -908,17 +937,17 @@
+   int8_t       retval;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+   pthread_mutex_lock(&this->vm_lock);
+   if (!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return -1;
+   }
+@@ -928,21 +957,39 @@
+   return retval;
+ }
+ 
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_get_audio_attr(dvdnav_t *this, uint8_t audio_num, audio_attr_t *audio_attr) {
++  if(!this || !audio_attr) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++  pthread_mutex_lock(&this->vm_lock);
++  if (!this->vm->state.pgc) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
++    pthread_mutex_unlock(&this->vm_lock);
++    return -1;
++  }
++  *audio_attr=vm_get_audio_attr(this->vm, audio_num);
++  pthread_mutex_unlock(&this->vm_lock);
++  return DVDNAV_STATUS_OK;
++}
++#endif
++
+ int8_t dvdnav_get_spu_logical_stream(dvdnav_t *this, uint8_t subp_num) {
+   int8_t       retval;
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+ 
+   pthread_mutex_lock(&this->vm_lock);
+   if (!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return -1;
+   }
+@@ -952,21 +999,39 @@
+   return retval;
+ }
+ 
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_get_spu_attr(dvdnav_t *this, uint8_t audio_num, subp_attr_t *subp_attr) {
++  if(!this || !subp_attr) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++  pthread_mutex_lock(&this->vm_lock);
++  if (!this->vm->state.pgc) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
++    pthread_mutex_unlock(&this->vm_lock);
++    return -1;
++  }
++  *subp_attr=vm_get_subp_attr(this->vm, audio_num);
++  pthread_mutex_unlock(&this->vm_lock);
++  return DVDNAV_STATUS_OK;
++}
++#endif
++
+ int8_t dvdnav_get_active_audio_stream(dvdnav_t *this) {
+   int8_t        retval;
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+   pthread_mutex_lock(&this->vm_lock); 
+   if (!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return -1;
+   }
+@@ -980,17 +1045,17 @@
+   int8_t        retval;
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+   pthread_mutex_lock(&this->vm_lock); 
+   if (!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return -1;
+   }
+@@ -1004,11 +1069,11 @@
+   int8_t        retval;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return -1;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return -1;
+   }
+   
+@@ -1041,7 +1106,7 @@
+   int32_t num, current;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -1051,7 +1116,7 @@
+   if((angle > 0) && (angle <= num)) {
+     this->vm->state.AGL_REG = angle;
+   } else {
+-    printerr("Passed an invalid angle number.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedAnInvalidAngleNumber);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -1063,7 +1128,7 @@
+ dvdnav_status_t dvdnav_get_angle_info(dvdnav_t *this, int32_t *current_angle,
+ 				      int32_t *number_of_angles) {
+   if(!this || !current_angle || !number_of_angles) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+--- dvdnav.h	2003-06-09 17:17:44.000000000 +0200
++++ dvdnav.h	2006-04-05 16:03:09.000000000 +0200
+@@ -33,18 +33,30 @@
+ extern "C" {
+ #endif
+ 
+-#ifdef DVDNAV_COMPILE
+-#  include "dvdnav_events.h"
+-#  include "dvd_types.h"
+-#  include "dvd_reader.h"
+-#  include "ifo_types.h" /* For vm_cmd_t */
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
+ #else
+-#  include <dvdnav/dvdnav_events.h>
+-#  include <dvdnav/dvd_types.h>
+-#  include <dvdnav/dvd_reader.h>
+-#  include <dvdnav/ifo_types.h> /* For vm_cmd_t */
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
+ #endif
+ 
++#include "dvdnav_events.h"
++#include "dvd_types.h"
+ 
+ 
+ /*********************************************************************
+@@ -228,6 +240,27 @@
+  */
+ dvdnav_status_t dvdnav_still_skip(dvdnav_t *self);
+ 
++#ifdef USE_MPDVDNAV
++/*
++ * If we are currently in a still-frame this function repeat it.
++ *
++ * See also the DVDNAV_STILL_FRAME event.
++ */
++dvdnav_status_t dvdnav_still_back(dvdnav_t *self);
++/*
++ * Clear wait flags and repeat current cell.
++ */
++dvdnav_status_t dvdnav_wait_back(dvdnav_t *self);
++/*
++ * Clear wait & still flags
++ */
++dvdnav_status_t dvdnav_wait_still_clear(dvdnav_t *self);
++/*
++ * Wheather the still event will be in the current cell?
++ */
++dvdnav_status_t dvdnav_is_still_cell(dvdnav_t *self, int *flag);
++#endif
++
+ /*
+  * If we are currently in WAIT state, that is: the application is required to
+  * wait for its fifos to become empty, calling this signals libdvdnav that this
+@@ -397,6 +430,12 @@
+ dvdnav_status_t dvdnav_get_position(dvdnav_t *self, uint32_t *pos,
+ 				    uint32_t *len);
+ 
++#ifdef USE_MPDVDNAV
++/*
++ * Get current PGC number
++ */
++dvdnav_status_t dvdnav_get_pgc(dvdnav_t *self, int *pg_num);
++#endif
+ 
+ /*********************************************************************
+  * menu highlights                                                   *
+@@ -436,6 +475,12 @@
+  */
+ dsi_t* dvdnav_get_current_nav_dsi(dvdnav_t *self);
+ 
++#ifdef USE_MPDVDNAV
++/*
++ * Enable & disable auto action mode
++ */
++dvdnav_status_t dvdnav_button_select_auto_action(dvdnav_t *self, int mode);
++#endif
+ /*
+  * Get the area associated with a certain button.
+  */
+@@ -558,11 +603,23 @@
+  */
+ int8_t dvdnav_get_audio_logical_stream(dvdnav_t *self, uint8_t audio_num);
+ 
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_get_audio_attr(dvdnav_t *self, uint8_t audio_mum, audio_attr_t *audio_attr);
++
++int8_t dvdnav_get_active_audio_stream(dvdnav_t *self);
++#endif
++
+ /*
+  * Converts a *physical* (MPEG) subpicture stream id into a logical stream number.
+  */
+ int8_t dvdnav_get_spu_logical_stream(dvdnav_t *self, uint8_t subp_num);
+ 
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_get_spu_attr(dvdnav_t *self, uint8_t audio_mum, subp_attr_t *subp_attr);
++
++int8_t dvdnav_get_active_spu_stream(dvdnav_t *self);
++#endif
++
+ /*
+  * Get active audio stream.
+  */
+--- dvdnav_events.h	2003-04-27 03:26:18.000000000 +0200
++++ dvdnav_events.h	2006-04-05 16:03:09.000000000 +0200
+@@ -28,9 +28,27 @@
+ #ifndef DVDNAV_EVENTS_H_INCLUDED
+ #define DVDNAV_EVENTS_H_INCLUDED
+ 
+-#include "ifo_types.h"
+-#include "dvd_reader.h"
+-#include "nav_types.h"
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
++#else
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
++#endif
+ 
+ 
+ /*
+--- dvdnav_internal.h	2005-12-27 23:57:39.000000000 +0100
++++ dvdnav_internal.h	2006-04-05 16:03:09.000000000 +0200
+@@ -28,8 +28,6 @@
+ #include "config.h"
+ #endif
+ 
+-#define TRACE
+-
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <unistd.h>
+@@ -38,6 +36,8 @@
+ 
+ #ifdef WIN32
+ 
++/* workaround for objidl.h */
++#undef STREAM_SEEK
+ /* pthread_mutex_* wrapper for win32 */
+ #include <windows.h>
+ #include <process.h>
+@@ -59,6 +59,7 @@
+ }
+ #include <io.h> /* read() */
+ #define lseek64 _lseeki64
++#define STREAM_SEEK (STREAM_SEEK_BW|STREAM_SEEK_FW)
+ 
+ #else
+ 
+--- highlight.c	2004-01-20 02:22:24.000000000 +0100
++++ highlight.c	2006-04-05 16:03:10.000000000 +0200
+@@ -21,14 +21,46 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include <assert.h>
+-#include "nav_types.h"
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
++#else
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
++#endif
+ #include "dvdnav_internal.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++#ifdef USE_MPDVDNAV_TRACE
++extern int dvdnav_trace;
++#endif
++
+ /*
+ #define BUTTON_TESTING
+ */
+@@ -45,7 +79,7 @@
+   assert((dtime->second>>4) < 0x7 && (dtime->second&0xf) < 0xa);
+   assert((dtime->frame_u&0xf) < 0xa);
+ 
+-  fprintf(MSG_OUT,"%02x:%02x:%02x.%02x",
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"%02x:%02x:%02x.%02x",
+          dtime->hour,
+          dtime->minute,
+          dtime->second,
+@@ -61,32 +95,32 @@
+     rate = "(please send a bug report)";
+     break;
+   }
+-  fprintf(MSG_OUT," @ %s fps", rate);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO," @ %s fps", rate);
+ }
+ 
+ static void nav_print_PCI_GI(pci_gi_t *pci_gi) {
+   int32_t i;
+ 
+-  fprintf(MSG_OUT,"libdvdnav: pci_gi:\n");
+-  fprintf(MSG_OUT,"libdvdnav: nv_pck_lbn    0x%08x\n", pci_gi->nv_pck_lbn);
+-  fprintf(MSG_OUT,"libdvdnav: vobu_cat      0x%04x\n", pci_gi->vobu_cat);
+-  fprintf(MSG_OUT,"libdvdnav: vobu_uop_ctl  0x%08x\n", *(uint32_t*)&pci_gi->vobu_uop_ctl);
+-  fprintf(MSG_OUT,"libdvdnav: vobu_s_ptm    0x%08x\n", pci_gi->vobu_s_ptm);
+-  fprintf(MSG_OUT,"libdvdnav: vobu_e_ptm    0x%08x\n", pci_gi->vobu_e_ptm);
+-  fprintf(MSG_OUT,"libdvdnav: vobu_se_e_ptm 0x%08x\n", pci_gi->vobu_se_e_ptm);
+-  fprintf(MSG_OUT,"libdvdnav: e_eltm        ");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: pci_gi:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nv_pck_lbn    0x%08x\n", pci_gi->nv_pck_lbn);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_cat      0x%04x\n", pci_gi->vobu_cat);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_uop_ctl  0x%08x\n", *(uint32_t*)&pci_gi->vobu_uop_ctl);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_s_ptm    0x%08x\n", pci_gi->vobu_s_ptm);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_e_ptm    0x%08x\n", pci_gi->vobu_e_ptm);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_se_e_ptm 0x%08x\n", pci_gi->vobu_se_e_ptm);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: e_eltm        ");
+   print_time(&pci_gi->e_eltm);
+-  fprintf(MSG_OUT,"\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n");
+ 
+-  fprintf(MSG_OUT,"libdvdnav: vobu_isrc     \"");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: vobu_isrc     \"");
+   for(i = 0; i < 32; i++) {
+     char c = pci_gi->vobu_isrc[i];
+     if((c >= ' ') && (c <= '~'))
+-      fprintf(MSG_OUT,"%c", c);
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,"%c", c);
+     else
+-      fprintf(MSG_OUT,".");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,".");
+   }
+-  fprintf(MSG_OUT,"\"\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"\"\n");
+ }
+ 
+ static void nav_print_NSML_AGLI(nsml_agli_t *nsml_agli) {
+@@ -97,10 +131,10 @@
+   if(j == 0)
+     return;
+ 
+-  fprintf(MSG_OUT,"libdvdnav: nsml_agli:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nsml_agli:\n");
+   for(i = 0; i < 9; i++)
+     if(nsml_agli->nsml_agl_dsta[i])
+-      fprintf(MSG_OUT,"libdvdnav: nsml_agl_c%d_dsta  0x%08x\n", i + 1,
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nsml_agl_c%d_dsta  0x%08x\n", i + 1,
+              nsml_agli->nsml_agl_dsta[i]);
+ }
+ 
+@@ -109,24 +143,24 @@
+   if((hl_gi->hli_ss & 0x03) == 0)
+     return;
+ 
+-  fprintf(MSG_OUT,"libdvdnav: hl_gi:\n");
+-  fprintf(MSG_OUT,"libdvdnav: hli_ss        0x%01x\n", hl_gi->hli_ss & 0x03);
+-  fprintf(MSG_OUT,"libdvdnav: hli_s_ptm     0x%08x\n", hl_gi->hli_s_ptm);
+-  fprintf(MSG_OUT,"libdvdnav: hli_e_ptm     0x%08x\n", hl_gi->hli_e_ptm);
+-  fprintf(MSG_OUT,"libdvdnav: btn_se_e_ptm  0x%08x\n", hl_gi->btn_se_e_ptm);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hl_gi:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli_ss        0x%01x\n", hl_gi->hli_ss & 0x03);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli_s_ptm     0x%08x\n", hl_gi->hli_s_ptm);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli_e_ptm     0x%08x\n", hl_gi->hli_e_ptm);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_se_e_ptm  0x%08x\n", hl_gi->btn_se_e_ptm);
+ 
+   *btngr_ns = hl_gi->btngr_ns;
+-  fprintf(MSG_OUT,"libdvdnav: btngr_ns      %d\n",  hl_gi->btngr_ns);
+-  fprintf(MSG_OUT,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 1, hl_gi->btngr1_dsp_ty);
+-  fprintf(MSG_OUT,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 2, hl_gi->btngr2_dsp_ty);
+-  fprintf(MSG_OUT,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 3, hl_gi->btngr3_dsp_ty);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr_ns      %d\n",  hl_gi->btngr_ns);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 1, hl_gi->btngr1_dsp_ty);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 2, hl_gi->btngr2_dsp_ty);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr%d_dsp_ty    0x%02x\n", 3, hl_gi->btngr3_dsp_ty);
+ 
+-  fprintf(MSG_OUT,"libdvdnav: btn_ofn       %d\n", hl_gi->btn_ofn);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_ofn       %d\n", hl_gi->btn_ofn);
+   *btn_ns = hl_gi->btn_ns;
+-  fprintf(MSG_OUT,"libdvdnav: btn_ns        %d\n", hl_gi->btn_ns);
+-  fprintf(MSG_OUT,"libdvdnav: nsl_btn_ns    %d\n", hl_gi->nsl_btn_ns);
+-  fprintf(MSG_OUT,"libdvdnav: fosl_btnn     %d\n", hl_gi->fosl_btnn);
+-  fprintf(MSG_OUT,"libdvdnav: foac_btnn     %d\n", hl_gi->foac_btnn);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_ns        %d\n", hl_gi->btn_ns);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: nsl_btn_ns    %d\n", hl_gi->nsl_btn_ns);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: fosl_btnn     %d\n", hl_gi->fosl_btnn);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: foac_btnn     %d\n", hl_gi->foac_btnn);
+ }
+ 
+ static void nav_print_BTN_COLIT(btn_colit_t *btn_colit) {
+@@ -138,10 +172,10 @@
+   if(j == 0)
+     return;
+ 
+-  fprintf(MSG_OUT,"libdvdnav: btn_colit:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_colit:\n");
+   for(i = 0; i < 3; i++)
+     for(j = 0; j < 2; j++)
+-      fprintf(MSG_OUT,"libdvdnav: btn_cqoli %d  %s_coli:  %08x\n",
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_cqoli %d  %s_coli:  %08x\n",
+              i, (j == 0) ? "sl" : "ac",
+              btn_colit->btn_coli[i][j]);
+ }
+@@ -149,9 +183,9 @@
+ static void nav_print_BTNIT(btni_t *btni_table, int32_t btngr_ns, int32_t btn_ns) {
+   int32_t i, j, k;
+ 
+-  fprintf(MSG_OUT,"libdvdnav: btnit:\n");
+-  fprintf(MSG_OUT,"libdvdnav: btngr_ns: %i\n", btngr_ns);
+-  fprintf(MSG_OUT,"libdvdnav: btn_ns: %i\n", btn_ns);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btnit:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btngr_ns: %i\n", btngr_ns);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: btn_ns: %i\n", btn_ns);
+ 
+   if(btngr_ns == 0)
+     return;
+@@ -161,24 +195,24 @@
+       if(j < btn_ns) {
+         btni_t *btni = &btni_table[(36 / btngr_ns) * i + j];
+ 
+-        fprintf(MSG_OUT,"libdvdnav: group %d btni %d:  ", i+1, j+1);
+-        fprintf(MSG_OUT,"btn_coln %d, auto_action_mode %d\n",
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: group %d btni %d:  ", i+1, j+1);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"btn_coln %d, auto_action_mode %d\n",
+                btni->btn_coln, btni->auto_action_mode);
+-        fprintf(MSG_OUT,"libdvdnav: coords   (%d, %d) .. (%d, %d)\n",
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: coords   (%d, %d) .. (%d, %d)\n",
+                btni->x_start, btni->y_start, btni->x_end, btni->y_end);
+ 
+-        fprintf(MSG_OUT,"libdvdnav: up %d, ", btni->up);
+-        fprintf(MSG_OUT,"down %d, ", btni->down);
+-        fprintf(MSG_OUT,"left %d, ", btni->left);
+-        fprintf(MSG_OUT,"right %d\n", btni->right);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: up %d, ", btni->up);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"down %d, ", btni->down);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"left %d, ", btni->left);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"right %d\n", btni->right);
+         for(k = 0; k < 8; k++) {
+-          fprintf(MSG_OUT, "libdvdnav: %02x ", btni->cmd.bytes[k]);
++          mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: %02x ", btni->cmd.bytes[k]);
+         }
+-        fprintf(MSG_OUT, "| ");
+-#ifdef TRACE
+-        vm_print_mnemonic(&btni->cmd);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,, "| ");
++#ifdef USE_MPDVDNAV_TRACE
++        if (dvdnav_trace) vm_print_mnemonic(&btni->cmd);
+ #endif
+-        fprintf(MSG_OUT, "\n");
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,"\n");
+       }
+     }
+   }
+@@ -187,14 +221,14 @@
+ static void nav_print_HLI(hli_t *hli) {
+   int32_t btngr_ns = 0, btn_ns = 0;
+ 
+-  fprintf(MSG_OUT,"libdvdnav: hli:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: hli:\n");
+   nav_print_HL_GI(&hli->hl_gi, & btngr_ns, & btn_ns);
+   nav_print_BTN_COLIT(&hli->btn_colit);
+   nav_print_BTNIT(hli->btnit, btngr_ns, btn_ns);
+ }
+ 
+ void nav_print_PCI(pci_t *pci) {
+-  fprintf(MSG_OUT,"libdvdnav: pci packet:\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: pci packet:\n");
+   nav_print_PCI_GI(&pci->pci_gi);
+   nav_print_NSML_AGLI(&pci->nsml_agli);
+   nav_print_HLI(&pci->hli);
+@@ -208,7 +242,7 @@
+ dvdnav_status_t dvdnav_get_current_highlight(dvdnav_t *this, int32_t *button) {
+   
+   if(!this || !button) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -223,15 +257,15 @@
+   int32_t button = 0;
+ 
+   if(!this || !pci) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return NULL;
+   }
+   if(!pci->hli.hl_gi.hli_ss) {
+-    printerr("Not in a menu.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+     return NULL;
+   }
+   if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+-    printerr("This NAV has already been left.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+     return NULL;
+   }
+ 
+@@ -244,6 +278,9 @@
+ }
+ 
+ static dvdnav_status_t button_auto_action(dvdnav_t *this, pci_t *pci) {
++#ifdef USE_MPDVDNAV
++  if (this->vm->auto_action_mode) return DVDNAV_STATUS_OK;
++#endif
+   if (get_current_button(this, pci)->auto_action_mode)
+     return dvdnav_button_activate(this, pci);
+   return DVDNAV_STATUS_OK;
+@@ -294,7 +331,7 @@
+   btni_t *button_ptr;
+ 
+ #ifdef BUTTON_TESTING
+-  fprintf(MSG_OUT, "libdvdnav: Button get_highlight_area %i\n", button);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Button get_highlight_area %i\n", button);
+ #endif
+   
+   if(!nav_pci->hli.hl_gi.hli_ss)
+@@ -317,7 +354,7 @@
+   highlight->pts = nav_pci->hli.hl_gi.hli_s_ptm;
+   highlight->buttonN = button;
+ #ifdef BUTTON_TESTING
+-  fprintf(MSG_OUT, "libdvdnav: highlight: Highlight area is (%u,%u)-(%u,%u), display = %i, button = %u\n",
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: highlight: Highlight area is (%u,%u)-(%u,%u), display = %i, button = %u\n",
+                button_ptr->x_start, button_ptr->y_start,
+                button_ptr->x_end, button_ptr->y_end,
+                1,
+@@ -332,15 +369,15 @@
+   btni_t *button_ptr = NULL;
+ 
+   if(!this || !pci) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!pci->hli.hl_gi.hli_ss) {
+-    printerr("Not in a menu.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+-    printerr("This NAV has already been left.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+     return DVDNAV_STATUS_ERR;
+   }
+   pthread_mutex_lock(&this->vm_lock); 
+@@ -376,7 +413,7 @@
+   /* Finally, make the VM execute the appropriate code and probably
+    * scedule a jump */
+ #ifdef BUTTON_TESTING
+-  fprintf(MSG_OUT, "libdvdnav: Evaluating Button Activation commands.\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Evaluating Button Activation commands.\n");
+ #endif
+   if(vm_exec_cmd(this->vm, &(button_ptr->cmd)) == 1) {
+     /* Command caused a jump */
+@@ -392,7 +429,7 @@
+ dvdnav_status_t dvdnav_button_activate_cmd(dvdnav_t *this, int32_t button, vm_cmd_t *cmd)
+ {
+   if(!this || !cmd) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+@@ -400,7 +437,7 @@
+   /* make the VM execute the appropriate code and probably
+    * schedule a jump */
+ #ifdef BUTTON_TESTING
+-  fprintf(MSG_OUT, "libdvdnav: dvdnav_button_activate_cmd: Evaluating Button Activation commands.\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: dvdnav_button_activate_cmd: Evaluating Button Activation commands.\n");
+ #endif
+   if(button > 0) {
+     this->vm->state.HL_BTNN_REG = (button << 10);
+@@ -419,24 +456,24 @@
+ dvdnav_status_t dvdnav_button_select(dvdnav_t *this, pci_t *pci, int32_t button) {
+   
+   if(!this || !pci) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!pci->hli.hl_gi.hli_ss) {
+-    printerr("Not in a menu.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+-    printerr("This NAV has already been left.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+     return DVDNAV_STATUS_ERR;
+   }
+  
+ #ifdef BUTTON_TESTING
+-  fprintf(MSG_OUT, "libdvdnav: Button select %i\n", button); 
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Button select %i\n", button);
+ #endif
+   
+   if((button <= 0) || (button > pci->hli.hl_gi.btn_ns)) {
+-    printerr("Button does not exist.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ButtonDoesNotExist);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+@@ -460,15 +497,15 @@
+   int32_t mx,my,dx,dy;
+ 
+   if(!this || !pci) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!pci->hli.hl_gi.hli_ss) {
+-    printerr("Not in a menu.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInAMenu);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(this->last_cmd_nav_lbn == pci->pci_gi.nv_pck_lbn) {
+-    printerr("This NAV has already been left.");
++    mp_msg( MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+--- navigation.c	2004-01-07 20:34:28.000000000 +0100
++++ navigation.c	2006-04-05 16:03:10.000000000 +0200
+@@ -21,17 +21,26 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include "dvdnav_internal.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
+ /* Navigation API calls */
+ 
+ dvdnav_status_t dvdnav_still_skip(dvdnav_t *this) {
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -43,9 +52,73 @@
+   return DVDNAV_STATUS_OK;
+ }
+ 
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_still_back(dvdnav_t *this) {
++  if(!this) {
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++
++  this->position_current.still = 0;
++  this->skip_still = 0;
++  this->sync_wait = 0;
++  this->sync_wait_skip = 1;
++
++  pthread_mutex_lock(&this->vm_lock);
++  vm_play_cell(this->vm);
++//  vm_play_pgc(this->vm);
++  pthread_mutex_unlock(&this->vm_lock);
++
++  return DVDNAV_STATUS_OK;
++}
++
++dvdnav_status_t dvdnav_wait_back(dvdnav_t *this) {
++  if(!this) {
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++
++  this->position_current.still = 0;
++  this->skip_still = 0;
++  this->sync_wait = 0;
++  this->sync_wait_skip = 0;
++
++  pthread_mutex_lock(&this->vm_lock);
++  vm_play_cell(this->vm);
++//  vm_play_pgc(this->vm);
++  pthread_mutex_unlock(&this->vm_lock);
++
++  return DVDNAV_STATUS_OK;
++}
++
++dvdnav_status_t dvdnav_wait_still_clear(dvdnav_t *this) {
++  if(!this) {
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++
++  this->position_current.still = 0;
++  this->skip_still = 0;
++  this->sync_wait = 0;
++  this->sync_wait_skip = 0;
++
++  return DVDNAV_STATUS_OK;
++}
++
++dvdnav_status_t dvdnav_is_still_cell(dvdnav_t *this, int *flag)
++{
++  if(!this || !flag) {
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++  *flag=this->position_current.still;
++  return DVDNAV_STATUS_OK;
++}
++#endif
++
+ dvdnav_status_t dvdnav_wait_skip(dvdnav_t *this) {
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -57,11 +130,11 @@
+ 
+ dvdnav_status_t dvdnav_get_number_of_titles(dvdnav_t *this, int32_t *titles) {
+   if(!this || !titles) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_VirtualDVDMachineNotStarted);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -72,15 +145,15 @@
+ 
+ dvdnav_status_t dvdnav_get_number_of_parts(dvdnav_t *this, int32_t title, int32_t *parts) {
+   if(!this || !parts) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_VirtualDVDMachineNotStarted);
+     return DVDNAV_STATUS_ERR;
+   }
+   if ((title < 1) || (title > vm_get_vmgi(this->vm)->tt_srpt->nr_of_srpts) ) {
+-    printerr("Passed a title number out of range.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedATitleNumberOutOfRange);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -93,18 +166,18 @@
+   int32_t retval;
+   
+   if(!this || !title || !part) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+   pthread_mutex_lock(&this->vm_lock);
+   if (!this->vm->vtsi || !this->vm->vmgi) {
+-    printerr("Bad VM state.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_BadVMState);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+   if (!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -123,14 +196,14 @@
+     pthread_mutex_unlock(&this->vm_lock);
+     return retval ? DVDNAV_STATUS_OK : DVDNAV_STATUS_ERR;
+   }
+-  printerr("Not in a title or menu.");
++  mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInATitleOrMenu);
+   pthread_mutex_unlock(&this->vm_lock);
+   return DVDNAV_STATUS_ERR;
+ }
+ 
+ dvdnav_status_t dvdnav_title_play(dvdnav_t *this, int32_t title) {
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   return dvdnav_part_play(this, title, 1);
+@@ -140,28 +213,28 @@
+   int32_t retval;
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+   pthread_mutex_lock(&this->vm_lock);
+   if (!this->vm->vmgi) {
+-    printerr("Bad VM state.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_BadVMState);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+   if (!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+   if((title < 1) || (title > this->vm->vmgi->tt_srpt->nr_of_srpts)) {
+-    printerr("Title out of range.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_TitleOutOfRange);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+   if((part < 1) || (part > this->vm->vmgi->tt_srpt->title[title-1].nr_of_ptts)) {
+-    printerr("Part out of range.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PartOutOfRange);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -178,25 +251,25 @@
+ 					   int32_t part, int32_t parts_to_play) {
+   /* FIXME: Implement auto-stop */
+  if (dvdnav_part_play(this, title, part) == DVDNAV_STATUS_OK)
+-   printerr("Not implemented yet.");
++   mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotImplementedYet);
+  return DVDNAV_STATUS_ERR;
+ }
+ 
+ dvdnav_status_t dvdnav_time_play(dvdnav_t *this, int32_t title,
+ 				 uint64_t time) {
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+   /* FIXME: Implement */
+-  printerr("Not implemented yet.");
++   mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotImplementedYet);
+   return DVDNAV_STATUS_ERR;
+ }
+ 
+ dvdnav_status_t dvdnav_stop(dvdnav_t *this) {
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+@@ -208,7 +281,7 @@
+ 
+ dvdnav_status_t dvdnav_go_up(dvdnav_t *this) {
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+--- read_cache.c	2004-03-03 17:48:36.000000000 +0100
++++ read_cache.c	2006-04-05 16:03:10.000000000 +0200
+@@ -27,9 +27,13 @@
+  * search the CVS attic.
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include "dvdnav.h"
+ #include "dvdnav_internal.h"
+@@ -45,6 +49,11 @@
+ #define READ_AHEAD_SIZE_MIN 4
+ #define READ_AHEAD_SIZE_MAX 512
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
+ typedef struct read_cache_chunk_s {
+   uint8_t     *cache_buffer;
+   uint8_t     *cache_buffer_base;  /* used in malloc and free for alignment */
+@@ -73,25 +82,6 @@
+ #define READ_CACHE_TRACE 0
+ */
+ 
+-#ifdef __GNUC__
+-# if READ_CACHE_TRACE
+-#  define dprintf(fmt, args...) fprintf(MSG_OUT, "libdvdnav: %s: "fmt,  __func__ , ## args)
+-# else
+-#  define dprintf(fmt, args...) /* Nowt */
+-# endif
+-#else
+-# if READ_CACHE_TRACE
+-#  define dprintf(fmt, ...) fprintf(MSG_OUT, "libdvdnav: %s: "fmt,  __func__ , __VA_ARGS__)
+-# else
+-#ifdef _MSC_VER
+-#  define dprintf(fmt, str) /* Nowt */
+-#else
+-#  define dprintf(fmt, ...) /* Nowt */
+-#endif /* _MSC_VER */
+-# endif
+-#endif
+-
+-
+ read_cache_t *dvdnav_read_cache_new(dvdnav_t* dvd_self) {
+   read_cache_t *self;
+   int i;
+@@ -183,7 +173,7 @@
+         block_count * DVD_VIDEO_LB_LEN + ALIGNMENT);
+       self->chunk[use].cache_buffer =
+         (uint8_t *)(((uintptr_t)self->chunk[use].cache_buffer_base & ~((uintptr_t)(ALIGNMENT - 1))) + ALIGNMENT);
+-      dprintf("pre_cache DVD read realloc happened\n");
++      mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_PreCacheDVDReadReallocHappened);
+       self->chunk[use].cache_malloc_size = block_count;
+     } else {
+       /* we still haven't found a cache chunk, let's allocate a new one */
+@@ -202,7 +192,7 @@
+ 	self->chunk[i].cache_buffer =
+ 	  (uint8_t *)(((uintptr_t)self->chunk[i].cache_buffer_base & ~((uintptr_t)(ALIGNMENT - 1))) + ALIGNMENT);
+ 	self->chunk[i].cache_malloc_size = block_count > 500 ? block_count : 500;
+-	dprintf("pre_cache DVD read malloc %d blocks\n",
++      mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_PreCacheDVDReadMalloc,
+ 	  (block_count > 500 ? block_count : 500 ));
+       }
+     }
+@@ -215,7 +205,7 @@
+     self->chunk[use].cache_valid = 1;
+     self->current = use;
+   } else {
+-    dprintf("pre_caching was impossible, no cache chunk available\n");
++    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_PreCachingWasImpossible);
+   }
+   pthread_mutex_unlock(&self->lock);
+ }
+@@ -274,7 +264,7 @@
+     chunk->usage_count++;
+     pthread_mutex_unlock(&self->lock);
+ 
+-    dprintf("libdvdnav: sector=%d, start_sector=%d, last_sector=%d\n", sector, chunk->cache_start_sector, chunk->cache_start_sector + chunk->cache_block_count);
++    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_ReadCacheSectorInfo, sector, chunk->cache_start_sector, chunk->cache_start_sector + chunk->cache_block_count);
+ 
+     /* read_ahead_size */
+     incr = self->read_ahead_incr >> 1;
+@@ -294,7 +284,7 @@
+       if (sector >= chunk->cache_start_sector + chunk->cache_read_count + size)
+         size = sector - chunk->cache_start_sector - chunk->cache_read_count;
+     }
+-    dprintf("libdvdnav: read_ahead_size=%d, size=%d\n", self->read_ahead_size, size);
++    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_ReadCacheReadAheadSize, self->read_ahead_size, size);
+ 
+     if (size)
+       chunk->cache_read_count += DVDReadBlocks(self->dvd_self->file,
+@@ -307,7 +297,7 @@
+   } else {
+ 
+     if (self->dvd_self->use_read_ahead)
+-      dprintf("cache miss on sector %d\n", sector);
++    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_CacheMissOnSector, sector);
+ 
+     res = DVDReadBlocks(self->dvd_self->file,
+                         sector,
+--- remap.c	2003-08-27 15:54:19.000000000 +0200
++++ remap.c	2006-04-05 16:40:59.000000000 +0200
+@@ -31,10 +31,19 @@
+ #endif
+ #endif /* _MSC_VER */
+ 
++#ifdef HAVE_MPLAYER
++#include "config.h"
++#endif
++
+ #include <assert.h>
+ #include "remap.h"
+ #include "dvdnav_internal.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
+ struct block_s {
+     int domain;
+     int title;
+@@ -189,16 +198,18 @@
+     remap_t *map;
+ 
+     /* Build the map filename */
+-    home = getenv("HOME"); assert(home);
+-    strncpy(fname, home, sizeof(fname));
+-    strncat(fname, "/.dvdnav/", sizeof(fname));
+-    strncat(fname, title, sizeof(fname));
+-    strncat(fname, ".map", sizeof(fname));
+-
++    home = getenv("HOME");
++#ifdef WIN32
++    if(!home) home = getenv("USERPROFILE");
++    if(!home) home = getenv("HOMEPATH");
++    if(!home) home = (char*)get_path("");
++#endif
++    assert(home);
++    snprintf(fname, sizeof(fname), "%s/.dvdnav/%s.map", home, title);
+     /* Open the map file */
+     fp = fopen( fname, "r");
+     if (!fp) {
+-	fprintf(MSG_OUT, "libdvdnav: Unable to find map file '%s'\n", fname);
++        mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_UnableToFindMapFile, fname);
+ 	return NULL;
+     }
+ 
+@@ -212,7 +223,7 @@
+ 	    res = parseblock( buf, 
+ 		&tmp.domain, &tmp.title, &tmp.program, &tmp.start_block, &tmp.end_block);
+ 	    if (res != 5) {
+-		fprintf(MSG_OUT, "libdvdnav: Ignoring map line (%d): %s\n", res, buf);
++		mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_IgnoringMapLine, res, buf);
+ 		continue;
+ 	    }
+ 	    remap_add_node( map, tmp);
+@@ -231,7 +242,7 @@
+     block_t *b;
+ 
+     if (map->debug) {
+-	fprintf(MSG_OUT, "libdvdnav: %s: domain %d, title %d, program %d, start %lx, next %lx\n",
++	mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_RemapInfo,
+ 	    map->title, domain, title, program, cblock, cblock+offset);
+     }
+ 
+@@ -243,7 +254,7 @@
+     
+     if (b) {
+        if (map->debug) {
+-	   fprintf(MSG_OUT, "libdvdnav: Redirected to %lx\n", b->end_block);
++	   mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_RedirectedTo, b->end_block);
+        }
+        return b->end_block - cblock;
+     }
+--- searching.c	2004-01-07 20:35:12.000000000 +0100
++++ searching.c	2006-04-05 16:03:10.000000000 +0200
+@@ -21,9 +21,13 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include <assert.h>
+ #include "dvdnav_internal.h"
+@@ -32,6 +36,11 @@
+ #define LOG_DEBUG
+ */
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
+ /* Searching API calls */
+ 
+ dvdnav_status_t dvdnav_time_search(dvdnav_t *this,
+@@ -48,7 +57,7 @@
+   vobu_admap_t *admap = NULL;
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: Seeking to target %u ...\n", seekto_block);
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Seeking to target %u ...\n", seekto_block);
+ #endif
+   *vobu = -1;
+ 
+@@ -66,7 +75,7 @@
+     admap = this->vm->vtsi->vts_vobu_admap;
+     break;
+   default:
+-    fprintf(MSG_OUT, "libdvdnav: Error: Unknown domain for seeking.\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_UnknownDomainForSeeking);
+   }
+   if(admap) {
+     uint32_t address = 0;
+@@ -79,7 +88,7 @@
+     while((!found) && ((address<<2) < admap->last_byte)) {
+       next_vobu = admap->vobu_start_sectors[address];
+ 
+-      /* fprintf(MSG_OUT, "libdvdnav: Found block %u\n", next_vobu); */
++      /* mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Found block %u\n", next_vobu); */
+ 
+       if(vobu_start <= seekto_block &&
+           next_vobu > seekto_block) {
+@@ -93,11 +102,11 @@
+       *vobu = vobu_start;
+       return DVDNAV_STATUS_OK;
+     } else {
+-      fprintf(MSG_OUT, "libdvdnav: Could not locate block\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_CouldNotLocateBlock);
+       return DVDNAV_STATUS_ERR;
+     }
+   }
+-  fprintf(MSG_OUT, "libdvdnav: admap not located\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_AdmapNotLocated);
+   return DVDNAV_STATUS_ERR;
+ }
+ 
+@@ -112,7 +121,7 @@
+   dvdnav_status_t result;
+ 
+   if(this->position_current.still != 0) {
+-    printerr("Cannot seek in a still frame.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_CannotSeekInAStillFrame);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+@@ -124,19 +133,19 @@
+   pthread_mutex_lock(&this->vm_lock);
+   state = &(this->vm->state);
+   if(!state->pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: seeking to offset=%lu pos=%u length=%u\n", offset, target, length); 
+-  fprintf(MSG_OUT, "libdvdnav: Before cellN=%u blockN=%u\n", state->cellN, state->blockN);
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: seeking to offset=%lu pos=%u length=%u\n", offset, target, length);
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Before cellN=%u blockN=%u\n", state->cellN, state->blockN);
+ #endif
+ 
+   switch(origin) {
+    case SEEK_SET:
+     if(offset > length) {
+-      printerr("Request to seek behind end.");
++      printerr(MSGTR_LIBMPDVDNAV_Err_RequestToSeekBehindEnd);
+       pthread_mutex_unlock(&this->vm_lock);
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -144,7 +153,7 @@
+     break;
+    case SEEK_CUR:
+     if(target + offset > length) {
+-      printerr("Request to seek behind end.");
++      printerr(MSGTR_LIBMPDVDNAV_Err_RequestToSeekBehindEnd);
+       pthread_mutex_unlock(&this->vm_lock);
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -152,7 +161,7 @@
+     break;
+    case SEEK_END:
+     if(length - offset < 0) {
+-      printerr("Request to seek before start.");
++      printerr(MSGTR_LIBMPDVDNAV_Err_RequestToSeekBeforeStart);
+       pthread_mutex_unlock(&this->vm_lock);
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -160,7 +169,7 @@
+     break;
+    default:
+     /* Error occured */
+-    printerr("Illegal seek mode.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_IllegalSeekMode);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -195,7 +204,7 @@
+   if(found) {
+     int32_t vobu;
+ #ifdef LOG_DEBUG
+-    fprintf(MSG_OUT, "libdvdnav: Seeking to cell %i from choice of %i to %i\n",
++    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Seeking to cell %i from choice of %i to %i\n",
+ 	    cell_nr, first_cell_nr, last_cell_nr);
+ #endif
+     if (dvdnav_scan_admap(this, state->domain, target, &vobu) == DVDNAV_STATUS_OK) {
+@@ -203,7 +212,7 @@
+       
+       if (vm_jump_cell_block(this->vm, cell_nr, vobu - start)) {
+ #ifdef LOG_DEBUG
+-        fprintf(MSG_OUT, "libdvdnav: After cellN=%u blockN=%u target=%x vobu=%x start=%x\n" ,
++        mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: After cellN=%u blockN=%u target=%x vobu=%x start=%x\n" ,
+           state->cellN, state->blockN, target, vobu, start);
+ #endif
+         this->vm->hop_channel += HOP_SEEK;
+@@ -213,9 +222,9 @@
+     }
+   }
+   
+-  fprintf(MSG_OUT, "libdvdnav: Error when seeking\n");
+-  fprintf(MSG_OUT, "libdvdnav: FIXME: Implement seeking to location %u\n", target); 
+-  printerr("Error when seeking.");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_ErrorWhenSeeking);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_FIXMEImplementSeekingToLocation, target);
++  printerr(MSGTR_LIBMPDVDNAV_Err_ErrorWhenSeeking);
+   pthread_mutex_unlock(&this->vm_lock);
+   return DVDNAV_STATUS_ERR;
+ }
+@@ -231,30 +240,30 @@
+ dvdnav_status_t dvdnav_prev_pg_search(dvdnav_t *this) {
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+   pthread_mutex_lock(&this->vm_lock);
+   if(!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: previous chapter\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: previous chapter\n");
+ #endif
+   if (!vm_jump_prev_pg(this->vm)) {
+-    fprintf(MSG_OUT, "libdvdnav: previous chapter failed.\n");
+-    printerr("Skip to previous chapter failed.");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_PreviousChapterFailed);
++    printerr(MSGTR_LIBMPDVDNAV_Err_SkipToPreviousChapterFailed);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+   this->position_current.still = 0;
+   this->vm->hop_channel++;
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: previous chapter done\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: previous chapter done\n");
+ #endif
+   pthread_mutex_unlock(&this->vm_lock);
+ 
+@@ -264,30 +273,30 @@
+ dvdnav_status_t dvdnav_top_pg_search(dvdnav_t *this) {
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+     
+   pthread_mutex_lock(&this->vm_lock);
+   if(!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: top chapter\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: top chapter\n");
+ #endif
+   if (!vm_jump_top_pg(this->vm)) {
+-    fprintf(MSG_OUT, "libdvdnav: top chapter failed.\n");
+-    printerr("Skip to top chapter failed.");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_TopChapterFailed);
++    printerr(MSGTR_LIBMPDVDNAV_Err_SkipToTopChapterFailed);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+   this->position_current.still = 0;
+   this->vm->hop_channel++;
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: top chapter done\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: top chapter done\n");
+ #endif
+   pthread_mutex_unlock(&this->vm_lock);
+ 
+@@ -298,19 +307,19 @@
+   vm_t *try_vm;
+ 
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   pthread_mutex_lock(&this->vm_lock);
+   if(!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: next chapter\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: next chapter\n");
+ #endif
+   /* make a copy of current VM and try to navigate the copy to the next PG */
+   try_vm = vm_new_copy(this->vm);
+@@ -321,8 +330,8 @@
+     vm_get_next_cell(try_vm);
+     if (try_vm->stopped) {
+       vm_free_copy(try_vm);
+-      fprintf(MSG_OUT, "libdvdnav: next chapter failed.\n");
+-      printerr("Skip to next chapter failed.");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_NextChapterFailed);
++      printerr(MSGTR_LIBMPDVDNAV_Err_SkipToNextChapterFailed);
+       pthread_mutex_unlock(&this->vm_lock);
+       return DVDNAV_STATUS_ERR;
+     }
+@@ -333,7 +342,7 @@
+   this->position_current.still = 0;
+   this->vm->hop_channel++;
+ #ifdef LOG_DEBUG
+-  fprintf(MSG_OUT, "libdvdnav: next chapter done\n");
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: next chapter done\n");
+ #endif
+   pthread_mutex_unlock(&this->vm_lock);
+ 
+@@ -344,13 +353,13 @@
+   vm_t *try_vm;
+   
+   if(!this) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   pthread_mutex_lock(&this->vm_lock);
+   if(!this->vm->state.pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -381,7 +390,7 @@
+     return DVDNAV_STATUS_OK;
+   } else {
+     vm_free_copy(try_vm);
+-    printerr("No such menu or menu not reachable.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoSuchMenuOrMenuNotReachable);
+     pthread_mutex_unlock(&this->vm_lock); 
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -395,18 +404,18 @@
+   dvd_state_t *state;
+ 
+   if(!this || !pos || !len) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+   if(!this->started) {
+-    printerr("Virtual DVD machine not started.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   pthread_mutex_lock(&this->vm_lock);
+   state = &(this->vm->state);
+   if(!state->pgc || this->vm->stopped) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -414,7 +423,7 @@
+       this->position_current.domain       != state->domain         ||
+       this->position_current.vts          != state->vtsN           ||
+       this->position_current.cell_restart != state->cell_restart) {
+-    printerr("New position not yet determined.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NewPositionNotYetDetermined);
+     pthread_mutex_unlock(&this->vm_lock);
+     return DVDNAV_STATUS_ERR;
+   }
+@@ -465,13 +474,13 @@
+   dvd_state_t *state;
+ 
+   if(!this || !pos || !len) {
+-    printerr("Passed a NULL pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   state = &(this->vm->state);
+   if(!state->pgc) {
+-    printerr("No current PGC.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -489,3 +498,26 @@
+   
+   return DVDNAV_STATUS_OK;
+ }
++
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_get_pgc(dvdnav_t *this, int *pg_num)
++{
++  if(!this || !pg_num) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++
++  pthread_mutex_lock(&this->vm_lock);
++  if(!this->vm->state.pgc) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
++    pthread_mutex_unlock(&this->vm_lock);
++    return DVDNAV_STATUS_ERR;
++  }
++#ifdef LOG_DEBUG
++  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: get pgc\n");
++#endif
++  *pg_num = vm_get_PGCN(this->vm);
++  pthread_mutex_unlock(&this->vm_lock);
++  return DVDNAV_STATUS_OK;
++}
++#endif
+--- settings.c	2003-12-31 22:37:16.000000000 +0100
++++ settings.c	2006-04-05 16:03:10.000000000 +0200
+@@ -21,17 +21,26 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include "dvdnav_internal.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
+ /* Characteristics/setting API calls */
+ 
+ dvdnav_status_t dvdnav_get_region_mask(dvdnav_t *this, int32_t *region) {
+   if(!this || !region) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -41,7 +50,7 @@
+ 
+ dvdnav_status_t dvdnav_set_region_mask(dvdnav_t *this, int32_t mask) {
+   if(!this) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -53,7 +62,7 @@
+ 
+ dvdnav_status_t dvdnav_set_readahead_flag(dvdnav_t *this, int32_t use_readahead) {
+   if(!this) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -63,7 +72,7 @@
+ 
+ dvdnav_status_t dvdnav_get_readahead_flag(dvdnav_t *this, int32_t *flag) {
+   if(!this || !flag) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -73,12 +82,12 @@
+ 
+ static dvdnav_status_t set_language_register(dvdnav_t *this, char *code, int reg) {
+   if(!this || !code) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+     
+   if(!code[0] || !code[1]) {
+-    printerr("Passed illegal language code.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedIllegalLanguageCode);
+     return DVDNAV_STATUS_ERR;
+   }
+   
+@@ -102,7 +111,7 @@
+ 
+ dvdnav_status_t dvdnav_set_PGC_positioning_flag(dvdnav_t *this, int32_t pgc) {
+   if(!this) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+@@ -112,10 +121,25 @@
+ 
+ dvdnav_status_t dvdnav_get_PGC_positioning_flag(dvdnav_t *this, int32_t *flag) {
+   if(!this || !flag) {
+-    printerr("Passed a NULL this pointer.");
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+     return DVDNAV_STATUS_ERR;
+   }
+ 
+   (*flag) = this->pgc_based;
+   return DVDNAV_STATUS_OK;
+ }
++
++#ifdef USE_MPDVDNAV
++dvdnav_status_t dvdnav_button_select_auto_action(dvdnav_t *this, int mode)
++{
++  if(!this) {
++    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
++    return DVDNAV_STATUS_ERR;
++  }
++
++  pthread_mutex_lock(&this->vm_lock);
++  this->vm->auto_action_mode = mode;
++  pthread_mutex_unlock(&this->vm_lock);
++  return DVDNAV_STATUS_OK;
++}
++#endif
+--- vm/decoder.c	2004-03-03 17:50:42.000000000 +0100
++++ decoder.c	2006-04-05 16:03:09.000000000 +0200
+@@ -23,18 +23,52 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <inttypes.h>
+ #include <string.h>  /* For memset */
+-#include "ifo_types.h" /* vm_cmd_t */
++
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
++#else
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
++#endif
+ 
+ #include "dvdnav_internal.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
++#ifdef USE_MPDVDNAV_TRACE
++extern int dvdnav_trace;
++#endif
++
+ uint32_t vm_getbits(command_t *command, int32_t start, int32_t count) {
+   uint64_t result = 0;
+   uint64_t bit_mask = 0;
+@@ -48,7 +82,7 @@
+        (start > 63) ||
+        (count < 0) ||
+        (start < 0) ) {
+-    fprintf(MSG_OUT, "libdvdnav: Bad call to vm_getbits. Parameter out of range\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_BadCallToVMGetbits);
+     abort();
+   }
+   /* all ones, please */
+@@ -66,7 +100,7 @@
+     struct timeval current_time, time_offset;
+     uint16_t result;
+     /* Counter mode */
+-    /* fprintf(MSG_OUT, "libdvdnav: Getting counter %d\n",reg);*/
++    /* mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Getting counter %d\n",reg);*/
+     gettimeofday(&current_time, NULL);
+     time_offset.tv_sec = current_time.tv_sec - registers->GPRM_time[reg].tv_sec;
+     time_offset.tv_usec = current_time.tv_usec - registers->GPRM_time[reg].tv_usec;
+@@ -89,7 +123,7 @@
+   if (registers->GPRM_mode[reg] & 0x01) {
+     struct timeval current_time;
+     /* Counter mode */
+-    /* fprintf(MSG_OUT, "libdvdnav: Setting counter %d\n",reg); */
++    /* mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Setting counter %d\n",reg); */
+     gettimeofday(&current_time, NULL);
+     registers->GPRM_time[reg] = current_time;
+     registers->GPRM_time[reg].tv_sec -= value;
+@@ -102,7 +136,7 @@
+ static uint16_t eval_reg(command_t* command, uint8_t reg) {
+   if(reg & 0x80) {
+     if ((reg & 0x1f) == 20) {
+-      fprintf(MSG_OUT, "libdvdnav: Suspected RCE Region Protection!!!\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_SuspectedRCERegionProtection);
+     }
+     return command->registers->SPRM[reg & 0x1f]; /*  FIXME max 24 not 32 */
+   } else {
+@@ -153,7 +187,7 @@
+     case 7:
+       return data1 <  data2;
+   }
+-  fprintf(MSG_OUT, "libdvdnav: eval_compare: Invalid comparison code\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_EvalCompareInvalidComparisonCode);
+   return 0;
+ }
+ 
+@@ -511,7 +545,7 @@
+       cond = eval_if_version_1(&command);
+       res = eval_special_instruction(&command, cond);
+       if(res == -1) {
+-	fprintf(MSG_OUT, "libdvdnav: Unknown Instruction!\n");
++	mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_UnknownInstrution);
+ 	abort();
+       }
+       break;
+@@ -565,15 +599,15 @@
+ 	res = -1;
+       break;
+     default: /* Unknown command */
+-      fprintf(MSG_OUT, "libdvdnav: WARNING: Unknown Command=%x\n", vm_getbits(&command, 63, 3));
++       mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_WarningUnknownComman, vm_getbits(&command, 63, 3));
+       abort();
+   }
+   /*  Check if there are bits not yet examined */
+ 
+   if(command.instruction & ~ command.examined) {
+-    fprintf(MSG_OUT, "libdvdnav: decoder.c: [WARNING, unknown bits:");
+-    fprintf(MSG_OUT, " %08llx", (command.instruction & ~ command.examined) );
+-    fprintf(MSG_OUT, "]\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCWarningUnknownBits);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO," %08llx", (command.instruction & ~ command.examined) );
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "]\n");
+   }
+ 
+   return res;
+@@ -585,15 +619,16 @@
+   int32_t i = 0;
+   int32_t total = 0;
+   
+-#ifdef TRACE
++#ifdef USE_MPDVDNAV_TRACE
+   /*  DEBUG */
+-  fprintf(MSG_OUT, "libdvdnav: Registers before transaction\n");
++  if (dvdnav_trace) {
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Registers before transaction\n");
+   vm_print_registers( registers );
+-  fprintf(MSG_OUT, "libdvdnav: Full list of commands to execute\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Full list of commands to execute\n");
+   for(i = 0; i < num_commands; i++)
+     vm_print_cmd(i, &commands[i]);
+-  fprintf(MSG_OUT, "libdvdnav: --------------------------------------------\n");
+-  fprintf(MSG_OUT, "libdvdnav: Single stepping commands\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: --------------------------------------------\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Single stepping commands\n");}
+ #endif
+ 
+   i = 0; 
+@@ -601,16 +636,17 @@
+     int32_t line;
+     
+ #ifdef TRACE
+-    vm_print_cmd(i, &commands[i]);
++  if (dvdnav_trace) vm_print_cmd(i, &commands[i]);
+ #endif
+ 
+     line = eval_command(&commands[i].bytes[0], registers, return_values);
+     
+     if (line < 0) { /*  Link command */
+-#ifdef TRACE
+-      fprintf(MSG_OUT, "libdvdnav: Registers after transaction\n");
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) {
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Registers after transaction\n");
+       vm_print_registers( registers );
+-      fprintf(MSG_OUT, "libdvdnav: eval: Doing Link/Jump/Call\n"); 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: eval: Doing Link/Jump/Call\n"); }
+ #endif
+       return 1;
+     }
+@@ -624,14 +660,15 @@
+   }
+   
+   memset(return_values, 0, sizeof(link_t));
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: Registers after transaction\n");
+-  vm_print_registers( registers );
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) {
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,"libdvdnav: Registers after transaction\n");
++  vm_print_registers( registers ); }
+ #endif
+   return 0;
+ }
+ 
+-#ifdef TRACE
++#ifdef USE_MPDVDNAV_TRACE
+ 
+ static char *linkcmd2str(link_cmd_t cmd) {
+   switch(cmd) {
+@@ -716,63 +753,63 @@
+   case LinkGoUpPGC:
+   case LinkTailPGC:
+   case LinkRSM:
+-    fprintf(MSG_OUT, "libdvdnav: %s (button %d)\n", cmd, value.data1);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCButton, cmd, value.data1);
+     break;
+   case LinkPGCN:
+   case JumpTT:
+   case JumpVTS_TT:
+   case JumpSS_VMGM_MENU: /*  == 2 -> Title Menu */
+   case JumpSS_VMGM_PGC:
+-    fprintf(MSG_OUT, "libdvdnav: %s %d\n", cmd, value.data1);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: %s %d\n", cmd, value.data1);
+     break;
+   case LinkPTTN:
+   case LinkPGN:
+   case LinkCN:
+-    fprintf(MSG_OUT, "libdvdnav: %s %d (button %d)\n", cmd, value.data1, value.data2);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCButton2, cmd, value.data1, value.data2);
+     break;
+   case Exit:
+   case JumpSS_FP:
+   case PlayThis: /*  Humm.. should we have this at all.. */
+-    fprintf(MSG_OUT, "libdvdnav: %s\n", cmd);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: %s\n", cmd);
+     break;
+   case JumpVTS_PTT:
+-    fprintf(MSG_OUT, "libdvdnav: %s %d:%d\n", cmd, value.data1, value.data2);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: %s %d:%d\n", cmd, value.data1, value.data2);
+     break;
+   case JumpSS_VTSM:
+-    fprintf(MSG_OUT, "libdvdnav: %s vts %d title %d menu %d\n", 
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCVtsTitleMenu,
+ 	    cmd, value.data1, value.data2, value.data3);
+     break;
+   case CallSS_FP:
+-    fprintf(MSG_OUT, "libdvdnav: %s resume cell %d\n", cmd, value.data1);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCResumeCell, cmd, value.data1);
+     break;
+   case CallSS_VMGM_MENU: /*  == 2 -> Title Menu */
+   case CallSS_VTSM:
+-    fprintf(MSG_OUT, "libdvdnav: %s %d resume cell %d\n", cmd, value.data1, value.data2);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCResumeCell2, cmd, value.data1, value.data2);
+     break;
+   case CallSS_VMGM_PGC:
+-    fprintf(MSG_OUT, "libdvdnav: %s %d resume cell %d\n", cmd, value.data1, value.data2);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_DecoderCResumeCell2, cmd, value.data1, value.data2);
+     break;
+   }
+  }
+ 
+ void vm_print_registers( registers_t *registers ) {
+   int32_t i;
+-  fprintf(MSG_OUT, "libdvdnav:    #   ");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav:    #   ");
+   for(i = 0; i < 24; i++)
+-    fprintf(MSG_OUT, " %2d |", i);
+-  fprintf(MSG_OUT, "\nlibdvdnav: SRPMS: ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %2d |", i);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: SRPMS: ");
+   for(i = 0; i < 24; i++)
+-    fprintf(MSG_OUT, "%04x|", registers->SPRM[i]);
+-  fprintf(MSG_OUT, "\nlibdvdnav: GRPMS: ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04x|", registers->SPRM[i]);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: GRPMS: ");
+   for(i = 0; i < 16; i++)
+-    fprintf(MSG_OUT, "%04x|", get_GPRM(registers, i) );
+-  fprintf(MSG_OUT, "\nlibdvdnav: Gmode: ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04x|", get_GPRM(registers, i) );
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: Gmode: ");
+   for(i = 0; i < 16; i++)
+-    fprintf(MSG_OUT, "%04x|", registers->GPRM_mode[i]);
+-  fprintf(MSG_OUT, "\nlibdvdnav: Gtime: ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04x|", registers->GPRM_mode[i]);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\nlibdvdnav: Gtime: ");
+   for(i = 0; i < 16; i++)
+-    fprintf(MSG_OUT, "%04lx|", registers->GPRM_time[i].tv_sec & 0xffff);
+-  fprintf(MSG_OUT, "\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%04lx|", registers->GPRM_time[i].tv_sec & 0xffff);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+ }
+ 
+ #endif
+--- vm/decoder.h	2004-01-11 22:43:13.000000000 +0100
++++ decoder.h	2006-04-05 16:03:09.000000000 +0200
+@@ -28,7 +28,27 @@
+ #include <inttypes.h>
+ #include <sys/time.h>
+ 
+-#include "ifo_types.h" /*  vm_cmd_t */
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
++#else
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
++#endif
+ #include "dvdnav_internal.h"
+ 
+ /* link command types */
+@@ -107,7 +127,7 @@
+ /* extracts some bits from the command */
+ uint32_t vm_getbits(command_t* command, int32_t start, int32_t count);
+ 
+-#ifdef TRACE
++#ifdef USE_MPDVDNAV_TRACE
+ /* for debugging: prints a link in readable form */
+ void vm_print_link(link_t value);
+ 
+--- vm/vm.c	2004-05-21 21:32:25.000000000 +0200
++++ vm.c	2006-04-05 16:41:51.000000000 +0200
+@@ -24,9 +24,13 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include <stdio.h>
+ #include <string.h>
+@@ -38,8 +42,27 @@
+ #include <sys/stat.h>
+ #include <fcntl.h>
+ 
+-#include "ifo_types.h"
+-#include "ifo_read.h"
++#ifdef USE_MPDVDKIT
++#if (USE_MPDVDKIT == 2)
++#include "libmpdvdkit2/dvd_input.h"
++#include "libmpdvdkit2/dvd_reader.h"
++#include "libmpdvdkit2/ifo_types.h"
++#include "libmpdvdkit2/ifo_read.h"
++#include "libmpdvdkit2/nav_read.h"
++#else
++#include "libmpdvdkit/dvd_input.h"
++#include "libmpdvdkit/dvd_reader.h"
++#include "libmpdvdkit/ifo_types.h"
++#include "libmpdvdkit/ifo_read.h"
++#include "libmpdvdkit/nav_read.h"
++#endif
++#else
++#include <dvdread/dvd_input.h>
++#include <dvdread/dvd_reader.h>
++#include <dvdread/ifo_types.h>
++#include <dvdread/ifo_read.h>
++#include <dvdread/nav_read.h>
++#endif
+ 
+ #include "dvdnav_internal.h"
+ 
+@@ -47,6 +70,14 @@
+ #include <io.h>   /* read() */
+ #endif /* _MSC_VER */
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++#ifdef USE_MPDVDNAV_TRACE
++extern int dvdnav_trace;
++#endif
++
+ /*
+ #define STRICT
+ */
+@@ -91,30 +122,30 @@
+ 
+ /* Helper functions */
+ 
+-#ifdef TRACE
++#ifdef USE_MPDVDNAV_TRACE
+ static void vm_print_current_domain_state(vm_t *vm) {
+   switch((vm->state).domain) {
+     case VTS_DOMAIN:
+-      fprintf(MSG_OUT, "libdvdnav: Video Title Domain: -\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Video Title Domain: -\n");
+       break;
+ 
+     case VTSM_DOMAIN:
+-      fprintf(MSG_OUT, "libdvdnav: Video Title Menu Domain: -\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Video Title Menu Domain: -\n");
+       break;
+ 
+     case VMGM_DOMAIN:
+-      fprintf(MSG_OUT, "libdvdnav: Video Manager Menu Domain: -\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Video Manager Menu Domain: -\n");
+       break;
+ 
+     case FP_DOMAIN: 
+-      fprintf(MSG_OUT, "libdvdnav: First Play Domain: -\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: First Play Domain: -\n");
+       break;
+ 
+     default:
+-      fprintf(MSG_OUT, "libdvdnav: Unknown Domain: -\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Unknown Domain: -\n");
+       break;
+   }
+-  fprintf(MSG_OUT, "libdvdnav: VTS:%d PGC:%d PG:%u CELL:%u BLOCK:%u VTS_TTN:%u TTN:%u TT_PGCN:%u\n", 
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: VTS:%d PGC:%d PG:%u CELL:%u BLOCK:%u VTS_TTN:%u TTN:%u TT_PGCN:%u\n",
+                    (vm->state).vtsN,
+                    get_PGCN(vm),
+                    (vm->state).pgN,
+@@ -131,56 +162,58 @@
+      * all off_t are 64bit.
+      */
+     off_t off;
+-    int fd, i;
++    int i;
++    dvd_input_t fd;
+     uint8_t data[DVD_VIDEO_LB_LEN];
+ 
+     /* Read DVD name */
+-    fd = open(device, O_RDONLY);
++    fd = dvdinput_open(device);
+     if (fd > 0) { 
+-      off = lseek( fd, 32 * (off_t) DVD_VIDEO_LB_LEN, SEEK_SET );
+-      if( off == ( 32 * (off_t) DVD_VIDEO_LB_LEN ) ) {
+-        off = read( fd, data, DVD_VIDEO_LB_LEN ); 
+-        close(fd);
+-        if (off == ( (off_t) DVD_VIDEO_LB_LEN )) {
+-          fprintf(MSG_OUT, "libdvdnav: DVD Title: ");
+-          for(i=25; i < 73; i++ ) {
++      off = dvdinput_seek( fd, 16 );
++      if( off == 16 ) {
++        off = dvdinput_read( fd, data, 1, DVDINPUT_NOFLAGS );
++        if (off == 1 ) {
++	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDTitle);
++          for(i=40; i < 73; i++ ) {
+             if((data[i] == 0)) break;
+             if((data[i] > 32) && (data[i] < 127)) {
+-              fprintf(MSG_OUT, "%c", data[i]);
++	    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c", data[i]);
+             } else {
+-              fprintf(MSG_OUT, " ");
++	      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+             }
+           }
+-          strncpy(name, &data[25], 48);
+-          name[48] = 0;
+-          fprintf(MSG_OUT, "\nlibdvdnav: DVD Serial Number: ");
+-          for(i=73; i < 89; i++ ) {
++          strncpy(name, &data[40], 32);
++          i=31;
++          while( (i >= 0) && (name[i] <= ' ')) --i;
++          name[i+1] = '\0';
++	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDSerialNumber);
++          for(i=813; i < 829; i++ ) {
+             if((data[i] == 0)) break;
+             if((data[i] > 32) && (data[i] < 127)) {
+-              fprintf(MSG_OUT, "%c", data[i]);
++	      mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c", data[i]);
+             } else {
+-              fprintf(MSG_OUT, " ");
++	      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+             } 
+           }
+-          fprintf(MSG_OUT, "\nlibdvdnav: DVD Title (Alternative): ");
++	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDTitleAlternative);
+           for(i=89; i < 128; i++ ) {
+             if((data[i] == 0)) break;
+             if((data[i] > 32) && (data[i] < 127)) {
+-              fprintf(MSG_OUT, "%c", data[i]);
++	      mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c", data[i]);
+             } else {
+-              fprintf(MSG_OUT, " ");
++	      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+             }
+           }
+-          fprintf(MSG_OUT, "\n");
++	  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+         } else {
+-          fprintf(MSG_OUT, "libdvdnav: Can't read name block. Probably not a DVD-ROM device.\n");
++	  mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_LIBMPDVDNAV_VmCCantReadNameBlock);
+         }
+       } else {
+-        fprintf(MSG_OUT, "libdvdnav: Can't seek to block %u\n", 32 );
++        mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_LIBMPDVDNAV_VmCCantSeekToBlock);
+       }
+-      close(fd);
++      dvdinput_close(fd);
+     } else {
+-    fprintf(MSG_OUT, "NAME OPEN FAILED\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_LIBMPDVDNAV_VmCNameOpenFailed);
+   }
+ }
+ 
+@@ -194,27 +228,27 @@
+   
+   vm->vtsi = ifoOpenVTSI(dvd, vtsN);
+   if(vm->vtsi == NULL) {
+-    fprintf(MSG_OUT, "libdvdnav: ifoOpenVTSI failed - CRASHING!!!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoOpenVTSIFailed);
+     assert(0);
+   }
+   if(!ifoRead_VTS_PTT_SRPT(vm->vtsi)) {
+-    fprintf(MSG_OUT, "libdvdnav: ifoRead_VTS_PTT_SRPT failed - CRASHING!!!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadVTSPTTSRPTFailed);
+     assert(0);
+   }
+   if(!ifoRead_PGCIT(vm->vtsi)) {
+-    fprintf(MSG_OUT, "libdvdnav: ifoRead_PGCIT failed - CRASHING!!!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadPGCITFailed);
+     assert(0);
+   }
+   if(!ifoRead_PGCI_UT(vm->vtsi)) {
+-    fprintf(MSG_OUT, "libdvdnav: ifoRead_PGCI_UT failed - CRASHING!!!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadPGCIUTFailed);
+     assert(0);
+   }
+   if(!ifoRead_VOBU_ADMAP(vm->vtsi)) {
+-    fprintf(MSG_OUT, "libdvdnav: ifoRead_VOBU_ADMAP vtsi failed - CRASHING\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadVOBUADMAPVtsiFailed);
+     assert(0);
+   }
+   if(!ifoRead_TITLE_VOBU_ADMAP(vm->vtsi)) {
+-    fprintf(MSG_OUT, "libdvdnav: ifoRead_TITLE_VOBU_ADMAP vtsi failed - CRASHING\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadTITLEVOBUADMAPVtsiFailed);
+     assert(0);
+   }
+   (vm->state).vtsN = vtsN;
+@@ -316,50 +350,50 @@
+   if (!vm->dvd) {
+     vm->dvd = DVDOpen(dvdroot);
+     if(!vm->dvd) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: faild to open/read the DVD\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmFaildToOpenReadTheDVD);
+       return 0;
+     }
+     dvd_read_name(vm->dvd_name, dvdroot);
+     vm->map  = remap_loadmap(vm->dvd_name);
+     vm->vmgi = ifoOpenVMGI(vm->dvd);
+     if(!vm->vmgi) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: faild to read VIDEO_TS.IFO\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmFaildToReadVIDEOTSIFO);
+       return 0;
+     }
+     if(!ifoRead_FP_PGC(vm->vmgi)) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: ifoRead_FP_PGC failed\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadFPPGCFailed);
+       return 0;
+     }
+     if(!ifoRead_TT_SRPT(vm->vmgi)) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: ifoRead_TT_SRPT failed\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadTTSRPTFailed);
+       return 0;
+     }
+     if(!ifoRead_PGCI_UT(vm->vmgi)) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: ifoRead_PGCI_UT failed\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadPGCIUTFailed);
+       return 0;
+     }
+     if(!ifoRead_PTL_MAIT(vm->vmgi)) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: ifoRead_PTL_MAIT failed\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadPRLMAITFailed);
+       /* return 0; Not really used for now.. */
+     }
+     if(!ifoRead_VTS_ATRT(vm->vmgi)) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: ifoRead_VTS_ATRT failed\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadVTSATRTFailed);
+       /* return 0; Not really used for now.. */
+     }
+     if(!ifoRead_VOBU_ADMAP(vm->vmgi)) {
+-      fprintf(MSG_OUT, "libdvdnav: vm: ifoRead_VOBU_ADMAP vgmi failed\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadVOBUADMAPVgmiFailed);
+       /* return 0; Not really used for now.. */
+     }
+     /* ifoRead_TXTDT_MGI(vmgi); Not implemented yet */
+   }
+   if (vm->vmgi) {
+     int i, mask;
+-    fprintf(MSG_OUT, "libdvdnav: DVD disk reports itself with Region mask 0x%08x. Regions:",
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDDiskReportsItselfWithRegionMask,
+       vm->vmgi->vmgi_mat->vmg_category);
+     for (i = 1, mask = 1; i <= 8; i++, mask <<= 1)
+       if (((vm->vmgi->vmgi_mat->vmg_category >> 16) & mask) == 0)
+-        fprintf(MSG_OUT, " %d", i);
+-    fprintf(MSG_OUT, "\n");
++	mp_msg(MSGT_CPLAYER,MSGL_INFO, " %d", i);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+   }
+   return 1;
+ }
+@@ -636,16 +670,16 @@
+   part++;
+   
+   if (!found) {
+-    fprintf(MSG_OUT, "libdvdnav: chapter NOT FOUND!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCChapterNotFound);
+     return 0;
+   }
+ 
+   title = get_TT(vm, vm->state.vtsN, vts_ttn);
+ 
+-#ifdef TRACE
+-  if (title) {
+-    fprintf(MSG_OUT, "libdvdnav: ************ this chapter FOUND!\n");
+-    fprintf(MSG_OUT, "libdvdnav: VTS_PTT_SRPT - Title %3i part %3i: PGC: %3i PG: %3i\n",
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace && title) {
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ************ this chapter FOUND!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: VTS_PTT_SRPT - Title %3i part %3i: PGC: %3i PG: %3i\n",
+              title, part,
+              vts_ptt_srpt->title[vts_ttn-1].ptt[part-1].pgcn ,
+              vts_ptt_srpt->title[vts_ttn-1].ptt[part-1].pgn );
+@@ -667,8 +701,8 @@
+   
+   if(audioN < 8) {
+     /* Is there any control info for this logical stream */ 
+-    if((vm->state).pgc->audio_control[audioN] & (1<<15)) {
+-      streamN = ((vm->state).pgc->audio_control[audioN] >> 8) & 0x07;  
++    if( (vm->state).pgc->audio_control[audioN].present) {
++      streamN = (vm->state).pgc->audio_control[audioN].s_audio;
+     }
+   }
+   
+@@ -695,19 +729,19 @@
+   
+   if(subpN < 32) { /* a valid logical stream */
+     /* Is this logical stream present */ 
+-    if((vm->state).pgc->subp_control[subpN] & (1<<31)) {
++    if((vm->state).pgc->subp_control[subpN].present) {
+       if(source_aspect == 0) /* 4:3 */	     
+-	streamN = ((vm->state).pgc->subp_control[subpN] >> 24) & 0x1f;  
++	streamN = (vm->state).pgc->subp_control[subpN].s_4p3;
+       if(source_aspect == 3) /* 16:9 */
+         switch (mode) {
+ 	case 0:
+-	  streamN = ((vm->state).pgc->subp_control[subpN] >> 16) & 0x1f;
++	  streamN = (vm->state).pgc->subp_control[subpN].s_wide;
+ 	  break;
+ 	case 1:
+-	  streamN = ((vm->state).pgc->subp_control[subpN] >> 8) & 0x1f;
++	  streamN = (vm->state).pgc->subp_control[subpN].s_lbox;
+ 	  break;
+ 	case 2:
+-	  streamN = (vm->state).pgc->subp_control[subpN] & 0x1f;
++	  streamN = (vm->state).pgc->subp_control[subpN].s_panscan;
+ 	}
+     }
+   }
+@@ -728,7 +762,11 @@
+   /* If no such stream, then select the first one that exists. */
+   if(streamN == -1) {
+     for(audioN = 0; audioN < 8; audioN++) {
++#ifdef USE_MPDVDKIT
++      if((vm->state).pgc->audio_control[audioN].present) {
++#else
+       if((vm->state).pgc->audio_control[audioN] & (1<<15)) {
++#endif
+         if ((streamN = vm_get_audio_stream(vm, audioN)) >= 0)
+           break;
+       }
+@@ -747,7 +785,11 @@
+   /* If no such stream, then select the first one that exists. */
+   if(streamN == -1) {
+     for(subpN = 0; subpN < 32; subpN++) {
++#ifdef USE_MPDVDKIT
++      if((vm->state).pgc->subp_control[subpN].present) {
++#else
+       if((vm->state).pgc->subp_control[subpN] & (1<<31)) {
++#endif
+         if ((streamN = vm_get_subp_stream(vm, subpN, mode)) >= 0)
+           break;
+       }
+@@ -844,6 +886,22 @@
+ }
+ #endif
+ 
++#if 0
++int vm_get_audio_id(vm_t *vm, int streamN) {
++  switch ((vm->state).domain) {
++  case VTS_DOMAIN:
++    return vm->vtsi->vtsi_mat->vts_audio_attr[streamN].s_audio;
++  case VTSM_DOMAIN:
++    return vm->vtsi->vtsi_mat->vtsm_audio_attr.s_audio;
++  case VMGM_DOMAIN:
++  case FP_DOMAIN:
++    return vm->vmgi->vmgi_mat->vmgm_audio_attr.s_audio;;
++  default:
++    abort();
++  }
++}
++#endif
++
+ int vm_get_video_aspect(vm_t *vm) {
+   int aspect = vm_get_video_attr(vm).display_aspect_ratio;
+   
+@@ -906,13 +964,14 @@
+ static link_t play_PGC(vm_t *vm) {
+   link_t link_values;
+   
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: play_PGC:");
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) {
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PGC:");
+   if((vm->state).domain != FP_DOMAIN) {
+-    fprintf(MSG_OUT, " (vm->state).pgcN (%i)\n", get_PGCN(vm));
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " (vm->state).pgcN (%i)\n", get_PGCN(vm));
+   } else {
+-    fprintf(MSG_OUT, " first_play_pgc\n");
+-  }
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " first_play_pgc\n");
++  } }
+ #endif
+ 
+   /* This must be set before the pre-commands are executed because they
+@@ -935,8 +994,8 @@
+       /*  link_values contains the 'jump' return value */
+       return link_values;
+     } else {
+-#ifdef TRACE
+-      fprintf(MSG_OUT, "libdvdnav: PGC pre commands didn't do a Jump, Link or Call\n");
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: PGC pre commands didn't do a Jump, Link or Call\n");
+ #endif
+     }
+   }
+@@ -946,13 +1005,14 @@
+ static link_t play_PGC_PG(vm_t *vm, int pgN) {    
+   link_t link_values;
+   
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: play_PGC_PG:");
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) {
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PGC_PG:");
+   if((vm->state).domain != FP_DOMAIN) {
+-    fprintf(MSG_OUT, " (vm->state).pgcN (%i)\n", get_PGCN(vm));
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " (vm->state).pgcN (%i)\n", get_PGCN(vm));
+   } else {
+-    fprintf(MSG_OUT, " first_play_pgc\n");
+-  }
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " first_play_pgc\n");
++  } }
+ #endif
+ 
+   /*  This must be set before the pre-commands are executed because they
+@@ -975,8 +1035,8 @@
+       /*  link_values contains the 'jump' return value */
+       return link_values;
+     } else {
+-#ifdef TRACE
+-      fprintf(MSG_OUT, "libdvdnav: PGC pre commands didn't do a Jump, Link or Call\n");
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: PGC pre commands didn't do a Jump, Link or Call\n");
+ #endif
+     }
+   }
+@@ -986,8 +1046,8 @@
+ static link_t play_PGC_post(vm_t *vm) {
+   link_t link_values;
+ 
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: play_PGC_post:\n");
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PGC_post:\n");
+ #endif
+   
+   /* eval -> updates the state and returns either 
+@@ -1002,26 +1062,28 @@
+     return link_values;
+   }
+   
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: ** Fell of the end of the pgc, continuing in NextPGC\n");
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ** Fell of the end of the pgc, continuing in NextPGC\n");
+ #endif
+   /* Should end up in the STOP_DOMAIN if next_pgc is 0. */
++//#ifndef USE_MPDVDNAV
+   if(!set_PGCN(vm, (vm->state).pgc->next_pgc_nr)) {
+     link_values.command = Exit;
+     return link_values;
+   }
++//#endif
+   return play_PGC(vm);
+ }
+ 
+ static link_t play_PG(vm_t *vm) {
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: play_PG: (vm->state).pgN (%i)\n", (vm->state).pgN);
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PG: (vm->state).pgN (%i)\n", (vm->state).pgN);
+ #endif
+   
+   assert((vm->state).pgN > 0);
+   if((vm->state).pgN > (vm->state).pgc->nr_of_programs) {
+-#ifdef TRACE
+-    fprintf(MSG_OUT, "libdvdnav: play_PG: (vm->state).pgN (%i) > pgc->nr_of_programs (%i)\n", 
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PG: (vm->state).pgN (%i) > pgc->nr_of_programs (%i)\n",
+ 	    (vm->state).pgN, (vm->state).pgc->nr_of_programs );
+ #endif
+     assert((vm->state).pgN == (vm->state).pgc->nr_of_programs + 1); 
+@@ -1036,14 +1098,14 @@
+ static link_t play_Cell(vm_t *vm) {
+   static const link_t play_this = {PlayThis, /* Block in Cell */ 0, 0, 0};
+ 
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: play_Cell: (vm->state).cellN (%i)\n", (vm->state).cellN);
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_Cell: (vm->state).cellN (%i)\n", (vm->state).cellN);
+ #endif
+   
+   assert((vm->state).cellN > 0);
+   if((vm->state).cellN > (vm->state).pgc->nr_of_cells) {
+-#ifdef TRACE
+-    fprintf(MSG_OUT, "libdvdnav: (vm->state).cellN (%i) > pgc->nr_of_cells (%i)\n", 
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: (vm->state).cellN (%i) > pgc->nr_of_cells (%i)\n",
+ 	    (vm->state).cellN, (vm->state).pgc->nr_of_cells );
+ #endif
+     assert((vm->state).cellN == (vm->state).pgc->nr_of_cells + 1); 
+@@ -1071,7 +1133,7 @@
+       if (!((vm->state).cellN <= (vm->state).pgc->nr_of_cells) ||
+           !((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode != 0) ||
+ 	  !((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type == 1)) {
+-	fprintf(MSG_OUT, "libdvdnav: Invalid angle block\n");
++	mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCInvalidAngleBlock);
+ 	(vm->state).cellN -= (vm->state).AGL_REG - 1;
+       }
+ #endif
+@@ -1079,7 +1141,7 @@
+     case 2: /*  ?? */
+     case 3: /*  ?? */
+     default:
+-      fprintf(MSG_OUT, "libdvdnav: Invalid? Cell block_mode (%d), block_type (%d)\n",
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCInvalidBlockMode,
+ 	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode,
+ 	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type);
+       assert(0);
+@@ -1089,7 +1151,7 @@
+   case 3: /*  Last cell in the block */
+   /* These might perhaps happen for RSM or LinkC commands? */
+   default:
+-    fprintf(MSG_OUT, "libdvdnav: Cell is in block but did not enter at first cell!\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCCellIsInBlockButDidNotEnter);
+   }
+   
+   /* Updates (vm->state).pgN and PTTN_REG */
+@@ -1100,8 +1162,8 @@
+   }
+   (vm->state).cell_restart++;
+   (vm->state).blockN = 0;
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: Cell should restart here\n");
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Cell should restart here\n");
+ #endif
+   return play_this;
+ }
+@@ -1109,8 +1171,8 @@
+ static link_t play_Cell_post(vm_t *vm) {
+   cell_playback_t *cell;
+   
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: play_Cell_post: (vm->state).cellN (%i)\n", (vm->state).cellN);
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_Cell_post: (vm->state).cellN (%i)\n", (vm->state).cellN);
+ #endif
+   
+   cell = &(vm->state).pgc->cell_playback[(vm->state).cellN - 1];
+@@ -1132,20 +1194,20 @@
+ 
+     if ((vm->state).pgc->command_tbl != NULL &&
+         (vm->state).pgc->command_tbl->nr_of_cell >= cell->cell_cmd_nr) {
+-#ifdef TRACE
+-      fprintf(MSG_OUT, "libdvdnav: Cell command present, executing\n");
++#ifdef USE_MPDVDNAV_TRACE
++      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Cell command present, executing\n");
+ #endif
+       if(vmEval_CMD(&(vm->state).pgc->command_tbl->cell_cmds[cell->cell_cmd_nr - 1], 1,
+ 		    &(vm->state).registers, &link_values)) {
+         return link_values;
+       } else {
+-#ifdef TRACE
+-        fprintf(MSG_OUT, "libdvdnav: Cell command didn't do a Jump, Link or Call\n");
++#ifdef USE_MPDVDNAV_TRACE
++        if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Cell command didn't do a Jump, Link or Call\n");
+ #endif
+       }
+     } else {
+-#ifdef TRACE
+-      fprintf(MSG_OUT, "libdvdnav: Invalid Cell command\n");
++#ifdef USE_MPDVDNAV_TRACE
++      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Invalid Cell command\n");
+ #endif
+     }
+   }
+@@ -1176,7 +1238,7 @@
+     case 2: /*  ?? */
+     case 3: /*  ?? */
+     default:
+-      fprintf(MSG_OUT, "libdvdnav: Invalid? Cell block_mode (%d), block_type (%d)\n",
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCInvalidBlockMode,
+ 	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode,
+ 	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type);
+       assert(0);
+@@ -1186,8 +1248,8 @@
+   
+   /* Figure out the correct pgN for the new cell */ 
+   if(!set_PGN(vm)) {
+-#ifdef TRACE
+-    fprintf(MSG_OUT, "libdvdnav: last cell in this PGC\n");
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: last cell in this PGC\n");
+ #endif
+     return play_PGC_post(vm);
+   }
+@@ -1201,13 +1263,14 @@
+   
+   while(link_values.command != PlayThis) {
+     
+-#ifdef TRACE
+-    fprintf(MSG_OUT, "libdvdnav: Before printout starts:\n");
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) {
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Before printout starts:\n");
+     vm_print_link(link_values);
+-    fprintf(MSG_OUT, "libdvdnav: Link values %i %i %i %i\n", link_values.command, 
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Link values %i %i %i %i\n", link_values.command,
+ 	    link_values.data1, link_values.data2, link_values.data3);
+     vm_print_current_domain_state(vm);
+-    fprintf(MSG_OUT, "libdvdnav: Before printout ends.\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Before printout ends.\n"); }
+ #endif
+     
+     switch(link_values.command) {
+@@ -1319,7 +1382,7 @@
+ 	
+ 	/* Check and see if there is any rsm info!! */
+ 	if (!(vm->state).rsm_vtsN) {
+-	  fprintf(MSG_OUT, "libdvdnav: trying to resume without any resume info set\n");
++          mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCTryingToResumeWithoutAnyResume);
+ 	  link_values.command = Exit;
+ 	  break;
+ 	}
+@@ -1542,10 +1605,11 @@
+       break;
+     }
+ 
+-#ifdef TRACE
+-    fprintf(MSG_OUT, "libdvdnav: After printout starts:\n");
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) {
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: After printout starts:\n");
+     vm_print_current_domain_state(vm);
+-    fprintf(MSG_OUT, "libdvdnav: After printout ends.\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: After printout ends.\n"); }
+ #endif
+     
+   }
+@@ -1619,8 +1683,8 @@
+   assert(pgcit != NULL);  /* ?? Make this return -1 instead */
+ 
+   if(pgcN < 1 || pgcN > pgcit->nr_of_pgci_srp) {
+-#ifdef TRACE
+-    fprintf(MSG_OUT, "libdvdnav:  ** No such pgcN = %d\n", pgcN);
++#ifdef USE_MPDVDNAV_TRACE
++    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav:  ** No such pgcN = %d\n", pgcN);
+ #endif
+     return 0;
+   }
+@@ -1660,7 +1724,7 @@
+       (vm->state).PTTN_REG = part;
+     } else {
+       /* FIXME: Handle RANDOM or SHUFFLE titles. */
+-      fprintf(MSG_OUT, "libdvdnav: RANDOM or SHUFFLE titles are NOT handled yet.\n");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCRandomOrShuffleTitlesAreNotHandledYet);
+     }
+   }
+   return 1;
+@@ -1718,8 +1782,8 @@
+   /* Relies on state to get the correct pgcit. */
+   pgcit = get_PGCIT(vm);
+   assert(pgcit != NULL);
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: ** Searching for menu (0x%x) entry PGC\n", id);
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ** Searching for menu (0x%x) entry PGC\n", id);
+ #endif
+ 
+   /* Force high bit set. */
+@@ -1729,20 +1793,21 @@
+   for(i = 0; i < pgcit->nr_of_pgci_srp; i++) {
+     if( (pgcit->pgci_srp[i].entry_id) == id) {
+       pgcN = i + 1;
+-#ifdef TRACE
+-      fprintf(MSG_OUT, "libdvdnav: Found menu.\n");
++#ifdef USE_MPDVDNAV_TRACE
++      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Found menu.\n");
+ #endif
+       return pgcN;
+     }
+   }
+-#ifdef TRACE
+-  fprintf(MSG_OUT, "libdvdnav: ** No such id/menu (0x%02x) entry PGC\n", id & 0x7f);
++#ifdef USE_MPDVDNAV_TRACE
++  if (dvdnav_trace) {
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ** No such id/menu (0x%02x) entry PGC\n", id & 0x7f);
+   for(i = 0; i < pgcit->nr_of_pgci_srp; i++) {
+     if ( (pgcit->pgci_srp[i].entry_id & 0x80) == 0x80) {
+-      fprintf(MSG_OUT, "libdvdnav: Available menus: 0x%x\n",
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Available menus: 0x%x\n",
+                      pgcit->pgci_srp[i].entry_id & 0x7f);
+     }
+-  }
++  } }
+ #endif
+   return 0; /*  error */
+ }
+@@ -1763,7 +1828,7 @@
+       pgcN++;
+     }
+   }
+-  fprintf(MSG_OUT, "libdvdnav: get_PGCN failed. Was trying to find pgcN in domain %d\n", 
++  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCGetPGCNFailed,
+          (vm->state).domain);
+   return 0; /*  error */
+ }
+@@ -1772,7 +1837,7 @@
+   int i;
+   
+   if(h == NULL || h->pgci_ut == NULL) {
+-    fprintf(MSG_OUT, "libdvdnav: *** pgci_ut handle is NULL ***\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCPgciUtHandleIsNULL);
+     return NULL; /*  error? */
+   }
+   
+@@ -1781,17 +1846,17 @@
+ 	&& h->pgci_ut->lu[i].lang_code != lang)
+     i++;
+   if(i == h->pgci_ut->nr_of_lus) {
+-    fprintf(MSG_OUT, "libdvdnav: Language '%c%c' not found, using '%c%c' instead\n",
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCLanguageNotFound,
+ 	    (char)(lang >> 8), (char)(lang & 0xff),
+  	    (char)(h->pgci_ut->lu[0].lang_code >> 8),
+ 	    (char)(h->pgci_ut->lu[0].lang_code & 0xff));
+-    fprintf(MSG_OUT, "libdvdnav: Menu Languages available: ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCMenuLanguagesAvailable);
+     for(i = 0; i < h->pgci_ut->nr_of_lus; i++) {
+-      fprintf(MSG_OUT, "%c%c ",
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c%c ",
+  	    (char)(h->pgci_ut->lu[i].lang_code >> 8),
+ 	    (char)(h->pgci_ut->lu[i].lang_code & 0xff));
+     }
+-    fprintf(MSG_OUT, "\n");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+     i = 0; /*  error? */
+   }
+   
+@@ -1823,9 +1888,9 @@
+ 
+ /* Debug functions */
+ 
+-#ifdef TRACE
++#ifdef USE_MPDVDNAV_TRACE
+ void vm_position_print(vm_t *vm, vm_position_t *position) {
+-  fprintf(MSG_OUT, "libdvdnav: But=%x Spu=%x Aud=%x Ang=%x Hop=%x vts=%x dom=%x cell=%x cell_restart=%x cell_start=%x still=%x block=%x\n",
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: But=%x Spu=%x Aud=%x Ang=%x Hop=%x vts=%x dom=%x cell=%x cell_restart=%x cell_start=%x still=%x block=%x\n",
+   position->button,
+   position->spu_channel,
+   position->audio_channel,
+@@ -1841,3 +1906,16 @@
+ }
+ #endif
+ 
++#ifdef USE_MPDVDNAV
++void vm_play_pgc(vm_t *vm)
++{
++  process_command(vm, play_PGC(vm));
++}
++
++void vm_play_cell(vm_t *vm)
++{
++  play_Cell(vm);
++}
++
++int vm_get_PGCN(vm_t *vm) { return get_PGCN(vm); }
++#endif
+--- vm/vm.h	2004-01-11 22:43:13.000000000 +0100
++++ vm.h	2006-04-05 16:03:10.000000000 +0200
+@@ -90,6 +90,10 @@
+   char          dvd_name[50];
+   remap_t      *map;
+   int           stopped;
++#ifdef USE_MPDVDNAV
++  int 	   	pgc_post_flag;
++  int		auto_action_mode;
++#endif
+ } vm_t;
+ 
+ /* magic number for seeking hops */
+@@ -172,10 +176,19 @@
+ audio_attr_t vm_get_audio_attr(vm_t *vm, int streamN);
+ subp_attr_t  vm_get_subp_attr(vm_t *vm, int streamN);
+ 
+-#ifdef TRACE
++#ifdef USE_MPDVDNAV
++void vm_play_pgc(vm_t *vm);
++void vm_play_cell(vm_t *vm);
++#endif
++
++#ifdef USE_MPDVDNAV_TRACE
+ /* Debug */
+ void vm_position_print(vm_t *vm, vm_position_t *position);
+ #endif
+ 
++#ifdef USE_MPDVDNAV
++int vm_get_PGCN(vm_t *vm);
++#endif
++
+ 
+ #endif /* VM_HV_INCLUDED */
+--- vm/vmcmd.c	2004-03-03 17:50:42.000000000 +0100
++++ vmcmd.c	2006-04-05 16:03:10.000000000 +0200
+@@ -23,9 +23,13 @@
+  *
+  */
+ 
++#ifndef HAVE_MPLAYER
+ #ifdef HAVE_CONFIG_H
+ #include "config.h"
+ #endif
++#else
++#include "config.h"
++#endif
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+@@ -33,6 +37,12 @@
+ 
+ #include "dvdnav_internal.h"
+ 
++#ifdef USE_MPDVDNAV
++#include "../mp_msg.h"
++#include "../help_mp.h"
++#endif
++
++
+ /*  freebsd compatibility */
+ #ifndef PRIu8
+ #define PRIu8 "d"
+@@ -114,16 +124,16 @@
+ 
+ static void print_system_reg(uint16_t reg) {
+   if(reg < sizeof(system_reg_abbr_table) / sizeof(char *))
+-    fprintf(MSG_OUT, "%s (SRPM:%d)", system_reg_table[reg], reg);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%s (SRPM:%d)", system_reg_table[reg], reg);
+   else
+-    fprintf(MSG_OUT, " WARNING: Unknown system register ( reg=%d ) ", reg);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown system register ( reg=%d ) ", reg);
+ }
+ 
+ static void print_g_reg(uint8_t reg) {
+     if(reg < 16)
+-      fprintf(MSG_OUT, "g[%" PRIu8 "]", reg);
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "g[%" PRIu8 "]", reg);
+     else
+-      fprintf(MSG_OUT, " WARNING: Unknown general register ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown general register ");
+ }
+ 
+ static void print_reg(uint8_t reg) {
+@@ -135,25 +145,25 @@
+ 
+ static void print_cmp_op(uint8_t op) {
+   if(op < sizeof(cmp_op_table) / sizeof(char *) && cmp_op_table[op] != NULL)
+-    fprintf(MSG_OUT, " %s ", cmp_op_table[op]);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %s ", cmp_op_table[op]);
+   else
+-    fprintf(MSG_OUT, " WARNING: Unknown compare op ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown compare op ");
+ }
+ 
+ static void print_set_op(uint8_t op) {
+   if(op < sizeof(set_op_table) / sizeof(char *) && set_op_table[op] != NULL)
+-    fprintf(MSG_OUT, " %s ", set_op_table[op]);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %s ", set_op_table[op]);
+   else
+-    fprintf(MSG_OUT, " WARNING: Unknown set op ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown set op ");
+ }
+ 
+ static void print_reg_or_data(command_t* command, int immediate, int start) {
+   if(immediate) {
+     uint32_t i = vm_getbits(command, start, 16);
+     
+-    fprintf(MSG_OUT, "0x%x", i);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "0x%x", i);
+     if(isprint(i & 0xff) && isprint((i>>8) & 0xff))
+-      fprintf(MSG_OUT, " (\"%c%c\")", (char)((i>>8) & 0xff), (char)(i & 0xff));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " (\"%c%c\")", (char)((i>>8) & 0xff), (char)(i & 0xff));
+   } else {
+     print_reg(vm_getbits(command, start - 8, 8));
+   }
+@@ -161,18 +171,18 @@
+ 
+ static void print_reg_or_data_2(command_t* command, int immediate, int start) {
+   if(immediate)
+-    fprintf(MSG_OUT, "0x%x", vm_getbits(command, start - 1, 7));
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "0x%x", vm_getbits(command, start - 1, 7));
+   else
+-    fprintf(MSG_OUT, "g[%" PRIu8 "]", vm_getbits(command, start - 4, 4));
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "g[%" PRIu8 "]", vm_getbits(command, start - 4, 4));
+ }
+ 
+ static void print_reg_or_data_3(command_t* command, int immediate, int start) {
+   if(immediate) {
+     uint32_t i = vm_getbits(command, start, 16);
+     
+-    fprintf(MSG_OUT, "0x%x", i);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "0x%x", i);
+     if(isprint(i & 0xff) && isprint((i>>8) & 0xff))
+-      fprintf(MSG_OUT, " (\"%c%c\")", (char)((i>>8) & 0xff), (char)(i & 0xff));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " (\"%c%c\")", (char)((i>>8) & 0xff), (char)(i & 0xff));
+   } else {
+     print_reg(vm_getbits(command, start, 8));
+   }
+@@ -183,11 +193,11 @@
+   uint8_t op = vm_getbits(command, 54, 3);
+   
+   if(op) {
+-    fprintf(MSG_OUT, "if (");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+     print_g_reg(vm_getbits(command,39,8));
+     print_cmp_op(op);
+     print_reg_or_data(command, vm_getbits(command, 55,1), 31);
+-    fprintf(MSG_OUT, ") ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+   }
+ }
+ 
+@@ -195,11 +205,11 @@
+   uint8_t op = vm_getbits(command, 54, 3);
+   
+   if(op) {
+-    fprintf(MSG_OUT, "if (");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+     print_reg(vm_getbits(command, 15, 8));
+     print_cmp_op(op);
+     print_reg(vm_getbits(command, 7, 8));
+-    fprintf(MSG_OUT, ") ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+   }
+ }
+ 
+@@ -207,11 +217,11 @@
+   uint8_t op = vm_getbits(command, 54, 3);
+   
+   if(op) {
+-    fprintf(MSG_OUT, "if (");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+     print_g_reg(vm_getbits(command, 43, 4));
+     print_cmp_op(op);
+     print_reg_or_data(command, vm_getbits(command, 55, 1), 15);
+-    fprintf(MSG_OUT, ") ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+   }
+ }
+ 
+@@ -219,11 +229,11 @@
+   uint8_t op = vm_getbits(command, 54, 3);
+ 
+   if(op) {
+-    fprintf(MSG_OUT, "if (");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+     print_g_reg(vm_getbits(command, 51, 4));
+     print_cmp_op(op);
+     print_reg_or_data(command, vm_getbits(command, 55, 1), 31);
+-    fprintf(MSG_OUT, ") ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+   }
+ }
+ 
+@@ -233,17 +243,17 @@
+   
+   if(op) {
+     if (set_immediate) {
+-      fprintf(MSG_OUT, "if (");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+       print_g_reg(vm_getbits(command, 31, 8));
+       print_cmp_op(op);
+       print_reg(vm_getbits(command, 23, 8));
+-      fprintf(MSG_OUT, ") ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+     } else {
+-      fprintf(MSG_OUT, "if (");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+       print_g_reg(vm_getbits(command, 39, 8));
+       print_cmp_op(op);
+       print_reg_or_data(command, vm_getbits(command, 55, 1), 31);
+-      fprintf(MSG_OUT, ") ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+     }
+   }
+ }
+@@ -253,20 +263,20 @@
+   
+   switch(op) {
+     case 0: /*  NOP */
+-      fprintf(MSG_OUT, "Nop");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Nop");
+       break;
+     case 1: /*  Goto line */
+-      fprintf(MSG_OUT, "Goto %" PRIu8, vm_getbits(command, 7, 8));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Goto %" PRIu8, vm_getbits(command, 7, 8));
+       break;
+     case 2: /*  Break */
+-      fprintf(MSG_OUT, "Break");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Break");
+       break;
+     case 3: /*  Parental level */
+-      fprintf(MSG_OUT, "SetTmpPML %" PRIu8 ", Goto %" PRIu8, 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "SetTmpPML %" PRIu8 ", Goto %" PRIu8,
+ 	      vm_getbits(command, 11, 4), vm_getbits(command, 7, 8));
+       break;
+     default:
+-      fprintf(MSG_OUT, "WARNING: Unknown special instruction (%i)", 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown special instruction (%i)",
+ 	      vm_getbits(command, 51, 4));
+   }
+ }
+@@ -276,99 +286,99 @@
+   uint32_t button = vm_getbits(command, 15, 6);
+   
+   if(linkop < sizeof(link_table)/sizeof(char *) && link_table[linkop] != NULL)
+-    fprintf(MSG_OUT, "%s (button %" PRIu8 ")", link_table[linkop], button);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%s (button %" PRIu8 ")", link_table[linkop], button);
+   else
+-    fprintf(MSG_OUT, "WARNING: Unknown linksub instruction (%i)", linkop);
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown linksub instruction (%i)", linkop);
+ }
+ 
+ static void print_link_instruction(command_t* command, int optional) {
+   uint8_t op = vm_getbits(command, 51, 4);
+   
+   if(optional && op)
+-    fprintf(MSG_OUT, ", ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, ", ");
+   
+   switch(op) {
+     case 0:
+       if(!optional)
+-      fprintf(MSG_OUT, "WARNING: NOP (link)!");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: NOP (link)!");
+       break;
+     case 1:
+       print_linksub_instruction(command);
+       break;
+     case 4:
+-      fprintf(MSG_OUT, "LinkPGCN %" PRIu16, vm_getbits(command, 14, 15));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkPGCN %" PRIu16, vm_getbits(command, 14, 15));
+       break;
+     case 5:
+-      fprintf(MSG_OUT, "LinkPTT %" PRIu16 " (button %" PRIu8 ")", 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkPTT %" PRIu16 " (button %" PRIu8 ")",
+ 	      vm_getbits(command, 9, 10), vm_getbits(command, 15, 6));
+       break;
+     case 6:
+-      fprintf(MSG_OUT, "LinkPGN %" PRIu8 " (button %" PRIu8 ")", 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkPGN %" PRIu8 " (button %" PRIu8 ")",
+ 	      vm_getbits(command, 6, 7), vm_getbits(command, 15, 6));
+       break;
+     case 7:
+-      fprintf(MSG_OUT, "LinkCN %" PRIu8 " (button %" PRIu8 ")", 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkCN %" PRIu8 " (button %" PRIu8 ")",
+ 	      vm_getbits(command, 7, 8), vm_getbits(command, 15, 6));
+       break;
+     default:
+-      fprintf(MSG_OUT, "WARNING: Unknown link instruction");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown link instruction");
+   }
+ }
+ 
+ static void print_jump_instruction(command_t* command) {
+   switch(vm_getbits(command, 51, 4)) {
+     case 1:
+-      fprintf(MSG_OUT, "Exit");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Exit");
+       break;
+     case 2:
+-      fprintf(MSG_OUT, "JumpTT %" PRIu8, vm_getbits(command, 22, 7));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpTT %" PRIu8, vm_getbits(command, 22, 7));
+       break;
+     case 3:
+-      fprintf(MSG_OUT, "JumpVTS_TT %" PRIu8, vm_getbits(command, 22, 7));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpVTS_TT %" PRIu8, vm_getbits(command, 22, 7));
+       break;
+     case 5:
+-      fprintf(MSG_OUT, "JumpVTS_PTT %" PRIu8 ":%" PRIu16, 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpVTS_PTT %" PRIu8 ":%" PRIu16,
+ 	      vm_getbits(command, 22, 7), vm_getbits(command, 41, 10));
+       break;
+     case 6:
+       switch(vm_getbits(command, 23, 2)) {
+         case 0:
+-          fprintf(MSG_OUT, "JumpSS FP");
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS FP");
+           break;
+         case 1:
+-          fprintf(MSG_OUT, "JumpSS VMGM (menu %" PRIu8 ")", vm_getbits(command, 19, 4));
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS VMGM (menu %" PRIu8 ")", vm_getbits(command, 19, 4));
+           break;
+         case 2:
+-          fprintf(MSG_OUT, "JumpSS VTSM (vts %" PRIu8 ", title %" PRIu8 
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS VTSM (vts %" PRIu8 ", title %" PRIu8
+ 		  ", menu %" PRIu8 ")", vm_getbits(command, 30, 7), vm_getbits(command, 38, 7), vm_getbits(command, 19, 4));
+           break;
+         case 3:
+-          fprintf(MSG_OUT, "JumpSS VMGM (pgc %" PRIu8 ")", vm_getbits(command, 46, 15));
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS VMGM (pgc %" PRIu8 ")", vm_getbits(command, 46, 15));
+           break;
+         }
+       break;
+     case 8:
+       switch(vm_getbits(command, 23, 2)) {
+         case 0:
+-          fprintf(MSG_OUT, "CallSS FP (rsm_cell %" PRIu8 ")",
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS FP (rsm_cell %" PRIu8 ")",
+               vm_getbits(command, 31, 8));
+           break;
+         case 1:
+-          fprintf(MSG_OUT, "CallSS VMGM (menu %" PRIu8 
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS VMGM (menu %" PRIu8
+ 		  ", rsm_cell %" PRIu8 ")", vm_getbits(command, 19, 4), vm_getbits(command, 31, 8));
+           break;
+         case 2:
+-          fprintf(MSG_OUT, "CallSS VTSM (menu %" PRIu8 
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS VTSM (menu %" PRIu8
+ 		  ", rsm_cell %" PRIu8 ")", vm_getbits(command, 19, 4), vm_getbits(command, 31, 8));
+           break;
+         case 3:
+-          fprintf(MSG_OUT, "CallSS VMGM (pgc %" PRIu8 ", rsm_cell %" PRIu8 ")", 
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS VMGM (pgc %" PRIu8 ", rsm_cell %" PRIu8 ")",
+ 		  vm_getbits(command, 46, 15), vm_getbits(command, 31, 8));
+           break;
+       }
+       break;
+     default:
+-      fprintf(MSG_OUT, "WARNING: Unknown Jump/Call instruction");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown Jump/Call instruction");
+   }
+ }
+ 
+@@ -382,26 +392,26 @@
+       for(i = 1; i <= 3; i++) {
+         if(vm_getbits(command, 47 - (i*8), 1)) {
+           print_system_reg(i);
+-          fprintf(MSG_OUT, " = ");
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, " = ");
+           print_reg_or_data_2(command, vm_getbits(command, 60, 1), 47 - (i*8) );
+-          fprintf(MSG_OUT, " ");
++          mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+         }
+       }
+       break;
+     case 2: /*  Set system reg 9 & 10 (Navigation timer, Title PGC number) */
+       print_system_reg(9);
+-      fprintf(MSG_OUT, " = ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " = ");
+       print_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+-      fprintf(MSG_OUT, " ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+       print_system_reg(10);
+-      fprintf(MSG_OUT, " = %" PRIu16, vm_getbits(command, 30, 15)); /*  ?? */
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " = %" PRIu16, vm_getbits(command, 30, 15)); /*  ?? */
+       break;
+     case 3: /*  Mode: Counter / Register + Set */
+-      fprintf(MSG_OUT, "SetMode ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "SetMode ");
+       if(vm_getbits(command, 23, 1))
+-	fprintf(MSG_OUT, "Counter ");
++	mp_msg(MSGT_CPLAYER,MSGL_INFO, "Counter ");
+       else
+-	fprintf(MSG_OUT, "Register ");
++	mp_msg(MSGT_CPLAYER,MSGL_INFO, "Register ");
+       print_g_reg(vm_getbits(command, 19, 4));
+       print_set_op(0x1); /*  '=' */
+       print_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+@@ -409,12 +419,12 @@
+     case 6: /*  Set system reg 8 (Highlighted button) */
+       print_system_reg(8);
+       if(vm_getbits(command, 60, 1)) /*  immediate */
+-        fprintf(MSG_OUT, " = 0x%x (button no %d)", vm_getbits(command, 31, 16), vm_getbits(command, 31, 6));
++        mp_msg(MSGT_CPLAYER,MSGL_INFO, " = 0x%x (button no %d)", vm_getbits(command, 31, 16), vm_getbits(command, 31, 6));
+       else
+-        fprintf(MSG_OUT, " = g[%" PRIu8 "]", vm_getbits(command, 19, 4));
++        mp_msg(MSGT_CPLAYER,MSGL_INFO, " = g[%" PRIu8 "]", vm_getbits(command, 19, 4));
+       break;
+     default:
+-      fprintf(MSG_OUT, "WARNING: Unknown system set instruction (%i)", 
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown system set instruction (%i)",
+ 	      vm_getbits(command, 59, 4));
+   }
+ }
+@@ -427,7 +437,7 @@
+     print_set_op(set_op);
+     print_reg_or_data(command, vm_getbits(command, 60, 1), 31);
+   } else {
+-    fprintf(MSG_OUT, "NOP");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "NOP");
+   }
+ }
+ 
+@@ -439,7 +449,7 @@
+     print_set_op(set_op);
+     print_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+   } else {
+-    fprintf(MSG_OUT, "NOP");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "NOP");
+   }
+ }
+ 
+@@ -451,7 +461,7 @@
+     print_set_op(set_op);
+     print_reg_or_data_3(command, vm_getbits(command, 60, 1), 47);
+   } else {
+-    fprintf(MSG_OUT, "NOP");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "NOP");
+   }
+ }
+ 
+@@ -494,46 +504,46 @@
+       break;
+     case 4: /*  Set, Compare -> LinkSub instructions */
+       print_set_version_2(&command);
+-      fprintf(MSG_OUT, ", ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, ", ");
+       print_if_version_4(&command);
+       print_linksub_instruction(&command);
+       break;
+     case 5: /*  Compare -> (Set and LinkSub) instructions */
+       print_if_version_5(&command);
+-      fprintf(MSG_OUT, "{ ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "{ ");
+       print_set_version_3(&command);
+-      fprintf(MSG_OUT, ", ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, ", ");
+       print_linksub_instruction(&command);
+-      fprintf(MSG_OUT, " }");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " }");
+       break;
+     case 6: /*  Compare -> Set, always LinkSub instructions */
+       print_if_version_5(&command);
+-      fprintf(MSG_OUT, "{ ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "{ ");
+       print_set_version_3(&command);
+-      fprintf(MSG_OUT, " } ");
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, " } ");
+       print_linksub_instruction(&command);
+       break;
+     default:
+-      fprintf(MSG_OUT, "WARNING: Unknown instruction type (%i)", vm_getbits(&command, 63, 3));
++      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown instruction type (%i)", vm_getbits(&command, 63, 3));
+   }
+   /*  Check if there still are bits set that were not examined */
+   
+   if(command.instruction & ~ command.examined) {
+-    fprintf(MSG_OUT, " libdvdnav: vmcmd.c: [WARNING, unknown bits:");
+-    fprintf(MSG_OUT, " %08llx", (command.instruction & ~ command.examined) );
+-    fprintf(MSG_OUT, "]");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " libdvdnav: vmcmd.c: [WARNING, unknown bits:");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %08llx", (command.instruction & ~ command.examined) );
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "]");
+   }
+ }
+ 
+ void vm_print_cmd(int row, vm_cmd_t *vm_command) {
+   int i;
+ 
+-  fprintf(MSG_OUT, "(%03d) ", row + 1);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "(%03d) ", row + 1);
+   for(i = 0; i < 8; i++)
+-    fprintf(MSG_OUT, "%02x ", vm_command->bytes[i]);
+-  fprintf(MSG_OUT, "| ");
++    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%02x ", vm_command->bytes[i]);
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "| ");
+ 
+   vm_print_mnemonic(vm_command);
+-  fprintf(MSG_OUT, "\n");
++  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+ }
+ 
diff -r 448a43f59a37 libmpdvdnav/navigation.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/navigation.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: navigation.c,v 1.21 2004/01/07 19:34:28 mroi Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include "dvdnav_internal.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+/* Navigation API calls */
+
+dvdnav_status_t dvdnav_still_skip(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->position_current.still = 0;
+  this->skip_still = 1;
+  this->sync_wait = 0;
+  this->sync_wait_skip = 1;
+
+  return DVDNAV_STATUS_OK;
+}
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_still_back(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->position_current.still = 0;
+  this->skip_still = 0;
+  this->sync_wait = 0;
+  this->sync_wait_skip = 1;
+
+  pthread_mutex_lock(&this->vm_lock);
+  vm_play_cell(this->vm);
+//  vm_play_pgc(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_wait_back(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->position_current.still = 0;
+  this->skip_still = 0;
+  this->sync_wait = 0;
+  this->sync_wait_skip = 0;
+
+  pthread_mutex_lock(&this->vm_lock);
+  vm_play_cell(this->vm);
+//  vm_play_pgc(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_wait_still_clear(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->position_current.still = 0;
+  this->skip_still = 0;
+  this->sync_wait = 0;
+  this->sync_wait_skip = 0;
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_is_still_cell(dvdnav_t *this, int *flag)
+{
+  if(!this || !flag) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  *flag=this->position_current.still;
+  return DVDNAV_STATUS_OK;
+}
+#endif
+
+dvdnav_status_t dvdnav_wait_skip(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->sync_wait = 0;
+  this->sync_wait_skip = 1;
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_number_of_titles(dvdnav_t *this, int32_t *titles) {
+  if(!this || !titles) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!this->started) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_VirtualDVDMachineNotStarted);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*titles) = vm_get_vmgi(this->vm)->tt_srpt->nr_of_srpts;
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_number_of_parts(dvdnav_t *this, int32_t title, int32_t *parts) {
+  if(!this || !parts) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!this->started) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_VirtualDVDMachineNotStarted);
+    return DVDNAV_STATUS_ERR;
+  }
+  if ((title < 1) || (title > vm_get_vmgi(this->vm)->tt_srpt->nr_of_srpts) ) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedATitleNumberOutOfRange);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*parts) = vm_get_vmgi(this->vm)->tt_srpt->title[title-1].nr_of_ptts;
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_current_title_info(dvdnav_t *this, int32_t *title, int32_t *part) {
+  int32_t retval;
+
+  if(!this || !title || !part) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->vtsi || !this->vm->vmgi) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_BadVMState);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  if (!this->vm->state.pgc) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  if ( (this->vm->state.domain == VTSM_DOMAIN)
+      || (this->vm->state.domain == VMGM_DOMAIN) ) {
+    /* Get current Menu ID: into *part. */
+    vm_get_current_menu(this->vm, part);
+    if (*part > -1) {
+      *title = 0;
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_OK;
+    }
+  }
+  if (this->vm->state.domain == VTS_DOMAIN) {
+    retval = vm_get_current_title_part(this->vm, title, part);
+    pthread_mutex_unlock(&this->vm_lock);
+    return retval ? DVDNAV_STATUS_OK : DVDNAV_STATUS_ERR;
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotInATitleOrMenu);
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_title_play(dvdnav_t *this, int32_t title) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  return dvdnav_part_play(this, title, 1);
+}
+
+dvdnav_status_t dvdnav_part_play(dvdnav_t *this, int32_t title, int32_t part) {
+  int32_t retval;
+
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if (!this->vm->vmgi) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_BadVMState);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  if (!this->vm->state.pgc) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  if((title < 1) || (title > this->vm->vmgi->tt_srpt->nr_of_srpts)) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_TitleOutOfRange);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  if((part < 1) || (part > this->vm->vmgi->tt_srpt->title[title-1].nr_of_ptts)) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PartOutOfRange);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  retval = vm_jump_title_part(this->vm, title, part);
+  if (retval)
+    this->vm->hop_channel++;
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return retval ? DVDNAV_STATUS_OK : DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_part_play_auto_stop(dvdnav_t *this, int32_t title,
+					   int32_t part, int32_t parts_to_play) {
+  /* FIXME: Implement auto-stop */
+ if (dvdnav_part_play(this, title, part) == DVDNAV_STATUS_OK)
+   mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotImplementedYet);
+ return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_time_play(dvdnav_t *this, int32_t title,
+				 uint64_t time) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* FIXME: Implement */
+   mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_NotImplementedYet);
+  return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_stop(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  this->vm->stopped = 1;
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_go_up(dvdnav_t *this) {
+  if(!this) {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_LIBMPDVDNAV_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* A nice easy function... delegate to the VM */
+  pthread_mutex_lock(&this->vm_lock);
+  vm_jump_up(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
diff -r 448a43f59a37 libmpdvdnav/read_cache.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/read_cache.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *               2001-2004 the dvdnav project
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: read_cache.c,v 1.30 2004/03/03 16:48:36 mroi Exp $
+ *
+ */
+/*
+ * There was a multithreaded read ahead cache in here for some time, but
+ * it had only been used for a short time. If you want to have a look at it,
+ * search the CVS attic.
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include "dvdnav.h"
+#include "dvdnav_internal.h"
+#include "read_cache.h"
+#include <sys/time.h>
+#include <time.h>
+
+#define READ_CACHE_CHUNKS 10
+
+/* all cache chunks must be memory aligned to allow use of raw devices */
+#define ALIGNMENT 2048
+
+#define READ_AHEAD_SIZE_MIN 4
+#define READ_AHEAD_SIZE_MAX 512
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+typedef struct read_cache_chunk_s {
+  uint8_t     *cache_buffer;
+  uint8_t     *cache_buffer_base;  /* used in malloc and free for alignment */
+  int32_t      cache_start_sector; /* -1 means cache invalid */
+  int32_t      cache_read_count;   /* this many sectors are already read */
+  size_t       cache_block_count;  /* this many sectors will go in this chunk */
+  size_t       cache_malloc_size;
+  int          cache_valid;
+  int          usage_count;  /* counts how many buffers where issued from this chunk */
+} read_cache_chunk_t;
+
+struct read_cache_s {
+  read_cache_chunk_t  chunk[READ_CACHE_CHUNKS];
+  int                 current;
+  int                 freeing;  /* is set to one when we are about to dispose the cache */
+  uint32_t            read_ahead_size;
+  int                 read_ahead_incr;
+  int                 last_sector;
+  pthread_mutex_t     lock;
+
+  /* Bit of strange cross-linking going on here :) -- Gotta love C :) */
+  dvdnav_t           *dvd_self;
+};
+
+/*
+#define READ_CACHE_TRACE 0
+*/
+
+read_cache_t *dvdnav_read_cache_new(dvdnav_t* dvd_self) {
+  read_cache_t *self;
+  int i;
+
+  self = (read_cache_t *)malloc(sizeof(read_cache_t));
+
+  if(self) {
+    self->current = 0;
+    self->freeing = 0;
+    self->dvd_self = dvd_self;
+    self->last_sector = 0;
+    self->read_ahead_size = READ_AHEAD_SIZE_MIN;
+    self->read_ahead_incr = 0;
+    pthread_mutex_init(&self->lock, NULL);
+    dvdnav_read_cache_clear(self);
+    for (i = 0; i < READ_CACHE_CHUNKS; i++) {
+      self->chunk[i].cache_buffer = NULL;
+      self->chunk[i].usage_count = 0;
+    }
+  }
+
+  return self;
+}
+
+void dvdnav_read_cache_free(read_cache_t* self) {
+  dvdnav_t *tmp;
+  int i;
+
+  pthread_mutex_lock(&self->lock);
+  self->freeing = 1;
+  for (i = 0; i < READ_CACHE_CHUNKS; i++)
+    if (self->chunk[i].cache_buffer && self->chunk[i].usage_count == 0) {
+      free(self->chunk[i].cache_buffer_base);
+      self->chunk[i].cache_buffer = NULL;
+    }
+  pthread_mutex_unlock(&self->lock);
+
+  for (i = 0; i < READ_CACHE_CHUNKS; i++)
+    if (self->chunk[i].cache_buffer) return;
+
+  /* all buffers returned, free everything */
+  tmp = self->dvd_self;
+  pthread_mutex_destroy(&self->lock);
+  free(self);
+  free(tmp);
+}
+
+/* This function MUST be called whenever self->file changes. */
+void dvdnav_read_cache_clear(read_cache_t *self) {
+  int i;
+
+  if(!self)
+   return;
+
+  pthread_mutex_lock(&self->lock);
+  for (i = 0; i < READ_CACHE_CHUNKS; i++)
+    self->chunk[i].cache_valid = 0;
+  pthread_mutex_unlock(&self->lock);
+}
+
+/* This function is called just after reading the NAV packet. */
+void dvdnav_pre_cache_blocks(read_cache_t *self, int sector, size_t block_count) {
+  int i, use;
+
+  if(!self)
+    return;
+
+  if(!self->dvd_self->use_read_ahead)
+    return;
+
+  pthread_mutex_lock(&self->lock);
+
+  /* find a free cache chunk that best fits the required size */
+  use = -1;
+  for (i = 0; i < READ_CACHE_CHUNKS; i++)
+    if (self->chunk[i].usage_count == 0 && self->chunk[i].cache_buffer &&
+        self->chunk[i].cache_malloc_size >= block_count &&
+        (use == -1 || self->chunk[use].cache_malloc_size > self->chunk[i].cache_malloc_size))
+      use = i;
+
+  if (use == -1) {
+    /* we haven't found a cache chunk, so we try to reallocate an existing one */
+    for (i = 0; i < READ_CACHE_CHUNKS; i++)
+      if (self->chunk[i].usage_count == 0 && self->chunk[i].cache_buffer &&
+          (use == -1 || self->chunk[use].cache_malloc_size < self->chunk[i].cache_malloc_size))
+        use = i;
+    if (use >= 0) {
+      self->chunk[use].cache_buffer_base = realloc(self->chunk[use].cache_buffer_base,
+        block_count * DVD_VIDEO_LB_LEN + ALIGNMENT);
+      self->chunk[use].cache_buffer =
+        (uint8_t *)(((uintptr_t)self->chunk[use].cache_buffer_base & ~((uintptr_t)(ALIGNMENT - 1))) + ALIGNMENT);
+      mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_PreCacheDVDReadReallocHappened);
+      self->chunk[use].cache_malloc_size = block_count;
+    } else {
+      /* we still haven't found a cache chunk, let's allocate a new one */
+      for (i = 0; i < READ_CACHE_CHUNKS; i++)
+        if (!self->chunk[i].cache_buffer) {
+	  use = i;
+	  break;
+	}
+      if (use >= 0) {
+        /* We start with a sensible figure for the first malloc of 500 blocks.
+         * Some DVDs I have seen venture to 450 blocks.
+         * This is so that fewer realloc's happen if at all.
+         */
+	self->chunk[i].cache_buffer_base =
+	  malloc((block_count > 500 ? block_count : 500) * DVD_VIDEO_LB_LEN + ALIGNMENT);
+	self->chunk[i].cache_buffer =
+	  (uint8_t *)(((uintptr_t)self->chunk[i].cache_buffer_base & ~((uintptr_t)(ALIGNMENT - 1))) + ALIGNMENT);
+	self->chunk[i].cache_malloc_size = block_count > 500 ? block_count : 500;
+      mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_PreCacheDVDReadMalloc,
+	  (block_count > 500 ? block_count : 500 ));
+      }
+    }
+  }
+
+  if (use >= 0) {
+    self->chunk[use].cache_start_sector = sector;
+    self->chunk[use].cache_block_count = block_count;
+    self->chunk[use].cache_read_count = 0;
+    self->chunk[use].cache_valid = 1;
+    self->current = use;
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_PreCachingWasImpossible);
+  }
+  pthread_mutex_unlock(&self->lock);
+}
+
+int dvdnav_read_cache_block(read_cache_t *self, int sector, size_t block_count, uint8_t **buf) {
+  int i, use;
+  int start;
+  int size;
+  int incr;
+  uint8_t *read_ahead_buf;
+  int32_t res;
+
+  if(!self)
+    return 0;
+
+  use = -1;
+
+  if(self->dvd_self->use_read_ahead) {
+    /* first check, if sector is in current chunk */
+    read_cache_chunk_t cur = self->chunk[self->current];
+    if (cur.cache_valid && sector >= cur.cache_start_sector &&
+        sector <= (cur.cache_start_sector + cur.cache_read_count) &&
+        sector + block_count <= cur.cache_start_sector + cur.cache_block_count)
+      use = self->current;
+    else
+      for (i = 0; i < READ_CACHE_CHUNKS; i++)
+        if (self->chunk[i].cache_valid &&
+            sector >= self->chunk[i].cache_start_sector &&
+            sector <= (self->chunk[i].cache_start_sector + self->chunk[i].cache_read_count) &&
+            sector + block_count <= self->chunk[i].cache_start_sector + self->chunk[i].cache_block_count)
+            use = i;
+  }
+
+  if (use >= 0) {
+    read_cache_chunk_t *chunk;
+
+    /* Increment read-ahead size if sector follows the last sector */
+    if (sector == (self->last_sector + 1)) {
+      if (self->read_ahead_incr < READ_AHEAD_SIZE_MAX)
+        self->read_ahead_incr++;
+    } else {
+      self->read_ahead_size = READ_AHEAD_SIZE_MIN;
+      self->read_ahead_incr = 0;
+    }
+    self->last_sector = sector;
+
+    /* The following resources need to be protected by a mutex :
+     *   self->chunk[*].cache_buffer
+     *   self->chunk[*].cache_malloc_size
+     *   self->chunk[*].usage_count
+     */
+    pthread_mutex_lock(&self->lock);
+    chunk = &self->chunk[use];
+    read_ahead_buf = chunk->cache_buffer + chunk->cache_read_count * DVD_VIDEO_LB_LEN;
+    *buf = chunk->cache_buffer + (sector - chunk->cache_start_sector) * DVD_VIDEO_LB_LEN;
+    chunk->usage_count++;
+    pthread_mutex_unlock(&self->lock);
+
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_ReadCacheSectorInfo, sector, chunk->cache_start_sector, chunk->cache_start_sector + chunk->cache_block_count);
+
+    /* read_ahead_size */
+    incr = self->read_ahead_incr >> 1;
+    if ((self->read_ahead_size + incr) > READ_AHEAD_SIZE_MAX) {
+      self->read_ahead_size = READ_AHEAD_SIZE_MAX;
+    } else {
+      self->read_ahead_size += incr;
+    }
+
+    /* real read size */
+    start = chunk->cache_start_sector + chunk->cache_read_count;
+    if (chunk->cache_read_count + self->read_ahead_size > chunk->cache_block_count) {
+      size = chunk->cache_block_count - chunk->cache_read_count;
+    } else {
+      size = self->read_ahead_size;
+      /* ensure that the sector we want will be read */
+      if (sector >= chunk->cache_start_sector + chunk->cache_read_count + size)
+        size = sector - chunk->cache_start_sector - chunk->cache_read_count;
+    }
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_ReadCacheReadAheadSize, self->read_ahead_size, size);
+
+    if (size)
+      chunk->cache_read_count += DVDReadBlocks(self->dvd_self->file,
+                                               start,
+                                               size,
+                                               read_ahead_buf);
+
+    res = DVD_VIDEO_LB_LEN * block_count;
+
+  } else {
+
+    if (self->dvd_self->use_read_ahead)
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_LIBMPDVDNAV_CacheMissOnSector, sector);
+
+    res = DVDReadBlocks(self->dvd_self->file,
+                        sector,
+                        block_count,
+                        *buf) * DVD_VIDEO_LB_LEN;
+  }
+
+  return res;
+
+}
+
+dvdnav_status_t dvdnav_free_cache_block(dvdnav_t *self, unsigned char *buf) {
+  read_cache_t *cache;
+  int i;
+
+  if (!self)
+    return DVDNAV_STATUS_ERR;
+
+  cache = self->cache;
+  if (!cache)
+    return DVDNAV_STATUS_ERR;
+
+  pthread_mutex_lock(&cache->lock);
+  for (i = 0; i < READ_CACHE_CHUNKS; i++) {
+    if (cache->chunk[i].cache_buffer && buf >= cache->chunk[i].cache_buffer &&
+        buf < cache->chunk[i].cache_buffer + cache->chunk[i].cache_malloc_size * DVD_VIDEO_LB_LEN) {
+      cache->chunk[i].usage_count--;
+    }
+  }
+  pthread_mutex_unlock(&cache->lock);
+
+  if (cache->freeing)
+    /* when we want to dispose the cache, try freeing it now */
+    dvdnav_read_cache_free(cache);
+
+  return DVDNAV_STATUS_OK;
+}
diff -r 448a43f59a37 libmpdvdnav/read_cache.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/read_cache.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: read_cache.h,v 1.4 2002/07/12 15:46:44 mroi Exp $
+ *
+ */
+
+#ifndef __DVDNAV_READ_CACHE_H
+#define __DVDNAV_READ_CACHE_H
+
+#include "dvdnav_internal.h"
+
+/* Opaque cache type -- defined in dvdnav_internal.h */
+/* typedef struct read_cache_s read_cache_t; */
+
+/* EXPERIMENTAL: Setting the following to 1 will use an experimental multi-threaded
+ *               read-ahead cache.
+ */
+#define _MULTITHREAD_ 0
+
+/* Constructor/destructors */
+read_cache_t *dvdnav_read_cache_new(dvdnav_t* dvd_self);
+void dvdnav_read_cache_free(read_cache_t* self);
+
+/* This function MUST be called whenever self->file changes. */
+void dvdnav_read_cache_clear(read_cache_t *self);
+/* This function is called just after reading the NAV packet. */
+void dvdnav_pre_cache_blocks(read_cache_t *self, int sector, size_t block_count);
+/* This function will do the cache read.
+ * The buffer handed in must be malloced to take one dvd block.
+ * On a cache hit, a different buffer will be returned though.
+ * Those buffers must _never_ be freed. */
+int dvdnav_read_cache_block(read_cache_t *self, int sector, size_t block_count, uint8_t **buf);
+
+#endif /* __DVDNAV_READ_CACHE_H */
diff -r 448a43f59a37 libmpdvdnav/remap.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/remap.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,262 @@
+/*
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: remap.c,v 1.4 2003/08/27 13:54:19 mroi Exp $
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#ifndef _MSC_VER
+#include <sys/param.h>
+#include <sys/fcntl.h>
+#else
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 255
+#endif
+#endif /* _MSC_VER */
+
+#ifdef HAVE_MPLAYER
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include "remap.h"
+#include "dvdnav_internal.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+struct block_s {
+    int domain;
+    int title;
+    int program;
+    unsigned long start_block;
+    unsigned long end_block;
+};
+
+struct remap_s {
+    char *title;
+    int maxblocks;
+    int nblocks;
+    int debug;
+    struct block_s *blocks;
+};
+
+static remap_t* remap_new( char *title) {
+    remap_t *map = malloc( sizeof(remap_t));
+    map->title = strdup(title);
+    map->maxblocks = 0;
+    map->nblocks = 0;
+    map->blocks = NULL;
+    map->debug = 0;
+    return map;
+}
+
+static int compare_block( block_t *a, block_t *b) {
+    /* returns -1 if a precedes b, 1 if a follows b, and 0 if a and b overlap */
+    if (a->domain < b->domain) {
+	return -1;
+    } else if (a->domain > b->domain) {
+	return 1;
+    }
+
+    if (a->title < b->title) {
+	return -1;
+    } else if (a->title > b->title) {
+	return 1;
+    }
+
+    if (a->program < b->program) {
+	return -1;
+    } else if (a->program > b->program) {
+	return 1;
+    }
+
+    if (a->end_block < b->start_block) {
+	return -1;
+    } else if (a->start_block > b->end_block) {
+	/*
+	 * if a->start_block == b->end_block then the two regions
+	 * aren't strictly overlapping, but they should be merged
+	 * anyway since there are zero blocks between them
+	 */
+	return 1;
+    }
+
+    return 0;
+}
+
+static block_t *findblock( remap_t *map, block_t *key) {
+    int lb = 0;
+    int ub = map->nblocks - 1;
+    int mid;
+    int res;
+
+    while (lb <= ub) {
+	mid = lb + (ub - lb)/2;
+	res = compare_block( key, &map->blocks[mid]);
+	if (res < 0) {
+	    ub = mid-1;
+	} else if (res > 0) {
+	    lb = mid+1;
+	} else {
+	    return &map->blocks[mid];
+	}
+    }
+    return NULL;
+}
+
+static void mergeblock( block_t *b, block_t tmp) {
+    if (tmp.start_block < b->start_block) b->start_block = tmp.start_block;
+    if (tmp.end_block > b->end_block) b->end_block = tmp.end_block;
+}
+
+static void remap_add_node( remap_t *map, block_t block) {
+    block_t *b;
+    int n;
+    b = findblock( map, &block);
+    if (b) {
+	/* overlaps an existing block */
+	mergeblock( b, block);
+    } else {
+        /* new block */
+	if (map->nblocks >= map->maxblocks) {
+	    map->maxblocks += 20;
+	    map->blocks = realloc( map->blocks, sizeof( block_t)*map->maxblocks);
+	}
+	n = map->nblocks++;
+	while (n > 0 && compare_block( &block, &map->blocks[ n-1]) < 0) {
+	    map->blocks[ n] = map->blocks[ n-1];
+	    n--;
+	}
+	map->blocks[ n] = block;
+    }
+}
+
+static int parseblock(char *buf, int *dom, int *tt, int *pg,
+		      unsigned long *start, unsigned long *end) {
+    long tmp;
+    char *tok;
+    char *epos;
+    char *marker[]={"domain", "title", "program", "start", "end"};
+    int st = 0;
+    tok = strtok( buf, " ");
+    while (st < 5) {
+        if (strcmp(tok, marker[st])) return -st-1000;
+        tok = strtok( NULL, " ");
+        if (!tok) return -st-2000;
+        tmp = strtol( tok, &epos, 0);
+        if (*epos != 0 && *epos != ',') return -st-3000;
+        switch (st) {
+	    case 0:
+		*dom = (int)tmp;
+		break;
+	    case 1:
+		*tt = (int)tmp;
+		break;
+	    case 2:
+		*pg = (int)tmp;
+		break;
+	    case 3:
+		*start = tmp;
+		break;
+	    case 4:
+		*end = tmp;
+		break;
+	}
+	st++;
+        tok = strtok( NULL, " ");
+    }
+    return st;
+}
+
+remap_t* remap_loadmap( char *title) {
+    char buf[160];
+    char fname[MAXPATHLEN];
+    char *home;
+    int res;
+    FILE *fp;
+    block_t tmp;
+    remap_t *map;
+
+    /* Build the map filename */
+    home = getenv("HOME");
+#ifdef WIN32
+    if(!home) home = getenv("USERPROFILE");
+    if(!home) home = getenv("HOMEPATH");
+    if(!home) home = (char*)get_path("");
+#endif
+    assert(home);
+    snprintf(fname, sizeof(fname), "%s/.dvdnav/%s.map", home, title);
+    /* Open the map file */
+    fp = fopen( fname, "r");
+    if (!fp) {
+        mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_UnableToFindMapFile, fname);
+	return NULL;
+    }
+
+    /* Load the map file */
+    map = remap_new( title);
+    while (fgets( buf, sizeof(buf), fp) != NULL) {
+        if (buf[0] == '\n' || buf[0] == '#' || buf[0] == 0) continue;
+        if (strncasecmp( buf, "debug", 5) == 0) {
+	    map->debug = 1;
+	} else {
+	    res = parseblock( buf,
+		&tmp.domain, &tmp.title, &tmp.program, &tmp.start_block, &tmp.end_block);
+	    if (res != 5) {
+		mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_IgnoringMapLine, res, buf);
+		continue;
+	    }
+	    remap_add_node( map, tmp);
+	}
+    }
+
+    if (map->nblocks == 0 && map->debug == 0) return NULL;
+    return map;
+}
+
+unsigned long remap_block(
+	remap_t *map, int domain, int title, int program,
+	unsigned long cblock, unsigned long offset)
+{
+    block_t key;
+    block_t *b;
+
+    if (map->debug) {
+	mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_RemapInfo,
+	    map->title, domain, title, program, cblock, cblock+offset);
+    }
+
+    key.domain = domain;
+    key.title = title;
+    key.program = program;
+    key.start_block = key.end_block = cblock + offset;
+    b = findblock( map, &key);
+
+    if (b) {
+       if (map->debug) {
+	   mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_RedirectedTo, b->end_block);
+       }
+       return b->end_block - cblock;
+    }
+    return offset;
+}
diff -r 448a43f59a37 libmpdvdnav/remap.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/remap.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,33 @@
+/*
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: remap.h,v 1.2 2003/02/20 15:32:19 mroi Exp $
+ */
+
+#ifndef __REMAP__H
+#define __REMAP__H
+typedef struct block_s block_t;
+
+typedef struct remap_s remap_t;
+
+remap_t* remap_loadmap( char *title);
+
+unsigned long remap_block(
+	remap_t *map, int domain, int title, int program,
+	unsigned long cblock, unsigned long offset);
+
+#endif
diff -r 448a43f59a37 libmpdvdnav/searching.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/searching.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,523 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: searching.c,v 1.35 2004/01/07 19:35:12 mroi Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include "dvdnav_internal.h"
+
+/*
+#define LOG_DEBUG
+*/
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+/* Searching API calls */
+
+dvdnav_status_t dvdnav_time_search(dvdnav_t *this,
+				   uint64_t time) {
+  /* FIXME: Time search the current PGC based on the xxx table */
+  return DVDNAV_STATUS_OK;
+}
+
+/* Scan the ADMAP for a particular block number. */
+/* Return placed in vobu. */
+/* Returns error status */
+/* FIXME: Maybe need to handle seeking outside current cell. */
+static dvdnav_status_t dvdnav_scan_admap(dvdnav_t *this, int32_t domain, uint32_t seekto_block, uint32_t *vobu) {
+  vobu_admap_t *admap = NULL;
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Seeking to target %u ...\n", seekto_block);
+#endif
+  *vobu = -1;
+
+  /* Search through the VOBU_ADMAP for the nearest VOBU
+   * to the target block */
+  switch(domain) {
+  case FP_DOMAIN:
+  case VMGM_DOMAIN:
+    admap = this->vm->vmgi->menu_vobu_admap;
+    break;
+  case VTSM_DOMAIN:
+    admap = this->vm->vtsi->menu_vobu_admap;
+    break;
+  case VTS_DOMAIN:
+    admap = this->vm->vtsi->vts_vobu_admap;
+    break;
+  default:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_UnknownDomainForSeeking);
+  }
+  if(admap) {
+    uint32_t address = 0;
+    uint32_t vobu_start, next_vobu;
+    int32_t found = 0;
+
+    /* Search through ADMAP for best sector */
+    vobu_start = SRI_END_OF_CELL;
+    /* FIXME: Implement a faster search algorithm */
+    while((!found) && ((address<<2) < admap->last_byte)) {
+      next_vobu = admap->vobu_start_sectors[address];
+
+      /* mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Found block %u\n", next_vobu); */
+
+      if(vobu_start <= seekto_block &&
+          next_vobu > seekto_block) {
+        found = 1;
+      } else {
+        vobu_start = next_vobu;
+      }
+      address ++;
+    }
+    if(found) {
+      *vobu = vobu_start;
+      return DVDNAV_STATUS_OK;
+    } else {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_CouldNotLocateBlock);
+      return DVDNAV_STATUS_ERR;
+    }
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_AdmapNotLocated);
+  return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_sector_search(dvdnav_t *this,
+				     uint64_t offset, int32_t origin) {
+  uint32_t target = 0;
+  uint32_t length = 0;
+  uint32_t first_cell_nr, last_cell_nr, cell_nr;
+  int32_t found;
+  cell_playback_t *cell;
+  dvd_state_t *state;
+  dvdnav_status_t result;
+
+  if(this->position_current.still != 0) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_CannotSeekInAStillFrame);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  result = dvdnav_get_position(this, &target, &length);
+  if(!result) {
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  state = &(this->vm->state);
+  if(!state->pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: seeking to offset=%lu pos=%u length=%u\n", offset, target, length);
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Before cellN=%u blockN=%u\n", state->cellN, state->blockN);
+#endif
+
+  switch(origin) {
+   case SEEK_SET:
+    if(offset > length) {
+      printerr(MSGTR_LIBMPDVDNAV_Err_RequestToSeekBehindEnd);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+    target = offset;
+    break;
+   case SEEK_CUR:
+    if(target + offset > length) {
+      printerr(MSGTR_LIBMPDVDNAV_Err_RequestToSeekBehindEnd);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+    target += offset;
+    break;
+   case SEEK_END:
+    if(length - offset < 0) {
+      printerr(MSGTR_LIBMPDVDNAV_Err_RequestToSeekBeforeStart);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+    target = length - offset;
+    break;
+   default:
+    /* Error occured */
+    printerr(MSGTR_LIBMPDVDNAV_Err_IllegalSeekMode);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  if (this->pgc_based) {
+    first_cell_nr = 1;
+    last_cell_nr = state->pgc->nr_of_cells;
+  } else {
+    /* Find start cell of program. */
+    first_cell_nr = state->pgc->program_map[state->pgN-1];
+    /* Find end cell of program */
+    if(state->pgN < state->pgc->nr_of_programs)
+      last_cell_nr = state->pgc->program_map[state->pgN] - 1;
+    else
+      last_cell_nr = state->pgc->nr_of_cells;
+  }
+
+  found = 0;
+  for(cell_nr = first_cell_nr; (cell_nr <= last_cell_nr) && !found; cell_nr ++) {
+    cell =  &(state->pgc->cell_playback[cell_nr-1]);
+    length = cell->last_sector - cell->first_sector + 1;
+    if (target >= length) {
+      target -= length;
+    } else {
+      /* convert the target sector from Cell-relative to absolute physical sector */
+      target += cell->first_sector;
+      found = 1;
+      break;
+    }
+  }
+
+  if(found) {
+    int32_t vobu;
+#ifdef LOG_DEBUG
+    mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: Seeking to cell %i from choice of %i to %i\n",
+	    cell_nr, first_cell_nr, last_cell_nr);
+#endif
+    if (dvdnav_scan_admap(this, state->domain, target, &vobu) == DVDNAV_STATUS_OK) {
+      int32_t start = state->pgc->cell_playback[cell_nr-1].first_sector;
+
+      if (vm_jump_cell_block(this->vm, cell_nr, vobu - start)) {
+#ifdef LOG_DEBUG
+        mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: After cellN=%u blockN=%u target=%x vobu=%x start=%x\n" ,
+          state->cellN, state->blockN, target, vobu, start);
+#endif
+        this->vm->hop_channel += HOP_SEEK;
+        pthread_mutex_unlock(&this->vm_lock);
+        return DVDNAV_STATUS_OK;
+      }
+    }
+  }
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_ErrorWhenSeeking);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_FIXMEImplementSeekingToLocation, target);
+  printerr(MSGTR_LIBMPDVDNAV_Err_ErrorWhenSeeking);
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_part_search(dvdnav_t *this, int32_t part) {
+  int32_t title, old_part;
+
+  if (dvdnav_current_title_info(this, &title, &old_part) == DVDNAV_STATUS_OK)
+    return dvdnav_part_play(this, title, part);
+  return DVDNAV_STATUS_ERR;
+}
+
+dvdnav_status_t dvdnav_prev_pg_search(dvdnav_t *this) {
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if(!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: previous chapter\n");
+#endif
+  if (!vm_jump_prev_pg(this->vm)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_PreviousChapterFailed);
+    printerr(MSGTR_LIBMPDVDNAV_Err_SkipToPreviousChapterFailed);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  this->position_current.still = 0;
+  this->vm->hop_channel++;
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: previous chapter done\n");
+#endif
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_top_pg_search(dvdnav_t *this) {
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if(!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: top chapter\n");
+#endif
+  if (!vm_jump_top_pg(this->vm)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_TopChapterFailed);
+    printerr(MSGTR_LIBMPDVDNAV_Err_SkipToTopChapterFailed);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  this->position_current.still = 0;
+  this->vm->hop_channel++;
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: top chapter done\n");
+#endif
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_next_pg_search(dvdnav_t *this) {
+  vm_t *try_vm;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if(!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: next chapter\n");
+#endif
+  /* make a copy of current VM and try to navigate the copy to the next PG */
+  try_vm = vm_new_copy(this->vm);
+  if (!vm_jump_next_pg(try_vm) || try_vm->stopped) {
+    vm_free_copy(try_vm);
+    /* next_pg failed, try to jump at least to the next cell */
+    try_vm = vm_new_copy(this->vm);
+    vm_get_next_cell(try_vm);
+    if (try_vm->stopped) {
+      vm_free_copy(try_vm);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_NextChapterFailed);
+      printerr(MSGTR_LIBMPDVDNAV_Err_SkipToNextChapterFailed);
+      pthread_mutex_unlock(&this->vm_lock);
+      return DVDNAV_STATUS_ERR;
+    }
+  }
+  /* merge changes on success */
+  vm_merge(this->vm, try_vm);
+  vm_free_copy(try_vm);
+  this->position_current.still = 0;
+  this->vm->hop_channel++;
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: next chapter done\n");
+#endif
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_menu_call(dvdnav_t *this, DVDMenuID_t menu) {
+  vm_t *try_vm;
+
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if(!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* make a copy of current VM and try to navigate the copy to the menu */
+  try_vm = vm_new_copy(this->vm);
+  if ( (menu == DVD_MENU_Escape) && (this->vm->state.domain != VTS_DOMAIN)) {
+    /* Try resume */
+    if (vm_jump_resume(try_vm) && !try_vm->stopped) {
+        /* merge changes on success */
+        vm_merge(this->vm, try_vm);
+        vm_free_copy(try_vm);
+        this->position_current.still = 0;
+        this->vm->hop_channel++;
+        pthread_mutex_unlock(&this->vm_lock);
+        return DVDNAV_STATUS_OK;
+    }
+  }
+  if (menu == DVD_MENU_Escape) menu = DVD_MENU_Root;
+
+  if (vm_jump_menu(try_vm, menu) && !try_vm->stopped) {
+    /* merge changes on success */
+    vm_merge(this->vm, try_vm);
+    vm_free_copy(try_vm);
+    this->position_current.still = 0;
+    this->vm->hop_channel++;
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_OK;
+  } else {
+    vm_free_copy(try_vm);
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoSuchMenuOrMenuNotReachable);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+}
+
+dvdnav_status_t dvdnav_get_position(dvdnav_t *this, uint32_t *pos,
+				    uint32_t *len) {
+  uint32_t cur_sector;
+  int32_t cell_nr, first_cell_nr, last_cell_nr;
+  cell_playback_t *cell;
+  dvd_state_t *state;
+
+  if(!this || !pos || !len) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+  if(!this->started) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  state = &(this->vm->state);
+  if(!state->pgc || this->vm->stopped) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  if (this->position_current.hop_channel  != this->vm->hop_channel ||
+      this->position_current.domain       != state->domain         ||
+      this->position_current.vts          != state->vtsN           ||
+      this->position_current.cell_restart != state->cell_restart) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NewPositionNotYetDetermined);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* Get current sector */
+  cur_sector = this->vobu.vobu_start + this->vobu.blockN;
+
+  if (this->pgc_based) {
+    first_cell_nr = 1;
+    last_cell_nr = state->pgc->nr_of_cells;
+  } else {
+    /* Find start cell of program. */
+    first_cell_nr = state->pgc->program_map[state->pgN-1];
+    /* Find end cell of program */
+    if(state->pgN < state->pgc->nr_of_programs)
+      last_cell_nr = state->pgc->program_map[state->pgN] - 1;
+    else
+      last_cell_nr = state->pgc->nr_of_cells;
+  }
+
+  *pos = -1;
+  *len = 0;
+  for (cell_nr = first_cell_nr; cell_nr <= last_cell_nr; cell_nr++) {
+    cell = &(state->pgc->cell_playback[cell_nr-1]);
+    if (cell_nr == state->cellN) {
+      /* the current sector is in this cell,
+       * pos is length of PG up to here + sector's offset in this cell */
+      *pos = *len + cur_sector - cell->first_sector;
+    }
+    *len += cell->last_sector - cell->first_sector + 1;
+  }
+
+  assert((signed)*pos != -1);
+
+  pthread_mutex_unlock(&this->vm_lock);
+
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_position_in_title(dvdnav_t *this,
+					     uint32_t *pos,
+					     uint32_t *len) {
+  uint32_t cur_sector;
+  uint32_t first_cell_nr;
+  uint32_t last_cell_nr;
+  cell_playback_t *first_cell;
+  cell_playback_t *last_cell;
+  dvd_state_t *state;
+
+  if(!this || !pos || !len) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  state = &(this->vm->state);
+  if(!state->pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* Get current sector */
+  cur_sector = this->vobu.vobu_start + this->vobu.blockN;
+
+  /* Now find first and last cells in title. */
+  first_cell_nr = state->pgc->program_map[0];
+  first_cell = &(state->pgc->cell_playback[first_cell_nr-1]);
+  last_cell_nr = state->pgc->nr_of_cells;
+  last_cell = &(state->pgc->cell_playback[last_cell_nr-1]);
+
+  *pos = cur_sector - first_cell->first_sector;
+  *len = last_cell->last_sector - first_cell->first_sector;
+
+  return DVDNAV_STATUS_OK;
+}
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_get_pgc(dvdnav_t *this, int *pg_num)
+{
+  if(!this || !pg_num) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  if(!this->vm->state.pgc) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC);
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+#ifdef LOG_DEBUG
+  mp_msg(MSGT_FIXME,MSGL_FIXME, "libdvdnav: get pgc\n");
+#endif
+  *pg_num = vm_get_PGCN(this->vm);
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+#endif
diff -r 448a43f59a37 libmpdvdnav/settings.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/settings.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2000 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: settings.c,v 1.9 2003/12/31 21:37:16 jcdutton Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include "dvdnav_internal.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+/* Characteristics/setting API calls */
+
+dvdnav_status_t dvdnav_get_region_mask(dvdnav_t *this, int32_t *region) {
+  if(!this || !region) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*region) = this->vm->state.registers.SPRM[20];
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_set_region_mask(dvdnav_t *this, int32_t mask) {
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  this->vm->state.registers.SPRM[20] = (mask & 0xff);
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_set_readahead_flag(dvdnav_t *this, int32_t use_readahead) {
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->use_read_ahead = use_readahead;
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_readahead_flag(dvdnav_t *this, int32_t *flag) {
+  if(!this || !flag) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*flag) = this->use_read_ahead;
+  return DVDNAV_STATUS_OK;
+}
+
+static dvdnav_status_t set_language_register(dvdnav_t *this, char *code, int reg) {
+  if(!this || !code) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  if(!code[0] || !code[1]) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedIllegalLanguageCode);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  this->vm->state.registers.SPRM[reg] = (code[0] << 8) | code[1];
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_menu_language_select(dvdnav_t *this, char *code) {
+  return set_language_register(this, code, 0);
+}
+
+dvdnav_status_t dvdnav_audio_language_select(dvdnav_t *this, char *code) {
+  return set_language_register(this, code, 16);
+}
+
+dvdnav_status_t dvdnav_spu_language_select(dvdnav_t *this, char *code) {
+  return set_language_register(this, code, 18);
+}
+
+dvdnav_status_t dvdnav_set_PGC_positioning_flag(dvdnav_t *this, int32_t pgc) {
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  this->pgc_based = pgc;
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_get_PGC_positioning_flag(dvdnav_t *this, int32_t *flag) {
+  if(!this || !flag) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  (*flag) = this->pgc_based;
+  return DVDNAV_STATUS_OK;
+}
+
+#ifdef USE_MPDVDNAV
+dvdnav_status_t dvdnav_button_select_auto_action(dvdnav_t *this, int mode)
+{
+  if(!this) {
+    printerr(MSGTR_LIBMPDVDNAV_Err_PassedANullPointer);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+  this->vm->auto_action_mode = mode;
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+#endif
diff -r 448a43f59a37 libmpdvdnav/vm.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/vm.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,1921 @@
+/*
+ * Copyright (C) 2000, 2001 Hkan Hjort
+ * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
+ *               2002-2004 the dvdnav project
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is modified
+ * from a file originally part of the Ogle DVD player.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: vm.c,v 1.6 2004/05/21 19:32:25 mroi Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+#include "dvdnav_internal.h"
+
+#ifdef _MSC_VER
+#include <io.h>   /* read() */
+#endif /* _MSC_VER */
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+#ifdef USE_MPDVDNAV_TRACE
+extern int dvdnav_trace;
+#endif
+
+/*
+#define STRICT
+*/
+
+/* Local prototypes */
+
+/* get_XYZ returns a value.
+ * set_XYZ sets state using passed parameters.
+ *         returns success/failure.
+ */
+
+/* Play */
+static link_t play_PGC(vm_t *vm);
+static link_t play_PGC_PG(vm_t *vm, int pgN);
+static link_t play_PGC_post(vm_t *vm);
+static link_t play_PG(vm_t *vm);
+static link_t play_Cell(vm_t *vm);
+static link_t play_Cell_post(vm_t *vm);
+
+/* Process link - returns 1 if a hop has been performed */
+static int process_command(vm_t *vm,link_t link_values);
+
+/* Set */
+static int  set_TT(vm_t *vm, int tt);
+static int  set_PTT(vm_t *vm, int tt, int ptt);
+static int  set_VTS_TT(vm_t *vm, int vtsN, int vts_ttn);
+static int  set_VTS_PTT(vm_t *vm, int vtsN, int vts_ttn, int part);
+static int  set_FP_PGC(vm_t *vm);
+static int  set_MENU(vm_t *vm, int menu);
+static int  set_PGCN(vm_t *vm, int pgcN);
+static int  set_PGN(vm_t *vm); /* Set PGN based on (vm->state).CellN */
+static void set_RSMinfo(vm_t *vm, int cellN, int blockN);
+
+/* Get */
+static int get_TT(vm_t *vm, int vtsN, int vts_ttn);
+static int get_ID(vm_t *vm, int id);
+static int get_PGCN(vm_t *vm);
+
+static pgcit_t* get_MENU_PGCIT(vm_t *vm, ifo_handle_t *h, uint16_t lang);
+static pgcit_t* get_PGCIT(vm_t *vm);
+
+
+/* Helper functions */
+
+#ifdef USE_MPDVDNAV_TRACE
+static void vm_print_current_domain_state(vm_t *vm) {
+  switch((vm->state).domain) {
+    case VTS_DOMAIN:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Video Title Domain: -\n");
+      break;
+
+    case VTSM_DOMAIN:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Video Title Menu Domain: -\n");
+      break;
+
+    case VMGM_DOMAIN:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Video Manager Menu Domain: -\n");
+      break;
+
+    case FP_DOMAIN:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: First Play Domain: -\n");
+      break;
+
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Unknown Domain: -\n");
+      break;
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: VTS:%d PGC:%d PG:%u CELL:%u BLOCK:%u VTS_TTN:%u TTN:%u TT_PGCN:%u\n",
+                   (vm->state).vtsN,
+                   get_PGCN(vm),
+                   (vm->state).pgN,
+                   (vm->state).cellN,
+                   (vm->state).blockN,
+                   (vm->state).VTS_TTN_REG,
+                   (vm->state).TTN_REG,
+                   (vm->state).TT_PGCN_REG);
+}
+#endif
+
+static void dvd_read_name(char *name, const char *device) {
+    /* Because we are compiling with _FILE_OFFSET_BITS=64
+     * all off_t are 64bit.
+     */
+    off_t off;
+    int i;
+    dvd_input_t fd;
+    uint8_t data[DVD_VIDEO_LB_LEN];
+
+    /* Read DVD name */
+    fd = dvdinput_open(device);
+    if (fd > 0) {
+      off = dvdinput_seek( fd, 16 );
+      if( off == 16 ) {
+        off = dvdinput_read( fd, data, 1, DVDINPUT_NOFLAGS );
+        if (off == 1 ) {
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDTitle);
+          for(i=40; i < 73; i++ ) {
+            if((data[i] == 0)) break;
+            if((data[i] > 32) && (data[i] < 127)) {
+	    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c", data[i]);
+            } else {
+	      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+            }
+          }
+          strncpy(name, &data[40], 32);
+          i=31;
+          while( (i >= 0) && (name[i] <= ' ')) --i;
+          name[i+1] = '\0';
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDSerialNumber);
+          for(i=813; i < 829; i++ ) {
+            if((data[i] == 0)) break;
+            if((data[i] > 32) && (data[i] < 127)) {
+	      mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c", data[i]);
+            } else {
+	      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+            }
+          }
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDTitleAlternative);
+          for(i=89; i < 128; i++ ) {
+            if((data[i] == 0)) break;
+            if((data[i] > 32) && (data[i] < 127)) {
+	      mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c", data[i]);
+            } else {
+	      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+            }
+          }
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+        } else {
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_LIBMPDVDNAV_VmCCantReadNameBlock);
+        }
+      } else {
+        mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_LIBMPDVDNAV_VmCCantSeekToBlock);
+      }
+      dvdinput_close(fd);
+    } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, MSGTR_LIBMPDVDNAV_VmCNameOpenFailed);
+  }
+}
+
+
+static void ifoOpenNewVTSI(vm_t *vm, dvd_reader_t *dvd, int vtsN) {
+  if((vm->state).vtsN == vtsN) {
+    return; /*  We alread have it */
+  }
+
+  if(vm->vtsi != NULL)
+    ifoClose(vm->vtsi);
+
+  vm->vtsi = ifoOpenVTSI(dvd, vtsN);
+  if(vm->vtsi == NULL) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoOpenVTSIFailed);
+    assert(0);
+  }
+  if(!ifoRead_VTS_PTT_SRPT(vm->vtsi)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadVTSPTTSRPTFailed);
+    assert(0);
+  }
+  if(!ifoRead_PGCIT(vm->vtsi)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadPGCITFailed);
+    assert(0);
+  }
+  if(!ifoRead_PGCI_UT(vm->vtsi)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadPGCIUTFailed);
+    assert(0);
+  }
+  if(!ifoRead_VOBU_ADMAP(vm->vtsi)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadVOBUADMAPVtsiFailed);
+    assert(0);
+  }
+  if(!ifoRead_TITLE_VOBU_ADMAP(vm->vtsi)) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCIfoReadTITLEVOBUADMAPVtsiFailed);
+    assert(0);
+  }
+  (vm->state).vtsN = vtsN;
+}
+
+
+/* Initialisation & Destruction */
+
+vm_t* vm_new_vm() {
+  return (vm_t*)calloc(sizeof(vm_t), sizeof(char));
+}
+
+void vm_free_vm(vm_t *vm) {
+  vm_stop(vm);
+  free(vm);
+}
+
+
+/* IFO Access */
+
+ifo_handle_t *vm_get_vmgi(vm_t *vm) {
+  return vm->vmgi;
+}
+
+ifo_handle_t *vm_get_vtsi(vm_t *vm) {
+  return vm->vtsi;
+}
+
+
+/* Reader Access */
+
+dvd_reader_t *vm_get_dvd_reader(vm_t *vm) {
+  return vm->dvd;
+}
+
+
+/* Basic Handling */
+
+void vm_start(vm_t *vm) {
+  /* Set pgc to FP (First Play) pgc */
+  set_FP_PGC(vm);
+  process_command(vm, play_PGC(vm));
+}
+
+void vm_stop(vm_t *vm) {
+  if(vm->vmgi) {
+    ifoClose(vm->vmgi);
+    vm->vmgi=NULL;
+  }
+  if(vm->vtsi) {
+    ifoClose(vm->vtsi);
+    vm->vtsi=NULL;
+  }
+  if(vm->dvd) {
+    DVDClose(vm->dvd);
+    vm->dvd=NULL;
+  }
+  vm->stopped = 1;
+}
+
+int vm_reset(vm_t *vm, const char *dvdroot) {
+  /*  Setup State */
+  memset((vm->state).registers.SPRM, 0, sizeof((vm->state).registers.SPRM));
+  memset((vm->state).registers.GPRM, 0, sizeof((vm->state).registers.GPRM));
+  memset((vm->state).registers.GPRM_mode, 0, sizeof((vm->state).registers.GPRM_mode));
+  memset((vm->state).registers.GPRM_mode, 0, sizeof((vm->state).registers.GPRM_mode));
+  memset((vm->state).registers.GPRM_time, 0, sizeof((vm->state).registers.GPRM_time));
+  (vm->state).registers.SPRM[0]  = ('e'<<8)|'n'; /* Player Menu Languange code */
+  (vm->state).AST_REG            = 15;           /* 15 why? */
+  (vm->state).SPST_REG           = 62;           /* 62 why? */
+  (vm->state).AGL_REG            = 1;
+  (vm->state).TTN_REG            = 1;
+  (vm->state).VTS_TTN_REG        = 1;
+  /* (vm->state).TT_PGCN_REG        = 0 */
+  (vm->state).PTTN_REG           = 1;
+  (vm->state).HL_BTNN_REG        = 1 << 10;
+  (vm->state).PTL_REG            = 15;           /* Parental Level */
+  (vm->state).registers.SPRM[12] = ('U'<<8)|'S'; /* Parental Management Country Code */
+  (vm->state).registers.SPRM[16] = ('e'<<8)|'n'; /* Initial Language Code for Audio */
+  (vm->state).registers.SPRM[18] = ('e'<<8)|'n'; /* Initial Language Code for Spu */
+  (vm->state).registers.SPRM[20] = 0x1;          /* Player Regional Code Mask. Region free! */
+  (vm->state).registers.SPRM[14] = 0x100;        /* Try Pan&Scan */
+
+  (vm->state).pgN                = 0;
+  (vm->state).cellN              = 0;
+  (vm->state).cell_restart       = 0;
+
+  (vm->state).domain             = FP_DOMAIN;
+  (vm->state).rsm_vtsN           = 0;
+  (vm->state).rsm_cellN          = 0;
+  (vm->state).rsm_blockN         = 0;
+
+  (vm->state).vtsN               = -1;
+
+  if (vm->dvd && dvdroot) {
+    /* a new dvd device has been requested */
+    vm_stop(vm);
+  }
+  if (!vm->dvd) {
+    vm->dvd = DVDOpen(dvdroot);
+    if(!vm->dvd) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmFaildToOpenReadTheDVD);
+      return 0;
+    }
+    dvd_read_name(vm->dvd_name, dvdroot);
+    vm->map  = remap_loadmap(vm->dvd_name);
+    vm->vmgi = ifoOpenVMGI(vm->dvd);
+    if(!vm->vmgi) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmFaildToReadVIDEOTSIFO);
+      return 0;
+    }
+    if(!ifoRead_FP_PGC(vm->vmgi)) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadFPPGCFailed);
+      return 0;
+    }
+    if(!ifoRead_TT_SRPT(vm->vmgi)) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadTTSRPTFailed);
+      return 0;
+    }
+    if(!ifoRead_PGCI_UT(vm->vmgi)) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadPGCIUTFailed);
+      return 0;
+    }
+    if(!ifoRead_PTL_MAIT(vm->vmgi)) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadPRLMAITFailed);
+      /* return 0; Not really used for now.. */
+    }
+    if(!ifoRead_VTS_ATRT(vm->vmgi)) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadVTSATRTFailed);
+      /* return 0; Not really used for now.. */
+    }
+    if(!ifoRead_VOBU_ADMAP(vm->vmgi)) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCVmIfoReadVOBUADMAPVgmiFailed);
+      /* return 0; Not really used for now.. */
+    }
+    /* ifoRead_TXTDT_MGI(vmgi); Not implemented yet */
+  }
+  if (vm->vmgi) {
+    int i, mask;
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCDVDDiskReportsItselfWithRegionMask,
+      vm->vmgi->vmgi_mat->vmg_category);
+    for (i = 1, mask = 1; i <= 8; i++, mask <<= 1)
+      if (((vm->vmgi->vmgi_mat->vmg_category >> 16) & mask) == 0)
+	mp_msg(MSGT_CPLAYER,MSGL_INFO, " %d", i);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+  }
+  return 1;
+}
+
+
+/* copying and merging */
+
+vm_t *vm_new_copy(vm_t *source) {
+  vm_t *target = vm_new_vm();
+  int vtsN;
+  int pgcN = get_PGCN(source);
+  int pgN  = (source->state).pgN;
+
+  assert(pgcN);
+
+  memcpy(target, source, sizeof(vm_t));
+
+  /* open a new vtsi handle, because the copy might switch to another VTS */
+  target->vtsi = NULL;
+  vtsN = (target->state).vtsN;
+  if (vtsN > 0) {
+    (target->state).vtsN = 0;
+    ifoOpenNewVTSI(target, target->dvd, vtsN);
+
+    /* restore pgc pointer into the new vtsi */
+    if (!set_PGCN(target, pgcN))
+      assert(0);
+    (target->state).pgN = pgN;
+  }
+
+  return target;
+}
+
+void vm_merge(vm_t *target, vm_t *source) {
+  if(target->vtsi)
+    ifoClose(target->vtsi);
+  memcpy(target, source, sizeof(vm_t));
+  memset(source, 0, sizeof(vm_t));
+}
+
+void vm_free_copy(vm_t *vm) {
+  if(vm->vtsi)
+    ifoClose(vm->vtsi);
+  free(vm);
+}
+
+
+/* regular playback */
+
+void vm_position_get(vm_t *vm, vm_position_t *position) {
+  position->button = (vm->state).HL_BTNN_REG >> 10;
+  position->vts = (vm->state).vtsN;
+  position->domain = (vm->state).domain;
+  position->spu_channel = (vm->state).SPST_REG;
+  position->audio_channel = (vm->state).AST_REG;
+  position->angle_channel = (vm->state).AGL_REG;
+  position->hop_channel = vm->hop_channel; /* Increases by one on each hop */
+  position->cell = (vm->state).cellN;
+  position->cell_restart = (vm->state).cell_restart;
+  position->cell_start = (vm->state).pgc->cell_playback[(vm->state).cellN - 1].first_sector;
+  position->still = (vm->state).pgc->cell_playback[(vm->state).cellN - 1].still_time;
+  position->block = (vm->state).blockN;
+
+  /* handle PGC stills at PGC end */
+  if ((vm->state).cellN == (vm->state).pgc->nr_of_cells)
+    position->still += (vm->state).pgc->still_time;
+  /* still already determined */
+  if (position->still)
+    return;
+  /* This is a rough fix for some strange still situations on some strange DVDs.
+   * There are discs (like the German "Back to the Future" RC2) where the only
+   * indication of a still is a cell playback time higher than the time the frames
+   * in this cell actually take to play (like 1 frame with 1 minute playback time).
+   * On the said BTTF disc, for these cells last_sector and last_vobu_start_sector
+   * are equal and the cells are very short, so we abuse these conditions to
+   * detect such discs. I consider these discs broken, so the fix is somewhat
+   * broken, too. */
+  if (((vm->state).pgc->cell_playback[(vm->state).cellN - 1].last_sector ==
+       (vm->state).pgc->cell_playback[(vm->state).cellN - 1].last_vobu_start_sector) &&
+      ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].last_sector -
+       (vm->state).pgc->cell_playback[(vm->state).cellN - 1].first_sector < 1024)) {
+    int time;
+    int size = (vm->state).pgc->cell_playback[(vm->state).cellN - 1].last_sector -
+	       (vm->state).pgc->cell_playback[(vm->state).cellN - 1].first_sector;
+    time  = ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].playback_time.hour   >> 4  ) * 36000;
+    time += ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].playback_time.hour   & 0x0f) * 3600;
+    time += ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].playback_time.minute >> 4  ) * 600;
+    time += ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].playback_time.minute & 0x0f) * 60;
+    time += ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].playback_time.second >> 4  ) * 10;
+    time += ((vm->state).pgc->cell_playback[(vm->state).cellN - 1].playback_time.second & 0x0f) * 1;
+    if (!time || size / time > 30)
+      /* datarate is too high, it might be a very short, but regular cell */
+      return;
+    if (time > 0xff) time = 0xff;
+    position->still = time;
+  }
+}
+
+void vm_get_next_cell(vm_t *vm) {
+  process_command(vm, play_Cell_post(vm));
+}
+
+
+/* Jumping */
+
+int vm_jump_pg(vm_t *vm, int pg) {
+  (vm->state).pgN = pg;
+  process_command(vm, play_PG(vm));
+  return 1;
+}
+
+int vm_jump_cell_block(vm_t *vm, int cell, int block) {
+  (vm->state).cellN = cell;
+  process_command(vm, play_Cell(vm));
+  /* play_Cell can jump to a different cell in case of angles */
+  if ((vm->state).cellN == cell)
+    (vm->state).blockN = block;
+  return 1;
+}
+
+int vm_jump_title_part(vm_t *vm, int title, int part) {
+  link_t link;
+
+  if(!set_PTT(vm, title, part))
+    return 0;
+  /* Some DVDs do not want us to jump directly into a title and have
+   * PGC pre commands taking us back to some menu. Since we do not like that,
+   * we do not execute PGC pre commands that would do a jump. */
+  /* process_command(vm, play_PGC_PG(vm, (vm->state).pgN)); */
+  link = play_PGC_PG(vm, (vm->state).pgN);
+  if (link.command != PlayThis)
+    /* jump occured -> ignore it and play the PG anyway */
+    process_command(vm, play_PG(vm));
+  else
+    process_command(vm, link);
+  return 1;
+}
+
+int vm_jump_top_pg(vm_t *vm) {
+  process_command(vm, play_PG(vm));
+  return 1;
+}
+
+int vm_jump_next_pg(vm_t *vm) {
+  if((vm->state).pgN >= (vm->state).pgc->nr_of_programs) {
+    /* last program -> move to TailPGC */
+    process_command(vm, play_PGC_post(vm));
+    return 1;
+  } else {
+    vm_jump_pg(vm, (vm->state).pgN + 1);
+    return 1;
+  }
+}
+
+int vm_jump_prev_pg(vm_t *vm) {
+  if ((vm->state).pgN <= 1) {
+    /* first program -> move to last program of previous PGC */
+    if ((vm->state).pgc->prev_pgc_nr && set_PGCN(vm, (vm->state).pgc->prev_pgc_nr)) {
+      process_command(vm, play_PGC(vm));
+      vm_jump_pg(vm, (vm->state).pgc->nr_of_programs);
+      return 1;
+    }
+    return 0;
+  } else {
+    vm_jump_pg(vm, (vm->state).pgN - 1);
+    return 1;
+  }
+}
+
+int vm_jump_up(vm_t *vm) {
+  if((vm->state).pgc->goup_pgc_nr && set_PGCN(vm, (vm->state).pgc->goup_pgc_nr)) {
+    process_command(vm, play_PGC(vm));
+    return 1;
+  }
+  return 0;
+}
+
+int vm_jump_menu(vm_t *vm, DVDMenuID_t menuid) {
+  domain_t old_domain = (vm->state).domain;
+
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    set_RSMinfo(vm, 0, (vm->state).blockN);
+    /* FALL THROUGH */
+  case VTSM_DOMAIN:
+  case VMGM_DOMAIN:
+    switch(menuid) {
+    case DVD_MENU_Title:
+    case DVD_MENU_Escape:
+      (vm->state).domain = VMGM_DOMAIN;
+      break;
+    case DVD_MENU_Root:
+    case DVD_MENU_Subpicture:
+    case DVD_MENU_Audio:
+    case DVD_MENU_Angle:
+    case DVD_MENU_Part:
+      (vm->state).domain = VTSM_DOMAIN;
+      break;
+    }
+    if(get_PGCIT(vm) && set_MENU(vm, menuid)) {
+      process_command(vm, play_PGC(vm));
+      return 1;  /* Jump */
+    } else {
+      (vm->state).domain = old_domain;
+    }
+    break;
+  case FP_DOMAIN: /* FIXME XXX $$$ What should we do here? */
+    break;
+  }
+
+  return 0;
+}
+
+int vm_jump_resume(vm_t *vm) {
+  link_t link_values = { LinkRSM, 0, 0, 0 };
+
+  if (!(vm->state).rsm_vtsN) /* Do we have resume info? */
+    return 0;
+  if (!process_command(vm, link_values))
+    return 0;
+  return 1;
+}
+
+int vm_exec_cmd(vm_t *vm, vm_cmd_t *cmd) {
+  link_t link_values;
+
+  if(vmEval_CMD(cmd, 1, &(vm->state).registers, &link_values))
+    return process_command(vm, link_values);
+  else
+    return 0; /*  It updated some state thats all... */
+}
+
+
+/* getting information */
+
+int vm_get_current_menu(vm_t *vm, int *menuid) {
+  pgcit_t* pgcit;
+  int pgcn;
+  pgcn = (vm->state).pgcN;
+  pgcit = get_PGCIT(vm);
+  *menuid = pgcit->pgci_srp[pgcn - 1].entry_id & 0xf ;
+  return 1;
+}
+
+int vm_get_current_title_part(vm_t *vm, int *title_result, int *part_result) {
+  vts_ptt_srpt_t *vts_ptt_srpt;
+  int title, part = 0, vts_ttn;
+  int found;
+  int16_t pgcN, pgN;
+
+  vts_ptt_srpt = vm->vtsi->vts_ptt_srpt;
+  pgcN = get_PGCN(vm);
+  pgN = vm->state.pgN;
+
+  found = 0;
+  for (vts_ttn = 0; (vts_ttn < vts_ptt_srpt->nr_of_srpts) && !found; vts_ttn++) {
+    for (part = 0; (part < vts_ptt_srpt->title[vts_ttn].nr_of_ptts) && !found; part++) {
+      if (vts_ptt_srpt->title[vts_ttn].ptt[part].pgcn == pgcN) {
+	if (vts_ptt_srpt->title[vts_ttn].ptt[part].pgn  == pgN) {
+	  found = 1;
+          break;
+	}
+	if (part > 0 && vts_ptt_srpt->title[vts_ttn].ptt[part].pgn > pgN &&
+	    vts_ptt_srpt->title[vts_ttn].ptt[part - 1].pgn < pgN) {
+	  part--;
+	  found = 1;
+	  break;
+	}
+      }
+    }
+    if (found) break;
+  }
+  vts_ttn++;
+  part++;
+
+  if (!found) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCChapterNotFound);
+    return 0;
+  }
+
+  title = get_TT(vm, vm->state.vtsN, vts_ttn);
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace && title) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ************ this chapter FOUND!\n");
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: VTS_PTT_SRPT - Title %3i part %3i: PGC: %3i PG: %3i\n",
+             title, part,
+             vts_ptt_srpt->title[vts_ttn-1].ptt[part-1].pgcn ,
+             vts_ptt_srpt->title[vts_ttn-1].ptt[part-1].pgn );
+  }
+#endif
+  *title_result = title;
+  *part_result = part;
+  return 1;
+}
+
+/* Return the substream id for 'logical' audio stream audioN.
+ * 0 <= audioN < 8
+ */
+int vm_get_audio_stream(vm_t *vm, int audioN) {
+  int streamN = -1;
+
+  if((vm->state).domain != VTS_DOMAIN)
+    audioN = 0;
+
+  if(audioN < 8) {
+    /* Is there any control info for this logical stream */
+    if( (vm->state).pgc->audio_control[audioN].present) {
+      streamN = (vm->state).pgc->audio_control[audioN].s_audio;
+    }
+  }
+
+  if((vm->state).domain != VTS_DOMAIN && streamN == -1)
+    streamN = 0;
+
+  /* FIXME: Should also check in vtsi/vmgi status what kind of stream
+   * it is (ac3/lpcm/dts/sdds...) to find the right (sub)stream id */
+  return streamN;
+}
+
+/* Return the substream id for 'logical' subpicture stream subpN and given mode.
+ * 0 <= subpN < 32
+ * mode == 0 - widescreen
+ * mode == 1 - letterbox
+ * mode == 2 - pan&scan
+ */
+int vm_get_subp_stream(vm_t *vm, int subpN, int mode) {
+  int streamN = -1;
+  int source_aspect = vm_get_video_aspect(vm);
+
+  if((vm->state).domain != VTS_DOMAIN)
+    subpN = 0;
+
+  if(subpN < 32) { /* a valid logical stream */
+    /* Is this logical stream present */
+    if((vm->state).pgc->subp_control[subpN].present) {
+      if(source_aspect == 0) /* 4:3 */
+	streamN = (vm->state).pgc->subp_control[subpN].s_4p3;
+      if(source_aspect == 3) /* 16:9 */
+        switch (mode) {
+	case 0:
+	  streamN = (vm->state).pgc->subp_control[subpN].s_wide;
+	  break;
+	case 1:
+	  streamN = (vm->state).pgc->subp_control[subpN].s_lbox;
+	  break;
+	case 2:
+	  streamN = (vm->state).pgc->subp_control[subpN].s_panscan;
+	}
+    }
+  }
+
+ if((vm->state).domain != VTS_DOMAIN && streamN == -1)
+   streamN = 0;
+
+  /* FIXME: Should also check in vtsi/vmgi status what kind of stream it is. */
+  return streamN;
+}
+
+int vm_get_audio_active_stream(vm_t *vm) {
+  int audioN;
+  int streamN;
+  audioN = (vm->state).AST_REG ;
+  streamN = vm_get_audio_stream(vm, audioN);
+
+  /* If no such stream, then select the first one that exists. */
+  if(streamN == -1) {
+    for(audioN = 0; audioN < 8; audioN++) {
+#ifdef USE_MPDVDKIT
+      if((vm->state).pgc->audio_control[audioN].present) {
+#else
+      if((vm->state).pgc->audio_control[audioN] & (1<<15)) {
+#endif
+        if ((streamN = vm_get_audio_stream(vm, audioN)) >= 0)
+          break;
+      }
+    }
+  }
+
+  return streamN;
+}
+
+int vm_get_subp_active_stream(vm_t *vm, int mode) {
+  int subpN;
+  int streamN;
+  subpN = (vm->state).SPST_REG & ~0x40;
+  streamN = vm_get_subp_stream(vm, subpN, mode);
+
+  /* If no such stream, then select the first one that exists. */
+  if(streamN == -1) {
+    for(subpN = 0; subpN < 32; subpN++) {
+#ifdef USE_MPDVDKIT
+      if((vm->state).pgc->subp_control[subpN].present) {
+#else
+      if((vm->state).pgc->subp_control[subpN] & (1<<31)) {
+#endif
+        if ((streamN = vm_get_subp_stream(vm, subpN, mode)) >= 0)
+          break;
+      }
+    }
+  }
+
+  if((vm->state).domain == VTS_DOMAIN && !((vm->state).SPST_REG & 0x40))
+    /* Bit 7 set means hide, and only let Forced display show */
+    return (streamN | 0x80);
+  else
+    return streamN;
+}
+
+void vm_get_angle_info(vm_t *vm, int *current, int *num_avail) {
+  *num_avail = 1;
+  *current = 1;
+
+  if((vm->state).domain == VTS_DOMAIN) {
+    title_info_t *title;
+    /* TTN_REG does not allways point to the correct title.. */
+    if((vm->state).TTN_REG > vm->vmgi->tt_srpt->nr_of_srpts)
+      return;
+    title = &vm->vmgi->tt_srpt->title[(vm->state).TTN_REG - 1];
+    if(title->title_set_nr != (vm->state).vtsN ||
+       title->vts_ttn != (vm->state).VTS_TTN_REG)
+      return;
+    *num_avail = title->nr_of_angles;
+    *current = (vm->state).AGL_REG;
+  }
+}
+
+#if 0
+/* currently unused */
+void vm_get_audio_info(vm_t *vm, int *current, int *num_avail) {
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    *num_avail = vm->vtsi->vtsi_mat->nr_of_vts_audio_streams;
+    *current = (vm->state).AST_REG;
+    break;
+  case VTSM_DOMAIN:
+    *num_avail = vm->vtsi->vtsi_mat->nr_of_vtsm_audio_streams; /*  1 */
+    *current = 1;
+    break;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    *num_avail = vm->vmgi->vmgi_mat->nr_of_vmgm_audio_streams; /*  1 */
+    *current = 1;
+    break;
+  }
+}
+
+/* currently unused */
+void vm_get_subp_info(vm_t *vm, int *current, int *num_avail) {
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    *num_avail = vm->vtsi->vtsi_mat->nr_of_vts_subp_streams;
+    *current = (vm->state).SPST_REG;
+    break;
+  case VTSM_DOMAIN:
+    *num_avail = vm->vtsi->vtsi_mat->nr_of_vtsm_subp_streams; /*  1 */
+    *current = 0x41;
+    break;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    *num_avail = vm->vmgi->vmgi_mat->nr_of_vmgm_subp_streams; /*  1 */
+    *current = 0x41;
+    break;
+  }
+}
+
+/* currently unused */
+void vm_get_video_res(vm_t *vm, int *width, int *height) {
+  video_attr_t attr = vm_get_video_attr(vm);
+
+  if(attr.video_format != 0)
+    *height = 576;
+  else
+    *height = 480;
+  switch(attr.picture_size) {
+  case 0:
+    *width = 720;
+    break;
+  case 1:
+    *width = 704;
+    break;
+  case 2:
+    *width = 352;
+    break;
+  case 3:
+    *width = 352;
+    *height /= 2;
+    break;
+  }
+}
+#endif
+
+#if 0
+int vm_get_audio_id(vm_t *vm, int streamN) {
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    return vm->vtsi->vtsi_mat->vts_audio_attr[streamN].s_audio;
+  case VTSM_DOMAIN:
+    return vm->vtsi->vtsi_mat->vtsm_audio_attr.s_audio;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    return vm->vmgi->vmgi_mat->vmgm_audio_attr.s_audio;;
+  default:
+    abort();
+  }
+}
+#endif
+
+int vm_get_video_aspect(vm_t *vm) {
+  int aspect = vm_get_video_attr(vm).display_aspect_ratio;
+
+  assert(aspect == 0 || aspect == 3);
+  (vm->state).registers.SPRM[14] &= ~(0x3 << 10);
+  (vm->state).registers.SPRM[14] |= aspect << 10;
+
+  return aspect;
+}
+
+int vm_get_video_scale_permission(vm_t *vm) {
+  return vm_get_video_attr(vm).permitted_df;
+}
+
+video_attr_t vm_get_video_attr(vm_t *vm) {
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    return vm->vtsi->vtsi_mat->vts_video_attr;
+  case VTSM_DOMAIN:
+    return vm->vtsi->vtsi_mat->vtsm_video_attr;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    return vm->vmgi->vmgi_mat->vmgm_video_attr;
+  default:
+    abort();
+  }
+}
+
+audio_attr_t vm_get_audio_attr(vm_t *vm, int streamN) {
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    return vm->vtsi->vtsi_mat->vts_audio_attr[streamN];
+  case VTSM_DOMAIN:
+    return vm->vtsi->vtsi_mat->vtsm_audio_attr;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    return vm->vmgi->vmgi_mat->vmgm_audio_attr;
+  default:
+    abort();
+  }
+}
+
+subp_attr_t vm_get_subp_attr(vm_t *vm, int streamN) {
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    return vm->vtsi->vtsi_mat->vts_subp_attr[streamN];
+  case VTSM_DOMAIN:
+    return vm->vtsi->vtsi_mat->vtsm_subp_attr;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    return vm->vmgi->vmgi_mat->vmgm_subp_attr;
+  default:
+    abort();
+  }
+}
+
+
+/* Playback control */
+
+static link_t play_PGC(vm_t *vm) {
+  link_t link_values;
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PGC:");
+  if((vm->state).domain != FP_DOMAIN) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " (vm->state).pgcN (%i)\n", get_PGCN(vm));
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " first_play_pgc\n");
+  } }
+#endif
+
+  /* This must be set before the pre-commands are executed because they
+   * might contain a CallSS that will save resume state */
+
+  /* FIXME: This may be only a temporary fix for something... */
+  (vm->state).pgN = 1;
+  (vm->state).cellN = 0;
+  (vm->state).blockN = 0;
+
+  /* eval -> updates the state and returns either
+     - some kind of jump (Jump(TT/SS/VTS_TTN/CallSS/link C/PG/PGC/PTTN)
+     - just play video i.e first PG
+       (This is what happens if you fall of the end of the pre_cmds)
+     - or an error (are there more cases?) */
+  if((vm->state).pgc->command_tbl && (vm->state).pgc->command_tbl->nr_of_pre) {
+    if(vmEval_CMD((vm->state).pgc->command_tbl->pre_cmds,
+		  (vm->state).pgc->command_tbl->nr_of_pre,
+		  &(vm->state).registers, &link_values)) {
+      /*  link_values contains the 'jump' return value */
+      return link_values;
+    } else {
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: PGC pre commands didn't do a Jump, Link or Call\n");
+#endif
+    }
+  }
+  return play_PG(vm);
+}
+
+static link_t play_PGC_PG(vm_t *vm, int pgN) {
+  link_t link_values;
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PGC_PG:");
+  if((vm->state).domain != FP_DOMAIN) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " (vm->state).pgcN (%i)\n", get_PGCN(vm));
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " first_play_pgc\n");
+  } }
+#endif
+
+  /*  This must be set before the pre-commands are executed because they
+   *  might contain a CallSS that will save resume state */
+
+  /* FIXME: This may be only a temporary fix for something... */
+  (vm->state).pgN = pgN;
+  (vm->state).cellN = 0;
+  (vm->state).blockN = 0;
+
+  /* eval -> updates the state and returns either
+     - some kind of jump (Jump(TT/SS/VTS_TTN/CallSS/link C/PG/PGC/PTTN)
+     - just play video i.e first PG
+       (This is what happens if you fall of the end of the pre_cmds)
+     - or an error (are there more cases?) */
+  if((vm->state).pgc->command_tbl && (vm->state).pgc->command_tbl->nr_of_pre) {
+    if(vmEval_CMD((vm->state).pgc->command_tbl->pre_cmds,
+		  (vm->state).pgc->command_tbl->nr_of_pre,
+		  &(vm->state).registers, &link_values)) {
+      /*  link_values contains the 'jump' return value */
+      return link_values;
+    } else {
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: PGC pre commands didn't do a Jump, Link or Call\n");
+#endif
+    }
+  }
+  return play_PG(vm);
+}
+
+static link_t play_PGC_post(vm_t *vm) {
+  link_t link_values;
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PGC_post:\n");
+#endif
+
+  /* eval -> updates the state and returns either
+     - some kind of jump (Jump(TT/SS/VTS_TTN/CallSS/link C/PG/PGC/PTTN)
+     - just go to next PGC
+       (This is what happens if you fall of the end of the post_cmds)
+     - or an error (are there more cases?) */
+  if((vm->state).pgc->command_tbl && (vm->state).pgc->command_tbl->nr_of_post &&
+     vmEval_CMD((vm->state).pgc->command_tbl->post_cmds,
+		(vm->state).pgc->command_tbl->nr_of_post,
+		&(vm->state).registers, &link_values)) {
+    return link_values;
+  }
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ** Fell of the end of the pgc, continuing in NextPGC\n");
+#endif
+  /* Should end up in the STOP_DOMAIN if next_pgc is 0. */
+//#ifndef USE_MPDVDNAV
+  if(!set_PGCN(vm, (vm->state).pgc->next_pgc_nr)) {
+    link_values.command = Exit;
+    return link_values;
+  }
+//#endif
+  return play_PGC(vm);
+}
+
+static link_t play_PG(vm_t *vm) {
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PG: (vm->state).pgN (%i)\n", (vm->state).pgN);
+#endif
+
+  assert((vm->state).pgN > 0);
+  if((vm->state).pgN > (vm->state).pgc->nr_of_programs) {
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_PG: (vm->state).pgN (%i) > pgc->nr_of_programs (%i)\n",
+	    (vm->state).pgN, (vm->state).pgc->nr_of_programs );
+#endif
+    assert((vm->state).pgN == (vm->state).pgc->nr_of_programs + 1);
+    return play_PGC_post(vm);
+  }
+
+  (vm->state).cellN = (vm->state).pgc->program_map[(vm->state).pgN - 1];
+
+  return play_Cell(vm);
+}
+
+static link_t play_Cell(vm_t *vm) {
+  static const link_t play_this = {PlayThis, /* Block in Cell */ 0, 0, 0};
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_Cell: (vm->state).cellN (%i)\n", (vm->state).cellN);
+#endif
+
+  assert((vm->state).cellN > 0);
+  if((vm->state).cellN > (vm->state).pgc->nr_of_cells) {
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: (vm->state).cellN (%i) > pgc->nr_of_cells (%i)\n",
+	    (vm->state).cellN, (vm->state).pgc->nr_of_cells );
+#endif
+    assert((vm->state).cellN == (vm->state).pgc->nr_of_cells + 1);
+    return play_PGC_post(vm);
+  }
+
+  /* Multi angle/Interleaved */
+  switch((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode) {
+  case 0: /*  Normal */
+    assert((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type == 0);
+    break;
+  case 1: /*  The first cell in the block */
+    switch((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type) {
+    case 0: /*  Not part of a block */
+      assert(0);
+      break;
+    case 1: /*  Angle block */
+      /* Loop and check each cell instead? So we don't get outside the block? */
+      (vm->state).cellN += (vm->state).AGL_REG - 1;
+#ifdef STRICT
+      assert((vm->state).cellN <= (vm->state).pgc->nr_of_cells);
+      assert((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode != 0);
+      assert((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type == 1);
+#else
+      if (!((vm->state).cellN <= (vm->state).pgc->nr_of_cells) ||
+          !((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode != 0) ||
+	  !((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type == 1)) {
+	mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCInvalidAngleBlock);
+	(vm->state).cellN -= (vm->state).AGL_REG - 1;
+      }
+#endif
+      break;
+    case 2: /*  ?? */
+    case 3: /*  ?? */
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCInvalidBlockMode,
+	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode,
+	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type);
+      assert(0);
+    }
+    break;
+  case 2: /*  Cell in the block */
+  case 3: /*  Last cell in the block */
+  /* These might perhaps happen for RSM or LinkC commands? */
+  default:
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCCellIsInBlockButDidNotEnter);
+  }
+
+  /* Updates (vm->state).pgN and PTTN_REG */
+  if(!set_PGN(vm)) {
+    /* Should not happen */
+    assert(0);
+    return play_PGC_post(vm);
+  }
+  (vm->state).cell_restart++;
+  (vm->state).blockN = 0;
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Cell should restart here\n");
+#endif
+  return play_this;
+}
+
+static link_t play_Cell_post(vm_t *vm) {
+  cell_playback_t *cell;
+
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: play_Cell_post: (vm->state).cellN (%i)\n", (vm->state).cellN);
+#endif
+
+  cell = &(vm->state).pgc->cell_playback[(vm->state).cellN - 1];
+
+  /* Still time is already taken care of before we get called. */
+
+  /* Deal with a Cell command, if any */
+  if(cell->cell_cmd_nr != 0) {
+    link_t link_values;
+
+/*  These asserts are now not needed.
+ *  Some DVDs have no cell commands listed in the PGC,
+ *  but the Cell itself points to a cell command that does not exist.
+ *  For this situation, just ignore the cell command and continue.
+ *
+ *  assert((vm->state).pgc->command_tbl != NULL);
+ *  assert((vm->state).pgc->command_tbl->nr_of_cell >= cell->cell_cmd_nr);
+ */
+
+    if ((vm->state).pgc->command_tbl != NULL &&
+        (vm->state).pgc->command_tbl->nr_of_cell >= cell->cell_cmd_nr) {
+#ifdef USE_MPDVDNAV_TRACE
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Cell command present, executing\n");
+#endif
+      if(vmEval_CMD(&(vm->state).pgc->command_tbl->cell_cmds[cell->cell_cmd_nr - 1], 1,
+		    &(vm->state).registers, &link_values)) {
+        return link_values;
+      } else {
+#ifdef USE_MPDVDNAV_TRACE
+        if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Cell command didn't do a Jump, Link or Call\n");
+#endif
+      }
+    } else {
+#ifdef USE_MPDVDNAV_TRACE
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Invalid Cell command\n");
+#endif
+    }
+  }
+
+  /* Where to continue after playing the cell... */
+  /* Multi angle/Interleaved */
+  switch((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode) {
+  case 0: /*  Normal */
+    assert((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type == 0);
+    (vm->state).cellN++;
+    break;
+  case 1: /*  The first cell in the block */
+  case 2: /*  A cell in the block */
+  case 3: /*  The last cell in the block */
+  default:
+    switch((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type) {
+    case 0: /*  Not part of a block */
+      assert(0);
+      break;
+    case 1: /*  Angle block */
+      /* Skip the 'other' angles */
+      (vm->state).cellN++;
+      while((vm->state).cellN <= (vm->state).pgc->nr_of_cells &&
+	    (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode >= 2) {
+	(vm->state).cellN++;
+      }
+      break;
+    case 2: /*  ?? */
+    case 3: /*  ?? */
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCInvalidBlockMode,
+	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode,
+	      (vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type);
+      assert(0);
+    }
+    break;
+  }
+
+  /* Figure out the correct pgN for the new cell */
+  if(!set_PGN(vm)) {
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: last cell in this PGC\n");
+#endif
+    return play_PGC_post(vm);
+  }
+  return play_Cell(vm);
+}
+
+
+/* link processing */
+
+static int process_command(vm_t *vm, link_t link_values) {
+
+  while(link_values.command != PlayThis) {
+
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Before printout starts:\n");
+    vm_print_link(link_values);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Link values %i %i %i %i\n", link_values.command,
+	    link_values.data1, link_values.data2, link_values.data3);
+    vm_print_current_domain_state(vm);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Before printout ends.\n"); }
+#endif
+
+    switch(link_values.command) {
+    case LinkNoLink:
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      return 0;  /* no actual jump */
+
+    case LinkTopC:
+      /* Restart playing from the beginning of the current Cell. */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      link_values = play_Cell(vm);
+      break;
+    case LinkNextC:
+      /* Link to Next Cell */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      (vm->state).cellN += 1;
+      link_values = play_Cell(vm);
+      break;
+    case LinkPrevC:
+      /* Link to Previous Cell */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      assert((vm->state).cellN > 1);
+      (vm->state).cellN -= 1;
+      link_values = play_Cell(vm);
+      break;
+
+    case LinkTopPG:
+      /* Link to Top of current Program */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      link_values = play_PG(vm);
+      break;
+    case LinkNextPG:
+      /* Link to Next Program */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      (vm->state).pgN += 1;
+      link_values = play_PG(vm);
+      break;
+    case LinkPrevPG:
+      /* Link to Previous Program */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      assert((vm->state).pgN > 1);
+      (vm->state).pgN -= 1;
+      link_values = play_PG(vm);
+      break;
+
+    case LinkTopPGC:
+      /* Restart playing from beginning of current Program Chain */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      link_values = play_PGC(vm);
+      break;
+    case LinkNextPGC:
+      /* Link to Next Program Chain */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      assert((vm->state).pgc->next_pgc_nr != 0);
+      if(!set_PGCN(vm, (vm->state).pgc->next_pgc_nr))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case LinkPrevPGC:
+      /* Link to Previous Program Chain */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      assert((vm->state).pgc->prev_pgc_nr != 0);
+      if(!set_PGCN(vm, (vm->state).pgc->prev_pgc_nr))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case LinkGoUpPGC:
+      /* Link to GoUp Program Chain */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      assert((vm->state).pgc->goup_pgc_nr != 0);
+      if(!set_PGCN(vm, (vm->state).pgc->goup_pgc_nr))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case LinkTailPGC:
+      /* Link to Tail of Program Chain */
+      /* BUTTON number:data1 */
+      if(link_values.data1 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data1 << 10;
+      link_values = play_PGC_post(vm);
+    break;
+
+    case LinkRSM:
+      {
+	/* Link to Resume point */
+	int i;
+
+	/* Check and see if there is any rsm info!! */
+	if (!(vm->state).rsm_vtsN) {
+          mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCTryingToResumeWithoutAnyResume);
+	  link_values.command = Exit;
+	  break;
+	}
+
+	(vm->state).domain = VTS_DOMAIN;
+	ifoOpenNewVTSI(vm, vm->dvd, (vm->state).rsm_vtsN);
+	set_PGCN(vm, (vm->state).rsm_pgcN);
+
+	/* These should never be set in SystemSpace and/or MenuSpace */
+	/* (vm->state).TTN_REG = rsm_tt; ?? */
+	/* (vm->state).TT_PGCN_REG = (vm->state).rsm_pgcN; ?? */
+	for(i = 0; i < 5; i++) {
+	  (vm->state).registers.SPRM[4 + i] = (vm->state).rsm_regs[i];
+	}
+
+	if(link_values.data1 != 0)
+	  (vm->state).HL_BTNN_REG = link_values.data1 << 10;
+
+	if((vm->state).rsm_cellN == 0) {
+	  assert((vm->state).cellN); /*  Checking if this ever happens */
+	  (vm->state).pgN = 1;
+	  link_values = play_PG(vm);
+	} else {
+	  /* (vm->state).pgN = ?? this gets the righ value in set_PGN() below */
+	  (vm->state).cellN = (vm->state).rsm_cellN;
+	  link_values.command = PlayThis;
+	  link_values.data1 = (vm->state).rsm_blockN;
+	  if(!set_PGN(vm)) {
+	    /* Were at the end of the PGC, should not happen for a RSM */
+	    assert(0);
+	    link_values.command = LinkTailPGC;
+	    link_values.data1 = 0;  /* No button */
+	  }
+	}
+      }
+      break;
+    case LinkPGCN:
+      /* Link to Program Chain Number:data1 */
+      if(!set_PGCN(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case LinkPTTN:
+      /* Link to Part of current Title Number:data1 */
+      /* BUTTON number:data2 */
+      /* PGC Pre-Commands are not executed */
+      assert((vm->state).domain == VTS_DOMAIN);
+      if(link_values.data2 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data2 << 10;
+      if(!set_VTS_PTT(vm, (vm->state).vtsN, (vm->state).VTS_TTN_REG, link_values.data1))
+	assert(0);
+      link_values = play_PG(vm);
+      break;
+    case LinkPGN:
+      /* Link to Program Number:data1 */
+      /* BUTTON number:data2 */
+      if(link_values.data2 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data2 << 10;
+      /* Update any other state, PTTN perhaps? */
+      (vm->state).pgN = link_values.data1;
+      link_values = play_PG(vm);
+      break;
+    case LinkCN:
+      /* Link to Cell Number:data1 */
+      /* BUTTON number:data2 */
+      if(link_values.data2 != 0)
+	(vm->state).HL_BTNN_REG = link_values.data2 << 10;
+      /* Update any other state, pgN, PTTN perhaps? */
+      (vm->state).cellN = link_values.data1;
+      link_values = play_Cell(vm);
+      break;
+
+    case Exit:
+      vm->stopped = 1;
+      return 0;
+
+    case JumpTT:
+      /* Jump to VTS Title Domain */
+      /* Only allowed from the First Play domain(PGC) */
+      /* or the Video Manager domain (VMG) */
+      /* Stop SPRM9 Timer */
+      /* Set SPRM1 and SPRM2 */
+      assert((vm->state).domain == VMGM_DOMAIN || (vm->state).domain == FP_DOMAIN); /* ?? */
+      if(!set_TT(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case JumpVTS_TT:
+      /* Jump to Title:data1 in same VTS Title Domain */
+      /* Only allowed from the VTS Menu Domain(VTSM) */
+      /* or the Video Title Set Domain(VTS) */
+      /* Stop SPRM9 Timer */
+      /* Set SPRM1 and SPRM2 */
+      assert((vm->state).domain == VTSM_DOMAIN || (vm->state).domain == VTS_DOMAIN); /* ?? */
+      if(!set_VTS_TT(vm, (vm->state).vtsN, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case JumpVTS_PTT:
+      /* Jump to Part:data2 of Title:data1 in same VTS Title Domain */
+      /* Only allowed from the VTS Menu Domain(VTSM) */
+      /* or the Video Title Set Domain(VTS) */
+      /* Stop SPRM9 Timer */
+      /* Set SPRM1 and SPRM2 */
+      assert((vm->state).domain == VTSM_DOMAIN || (vm->state).domain == VTS_DOMAIN); /* ?? */
+      if(!set_VTS_PTT(vm, (vm->state).vtsN, link_values.data1, link_values.data2))
+	assert(0);
+      link_values = play_PGC_PG(vm, (vm->state).pgN);
+      break;
+
+    case JumpSS_FP:
+      /* Jump to First Play Domain */
+      /* Only allowed from the VTS Menu Domain(VTSM) */
+      /* or the Video Manager domain (VMG) */
+      /* Stop SPRM9 Timer and any GPRM counters */
+      assert((vm->state).domain == VMGM_DOMAIN || (vm->state).domain == VTSM_DOMAIN); /* ?? */
+      if (!set_FP_PGC(vm))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case JumpSS_VMGM_MENU:
+      /* Jump to Video Manger domain - Title Menu:data1 or any PGC in VMG */
+      /* Allowed from anywhere except the VTS Title domain */
+      /* Stop SPRM9 Timer and any GPRM counters */
+      assert((vm->state).domain != VTS_DOMAIN); /* ?? */
+      (vm->state).domain = VMGM_DOMAIN;
+      if(!set_MENU(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case JumpSS_VTSM:
+      /* Jump to a menu in Video Title domain, */
+      /* or to a Menu is the current VTS */
+      /* Stop SPRM9 Timer and any GPRM counters */
+      /* ifoOpenNewVTSI:data1 */
+      /* VTS_TTN_REG:data2 */
+      /* get_MENU:data3 */
+      if(link_values.data1 != 0) {
+	if (link_values.data1 != (vm->state).vtsN) {
+	  /* the normal case */
+	  assert((vm->state).domain == VMGM_DOMAIN || (vm->state).domain == FP_DOMAIN); /* ?? */
+	  (vm->state).domain = VTSM_DOMAIN;
+	  ifoOpenNewVTSI(vm, vm->dvd, link_values.data1);  /* Also sets (vm->state).vtsN */
+	} else {
+	  /* This happens on some discs like "Captain Scarlet & the Mysterons" or
+	   * the German RC2 of "Anatomie" in VTSM. */
+	  assert((vm->state).domain == VTSM_DOMAIN ||
+	    (vm->state).domain == VMGM_DOMAIN || (vm->state).domain == FP_DOMAIN); /* ?? */
+	  (vm->state).domain = VTSM_DOMAIN;
+	}
+      } else {
+	/*  This happens on 'The Fifth Element' region 2. */
+	assert((vm->state).domain == VTSM_DOMAIN);
+      }
+      /*  I don't know what title is supposed to be used for. */
+      /*  Alien or Aliens has this != 1, I think. */
+      /* assert(link_values.data2 == 1); */
+      (vm->state).VTS_TTN_REG = link_values.data2;
+      /* TTN_REG (SPRM4), VTS_TTN_REG (SPRM5), TT_PGCN_REG (SPRM6) are linked, */
+      /* so if one changes, the others must change to match it. */
+      (vm->state).TTN_REG     = get_TT(vm, (vm->state).vtsN, (vm->state).VTS_TTN_REG);
+      if(!set_MENU(vm, link_values.data3))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case JumpSS_VMGM_PGC:
+      /* set_PGCN:data1 */
+      /* Stop SPRM9 Timer and any GPRM counters */
+      assert((vm->state).domain != VTS_DOMAIN); /* ?? */
+      (vm->state).domain = VMGM_DOMAIN;
+      if(!set_PGCN(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+
+    case CallSS_FP:
+      /* set_RSMinfo:data1 */
+      assert((vm->state).domain == VTS_DOMAIN); /* ?? */
+      /* Must be called before domain is changed */
+      set_RSMinfo(vm, link_values.data1, /* We dont have block info */ 0);
+      set_FP_PGC(vm);
+      link_values = play_PGC(vm);
+      break;
+    case CallSS_VMGM_MENU:
+      /* set_MENU:data1 */
+      /* set_RSMinfo:data2 */
+      assert((vm->state).domain == VTS_DOMAIN); /* ?? */
+      /* Must be called before domain is changed */
+      set_RSMinfo(vm, link_values.data2, /* We dont have block info */ 0);
+      (vm->state).domain = VMGM_DOMAIN;
+      if(!set_MENU(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case CallSS_VTSM:
+      /* set_MENU:data1 */
+      /* set_RSMinfo:data2 */
+      assert((vm->state).domain == VTS_DOMAIN); /* ?? */
+      /* Must be called before domain is changed */
+      set_RSMinfo(vm, link_values.data2, /* We dont have block info */ 0);
+      (vm->state).domain = VTSM_DOMAIN;
+      if(!set_MENU(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case CallSS_VMGM_PGC:
+      /* set_PGC:data1 */
+      /* set_RSMinfo:data2 */
+      assert((vm->state).domain == VTS_DOMAIN); /* ?? */
+      /* Must be called before domain is changed */
+      set_RSMinfo(vm, link_values.data2, /* We dont have block info */ 0);
+      (vm->state).domain = VMGM_DOMAIN;
+      if(!set_PGCN(vm, link_values.data1))
+	assert(0);
+      link_values = play_PGC(vm);
+      break;
+    case PlayThis:
+      /* Should never happen. */
+      assert(0);
+      break;
+    }
+
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: After printout starts:\n");
+    vm_print_current_domain_state(vm);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: After printout ends.\n"); }
+#endif
+
+  }
+  (vm->state).blockN = link_values.data1;
+  return 1;
+}
+
+
+/* Set functions */
+
+static int set_TT(vm_t *vm, int tt) {
+  return set_PTT(vm, tt, 1);
+}
+
+static int set_PTT(vm_t *vm, int tt, int ptt) {
+  assert(tt <= vm->vmgi->tt_srpt->nr_of_srpts);
+  return set_VTS_PTT(vm, vm->vmgi->tt_srpt->title[tt - 1].title_set_nr,
+		     vm->vmgi->tt_srpt->title[tt - 1].vts_ttn, ptt);
+}
+
+static int set_VTS_TT(vm_t *vm, int vtsN, int vts_ttn) {
+  return set_VTS_PTT(vm, vtsN, vts_ttn, 1);
+}
+
+static int set_VTS_PTT(vm_t *vm, int vtsN, int vts_ttn, int part) {
+  int pgcN, pgN, res;
+
+  (vm->state).domain = VTS_DOMAIN;
+
+  if(vtsN != (vm->state).vtsN)
+    ifoOpenNewVTSI(vm, vm->dvd, vtsN);  /* Also sets (vm->state).vtsN */
+
+  if ((vts_ttn < 1) || (vts_ttn > vm->vtsi->vts_ptt_srpt->nr_of_srpts) ||
+      (part < 1) || (part > vm->vtsi->vts_ptt_srpt->title[vts_ttn - 1].nr_of_ptts) ) {
+    return 0;
+  }
+
+  pgcN = vm->vtsi->vts_ptt_srpt->title[vts_ttn - 1].ptt[part - 1].pgcn;
+  pgN = vm->vtsi->vts_ptt_srpt->title[vts_ttn - 1].ptt[part - 1].pgn;
+
+  (vm->state).TT_PGCN_REG = pgcN;
+  (vm->state).PTTN_REG    = part;
+  (vm->state).TTN_REG     = get_TT(vm, vtsN, vts_ttn);
+  assert( (vm->state.TTN_REG) != 0 );
+  (vm->state).VTS_TTN_REG = vts_ttn;
+  (vm->state).vtsN        = vtsN;  /* Not sure about this one. We can get to it easily from TTN_REG */
+  /* Any other registers? */
+
+  res = set_PGCN(vm, pgcN);   /* This clobber's state.pgN (sets it to 1), but we don't want clobbering here. */
+  (vm->state).pgN = pgN;
+  return res;
+}
+
+static int set_FP_PGC(vm_t *vm) {
+  (vm->state).domain = FP_DOMAIN;
+  (vm->state).pgc = vm->vmgi->first_play_pgc;
+  (vm->state).pgcN = vm->vmgi->vmgi_mat->first_play_pgc;
+  return 1;
+}
+
+
+static int set_MENU(vm_t *vm, int menu) {
+  assert((vm->state).domain == VMGM_DOMAIN || (vm->state).domain == VTSM_DOMAIN);
+  return set_PGCN(vm, get_ID(vm, menu));
+}
+
+static int set_PGCN(vm_t *vm, int pgcN) {
+  pgcit_t *pgcit;
+
+  pgcit = get_PGCIT(vm);
+  assert(pgcit != NULL);  /* ?? Make this return -1 instead */
+
+  if(pgcN < 1 || pgcN > pgcit->nr_of_pgci_srp) {
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav:  ** No such pgcN = %d\n", pgcN);
+#endif
+    return 0;
+  }
+
+  (vm->state).pgc = pgcit->pgci_srp[pgcN - 1].pgc;
+  (vm->state).pgcN = pgcN;
+  (vm->state).pgN = 1;
+
+  if((vm->state).domain == VTS_DOMAIN)
+    (vm->state).TT_PGCN_REG = pgcN;
+
+  return 1;
+}
+
+/* Figure out the correct pgN from the cell and update (vm->state). */
+static int set_PGN(vm_t *vm) {
+  int new_pgN = 0;
+
+  while(new_pgN < (vm->state).pgc->nr_of_programs
+	&& (vm->state).cellN >= (vm->state).pgc->program_map[new_pgN])
+    new_pgN++;
+
+  if(new_pgN == (vm->state).pgc->nr_of_programs) /* We are at the last program */
+    if((vm->state).cellN > (vm->state).pgc->nr_of_cells)
+      return 0; /* We are past the last cell */
+
+  (vm->state).pgN = new_pgN;
+
+  if((vm->state).domain == VTS_DOMAIN) {
+    playback_type_t *pb_ty;
+    if((vm->state).TTN_REG > vm->vmgi->tt_srpt->nr_of_srpts)
+      return 0; /* ?? */
+    pb_ty = &vm->vmgi->tt_srpt->title[(vm->state).TTN_REG - 1].pb_ty;
+    if(pb_ty->multi_or_random_pgc_title == /* One_Sequential_PGC_Title */ 0) {
+      int dummy, part;
+      vm_get_current_title_part(vm, &dummy, &part);
+      (vm->state).PTTN_REG = part;
+    } else {
+      /* FIXME: Handle RANDOM or SHUFFLE titles. */
+      mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCRandomOrShuffleTitlesAreNotHandledYet);
+    }
+  }
+  return 1;
+}
+
+/* Must be called before domain is changed (set_PGCN()) */
+static void set_RSMinfo(vm_t *vm, int cellN, int blockN) {
+  int i;
+
+  if(cellN) {
+    (vm->state).rsm_cellN = cellN;
+    (vm->state).rsm_blockN = blockN;
+  } else {
+    (vm->state).rsm_cellN = (vm->state).cellN;
+    (vm->state).rsm_blockN = blockN;
+  }
+  (vm->state).rsm_vtsN = (vm->state).vtsN;
+  (vm->state).rsm_pgcN = get_PGCN(vm);
+
+  /* assert((vm->state).rsm_pgcN == (vm->state).TT_PGCN_REG);  for VTS_DOMAIN */
+
+  for(i = 0; i < 5; i++) {
+    (vm->state).rsm_regs[i] = (vm->state).registers.SPRM[4 + i];
+  }
+}
+
+
+/* Get functions */
+
+/* Searches the TT tables, to find the current TT.
+ * returns the current TT.
+ * returns 0 if not found.
+ */
+static int get_TT(vm_t *vm, int vtsN, int vts_ttn) {
+  int i;
+  int tt=0;
+
+  for(i = 1; i <= vm->vmgi->tt_srpt->nr_of_srpts; i++) {
+    if( vm->vmgi->tt_srpt->title[i - 1].title_set_nr == vtsN &&
+        vm->vmgi->tt_srpt->title[i - 1].vts_ttn == vts_ttn) {
+      tt=i;
+      break;
+    }
+  }
+  return tt;
+}
+
+/* Search for entry_id match of the PGC Category in the current VTS PGCIT table.
+ * Return pgcN based on entry_id match.
+ */
+static int get_ID(vm_t *vm, int id) {
+  int pgcN, i;
+  pgcit_t *pgcit;
+
+  /* Relies on state to get the correct pgcit. */
+  pgcit = get_PGCIT(vm);
+  assert(pgcit != NULL);
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ** Searching for menu (0x%x) entry PGC\n", id);
+#endif
+
+  /* Force high bit set. */
+  id |=0x80;
+
+  /* Get menu/title */
+  for(i = 0; i < pgcit->nr_of_pgci_srp; i++) {
+    if( (pgcit->pgci_srp[i].entry_id) == id) {
+      pgcN = i + 1;
+#ifdef USE_MPDVDNAV_TRACE
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Found menu.\n");
+#endif
+      return pgcN;
+    }
+  }
+#ifdef USE_MPDVDNAV_TRACE
+  if (dvdnav_trace) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: ** No such id/menu (0x%02x) entry PGC\n", id & 0x7f);
+  for(i = 0; i < pgcit->nr_of_pgci_srp; i++) {
+    if ( (pgcit->pgci_srp[i].entry_id & 0x80) == 0x80) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: Available menus: 0x%x\n",
+                     pgcit->pgci_srp[i].entry_id & 0x7f);
+    }
+  } }
+#endif
+  return 0; /*  error */
+}
+
+/* FIXME: we have a pgcN member in the vm's state now, so this should be obsolete */
+static int get_PGCN(vm_t *vm) {
+  pgcit_t *pgcit;
+  int pgcN = 1;
+
+  pgcit = get_PGCIT(vm);
+
+  if (pgcit) {
+    while(pgcN <= pgcit->nr_of_pgci_srp) {
+      if(pgcit->pgci_srp[pgcN - 1].pgc == (vm->state).pgc) {
+	assert((vm->state).pgcN == pgcN);
+	return pgcN;
+      }
+      pgcN++;
+    }
+  }
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCGetPGCNFailed,
+         (vm->state).domain);
+  return 0; /*  error */
+}
+
+static pgcit_t* get_MENU_PGCIT(vm_t *vm, ifo_handle_t *h, uint16_t lang) {
+  int i;
+
+  if(h == NULL || h->pgci_ut == NULL) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCPgciUtHandleIsNULL);
+    return NULL; /*  error? */
+  }
+
+  i = 0;
+  while(i < h->pgci_ut->nr_of_lus
+	&& h->pgci_ut->lu[i].lang_code != lang)
+    i++;
+  if(i == h->pgci_ut->nr_of_lus) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCLanguageNotFound,
+	    (char)(lang >> 8), (char)(lang & 0xff),
+	    (char)(h->pgci_ut->lu[0].lang_code >> 8),
+	    (char)(h->pgci_ut->lu[0].lang_code & 0xff));
+    mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_LIBMPDVDNAV_VmCMenuLanguagesAvailable);
+    for(i = 0; i < h->pgci_ut->nr_of_lus; i++) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "%c%c ",
+	    (char)(h->pgci_ut->lu[i].lang_code >> 8),
+	    (char)(h->pgci_ut->lu[i].lang_code & 0xff));
+    }
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+    i = 0; /*  error? */
+  }
+
+  return h->pgci_ut->lu[i].pgcit;
+}
+
+/* Uses state to decide what to return */
+static pgcit_t* get_PGCIT(vm_t *vm) {
+  pgcit_t *pgcit;
+
+  switch ((vm->state).domain) {
+  case VTS_DOMAIN:
+    pgcit = vm->vtsi->vts_pgcit;
+    break;
+  case VTSM_DOMAIN:
+    pgcit = get_MENU_PGCIT(vm, vm->vtsi, (vm->state).registers.SPRM[0]);
+    break;
+  case VMGM_DOMAIN:
+  case FP_DOMAIN:
+    pgcit = get_MENU_PGCIT(vm, vm->vmgi, (vm->state).registers.SPRM[0]);
+    break;
+  default:
+    abort();
+  }
+
+  return pgcit;
+}
+
+
+/* Debug functions */
+
+#ifdef USE_MPDVDNAV_TRACE
+void vm_position_print(vm_t *vm, vm_position_t *position) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "libdvdnav: But=%x Spu=%x Aud=%x Ang=%x Hop=%x vts=%x dom=%x cell=%x cell_restart=%x cell_start=%x still=%x block=%x\n",
+  position->button,
+  position->spu_channel,
+  position->audio_channel,
+  position->angle_channel,
+  position->hop_channel,
+  position->vts,
+  position->domain,
+  position->cell,
+  position->cell_restart,
+  position->cell_start,
+  position->still,
+  position->block);
+}
+#endif
+
+#ifdef USE_MPDVDNAV
+void vm_play_pgc(vm_t *vm)
+{
+  process_command(vm, play_PGC(vm));
+}
+
+void vm_play_cell(vm_t *vm)
+{
+  play_Cell(vm);
+}
+
+int vm_get_PGCN(vm_t *vm) { return get_PGCN(vm); }
+#endif
diff -r 448a43f59a37 libmpdvdnav/vm.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/vm.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2000, 2001 Hkan Hjort
+ * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is modified
+ * from a file originally part of the Ogle DVD player.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: vm.h,v 1.1 2004/01/11 21:43:13 mroi Exp $
+ *
+ */
+
+#ifndef VM_H_INCLUDED
+#define VM_H_INCLUDED
+
+#include "remap.h"
+#include "dvdnav_internal.h"
+
+/* DOMAIN enum */
+
+typedef enum {
+  FP_DOMAIN   = 1,
+  VTS_DOMAIN  = 2,
+  VMGM_DOMAIN = 4,
+  VTSM_DOMAIN = 8
+} domain_t;
+
+/**
+ * State: SPRM, GPRM, Domain, pgc, pgN, cellN, ?
+ */
+typedef struct {
+  registers_t registers;
+
+  domain_t  domain;
+  int       vtsN;         /* 0 is vmgm? */
+  pgc_t    *pgc;          /* either this or 'int pgcN' is enough? */
+  int       pgcN;         /* but provide pgcN for quick lookup */
+  int       pgN;          /* is this needed? can allways fid pgN from cellN? */
+  int       cellN;
+  int32_t   cell_restart; /* get cell to restart */
+  int       blockN;
+
+  /* Resume info */
+  int      rsm_vtsN;
+  int      rsm_blockN;    /* of nav_packet */
+  uint16_t rsm_regs[5];   /* system registers 4-8 */
+  int      rsm_pgcN;
+  int      rsm_cellN;
+} dvd_state_t;
+
+typedef struct vm_position_s {
+  int16_t  button;        /* Button highlighted */
+  int32_t  vts;           /* vts number to use */
+  domain_t domain;        /* domain to use */
+  int32_t  spu_channel;   /* spu channel to use */
+  int32_t  angle_channel; /* angle channel to use */
+  int32_t  audio_channel; /* audio channel to use */
+  int32_t  hop_channel;   /* channel hopping. E.g menu button pressed */
+#if 0
+  /* currently unused */
+  int32_t  title;         /* title number */
+  int32_t  chapter;       /* chapter number */
+#endif
+  int32_t  cell;          /* cell number */
+  int32_t  cell_restart;  /* get cell to restart */
+  int32_t  cell_start;    /* sector number of start of current cell in use */
+  int32_t  still;         /* is cell still */
+  int32_t  block;         /* block number within cell in use */
+} vm_position_t;
+
+typedef struct {
+  dvd_reader_t *dvd;
+  ifo_handle_t *vmgi;
+  ifo_handle_t *vtsi;
+  dvd_state_t   state;
+  int32_t       hop_channel;
+  char          dvd_name[50];
+  remap_t      *map;
+  int           stopped;
+#ifdef USE_MPDVDNAV
+  int 	   	pgc_post_flag;
+  int		auto_action_mode;
+#endif
+} vm_t;
+
+/* magic number for seeking hops */
+#define HOP_SEEK 0x1000
+
+
+/*  Audio stream number */
+#define AST_REG      registers.SPRM[1]
+/*  Subpicture stream number */
+#define SPST_REG     registers.SPRM[2]
+/*  Angle number */
+#define AGL_REG      registers.SPRM[3]
+/*  Title Track Number */
+#define TTN_REG      registers.SPRM[4]
+/*  VTS Title Track Number */
+#define VTS_TTN_REG  registers.SPRM[5]
+/*  PGC Number for this Title Track */
+#define TT_PGCN_REG  registers.SPRM[6]
+/*  Current Part of Title (PTT) number for (One_Sequential_PGC_Title) */
+#define PTTN_REG     registers.SPRM[7]
+/*  Highlighted Button Number (btn nr 1 == value 1024) */
+#define HL_BTNN_REG  registers.SPRM[8]
+/*  Parental Level */
+#define PTL_REG      registers.SPRM[13]
+
+/* Initialisation & destruction */
+vm_t *vm_new_vm(void);
+void  vm_free_vm(vm_t *vm);
+
+/* IFO access */
+ifo_handle_t *vm_get_vmgi(vm_t *vm);
+ifo_handle_t *vm_get_vtsi(vm_t *vm);
+
+/* Reader Access */
+dvd_reader_t *vm_get_dvd_reader(vm_t *vm);
+
+/* Basic Handling */
+void vm_start(vm_t *vm);
+void vm_stop(vm_t *vm);
+int  vm_reset(vm_t *vm, const char *dvdroot);
+
+/* copying and merging  - useful for try-running an operation */
+vm_t *vm_new_copy(vm_t *vm);
+void  vm_merge(vm_t *target, vm_t *source);
+void  vm_free_copy(vm_t *vm);
+
+/* regular playback */
+void vm_position_get(vm_t *vm, vm_position_t *position);
+void vm_get_next_cell(vm_t *vm);
+
+/* Jumping - all these return 1, if a hop has been performed */
+int vm_jump_pg(vm_t *vm, int pg);
+int vm_jump_cell_block(vm_t *vm, int cell, int block);
+int vm_jump_title_part(vm_t *vm, int title, int part);
+int vm_jump_top_pg(vm_t *vm);
+int vm_jump_next_pg(vm_t *vm);
+int vm_jump_prev_pg(vm_t *vm);
+int vm_jump_up(vm_t *vm);
+int vm_jump_menu(vm_t *vm, DVDMenuID_t menuid);
+int vm_jump_resume(vm_t *vm);
+int vm_exec_cmd(vm_t *vm, vm_cmd_t *cmd);
+
+/* getting information */
+int vm_get_current_menu(vm_t *vm, int *menuid);
+int vm_get_current_title_part(vm_t *vm, int *title_result, int *part_result);
+int vm_get_audio_stream(vm_t *vm, int audioN);
+int vm_get_subp_stream(vm_t *vm, int subpN, int mode);
+int vm_get_audio_active_stream(vm_t *vm);
+int vm_get_subp_active_stream(vm_t *vm, int mode);
+void vm_get_angle_info(vm_t *vm, int *current, int *num_avail);
+#if 0
+/* currently unused */
+void vm_get_audio_info(vm_t *vm, int *current, int *num_avail);
+void vm_get_subp_info(vm_t *vm, int *current, int *num_avail);
+void vm_get_video_res(vm_t *vm, int *width, int *height);
+#endif
+int  vm_get_video_aspect(vm_t *vm);
+int  vm_get_video_scale_permission(vm_t *vm);
+video_attr_t vm_get_video_attr(vm_t *vm);
+audio_attr_t vm_get_audio_attr(vm_t *vm, int streamN);
+subp_attr_t  vm_get_subp_attr(vm_t *vm, int streamN);
+
+#ifdef USE_MPDVDNAV
+void vm_play_pgc(vm_t *vm);
+void vm_play_cell(vm_t *vm);
+#endif
+
+#ifdef USE_MPDVDNAV_TRACE
+/* Debug */
+void vm_position_print(vm_t *vm, vm_position_t *position);
+#endif
+
+#ifdef USE_MPDVDNAV
+int vm_get_PGCN(vm_t *vm);
+#endif
+
+
+#endif /* VM_HV_INCLUDED */
diff -r 448a43f59a37 libmpdvdnav/vmcmd.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/vmcmd.c	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,549 @@
+/*
+ * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
+ *               2002-2004 the dvdnav project
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is modified
+ * from a file originally part of the Ogle DVD player.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: vmcmd.c,v 1.2 2004/03/03 16:50:42 mroi Exp $
+ *
+ */
+
+#ifndef HAVE_MPLAYER
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#else
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <inttypes.h>
+
+#include "dvdnav_internal.h"
+
+#ifdef USE_MPDVDNAV
+#include "../mp_msg.h"
+#include "../help_mp.h"
+#endif
+
+
+/*  freebsd compatibility */
+#ifndef PRIu8
+#define PRIu8 "d"
+#endif
+
+/*  freebsd compatibility */
+#ifndef PRIu16
+#define PRIu16 "d"
+#endif
+
+static const char *cmp_op_table[] = {
+  NULL, "&", "==", "!=", ">=", ">", "<=", "<"
+};
+static const char *set_op_table[] = {
+  NULL, "=", "<->", "+=", "-=", "*=", "/=", "%=", "rnd", "&=", "|=", "^="
+};
+
+static const char *link_table[] = {
+  "LinkNoLink",  "LinkTopC",    "LinkNextC",   "LinkPrevC",
+  NULL,          "LinkTopPG",   "LinkNextPG",  "LinkPrevPG",
+  NULL,          "LinkTopPGC",  "LinkNextPGC", "LinkPrevPGC",
+  "LinkGoUpPGC", "LinkTailPGC", NULL,          NULL,
+  "RSM"
+};
+
+static const char *system_reg_table[] = {
+  "Menu Description Language Code",
+  "Audio Stream Number",
+  "Sub-picture Stream Number",
+  "Angle Number",
+  "Title Track Number",
+  "VTS Title Track Number",
+  "VTS PGC Number",
+  "PTT Number for One_Sequential_PGC_Title",
+  "Highlighted Button Number",
+  "Navigation Timer",
+  "Title PGC Number for Navigation Timer",
+  "Audio Mixing Mode for Karaoke",
+  "Country Code for Parental Management",
+  "Parental Level",
+  "Player Configurations for Video",
+  "Player Configurations for Audio",
+  "Initial Language Code for Audio",
+  "Initial Language Code Extension for Audio",
+  "Initial Language Code for Sub-picture",
+  "Initial Language Code Extension for Sub-picture",
+  "Player Regional Code",
+  "Reserved 21",
+  "Reserved 22",
+  "Reserved 23"
+};
+
+static const char *system_reg_abbr_table[] = {
+  NULL,
+  "ASTN",
+  "SPSTN",
+  "AGLN",
+  "TTN",
+  "VTS_TTN",
+  "TT_PGCN",
+  "PTTN",
+  "HL_BTNN",
+  "NVTMR",
+  "NV_PGCN",
+  NULL,
+  "CC_PLT",
+  "PLT",
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+};
+
+static void print_system_reg(uint16_t reg) {
+  if(reg < sizeof(system_reg_abbr_table) / sizeof(char *))
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%s (SRPM:%d)", system_reg_table[reg], reg);
+  else
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown system register ( reg=%d ) ", reg);
+}
+
+static void print_g_reg(uint8_t reg) {
+    if(reg < 16)
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "g[%" PRIu8 "]", reg);
+    else
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown general register ");
+}
+
+static void print_reg(uint8_t reg) {
+  if(reg & 0x80)
+    print_system_reg(reg & 0x7f);
+  else
+    print_g_reg(reg & 0x7f);
+}
+
+static void print_cmp_op(uint8_t op) {
+  if(op < sizeof(cmp_op_table) / sizeof(char *) && cmp_op_table[op] != NULL)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %s ", cmp_op_table[op]);
+  else
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown compare op ");
+}
+
+static void print_set_op(uint8_t op) {
+  if(op < sizeof(set_op_table) / sizeof(char *) && set_op_table[op] != NULL)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %s ", set_op_table[op]);
+  else
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " WARNING: Unknown set op ");
+}
+
+static void print_reg_or_data(command_t* command, int immediate, int start) {
+  if(immediate) {
+    uint32_t i = vm_getbits(command, start, 16);
+
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "0x%x", i);
+    if(isprint(i & 0xff) && isprint((i>>8) & 0xff))
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " (\"%c%c\")", (char)((i>>8) & 0xff), (char)(i & 0xff));
+  } else {
+    print_reg(vm_getbits(command, start - 8, 8));
+  }
+}
+
+static void print_reg_or_data_2(command_t* command, int immediate, int start) {
+  if(immediate)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "0x%x", vm_getbits(command, start - 1, 7));
+  else
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "g[%" PRIu8 "]", vm_getbits(command, start - 4, 4));
+}
+
+static void print_reg_or_data_3(command_t* command, int immediate, int start) {
+  if(immediate) {
+    uint32_t i = vm_getbits(command, start, 16);
+
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "0x%x", i);
+    if(isprint(i & 0xff) && isprint((i>>8) & 0xff))
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " (\"%c%c\")", (char)((i>>8) & 0xff), (char)(i & 0xff));
+  } else {
+    print_reg(vm_getbits(command, start, 8));
+  }
+}
+
+
+static void print_if_version_1(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+
+  if(op) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+    print_g_reg(vm_getbits(command,39,8));
+    print_cmp_op(op);
+    print_reg_or_data(command, vm_getbits(command, 55,1), 31);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+  }
+}
+
+static void print_if_version_2(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+
+  if(op) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+    print_reg(vm_getbits(command, 15, 8));
+    print_cmp_op(op);
+    print_reg(vm_getbits(command, 7, 8));
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+  }
+}
+
+static void print_if_version_3(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+
+  if(op) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+    print_g_reg(vm_getbits(command, 43, 4));
+    print_cmp_op(op);
+    print_reg_or_data(command, vm_getbits(command, 55, 1), 15);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+  }
+}
+
+static void print_if_version_4(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+
+  if(op) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+    print_g_reg(vm_getbits(command, 51, 4));
+    print_cmp_op(op);
+    print_reg_or_data(command, vm_getbits(command, 55, 1), 31);
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+  }
+}
+
+static void print_if_version_5(command_t* command) {
+  uint8_t op = vm_getbits(command, 54, 3);
+  int set_immediate = vm_getbits(command, 60, 1);
+
+  if(op) {
+    if (set_immediate) {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+      print_g_reg(vm_getbits(command, 31, 8));
+      print_cmp_op(op);
+      print_reg(vm_getbits(command, 23, 8));
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+    } else {
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "if (");
+      print_g_reg(vm_getbits(command, 39, 8));
+      print_cmp_op(op);
+      print_reg_or_data(command, vm_getbits(command, 55, 1), 31);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, ") ");
+    }
+  }
+}
+
+static void print_special_instruction(command_t* command) {
+  uint8_t op = vm_getbits(command, 51, 4);
+
+  switch(op) {
+    case 0: /*  NOP */
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Nop");
+      break;
+    case 1: /*  Goto line */
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Goto %" PRIu8, vm_getbits(command, 7, 8));
+      break;
+    case 2: /*  Break */
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Break");
+      break;
+    case 3: /*  Parental level */
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "SetTmpPML %" PRIu8 ", Goto %" PRIu8,
+	      vm_getbits(command, 11, 4), vm_getbits(command, 7, 8));
+      break;
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown special instruction (%i)",
+	      vm_getbits(command, 51, 4));
+  }
+}
+
+static void print_linksub_instruction(command_t* command) {
+  uint32_t linkop = vm_getbits(command, 7, 8);
+  uint32_t button = vm_getbits(command, 15, 6);
+
+  if(linkop < sizeof(link_table)/sizeof(char *) && link_table[linkop] != NULL)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%s (button %" PRIu8 ")", link_table[linkop], button);
+  else
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown linksub instruction (%i)", linkop);
+}
+
+static void print_link_instruction(command_t* command, int optional) {
+  uint8_t op = vm_getbits(command, 51, 4);
+
+  if(optional && op)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, ", ");
+
+  switch(op) {
+    case 0:
+      if(!optional)
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: NOP (link)!");
+      break;
+    case 1:
+      print_linksub_instruction(command);
+      break;
+    case 4:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkPGCN %" PRIu16, vm_getbits(command, 14, 15));
+      break;
+    case 5:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkPTT %" PRIu16 " (button %" PRIu8 ")",
+	      vm_getbits(command, 9, 10), vm_getbits(command, 15, 6));
+      break;
+    case 6:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkPGN %" PRIu8 " (button %" PRIu8 ")",
+	      vm_getbits(command, 6, 7), vm_getbits(command, 15, 6));
+      break;
+    case 7:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "LinkCN %" PRIu8 " (button %" PRIu8 ")",
+	      vm_getbits(command, 7, 8), vm_getbits(command, 15, 6));
+      break;
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown link instruction");
+  }
+}
+
+static void print_jump_instruction(command_t* command) {
+  switch(vm_getbits(command, 51, 4)) {
+    case 1:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "Exit");
+      break;
+    case 2:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpTT %" PRIu8, vm_getbits(command, 22, 7));
+      break;
+    case 3:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpVTS_TT %" PRIu8, vm_getbits(command, 22, 7));
+      break;
+    case 5:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpVTS_PTT %" PRIu8 ":%" PRIu16,
+	      vm_getbits(command, 22, 7), vm_getbits(command, 41, 10));
+      break;
+    case 6:
+      switch(vm_getbits(command, 23, 2)) {
+        case 0:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS FP");
+          break;
+        case 1:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS VMGM (menu %" PRIu8 ")", vm_getbits(command, 19, 4));
+          break;
+        case 2:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS VTSM (vts %" PRIu8 ", title %" PRIu8
+		  ", menu %" PRIu8 ")", vm_getbits(command, 30, 7), vm_getbits(command, 38, 7), vm_getbits(command, 19, 4));
+          break;
+        case 3:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "JumpSS VMGM (pgc %" PRIu8 ")", vm_getbits(command, 46, 15));
+          break;
+        }
+      break;
+    case 8:
+      switch(vm_getbits(command, 23, 2)) {
+        case 0:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS FP (rsm_cell %" PRIu8 ")",
+              vm_getbits(command, 31, 8));
+          break;
+        case 1:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS VMGM (menu %" PRIu8
+		  ", rsm_cell %" PRIu8 ")", vm_getbits(command, 19, 4), vm_getbits(command, 31, 8));
+          break;
+        case 2:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS VTSM (menu %" PRIu8
+		  ", rsm_cell %" PRIu8 ")", vm_getbits(command, 19, 4), vm_getbits(command, 31, 8));
+          break;
+        case 3:
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, "CallSS VMGM (pgc %" PRIu8 ", rsm_cell %" PRIu8 ")",
+		  vm_getbits(command, 46, 15), vm_getbits(command, 31, 8));
+          break;
+      }
+      break;
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown Jump/Call instruction");
+  }
+}
+
+static void print_system_set(command_t* command) {
+  int i;
+/* FIXME: What about SPRM11 ? Karaoke */
+/*        Surely there must be some system set command for that ? */
+
+  switch(vm_getbits(command, 59, 4)) {
+    case 1: /*  Set system reg 1 &| 2 &| 3 (Audio, Subp. Angle) */
+      for(i = 1; i <= 3; i++) {
+        if(vm_getbits(command, 47 - (i*8), 1)) {
+          print_system_reg(i);
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, " = ");
+          print_reg_or_data_2(command, vm_getbits(command, 60, 1), 47 - (i*8) );
+          mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+        }
+      }
+      break;
+    case 2: /*  Set system reg 9 & 10 (Navigation timer, Title PGC number) */
+      print_system_reg(9);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " = ");
+      print_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " ");
+      print_system_reg(10);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " = %" PRIu16, vm_getbits(command, 30, 15)); /*  ?? */
+      break;
+    case 3: /*  Mode: Counter / Register + Set */
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "SetMode ");
+      if(vm_getbits(command, 23, 1))
+	mp_msg(MSGT_CPLAYER,MSGL_INFO, "Counter ");
+      else
+	mp_msg(MSGT_CPLAYER,MSGL_INFO, "Register ");
+      print_g_reg(vm_getbits(command, 19, 4));
+      print_set_op(0x1); /*  '=' */
+      print_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+      break;
+    case 6: /*  Set system reg 8 (Highlighted button) */
+      print_system_reg(8);
+      if(vm_getbits(command, 60, 1)) /*  immediate */
+        mp_msg(MSGT_CPLAYER,MSGL_INFO, " = 0x%x (button no %d)", vm_getbits(command, 31, 16), vm_getbits(command, 31, 6));
+      else
+        mp_msg(MSGT_CPLAYER,MSGL_INFO, " = g[%" PRIu8 "]", vm_getbits(command, 19, 4));
+      break;
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown system set instruction (%i)",
+	      vm_getbits(command, 59, 4));
+  }
+}
+
+static void print_set_version_1(command_t* command) {
+  uint8_t set_op = vm_getbits(command, 59, 4);
+
+  if(set_op) {
+    print_g_reg(vm_getbits(command, 35, 4));
+    print_set_op(set_op);
+    print_reg_or_data(command, vm_getbits(command, 60, 1), 31);
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "NOP");
+  }
+}
+
+static void print_set_version_2(command_t* command) {
+  uint8_t set_op = vm_getbits(command, 59, 4);
+
+  if(set_op) {
+    print_g_reg(vm_getbits(command, 51, 4));
+    print_set_op(set_op);
+    print_reg_or_data(command, vm_getbits(command, 60, 1), 47);
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "NOP");
+  }
+}
+
+static void print_set_version_3(command_t* command) {
+  uint8_t set_op = vm_getbits(command, 59, 4);
+
+  if(set_op) {
+    print_g_reg(vm_getbits(command, 51, 4));
+    print_set_op(set_op);
+    print_reg_or_data_3(command, vm_getbits(command, 60, 1), 47);
+  } else {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "NOP");
+  }
+}
+
+
+void vm_print_mnemonic(vm_cmd_t *vm_command)  {
+  command_t command;
+  command.instruction =( (uint64_t) vm_command->bytes[0] << 56 ) |
+        ( (uint64_t) vm_command->bytes[1] << 48 ) |
+        ( (uint64_t) vm_command->bytes[2] << 40 ) |
+        ( (uint64_t) vm_command->bytes[3] << 32 ) |
+        ( (uint64_t) vm_command->bytes[4] << 24 ) |
+        ( (uint64_t) vm_command->bytes[5] << 16 ) |
+        ( (uint64_t) vm_command->bytes[6] <<  8 ) |
+          (uint64_t) vm_command->bytes[7] ;
+  command.examined = 0;
+
+  switch(vm_getbits(&command,63,3)) { /* three first bits */
+    case 0: /*  Special instructions */
+      print_if_version_1(&command);
+      print_special_instruction(&command);
+      break;
+    case 1: /*  Jump/Call or Link instructions */
+      if(vm_getbits(&command,60,1)) {
+        print_if_version_2(&command);
+        print_jump_instruction(&command);
+      } else {
+        print_if_version_1(&command);
+        print_link_instruction(&command, 0); /*  must be pressent */
+      }
+      break;
+    case 2: /*  Set System Parameters instructions */
+      print_if_version_2(&command);
+      print_system_set(&command);
+      print_link_instruction(&command, 1); /*  either 'if' or 'link' */
+      break;
+    case 3: /*  Set General Parameters instructions */
+      print_if_version_3(&command);
+      print_set_version_1(&command);
+      print_link_instruction(&command, 1); /*  either 'if' or 'link' */
+      break;
+    case 4: /*  Set, Compare -> LinkSub instructions */
+      print_set_version_2(&command);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, ", ");
+      print_if_version_4(&command);
+      print_linksub_instruction(&command);
+      break;
+    case 5: /*  Compare -> (Set and LinkSub) instructions */
+      print_if_version_5(&command);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "{ ");
+      print_set_version_3(&command);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, ", ");
+      print_linksub_instruction(&command);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " }");
+      break;
+    case 6: /*  Compare -> Set, always LinkSub instructions */
+      print_if_version_5(&command);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "{ ");
+      print_set_version_3(&command);
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, " } ");
+      print_linksub_instruction(&command);
+      break;
+    default:
+      mp_msg(MSGT_CPLAYER,MSGL_INFO, "WARNING: Unknown instruction type (%i)", vm_getbits(&command, 63, 3));
+  }
+  /*  Check if there still are bits set that were not examined */
+
+  if(command.instruction & ~ command.examined) {
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " libdvdnav: vmcmd.c: [WARNING, unknown bits:");
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, " %08llx", (command.instruction & ~ command.examined) );
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "]");
+  }
+}
+
+void vm_print_cmd(int row, vm_cmd_t *vm_command) {
+  int i;
+
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "(%03d) ", row + 1);
+  for(i = 0; i < 8; i++)
+    mp_msg(MSGT_CPLAYER,MSGL_INFO, "%02x ", vm_command->bytes[i]);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "| ");
+
+  vm_print_mnemonic(vm_command);
+  mp_msg(MSGT_CPLAYER,MSGL_INFO, "\n");
+}
+
diff -r 448a43f59a37 libmpdvdnav/vmcmd.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmpdvdnav/vmcmd.h	Sun Apr 30 17:14:32 2006 +0200
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
+ *
+ * This file is part of libdvdnav, a DVD navigation library. It is modified
+ * from a file originally part of the Ogle DVD player.
+ *
+ * libdvdnav is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libdvdnav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: vmcmd.h,v 1.1 2004/01/11 21:43:13 mroi Exp $
+ *
+ */
+
+#ifndef VMCMD_H_INCLUDED
+#define VMCMD_H_INCLUDED
+
+#include <inttypes.h>
+
+void vm_print_mnemonic(vm_cmd_t *command);
+void vm_print_cmd(int row, vm_cmd_t *command);
+
+#endif /* VMCMD_H_INCLUDED */
