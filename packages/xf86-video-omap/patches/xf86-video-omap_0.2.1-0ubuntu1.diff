--- xf86-video-omap-0.2.1.orig/debian/xserver-xorg-video-omap.install
+++ xf86-video-omap-0.2.1/debian/xserver-xorg-video-omap.install
@@ -0,0 +1,2 @@
+usr/lib/xorg/modules/drivers/omap_drv.so
+usr/share/man/man4/omap.4
--- xf86-video-omap-0.2.1.orig/debian/compat
+++ xf86-video-omap-0.2.1/debian/compat
@@ -0,0 +1 @@
+7
--- xf86-video-omap-0.2.1.orig/debian/xserver-xorg-video-omap-dev.install
+++ xf86-video-omap-0.2.1/debian/xserver-xorg-video-omap-dev.install
@@ -0,0 +1 @@
+usr/include/*
--- xf86-video-omap-0.2.1.orig/debian/copyright
+++ xf86-video-omap-0.2.1/debian/copyright
@@ -0,0 +1,65 @@
+xf86-video-omap was packaged for Debian by:
+
+    David Bercovitz <d-bercovitz@ti.com> on Thu, 08 Dec 2011 14:45:01 +0200
+
+Original source code was downloaded from <git://github.com/robclark/xf86-video-omap.git>
+
+Copyright:
+
+    Copyright(c) 2011 Texas Instruments. All rights reserved.     
+    All rights reserved.                                                  
+                                                                      
+    Redistribution and use in source and binary forms, with or without    
+    modification, are permitted provided that the following conditions    
+    are met:                                                              
+                                                                      
+    * Redistributions of source code must retain the above copyright     
+      notice, this list of conditions and the following disclaimer.      
+    * Redistributions in binary form must reproduce the above copyright  
+      notice, this list of conditions and the following disclaimer in    
+      the documentation and/or other materials provided with the         
+      distribution.                                                      
+    * Neither the name Texas Instruments nor the names of its            
+      contributors may be used to endorse or promote products derived    
+      from this software without specific prior written permission.      
+                                                                      
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   
+    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     
+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  
+    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      
+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   
+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+License:
+
+    GPL-2 (GNU GPL Version 2),
+   
+    This package is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License version 2 as
+    published by the Free Software Foundation.
+
+    This package is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this package; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+
+On Debian systems, the complete text of the GNU General
+Public License version 2 can be found in `/usr/share/common-licenses/GPL-2'.
+
+The Debian packaging is:
+
+    Copyright (C) 2011 David Bercovitz <d-bercovitz@ti.com>
+
+you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
--- xf86-video-omap-0.2.1.orig/debian/changelog
+++ xf86-video-omap-0.2.1/debian/changelog
@@ -0,0 +1,113 @@
+xf86-video-omap (0.2.1-0ubuntu1) precise; urgency=low
+
+  * New upstream
+  * Properties and dri2video support added as patches
+
+ -- Xavier Boudet <x-boudet@ti.com>  Mon, 23 Apr 2012 11:33:50 +0000
+
+xf86-video-omap (0.2.0-0ubuntu2) precise; urgency=low
+
+  * Add dri2-blit-complete.patch 
+
+ -- Xavier Boudet <x-boudet@ti.com>  Thu, 19 Apr 2012 15:45:09 +0000
+
+xf86-video-omap (0.2.0-0ubuntu1) precise; urgency=low
+
+  * New upstream
+  * Properties and dri2video support added as patches
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 18 Apr 2012 09:04:36 +0000
+
+xf86-video-omap (0.1.0-0ubuntu1) precise; urgency=low
+
+  * New upstream rebase for properties
+  * Add dri2video patch 
+
+ -- Xavier Boudet <x-boudet@ti.com>  Thu, 12 Apr 2012 09:16:16 +0000
+
+xf86-video-omap (0.0.4-0ubuntu8) precise; urgency=low
+
+  * Support rotation properties
+
+ -- Xavier Boudet <x-boudet@ti.com>  Thu, 05 Apr 2012 17:22:33 +0200
+
+xf86-video-omap (0.0.4-0ubuntu7) precise; urgency=low
+
+  * Support rotation and no rotation
+
+ -- Xavier Boudet <x-boudet@ti.com>  Mon, 02 Apr 2012 16:15:00 +0000
+
+xf86-video-omap (0.0.4-0ubuntu6) precise; urgency=low
+
+  * Enable rotation 
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 28 Mar 2012 18:13:43 +0000
+
+xf86-video-omap (0.0.4-0ubuntu5) precise; urgency=low
+
+  * Update dependencies version for libdri2-dev and libdrm-dev
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 28 Mar 2012 15:41:58 +0000
+
+xf86-video-omap (0.0.4-0ubuntu4) precise; urgency=low
+
+  * Disable rotation
+  * add package xserver-xorg-video-omap-dev
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 28 Mar 2012 08:39:12 +0000
+
+xf86-video-omap (0.0.4-0ubuntu3) precise; urgency=low
+
+  * Fix debian/rules issue 
+
+ -- Xavier Boudet <x-boudet@ti.com>  Thu, 22 Mar 2012 16:43:11 +0000
+
+xf86-video-omap (0.0.4-0ubuntu2) precise; urgency=low
+
+  * Rebuild vs xserver-xorg-dev >= 2:1.11.4-0ubuntu7+ti1.1 for rotation 
+  * Add xrandr-rotation.patch
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 21 Mar 2012 17:31:33 +0000
+
+xf86-video-omap (0.0.4-0ubuntu1) precise; urgency=low
+
+  * Added dri2video support
+  * Incremented libdri2 dependency version
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Thu, 01 Mar 2012 15:05:50 +0100
+
+xf86-video-omap (0.0.3-0ubuntu2) precise; urgency=low
+
+  * Updated libdrm dependency and added dep on libdri2 
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Fri, 17 Feb 2012 14:47:17 +0100
+
+xf86-video-omap (0.0.3-0ubuntu1) precise; urgency=low
+
+  * Updated package with new upstream source code
+    Fixed the FOURCC macros definitions
+    Rob's commit ID e438755dbb921e47252f91a19aba7f0347e1482f 
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Mon, 30 Jan 2012 10:56:40 +0100
+
+xf86-video-omap (0.0.2-0ubuntu1) precise; urgency=low
+
+  * Updated package with new upstream source code per
+    Rob's notification to update.
+
+  * Also updated from oneiric to precise as Rob is now
+    testing with xserver and filesystem from Precise.
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Mon, 16 Jan 2012 11:07:50 +0100
+
+xf86-video-omap (0.0.1-0ubuntu2) oneiric; urgency=low
+
+  * Corrected libdrm-dev version dependency in the control file
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Wed, 11 Jan 2012 11:56:38 +0100
+
+xf86-video-omap (0.0.1-0ubuntu1) oneiric; urgency=low
+
+  * Initial Ubuntu Package
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Thu, 08 Dec 2011 14:45:41 +0200
--- xf86-video-omap-0.2.1.orig/debian/rules
+++ xf86-video-omap-0.2.1/debian/rules
@@ -0,0 +1,25 @@
+#!/usr/bin/make -f
+
+override_dh_autoreconf:
+	mkdir m4
+	dh_autoreconf
+
+override_dh_autoreconf_clean:
+	dh_autoreconf_clean
+	rm -rf m4
+
+override_dh_strip:
+	dh_strip --dbg-package=xserver-xorg-video-omap-dbg
+
+override_dh_auto_install:
+	dh_auto_install --destdir=debian/tmp
+
+override_dh_installdocs:
+	dh_installdocs --link-doc=xserver-xorg-video-omap
+
+# use appropriate warning level for a plugin
+override_dh_shlibdeps:
+	dh_shlibdeps -- --warnings=6
+
+%:
+	dh $@ --with quilt,autoreconf,xsf --builddirectory=build/
--- xf86-video-omap-0.2.1.orig/debian/control
+++ xf86-video-omap-0.2.1/debian/control
@@ -0,0 +1,84 @@
+Source: xf86-video-omap
+Section: x11
+Priority: optional
+Maintainer: TI OMAP Developers <tiomap-dev@lists.launchpad.net>
+Build-Depends: 
+ debhelper (>= 8.1.2ubuntu2),
+ dh-autoreconf,
+ quilt,
+ pkg-config,
+ xutils-dev (>= 1:7.6+5),
+ xserver-xorg-dev (>= 2:1.11.4-0ubuntu7+ti1.1),
+ libxext-dev (>= 2:1.3.0),
+ libudev-dev (>= 173),
+ x11proto-core-dev (>= 7.0.22),
+ x11proto-fonts-dev (>= 2.1.1),
+ x11proto-xf86dri-dev (>= 2.1.1),
+ libdrm-dev (>= 2.4.32-1ubuntu1+ti1.2),
+ libdri2-dev (>= 1.0.2-0ubuntu3),
+Standards-Version: 3.9.2
+Vcs-Git: git://github.com/robclark/xf86-video-omap.git
+Vcs-Browser: http://github.com/robclark/xf86-video-omap.git
+
+Package: xserver-xorg-video-omap
+Architecture: armel armhf
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends},
+ ${xviddriver:Depends}
+Provides: ${xviddriver:Provides}
+Description: X.org graphics -- TI OMAP display driver
+ This driver for the X.org server provides support for OMAP3 and
+ newer devices. Currently it relies on a closed-source submodule
+ for EXA acceleration on the following chipsets:
+  + OMAP3430
+  + OMAP3630
+  + OMAP4430
+  + OMAP4460
+ .
+ The driver depends on omapdrm driver in the kernel with 
+ GEM support.
+ .
+ More information about X.org can be found at:
+  * <URL:http://www.X.org>
+  * <URL:http://xorg.freedesktop.org>
+  * <URL:http://lists.freedesktop.org/mailman/listinfo/xorg>
+
+Package: xserver-xorg-video-omap-dbg
+Architecture: armel armhf
+Section: debug
+Priority: extra
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends},
+ xserver-xorg-video-omap (= ${binary:Version})
+Description: X.org graphics -- TI OMAP display driver (debug symbols)
+ This driver for the X.org server provides debug symbols support for 
+ OMAP3 and newer devices. Currently it relies on a closed-source submodule
+ for EXA acceleration on the following chipsets:
+  + OMAP3430
+  + OMAP3630
+  + OMAP4430
+  + OMAP4460
+ .
+ The driver depends on omapdrm driver in the kernel with 
+ GEM support.
+ .
+ More information about X.org can be found at: 
+  * <URL:http://www.X.org>
+  * <URL:http://xorg.freedesktop.org>
+  * <URL:http://lists.freedesktop.org/mailman/listinfo/xorg>
+ .
+ This package contains debug symbols for xserver-xorg-video-omap.
+
+Package: xserver-xorg-video-omap-dev
+Architecture: armel armhf
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends},
+ xserver-xorg-video-omap (= ${binary:Version})
+Description: X.org graphics -- TI OMAP display driver Headers
+ This package provides Headers for  xserver-xorg-video-omap
--- xf86-video-omap-0.2.1.orig/debian/patches/0002-fix-build-with-older-xserver.patch
+++ xf86-video-omap-0.2.1/debian/patches/0002-fix-build-with-older-xserver.patch
@@ -0,0 +1,32 @@
+From 47840b37e272b615825624ae3125e6f1a381b95f Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Tue, 10 Apr 2012 17:06:17 -0500
+Subject: [PATCH 2/4] fix build with older xserver
+
+was missing an #if XF86_CRTC_VERSION >= 4
+---
+ src/drmmode_display.c |    2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/src/drmmode_display.c b/src/drmmode_display.c
+index 7aacf98..9b8413e 100644
+--- a/src/drmmode_display.c
++++ b/src/drmmode_display.c
+@@ -469,12 +469,14 @@ drmmode_show_cursor(xf86CrtcPtr crtc)
+ 		h = crtc->mode.VDisplay - crtc_y;
+ 	}
+ 
++#if XF86_CRTC_VERSION >= 4
+ 	/* NOTE: driver is taking care of rotation in hw, which means
+ 	 * we need to deal w/ transformation of mouse cursor ourself:
+ 	 */
+ 	if (crtc->driverIsPerformingTransform) {
+ 		xf86CrtcTransformCursorPos(crtc, &crtc_x, &crtc_y);
+ 	}
++#endif
+ 
+ 	/* note src coords (last 4 args) are in Q16 format */
+ 	drmModeSetPlane(drmmode->fd, cursor->ovr->plane_id,
+-- 
+1.7.9.5
+
--- xf86-video-omap-0.2.1.orig/debian/patches/0001-xrandr-rotation-v2.patch
+++ xf86-video-omap-0.2.1/debian/patches/0001-xrandr-rotation-v2.patch
@@ -0,0 +1,427 @@
+From c11485761679edb67abc5e7cb0876e48149855d7 Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Thu, 8 Mar 2012 15:47:24 -0600
+Subject: [PATCH 1/4] xrandr rotation (v2)
+
+If XF86_CRTC_VERSION >= 4, on platforms with dmm/tiler (OMAP4+),
+use tiled buffers for scanout buffer to enable rotatated and/or
+mirrored scanout.
+
+This utilizes the RFC crtc/plane properties support to configure
+rotation.  Tiled buffers are only used if rotation is enabled.
+---
+ src/drmmode_display.c |  196 +++++++++++++++++++++++++++++++++++++++----------
+ src/omap_driver.c     |   40 +++++-----
+ src/omap_driver.h     |   12 +++
+ 3 files changed, 191 insertions(+), 57 deletions(-)
+
+diff --git a/src/drmmode_display.c b/src/drmmode_display.c
+index 0dbc01d..7aacf98 100644
+--- a/src/drmmode_display.c
++++ b/src/drmmode_display.c
+@@ -84,6 +84,7 @@
+ #endif
+ 
+ #include "omap_driver.h"
++#include "omap_drm.h"
+ 
+ #include "xf86Crtc.h"
+ 
+@@ -111,11 +112,16 @@ typedef struct {
+ 	struct udev_monitor *uevent_monitor;
+ 	InputHandlerProc uevent_handler;
+ 	drmmode_cursor_ptr cursor;
++	int rotated_crtcs;
+ } drmmode_rec, *drmmode_ptr;
+ 
+ typedef struct {
+ 	drmmode_ptr drmmode;
+ 	drmModeCrtcPtr mode_crtc;
++	Rotation rotation;
++
++	/* properties that we care about: */
++	uint32_t prop_rotation;
+ } drmmode_crtc_private_rec, *drmmode_crtc_private_ptr;
+ 
+ typedef struct {
+@@ -215,6 +221,34 @@ drmmode_crtc_dpms(xf86CrtcPtr drmmode_crtc, int mode)
+ 	// FIXME - Implement this function
+ }
+ 
++#define SUPPORTED_ROTATIONS (RR_Rotate_0 | RR_Rotate_90 | RR_Rotate_180 | RR_Rotate_270 | RR_Reflect_X | RR_Reflect_Y)
++
++static Bool
++drmmode_set_rotation(xf86CrtcPtr crtc, Rotation rotation)
++{
++#if XF86_CRTC_VERSION >= 4
++	ScrnInfoPtr pScrn = crtc->scrn;
++	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
++
++	if (!(rotation & ~SUPPORTED_ROTATIONS)) {
++		int ret;
++
++		ret = drmModeObjectSetProperty(drmmode_crtc->drmmode->fd,
++				drmmode_crtc->mode_crtc->crtc_id,
++				DRM_MODE_OBJECT_CRTC,
++				drmmode_crtc->prop_rotation,
++				rotation);
++		if (ret) {
++			ERROR_MSG("failed to set orientation %s", strerror(errno));
++			return FALSE;
++		}
++
++		crtc->driverIsPerformingTransform = TRUE;
++	}
++#endif
++	return xf86CrtcRotate(crtc);
++}
++
+ static Bool
+ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+ 		Rotation rotation, int x, int y)
+@@ -233,15 +267,48 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+ 	int i;
+ 	int fb_id;
+ 	drmModeModeInfo kmode;
++	Bool was_rotated = drmmode->rotated_crtcs > 0;
+ 
+ 	TRACE_ENTER();
+ 
+ 	/* remove old fb if it exists */
+ 	drmmode_remove_fb(pScrn);
+ 
++	/* update the count of number of rotated CRTCs.. if we have one or more
++	 * rotated outputs then we want to use a tiled buffer, but otherwise
++	 * stick with non-tiled
++	 */
++	if ((drmmode_crtc->rotation != RR_Rotate_0) &&
++			(rotation == RR_Rotate_0)) {
++		DEBUG_MSG("disabling rotation for crtc: %u",
++				drmmode_crtc->mode_crtc->crtc_id);
++		drmmode->rotated_crtcs--;
++	} else if ((drmmode_crtc->rotation == RR_Rotate_0) &&
++			(rotation != RR_Rotate_0)) {
++		DEBUG_MSG("enabling rotation for crtc: %u",
++				drmmode_crtc->mode_crtc->crtc_id);
++		drmmode->rotated_crtcs++;
++	}
++
++	drmmode_crtc->rotation = rotation;
++
++	/* at this point, if we are switching from unrotated to rotated
++	 * or visa versa, then we need to reallocate the scanout buffer..
++	 */
++	if (was_rotated != (drmmode->rotated_crtcs > 0)) {
++		/* reallocate scanout buffer.. */
++		drmmode_reallocate_scanout(pScrn);
++	}
++
++	/* note: this needs to be done before setting the mode, otherwise
++	 * drm core will reject connecting the fb to crtc due to mismatched
++	 * dimensions:
++	 */
++	if (!drmmode_set_rotation(crtc, rotation))
++		goto done;
++
+ 	if (drmmode->fb_id == 0) {
+-		unsigned int pitch =
+-				OMAPCalculateStride(pScrn->virtualX, pScrn->bitsPerPixel);
++		unsigned int pitch = pScrn->displayWidth * (pScrn->bitsPerPixel / 8);
+ 
+ 		DEBUG_MSG("create framebuffer: %dx%d",
+ 				pScrn->virtualX, pScrn->virtualY);
+@@ -290,9 +357,6 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+ 		output_count++;
+ 	}
+ 
+-	if (!xf86CrtcRotate(crtc))
+-		goto done;
+-
+ 	// Fixme - Intel puts this function here, and Nouveau puts it at the end
+ 	// of this function -> determine what's best for TI'S OMAP4:
+ 	crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
+@@ -333,7 +397,7 @@ done:
+ 		free(output_ids);
+ 	}
+ 	if (!ret) {
+-		/* If there was a problem, resture the old mode: */
++		/* If there was a problem, restore the old mode: */
+ 		crtc->x = saved_x;
+ 		crtc->y = saved_y;
+ 		crtc->rotation = saved_rotation;
+@@ -405,6 +469,13 @@ drmmode_show_cursor(xf86CrtcPtr crtc)
+ 		h = crtc->mode.VDisplay - crtc_y;
+ 	}
+ 
++	/* NOTE: driver is taking care of rotation in hw, which means
++	 * we need to deal w/ transformation of mouse cursor ourself:
++	 */
++	if (crtc->driverIsPerformingTransform) {
++		xf86CrtcTransformCursorPos(crtc, &crtc_x, &crtc_y);
++	}
++
+ 	/* note src coords (last 4 args) are in Q16 format */
+ 	drmModeSetPlane(drmmode->fd, cursor->ovr->plane_id,
+ 			drmmode_crtc->mode_crtc->crtc_id, cursor->fb_id, 0,
+@@ -550,6 +621,7 @@ static const xf86CrtcFuncsRec drmmode_crtc_funcs = {
+ static void
+ drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
+ {
++	drmModeObjectPropertiesPtr props;
+ 	xf86CrtcPtr crtc;
+ 	drmmode_crtc_private_ptr drmmode_crtc;
+ 
+@@ -563,8 +635,23 @@ drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
+ 	drmmode_crtc->mode_crtc = drmModeGetCrtc(drmmode->fd,
+ 			drmmode->mode_res->crtcs[num]);
+ 	drmmode_crtc->drmmode = drmmode;
+-
+-	// FIXME - potentially add code to allocate a HW cursor here.
++	drmmode_crtc->rotation = RR_Rotate_0;
++
++	/* find properties that we care about: */
++	props = drmModeObjectGetProperties(drmmode->fd,
++			drmmode_crtc->mode_crtc->crtc_id, DRM_MODE_OBJECT_CRTC);
++	if (props) {
++		drmModePropertyPtr prop;
++		int i;
++		for (i = 0; i < props->count_props; i++) {
++			prop = drmModeGetProperty(drmmode->fd, props->props[i]);
++			if (!strcmp(prop->name, "rotation")) {
++				drmmode_crtc->prop_rotation = prop->prop_id;
++			}
++			drmModeFreeProperty(prop);
++		}
++		drmModeFreeObjectProperties(props);
++	}
+ 
+ 	crtc->driver_private = drmmode_crtc;
+ 
+@@ -1016,55 +1103,86 @@ drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
+ 	return;
+ }
+ 
+-static Bool
+-drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
++Bool
++drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ {
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+ 	ScreenPtr pScreen = pScrn->pScreen;
++	drmmode_ptr drmmode = drmmode_from_scrn(pScrn);
++	Bool changed = FALSE;
++	uint32_t flags = OMAP_BO_SCANOUT | OMAP_BO_WC;
++	int width = pScrn->virtualX;
++	int height = pScrn->virtualY;
+ 	unsigned int pitch;
++	Bool rotate = has_rotation(pOMAP) && drmmode->rotated_crtcs > 0;
+ 
+-	TRACE_ENTER();
+-
+-	/* if fb required size has changed, realloc! */
+-
+-	DEBUG_MSG("Resize!  %dx%d", width, height);
+-
+-	pScrn->virtualX = width;
+-	pScrn->virtualY = height;
+-
+-	pitch = OMAPCalculateStride(width, pScrn->bitsPerPixel);
+-
+-	if ((pitch * height) != omap_bo_size(pOMAP->scanout)) {
+-		/* hmm, should we remove fb here.. we don't want to keep
+-		 * scanning out a deallocated buffer..
++	if (rotate) {
++		/* if we are using tiled buffers, we really should check if
++		 * width/height has changed, rather than size.. for now, just
++		 * always re-alloc:
+ 		 */
+-		drmmode_remove_fb(pScrn);
++		changed = TRUE;
++		pitch = OMAPCalculateTiledStride(width, pScrn->bitsPerPixel);
++	} else {
++		pitch = OMAPCalculateStride(width, pScrn->bitsPerPixel);
++	}
+ 
++	if (pOMAP->scanout) {
++		if ((pitch * height) != omap_bo_size(pOMAP->scanout)) {
++			changed = TRUE;
++		}
++	} else {
++		changed = TRUE;
++	}
++
++	if (changed) {
+ 		/* delete old scanout buffer */
+ 		omap_bo_del(pOMAP->scanout);
+ 
+-		DEBUG_MSG("allocating new scanout buffer: %dx%d (%d)",
+-				width, height, pitch);
++		if (rotate) {
++			DEBUG_MSG("allocating tiled scanout buffer: %dx%d (%d)",
++					width, height, pitch);
++			flags |= OMAPTiledFlags(pScrn->bitsPerPixel);
++			pOMAP->scanout = omap_bo_new_tiled(pOMAP->dev,
++					width, height, flags);
++		} else {
++			DEBUG_MSG("allocating linear scanout buffer: %dx%d (%d)",
++					width, height, pitch);
++			pOMAP->scanout = omap_bo_new(pOMAP->dev, height * pitch, flags);
++		}
+ 
+-		/* allocate new scanout buffer */
+-		pOMAP->scanout = omap_bo_new(pOMAP->dev, height * pitch,
+-				OMAP_BO_SCANOUT | OMAP_BO_WC);
+ 		if (!pOMAP->scanout) {
+ 			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+ 					"Error reallocating scanout buffer\n");
+ 			return FALSE;
+ 		}
+-	}
+ 
+-	if (pScreen && pScreen->ModifyPixmapHeader) {
+-		PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
+-		pScreen->ModifyPixmapHeader(rootPixmap,
+-				pScrn->virtualX, pScrn->virtualY,
+-				pScrn->depth, pScrn->bitsPerPixel, pitch,
+-				omap_bo_map(pOMAP->scanout));
++		pScrn->displayWidth = pitch / (pScrn->bitsPerPixel / 8);
++
++		if (pScreen && pScreen->ModifyPixmapHeader) {
++			PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
++			pScreen->ModifyPixmapHeader(rootPixmap,
++					pScrn->virtualX, pScrn->virtualY,
++					pScrn->depth, pScrn->bitsPerPixel,
++					pScrn->displayWidth * (pScrn->bitsPerPixel / 8),
++					omap_bo_map(pOMAP->scanout));
++		}
+ 	}
+ 
+-	TRACE_EXIT();
++	return TRUE;
++}
++
++static Bool
++drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
++{
++	DEBUG_MSG("Resize!  %dx%d", width, height);
++
++	pScrn->virtualX = width;
++	pScrn->virtualY = height;
++
++	if (!drmmode_reallocate_scanout(pScrn))
++		return FALSE;
++
+ 	return TRUE;
+ }
+ 
+@@ -1302,6 +1420,8 @@ drmmode_wakeup_handler(pointer data, int err, pointer p)
+ 	if (pScrn == NULL || err < 0)
+ 		return;
+ 
++	drmmode = drmmode_from_scrn(pScrn);
++
+ 	if (FD_ISSET(drmmode->fd, read_mask))
+ 		drmHandleEvent(drmmode->fd, &event_context);
+ }
+diff --git a/src/omap_driver.c b/src/omap_driver.c
+index 3d32b7e..ba69b7c 100644
+--- a/src/omap_driver.c
++++ b/src/omap_driver.c
+@@ -198,29 +198,21 @@ OMAPCalculateTiledStride(unsigned int width, unsigned int bitsPerPixel)
+ 	return stride;
+ }
+ 
++unsigned int
++OMAPTiledFlags(unsigned int bitsPerPixel)
++{
++	switch(bitsPerPixel) {
++	case 32: return OMAP_BO_TILED_32;
++	case 16: return OMAP_BO_TILED_16;
++	case 8:  return OMAP_BO_TILED_8;
++	default: return 0;
++	}
++}
+ 
+ static Bool
+ OMAPMapMem(ScrnInfoPtr pScrn)
+ {
+-	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-	int pitch;
+-
+-	pitch = OMAPCalculateStride(pScrn->virtualX, pScrn->bitsPerPixel);
+-
+-	DEBUG_MSG("allocating new scanout buffer: %dx%d (%d)",
+-			pScrn->virtualX, pScrn->virtualY, pitch);
+-
+-	pOMAP->scanout = omap_bo_new(pOMAP->dev, pScrn->virtualY * pitch,
+-			OMAP_BO_SCANOUT | OMAP_BO_WC);
+-	if (!pOMAP->scanout) {
+-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+-			   "Error allocating scanout buffer\n");
+-		return FALSE;
+-	}
+-
+-	pScrn->displayWidth = pitch / (pScrn->bitsPerPixel / 8);
+-
+-	return TRUE;
++	return drmmode_reallocate_scanout(pScrn);
+ }
+ 
+ 
+@@ -818,6 +810,16 @@ OMAPScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
+ 		goto fail;
+ 	}
+ 
++	if (has_rotation(pOMAP)) {
++		xf86RandR12SetRotations(pScreen, RR_Rotate_0 | RR_Rotate_90 |
++				RR_Rotate_180 | RR_Rotate_270 | RR_Reflect_X | RR_Reflect_Y);
++	} else {
++#if XF86_CRTC_VERSION < 4
++		WARNING_MSG("rotation not supported by XF86_CRTC_VERSION version: %d",
++				XF86_CRTC_VERSION);
++#endif
++	}
++
+ 	if (!miCreateDefColormap(pScreen)) {
+ 		ERROR_MSG("Cannot create colormap!");
+ 		goto fail;
+diff --git a/src/omap_driver.h b/src/omap_driver.h
+index ede45e4..8e53fc3 100644
+--- a/src/omap_driver.h
++++ b/src/omap_driver.h
+@@ -115,6 +115,7 @@ extern unsigned int
+ OMAPCalculateStride(unsigned int fbWidth, unsigned int bitsPerPixel);
+ extern unsigned int
+ OMAPCalculateTiledStride(unsigned int width, unsigned int bitsPerPixel);
++unsigned int OMAPTiledFlags(unsigned int bitsPerPixel);
+ 
+ 
+ 
+@@ -181,6 +182,16 @@ static inline Bool has_dmm(OMAPPtr pOMAP)
+ 	return pOMAP->chipset >= 0x4430;
+ }
+ 
++static inline Bool has_rotation(OMAPPtr pOMAP)
++{
++#if XF86_CRTC_VERSION >= 4
++	// TODO .. should somehow check if driver has rotation property..
++	return has_dmm(pOMAP);
++#else
++	return FALSE;
++#endif
++}
++
+ /** Return a pointer to the driver's private structure. */
+ #define OMAPPTR(p) ((OMAPPtr)((p)->driverPrivate))
+ #define OMAPPTR_FROM_SCREEN(pScreen) \
+@@ -224,6 +235,7 @@ void drmmode_remove_fb(ScrnInfoPtr pScrn);
+ Bool drmmode_page_flip(DrawablePtr draw, uint32_t fb_id, void *priv);
+ void drmmode_wait_for_event(ScrnInfoPtr pScrn);
+ Bool drmmode_cursor_init(ScreenPtr pScreen);
++Bool drmmode_reallocate_scanout(ScrnInfoPtr pScrn);
+ 
+ 
+ /**
+-- 
+1.7.9.5
+
--- xf86-video-omap-0.2.1.orig/debian/patches/series
+++ xf86-video-omap-0.2.1/debian/patches/series
@@ -0,0 +1,5 @@
+0001-xrandr-rotation-v2.patch
+0002-fix-build-with-older-xserver.patch
+0003-drmmode-trigger-redraw-when-reallocating.patch
+0004-WIP-dri2video-v3.patch
+0007-add-headers.patch
--- xf86-video-omap-0.2.1.orig/debian/patches/0007-add-headers.patch
+++ xf86-video-omap-0.2.1/debian/patches/0007-add-headers.patch
@@ -0,0 +1,11 @@
+Index: xf86-video-omap/src/Makefile.am
+===================================================================
+--- xf86-video-omap.orig/src/Makefile.am	2012-03-27 12:44:10.000000000 +0000
++++ xf86-video-omap/src/Makefile.am	2012-03-27 12:49:12.000000000 +0000
+@@ -49,3 +49,6 @@
+          omap_xv.c \
+          omap_dri2.c \
+          omap_driver.c
++
++omap_drvincludedir = ${includedir}
++omap_drvinclude_HEADERS = omap_driver.h omap_exa.h omap_util.h
--- xf86-video-omap-0.2.1.orig/debian/patches/0004-WIP-dri2video-v3.patch
+++ xf86-video-omap-0.2.1/debian/patches/0004-WIP-dri2video-v3.patch
@@ -0,0 +1,468 @@
+From bc521f4a390bcb25b784aec8d50daf430029aebc Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Mon, 23 Apr 2012 11:39:23 -0500
+Subject: [PATCH 4/4] WIP: dri2video (v3)
+
+---
+ src/omap_dri2.c |  340 ++++++++++++++++++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 311 insertions(+), 29 deletions(-)
+
+diff --git a/src/omap_dri2.c b/src/omap_dri2.c
+index 1ab48e0..46dadc1 100644
+--- a/src/omap_dri2.c
++++ b/src/omap_dri2.c
+@@ -37,7 +37,7 @@
+ #include "dri2.h"
+ 
+ /* any point to support earlier? */
+-#if DRI2INFOREC_VERSION < 4
++#if DRI2INFOREC_VERSION < 7
+ #	error "Requires newer DRI2"
+ #endif
+ 
+@@ -68,6 +68,14 @@ typedef struct {
+ 	 */
+ 	int refcnt;
+ 
++	/**
++	 * For multi-planar formats, extra buffer info..
++	 */
++	int extraCount;
++	PixmapPtr *extraPix;
++	unsigned int *extraNames;
++	unsigned int *extraPitches;
++
+ } OMAPDRI2BufferRec, *OMAPDRI2BufferPtr;
+ 
+ #define OMAPBUF(p)	((OMAPDRI2BufferPtr)(p))
+@@ -121,6 +129,34 @@ createpix(DrawablePtr pDraw)
+ 			pDraw->width, pDraw->height, pDraw->depth, flags);
+ }
+ 
++static OMAPDRI2BufferPtr
++createbuf(DrawablePtr pDraw, PixmapPtr pPixmap, int attachment, int format)
++{
++	ScreenPtr pScreen = pDraw->pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPDRI2BufferPtr buf = calloc(1, sizeof(*buf));
++	int ret;
++
++	if (!buf) {
++		return NULL;
++	}
++
++	DRIBUF(buf)->attachment = attachment;
++	DRIBUF(buf)->pitch = exaGetPixmapPitch(pPixmap);
++	DRIBUF(buf)->cpp = pPixmap->drawable.bitsPerPixel / 8;
++	DRIBUF(buf)->format = format;
++	buf->refcnt = 1;
++	buf->pPixmap = pPixmap;
++
++	ret = omap_bo_get_name(OMAPPixmapBo(pPixmap), &DRIBUF(buf)->name);
++	if (ret) {
++		ERROR_MSG("could not get buffer name: %d", ret);
++		return NULL;
++	}
++
++	return buf;
++}
++
+ /**
+  * Create Buffer.
+  *
+@@ -138,18 +174,12 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 	ScreenPtr pScreen = pDraw->pScreen;
+ 	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-	OMAPDRI2BufferPtr buf = calloc(1, sizeof(*buf));
++	OMAPDRI2BufferPtr buf;
+ 	PixmapPtr pPixmap;
+-	struct omap_bo *bo;
+-	int ret;
+ 
+ 	DEBUG_MSG("pDraw=%p, attachment=%d, format=%08x",
+ 			pDraw, attachment, format);
+ 
+-	if (!buf) {
+-		return NULL;
+-	}
+-
+ 	if (attachment == DRI2BufferFrontLeft) {
+ 		pPixmap = draw2pix(pDraw);
+ 
+@@ -178,21 +208,7 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 		pPixmap = createpix(pDraw);
+ 	}
+ 
+-	bo = OMAPPixmapBo(pPixmap);
+-
+-	DRIBUF(buf)->attachment = attachment;
+-	DRIBUF(buf)->pitch = exaGetPixmapPitch(pPixmap);
+-	DRIBUF(buf)->cpp = pPixmap->drawable.bitsPerPixel / 8;
+-	DRIBUF(buf)->format = format;
+-	buf->refcnt = 1;
+-	buf->pPixmap = pPixmap;
+-
+-	ret = omap_bo_get_name(bo, &DRIBUF(buf)->name);
+-	if (ret) {
+-		ERROR_MSG("could not get buffer name: %d", ret);
+-		/* TODO cleanup */
+-		return NULL;
+-	}
++	buf = createbuf(pDraw, pPixmap, attachment, format);
+ 
+ 	/* Q: how to know across OMAP generations what formats that the display
+ 	 * can support directly?
+@@ -202,7 +218,7 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 	if (canflip(pDraw)) {
+ 		int ret = drmModeAddFB(pOMAP->drmFD, pDraw->width, pDraw->height,
+ 				pDraw->depth, pDraw->bitsPerPixel, DRIBUF(buf)->pitch,
+-				omap_bo_handle(bo), &buf->fb_id);
++				omap_bo_handle(OMAPPixmapBo(pPixmap)), &buf->fb_id);
+ 		if (ret) {
+ 			/* to-bad, so-sad, we can't flip */
+ 			WARNING_MSG("could not create fb: %d", ret);
+@@ -213,6 +229,84 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 	return DRIBUF(buf);
+ }
+ 
++static DRI2BufferPtr
++OMAPDRI2CreateBufferVid(DrawablePtr pDraw, unsigned int attachment,
++		unsigned int format, unsigned int width, unsigned int height)
++{
++	ScreenPtr pScreen = pDraw->pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPDRI2BufferPtr buf;
++	PixmapPtr pPixmap;
++	int bpp, extraCount = 0, ew = width, eh = height;
++
++	DEBUG_MSG("pDraw=%p, attachment=%d, format=%08x",
++			pDraw, attachment, format);
++
++	switch(format) {
++	case fourcc_code('I','4','2','0'):
++	case fourcc_code('Y','V','1','2'):
++		extraCount++;
++		ew /= 2;
++		/* fallthru */
++	case fourcc_code('N','V','1','2'):
++		extraCount++;
++		eh /= 2;
++		bpp = 8;
++		break;
++	case fourcc_code('U','Y','V','Y'):
++	case fourcc_code('Y','U','Y','2'):
++		bpp = 16;
++		break;
++	default:
++		return NULL;
++	}
++
++	/* main buffer, luma buffer in case of multi-planar.. */
++	pPixmap = pScreen->CreatePixmap(pScreen, width, height, bpp, 0);
++
++	buf = createbuf(pDraw, pPixmap, attachment, format);
++
++	if (extraCount > 0) {
++		int i, ret;
++
++		buf->extraPix = malloc(extraCount * sizeof(buf->extraPix[0]));
++		buf->extraNames = malloc(extraCount * sizeof(buf->extraNames[0]));
++		buf->extraPitches = malloc(extraCount * sizeof(buf->extraPitches[0]));
++		buf->extraCount = extraCount;
++
++		for (i = 0; i < extraCount; i++) {
++			PixmapPtr p = pScreen->CreatePixmap(pScreen, ew, eh, bpp, 0);
++
++			buf->extraPix[i] = p;
++			buf->extraPitches[i] = exaGetPixmapPitch(p);
++
++			ret = omap_bo_get_name(OMAPPixmapBo(p), &buf->extraNames[i]);
++			if (ret) {
++				ERROR_MSG("could not get buffer name: %d", ret);
++				/* TODO: cleanup.. */
++				return NULL;
++			}
++		}
++	}
++
++	return DRIBUF(buf);
++}
++
++/**
++ * An ugly approach to avoid changing DRI2BufferPtr and cause ABI breakage
++ * between driver and xserver.  This only needs to be implemented by drivers
++ * supporting planar formats with one buffer per plane.
++ */
++static unsigned int
++OMAPDRI2GetExtraBufferNames(DrawablePtr pDraw, DRI2BufferPtr buffer,
++		unsigned int **names, unsigned int **pitches)
++{
++	OMAPDRI2BufferPtr buf = OMAPBUF(buffer);
++	*names = buf->extraNames;
++	*pitches = buf->extraPitches;
++	return buf->extraCount;
++}
++
+ /**
+  * Destroy Buffer
+  *
+@@ -230,7 +324,8 @@ OMAPDRI2DestroyBuffer(DrawablePtr pDraw, DRI2BufferPtr buffer)
+ 	ScreenPtr pScreen = buf->pPixmap->drawable.pScreen;
+ 	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-
++	int i;
++	
+ 	if (--buf->refcnt > 0)
+ 		return;
+ 
+@@ -242,6 +337,14 @@ OMAPDRI2DestroyBuffer(DrawablePtr pDraw, DRI2BufferPtr buffer)
+ 
+ 	pScreen->DestroyPixmap(buf->pPixmap);
+ 
++	for (i = 0; i < buf->extraCount; i++) {
++		pScreen->DestroyPixmap(buf->extraPix[i]);
++	}
++
++	free(buf->extraPix);
++	free(buf->extraNames);
++	free(buf->extraPitches);
++
+ 	free(buf);
+ }
+ 
+@@ -269,12 +372,19 @@ OMAPDRI2CopyRegion(DrawablePtr pDraw, RegionPtr pRegion,
+ 	DEBUG_MSG("pDraw=%p, pDstBuffer=%p (%p), pSrcBuffer=%p (%p)",
+ 			pDraw, pDstBuffer, pSrcDraw, pSrcBuffer, pDstDraw);
+ 
++	if (pDstBuffer->attachment == DRI2BufferFakeFrontLeft) {
++		/* I think we don't need this.. it should be handled
++		 * on client side (I think)..
++		 */
++		return;
++	}
++
+ 	pGC = GetScratchGC(pDstDraw->depth, pScreen);
+ 	if (!pGC) {
+ 		return;
+ 	}
+ 
+-	pCopyClip = REGION_CREATE(pScreen, NULL, 0);
++	pCopyClip = RegionCreate(NULL, 0);
+ 	RegionCopy(pCopyClip, pRegion);
+ 	(*pGC->funcs->ChangeClip) (pGC, CT_REGION, pCopyClip, 0);
+ 	ValidateGC(pDstDraw, pGC);
+@@ -449,6 +559,121 @@ OMAPDRI2ScheduleSwap(ClientPtr client, DrawablePtr pDraw,
+ 	return TRUE;
+ }
+ 
++static int OMAPDRI2PutTextureImage(
++		PixmapPtr pSrcPix, BoxPtr pSrcBox,
++		PixmapPtr pOsdPix, BoxPtr pOsdBox,
++		PixmapPtr pDstPix, BoxPtr pDstBox,
++		void *closure)
++{
++	ScreenPtr pScreen = pDstPix->drawable.pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	OMAPDRISwapCmd *cmd = closure;
++	OMAPDRI2BufferPtr src = OMAPBUF(cmd->pSrcBuffer);
++	Bool ret;
++
++	ret = pOMAP->pOMAPEXA->PutTextureImage(pSrcPix, pSrcBox,
++			pOsdPix, pOsdBox, pDstPix, pDstBox,
++			src->extraCount, src->extraPix,
++			cmd->pSrcBuffer->format);
++	if (ret) {
++		return Success;
++	}
++	DEBUG_MSG("PutTextureImage failed");
++
++	return BadImplementation;
++}
++
++
++/**
++ * Schedule a video buffer swap
++ *
++ * Drivers should queue an event for the frame count that satisfies the
++ * parameters passed in.  If the event is in the future (i.e. the conditions
++ * aren't currently satisfied), the server may block the client at the next
++ * GLX request using DRI2WaitSwap. When the event arrives, drivers should call
++ * \c DRI2SwapComplete, which will handle waking the client and returning
++ * the appropriate data.
++ *
++ * The DDX is responsible for doing an overlay buffer flip/exchange, or
++ * scaling/colorconvert blit when the corresponding event arrives.
++ *
++ * If the target drawable is resized/damaged, or the osd pixmap is changed/
++ * damaged, ScheduleSwapVid can be re-invoked by the core with the same
++ * source buffer to repair the dri2 video drawable.
++ */
++static Bool
++OMAPDRI2ScheduleSwapVid(ClientPtr client, DrawablePtr pDraw,
++		DRI2BufferPtr pDstBuffer, DRI2BufferPtr pSrcBuffer,
++		BoxPtr pSrcBox, DrawablePtr osd,
++		CARD64 *target_msc, CARD64 divisor, CARD64 remainder,
++		DRI2SwapEventPtr func, void *data)
++{
++	ScreenPtr pScreen = pDraw->pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPDRISwapCmd *cmd = calloc(1, sizeof(*cmd));
++	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	RegionPtr pCopyClip;
++	GCPtr pGC;
++	BoxRec dstbox = {
++			.x1 = pDraw->x, .y1 = pDraw->y,
++			.x2 = pDraw->x + pDraw->width, .y2 = pDraw->y + pDraw->height
++	};
++	BoxRec osdbox = {
++			.x1 = 0, .y1 = 0,
++			.x2 = osd ? osd->width : 0, .y2 = osd ? osd->height : 0,
++	};
++
++	cmd->client = client;
++	cmd->pScreen = pScreen;
++	cmd->draw_id = pDraw->id;
++	cmd->pSrcBuffer = pSrcBuffer;
++	cmd->pDstBuffer = pDstBuffer;
++	cmd->func = func;
++	cmd->data = data;
++
++	DEBUG_MSG("%d -> %d", pSrcBuffer->attachment, pDstBuffer->attachment);
++
++	/* obtain extra ref on buffers to avoid them going away while we await
++	 * the page flip event:
++	 */
++	OMAPDRI2ReferenceBuffer(pSrcBuffer);
++	OMAPDRI2ReferenceBuffer(pDstBuffer);
++	pOMAP->pending_flips++;
++
++	pGC = GetScratchGC(pDraw->depth, pScreen);
++	if (!pGC) {
++		return FALSE;
++	}
++
++	pCopyClip = RegionCreate(&dstbox, 1);
++	(*pGC->funcs->ChangeClip) (pGC, CT_REGION, pCopyClip, 0);
++	ValidateGC(pDraw, pGC);
++
++	/* someday, support overlay too.. */
++	if (has_video(pOMAP)) {
++		cmd->type = DRI2_BLIT_COMPLETE;
++		if (OMAPVidCopyArea(dri2draw(pDraw, pSrcBuffer), pSrcBox,
++				osd, &osdbox, dri2draw(pDraw, pDstBuffer), &dstbox,
++				OMAPDRI2PutTextureImage, cmd, pCopyClip) == Success) {
++			OMAPDRI2SwapComplete(cmd);
++			return TRUE;
++		}
++	}
++
++	// XXX for RGB formats, we should be able to fall back to
++	// generic composite operation..
++
++
++	/* drop extra refcnt we obtained prior to swap:
++	 */
++	OMAPDRI2DestroyBuffer(pDraw, cmd->pSrcBuffer);
++	OMAPDRI2DestroyBuffer(pDraw, cmd->pDstBuffer);
++	pOMAP->pending_flips--;
++
++	return FALSE;
++}
++
+ /**
+  * Request a DRM event when the requested conditions will be satisfied.
+  *
+@@ -469,6 +694,37 @@ OMAPDRI2ScheduleWaitMSC(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
+ 	return FALSE;
+ }
+ 
++#define ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
++
++static int
++OMAPDRI2SetAttribute(DrawablePtr pDraw, Atom attribute,
++		int len, const CARD32 *val)
++{
++	/* just for testing.. bogus colorspace conversion matrix.. */
++	if (attribute == ATOM("XV_CSC_MATRIX")) {
++		return Success;
++	}
++	return BadMatch;
++}
++
++static int
++OMAPDRI2GetAttribute(DrawablePtr pDraw, Atom attribute,
++		int *len, const CARD32 **val)
++{
++	/* just for testing.. bogus colorspace conversion matrix.. */
++	if (attribute == ATOM("XV_CSC_MATRIX")) {
++		static const CARD32 csc[] = {
++				0x00, 0x01, 0x02, 0x03,
++				0x10, 0x11, 0x12, 0x13,
++				0x20, 0x21, 0x22, 0x23,
++		};
++		*val = csc;
++		*len = sizeof(csc) / 4;
++		return Success;
++	}
++	return BadMatch;
++}
++
+ /**
+  * The DRI2 ScreenInit() function.. register our handler fxns w/ DRI2 core
+  */
+@@ -477,20 +733,46 @@ OMAPDRI2ScreenInit(ScreenPtr pScreen)
+ {
+ 	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	const char *driverNames[] = {
++			[DRI2DriverDRI] = "omap",
++			[DRI2DriverXV]  = has_video(pOMAP) ? "omap" : NULL,
++	};
+ 	DRI2InfoRec info = {
+-			.version			= 5,
++			.version			= 7,
+ 			.fd 				= pOMAP->drmFD,
+-			.driverName			= "omap",
++			.numDrivers			= 3,
++			.driverNames		= driverNames,
++			.driverName			= driverNames[DRI2DriverDRI],
+ 			.deviceName			= pOMAP->deviceName,
+ 			.CreateBuffer		= OMAPDRI2CreateBuffer,
++			.CreateBufferVid	= OMAPDRI2CreateBufferVid,
+ 			.DestroyBuffer		= OMAPDRI2DestroyBuffer,
+ 			.CopyRegion			= OMAPDRI2CopyRegion,
+ 			.ScheduleSwap		= OMAPDRI2ScheduleSwap,
++			.ScheduleSwapVid	= OMAPDRI2ScheduleSwapVid,
+ 			.ScheduleWaitMSC	= OMAPDRI2ScheduleWaitMSC,
+ 			.GetMSC				= OMAPDRI2GetMSC,
+ 			.AuthMagic			= drmAuthMagic,
++			.GetExtraBufferNames= OMAPDRI2GetExtraBufferNames,
++			.SetAttribute		= OMAPDRI2SetAttribute,
++			.GetAttribute		= OMAPDRI2GetAttribute,
+ 	};
+-	int minor = 1, major = 0;
++	int minor = 1, major = 0, nformats = 0;
++	static unsigned int formats[MAX_FORMATS + 4];
++
++	if (has_video(pOMAP)) {
++		/* add supported video formats: */
++		nformats = pOMAP->pOMAPEXA->GetFormats(formats);
++	}
++
++	/* add supported non-video formats: */
++	formats[nformats++] = 24;
++	formats[nformats++] = 32;
++	formats[nformats++] = fourcc_code('X','R','2','4');
++	formats[nformats++] = fourcc_code('A','R','2','4');
++
++	info.formats = formats;
++	info.numFormats = nformats;
+ 
+ 	if (xf86LoaderCheckSymbol("DRI2Version")) {
+ 		DRI2Version(&major, &minor);
+-- 
+1.7.9.5
+
--- xf86-video-omap-0.2.1.orig/debian/patches/0003-drmmode-trigger-redraw-when-reallocating.patch
+++ xf86-video-omap-0.2.1/debian/patches/0003-drmmode-trigger-redraw-when-reallocating.patch
@@ -0,0 +1,99 @@
+From 92778f4868c7174a9686b10b2e4f78d21a917fca Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Fri, 13 Apr 2012 16:38:47 -0500
+Subject: [PATCH 3/4] drmmode: trigger redraw when reallocating
+
+When we are re-allocating scanout buffer in paths where the xserver
+does not expect it (ie. to change tiling for rotation), then be
+sure to trigger the xserver to redraw.
+---
+ src/drmmode_display.c |   15 ++++++++++-----
+ src/omap_driver.c     |    2 +-
+ src/omap_driver.h     |    2 +-
+ 3 files changed, 12 insertions(+), 7 deletions(-)
+
+diff --git a/src/drmmode_display.c b/src/drmmode_display.c
+index 9b8413e..63f048c 100644
+--- a/src/drmmode_display.c
++++ b/src/drmmode_display.c
+@@ -297,7 +297,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+ 	 */
+ 	if (was_rotated != (drmmode->rotated_crtcs > 0)) {
+ 		/* reallocate scanout buffer.. */
+-		drmmode_reallocate_scanout(pScrn);
++		drmmode_reallocate_scanout(pScrn, TRUE);
+ 	}
+ 
+ 	/* note: this needs to be done before setting the mode, otherwise
+@@ -1106,7 +1106,7 @@ drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
+ }
+ 
+ Bool
+-drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
++drmmode_reallocate_scanout(ScrnInfoPtr pScrn, Bool redraw)
+ {
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+ 	ScreenPtr pScreen = pScrn->pScreen;
+@@ -1138,6 +1138,9 @@ drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ 	}
+ 
+ 	if (changed) {
++		if (pScreen && pScrn->EnableDisableFBAccess && redraw)
++			pScrn->EnableDisableFBAccess(pScrn->scrnIndex, FALSE);
++
+ 		/* delete old scanout buffer */
+ 		omap_bo_del(pOMAP->scanout);
+ 
+@@ -1165,10 +1168,12 @@ drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ 			PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
+ 			pScreen->ModifyPixmapHeader(rootPixmap,
+ 					pScrn->virtualX, pScrn->virtualY,
+-					pScrn->depth, pScrn->bitsPerPixel,
+-					pScrn->displayWidth * (pScrn->bitsPerPixel / 8),
++					pScrn->depth, pScrn->bitsPerPixel, pitch,
+ 					omap_bo_map(pOMAP->scanout));
+ 		}
++
++		if (pScreen && pScrn->EnableDisableFBAccess && redraw)
++			pScrn->EnableDisableFBAccess(pScrn->scrnIndex, TRUE);
+ 	}
+ 
+ 	return TRUE;
+@@ -1182,7 +1187,7 @@ drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
+ 	pScrn->virtualX = width;
+ 	pScrn->virtualY = height;
+ 
+-	if (!drmmode_reallocate_scanout(pScrn))
++	if (!drmmode_reallocate_scanout(pScrn, FALSE))
+ 		return FALSE;
+ 
+ 	return TRUE;
+diff --git a/src/omap_driver.c b/src/omap_driver.c
+index ba69b7c..b729a85 100644
+--- a/src/omap_driver.c
++++ b/src/omap_driver.c
+@@ -212,7 +212,7 @@ OMAPTiledFlags(unsigned int bitsPerPixel)
+ static Bool
+ OMAPMapMem(ScrnInfoPtr pScrn)
+ {
+-	return drmmode_reallocate_scanout(pScrn);
++	return drmmode_reallocate_scanout(pScrn, FALSE);
+ }
+ 
+ 
+diff --git a/src/omap_driver.h b/src/omap_driver.h
+index 8e53fc3..9c6f15a 100644
+--- a/src/omap_driver.h
++++ b/src/omap_driver.h
+@@ -235,7 +235,7 @@ void drmmode_remove_fb(ScrnInfoPtr pScrn);
+ Bool drmmode_page_flip(DrawablePtr draw, uint32_t fb_id, void *priv);
+ void drmmode_wait_for_event(ScrnInfoPtr pScrn);
+ Bool drmmode_cursor_init(ScreenPtr pScreen);
+-Bool drmmode_reallocate_scanout(ScrnInfoPtr pScrn);
++Bool drmmode_reallocate_scanout(ScrnInfoPtr pScrn, Bool redraw);
+ 
+ 
+ /**
+-- 
+1.7.9.5
+
