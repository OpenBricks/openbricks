--- xf86-video-omap-0.0.4.orig/debian/xserver-xorg-video-omap.install
+++ xf86-video-omap-0.0.4/debian/xserver-xorg-video-omap.install
@@ -0,0 +1,2 @@
+usr/lib/xorg/modules/drivers/omap_drv.so
+usr/share/man/man4/omap.4
--- xf86-video-omap-0.0.4.orig/debian/compat
+++ xf86-video-omap-0.0.4/debian/compat
@@ -0,0 +1 @@
+7
--- xf86-video-omap-0.0.4.orig/debian/xserver-xorg-video-omap-dev.install
+++ xf86-video-omap-0.0.4/debian/xserver-xorg-video-omap-dev.install
@@ -0,0 +1 @@
+usr/include/*
--- xf86-video-omap-0.0.4.orig/debian/copyright
+++ xf86-video-omap-0.0.4/debian/copyright
@@ -0,0 +1,65 @@
+xf86-video-omap was packaged for Debian by:
+
+    David Bercovitz <d-bercovitz@ti.com> on Thu, 08 Dec 2011 14:45:01 +0200
+
+Original source code was downloaded from <git://github.com/robclark/xf86-video-omap.git>
+
+Copyright:
+
+    Copyright(c) 2011 Texas Instruments. All rights reserved.     
+    All rights reserved.                                                  
+                                                                      
+    Redistribution and use in source and binary forms, with or without    
+    modification, are permitted provided that the following conditions    
+    are met:                                                              
+                                                                      
+    * Redistributions of source code must retain the above copyright     
+      notice, this list of conditions and the following disclaimer.      
+    * Redistributions in binary form must reproduce the above copyright  
+      notice, this list of conditions and the following disclaimer in    
+      the documentation and/or other materials provided with the         
+      distribution.                                                      
+    * Neither the name Texas Instruments nor the names of its            
+      contributors may be used to endorse or promote products derived    
+      from this software without specific prior written permission.      
+                                                                      
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   
+    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     
+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  
+    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      
+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   
+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+License:
+
+    GPL-2 (GNU GPL Version 2),
+   
+    This package is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License version 2 as
+    published by the Free Software Foundation.
+
+    This package is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this package; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+
+On Debian systems, the complete text of the GNU General
+Public License version 2 can be found in `/usr/share/common-licenses/GPL-2'.
+
+The Debian packaging is:
+
+    Copyright (C) 2011 David Bercovitz <d-bercovitz@ti.com>
+
+you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
--- xf86-video-omap-0.0.4.orig/debian/changelog
+++ xf86-video-omap-0.0.4/debian/changelog
@@ -0,0 +1,80 @@
+xf86-video-omap (0.0.4-0ubuntu7) precise; urgency=low
+
+  * Support rotation and no rotation
+
+ -- Xavier Boudet <x-boudet@ti.com>  Mon, 02 Apr 2012 16:15:00 +0000
+
+xf86-video-omap (0.0.4-0ubuntu6) precise; urgency=low
+
+  * Enable rotation 
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 28 Mar 2012 18:13:43 +0000
+
+xf86-video-omap (0.0.4-0ubuntu5) precise; urgency=low
+
+  * Update dependencies version for libdri2-dev and libdrm-dev
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 28 Mar 2012 15:41:58 +0000
+
+xf86-video-omap (0.0.4-0ubuntu4) precise; urgency=low
+
+  * Disable rotation
+  * add package xserver-xorg-video-omap-dev
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 28 Mar 2012 08:39:12 +0000
+
+xf86-video-omap (0.0.4-0ubuntu3) precise; urgency=low
+
+  * Fix debian/rules issue 
+
+ -- Xavier Boudet <x-boudet@ti.com>  Thu, 22 Mar 2012 16:43:11 +0000
+
+xf86-video-omap (0.0.4-0ubuntu2) precise; urgency=low
+
+  * Rebuild vs xserver-xorg-dev >= 2:1.11.4-0ubuntu7+ti1.1 for rotation 
+  * Add xrandr-rotation.patch
+
+ -- Xavier Boudet <x-boudet@ti.com>  Wed, 21 Mar 2012 17:31:33 +0000
+
+xf86-video-omap (0.0.4-0ubuntu1) precise; urgency=low
+
+  * Added dri2video support
+  * Incremented libdri2 dependency version
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Thu, 01 Mar 2012 15:05:50 +0100
+
+xf86-video-omap (0.0.3-0ubuntu2) precise; urgency=low
+
+  * Updated libdrm dependency and added dep on libdri2 
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Fri, 17 Feb 2012 14:47:17 +0100
+
+xf86-video-omap (0.0.3-0ubuntu1) precise; urgency=low
+
+  * Updated package with new upstream source code
+    Fixed the FOURCC macros definitions
+    Rob's commit ID e438755dbb921e47252f91a19aba7f0347e1482f 
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Mon, 30 Jan 2012 10:56:40 +0100
+
+xf86-video-omap (0.0.2-0ubuntu1) precise; urgency=low
+
+  * Updated package with new upstream source code per
+    Rob's notification to update.
+
+  * Also updated from oneiric to precise as Rob is now
+    testing with xserver and filesystem from Precise.
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Mon, 16 Jan 2012 11:07:50 +0100
+
+xf86-video-omap (0.0.1-0ubuntu2) oneiric; urgency=low
+
+  * Corrected libdrm-dev version dependency in the control file
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Wed, 11 Jan 2012 11:56:38 +0100
+
+xf86-video-omap (0.0.1-0ubuntu1) oneiric; urgency=low
+
+  * Initial Ubuntu Package
+
+ -- David Bercovitz <d-bercovitz@ti.com>  Thu, 08 Dec 2011 14:45:41 +0200
--- xf86-video-omap-0.0.4.orig/debian/rules
+++ xf86-video-omap-0.0.4/debian/rules
@@ -0,0 +1,25 @@
+#!/usr/bin/make -f
+
+override_dh_autoreconf:
+	mkdir m4
+	dh_autoreconf
+
+override_dh_autoreconf_clean:
+	dh_autoreconf_clean
+	rm -rf m4
+
+override_dh_strip:
+	dh_strip --dbg-package=xserver-xorg-video-omap-dbg
+
+override_dh_auto_install:
+	dh_auto_install --destdir=debian/tmp
+
+override_dh_installdocs:
+	dh_installdocs --link-doc=xserver-xorg-video-omap
+
+# use appropriate warning level for a plugin
+override_dh_shlibdeps:
+	dh_shlibdeps -- --warnings=6
+
+%:
+	dh $@ --with quilt,autoreconf,xsf --builddirectory=build/
--- xf86-video-omap-0.0.4.orig/debian/control
+++ xf86-video-omap-0.0.4/debian/control
@@ -0,0 +1,84 @@
+Source: xf86-video-omap
+Section: x11
+Priority: optional
+Maintainer: TI OMAP Developers <tiomap-dev@lists.launchpad.net>
+Build-Depends: 
+ debhelper (>= 8.1.2ubuntu2),
+ dh-autoreconf,
+ quilt,
+ pkg-config,
+ xutils-dev (>= 1:7.6+5),
+ xserver-xorg-dev (>= 2:1.11.4-0ubuntu7+ti1.1),
+ libxext-dev (>= 2:1.3.0),
+ libudev-dev (>= 173),
+ x11proto-core-dev (>= 7.0.22),
+ x11proto-fonts-dev (>= 2.1.1),
+ x11proto-xf86dri-dev (>= 2.1.1),
+ libdrm-dev (>= 2.4.32-1ubuntu1+ti1.2),
+ libdri2-dev (>= 1.0.2-0ubuntu3),
+Standards-Version: 3.9.2
+Vcs-Git: git://github.com/robclark/xf86-video-omap.git
+Vcs-Browser: http://github.com/robclark/xf86-video-omap.git
+
+Package: xserver-xorg-video-omap
+Architecture: armel armhf
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends},
+ ${xviddriver:Depends}
+Provides: ${xviddriver:Provides}
+Description: X.org graphics -- TI OMAP display driver
+ This driver for the X.org server provides support for OMAP3 and
+ newer devices. Currently it relies on a closed-source submodule
+ for EXA acceleration on the following chipsets:
+  + OMAP3430
+  + OMAP3630
+  + OMAP4430
+  + OMAP4460
+ .
+ The driver depends on omapdrm driver in the kernel with 
+ GEM support.
+ .
+ More information about X.org can be found at:
+  * <URL:http://www.X.org>
+  * <URL:http://xorg.freedesktop.org>
+  * <URL:http://lists.freedesktop.org/mailman/listinfo/xorg>
+
+Package: xserver-xorg-video-omap-dbg
+Architecture: armel armhf
+Section: debug
+Priority: extra
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends},
+ xserver-xorg-video-omap (= ${binary:Version})
+Description: X.org graphics -- TI OMAP display driver (debug symbols)
+ This driver for the X.org server provides debug symbols support for 
+ OMAP3 and newer devices. Currently it relies on a closed-source submodule
+ for EXA acceleration on the following chipsets:
+  + OMAP3430
+  + OMAP3630
+  + OMAP4430
+  + OMAP4460
+ .
+ The driver depends on omapdrm driver in the kernel with 
+ GEM support.
+ .
+ More information about X.org can be found at: 
+  * <URL:http://www.X.org>
+  * <URL:http://xorg.freedesktop.org>
+  * <URL:http://lists.freedesktop.org/mailman/listinfo/xorg>
+ .
+ This package contains debug symbols for xserver-xorg-video-omap.
+
+Package: xserver-xorg-video-omap-dev
+Architecture: armel armhf
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends},
+ xserver-xorg-video-omap (= ${binary:Version})
+Description: X.org graphics -- TI OMAP display driver Headers
+ This package provides Headers for  xserver-xorg-video-omap
--- xf86-video-omap-0.0.4.orig/debian/patches/0002-xrandr-rotation.patch
+++ xf86-video-omap-0.0.4/debian/patches/0002-xrandr-rotation.patch
@@ -0,0 +1,332 @@
+From 87ffbaf9d282831bf03da457e6f6c4e45a0d6b2b Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Thu, 8 Mar 2012 15:47:24 -0600
+Subject: [PATCH] xrandr rotation
+
+If XF86_CRTC_VERSION >= 4 and DRM_OMAP_SET_ORIENTATION is supported,
+on platforms with dmm/tiler (OMAP4+), use tiled buffers for scanout
+buffer to enable rotatated and/or mirrored scanout.
+---
+ src/drmmode_display.c |  155 +++++++++++++++++++++++++++++++++++++++---------
+ src/omap_driver.c     |   42 +++++++------
+ src/omap_driver.h     |   16 +++++
+ 3 files changed, 165 insertions(+), 48 deletions(-)
+
+Index: xf86-video-omap/src/drmmode_display.c
+===================================================================
+--- xf86-video-omap.orig/src/drmmode_display.c	2012-03-02 16:44:23.000000000 +0000
++++ xf86-video-omap/src/drmmode_display.c	2012-03-21 19:10:02.000000000 +0000
+@@ -84,6 +84,7 @@
+ #endif
+ 
+ #include "omap_driver.h"
++#include "omap_drm.h"
+ 
+ #include "xf86Crtc.h"
+ 
+@@ -215,6 +216,65 @@
+ 	// FIXME - Implement this function
+ }
+ 
++#define SUPPORTED_ROTATIONS (RR_Rotate_0 | RR_Rotate_90 | RR_Rotate_180 | RR_Rotate_270 | RR_Reflect_X | RR_Reflect_Y)
++
++static Bool
++drmmode_set_rotation(xf86CrtcPtr crtc, Rotation rotation)
++{
++#if defined(DRM_OMAP_SET_ORIENTATION) && (XF86_CRTC_VERSION >= 4)
++	ScrnInfoPtr pScrn = crtc->scrn;
++	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
++
++	if (!(rotation & ~SUPPORTED_ROTATIONS)) {
++		int ret;
++		struct drm_omap_set_orientation req = {
++				.crtc_or_plane_id = drmmode_crtc->mode_crtc->crtc_id,
++		};
++
++		switch (rotation & 0xf) {
++		case RR_Rotate_0:
++			req.orientation = 0;
++			break;
++		case RR_Rotate_90:
++			req.orientation = OMAP_ORIENT_MASK_XY_FLIP | OMAP_ORIENT_MASK_X_INVERT;
++			break;
++		case RR_Rotate_180:
++			req.orientation = OMAP_ORIENT_MASK_X_INVERT | OMAP_ORIENT_MASK_Y_INVERT;
++			break;
++		case RR_Rotate_270:
++			req.orientation = OMAP_ORIENT_MASK_XY_FLIP | OMAP_ORIENT_MASK_Y_INVERT;
++			break;
++		default:
++			ERROR_MSG("invalid rotation: %02x", rotation);
++			return FALSE;
++		}
++
++		if (rotation & RR_Reflect_X)
++			req.orientation ^= OMAP_ORIENT_MASK_X_INVERT;
++
++		if (rotation & RR_Reflect_Y)
++			req.orientation ^= OMAP_ORIENT_MASK_Y_INVERT;
++
++		DEBUG_MSG("setting orientation: %02x", req.orientation);
++
++		ret = drmCommandWrite(drmmode_crtc->drmmode->fd,
++				DRM_OMAP_SET_ORIENTATION, &req, sizeof(req));
++		if (ret) {
++			ERROR_MSG("failed to set orientation %s", strerror(errno));
++			return FALSE;
++		}
++
++		/* NOTE: driver is taking care of rotation in hw, which means
++		 * we need to deal w/ transformation of mouse cursor ourself..
++		 * see helper xf86CrtcTransformCursorPos() for help with that
++		 */
++
++		crtc->driverIsPerformingTransform = TRUE;
++	}
++#endif
++	return xf86CrtcRotate(crtc);
++}
++
+ static Bool
+ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+ 		Rotation rotation, int x, int y)
+@@ -240,8 +300,7 @@
+ 	drmmode_remove_fb(pScrn);
+ 
+ 	if (drmmode->fb_id == 0) {
+-		unsigned int pitch =
+-				OMAPCalculateStride(pScrn->virtualX, pScrn->bitsPerPixel);
++		unsigned int pitch = pScrn->displayWidth * (pScrn->bitsPerPixel / 8);
+ 
+ 		DEBUG_MSG("create framebuffer: %dx%d",
+ 				pScrn->virtualX, pScrn->virtualY);
+@@ -290,7 +349,7 @@
+ 		output_count++;
+ 	}
+ 
+-	if (!xf86CrtcRotate(crtc))
++	if (!drmmode_set_rotation(crtc, rotation))
+ 		goto done;
+ 
+ 	// Fixme - Intel puts this function here, and Nouveau puts it at the end
+@@ -1016,51 +1075,89 @@
+ 	return;
+ }
+ 
+-static Bool
+-drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
++Bool
++drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ {
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-	ScreenPtr pScreen = pScrn->pScreen;
++	Bool changed = FALSE;
++	uint32_t flags = OMAP_BO_SCANOUT | OMAP_BO_WC;
++	int width = pScrn->virtualX;
++	int height = pScrn->virtualY;
+ 	unsigned int pitch;
+ 
+-	TRACE_ENTER();
+-
+-	/* if fb required size has changed, realloc! */
+-
+-	DEBUG_MSG("Resize!  %dx%d", width, height);
+-
+-	pScrn->virtualX = width;
+-	pScrn->virtualY = height;
+-
+-	pitch = OMAPCalculateStride(width, pScrn->bitsPerPixel);
+-
+-	if ((pitch * height) != omap_bo_size(pOMAP->scanout)) {
+-		/* hmm, should we remove fb here.. we don't want to keep
+-		 * scanning out a deallocated buffer..
++	if (has_rotation(pOMAP)) {
++		/* if we are using tiled buffers, we really should check if
++		 * width/height has changed, rather than size.. for now, just
++		 * always re-alloc:
+ 		 */
+-		drmmode_remove_fb(pScrn);
++		changed = TRUE;
++		pitch = OMAPCalculateTiledStride(width, pScrn->bitsPerPixel);
++	} else {
++		pitch = OMAPCalculateStride(width, pScrn->bitsPerPixel);
++	}
+ 
+-		/* delete old scanout buffer */
+-		omap_bo_del(pOMAP->scanout);
++	if (pOMAP->scanout) {
++		if ((pitch * height) != omap_bo_size(pOMAP->scanout)) {
++			changed = TRUE;
++		}
++		if (changed) {
++			/* delete old scanout buffer */
++			omap_bo_del(pOMAP->scanout);
++		}
++	} else {
++		changed = TRUE;
++	}
+ 
+-		DEBUG_MSG("allocating new scanout buffer: %dx%d (%d)",
+-				width, height, pitch);
++	if (changed) {
++		/* we don't know yet if user wants rotation.. so if rotation
++		 * is supported we need to go ahead and allocate tiled buffer:
++		 */
++		if (has_rotation(pOMAP)) {
++			DEBUG_MSG("allocating tiled scanout buffer: %dx%d (%d)",
++					width, height, pitch);
++			flags |= OMAPTiledFlags(pScrn->bitsPerPixel);
++			pOMAP->scanout = omap_bo_new_tiled(pOMAP->dev,
++					width, height, flags);
++		} else {
++			DEBUG_MSG("allocating linear scanout buffer: %dx%d (%d)",
++					width, height, pitch);
++			pOMAP->scanout = omap_bo_new(pOMAP->dev, height * pitch, flags);
++		}
+ 
+-		/* allocate new scanout buffer */
+-		pOMAP->scanout = omap_bo_new(pOMAP->dev, height * pitch,
+-				OMAP_BO_SCANOUT | OMAP_BO_WC);
+ 		if (!pOMAP->scanout) {
+ 			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+ 					"Error reallocating scanout buffer\n");
+ 			return FALSE;
+ 		}
++
++		pScrn->displayWidth = pitch / (pScrn->bitsPerPixel / 8);
+ 	}
+ 
++	return TRUE;
++}
++
++static Bool
++drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
++{
++	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	ScreenPtr pScreen = pScrn->pScreen;
++
++	TRACE_ENTER();
++
++	DEBUG_MSG("Resize!  %dx%d", width, height);
++
++	pScrn->virtualX = width;
++	pScrn->virtualY = height;
++
++	if (!drmmode_reallocate_scanout(pScrn))
++		return FALSE;
++
+ 	if (pScreen && pScreen->ModifyPixmapHeader) {
+ 		PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
+ 		pScreen->ModifyPixmapHeader(rootPixmap,
+ 				pScrn->virtualX, pScrn->virtualY,
+-				pScrn->depth, pScrn->bitsPerPixel, pitch,
++				pScrn->depth, pScrn->bitsPerPixel,
++				pScrn->displayWidth * (pScrn->bitsPerPixel / 8),
+ 				omap_bo_map(pOMAP->scanout));
+ 	}
+ 
+Index: xf86-video-omap/src/omap_driver.c
+===================================================================
+--- xf86-video-omap.orig/src/omap_driver.c	2012-03-02 16:44:23.000000000 +0000
++++ xf86-video-omap/src/omap_driver.c	2012-03-21 19:10:02.000000000 +0000
+@@ -196,29 +196,21 @@
+ 	return stride;
+ }
+ 
++unsigned int
++OMAPTiledFlags(unsigned int bitsPerPixel)
++{
++	switch(bitsPerPixel) {
++	case 32: return OMAP_BO_TILED_32;
++	case 16: return OMAP_BO_TILED_16;
++	case 8:  return OMAP_BO_TILED_8;
++	default: return 0;
++	}
++}
+ 
+ static Bool
+ OMAPMapMem(ScrnInfoPtr pScrn)
+ {
+-	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-	int pitch;
+-
+-	pitch = OMAPCalculateStride(pScrn->virtualX, pScrn->bitsPerPixel);
+-
+-	DEBUG_MSG("allocating new scanout buffer: %dx%d (%d)",
+-			pScrn->virtualX, pScrn->virtualY, pitch);
+-
+-	pOMAP->scanout = omap_bo_new(pOMAP->dev, pScrn->virtualY * pitch,
+-			OMAP_BO_SCANOUT | OMAP_BO_WC);
+-	if (!pOMAP->scanout) {
+-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+-			   "Error allocating scanout buffer\n");
+-		return FALSE;
+-	}
+-
+-	pScrn->displayWidth = pitch / (pScrn->bitsPerPixel / 8);
+-
+-	return TRUE;
++	return drmmode_reallocate_scanout(pScrn);
+ }
+ 
+ 
+@@ -812,6 +804,18 @@
+ 		goto fail;
+ 	}
+ 
++	if (has_rotation(pOMAP)) {
++		xf86RandR12SetRotations(pScreen, RR_Rotate_0 | RR_Rotate_90 |
++				RR_Rotate_180 | RR_Rotate_270 | RR_Reflect_X | RR_Reflect_Y);
++	} else {
++#if ! defined(DRM_OMAP_SET_ORIENTATION)
++		WARNING_MSG("rotation not supported by libdrm_omap version");
++#elif XF86_CRTC_VERSION < 4
++		WARNING_MSG("rotation not supported by XF86_CRTC_VERSION version: %d",
++				XF86_CRTC_VERSION);
++#endif
++	}
++
+ 	if (!miCreateDefColormap(pScreen)) {
+ 		ERROR_MSG("Cannot create colormap!");
+ 		goto fail;
+Index: xf86-video-omap/src/omap_driver.h
+===================================================================
+--- xf86-video-omap.orig/src/omap_driver.h	2012-03-02 16:44:23.000000000 +0000
++++ xf86-video-omap/src/omap_driver.h	2012-03-21 19:10:02.000000000 +0000
+@@ -115,6 +115,7 @@
+ OMAPCalculateStride(unsigned int fbWidth, unsigned int bitsPerPixel);
+ extern unsigned int
+ OMAPCalculateTiledStride(unsigned int width, unsigned int bitsPerPixel);
++unsigned int OMAPTiledFlags(unsigned int bitsPerPixel);
+ 
+ 
+ 
+@@ -173,6 +174,20 @@
+ 			pOMAP->pOMAPEXA->PutTextureImage;
+ }
+ 
++static inline Bool has_dmm(OMAPPtr pOMAP)
++{
++	return pOMAP->chipset >= 0x4430;
++}
++
++static inline Bool has_rotation(OMAPPtr pOMAP)
++{
++#if defined(DRM_OMAP_SET_ORIENTATION) && (XF86_CRTC_VERSION >= 4)
++	return has_dmm(pOMAP);
++#else
++	return FALSE;
++#endif
++}
++
+ /** Return a pointer to the driver's private structure. */
+ #define OMAPPTR(p) ((OMAPPtr)((p)->driverPrivate))
+ #define OMAPPTR_FROM_SCREEN(pScreen) \
+@@ -215,6 +230,7 @@
+ void drmmode_remove_fb(ScrnInfoPtr pScrn);
+ Bool drmmode_page_flip(DrawablePtr draw, uint32_t fb_id, void *priv);
+ Bool drmmode_cursor_init(ScreenPtr pScreen);
++Bool drmmode_reallocate_scanout(ScrnInfoPtr pScrn);
+ 
+ 
+ /**
--- xf86-video-omap-0.0.4.orig/debian/patches/0003_add-headers.patch
+++ xf86-video-omap-0.0.4/debian/patches/0003_add-headers.patch
@@ -0,0 +1,11 @@
+Index: xf86-video-omap/src/Makefile.am
+===================================================================
+--- xf86-video-omap.orig/src/Makefile.am	2012-03-27 12:44:10.000000000 +0000
++++ xf86-video-omap/src/Makefile.am	2012-03-27 12:49:12.000000000 +0000
+@@ -49,3 +49,6 @@
+          omap_xv.c \
+          omap_dri2.c \
+          omap_driver.c
++
++omap_drvincludedir = ${includedir}
++omap_drvinclude_HEADERS = omap_driver.h omap_exa.h omap_util.h
--- xf86-video-omap-0.0.4.orig/debian/patches/series
+++ xf86-video-omap-0.0.4/debian/patches/series
@@ -0,0 +1,4 @@
+0001-WIP-dri2video.patch
+0002-xrandr-rotation.patch
+0003_add-headers.patch
+0004-only-use-tiled-buffers-if-rotation-is-used-v2.patch
--- xf86-video-omap-0.0.4.orig/debian/patches/0001-WIP-dri2video.patch
+++ xf86-video-omap-0.0.4/debian/patches/0001-WIP-dri2video.patch
@@ -0,0 +1,476 @@
+From 89bd8d3c2060defb5e0eb2b0455f269229255f7a Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Fri, 27 Jan 2012 11:17:23 -0600
+Subject: [PATCH] WIP: dri2video
+
+---
+ src/omap_dri2.c |  335 +++++++++++++++++++++++++++++++++++++++++++++++++-----
+ 1 files changed, 304 insertions(+), 31 deletions(-)
+
+diff --git a/src/omap_dri2.c b/src/omap_dri2.c
+index 8a1013c..d6c703c 100644
+--- a/src/omap_dri2.c
++++ b/src/omap_dri2.c
+@@ -37,7 +37,7 @@
+ #include "dri2.h"
+ 
+ /* any point to support earlier? */
+-#if DRI2INFOREC_VERSION < 4
++#if DRI2INFOREC_VERSION < 7
+ #	error "Requires newer DRI2"
+ #endif
+ 
+@@ -58,6 +58,14 @@ typedef struct {
+ 	 */
+ 	uint32_t fb_id;
+ 
++	/**
++	 * For multi-planar formats, extra buffer info..
++	 */
++	int extraCount;
++	PixmapPtr *extraPix;
++	unsigned int *extraNames;
++	unsigned int *extraPitches;
++
+ } OMAPDRI2BufferRec, *OMAPDRI2BufferPtr;
+ 
+ #define OMAPBUF(p)	((OMAPDRI2BufferPtr)(p))
+@@ -116,6 +124,36 @@ createpix(DrawablePtr pDraw)
+ 			pDraw->width, pDraw->height, pDraw->depth, flags);
+ }
+ 
++static OMAPDRI2BufferPtr
++createbuf(DrawablePtr pDraw, PixmapPtr pPixmap, int attachment, int format)
++{
++	ScreenPtr pScreen = pDraw->pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPDRI2BufferPtr buf = calloc(1, sizeof(*buf));
++	int ret;
++
++	if (!buf) {
++		return NULL;
++	}
++
++	DRIBUF(buf)->attachment = attachment;
++	DRIBUF(buf)->pitch = exaGetPixmapPitch(pPixmap);
++	DRIBUF(buf)->cpp = pPixmap->drawable.bitsPerPixel / 8;
++	DRIBUF(buf)->format = format;
++
++	ret = omap_bo_get_name(OMAPPixmapBo(pPixmap), &DRIBUF(buf)->name);
++	if (ret) {
++		ERROR_MSG("could not get buffer name: %d", ret);
++		return NULL;
++	}
++
++	if (attachment != DRI2BufferFrontLeft) {
++		buf->pPixmap = pPixmap;
++	}
++
++	return buf;
++}
++
+ /**
+  * Create Buffer.
+  *
+@@ -133,28 +171,28 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 	ScreenPtr pScreen = pDraw->pScreen;
+ 	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-	OMAPDRI2BufferPtr buf = calloc(1, sizeof(*buf));
++	OMAPDRI2BufferPtr buf;
+ 	PixmapPtr pPixmap;
+-	struct omap_bo *bo;
+-	int ret;
+ 
+ 	DEBUG_MSG("pDraw=%p, attachment=%d, format=%08x",
+ 			pDraw, attachment, format);
+ 
+-	if (!buf) {
+-		return NULL;
+-	}
+-
+ 	if (attachment == DRI2BufferFrontLeft) {
+ 		pPixmap = draw2pix(pDraw);
+ 
++#if 0
+ 		/* to do flipping, we need a scanout capable (physically contiguous)
+ 		 * buffer.. this bit of gymnastics ensures that.
+ 		 *
+ 		 * TODO we may need to re-allocate and switch back to non-scanout
+ 		 * buffer when client disconnects from drawable..
++		 *
++		 * TODO don't reallocate buffers that are already scanout!  Check
++		 * for and avoid deleting pOMAP->scanout!!  And we
++		 * need back-buffers to be scannout capable to.. so this this all
++		 * messed up!!
+ 		 */
+-		if (canflip(pDraw)) {
++		if (canflip(pDraw) && !has_dmm(pOMAP)) {
+ 			/* need to re-allocate pixmap to get a scanout capable buffer */
+ 			PixmapPtr pNewPix = createpix(pDraw);
+ 
+@@ -164,27 +202,12 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 
+ 			pScreen->DestroyPixmap(pNewPix);
+ 		}
++#endif
+ 	} else {
+ 		pPixmap = createpix(pDraw);
+ 	}
+ 
+-	bo = OMAPPixmapBo(pPixmap);
+-
+-	DRIBUF(buf)->attachment = attachment;
+-	DRIBUF(buf)->pitch = exaGetPixmapPitch(pPixmap);
+-	DRIBUF(buf)->cpp = pPixmap->drawable.bitsPerPixel / 8;
+-	DRIBUF(buf)->format = format;
+-
+-	ret = omap_bo_get_name(bo, &DRIBUF(buf)->name);
+-	if (ret) {
+-		ERROR_MSG("could not get buffer name: %d", ret);
+-		/* TODO cleanup */
+-		return NULL;
+-	}
+-
+-	if (attachment != DRI2BufferFrontLeft) {
+-		buf->pPixmap = pPixmap;
+-	}
++	buf = createbuf(pDraw, pPixmap, attachment, format);
+ 
+ 	/* Q: how to know across OMAP generations what formats that the display
+ 	 * can support directly?
+@@ -194,7 +217,7 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 	if (canflip(pDraw)) {
+ 		int ret = drmModeAddFB(pOMAP->drmFD, pDraw->width, pDraw->height,
+ 				pDraw->depth, pDraw->bitsPerPixel, DRIBUF(buf)->pitch,
+-				omap_bo_handle(bo), &buf->fb_id);
++				omap_bo_handle(OMAPPixmapBo(pPixmap)), &buf->fb_id);
+ 		if (ret) {
+ 			/* to-bad, so-sad, we can't flip */
+ 			WARNING_MSG("could not create fb: %d", ret);
+@@ -205,6 +228,84 @@ OMAPDRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
+ 	return DRIBUF(buf);
+ }
+ 
++static DRI2BufferPtr
++OMAPDRI2CreateBufferVid(DrawablePtr pDraw, unsigned int attachment,
++		unsigned int format, unsigned int width, unsigned int height)
++{
++	ScreenPtr pScreen = pDraw->pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPDRI2BufferPtr buf;
++	PixmapPtr pPixmap;
++	int bpp, extraCount = 0, ew = width, eh = height;
++
++	DEBUG_MSG("pDraw=%p, attachment=%d, format=%08x",
++			pDraw, attachment, format);
++
++	switch(format) {
++	case fourcc_code('I','4','2','0'):
++	case fourcc_code('Y','V','1','2'):
++		extraCount++;
++		ew /= 2;
++		/* fallthru */
++	case fourcc_code('N','V','1','2'):
++		extraCount++;
++		eh /= 2;
++		bpp = 8;
++		break;
++	case fourcc_code('U','Y','V','Y'):
++	case fourcc_code('Y','U','Y','2'):
++		bpp = 16;
++		break;
++	default:
++		return NULL;
++	}
++
++	/* main buffer, luma buffer in case of multi-planar.. */
++	pPixmap = pScreen->CreatePixmap(pScreen, width, height, bpp, 0);
++
++	buf = createbuf(pDraw, pPixmap, attachment, format);
++
++	if (extraCount > 0) {
++		int i, ret;
++
++		buf->extraPix = malloc(extraCount * sizeof(buf->extraPix[0]));
++		buf->extraNames = malloc(extraCount * sizeof(buf->extraNames[0]));
++		buf->extraPitches = malloc(extraCount * sizeof(buf->extraPitches[0]));
++		buf->extraCount = extraCount;
++
++		for (i = 0; i < extraCount; i++) {
++			PixmapPtr p = pScreen->CreatePixmap(pScreen, ew, eh, bpp, 0);
++
++			buf->extraPix[i] = p;
++			buf->extraPitches[i] = exaGetPixmapPitch(p);
++
++			ret = omap_bo_get_name(OMAPPixmapBo(p), &buf->extraNames[i]);
++			if (ret) {
++				ERROR_MSG("could not get buffer name: %d", ret);
++				/* TODO: cleanup.. */
++				return NULL;
++			}
++		}
++	}
++
++	return DRIBUF(buf);
++}
++
++/**
++ * An ugly approach to avoid changing DRI2BufferPtr and cause ABI breakage
++ * between driver and xserver.  This only needs to be implemented by drivers
++ * supporting planar formats with one buffer per plane.
++ */
++static unsigned int
++OMAPDRI2GetExtraBufferNames(DrawablePtr pDraw, DRI2BufferPtr buffer,
++		unsigned int **names, unsigned int **pitches)
++{
++	OMAPDRI2BufferPtr buf = OMAPBUF(buffer);
++	*names = buf->extraNames;
++	*pitches = buf->extraPitches;
++	return buf->extraCount;
++}
++
+ /**
+  * Destroy Buffer
+  *
+@@ -219,6 +320,7 @@ OMAPDRI2DestroyBuffer(DrawablePtr pDraw, DRI2BufferPtr buffer)
+ 	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
+ 	OMAPDRI2BufferPtr buf = OMAPBUF(buffer);
++	int i;
+ 
+ 	DEBUG_MSG("pDraw=%p, buffer=%p", pDraw, buffer);
+ 
+@@ -232,6 +334,14 @@ OMAPDRI2DestroyBuffer(DrawablePtr pDraw, DRI2BufferPtr buffer)
+ 		pScreen->DestroyPixmap(buf->pPixmap);
+ 	}
+ 
++	for (i = 0; i < buf->extraCount; i++) {
++		pScreen->DestroyPixmap(buf->extraPix[i]);
++	}
++
++	free(buf->extraPix);
++	free(buf->extraNames);
++	free(buf->extraPitches);
++
+ 	free(buf);
+ }
+ 
+@@ -252,12 +362,19 @@ OMAPDRI2CopyRegion(DrawablePtr pDraw, RegionPtr pRegion,
+ 	DEBUG_MSG("pDraw=%p, pDstBuffer=%p (%p), pSrcBuffer=%p (%p)",
+ 			pDraw, pDstBuffer, pSrcDraw, pSrcBuffer, pDstDraw);
+ 
++	if (pDstBuffer->attachment == DRI2BufferFakeFrontLeft) {
++		/* I think we don't need this.. it should be handled
++		 * on client side (I think)..
++		 */
++		return;
++	}
++
+ 	pGC = GetScratchGC(pDstDraw->depth, pScreen);
+ 	if (!pGC) {
+ 		return;
+ 	}
+ 
+-	pCopyClip = REGION_CREATE(pScreen, NULL, 0);
++	pCopyClip = RegionCreate(NULL, 0);
+ 	RegionCopy(pCopyClip, pRegion);
+ 	(*pGC->funcs->ChangeClip) (pGC, CT_REGION, pCopyClip, 0);
+ 	ValidateGC(pDstDraw, pGC);
+@@ -397,6 +514,105 @@ OMAPDRI2ScheduleSwap(ClientPtr client, DrawablePtr pDraw,
+ 	return TRUE;
+ }
+ 
++static int OMAPDRI2PutTextureImage(
++		PixmapPtr pSrcPix, BoxPtr pSrcBox,
++		PixmapPtr pOsdPix, BoxPtr pOsdBox,
++		PixmapPtr pDstPix, BoxPtr pDstBox,
++		void *closure)
++{
++	ScreenPtr pScreen = pDstPix->drawable.pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	OMAPDRISwapCmd *cmd = closure;
++	OMAPDRI2BufferPtr src = OMAPBUF(cmd->pSrcBuffer);
++	Bool ret;
++
++	ret = pOMAP->pOMAPEXA->PutTextureImage(pSrcPix, pSrcBox,
++			pOsdPix, pOsdBox, pDstPix, pDstBox,
++			src->extraCount, src->extraPix,
++			cmd->pSrcBuffer->format);
++	if (ret) {
++		return Success;
++	}
++	DEBUG_MSG("PutTextureImage failed");
++
++	return BadImplementation;
++}
++
++
++/**
++ * Schedule a video buffer swap
++ *
++ * Drivers should queue an event for the frame count that satisfies the
++ * parameters passed in.  If the event is in the future (i.e. the conditions
++ * aren't currently satisfied), the server may block the client at the next
++ * GLX request using DRI2WaitSwap. When the event arrives, drivers should call
++ * \c DRI2SwapComplete, which will handle waking the client and returning
++ * the appropriate data.
++ *
++ * The DDX is responsible for doing an overlay buffer flip/exchange, or
++ * scaling/colorconvert blit when the corresponding event arrives.
++ *
++ * If the target drawable is resized/damaged, or the osd pixmap is changed/
++ * damaged, ScheduleSwapVid can be re-invoked by the core with the same
++ * source buffer to repair the dri2 video drawable.
++ */
++static Bool
++OMAPDRI2ScheduleSwapVid(ClientPtr client, DrawablePtr pDraw,
++		DRI2BufferPtr pDstBuffer, DRI2BufferPtr pSrcBuffer,
++		BoxPtr pSrcBox, DrawablePtr osd,
++		CARD64 *target_msc, CARD64 divisor, CARD64 remainder,
++		DRI2SwapEventPtr func, void *data)
++{
++	ScreenPtr pScreen = pDraw->pScreen;
++	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
++	OMAPDRISwapCmd *cmd = calloc(1, sizeof(*cmd));
++	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	RegionPtr pCopyClip;
++	GCPtr pGC;
++	BoxRec dstbox = {
++			.x1 = pDraw->x, .y1 = pDraw->y,
++			.x2 = pDraw->x + pDraw->width, .y2 = pDraw->y + pDraw->height
++	};
++	BoxRec osdbox = {
++			.x1 = 0, .y1 = 0,
++			.x2 = osd ? osd->width : 0, .y2 = osd ? osd->height : 0,
++	};
++
++	cmd->client = client;
++	cmd->pDraw = pDraw;
++	cmd->pSrcBuffer = pSrcBuffer;
++	cmd->pDstBuffer = pDstBuffer;
++	cmd->func = func;
++	cmd->data = data;
++
++	DEBUG_MSG("%d -> %d", pSrcBuffer->attachment, pDstBuffer->attachment);
++
++	pGC = GetScratchGC(pDraw->depth, pScreen);
++	if (!pGC) {
++		return FALSE;
++	}
++
++	pCopyClip = RegionCreate(&dstbox, 1);
++	(*pGC->funcs->ChangeClip) (pGC, CT_REGION, pCopyClip, 0);
++	ValidateGC(pDraw, pGC);
++
++	/* someday, support overlay too.. */
++	if (has_video(pOMAP)) {
++		if (OMAPVidCopyArea(dri2draw(pDraw, pSrcBuffer), pSrcBox,
++				osd, &osdbox, dri2draw(pDraw, pDstBuffer), &dstbox,
++				OMAPDRI2PutTextureImage, cmd, pCopyClip) == Success) {
++			OMAPDRI2SwapComplete(cmd);
++			return TRUE;
++		}
++	}
++
++	// XXX for RGB formats, we should be able to fall back to
++	// generic composite operation..
++
++	return FALSE;
++}
++
+ /**
+  * Request a DRM event when the requested conditions will be satisfied.
+  *
+@@ -417,6 +633,37 @@ OMAPDRI2ScheduleWaitMSC(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
+ 	return FALSE;
+ }
+ 
++#define ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
++
++static int
++OMAPDRI2SetAttribute(DrawablePtr pDraw, Atom attribute,
++		int len, const CARD32 *val)
++{
++	/* just for testing.. bogus colorspace conversion matrix.. */
++	if (attribute == ATOM("XV_CSC_MATRIX")) {
++		return Success;
++	}
++	return BadMatch;
++}
++
++static int
++OMAPDRI2GetAttribute(DrawablePtr pDraw, Atom attribute,
++		int *len, const CARD32 **val)
++{
++	/* just for testing.. bogus colorspace conversion matrix.. */
++	if (attribute == ATOM("XV_CSC_MATRIX")) {
++		static const CARD32 csc[] = {
++				0x00, 0x01, 0x02, 0x03,
++				0x10, 0x11, 0x12, 0x13,
++				0x20, 0x21, 0x22, 0x23,
++		};
++		*val = csc;
++		*len = sizeof(csc) / 4;
++		return Success;
++	}
++	return BadMatch;
++}
++
+ /**
+  * The DRI2 ScreenInit() function.. register our handler fxns w/ DRI2 core
+  */
+@@ -425,20 +672,46 @@ OMAPDRI2ScreenInit(ScreenPtr pScreen)
+ {
+ 	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	const char *driverNames[] = {
++			[DRI2DriverDRI] = "omap",
++			[DRI2DriverXV]  = has_video(pOMAP) ? "omap" : NULL,
++	};
+ 	DRI2InfoRec info = {
+-			.version			= 5,
++			.version			= 7,
+ 			.fd 				= pOMAP->drmFD,
+-			.driverName			= "omap",
++			.numDrivers			= 3,
++			.driverNames		= driverNames,
++			.driverName			= driverNames[DRI2DriverDRI],
+ 			.deviceName			= pOMAP->deviceName,
+ 			.CreateBuffer		= OMAPDRI2CreateBuffer,
++			.CreateBufferVid	= OMAPDRI2CreateBufferVid,
+ 			.DestroyBuffer		= OMAPDRI2DestroyBuffer,
+ 			.CopyRegion			= OMAPDRI2CopyRegion,
+ 			.ScheduleSwap		= OMAPDRI2ScheduleSwap,
++			.ScheduleSwapVid	= OMAPDRI2ScheduleSwapVid,
+ 			.ScheduleWaitMSC	= OMAPDRI2ScheduleWaitMSC,
+ 			.GetMSC				= OMAPDRI2GetMSC,
+ 			.AuthMagic			= drmAuthMagic,
++			.GetExtraBufferNames= OMAPDRI2GetExtraBufferNames,
++			.SetAttribute		= OMAPDRI2SetAttribute,
++			.GetAttribute		= OMAPDRI2GetAttribute,
+ 	};
+-	int minor = 1, major = 0;
++	int minor = 1, major = 0, nformats = 0;
++	static unsigned int formats[MAX_FORMATS + 4];
++
++	if (has_video(pOMAP)) {
++		/* add supported video formats: */
++		nformats = pOMAP->pOMAPEXA->GetFormats(formats);
++	}
++
++	/* add supported non-video formats: */
++	formats[nformats++] = 24;
++	formats[nformats++] = 32;
++	formats[nformats++] = fourcc_code('R','G','B','3');
++	formats[nformats++] = fourcc_code('R','G','B','4');
++
++	info.formats = formats;
++	info.numFormats = nformats;
+ 
+ 	if (xf86LoaderCheckSymbol("DRI2Version")) {
+ 		DRI2Version(&major, &minor);
+-- 
+1.7.5.1
+
--- xf86-video-omap-0.0.4.orig/debian/patches/0004-only-use-tiled-buffers-if-rotation-is-used-v2.patch
+++ xf86-video-omap-0.0.4/debian/patches/0004-only-use-tiled-buffers-if-rotation-is-used-v2.patch
@@ -0,0 +1,159 @@
+From 0d42b2de7f9202e816a643694ee537b20e9705e9 Mon Sep 17 00:00:00 2001
+From: Rob Clark <rob@ti.com>
+Date: Thu, 22 Mar 2012 16:00:13 -0500
+Subject: [PATCH 1/2] only use tiled buffers if rotation is used v2
+
+---
+ src/drmmode_display.c |   63 +++++++++++++++++++++++++++++++++++--------------
+ 1 files changed, 45 insertions(+), 18 deletions(-)
+
+diff --git a/src/drmmode_display.c b/src/drmmode_display.c
+index d46ecb2..4a3ea53 100644
+--- a/src/drmmode_display.c
++++ b/src/drmmode_display.c
+@@ -112,11 +112,13 @@ typedef struct {
+ 	struct udev_monitor *uevent_monitor;
+ 	InputHandlerProc uevent_handler;
+ 	drmmode_cursor_ptr cursor;
++	int rotated_crtcs;
+ } drmmode_rec, *drmmode_ptr;
+ 
+ typedef struct {
+ 	drmmode_ptr drmmode;
+ 	drmModeCrtcPtr mode_crtc;
++	Rotation rotation;
+ } drmmode_crtc_private_rec, *drmmode_crtc_private_ptr;
+ 
+ typedef struct {
+@@ -293,12 +295,39 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+ 	int i;
+ 	int fb_id;
+ 	drmModeModeInfo kmode;
++	Bool was_rotated = drmmode->rotated_crtcs > 0;
+ 
+ 	TRACE_ENTER();
+ 
+ 	/* remove old fb if it exists */
+ 	drmmode_remove_fb(pScrn);
+ 
++	/* update the count of number of rotated CRTCs.. if we have one or more
++	 * rotated outputs then we want to use a tiled buffer, but otherwise
++	 * stick with non-tiled
++	 */
++	if ((drmmode_crtc->rotation != RR_Rotate_0) &&
++			(rotation == RR_Rotate_0)) {
++		DEBUG_MSG("disabling rotation for crtc: %u",
++				drmmode_crtc->mode_crtc->crtc_id);
++		drmmode->rotated_crtcs--;
++	} else if ((drmmode_crtc->rotation == RR_Rotate_0) &&
++			(rotation != RR_Rotate_0)) {
++		DEBUG_MSG("enabling rotation for crtc: %u",
++				drmmode_crtc->mode_crtc->crtc_id);
++		drmmode->rotated_crtcs++;
++	}
++
++	drmmode_crtc->rotation = rotation;
++
++	/* at this point, if we are transitioning from unrotated to rotated
++	 * or visa versa, then we need to reallocate the scanout buffer..
++	 */
++	if (was_rotated != (drmmode->rotated_crtcs > 0)) {
++		/* reallocate scanout buffer.. */
++		drmmode_reallocate_scanout(pScrn);
++	}
++
+ 	if (drmmode->fb_id == 0) {
+ 		unsigned int pitch = pScrn->displayWidth * (pScrn->bitsPerPixel / 8);
+ 
+@@ -392,7 +421,7 @@ done:
+ 		free(output_ids);
+ 	}
+ 	if (!ret) {
+-		/* If there was a problem, resture the old mode: */
++		/* If there was a problem, restore the old mode: */
+ 		crtc->x = saved_x;
+ 		crtc->y = saved_y;
+ 		crtc->rotation = saved_rotation;
+@@ -622,6 +651,7 @@ drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
+ 	drmmode_crtc->mode_crtc = drmModeGetCrtc(drmmode->fd,
+ 			drmmode->mode_res->crtcs[num]);
+ 	drmmode_crtc->drmmode = drmmode;
++	drmmode_crtc->rotation = RR_Rotate_0;
+ 
+ 	// FIXME - potentially add code to allocate a HW cursor here.
+ 
+@@ -1079,13 +1109,16 @@ Bool
+ drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ {
+ 	OMAPPtr pOMAP = OMAPPTR(pScrn);
++	ScreenPtr pScreen = pScrn->pScreen;
++	drmmode_ptr drmmode = drmmode_from_scrn(pScrn);
+ 	Bool changed = FALSE;
+ 	uint32_t flags = OMAP_BO_SCANOUT | OMAP_BO_WC;
+ 	int width = pScrn->virtualX;
+ 	int height = pScrn->virtualY;
+ 	unsigned int pitch;
++	Bool rotate = has_rotation(pOMAP) && drmmode->rotated_crtcs > 0;
+ 
+-	if (has_rotation(pOMAP)) {
++	if (rotate) {
+ 		/* if we are using tiled buffers, we really should check if
+ 		 * width/height has changed, rather than size.. for now, just
+ 		 * always re-alloc:
+@@ -1112,7 +1145,7 @@ drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ 		/* we don't know yet if user wants rotation.. so if rotation
+ 		 * is supported we need to go ahead and allocate tiled buffer:
+ 		 */
+-		if (has_rotation(pOMAP)) {
++		if (rotate) {
+ 			DEBUG_MSG("allocating tiled scanout buffer: %dx%d (%d)",
+ 					width, height, pitch);
+ 			flags |= OMAPTiledFlags(pScrn->bitsPerPixel);
+@@ -1131,6 +1164,15 @@ drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ 		}
+ 
+ 		pScrn->displayWidth = pitch / (pScrn->bitsPerPixel / 8);
++
++		if (pScreen && pScreen->ModifyPixmapHeader) {
++			PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
++			pScreen->ModifyPixmapHeader(rootPixmap,
++					pScrn->virtualX, pScrn->virtualY,
++					pScrn->depth, pScrn->bitsPerPixel,
++					pScrn->displayWidth * (pScrn->bitsPerPixel / 8),
++					omap_bo_map(pOMAP->scanout));
++		}
+ 	}
+ 
+ 	return TRUE;
+@@ -1139,11 +1181,6 @@ drmmode_reallocate_scanout(ScrnInfoPtr pScrn)
+ static Bool
+ drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
+ {
+-	OMAPPtr pOMAP = OMAPPTR(pScrn);
+-	ScreenPtr pScreen = pScrn->pScreen;
+-
+-	TRACE_ENTER();
+-
+ 	DEBUG_MSG("Resize!  %dx%d", width, height);
+ 
+ 	pScrn->virtualX = width;
+@@ -1152,16 +1189,6 @@ drmmode_xf86crtc_resize(ScrnInfoPtr pScrn, int width, int height)
+ 	if (!drmmode_reallocate_scanout(pScrn))
+ 		return FALSE;
+ 
+-	if (pScreen && pScreen->ModifyPixmapHeader) {
+-		PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
+-		pScreen->ModifyPixmapHeader(rootPixmap,
+-				pScrn->virtualX, pScrn->virtualY,
+-				pScrn->depth, pScrn->bitsPerPixel,
+-				pScrn->displayWidth * (pScrn->bitsPerPixel / 8),
+-				omap_bo_map(pOMAP->scanout));
+-	}
+-
+-	TRACE_EXIT();
+ 	return TRUE;
+ }
+ 
+-- 
+1.7.4.1
+
