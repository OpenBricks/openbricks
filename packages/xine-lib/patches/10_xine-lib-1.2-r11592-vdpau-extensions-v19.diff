diff --git a/README-VDPAU-EXTENSIONS-PATCH.DE b/README-VDPAU-EXTENSIONS-PATCH.DE
new file mode 100644
index 0000000..2acfe2f
--- /dev/null
+++ b/README-VDPAU-EXTENSIONS-PATCH.DE
@@ -0,0 +1,51 @@
+Der VDPAU extensions patch erweitert die xine-lib 1.2 um folgende Funktionen:
+
+Optimiert die Funktion zum lesen der Bilddaten aus einer VDPAU video surface in dem es die Verwendung von
+dynamisch allokierten Zwischenbuffern vermeidet. Die Funktion wird z.b. von dem
+xine autocrop plugin verwendet dass im Lieferumfang des xineliboutput plugin enthalten ist.
+Weiterhin werden zwei Bugs in der xine-lib beseitigt die beim Einsatz des autocrop plugin zum tragen kommen.
+
+
+Vereinheitlicht die Verarbeitung von RLE codierten overlays (werden im xineliboutput player verwendet) und ARGB
+codierten overlays (werden im xine-ui player verwendet). Bei beiden Formaten wird jetzt skaliertes und
+unskalierten OSD unterstützt sowie die Positionierung eines Video-Fenster innerhalb des OSD. Durch die einheitliche
+Verarbeitung arbeitet auch das autocrop plugin (und vermutlich auch diverse VDR-Plugins die das OSD-Videofenster nutzen)
+jetzt mit beiden playern richtig zusammen. Weiterhin benötigt die Implementierung nur zwei zusätzliche VDPAU output surface
+Objekte anstatt drei.
+
+
+Erweitert das Protokoll der Funktion 'xine_port_send_gui_data' um die Möglichkeit, die im VDPAU Treiber nach der Verarbeitung
+im VDPAU video mixer ausgegebenen Videoframes, die dem tatsächlich angezeigten Bildinhalt entsprechen (also inkl. OSD, deinterlacing,
+Skalierung und Bildkorrekturen), als RGB-Image zu grabben.
+Weiterhin wird das xine input plugin für das VDR xine plugin um eine entsprechende frame grab Funktion erweitert. (Entsprechende
+Funktion ist auch bereits im xineliboutput plugin standardmäßig enthalten).
+Durch die grab Erweiterung funktionieren jetzt (laufender xine player vorausgesetzt) die Videofenster im vdradmin oder vdr live plugin
+vernüftig. Weiterhin wird die GRAB-Erweiterung vom xine atmo und vdr atmo plugin verwendet.
+
+
+Die Anzahl der VDPAU output surfaces, die für die Ausgabe der Bilddaten an die VDPAU display queue übergeben werden, kann über
+ein neues Konfigurationsparameter 'video.output.vdpau_display_queue_length' eingestellt werden. Bisher wurden immer nur zwei surfaces
+verwendet. Insbesondere bei schwächerer GPU Hardware kann das knappe Timing des video ausgabe thread durch erhöhen der Anzahl surfaces 
+verbessert werden wodurch es zu weniger dropped frames kommt. Allerdings sollte man den Wert behutsam erhöhen da höhere Werte zu
+Zeitversatz zwischen Video und Audio führen kann.
+Der Wert kann im Bereich 2 ... 8 surfaces gewählt werden. Der Standardwert ist jetzt 3.
+
+
+Über dass neue Konfigurationsparameter 'video.output.vdpau_sd_only_properties' kann die Wirkung des Schärfe- und Rauschfilters auf
+Videos im SD Format (< 800 horizontale Bildpunkte) beschränkt werden.
+
+
+Es wird jetzt im Log eine Fehlermeldung ausgegeben, wenn dass erhöhen der Prozesspriorität für den decoder und video out thread fehlschlägt.
+
+
+Für die wichtigen VDPAU-Funktionsaufrufe kann ein Profiling zugeschaltet werden dass die Ausführungsdauer der Funktionsaufrufe 
+entweder in regelmäßigen Abständen und/oder bei ungewöhnlich langen Ausführungszeiten protokoliert.
+Das Profiling kann durch editieren folgender Zeilen in der Datei 'src/xine-engine/accel_vdpau.h' konfigriert werden:
+	#define VDPAU_PROFILING                                            /* uncomment this if you want profiling statistics of vdpau function calls */
+	#define VDPAU_PROFILING_STATISTICS_RATE            0 /*(50*60*3)   /* number of calls to be executed after that statistics will be logged */
+	#define VDPAU_PROFILING_UNUSUAL_DURATION_LIMIT     250000          /* [us] limit for unusual long execution time of a call */
+
+
+Im VDPAU Ausgabemodule 'src/video_out/video_out_vdpau.c' wird das define LOCKDISPLAY undefined damit decoder thread und video out thread
+wirklich parallel ablaufen können.
+Dies muss rückgängig gemacht werden falls eine ältere Betriebsystemumgebung mit fehlerhafter libxcb verwendet wird!!!
diff --git a/include/xine.h b/include/xine.h
index 1d659a9..d893c6b 100644
--- a/include/xine.h
+++ b/include/xine.h
@@ -1395,6 +1395,29 @@ typedef struct {
 
 #endif /* WIN32 */
 
+
+/*
+ * frame structure used for grabbing raw RGB output frames
+ */
+typedef struct {
+    /* Cropping of source image */
+  int crop_left;
+  int crop_right;
+  int crop_top;
+  int crop_bottom;
+
+    /* Parameters of returned image */
+  int width;
+  int height;
+  uint8_t *img;
+  int64_t vpts;
+
+  int timeout;       /* Max. time to wait for next frame in milliseconds */
+  int continuous;    /* If true optimize resource allocation for continuous frame grabbing */
+
+} xine_grab_frame_t;
+
+
 /*
  * "type" constants for xine_port_send_gui_data(...)
  */
@@ -1424,6 +1447,18 @@ typedef struct {
 /* Gui is about to destroy drawable */
 #define XINE_GUI_SEND_WILL_DESTROY_DRAWABLE  9
 
+/* Allocate grab frame */
+/* xine_grab_frame_t **data */
+#define XINE_GUI_SEND_ALLOC_GRAB_FRAME       10
+
+/* Free grab frame */
+/* xine_grab_frame_t *data */
+#define XINE_GUI_SEND_FREE_GRAB_FRAME        11
+
+/* Grab image of last displayed frame */
+/* xine_grab_frame_t *data */
+#define XINE_GUI_SEND_GRAB_FRAME             12
+
 
 /*********************************************************************
  * xine health check stuff                                           *
diff --git a/include/xine/vdr.h b/include/xine/vdr.h
index c45cee1..50dc8d7 100644
--- a/include/xine/vdr.h
+++ b/include/xine/vdr.h
@@ -22,7 +22,7 @@
 #define __VDR_H
 
 
-#define XINE_VDR_VERSION 901
+#define XINE_VDR_VERSION 1901
 
 
 enum funcs
@@ -415,6 +415,11 @@ data_set_video_window_t;
 typedef struct __attribute__((packed)) data_grab_image_s
 {
   data_header_t header;
+
+  uint16_t width;
+  uint16_t height;
+  uint16_t jpeg;
+  uint16_t quality;
 }
 data_grab_image_t;
 
diff --git a/src/vdr/Makefile.am b/src/vdr/Makefile.am
index 09435a8..b7b4098 100644
--- a/src/vdr/Makefile.am
+++ b/src/vdr/Makefile.am
@@ -9,4 +9,4 @@ xineplug_LTLIBRARIES = xineplug_vdr.la
 endif
 
 xineplug_vdr_la_SOURCES = combined_vdr.c combined_vdr.h input_vdr.c post_vdr_video.c post_vdr_audio.c
-xineplug_vdr_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS)
+xineplug_vdr_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) -ljpeg
diff --git a/src/vdr/input_vdr.c b/src/vdr/input_vdr.c
index ac9a313..ee6f80f 100644
--- a/src/vdr/input_vdr.c
+++ b/src/vdr/input_vdr.c
@@ -50,6 +50,14 @@
 
 
 
+#ifdef boolean
+# define HAVE_BOOLEAN
+#endif
+#include <jpeglib.h>
+#undef boolean 
+
+
+
 #define VDR_MAX_NUM_WINDOWS 16
 #define VDR_ABS_FIFO_DIR "/tmp/vdr-xine"
 
@@ -184,6 +192,53 @@ vdr_input_class_t;
 
 
 
+#define JPEGCOMPRESSMEM 500000
+
+typedef struct tJpegCompressData_s {
+  int size;
+  unsigned char *mem;
+} tJpegCompressData;
+
+static void JpegCompressInitDestination(const j_compress_ptr cinfo)
+{
+  tJpegCompressData *jcd = (tJpegCompressData *)cinfo->client_data;
+  if (jcd) {
+     cinfo->dest->free_in_buffer = jcd->size = JPEGCOMPRESSMEM;
+     cinfo->dest->next_output_byte = jcd->mem = 
+       (unsigned char *)malloc(jcd->size);
+     }
+}
+
+static boolean JpegCompressEmptyOutputBuffer(const j_compress_ptr cinfo)
+{
+  tJpegCompressData *jcd = (tJpegCompressData *)cinfo->client_data;
+  if (jcd) {
+     int Used = jcd->size;
+     jcd->size += JPEGCOMPRESSMEM;
+     jcd->mem = (unsigned char *)realloc(jcd->mem, jcd->size);
+     if (jcd->mem) {
+        cinfo->dest->next_output_byte = jcd->mem + Used;
+        cinfo->dest->free_in_buffer = jcd->size - Used;
+        return TRUE;
+        }
+     }
+  return FALSE;
+}
+
+static void JpegCompressTermDestination(const j_compress_ptr cinfo)
+{
+  tJpegCompressData *jcd = (tJpegCompressData *)cinfo->client_data;
+  if (jcd) {
+     int Used = cinfo->dest->next_output_byte - jcd->mem;
+     if (Used < jcd->size) {
+        jcd->size = Used;
+        jcd->mem = (unsigned char *)realloc(jcd->mem, jcd->size);
+        }
+     }
+}
+
+
+
 static int vdr_write(int f, void *b, int n)
 {
   int t = 0, r;
@@ -430,6 +485,12 @@ static off_t vdr_execute_rpc_command(vdr_input_plugin_t *this)
 
       if (this->osd_supports_custom_extent && data->w_ref > 0 && data->h_ref > 0)
         xine_osd_set_extent(this->osd[ data->window ].window, data->w_ref, data->h_ref);
+ 
+      /*
+       * We use a new object type id for osd objects coming from this input plugin so that
+       * post plugins like autocrop can do special handling
+       */
+      this->osd[ data->window ].window->osd.renderer->event.object.object_type = 2;
     }
     break;
 
@@ -1095,9 +1156,88 @@ t3 = _now();
     {
       READ_DATA_OR_FAIL(grab_image, lprintf("got GRABIMAGE\n"));
 
+      int size = 0;
+      char *img = NULL;
+
+      result_grab_image_t result_grab_image;
+      memset(&result_grab_image, 0, sizeof(result_grab_image));
+      result_grab_image.header.func = data->header.func;
+      result_grab_image.header.len  = sizeof (result_grab_image);
+
+      xine_grab_frame_t *grab_frame;
+      if (!xine_port_send_gui_data(this->stream->video_out, XINE_GUI_SEND_ALLOC_GRAB_FRAME, &grab_frame)) /* use new grab interface */
       {
-        off_t ret_val   = -1;
+        grab_frame->width = data->width;
+        grab_frame->height = data->height;
+        if (!xine_port_send_gui_data(this->stream->video_out, XINE_GUI_SEND_GRAB_FRAME, grab_frame))
+        {
+          if (!data->jpeg) /* convert to PNM */
+          {
+              /* allocate memory for result */
+              size_t bytes = grab_frame->width * grab_frame->height * 3;
+              img = malloc(bytes + 64);
+              if (img)
+              {
+                /* PNM header */
+                sprintf(img, "P6\n%d\n%d\n255\n", grab_frame->width, grab_frame->height);
+                int hdrlen = strlen(img);
 
+                /* copy image */
+                xine_fast_memcpy(img + hdrlen, grab_frame->img, bytes);
+
+                size = bytes + hdrlen;
+              }
+          }
+          else /* JPEG */
+          {
+              /* Compress JPEG */
+              struct jpeg_destination_mgr jdm;
+              struct jpeg_compress_struct cinfo;
+              struct jpeg_error_mgr jerr;
+              tJpegCompressData jcd;
+
+              jdm.init_destination = JpegCompressInitDestination;
+              jdm.empty_output_buffer = JpegCompressEmptyOutputBuffer;
+              jdm.term_destination = JpegCompressTermDestination;
+              cinfo.err = jpeg_std_error(&jerr);
+              jpeg_create_compress(&cinfo);
+              cinfo.dest = &jdm;
+              cinfo.client_data = &jcd;
+              cinfo.image_width = grab_frame->width;
+              cinfo.image_height = grab_frame->height;
+              cinfo.input_components = 3;
+              cinfo.in_color_space = JCS_RGB;
+
+              jpeg_set_defaults(&cinfo);
+              jpeg_set_quality(&cinfo, data->quality, TRUE);
+              jpeg_start_compress(&cinfo, TRUE);
+
+              JSAMPROW rp[grab_frame->height];
+              int rs = grab_frame->width * 3;
+              int k;
+              for (k = 0; k < grab_frame->height; k++)
+                rp[k] = grab_frame->img + k * rs;
+              jpeg_write_scanlines(&cinfo, rp, grab_frame->height);
+
+              jpeg_finish_compress(&cinfo);
+              jpeg_destroy_compress(&cinfo);
+
+              size = jcd.size;
+              img = (char*)jcd.mem;
+          }
+        }
+        if (img && size > 0)
+        {
+          result_grab_image.width       = grab_frame->width;
+          result_grab_image.height      = grab_frame->height;
+        }
+        else
+          size = 0;
+
+        xine_port_send_gui_data(this->stream->video_out, XINE_GUI_SEND_FREE_GRAB_FRAME, grab_frame);
+      }
+      else /* use standard grab interface */
+      {
         xine_current_frame_data_t frame_data;
         memset(&frame_data, 0, sizeof (frame_data));
 
@@ -1113,14 +1253,10 @@ t3 = _now();
             frame_data.ratio_code = 21100;
         }
 
-        if (!frame_data.img)
-          memset(&frame_data, 0, sizeof (frame_data));
-
+        img = frame_data.img;
+        size = frame_data.img_size;
+        if (img && size > 0)
         {
-          result_grab_image_t result_grab_image;
-          result_grab_image.header.func = data->header.func;
-          result_grab_image.header.len = sizeof (result_grab_image) + frame_data.img_size;
-
           result_grab_image.width       = frame_data.width;
           result_grab_image.height      = frame_data.height;
           result_grab_image.ratio       = frame_data.ratio_code;
@@ -1130,19 +1266,24 @@ t3 = _now();
           result_grab_image.crop_right  = frame_data.crop_right;
           result_grab_image.crop_top    = frame_data.crop_top;
           result_grab_image.crop_bottom = frame_data.crop_bottom;
-
-          if (sizeof (result_grab_image) == vdr_write(this->fh_result, &result_grab_image, sizeof (result_grab_image)))
-          {
-            if (!frame_data.img_size || (frame_data.img_size == vdr_write(this->fh_result, frame_data.img, frame_data.img_size)))
-              ret_val = 0;
-          }
         }
+        else
+          size = 0;
+      }
 
-        free(frame_data.img);
+      result_grab_image.header.len  += size;
 
-        if (ret_val != 0)
-          return ret_val;
+      int ok = 0;
+      if (sizeof (result_grab_image) == vdr_write(this->fh_result, &result_grab_image, sizeof (result_grab_image)))
+      {
+          if (!size || (size == vdr_write(this->fh_result, img, size)))
+            ok = 1;
       }
+
+      free(img);
+
+      if (!ok)
+        return -1;
     }
     break;
 
diff --git a/src/video_dec/libvdpau/vdpau_h264.c b/src/video_dec/libvdpau/vdpau_h264.c
index e16c800..c79cd90 100644
--- a/src/video_dec/libvdpau/vdpau_h264.c
+++ b/src/video_dec/libvdpau/vdpau_h264.c
@@ -22,6 +22,8 @@
  * vdpau_h264.c: H264 Video Decoder utilizing nvidia VDPAU engine
  */
 
+#define LOG_MODULE "vdpau_h264"
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -425,7 +427,7 @@ static int vdpau_decoder_init(video_decoder_t *this_gen)
 
   if (this->dangling_img) {
     xprintf(this->xine, XINE_VERBOSITY_LOG,
-        "broken stream: current img wasn't processed -- freeing it\n!");
+        "broken stream: current img wasn't processed -- freeing it!\n");
     this->dangling_img->free(this->dangling_img);
   }
   this->dangling_img = img;
@@ -564,7 +566,7 @@ static int vdpau_decoder_render(video_decoder_t *this_gen, VdpBitstreamBuffer *v
 
     if (this->dangling_img) {
       xprintf(this->xine, XINE_VERBOSITY_LOG,
-          "broken stream: current img wasn't processed -- freeing it\n!");
+          "broken stream: current img wasn't processed -- freeing it!\n");
       this->dangling_img->free(this->dangling_img);
     }
     this->dangling_img = img;
@@ -587,8 +589,8 @@ static int vdpau_decoder_render(video_decoder_t *this_gen, VdpBitstreamBuffer *v
 
   /*xprintf(this->xine, XINE_VERBOSITY_DEBUG,
       "Decode: NUM: %d, REF: %d, BYTES: %d, PTS: %lld\n", pic.frame_num, pic.is_reference, vdp_buffer->bitstream_bytes, this->completed_pic->pts);*/
-  VdpStatus status = this->vdpau_accel->vdp_decoder_render(this->decoder,
-      surface, (VdpPictureInfo*)&pic, 1, vdp_buffer);
+  VdpStatus status;
+  VDPAU_PROFILE(status = this->vdpau_accel->vdp_decoder_render(this->decoder, surface, (VdpPictureInfo*)&pic, 1, vdp_buffer));
 
   /* free the image data */
   if(((uint8_t*)vdp_buffer->bitstream) != NULL) {
diff --git a/src/video_dec/libvdpau/vdpau_mpeg12.c b/src/video_dec/libvdpau/vdpau_mpeg12.c
index e0a7bcd..984e810 100644
--- a/src/video_dec/libvdpau/vdpau_mpeg12.c
+++ b/src/video_dec/libvdpau/vdpau_mpeg12.c
@@ -618,7 +618,7 @@ static void decode_render( vdpau_mpeg12_decoder_t *vd, vdpau_accel_t *accel )
   vbit.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
   vbit.bitstream = pic->slices;
   vbit.bitstream_bytes = (pic->vdp_infos.picture_structure==PICTURE_FRAME)? pic->slices_pos : pic->slices_pos_top;
-  st = accel->vdp_decoder_render( vd->decoder, accel->surface, (VdpPictureInfo*)&pic->vdp_infos, 1, &vbit );
+  VDPAU_PROFILE(st = accel->vdp_decoder_render( vd->decoder, accel->surface, (VdpPictureInfo*)&pic->vdp_infos, 1, &vbit ));
   if ( st!=VDP_STATUS_OK )
     lprintf( "decoder failed : %d!! %s\n", st, accel->vdp_get_error_string( st ) );
   else {
@@ -646,7 +646,7 @@ static void decode_render( vdpau_mpeg12_decoder_t *vd, vdpau_accel_t *accel )
     vbit.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
     vbit.bitstream = pic->slices+pic->slices_pos_top;
     vbit.bitstream_bytes = pic->slices_pos-pic->slices_pos_top;
-    st = accel->vdp_decoder_render( vd->decoder, accel->surface, (VdpPictureInfo*)&pic->vdp_infos2, 1, &vbit );
+    VDPAU_PROFILE(st = accel->vdp_decoder_render( vd->decoder, accel->surface, (VdpPictureInfo*)&pic->vdp_infos2, 1, &vbit ));
     if ( st!=VDP_STATUS_OK )
       lprintf( "decoder failed : %d!! %s\n", st, accel->vdp_get_error_string( st ) );
     else
diff --git a/src/video_out/video_out_vdpau.c b/src/video_out/video_out_vdpau.c
index 148aad7..3ce604b 100644
--- a/src/video_out/video_out_vdpau.c
+++ b/src/video_out/video_out_vdpau.c
@@ -61,7 +61,7 @@
 #define NUM_FRAMES_BACK 1
 
 #define LOCKDISPLAY /*define this if you have a buggy libX11/xcb*/
-//#undef LOCKDISPLAY 
+#undef LOCKDISPLAY 
 
 
 #define DEINT_BOB                    1
@@ -91,6 +91,14 @@ char* vdpau_deinterlacer_description [] = {
 };
 
 
+char *vdpau_sd_only_properties[] = {
+  "none",
+  "noise",
+  "sharpness",
+  "noise+sharpness",
+  NULL
+};
+
 VdpOutputSurfaceRenderBlendState blend = {
   VDP_OUTPUT_SURFACE_RENDER_BLEND_STATE_VERSION,
   VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE,
@@ -125,7 +133,10 @@ VdpVideoSurfaceGetBitsYCbCr *vdp_video_surface_getbits_ycbcr;
 VdpOutputSurfaceCreate *vdp_output_surface_create;
 VdpOutputSurfaceDestroy *vdp_output_surface_destroy;
 VdpOutputSurfaceRenderBitmapSurface *vdp_output_surface_render_bitmap_surface;
+VdpOutputSurfaceRenderOutputSurface *vdp_output_surface_render_output_surface;
 VdpOutputSurfacePutBitsNative *vdp_output_surface_put_bits;
+VdpOutputSurfaceGetBitsNative *vdp_output_surface_get_bits;
+VdpOutputSurfacePutBitsYCbCr *vdp_output_surface_put_bits_ycbcr;
 
 VdpVideoMixerCreate *vdp_video_mixer_create;
 VdpVideoMixerDestroy *vdp_video_mixer_destroy;
@@ -276,27 +287,6 @@ static VdpStatus guarded_vdp_decoder_render(VdpDecoder decoder, VdpVideoSurface
 }
 
 
-
-typedef struct {
-  VdpBitmapSurface ovl_bitmap;
-  uint32_t  bitmap_width, bitmap_height;
-  int ovl_w, ovl_h; /* overlay's width and height */
-  int ovl_x, ovl_y; /* overlay's top-left display position */
-  int unscaled;
-  int expected_overlay_width; /*if >0 scale to video width*/
-  int expected_overlay_height; /* if >0 scale to video height */
-} vdpau_overlay_t;
-
-
-typedef struct {
-  int                 x;
-  int                 y;
-  int                 w;
-  int                 h;
-}
-argb_ovl_data_t;
-
-
 typedef struct {
   vo_frame_t         vo_frame;
 
@@ -310,6 +300,23 @@ typedef struct {
 
 
 typedef struct {
+  xine_grab_frame_t grab_frame;
+
+  VdpOutputSurface render_surface;
+  int vdp_runtime_nr;
+  int width, height;
+  uint32_t *rgba;
+} vdpau_grab_frame_t;
+
+
+typedef struct {
+  int x1, y1, x2, y2;
+} vdpau_rect_t;
+
+#define RECT_IS_EQ(a, b) ((a).x1 == (b).x1 && (a).y1 == (b).y1 && (a).x2 == (b).x2 && (a).y2 == (b).y2)
+
+
+typedef struct {
 
   vo_driver_t        vo_driver;
   vo_scale_t         sc;
@@ -321,28 +328,26 @@ typedef struct {
 
   config_values_t   *config;
 
-  int ovl_changed;
-  vdpau_overlay_t     overlays[XINE_VORAW_MAX_OVL];
-  yuv2rgb_factory_t   *yuv2rgb_factory;
-  yuv2rgb_t           *ovl_yuv2rgb;
-  VdpOutputSurface    overlay_output;
+  int                 ovl_changed;
+  vo_overlay_t        *overlays[XINE_VORAW_MAX_OVL];
+  uint32_t            *overlay_bitmap;
+  int                 overlay_bitmap_size;
+
+  VdpOutputSurface    overlay_output_surface;
   uint32_t            overlay_output_width;
   uint32_t            overlay_output_height;
+  vdpau_rect_t        overlay_dirty_rect;
   int                 has_overlay;
 
-  VdpOutputSurface    overlay_unscaled;
+  VdpOutputSurface    overlay_unscaled_surface;
   uint32_t            overlay_unscaled_width;
   uint32_t            overlay_unscaled_height;
+  vdpau_rect_t        overlay_unscaled_dirty_rect;
   int                 has_unscaled;
 
-  VdpOutputSurface    argb_overlay;
-  uint32_t            argb_overlay_width;
-  uint32_t            argb_overlay_height;
-  int                 has_argb_overlay;
-  int                 argb_ovl_count;
-  vo_overlay_t       *argb_ovl[XINE_VORAW_MAX_OVL];
-  int                 argb_ovl_data_count;
-  argb_ovl_data_t     argb_ovl_data[XINE_VORAW_MAX_OVL];
+  VdpOutputSurface    overlay_render_surface;
+  uint32_t            overlay_render_width;
+  uint32_t            overlay_render_height;
 
   int32_t             video_window_x;
   int32_t             video_window_y;
@@ -354,12 +359,17 @@ typedef struct {
   uint32_t             soft_surface_height;
   int                  soft_surface_format;
 
-#define NOUTPUTSURFACE 2
+#define NOUTPUTSURFACE 8
   VdpOutputSurface     output_surface[NOUTPUTSURFACE];
   uint8_t              current_output_surface;
   uint32_t             output_surface_width[NOUTPUTSURFACE];
   uint32_t             output_surface_height[NOUTPUTSURFACE];
   uint8_t              init_queue;
+  uint8_t              queue_length;
+
+  vdpau_grab_frame_t   *pending_grab_request;
+  pthread_mutex_t      grab_lock;
+  pthread_cond_t       grab_cond;
 
   VdpVideoMixer        video_mixer;
   VdpChromaType        video_mixer_chroma;
@@ -399,6 +409,7 @@ typedef struct {
   int               enable_inverse_telecine;
   int               honor_progressive;
   int               skip_chroma;
+  int               sd_only_properties;
   int               studio_levels;
   int               background;
 
@@ -419,412 +430,416 @@ typedef struct {
 } vdpau_class_t;
 
 
-
-static void vdpau_overlay_clut_yuv2rgb(vdpau_driver_t  *this, vo_overlay_t *overlay, vdpau_frame_t *frame)
-{
-  int i;
-  clut_t* clut = (clut_t*) overlay->color;
-
-  if (!overlay->rgb_clut) {
-    for ( i=0; i<sizeof(overlay->color)/sizeof(overlay->color[0]); i++ ) {
-      *((uint32_t *)&clut[i]) = this->ovl_yuv2rgb->yuv2rgb_single_pixel_fun(this->ovl_yuv2rgb, clut[i].y, clut[i].cb, clut[i].cr);
-    }
-    overlay->rgb_clut++;
-  }
-  if (!overlay->hili_rgb_clut) {
-    clut = (clut_t*) overlay->hili_color;
-    for ( i=0; i<sizeof(overlay->color)/sizeof(overlay->color[0]); i++) {
-      *((uint32_t *)&clut[i]) = this->ovl_yuv2rgb->yuv2rgb_single_pixel_fun(this->ovl_yuv2rgb, clut[i].y, clut[i].cb, clut[i].cr);
-    }
-    overlay->hili_rgb_clut++;
-  }
-}
-
-
-
-static void vdpau_process_argb_ovls(vdpau_driver_t *this_gen, vo_frame_t *frame_gen)
+static void vdpau_overlay_begin (vo_driver_t *this_gen, vo_frame_t *frame_gen, int changed)
 {
   vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
-  int i, k;
 
-  vo_overlay_t *ovl[XINE_VORAW_MAX_OVL];
-  argb_ovl_data_t ovl_data[XINE_VORAW_MAX_OVL];
-  int ovl_data_count = 0;
+  if ( !changed )
+    return;
 
-  int total_extent_width = 0, total_extent_height = 0;
+  this->has_overlay = this->has_unscaled = 0;
   this->video_window_x      = 0;
   this->video_window_y      = 0;
   this->video_window_width  = 0;
   this->video_window_height = 0;
+  ++this->ovl_changed;
+  lprintf("overlay begin\n");
+}
 
-  /* lock layers while processing and determine extent */
-  for (i = 0; i < this->argb_ovl_count; i++) {
-    pthread_mutex_lock(&this->argb_ovl[i]->argb_layer->mutex);
 
-    if (this->argb_ovl[i]->argb_layer->buffer != NULL) {
-      int extent_width  = this->argb_ovl[i]->extent_width;
-      int extent_height = this->argb_ovl[i]->extent_height;
-      if (extent_width <= 0 || extent_height <= 0) {
-        extent_width  = frame_gen->width;
-        extent_height = frame_gen->height;
-      }
-      if (extent_width > 0 && extent_height > 0) {
-        if (total_extent_width < extent_width)
-          total_extent_width = extent_width;
-        if (total_extent_height < extent_height)
-          total_extent_height = extent_height;
-        ovl_data[ovl_data_count].x = this->argb_ovl[i]->x;
-        ovl_data[ovl_data_count].y = this->argb_ovl[i]->y;
-        ovl_data[ovl_data_count].w = this->argb_ovl[i]->width;
-        ovl_data[ovl_data_count].h = this->argb_ovl[i]->height;
-        ovl[ovl_data_count++] = this->argb_ovl[i];
-      }
-      if (this->argb_ovl[i]->video_window_width > 0
-        && this->argb_ovl[i]->video_window_height > 0) {
-        /* last one wins */
-        this->video_window_x      = this->argb_ovl[i]->video_window_x;
-        this->video_window_y      = this->argb_ovl[i]->video_window_y;
-        this->video_window_width  = this->argb_ovl[i]->video_window_width;
-        this->video_window_height = this->argb_ovl[i]->video_window_height;
-      }
-    }
-  }
 
-  /* adjust surface */
-  if (total_extent_width > 0 && total_extent_height > 0) {
-    if (this->argb_overlay_width != total_extent_width || this->argb_overlay_height != total_extent_height || this->argb_overlay == VDP_INVALID_HANDLE) {
-      if (this->argb_overlay != VDP_INVALID_HANDLE)
-        vdp_output_surface_destroy(this->argb_overlay);
+static void vdpau_overlay_blend (vo_driver_t *this_gen, vo_frame_t *frame_gen, vo_overlay_t *overlay)
+{
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
 
-      VdpStatus st = vdp_output_surface_create(vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, total_extent_width, total_extent_height, &this->argb_overlay);
-      if (st != VDP_STATUS_OK)
-        fprintf(stderr, "vdpau_process_argb_ovl: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st));
-
-      this->argb_overlay_width  = total_extent_width;
-      this->argb_overlay_height = total_extent_height;
-
-      /* change argb_ovl_data to wipe complete surface */
-      this->argb_ovl_data_count = 1;
-      this->argb_ovl_data[0].x = 0;
-      this->argb_ovl_data[0].y = 0;
-      this->argb_ovl_data[0].w = total_extent_width;
-      this->argb_ovl_data[0].h = total_extent_height;
-
-      /* extend dirty areas to maximum for filling wiped surface */
-      for (i = 0; i < ovl_data_count; i++) {
-        ovl[i]->argb_layer->x1 = 0;
-        ovl[i]->argb_layer->y1 = 0;
-        ovl[i]->argb_layer->x2 = ovl[i]->width;
-        ovl[i]->argb_layer->y2 = ovl[i]->height;
-      }
-    }
-  }
+  int i = this->ovl_changed;
+  if (!i)
+    return;
 
-  /* wipe surface for gone overlays */
-  if (this->argb_overlay != VDP_INVALID_HANDLE) {
-    uint32_t *zeros = NULL;
-    for (i = 0; i < this->argb_ovl_data_count; i++) {
-      argb_ovl_data_t *curr_ovl_data = &this->argb_ovl_data[i];
-      int ovl_gone = 1;
-      for (k = 0; k < ovl_data_count; k++) {
-        if (0 == memcmp(curr_ovl_data, &ovl_data[k], sizeof (*curr_ovl_data))) {
-          ovl_gone = 0;
-          break;
-        }
-      }
-      if (!ovl_gone)
-        continue;
-      if (!zeros)
-        zeros = calloc(4, this->argb_overlay_width * this->argb_overlay_height);
-      if (zeros) {
-        uint32_t pitch = curr_ovl_data->w * 4;
-        VdpRect dest = { curr_ovl_data->x, curr_ovl_data->y, curr_ovl_data->x + curr_ovl_data->w, curr_ovl_data->y + curr_ovl_data->h };
-        VdpStatus st = vdp_output_surface_put_bits(this->argb_overlay, (void *)&zeros, &pitch, &dest);
-        if (st != VDP_STATUS_OK)
-          fprintf(stderr, "vdpau_process_argb_ovl: vdp_output_surface_put_bits_native failed : %s\n", vdp_get_error_string(st));
-      }
-    }
-    free(zeros);
-  }
+  if (--i >= XINE_VORAW_MAX_OVL)
+    return;
 
-  /* set destination area according to dirty area of argb layer and reset dirty area */
-  for (i = 0; i < ovl_data_count; i++) {
-    uint32_t pitch = ovl[i]->width * 4;
-    uint32_t *buffer_start = ovl[i]->argb_layer->buffer + ovl[i]->argb_layer->y1 * ovl[i]->width + ovl[i]->argb_layer->x1;
-    VdpRect dest = { ovl[i]->x + ovl[i]->argb_layer->x1, ovl[i]->y + ovl[i]->argb_layer->y1, ovl[i]->x + ovl[i]->argb_layer->x2, ovl[i]->y + ovl[i]->argb_layer->y2 };
-    ovl[i]->argb_layer->x1 = ovl[i]->width;
-    ovl[i]->argb_layer->y1 = ovl[i]->height;
-    ovl[i]->argb_layer->x2 = 0;
-    ovl[i]->argb_layer->y2 = 0;
+  if (overlay->width <= 0 || overlay->height <= 0 || (!overlay->rle && (!overlay->argb_layer || !overlay->argb_layer->buffer)))
+    return;
 
-    VdpStatus st = vdp_output_surface_put_bits(this->argb_overlay, (void *)&buffer_start, &pitch, &dest);
-    if (st != VDP_STATUS_OK)
-      fprintf(stderr, "vdpau_process_argb_ovl: vdp_output_surface_put_bits_native failed : %s\n", vdp_get_error_string(st));
-    else
-      this->has_argb_overlay = 1;
+  if (overlay->rle)
+    lprintf("overlay[%d] rle %s%s %dx%d@%d,%d hili rect %d,%d-%d,%d\n", i,
+                  overlay->unscaled ? " unscaled ": " scaled ",
+                  (overlay->rgb_clut > 0 || overlay->hili_rgb_clut > 0) ? " rgb ": " ycbcr ",
+		  overlay->width, overlay->height, overlay->x, overlay->y,
+                  overlay->hili_left, overlay->hili_top,
+                  overlay->hili_right, overlay->hili_bottom);
+  if (overlay->argb_layer && overlay->argb_layer->buffer)
+    lprintf("overlay[%d] argb %s %dx%d@%d,%d dirty rect %d,%d-%d,%d\n", i,
+                  overlay->unscaled ? " unscaled ": " scaled ",
+                  overlay->width, overlay->height, overlay->x, overlay->y,
+                  overlay->argb_layer->x1, overlay->argb_layer->y1,
+                  overlay->argb_layer->x2, overlay->argb_layer->y2);
+
+  this->overlays[i] = overlay;
+
+  if (overlay->video_window_width > 0 && overlay->video_window_height > 0) {
+        /* last one wins */
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
   }
 
-  /* store ovl_data */
-  memcpy(this->argb_ovl_data, ovl_data, sizeof (ovl_data));
-  this->argb_ovl_data_count = ovl_data_count;
-
-  /* unlock layers */
-  for (i = 0; i < this->argb_ovl_count; i++)
-    pthread_mutex_unlock(&this->argb_ovl[i]->argb_layer->mutex);
+  ++this->ovl_changed;
 }
 
 
 
-static int vdpau_process_ovl( vdpau_driver_t *this_gen, vo_overlay_t *overlay )
+
+static void vdpau_overlay_end (vo_driver_t *this_gen, vo_frame_t *frame)
 {
-  vdpau_overlay_t *ovl = &this_gen->overlays[this_gen->ovl_changed-1];
+  VdpStatus st;
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
+
+  int novls = this->ovl_changed;
+  if (novls < 2) {
+    this->ovl_changed = 0;
+    return;
+  }
+  --novls;
 
-  if ( overlay->width<=0 || overlay->height<=0 )
-    return 0;
+  uint32_t output_width = frame->width;
+  uint32_t output_height = frame->height;
+  uint32_t unscaled_width = 0, unscaled_height = 0;
+  uint32_t render_width = 0, render_height = 0;
+  vo_overlay_t *first_scaled = NULL, *first_unscaled = NULL;
+  vdpau_rect_t dirty_rect, unscaled_dirty_rect;
+  int i;
+  for (i = 0; i < novls; ++i) {
+    vo_overlay_t *overlay = this->overlays[i];
+
+    if (overlay->unscaled) {
+      if (first_unscaled) {
+        if (overlay->width > render_width)
+          render_width = overlay->width;
+        if (overlay->height > render_height)
+          render_height = overlay->height;
+
+        if (overlay->x < unscaled_dirty_rect.x1)
+          unscaled_dirty_rect.x1 = overlay->x;
+        if (overlay->y < unscaled_dirty_rect.y1)
+          unscaled_dirty_rect.y1 = overlay->y;
+        if ((overlay->x + overlay->width) > unscaled_dirty_rect.x2)
+          unscaled_dirty_rect.x2 = overlay->x + overlay->width;
+        if ((overlay->y + overlay->height) > unscaled_dirty_rect.y2)
+          unscaled_dirty_rect.y2 = overlay->y + overlay->height;
+      } else {
+        first_unscaled = overlay;
+        unscaled_dirty_rect.x1 = overlay->x;
+        unscaled_dirty_rect.y1 = overlay->y;
+        unscaled_dirty_rect.x2 = overlay->x + overlay->width;
+        unscaled_dirty_rect.y2 = overlay->y + overlay->height;
+      }
 
-  if ( (ovl->bitmap_width < overlay->width ) || (ovl->bitmap_height < overlay->height) || (ovl->ovl_bitmap == VDP_INVALID_HANDLE) ) {
-    if (ovl->ovl_bitmap != VDP_INVALID_HANDLE) {
-      vdp_bitmap_destroy( ovl->ovl_bitmap );
-      ovl->ovl_bitmap = VDP_INVALID_HANDLE;
-    }
-    VdpStatus st = vdp_bitmap_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, overlay->width, overlay->height, 0, &ovl->ovl_bitmap );
-    if ( st != VDP_STATUS_OK ) {
-      fprintf(stderr, "vdpau_process_ovl: vdp_bitmap_create failed : %s\n", vdp_get_error_string(st) );
-    }
-    ovl->bitmap_width = overlay->width;
-    ovl->bitmap_height = overlay->height;
-  }
-  ovl->ovl_w = overlay->width;
-  ovl->ovl_h = overlay->height;
-  ovl->ovl_x = overlay->x;
-  ovl->ovl_y = overlay->y;
-  ovl->unscaled = overlay->unscaled;
-  ovl->expected_overlay_width = overlay->extent_width;
-  ovl->expected_overlay_height = overlay->extent_height;
-  uint32_t *buf = (uint32_t*)malloc(ovl->ovl_w*ovl->ovl_h*4);
-  if ( !buf )
-    return 0;
-
-  int num_rle = overlay->num_rle;
-  rle_elem_t *rle = overlay->rle;
-  uint32_t *rgba = buf;
-  uint32_t red, green, blue, alpha;
-  clut_t *low_colors = (clut_t*)overlay->color;
-  clut_t *hili_colors = (clut_t*)overlay->hili_color;
-  uint8_t *low_trans = overlay->trans;
-  uint8_t *hili_trans = overlay->hili_trans;
-  clut_t *colors;
-  uint8_t *trans;
-  int rlelen = 0;
-  uint8_t clr = 0;
-  int i, pos=0, x, y;
-
-  while ( num_rle>0 ) {
-    x = pos%ovl->ovl_w;
-    y = pos/ovl->ovl_w;
-    if ( (x>=overlay->hili_left && x<=overlay->hili_right) && (y>=overlay->hili_top && y<=overlay->hili_bottom) ) {
-      colors = hili_colors;
-      trans = hili_trans;
+      unscaled_width = unscaled_dirty_rect.x2;
+      unscaled_height = unscaled_dirty_rect.y2;
     }
     else {
-      colors = low_colors;
-      trans = low_trans;
-    }
-    rlelen = rle->len;
-    clr = rle->color;
-    for ( i=0; i<rlelen; ++i ) {
-      if ( trans[clr] == 0 ) {
-        alpha = red = green = blue = 0;
+      if (overlay->width > render_width)
+        render_width = overlay->width;
+      if (overlay->height > render_height)
+        render_height = overlay->height;
+
+      if (first_scaled) {
+        if (overlay->x < dirty_rect.x1)
+          dirty_rect.x1 = overlay->x;
+        if (overlay->y < dirty_rect.y1)
+          dirty_rect.y1 = overlay->y;
+        if ((overlay->x + overlay->width) > dirty_rect.x2)
+          dirty_rect.x2 = overlay->x + overlay->width;
+        if ((overlay->y + overlay->height) > dirty_rect.y2)
+          dirty_rect.y2 = overlay->y + overlay->height;
+      } else {
+        first_scaled = overlay;
+        dirty_rect.x1 = overlay->x;
+        dirty_rect.y1 = overlay->y;
+        dirty_rect.x2 = overlay->x + overlay->width;
+        dirty_rect.y2 = overlay->y + overlay->height;
       }
-      else {
-        red = colors[clr].y; /* red */
-        green = colors[clr].cr; /* green */
-        blue = colors[clr].cb; /* blue */
-        alpha = trans[clr]*255/15;
+
+      if (dirty_rect.x2 > output_width)
+        output_width = dirty_rect.x2;
+      if (dirty_rect.y2 > output_height)
+        output_height = dirty_rect.y2;
+
+      if (overlay->extent_width > 0 || overlay->extent_height > 0) {
+        if (this->video_mixer_width > output_width)
+          output_width = this->video_mixer_width;
+        if (this->video_mixer_height > output_height)
+          output_height = this->video_mixer_height;
       }
-      *rgba = (alpha<<24) | (red<<16) | (green<<8) | blue;
-      rgba++;
-      ++pos;
     }
-    ++rle;
-    --num_rle;
-  }
-  uint32_t pitch = ovl->ovl_w*4;
-  VdpRect dest = { 0, 0, ovl->ovl_w, ovl->ovl_h };
-  VdpStatus st = vdp_bitmap_put_bits( ovl->ovl_bitmap, &buf, &pitch, &dest);
-  if ( st != VDP_STATUS_OK ) {
-    fprintf(stderr, "vdpau_process_ovl: vdp_bitmap_put_bits failed : %s\n", vdp_get_error_string(st) );
   }
-  free(buf);
-  return 1;
-}
-
-
-
-static void vdpau_overlay_begin (vo_driver_t *this_gen, vo_frame_t *frame_gen, int changed)
-{
-  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
-
-  if ( !changed )
-    return;
-
-  this->has_overlay = this->has_unscaled = 0;
-  this->has_argb_overlay = 0;
-  this->argb_ovl_count = 0;
-  ++this->ovl_changed;
-}
 
+  int need_render_surface = (novls > 1);
+  int need_init = 0;
+  if (first_scaled) {
+    vdpau_rect_t dest;
+    dest.x1 = first_scaled->x;
+    dest.y1 = first_scaled->y;
+    dest.x2 = first_scaled->x + first_scaled->width;
+    dest.y2 = first_scaled->y + first_scaled->height;
+    if (first_scaled->extent_width > 0 && first_scaled->extent_height > 0) {
+      double rx = (double)output_width / (double)first_scaled->extent_width;
+      double ry = (double)output_height / (double)first_scaled->extent_height;
+      dest.x1 *= rx; dest.y1 *= ry; dest.x2 *= rx; dest.y2 *= ry;
+    }
+    if (!RECT_IS_EQ(dest, dirty_rect))
+      need_init = 1;
+    if ((dest.x2 - dest.x1) != first_scaled->width || (dest.y2 - dest.y1) != first_scaled->height)
+      need_render_surface = 1;
+  }
 
+  int need_unscaled_init = (first_unscaled &&
+                                  (first_unscaled->x != unscaled_dirty_rect.x1 ||
+                                   first_unscaled->y != unscaled_dirty_rect.y1 ||
+                                   (first_unscaled->x + first_unscaled->width) != unscaled_dirty_rect.x2 ||
+                                   (first_unscaled->y + first_unscaled->height) != unscaled_dirty_rect.y2));
 
-static void vdpau_overlay_blend (vo_driver_t *this_gen, vo_frame_t *frame_gen, vo_overlay_t *overlay)
-{
-  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
-  vdpau_frame_t *frame = (vdpau_frame_t *) frame_gen;
+  if (this->overlay_render_surface != VDP_INVALID_HANDLE && (!need_render_surface || this->overlay_render_width != render_width || this->overlay_render_height != render_height) ) {
+    lprintf("overlay destroy render surface\n");
+    VDPAU_PROFILE(st = vdp_output_surface_destroy( this->overlay_render_surface ));
+    if ( st != VDP_STATUS_OK ) {
+      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+    }
+    this->overlay_render_surface = VDP_INVALID_HANDLE;
+  }
 
-  if (!this->ovl_changed)
-    return;
+  if (this->overlay_output_surface != VDP_INVALID_HANDLE && (!first_scaled || this->overlay_output_width != output_width || this->overlay_output_height != output_height) ) {
+    lprintf("overlay destroy scaled surface\n");
+    VDPAU_PROFILE(st = vdp_output_surface_destroy( this->overlay_output_surface ));
+    if ( st != VDP_STATUS_OK ) {
+      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+    }
+    this->overlay_output_surface = VDP_INVALID_HANDLE;
+  }
 
-  if (overlay->rle) {
-    if (this->ovl_changed >= XINE_VORAW_MAX_OVL)
-      return;
-    if (!overlay->rgb_clut || !overlay->hili_rgb_clut)
-      vdpau_overlay_clut_yuv2rgb (this, overlay, frame);
-    if ( vdpau_process_ovl( this, overlay ) )
-      ++this->ovl_changed;
+  if (this->overlay_unscaled_surface != VDP_INVALID_HANDLE && (!first_unscaled || this->overlay_unscaled_width != unscaled_width || this->overlay_unscaled_height != unscaled_height) ) {
+    lprintf("overlay destroy unscaled surface\n");
+    VDPAU_PROFILE(st = vdp_output_surface_destroy( this->overlay_unscaled_surface ));
+    if ( st != VDP_STATUS_OK ) {
+      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+    }
+    this->overlay_unscaled_surface = VDP_INVALID_HANDLE;
   }
 
-  if (overlay->argb_layer) {
-    if (this->argb_ovl_count >= XINE_VORAW_MAX_OVL)
-      return;
-    this->argb_ovl[this->argb_ovl_count++] = overlay;
+  if (need_render_surface && this->overlay_render_surface == VDP_INVALID_HANDLE ) {
+    lprintf("overlay create render surface %dx%d\n", render_width, render_height);
+    VDPAU_PROFILE(st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, render_width, render_height, &this->overlay_render_surface ));
+    if ( st != VDP_STATUS_OK )
+      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
+
+    this->overlay_render_width = render_width;
+    this->overlay_render_height = render_height;
   }
-}
 
+  if (first_scaled) {
+    if (this->overlay_output_surface == VDP_INVALID_HANDLE ) {
+      lprintf("overlay create scaled surface %dx%d\n", output_width, output_height);
+      VDPAU_PROFILE(st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, output_width, output_height, &this->overlay_output_surface ));
+      if ( st != VDP_STATUS_OK )
+        fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
 
+      this->overlay_output_width = output_width;
+      this->overlay_output_height = output_height;
 
-static void vdpau_overlay_end (vo_driver_t *this_gen, vo_frame_t *frame)
-{
-  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
-  int i;
-  VdpStatus st;
+      need_init = 1;
+    } else if (!RECT_IS_EQ(dirty_rect, this->overlay_dirty_rect)) {
+      need_init = 1;
+    }
+    this->overlay_dirty_rect = dirty_rect;
+  }
 
-  if ( !this->ovl_changed )
-    return;
+  if (first_unscaled) {
+    if (this->overlay_unscaled_surface == VDP_INVALID_HANDLE ) {
+      lprintf("overlay create unscaled surface %dx%d\n", unscaled_width, unscaled_height);
+      VDPAU_PROFILE(st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, unscaled_width, unscaled_height, &this->overlay_unscaled_surface ));
+      if ( st != VDP_STATUS_OK )
+        fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
 
-  if (this->argb_ovl_count || this->argb_ovl_data_count)
-    vdpau_process_argb_ovls(this, frame);
+      this->overlay_unscaled_width = unscaled_width;
+      this->overlay_unscaled_height = unscaled_height;
 
-  if ( !(this->ovl_changed-1) ) {
-    this->ovl_changed = 0;
-    this->has_overlay = 0;
-    this->has_unscaled = 0;
-    return;
+      need_unscaled_init = 1;
+    } else if (!RECT_IS_EQ(unscaled_dirty_rect, this->overlay_unscaled_dirty_rect)) {
+      need_unscaled_init = 1;
+    }
+    this->overlay_unscaled_dirty_rect = unscaled_dirty_rect;
   }
 
-  int w=0, h=0;
-  int scaler = 0;
-  for ( i=0; i<this->ovl_changed-1; ++i ) {
-    if ( this->overlays[i].unscaled )
-      continue;
-    if ( w < (this->overlays[i].ovl_x+this->overlays[i].ovl_w) )
-      w = this->overlays[i].ovl_x+this->overlays[i].ovl_w;
-    if ( h < (this->overlays[i].ovl_y+this->overlays[i].ovl_h) )
-      h = this->overlays[i].ovl_y+this->overlays[i].ovl_h;
-    if ( this->overlays[i].expected_overlay_width )
-      scaler = 1;
-    if ( this->overlays[i].expected_overlay_height )
-      scaler = 1;
-  }
+  uint32_t w = (unscaled_width > output_width) ? unscaled_width : output_width;
+  uint32_t h = (unscaled_height > output_height) ? unscaled_height : output_height;
 
-  if ( scaler ) {
-    w = this->video_mixer_width;
-    h = this->video_mixer_height;
+  if ((w * h) > this->overlay_bitmap_size) {
+    this->overlay_bitmap_size = w * h;
+    free(this->overlay_bitmap);
+    this->overlay_bitmap = calloc(this->overlay_bitmap_size, sizeof(uint32_t));
+  } else if (need_init || need_unscaled_init) {
+    memset(this->overlay_bitmap, 0, (w * h * sizeof(uint32_t)));
   }
 
-  int out_w = (w>frame->width) ? w : frame->width;
-  int out_h = (h>frame->height) ? h : frame->height;
-
-  if ( (this->overlay_output_width!=out_w || this->overlay_output_height!=out_h) && this->overlay_output != VDP_INVALID_HANDLE ) {
-    st = vdp_output_surface_destroy( this->overlay_output );
+  if (need_init) {
+    lprintf("overlay init scaled surface %dx%d\n", output_width, output_height);
+    uint32_t pitch = w * sizeof(uint32_t);
+    VdpRect clear = { 0, 0, output_width, output_height };
+    VDPAU_PROFILE(st = vdp_output_surface_put_bits( this->overlay_output_surface, &this->overlay_bitmap, &pitch, &clear ));
     if ( st != VDP_STATUS_OK ) {
-      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_put_bits (clear) failed : %s\n", vdp_get_error_string(st) );
     }
-    this->overlay_output = VDP_INVALID_HANDLE;
   }
 
-  this->overlay_output_width = out_w;
-  this->overlay_output_height = out_h;
-
-  w = 64; h = 64;
-  for ( i=0; i<this->ovl_changed-1; ++i ) {
-    if ( !this->overlays[i].unscaled )
-      continue;
-    if ( w < (this->overlays[i].ovl_x+this->overlays[i].ovl_w) )
-      w = this->overlays[i].ovl_x+this->overlays[i].ovl_w;
-    if ( h < (this->overlays[i].ovl_y+this->overlays[i].ovl_h) )
-      h = this->overlays[i].ovl_y+this->overlays[i].ovl_h;
-  }
-
-  if ( (this->overlay_unscaled_width!=w || this->overlay_unscaled_height!=h) && this->overlay_unscaled != VDP_INVALID_HANDLE ) {
-    st = vdp_output_surface_destroy( this->overlay_unscaled );
+  if (need_unscaled_init) {
+    lprintf("overlay init unscaled surface %dx%d\n", unscaled_width, unscaled_height);
+    uint32_t pitch = w * sizeof(uint32_t);
+    VdpRect clear = { 0, 0, unscaled_width, unscaled_height };
+    VDPAU_PROFILE(st = vdp_output_surface_put_bits( this->overlay_unscaled_surface, &this->overlay_bitmap, &pitch, &clear ));
     if ( st != VDP_STATUS_OK ) {
-      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_put_bits (clear) failed : %s\n", vdp_get_error_string(st) );
     }
-    this->overlay_unscaled = VDP_INVALID_HANDLE;
   }
 
-  this->overlay_unscaled_width = w;
-  this->overlay_unscaled_height = h;
+  for (i = 0; i < novls; ++i) {
+    vo_overlay_t *ovl = this->overlays[i];
+    uint32_t *bitmap;
+    int is_argb = 1;
+
+    if (ovl->rle) {
+      rle_elem_t *rle = ovl->rle;
+      bitmap = this->overlay_bitmap;
+      int pos = 0;
+
+      int num_rle = ovl->num_rle;
+      while (num_rle > 0) {
+        int x = pos % ovl->width;
+        int y = pos / ovl->width;
+        clut_t *colors;
+        uint8_t *trans;
+        if (x >= ovl->hili_left && x <= ovl->hili_right && y >= ovl->hili_top && y <= ovl->hili_bottom) {
+          colors = (clut_t*)ovl->hili_color;
+          trans = ovl->hili_trans;
+          is_argb = ovl->hili_rgb_clut;
+        } else {
+          colors = (clut_t*)ovl->color;
+          trans = ovl->trans;
+          is_argb = ovl->rgb_clut;
+        }
 
-  if ( this->overlay_unscaled == VDP_INVALID_HANDLE ) {
-    st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->overlay_unscaled_width, this->overlay_unscaled_height, &this->overlay_unscaled );
-    if ( st != VDP_STATUS_OK )
-      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
-  }
+        int clr = rle->color;
+        uint32_t pixel;
+        if ( trans[clr] == 0 )
+          pixel = 0;
+        else if (is_argb)
+          pixel = (((uint32_t)trans[clr] * 255 / 15) << 24) | (((uint32_t)colors[clr].y) << 16) | (((uint32_t)colors[clr].cr) << 8) | ((uint32_t)colors[clr].cb);
+	else
+          pixel = (((uint32_t)trans[clr] * 255 / 15) << 24) | (((uint32_t)colors[clr].y) << 16) | (((uint32_t)colors[clr].cb) << 8) | ((uint32_t)colors[clr].cr);
+
+        int rlelen = rle->len;
+        pos += rlelen;
+        while (rlelen > 0) {
+          *bitmap++ = pixel;
+          --rlelen;
+        }
+        ++rle;
+        --num_rle;
+      }
 
-  if ( this->overlay_output == VDP_INVALID_HANDLE ) {
-    st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->overlay_output_width, this->overlay_output_height, &this->overlay_output );
-    if ( st != VDP_STATUS_OK )
-      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
-  }
+      int n = ovl->width * ovl->height - pos;
+      if (n > 0)
+        memset(bitmap, 0, n * sizeof(uint32_t));
 
-  w = (this->overlay_unscaled_width>this->overlay_output_width) ? this->overlay_unscaled_width : this->overlay_output_width;
-  h = (this->overlay_unscaled_height>this->overlay_output_height) ? this->overlay_unscaled_height : this->overlay_output_height;
+      bitmap = this->overlay_bitmap;
+    } else {
+      pthread_mutex_lock(&ovl->argb_layer->mutex);
+      bitmap = ovl->argb_layer->buffer;
+    }
 
-  uint32_t *buf = (uint32_t*)calloc(w*4,h);
-  uint32_t pitch = w*4;
-  VdpRect clear = { 0, 0, this->overlay_output_width, this->overlay_output_height };
-  st = vdp_output_surface_put_bits( this->overlay_output, &buf, &pitch, &clear );
-  if ( st != VDP_STATUS_OK ) {
-    fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_put_bits (clear) failed : %s\n", vdp_get_error_string(st) );
-  }
-  clear.x1 = this->overlay_unscaled_width; clear.y1 = this->overlay_unscaled_height;
-  st = vdp_output_surface_put_bits( this->overlay_unscaled, &buf, &pitch, &clear );
-  if ( st != VDP_STATUS_OK ) {
-    fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_put_bits (clear) failed : %s\n", vdp_get_error_string(st) );
-  }
-  free(buf);
-
-  VdpOutputSurface *surface;
-  for ( i=0; i<this->ovl_changed-1; ++i ) {
-    VdpRect dest = { this->overlays[i].ovl_x, this->overlays[i].ovl_y, this->overlays[i].ovl_x+this->overlays[i].ovl_w, this->overlays[i].ovl_y+this->overlays[i].ovl_h };
-    if ( this->overlays[i].expected_overlay_width ) {
-      double rx = (double)this->overlay_output_width/(double)this->overlays[i].expected_overlay_width;
-      double ry = (double)this->overlay_output_height/(double)this->overlays[i].expected_overlay_height;
-      dest.x0 *= rx; dest.y0 *= ry; dest.x1 *=rx; dest.y1 *= ry;
-      lprintf( "vdpau_overlay_end: overlay_width=%d overlay_height=%d rx=%f ry=%f\n", this->overlay_output_width, this->overlay_output_height, rx, ry );
+    VdpOutputSurface surface;
+    VdpRect dest;
+    VdpOutputSurfaceRenderBlendState *bs = NULL;
+    if (ovl == first_scaled) {
+      if (need_render_surface) {
+        surface = this->overlay_render_surface;
+        dest.x0 = 0;
+        dest.y0 = 0;
+        dest.x1 = ovl->width;
+        dest.y1 = ovl->height;
+      } else {
+        surface = this->overlay_output_surface;
+        dest.x0 = ovl->x;
+        dest.y0 = ovl->y;
+        dest.x1 = ovl->x + ovl->width;
+        dest.y1 = ovl->y + ovl->height;
+      }
+    } else if (ovl == first_unscaled) {
+      surface = this->overlay_unscaled_surface;
+      dest.x0 = ovl->x;
+      dest.y0 = ovl->y;
+      dest.x1 = ovl->x + ovl->width;
+      dest.y1 = ovl->y + ovl->height;
+    } else {
+      bs = &blend;
+      surface = this->overlay_render_surface;
+      dest.x0 = 0;
+      dest.y0 = 0;
+      dest.x1 = ovl->width;
+      dest.y1 = ovl->height;
     }
-    VdpRect src = { 0, 0, this->overlays[i].ovl_w, this->overlays[i].ovl_h };
-    surface = (this->overlays[i].unscaled) ? &this->overlay_unscaled : &this->overlay_output;
-    st = vdp_output_surface_render_bitmap_surface( *surface, &dest, this->overlays[i].ovl_bitmap, &src, 0, &blend, 0 );
-    if ( st != VDP_STATUS_OK ) {
-      fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_render_bitmap_surface failed : %s\n", vdp_get_error_string(st) );
+
+    uint32_t pitch = ovl->width * sizeof(uint32_t);
+    if (is_argb) {
+      lprintf("overlay put argb %d,%d-%d,%d\n", dest.x0, dest.y0, dest.x1, dest.y1);
+      VDPAU_PROFILE(st = vdp_output_surface_put_bits(surface, &bitmap, &pitch, &dest));
+      if (st != VDP_STATUS_OK)
+        fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_put_bits_native failed : %s\n", vdp_get_error_string(st));
+    } else {
+      lprintf("overlay put ycbcr %d,%d-%d,%d\n", dest.x0, dest.y0, dest.x1, dest.y1);
+      VDPAU_PROFILE(st = vdp_output_surface_put_bits_ycbcr(surface, VDP_YCBCR_FORMAT_V8U8Y8A8, &bitmap, &pitch, &dest, NULL));
+      if (st != VDP_STATUS_OK)
+        fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_put_bits_ycbcr failed : %s\n", vdp_get_error_string(st));
+    }
+
+    if (!ovl->rle)
+      pthread_mutex_unlock(&ovl->argb_layer->mutex);
+
+    if (surface == this->overlay_render_surface) {
+      VdpRect src = { 0, 0, ovl->width, ovl->height };
+      dest.x0 = ovl->x;
+      dest.y0 = ovl->y;
+      dest.x1 = ovl->x + ovl->width;
+      dest.y1 = ovl->y + ovl->height;
+      if (ovl->unscaled) {
+        surface = this->overlay_unscaled_surface;
+        lprintf("overlay render unscaled %d,%d-%d,%d\n", dest.x0, dest.y0, dest.x1, dest.y1);
+      } else {
+        if (ovl->extent_width > 0 && ovl->extent_height > 0) {
+          double rx = (double)output_width / (double)ovl->extent_width;
+          double ry = (double)output_height / (double)ovl->extent_height;
+          dest.x0 *= rx; dest.y0 *= ry; dest.x1 *=rx; dest.y1 *= ry;
+        }
+        surface = this->overlay_output_surface;
+        lprintf("overlay render scaled %dx%d -> %d,%d-%d,%d\n", src.x1, src.y1, dest.x0, dest.y0, dest.x1, dest.y1);
+      }
+      VDPAU_PROFILE(st = vdp_output_surface_render_output_surface(surface, &dest, this->overlay_render_surface, &src, 0, bs, 0 ));
+      if ( st != VDP_STATUS_OK ) {
+        fprintf(stderr, "vdpau_overlay_end: vdp_output_surface_render_output_surface failed : %s\n", vdp_get_error_string(st));
+      }
     }
   }
-  this->has_overlay = 1;
+
   this->ovl_changed = 0;
-}
+  this->has_overlay = (first_scaled != NULL);
+  this->has_unscaled = (first_unscaled != NULL);
 
+  lprintf("overlay has %s %s video window %dx%d@%d,%d\n",
+                  first_scaled ? "scaled": "", first_unscaled ? "unscaled": "",
+                  this->video_window_x, this->video_window_y, this->video_mixer_width, this->video_window_height);
+}
 
 
 static void vdpau_frame_proc_slice (vo_frame_t *vo_img, uint8_t **src)
@@ -904,76 +919,57 @@ static vo_frame_t *vdpau_alloc_frame (vo_driver_t *this_gen)
 
 
 
-static void vdpau_provide_standard_frame_data (vo_frame_t *this_gen, xine_current_frame_data_t *data)
+static void vdpau_provide_standard_frame_data (vo_frame_t *this, xine_current_frame_data_t *data)
 {
-  vdpau_frame_t *this = (vdpau_frame_t *)this_gen;
   VdpStatus st;
   VdpYCbCrFormat format;
+  uint32_t pitches[3];
+  void *base[3];
 
-  if (this->vo_frame.format != XINE_IMGFMT_VDPAU) {
-    fprintf(stderr, "vdpau_provide_standard_frame_data: unexpected frame format 0x%08x!\n", this->vo_frame.format);
+  if (this->format != XINE_IMGFMT_VDPAU) {
+    fprintf(stderr, "vdpau_provide_standard_frame_data: unexpected frame format 0x%08x!\n", this->format);
     return;
   }
 
-  if (!(this->flags & VO_CHROMA_422)) {
+  vdpau_accel_t *accel = (vdpau_accel_t *) this->accel_data;
+
+  if (accel->vdp_runtime_nr != *(accel->current_vdp_runtime_nr))
+    return;
+
+  this = accel->vo_frame;
+
+  if (accel->chroma == VDP_CHROMA_TYPE_420) {
     data->format = XINE_IMGFMT_YV12;
-    data->img_size = this->vo_frame.width * this->vo_frame.height
-                   + ((this->vo_frame.width + 1) / 2) * ((this->vo_frame.height + 1) / 2)
-                   + ((this->vo_frame.width + 1) / 2) * ((this->vo_frame.height + 1) / 2);
+    data->img_size = this->width * this->height
+                   + ((this->width + 1) / 2) * ((this->height + 1) / 2)
+                   + ((this->width + 1) / 2) * ((this->height + 1) / 2);
     if (data->img) {
-      this->vo_frame.pitches[0] = 8*((this->vo_frame.width + 7) / 8);
-      this->vo_frame.pitches[1] = 8*((this->vo_frame.width + 15) / 16);
-      this->vo_frame.pitches[2] = 8*((this->vo_frame.width + 15) / 16);
-      this->vo_frame.base[0] = av_mallocz(this->vo_frame.pitches[0] * this->vo_frame.height);
-      this->vo_frame.base[1] = av_mallocz(this->vo_frame.pitches[1] * ((this->vo_frame.height+1)/2));
-      this->vo_frame.base[2] = av_mallocz(this->vo_frame.pitches[2] * ((this->vo_frame.height+1)/2));
+      pitches[0] = this->width;
+      pitches[1] = this->width / 2;
+      pitches[2] = this->width / 2;
+      base[0] = data->img;
+      base[1] = data->img + this->width * this->height;
+      base[2] = data->img + this->width * this->height + this->width * this->height / 4;
       format = VDP_YCBCR_FORMAT_YV12;
     }
   } else {
     data->format = XINE_IMGFMT_YUY2;
-    data->img_size = this->vo_frame.width * this->vo_frame.height
-                   + ((this->vo_frame.width + 1) / 2) * this->vo_frame.height
-                   + ((this->vo_frame.width + 1) / 2) * this->vo_frame.height;
+    data->img_size = this->width * this->height
+                   + ((this->width + 1) / 2) * this->height
+                   + ((this->width + 1) / 2) * this->height;
     if (data->img) {
-      this->vo_frame.pitches[0] = 8*((this->vo_frame.width + 3) / 4);
-      this->vo_frame.base[0] = av_mallocz(this->vo_frame.pitches[0] * this->vo_frame.height);
+      pitches[0] = this->width * 2;
+      base[0] = data->img;
       format = VDP_YCBCR_FORMAT_YUYV;
     }
   }
 
   if (data->img) {
-    st = vdp_video_surface_getbits_ycbcr(this->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches);
+    VDPAU_PROFILE(st = vdp_video_surface_getbits_ycbcr(accel->surface, format, base, pitches));
     if (st != VDP_STATUS_OK)
       fprintf(stderr, "vo_vdpau: failed to get surface bits !! %s\n", vdp_get_error_string(st));
-
-    if (format == VDP_YCBCR_FORMAT_YV12) {
-      yv12_to_yv12(
-       /* Y */
-        this->vo_frame.base[0], this->vo_frame.pitches[0],
-        data->img, this->vo_frame.width,
-       /* U */
-        this->vo_frame.base[2], this->vo_frame.pitches[2],
-        data->img+this->vo_frame.width*this->vo_frame.height, this->vo_frame.width/2,
-       /* V */
-        this->vo_frame.base[1], this->vo_frame.pitches[1],
-        data->img+this->vo_frame.width*this->vo_frame.height+this->vo_frame.width*this->vo_frame.height/4, this->vo_frame.width/2,
-       /* width x height */
-        this->vo_frame.width, this->vo_frame.height);
-    } else {
-      yuy2_to_yuy2(
-       /* src */
-        this->vo_frame.base[0], this->vo_frame.pitches[0],
-       /* dst */
-        data->img, this->vo_frame.width*2,
-       /* width x height */
-        this->vo_frame.width, this->vo_frame.height);
     }
-
-    av_freep (&this->vo_frame.base[0]);
-    av_freep (&this->vo_frame.base[1]);
-    av_freep (&this->vo_frame.base[2]);
   }
-}
 
 
 
@@ -1008,11 +1004,11 @@ static void vdpau_duplicate_frame_data (vo_frame_t *this_gen, vo_frame_t *origin
     format = VDP_YCBCR_FORMAT_YUYV;
   }
 
-  st = vdp_video_surface_getbits_ycbcr(orig->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches);
+  VDPAU_PROFILE(st = vdp_video_surface_getbits_ycbcr(orig->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches));
   if (st != VDP_STATUS_OK)
     fprintf(stderr, "vo_vdpau: failed to get surface bits !! %s\n", vdp_get_error_string(st));
 
-  st = vdp_video_surface_putbits_ycbcr(this->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches);
+  VDPAU_PROFILE(st = vdp_video_surface_putbits_ycbcr(this->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches));
   if (st != VDP_STATUS_OK)
     fprintf(stderr, "vo_vdpau: failed to put surface bits !! %s\n", vdp_get_error_string(st));
 
@@ -1029,7 +1025,7 @@ static void vdpau_update_frame_format (vo_driver_t *this_gen, vo_frame_t *frame_
       uint32_t width, uint32_t height, double ratio, int format, int flags)
 {
   vdpau_driver_t *this = (vdpau_driver_t *) this_gen;
-  vdpau_frame_t   *frame = VDPAU_FRAME(frame_gen);
+  vdpau_frame_t *frame = (vdpau_frame_t *) frame_gen;
 
   int clear = 0;
 
@@ -1038,15 +1034,6 @@ static void vdpau_update_frame_format (vo_driver_t *this_gen, vo_frame_t *frame_
 
   VdpChromaType chroma = (flags & VO_CHROMA_422) ? VDP_CHROMA_TYPE_422 : VDP_CHROMA_TYPE_420;
 
-  vo_frame_t orig_frame_content;
-  if (format == XINE_IMGFMT_VDPAU) {
-    if (frame_gen != &frame->vo_frame) {
-      /* this is an intercepted frame, so we need to detect and propagate any
-       * changes on the original vo_frame to all the intercepted frames */
-       xine_fast_memcpy(&orig_frame_content, &frame->vo_frame, sizeof (vo_frame_t));
-    }
-  }
-
   /* Check frame size and format and reallocate if necessary */
   if ( (frame->width != width) || (frame->height != height) || (frame->format != format) || (frame->format==XINE_IMGFMT_VDPAU && frame->vdpau_accel_data.chroma!=chroma) ||
         (frame->vdpau_accel_data.vdp_runtime_nr != this->vdp_runtime_nr)) {
@@ -1137,36 +1124,6 @@ static void vdpau_update_frame_format (vo_driver_t *this_gen, vo_frame_t *frame_
   frame->vdpau_accel_data.color_standard = VDP_COLOR_STANDARD_ITUR_BT_601;
   frame->ratio = ratio;
   frame->vo_frame.future_frame = NULL;
-
-  if (format == XINE_IMGFMT_VDPAU) {
-    if (frame_gen != &frame->vo_frame) {
-      /* this is an intercepted frame, so we need to detect and propagate any
-       * changes on the original vo_frame to all the intercepted frames */
-      unsigned char *p0 = (unsigned char *)&orig_frame_content;
-      unsigned char *p1 = (unsigned char *)&frame->vo_frame;
-      int i;
-      for (i = 0; i < sizeof (vo_frame_t); i++) {
-        if (*p0 != *p1) {
-          /* propagate the change */
-          vo_frame_t *f = frame_gen;
-          while (f->next) {
-            /* serveral restrictions apply when intercepting VDPAU frames. So let's check
-             * the intercepted frames before modifing them and fail otherwise. */
-            unsigned char *p = (unsigned char *)f + i;
-            if (*p != *p0) {
-              xprintf(this->xine, XINE_VERBOSITY_DEBUG, "vdpau_update_frame_format: a post plugin violates the restrictions on intercepting VDPAU frames\n");
-              _x_abort();
-            }
-
-            *p = *p1;
-            f = f->next;
-          }
-        }
-        p0++;
-        p1++;
-      }
-    }
-  }
 }
 
 
@@ -1381,7 +1338,7 @@ static void vdpau_update_noise( vdpau_driver_t *this_gen )
     return;
 
   float value = this_gen->noise/100.0;
-  if ( value==0 ) {
+  if ( value==0 || ((this_gen->sd_only_properties & 1) && this_gen->video_mixer_width >= 800)) {
     VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION };
     VdpBool feature_enables[] = { 0 };
     vdp_video_mixer_set_feature_enables( this_gen->video_mixer, 1, features, feature_enables );
@@ -1410,7 +1367,7 @@ static void vdpau_update_sharpness( vdpau_driver_t *this_gen )
     return;
 
   float value = this_gen->sharpness/100.0;
-  if ( value==0 ) {
+  if ( value==0 || (this_gen->sd_only_properties >= 2 && this_gen->video_mixer_width >= 800)) {
     VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_SHARPNESS  };
     VdpBool feature_enables[] = { 0 };
     vdp_video_mixer_set_feature_enables( this_gen->video_mixer, 1, features, feature_enables );
@@ -1433,6 +1390,18 @@ static void vdpau_update_sharpness( vdpau_driver_t *this_gen )
 
 
 
+static void vdpau_update_sd_only_properties( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+
+  this->sd_only_properties = entry->num_value;
+  printf( "vo_vdpau: enable sd only noise=%d, sd only sharpness %d\n", ((this->sd_only_properties & 1) != 0), (this->sd_only_properties >= 2) );
+  vdpau_update_noise(this);
+  vdpau_update_sharpness(this);
+}
+
+
+
 static void vdpau_update_csc( vdpau_driver_t *this_gen )
 {
   float hue = this_gen->hue/100.0;
@@ -1567,10 +1536,10 @@ static void vdpau_shift_queue( vo_driver_t *this_gen )
 {
   vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
 
-  if ( this->init_queue<2 )
+  if ( this->init_queue < this->queue_length )
     ++this->init_queue;
   ++this->current_output_surface;
-  if ( this->current_output_surface > (NOUTPUTSURFACE-1) )
+  if ( this->current_output_surface >= this->queue_length )
     this->current_output_surface = 0;
 }
 
@@ -1592,6 +1561,115 @@ static void vdpau_check_output_size( vo_driver_t *this_gen )
 }
 
 
+static void vdpau_grab_current_output_surface (vdpau_driver_t *this, int64_t vpts)
+{
+  pthread_mutex_lock(&this->grab_lock);
+
+  vdpau_grab_frame_t *frame = this->pending_grab_request;
+  if (frame) {
+    VdpStatus st;
+
+    this->pending_grab_request = NULL;
+    frame->grab_frame.vpts = -1;
+
+    VdpOutputSurface grab_surface = this->output_surface[this->current_output_surface];
+    int width = this->output_surface_width[this->current_output_surface];
+    int height = this->output_surface_height[this->current_output_surface];
+
+    width = width - frame->grab_frame.crop_left - frame->grab_frame.crop_right;
+    height = height - frame->grab_frame.crop_top - frame->grab_frame.crop_bottom;
+    if (width < 1)
+      width = 1;
+    if (height < 1)
+      height = 1;
+
+    if (frame->grab_frame.width <= 0)
+      frame->grab_frame.width = width;
+    if (frame->grab_frame.height <= 0)
+      frame->grab_frame.height = height;
+
+    if (frame->vdp_runtime_nr != this->vdp_runtime_nr)
+      frame->render_surface = VDP_INVALID_HANDLE;
+
+    if (frame->grab_frame.width != frame->width || frame->grab_frame.height != frame->height) {
+      free(frame->rgba);
+      free(frame->grab_frame.img);
+      frame->rgba = NULL;
+      frame->grab_frame.img = NULL;
+
+      if (frame->render_surface != VDP_INVALID_HANDLE) {
+        VDPAU_PROFILE(st = vdp_output_surface_destroy(frame->render_surface));
+        frame->render_surface = VDP_INVALID_HANDLE;
+        if (st != VDP_STATUS_OK) {
+          fprintf(stderr, "vo_vdpau: Can't destroy grab render output surface: %s\n", vdp_get_error_string (st));
+          pthread_cond_broadcast(&this->grab_cond);
+          pthread_mutex_unlock(&this->grab_lock);
+          return;
+        }
+      }
+
+      frame->width = frame->grab_frame.width;
+      frame->height = frame->grab_frame.height;
+    }
+
+    if (frame->rgba == NULL) {
+      frame->rgba = (uint32_t *) calloc(frame->width * frame->height, sizeof(uint32_t));
+      if (frame->rgba == NULL) {
+        pthread_cond_broadcast(&this->grab_cond);
+        pthread_mutex_unlock(&this->grab_lock);
+        return;
+      }
+    }
+    if (frame->grab_frame.img == NULL) {
+      frame->grab_frame.img = (uint8_t *) calloc(frame->width * frame->height, 3);
+      if (frame->grab_frame.img == NULL) {
+        pthread_cond_broadcast(&this->grab_cond);
+        pthread_mutex_unlock(&this->grab_lock);
+        return;
+      }
+    }
+
+    uint32_t pitches = frame->width * sizeof(uint32_t);
+    VdpRect src_rect = { frame->grab_frame.crop_left, frame->grab_frame.crop_top, width+frame->grab_frame.crop_left, height+frame->grab_frame.crop_top };
+
+    if (frame->width != width || frame->height != height) {
+      st = VDP_STATUS_OK;
+      if (frame->render_surface == VDP_INVALID_HANDLE) {
+        frame->vdp_runtime_nr = this->vdp_runtime_nr;
+        VDPAU_PROFILE(st = vdp_output_surface_create(vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, frame->width, frame->height, &frame->render_surface));
+      }
+      if (st == VDP_STATUS_OK) {
+        VDPAU_PROFILE(st = vdp_output_surface_render_output_surface(frame->render_surface, NULL, grab_surface, &src_rect, NULL, NULL, VDP_OUTPUT_SURFACE_RENDER_ROTATE_0));
+        if (st == VDP_STATUS_OK) {
+          VDPAU_PROFILE(st = vdp_output_surface_get_bits(frame->render_surface, NULL, &frame->rgba, &pitches));
+          if (st == VDP_STATUS_OK) {
+            if (!frame->grab_frame.continuous) {
+              VDPAU_PROFILE(st = vdp_output_surface_destroy(frame->render_surface));
+              if (st != VDP_STATUS_OK)
+                fprintf(stderr, "vo_vdpau: Can't destroy grab render output surface: %s\n", vdp_get_error_string (st));
+              frame->render_surface = VDP_INVALID_HANDLE;
+            }
+          } else
+            fprintf(stderr, "vo_vdpau: Can't get output surface bits for raw frame grabbing: %s\n", vdp_get_error_string (st));
+        } else
+          fprintf(stderr, "vo_vdpau: Can't render output surface for raw frame grabbing: %s\n", vdp_get_error_string (st));
+      } else
+        fprintf(stderr, "vo_vdpau: Can't create render output surface for raw frame grabbing: %s\n", vdp_get_error_string (st));
+    } else {
+      VDPAU_PROFILE(st = vdp_output_surface_get_bits(grab_surface, &src_rect, &frame->rgba, &pitches));
+      if (st != VDP_STATUS_OK)
+        fprintf(stderr, "vo_vdpau: Can't get output surface bits for raw frame grabbing: %s\n", vdp_get_error_string (st));
+    }
+
+    if (st == VDP_STATUS_OK)
+      frame->grab_frame.vpts = vpts;
+
+    pthread_cond_broadcast(&this->grab_cond);
+  }
+
+  pthread_mutex_unlock(&this->grab_lock);
+}
+
 
 static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
 {
@@ -1605,7 +1683,13 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
   uint32_t mix_h = this->video_mixer_height;
   VdpTime stream_speed;
 
-  if ( (frame->width != this->sc.delivered_width) || (frame->height != this->sc.delivered_height) || (frame->ratio != this->sc.delivered_ratio) ) {
+  if ( (frame->width != this->sc.delivered_width) ||
+                  (frame->height != this->sc.delivered_height) ||
+                  (frame->ratio != this->sc.delivered_ratio) ||
+                  (frame->vo_frame.crop_left != this->sc.crop_left) ||
+                  (frame->vo_frame.crop_right != this->sc.crop_right) ||
+                  (frame->vo_frame.crop_top != this->sc.crop_top) ||
+                  (frame->vo_frame.crop_bottom != this->sc.crop_bottom) ) {
     this->sc.force_redraw = 1;    /* trigger re-calc of output size */
   }
 
@@ -1704,7 +1788,7 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
 #endif
     VdpVideoMixerParameter params[] = { VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH, VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
           VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE, VDP_VIDEO_MIXER_PARAMETER_LAYERS };
-    int num_layers = 3;
+    int num_layers = 2;
     void const *param_values[] = { &mix_w, &mix_h, &chroma, &num_layers };
     vdp_video_mixer_create( vdp_device, features_count, features, 4, params, param_values, &this->video_mixer );
     this->video_mixer_chroma = chroma;
@@ -1729,8 +1813,6 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
 
   VdpRect vid_source, out_dest, vid_dest;
 
-  vdpau_check_output_size( this_gen );
-
   vid_source.x0 = this->sc.displayed_xoffset; vid_source.y0 = this->sc.displayed_yoffset;
   vid_source.x1 = this->sc.displayed_width+this->sc.displayed_xoffset; vid_source.y1 = this->sc.displayed_height+this->sc.displayed_yoffset;
   out_dest.x0 = out_dest.y0 = 0;
@@ -1740,41 +1822,34 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
 
   stream_speed = frame->vo_frame.stream ? xine_get_param(frame->vo_frame.stream, XINE_PARAM_FINE_SPEED) : 0;
 
-  VdpTime last_time;
-
-  if ( this->init_queue>1 )
-    vdp_queue_block( vdp_queue, this->output_surface[this->current_output_surface], &last_time );
-
-  uint32_t layer_count;
-  VdpLayer layer[3];
-  VdpRect unscaledsrc;
+  uint32_t layer_count = 0;
+  VdpLayer layer[2];
+  VdpRect ovl_source, unscaled_source;
   if ( this->has_overlay ) {
-    layer_count = 2;
-    layer[0].struct_version = VDP_LAYER_VERSION; layer[0].source_surface = this->overlay_output; layer[0].source_rect = &vid_source; layer[0].destination_rect = &vid_dest;
-    unscaledsrc.x0 = 0; unscaledsrc.y0 = 0; unscaledsrc.x1 = this->overlay_unscaled_width; unscaledsrc.y1 = this->overlay_unscaled_height;
-    layer[1].struct_version = VDP_LAYER_VERSION; layer[1].source_surface = this->overlay_unscaled; layer[1].source_rect = &unscaledsrc; layer[1].destination_rect = &unscaledsrc;
+    ovl_source.x0 = 0; ovl_source.y0 = 0; ovl_source.x1 = this->overlay_output_width; ovl_source.y1 = this->overlay_output_height;
+    layer[0].struct_version = VDP_LAYER_VERSION; layer[0].source_surface = this->overlay_output_surface; layer[0].source_rect = &ovl_source; layer[0].destination_rect = &vid_dest;
+    /* recalculate video destination window to match osd's specified video window */
+    if (!this->has_unscaled && this->video_window_width > 0 && this->video_window_height > 0) {
+        VdpRect win_rect = { this->video_window_x, this->video_window_y, this->video_window_x + this->video_window_width, this->video_window_y + this->video_window_height };
+        vid_dest.x0 = ((win_rect.x0 - ovl_source.x0) * (vid_dest.x1 - vid_dest.x0) + vid_dest.x0 * (ovl_source.x1 - ovl_source.x0)) / (ovl_source.x1 - ovl_source.x0);
+        vid_dest.y0 = ((win_rect.y0 - ovl_source.y0) * (vid_dest.y1 - vid_dest.y0) + vid_dest.y0 * (ovl_source.y1 - ovl_source.y0)) / (ovl_source.y1 - ovl_source.y0);
+        vid_dest.x1 = ((win_rect.x1 - ovl_source.x0) * (vid_dest.x1 - vid_dest.x0) + vid_dest.x0 * (ovl_source.x1 - ovl_source.x0)) / (ovl_source.x1 - ovl_source.x0);
+        vid_dest.y1 = ((win_rect.y1 - ovl_source.y0) * (vid_dest.y1 - vid_dest.y0) + vid_dest.y0 * (ovl_source.y1 - ovl_source.y0)) / (ovl_source.y1 - ovl_source.y0);
   }
-  else {
-    layer_count = 0;
-  }
-
-  VdpRect argb_dest;
-  VdpRect argb_rect = { 0, 0, this->argb_overlay_width, this->argb_overlay_height };
-  if( this->has_argb_overlay ) {
-    layer_count++;
-    memcpy(&argb_dest, &vid_dest, sizeof (vid_dest));
-    layer[layer_count-1].destination_rect = &argb_dest;
-    layer[layer_count-1].source_rect = &argb_rect;
-    layer[layer_count-1].source_surface = this->argb_overlay;
-    layer[layer_count-1].struct_version = VDP_LAYER_VERSION;
+    ++layer_count;
+  }
+
+  if ( this->has_unscaled ) {
+    unscaled_source.x0 = 0; unscaled_source.y0 = 0; unscaled_source.x1 = this->overlay_unscaled_width; unscaled_source.y1 = this->overlay_unscaled_height;
+    layer[layer_count].struct_version = VDP_LAYER_VERSION; layer[layer_count].source_surface = this->overlay_unscaled_surface; layer[layer_count].source_rect = &unscaled_source; layer[layer_count].destination_rect = &unscaled_source;
     /* recalculate video destination window to match osd's specified video window */
     if (this->video_window_width > 0 && this->video_window_height > 0) {
-      VdpRect win_rect = { this->video_window_x, this->video_window_y, this->video_window_x + this->video_window_width, this->video_window_y + this->video_window_height };
-      vid_dest.x0 = ((win_rect.x0 - argb_rect.x0) * (argb_dest.x1 - argb_dest.x0) + argb_dest.x0 * (argb_rect.x1 - argb_rect.x0)) / (argb_rect.x1 - argb_rect.x0);
-      vid_dest.y0 = ((win_rect.y0 - argb_rect.y0) * (argb_dest.y1 - argb_dest.y0) + argb_dest.y0 * (argb_rect.y1 - argb_rect.y0)) / (argb_rect.y1 - argb_rect.y0);
-      vid_dest.x1 = ((win_rect.x1 - argb_rect.x0) * (argb_dest.x1 - argb_dest.x0) + argb_dest.x0 * (argb_rect.x1 - argb_rect.x0)) / (argb_rect.x1 - argb_rect.x0);
-      vid_dest.y1 = ((win_rect.y1 - argb_rect.y0) * (argb_dest.y1 - argb_dest.y0) + argb_dest.y0 * (argb_rect.y1 - argb_rect.y0)) / (argb_rect.y1 - argb_rect.y0);
+      vid_dest.x0 = this->video_window_x;
+      vid_dest.y0 = this->video_window_y;
+      vid_dest.x1 = this->video_window_x + this->video_window_width;
+      vid_dest.y1 = this->video_window_y + this->video_window_height;
     }
+    ++layer_count;
   }
 
   /* try to get frame duration from previous img->pts when frame->duration is 0 */
@@ -1790,10 +1865,17 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
   else
     non_progressive = (this->honor_progressive && !frame->vo_frame.progressive_frame) || !this->honor_progressive;
 
+  VdpTime last_time;
+
+  if ( this->init_queue>=this->queue_length )
+    VDPAU_PROFILE(vdp_queue_block( vdp_queue, this->output_surface[this->current_output_surface], &last_time ));
+
 #ifdef LOCKDISPLAY
   XLockDisplay( this->display );
 #endif
 
+  vdpau_check_output_size( this_gen );
+
   if ( frame->format==XINE_IMGFMT_VDPAU && this->deinterlace && non_progressive && !(frame->vo_frame.flags & VO_STILL_IMAGE) && frame_duration>2500 ) {
     VdpTime current_time = 0;
     VdpVideoSurface past[2];
@@ -1804,13 +1886,14 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
     future[0] = surface;
     picture_structure = ( frame->vo_frame.top_field_first ) ? VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD : VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
 
-    st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, picture_structure,
-                               2, past, surface, 1, future, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL );
+    VDPAU_PROFILE(st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, picture_structure,
+                               2, past, surface, 1, future, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL ));
     if ( st != VDP_STATUS_OK )
       fprintf(stderr, "vo_vdpau: vdp_video_mixer_render error : %s\n", vdp_get_error_string( st ) );
 
-    vdp_queue_get_time( vdp_queue, &current_time );
-    vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, 0 ); /* display _now_ */
+    vdpau_grab_current_output_surface( this, frame->vo_frame.vpts );
+    VDPAU_PROFILE(vdp_queue_get_time( vdp_queue, &current_time ));
+    VDPAU_PROFILE(vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, 0 )); /* display _now_ */
     vdpau_shift_queue( this_gen );
 
     int dm;
@@ -1820,11 +1903,11 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
       dm = this->deinterlacers_method[this->deinterlace_method_hd];
     
     if ( (dm != DEINT_HALF_TEMPORAL) && (dm != DEINT_HALF_TEMPORAL_SPATIAL) && frame->vo_frame.future_frame ) {  /* process second field */
-      if ( this->init_queue>1 ) {
+      if ( this->init_queue>=this->queue_length ) {
 #ifdef LOCKDISPLAY
         XUnlockDisplay(this->display);
 #endif
-        vdp_queue_block( vdp_queue, this->output_surface[this->current_output_surface], &last_time );
+        VDPAU_PROFILE(vdp_queue_block( vdp_queue, this->output_surface[this->current_output_surface], &last_time ));
 #ifdef LOCKDISPLAY
         XLockDisplay(this->display);
 #endif
@@ -1839,27 +1922,28 @@ static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
       else
         future[0] = VDP_INVALID_HANDLE;
 
-      st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, picture_structure,
-                               2, past, surface, 1, future, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL );
+      VDPAU_PROFILE(st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, picture_structure,
+                               2, past, surface, 1, future, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL ));
       if ( st != VDP_STATUS_OK )
         fprintf(stderr, "vo_vdpau: vdp_video_mixer_render error : %s\n", vdp_get_error_string( st ) );
 
       if ( stream_speed > 0 )
         current_time += frame->vo_frame.duration * 1000000ull * XINE_FINE_SPEED_NORMAL / (180 * stream_speed);
 
-      vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, current_time );
+      VDPAU_PROFILE(vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, current_time ));
       vdpau_shift_queue( this_gen );
     }
   }
   else {
     if ( frame->vo_frame.flags & VO_STILL_IMAGE )
       lprintf( "vo_vdpau: VO_STILL_IMAGE\n");
-    st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
-                               0, 0, surface, 0, 0, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL );
+    VDPAU_PROFILE(st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                               0, 0, surface, 0, 0, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL ));
     if ( st != VDP_STATUS_OK )
       fprintf(stderr, "vo_vdpau: vdp_video_mixer_render error : %s\n", vdp_get_error_string( st ) );
 
-    vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, 0 );
+    vdpau_grab_current_output_surface( this, frame->vo_frame.vpts );
+    VDPAU_PROFILE(vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, 0 ));
     vdpau_shift_queue( this_gen );
   }
 
@@ -1988,6 +2072,91 @@ static void vdpau_get_property_min_max (vo_driver_t *this_gen, int property, int
 }
 
 
+static int vdpau_alloc_grab_frame(vdpau_driver_t *this, void *data)
+{
+  vdpau_grab_frame_t *frame = calloc(1, sizeof(vdpau_grab_frame_t));
+  if (!frame)
+    return -1;
+
+  frame->render_surface = VDP_INVALID_HANDLE;
+  frame->grab_frame.vpts = -1;
+  frame->grab_frame.timeout = 500;
+  *((vdpau_grab_frame_t **) data) = frame;
+
+  return 0;
+}
+
+
+static int vdpau_free_grab_frame(vdpau_driver_t *this, void *data)
+{
+  vdpau_grab_frame_t *frame = (vdpau_grab_frame_t *) data;
+
+  free(frame->grab_frame.img);
+  free(frame->rgba);
+  if (frame->render_surface != VDP_INVALID_HANDLE && frame->vdp_runtime_nr == this->vdp_runtime_nr) {
+    VdpStatus st;
+    VDPAU_PROFILE(st = vdp_output_surface_destroy(frame->render_surface));
+    if (st != VDP_STATUS_OK)
+      fprintf(stderr, "vo_vdpau: Can't destroy grab render output surface: %s\n", vdp_get_error_string (st) );
+  }
+  free(frame);
+  return 0;
+}
+
+
+static int vdpau_grab_next_displayed_frame (vdpau_driver_t *this, void *data) {
+  vdpau_grab_frame_t *frame = (vdpau_grab_frame_t *) data;
+  struct timeval tvnow, tvdiff, tvtimeout;
+  struct timespec ts;
+
+  tvdiff.tv_sec = frame->grab_frame.timeout / 1000;
+  tvdiff.tv_usec = frame->grab_frame.timeout % 1000;
+  tvdiff.tv_usec *= 1000;
+  gettimeofday(&tvnow, NULL);
+  timeradd(&tvnow, &tvdiff, &tvtimeout);
+  ts.tv_sec  = tvtimeout.tv_sec;
+  ts.tv_nsec = tvtimeout.tv_usec;
+  ts.tv_nsec *= 1000;
+
+  pthread_mutex_lock(&this->grab_lock);
+
+  /* wait until other pending grab request is finished */
+  while (this->pending_grab_request) {
+    if (pthread_cond_timedwait(&this->grab_cond, &this->grab_lock, &ts) == ETIMEDOUT) {
+      pthread_mutex_unlock(&this->grab_lock);
+      return 1;   /* no frame available */
+    }
+  }
+
+  this->pending_grab_request = frame;
+
+  /* wait until our request is finished */
+  while (this->pending_grab_request) {
+    if (pthread_cond_timedwait(&this->grab_cond, &this->grab_lock, &ts) == ETIMEDOUT) {
+      this->pending_grab_request = NULL;
+      pthread_mutex_unlock(&this->grab_lock);
+      return 1;   /* no frame available */
+    }
+  }
+
+  pthread_mutex_unlock(&this->grab_lock);
+
+  if (frame->grab_frame.vpts == -1)
+    return -1; /* error happened */
+
+  uint32_t *src = frame->rgba;
+  uint8_t *dst = frame->grab_frame.img;
+  int n = frame->width * frame->height;
+  while (n--) {
+    uint32_t rgb = *src++;
+    *dst++ = (uint8_t)(rgb >> 16);  /*R*/
+    *dst++ = (uint8_t)(rgb >> 8);   /*G*/
+    *dst++ = (uint8_t)(rgb);        /*B*/
+  }
+
+  return 0;
+}
+
 
 static int vdpau_gui_data_exchange (vo_driver_t *this_gen, int data_type, void *data)
 {
@@ -2005,9 +2174,11 @@ static int vdpau_gui_data_exchange (vo_driver_t *this_gen, int data_type, void *
 #ifdef LOCKDISPLAY
         XLockDisplay( this->display );
 #endif
-        int previous = this->current_output_surface - 1;
-        if ( previous < 0 )
-          previous = NOUTPUTSURFACE - 1;
+        int previous;
+        if ( this->current_output_surface )
+          previous = this->current_output_surface - 1;
+        else
+          previous = this->queue_length - 1;
         vdp_queue_display( vdp_queue, this->output_surface[previous], 0, 0, 0 );
 #ifdef LOCKDISPLAY
         XUnlockDisplay( this->display );
@@ -2066,6 +2237,15 @@ static int vdpau_gui_data_exchange (vo_driver_t *this_gen, int data_type, void *
       break;
     }
 
+    case XINE_GUI_SEND_ALLOC_GRAB_FRAME:
+      return vdpau_alloc_grab_frame( this, data );
+
+    case XINE_GUI_SEND_FREE_GRAB_FRAME:
+      return vdpau_free_grab_frame( this, data );
+
+    case XINE_GUI_SEND_GRAB_FRAME:
+      return vdpau_grab_next_displayed_frame( this, data );
+
     default:
       return -1;
   }
@@ -2089,13 +2269,7 @@ static void vdpau_dispose (vo_driver_t *this_gen)
   vdpau_driver_t *this = (vdpau_driver_t *) this_gen;
   int i;
 
-  this->ovl_yuv2rgb->dispose(this->ovl_yuv2rgb);
-  this->yuv2rgb_factory->dispose (this->yuv2rgb_factory);
-
-  for ( i=0; i<XINE_VORAW_MAX_OVL; ++i ) {
-    if ( this->overlays[i].ovl_bitmap != VDP_INVALID_HANDLE )
-      vdp_bitmap_destroy( this->overlays[i].ovl_bitmap );
-  }
+  free(this->overlay_bitmap);
 
   if ( this->video_mixer!=VDP_INVALID_HANDLE )
     vdp_video_mixer_destroy( this->video_mixer );
@@ -2103,13 +2277,13 @@ static void vdpau_dispose (vo_driver_t *this_gen)
     vdp_video_surface_destroy( this->soft_surface );
 
   if ( vdp_output_surface_destroy ) {
-    if (this->argb_overlay != VDP_INVALID_HANDLE)
-      vdp_output_surface_destroy(this->argb_overlay);
-    if ( this->overlay_unscaled!=VDP_INVALID_HANDLE )
-      vdp_output_surface_destroy( this->overlay_unscaled );
-    if ( this->overlay_output!=VDP_INVALID_HANDLE )
-      vdp_output_surface_destroy( this->overlay_output );
-    for ( i=0; i<NOUTPUTSURFACE; ++i ) {
+    if ( this->overlay_unscaled_surface!=VDP_INVALID_HANDLE )
+      vdp_output_surface_destroy( this->overlay_unscaled_surface );
+    if ( this->overlay_output_surface!=VDP_INVALID_HANDLE )
+      vdp_output_surface_destroy( this->overlay_output_surface );
+    if ( this->overlay_render_surface!=VDP_INVALID_HANDLE )
+      vdp_output_surface_destroy( this->overlay_render_surface );
+    for ( i=0; i<this->queue_length; ++i ) {
       if ( this->output_surface[i]!=VDP_INVALID_HANDLE )
         vdp_output_surface_destroy( this->output_surface[i] );
 	}
@@ -2127,6 +2301,8 @@ static void vdpau_dispose (vo_driver_t *this_gen)
   if ( (vdp_device != VDP_INVALID_HANDLE) && vdp_device_destroy )
     vdp_device_destroy( vdp_device );
 
+  pthread_mutex_destroy(&this->grab_lock);
+  pthread_cond_destroy(&this->grab_cond);
   pthread_mutex_destroy(&this->drawable_lock);
   free (this);
 }
@@ -2198,7 +2374,7 @@ static void vdpau_reinit( vo_driver_t *this_gen )
   this->current_output_surface = 0;
   this->init_queue = 0;
   int i;
-  for ( i=0; i<NOUTPUTSURFACE; ++i ) {
+  for ( i=0; i<this->queue_length; ++i ) {
     st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[i], this->output_surface_height[i], &this->output_surface[i] );
     if ( vdpau_reinit_error( st, "Can't create output surface !!" ) ) {
       int j;
@@ -2212,24 +2388,16 @@ static void vdpau_reinit( vo_driver_t *this_gen )
     }
   }
 
-  /* osd overlays need to be recreated */
-  for ( i=0; i<XINE_VORAW_MAX_OVL; ++i ) {
-    this->overlays[i].ovl_bitmap = VDP_INVALID_HANDLE;
-    this->overlays[i].bitmap_width = 0;
-    this->overlays[i].bitmap_height = 0;
-  }
-  this->overlay_output = VDP_INVALID_HANDLE;
+  this->overlay_output_surface = VDP_INVALID_HANDLE;
   this->overlay_output_width = this->overlay_output_height = 0;
-  this->overlay_unscaled = VDP_INVALID_HANDLE;
+  this->overlay_unscaled_surface = VDP_INVALID_HANDLE;
   this->overlay_unscaled_width = this->overlay_unscaled_height = 0;
+  this->overlay_render_surface = VDP_INVALID_HANDLE;
+  this->overlay_render_width = this->overlay_render_height = 0;
   this->ovl_changed = 0;
   this->has_overlay = 0;
   this->has_unscaled = 0;
 
-  this->argb_overlay = VDP_INVALID_HANDLE;
-  this->argb_overlay_width = this->argb_overlay_height = 0;
-  this->has_argb_overlay = 0;
-
   VdpVideoMixerFeature features[15];
   int features_count = 0;
   if ( this->noise_reduction_is_supported ) {
@@ -2259,12 +2427,12 @@ static void vdpau_reinit( vo_driver_t *this_gen )
   }
 #endif
   VdpVideoMixerParameter params[] = { VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH, VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT, VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE, VDP_VIDEO_MIXER_PARAMETER_LAYERS };
-  int num_layers = 3;
+  int num_layers = 2;
   void const *param_values[] = { &this->video_mixer_width, &this->video_mixer_height, &chroma, &num_layers };
   st = vdp_video_mixer_create( vdp_device, features_count, features, 4, params, param_values, &this->video_mixer );
   if ( vdpau_reinit_error( st, "Can't create video mixer !!" ) ) {
     orig_vdp_video_surface_destroy( this->soft_surface );
-    for ( i=0; i<NOUTPUTSURFACE; ++i )
+    for ( i=0; i<this->queue_length; ++i )
       vdp_output_surface_destroy( this->output_surface[i] );
 #ifdef LOCKDISPLAY
     XUnlockDisplay(guarded_display);
@@ -2383,28 +2551,18 @@ static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const vo
   this->skip_chroma_is_supported = 0;
   this->background_is_supported = 0;
 
-  for ( i=0; i<XINE_VORAW_MAX_OVL; ++i ) {
-    this->overlays[i].ovl_w = this->overlays[i].ovl_h = 0;
-    this->overlays[i].bitmap_width = this->overlays[i].bitmap_height = 0;
-    this->overlays[i].ovl_bitmap = VDP_INVALID_HANDLE;
-    this->overlays[i].ovl_x = this->overlays[i].ovl_y = 0;
-  }
-  this->overlay_output = VDP_INVALID_HANDLE;
+  this->overlay_output_surface = VDP_INVALID_HANDLE;
   this->overlay_output_width = this->overlay_output_height = 0;
-  this->overlay_unscaled = VDP_INVALID_HANDLE;
+  this->overlay_unscaled_surface = VDP_INVALID_HANDLE;
   this->overlay_unscaled_width = this->overlay_unscaled_height = 0;
+  this->overlay_render_surface = VDP_INVALID_HANDLE;
+  this->overlay_render_width = this->overlay_render_height = 0;
+  this->overlay_bitmap = NULL;
+  this->overlay_bitmap_size = 0;
   this->ovl_changed = 0;
   this->has_overlay = 0;
   this->has_unscaled = 0;
 
-  this->argb_overlay = VDP_INVALID_HANDLE;
-  this->argb_overlay_width = this->argb_overlay_height = 0;
-  this->has_argb_overlay = 0;
-
-  /*  overlay converter */
-  this->yuv2rgb_factory = yuv2rgb_factory_init (MODE_24_BGR, 0, NULL);
-  this->ovl_yuv2rgb = this->yuv2rgb_factory->create_converter( this->yuv2rgb_factory );
-
   VdpStatus st = vdp_device_create_x11( visual->display, visual->screen, &vdp_device, &vdp_get_proc_address );
   if ( st != VDP_STATUS_OK ) {
     fprintf(stderr, "vo_vdpau: Can't create vdp device : " );
@@ -2474,9 +2632,18 @@ static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const vo
   st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_RENDER_BITMAP_SURFACE , (void*)&vdp_output_surface_render_bitmap_surface );
   if ( vdpau_init_error( st, "Can't get OUTPUT_SURFACE_RENDER_BITMAP_SURFACE proc address !!", &this->vo_driver, 1 ) )
     return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_RENDER_OUTPUT_SURFACE , (void*)&vdp_output_surface_render_output_surface );
+  if ( vdpau_init_error( st, "Can't get OUTPUT_SURFACE_RENDER_OUTPUT_SURFACE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
   st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE , (void*)&vdp_output_surface_put_bits );
   if ( vdpau_init_error( st, "Can't get VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE proc address !!", &this->vo_driver, 1 ) )
     return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_GET_BITS_NATIVE , (void*)&vdp_output_surface_get_bits );
+  if ( vdpau_init_error( st, "Can't get VDP_FUNC_ID_OUTPUT_SURFACE_GET_BITS_NATIVE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR , (void*)&vdp_output_surface_put_bits_ycbcr );
+  if ( vdpau_init_error( st, "Can't get VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_YCBCR proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
   st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_CREATE , (void*)&vdp_video_mixer_create );
   if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_CREATE proc address !!", &this->vo_driver, 1 ) )
     return NULL;
@@ -2591,13 +2758,24 @@ static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const vo
   if ( vdpau_init_error( st, "Can't create video surface !!", &this->vo_driver, 1 ) )
     return NULL;
 
-  for ( i=0; i<NOUTPUTSURFACE; ++i ) {
+  this->queue_length = config->register_num (config, "video.output.vdpau_display_queue_length", 3, /* default */
+       _("default length of display queue"),
+       _("The default number of video output surfaces to create for the display queue"),
+      20, NULL, this);
+  if (this->queue_length < 2)
+    this->queue_length = 2;
+  if (this->queue_length > NOUTPUTSURFACE)
+    this->queue_length = NOUTPUTSURFACE;
+  fprintf(stderr, "vo_vdpau: using %d output surfaces for display queue\n", this->queue_length);
+
+  for ( i=0; i<this->queue_length; ++i ) {
     this->output_surface_width[i] = 320;
     this->output_surface_height[i] = 240;
   }
   this->current_output_surface = 0;
   this->init_queue = 0;
-  for ( i=0; i<NOUTPUTSURFACE; ++i ) {
+
+  for ( i=0; i<this->queue_length; ++i ) {
     st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[i], this->output_surface_height[i], &this->output_surface[i] );
     if ( vdpau_init_error( st, "Can't create output surface !!", &this->vo_driver, 1 ) ) {
       int j;
@@ -2666,12 +2844,12 @@ static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const vo
 #endif
   VdpVideoMixerParameter params[] = { VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH, VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
         VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE, VDP_VIDEO_MIXER_PARAMETER_LAYERS };
-  int num_layers = 3;
+  int num_layers = 2;
   void const *param_values[] = { &this->video_mixer_width, &this->video_mixer_height, &chroma, &num_layers };
   st = vdp_video_mixer_create( vdp_device, features_count, features, 4, params, param_values, &this->video_mixer );
   if ( vdpau_init_error( st, "Can't create video mixer !!", &this->vo_driver, 1 ) ) {
     vdp_video_surface_destroy( this->soft_surface );
-    for ( i=0; i<NOUTPUTSURFACE; ++i )
+    for ( i=0; i<this->queue_length; ++i )
       vdp_output_surface_destroy( this->output_surface[i] );
     return NULL;
   }
@@ -2761,6 +2939,18 @@ static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const vo
         10, vdpau_set_background, this );
   }
 
+  this->sd_only_properties = config->register_enum( config, "video.output.vdpau_sd_only_properties", 0, vdpau_sd_only_properties,
+        _("vdpau: restrict enabling video properties for SD video only"),
+        _("none\n"
+          "No restrictions\n\n"
+          "noise\n"
+          "Restrict noise reduction property.\n\n"
+          "sharpness\n"
+          "Restrict sharpness property.\n\n"
+          "noise+sharpness"
+          "Restrict noise and sharpness properties.\n\n"),
+        10, vdpau_update_sd_only_properties, this );
+
   /* number of video frames from config - register it with the default value. */
   int frame_num = config->register_num (config, "engine.buffers.video_num_frames", 15, /* default */
        _("default number of video frames"),
@@ -2836,6 +3026,10 @@ static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const vo
 
   this->vdp_runtime_nr = 1;
 
+  this->pending_grab_request = NULL;
+  pthread_mutex_init(&this->grab_lock, NULL);
+  pthread_cond_init(&this->grab_cond, NULL);
+
   return &this->vo_driver;
 }
 
diff --git a/src/xine-engine/accel_vdpau.h b/src/xine-engine/accel_vdpau.h
index 7ddc5e2..2917287 100644
--- a/src/xine-engine/accel_vdpau.h
+++ b/src/xine-engine/accel_vdpau.h
@@ -57,12 +57,39 @@ typedef struct {
 
 } vdpau_accel_t;
 
-#define VDPAU_DATA(frame_gen)  ((frame_gen) ? (vdpau_accel_t *)(frame_gen)->accel_data : (vdpau_accel_t *)0)
-#define VDPAU_FRAME(frame_gen) ((frame_gen) ? (vdpau_accel_t *)VDPAU_DATA(frame_gen)->vo_frame : (vdpau_frame_t *)0)
-
 #ifdef __cplusplus
 }
 #endif
 
+
+/*#define VDPAU_PROFILING*/                                            /* uncomment this if you want profiling statistics of vdpau function calls */
+#define VDPAU_PROFILING_STATISTICS_RATE            0 /*(50*60*3)       /* number of calls to be executed after that statistics will be logged */
+#define VDPAU_PROFILING_UNUSUAL_DURATION_LIMIT     250000          /* [us] limit for unusual long execution time of a call */
+
+#ifdef VDPAU_PROFILING
+#define VDPAU_PROFILE(function) \
+  do { \
+    struct timeval start_tv, end_tv, diff_tv; \
+    static uint64_t sum_us, peak_us, call_cnt; \
+    xine_monotonic_clock(&start_tv, NULL); \
+    function; \
+    xine_monotonic_clock(&end_tv, NULL); \
+    timersub(&end_tv, &start_tv, &diff_tv); \
+    uint64_t diff_us = diff_tv.tv_sec * 1000000 + diff_tv.tv_usec; \
+    if (diff_us > peak_us) \
+      peak_us = diff_us; \
+    if ((VDPAU_PROFILING_STATISTICS_RATE > 0 && call_cnt >= VDPAU_PROFILING_STATISTICS_RATE) || (VDPAU_PROFILING_UNUSUAL_DURATION_LIMIT > 0 && peak_us >= VDPAU_PROFILING_UNUSUAL_DURATION_LIMIT)) {\
+      if (call_cnt) \
+        sum_us /= call_cnt; \
+      printf("%s: (%s:%d) peak: %.3lf ms  avg: %.3lf ms  calls: %d\n", LOG_MODULE, __XINE_FUNCTION__, __LINE__, ((double)peak_us)/1000.0, ((double)sum_us)/1000.0, (int)call_cnt); \
+      call_cnt = sum_us = peak_us = 0; \
+    } \
+    sum_us += diff_us; \
+    ++call_cnt; \
+} while(0)
+#else
+#define VDPAU_PROFILE(function) function
+#endif
+
 #endif
 
diff --git a/src/xine-engine/post.c b/src/xine-engine/post.c
index 98cb3b6..d9b9fb2 100644
--- a/src/xine-engine/post.c
+++ b/src/xine-engine/post.c
@@ -436,7 +436,6 @@ void _x_post_frame_copy_down(vo_frame_t *from, vo_frame_t *to) {
   to->progressive_frame   = from->progressive_frame;
   to->picture_coding_type = from->picture_coding_type;
   to->drawn               = from->drawn;
-  to->accel_data          = from->accel_data;
   to->stream              = from->stream;
   to->crop_left           = from->crop_left;
   to->crop_right          = from->crop_right;
diff --git a/src/xine-engine/video_decoder.c b/src/xine-engine/video_decoder.c
index 29bc26d..79f2f3f 100644
--- a/src/xine-engine/video_decoder.c
+++ b/src/xine-engine/video_decoder.c
@@ -26,6 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
 
 #define XINE_ENGINE_INTERNAL
 
@@ -120,7 +121,9 @@ static void *video_decoder_loop (void *stream_gen) {
    * playback. follow the link for more information:
    * http://cambuca.ldhs.cetuc.puc-rio.br/~miguel/multimedia_sim/
    */
-  nice(-1);
+  errno = 0;
+  if (nice(-1) == -1 && errno)
+    xine_log(stream->xine, XINE_LOG_MSG, "video_decoder: can't raise nice priority by 1: %s\n", strerror(errno));
 #endif /* WIN32 */
 
   if (prof_video_decode == -1)
diff --git a/src/xine-engine/video_out.c b/src/xine-engine/video_out.c
index ea04051..2b77214 100644
--- a/src/xine-engine/video_out.c
+++ b/src/xine-engine/video_out.c
@@ -34,6 +34,7 @@
 #include <pthread.h>
 #include <inttypes.h>
 #include <assert.h>
+#include <errno.h>
 
 #define XINE_ENABLE_EXPERIMENTAL_FEATURES
 #define XINE_ENGINE_INTERNAL
@@ -1174,7 +1175,9 @@ static void *video_out_loop (void *this_gen) {
    * playback. follow the link for more information:
    * http://cambuca.ldhs.cetuc.puc-rio.br/~miguel/multimedia_sim/
    */
-  nice(-2);
+  errno = 0;
+  if (nice(-2) == -1 && errno)
+    xine_log(this->xine, XINE_LOG_MSG, "video_out: can't raise nice priority by 2: %s\n", strerror(errno));
 #endif /* WIN32 */
 
   /*
