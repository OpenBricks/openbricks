#!/bin/sh

# mount required filesystems
mount -t proc none /proc
mount -t sysfs none /sys

# prepare /dev
mount -t devtmpfs devtmpfs /dev
busybox mkdir /dev/pts /dev/shm
mount -t devpts devpts /dev/pts
mount -t tmpfs none /dev/shm

# install busybox symlinks
busybox --install -s
[ -x /sbin/bootchartd ] && /sbin/bootchartd

echo geexbox > /proc/sys/kernel/hostname

export PATH=/bin:/sbin:/usr/bin:/usr/sbin

progress() {
  echo "### $2 ###"
}

prepare_boot_from_hdd () {
  progress 11000 "HDD Boot Device Detection"
  HDD=/hdd
  mkdir -p $HDD
  for i in 0 1 2 3 4 5 6 7 8 9; do
    if [ -b "$BOOT_DEV" ]; then
      mount -o rw $BOOT_DEV $HDD
    elif [ -n "$BOOT_LABEL" -a -e "/dev/disk/by-label/$BOOT_LABEL" ]; then
      mount -o rw "/dev/disk/by-label/$BOOT_LABEL" $HDD
    fi
    if [ -d "$HDD$ROOT_LOCATION" ]; then
      GEEXBOX="$HDD$ROOT_LOCATION"
      progress 11001 "Booting from: $GEEXBOX"
      break
    fi
    [ -n "$GEEXBOX" ] && break
    usleep 250000
  done
  [ -z "$GEEXBOX" ] && echo "Booting from hdd $GEEXBOX failed! Dropping you on emergency shell..." && /bin/sh -l
}

get_devices_from_uuids () {
  # cannot be sure whether its written upper or lower case
  [ -n "$BOOT_UUID" ] && BOOT_DEV="" && BOOT_DEV_NAME=""

  for i in 0 1 2 3 4 5 6 7 9; do

    if [ -n "$BOOT_UUID" -a -z "$BOOT_DEV_NAME" ]; then
      DEV_PATH=$(find /dev/disk/by-uuid/ -iname ${BOOT_UUID})
      if [ -n "$DEV_PATH" ]; then
        BOOT_DEV_NAME=$(ls -l ${DEV_PATH} | sed 's#.*\.\.\/##')
        BOOT_DEV=/dev/$BOOT_DEV_NAME
      fi
    fi

    [ -z "$BOOT_UUID" -o -n "$BOOT_DEV" ] && break

    echo "boot device unavailable, retrying..."
    usleep 250000
  done
}

# parse command line arguments
for arg in $(cat /proc/cmdline); do
  case $arg in
    boot=*)
      BOOT="${arg#boot=}"
      case "$BOOT" in
        UUID=*)
          # Grab real device name from UUID symlink
          BOOT_UUID="${BOOT#UUID=}"
          BOOT=hdd
          ;;
        LABEL=*)
          BOOT_LABEL="${BOOT#LABEL=}"
          BOOT=hdd
          ;;
        cdrom)
          BOOT_DEV=/dev/cdrom
          BOOT=cdrom
          ;;
        *)
          BOOT_DEV=$BOOT
          BOOT=hdd
          ;;
      esac
      ;;
    bootdir=*)
      ROOT_LOCATION="${arg#bootdir=}"
      ;;
    debugging)
      INIT_ARGS="--debug"
      export DEBUG="yes"
      ;;
  esac
done

echo > /proc/sys/kernel/hotplug
mkdir -p /dev/.udev /var/log
udevd --daemon
udevadm trigger
udevadm settle --timeout=180
udevadm monitor 2>&1 >/var/log/udev &

# determine if a bootdir was specified or force the default one
[ -z "$ROOT_LOCATION" ] && ROOT_LOCATION="/GEEXBOX"


# initialize LVM
if [ -x /sbin/lvm ]; then
  modprobe dm_mod
  devmap=$(cat /proc/misc | grep "device-mapper")
  if [ -n "$devmap" ]; then
    lvm vgscan --ignorelockingfailure
    lvm vgchange -a y --ignorelockingfailure
  fi
fi

get_devices_from_uuids
[ "$BOOT" = hdd ] &&  prepare_boot_from_hdd

INIT=/sbin/init

# make environment of /etc/profile available to upstart services
export ENV=/etc/profile
. $ENV

# stop udevd, will be started by upstart again
echo -n "stopping udevd"
killall udevadm >/dev/null 2>&1
killall udevd >/dev/null 2>&1
# give it some time to end properly
for i in 0 1 2 3 4 5 6 7 8 9; do
  echo -n "."
  ( ( ps | grep -q "[u]dev" ) && usleep 250000 ) || break
done
( ps | grep -q "[u]dev" ) && echo "killing udevd."
killall -9 udevadm >/dev/null 2>&1
killall -9 udevd >/dev/null 2>&1
echo

if [ "$BOOT" = hdd ]; then 
  # bind geexbox location to a new mountpoint
  mkdir /newroot
  mount -o bind ${GEEXBOX} /newroot
  # clean up mtab
  echo -n >/newroot/etc/mtab
  [ -d /$HDD/boot ] && mkdir -p /newroot/boot && mount -o bind $HDD/boot /newroot/boot

  # fix /etc/mtab entry
  # notice: mount output on booted system is not so true. actually the device is not mounted as is, but the subdirectory {GEEXBOX}
  # same goes for boot btw, which of the origin is hidden totally
  mount | grep " on $HDD " | sed -e "s| on $HDD | \/ |" -e "s| type | |" >>/newroot/etc/mtab
  umount $HDD

  # clean up any remaining pid files from last boot
  find /newroot/var/run -name "*pid" | while read f; do rm $f; done

  # clean up /tmp
  rm -rf /newroot/tmp/* >/dev/null 2>&1
  rm -rf /newroot/tmp/.[^.]* >/dev/null 2>&1

  # clean up old mount points
  rmdir -f /newroot/mnt/* >/dev/null 2>&1

  mount -o bind /proc /newroot/proc
  mount -o bind /sys /newroot/sys
  mount -o bind /dev/shm /newroot/dev/shm
  # proc and sys and shm already mounted after switch_root
  grep "^none" /etc/mtab >>/newroot/etc/mtab

  # clean ramdisk, chroot and run init
  exec switch_root -c /dev/console /newroot $INIT $INIT_ARGS
else
  exec /sbin/init $INIT_ARGS </dev/tty1 >/dev/tty1
fi

