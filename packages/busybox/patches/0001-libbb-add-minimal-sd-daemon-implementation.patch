>From 04a91949e46db799e67ec775d8349414abde1a34 Mon Sep 17 00:00:00 2001
From: Davide Cavalca <davide@geexbox.org>
Date: Sun, 16 Jan 2011 10:39:08 +0100
Subject: [PATCH 1/4] libbb: add minimal sd-daemon implementation


Signed-off-by: Davide Cavalca <davide@geexbox.org>
---
 include/sd-daemon.h |   36 +++++++++++
 libbb/sd-daemon.c   |  164 +++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 200 insertions(+), 0 deletions(-)
 create mode 100644 include/sd-daemon.h
 create mode 100644 libbb/sd-daemon.c

diff --git a/include/sd-daemon.h b/include/sd-daemon.h
new file mode 100644
index 0000000..f605c52
--- /dev/null
+++ b/include/sd-daemon.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2011 Davide Cavalca <davide@geexbox.org>
+ *
+ * Based on http://cgit.freedesktop.org/systemd/tree/src/sd-daemon.h
+ * Copyright 2010 Lennart Poettering
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef BB_SD_DAEMON_H
+#define BB_SD_DAEMON_H
+
+#define SD_LISTEN_FDS_START 3
+
+int sd_listen_fds(void);
+int xsystemd_unix_socket(const char *path);
+
+#endif
diff --git a/libbb/sd-daemon.c b/libbb/sd-daemon.c
new file mode 100644
index 0000000..2237e19
--- /dev/null
+++ b/libbb/sd-daemon.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2011 Davide Cavalca <davide@geexbox.org>
+ *
+ * Based on http://cgit.freedesktop.org/systemd/tree/src/sd-daemon.c
+ * Copyright 2010 Lennart Poettering
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <sys/un.h>
+
+#include "libbb.h"
+#include "sd-daemon.h"
+
+int sd_listen_fds(void) {
+	int fd;
+	const char *e;
+	char *p = NULL;
+	unsigned long l;
+
+	if (!(e = getenv("LISTEN_PID")))
+		return 0;
+
+	errno = 0;
+	l = strtoul(e, &p, 10);
+
+	if (errno != 0)
+		return -errno;
+
+	if (!p || *p || l <= 0)
+		return -EINVAL;
+
+	/* Is this for us? */
+	if (getpid() != (pid_t) l)
+		return 0;
+
+	if (!(e = getenv("LISTEN_FDS")))
+		return 0;
+
+	errno = 0;
+	l = strtoul(e, &p, 10);
+
+	if (errno != 0)
+		return -errno;
+
+	if (!p || *p)
+		return -EINVAL;
+
+	for (fd = SD_LISTEN_FDS_START; fd < SD_LISTEN_FDS_START + (int) l; fd ++) {
+		int flags;
+
+		if ((flags = fcntl(fd, F_GETFD)) < 0)
+			return -errno;
+
+		if (flags & FD_CLOEXEC)
+			continue;
+
+		if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)
+			return -errno;
+	}
+
+	return (int) l;
+}
+
+static int sd_is_socket_internal(int fd, int type) {
+	struct stat st_fd;
+
+	if (fd < 0 || type < 0)
+		return -EINVAL;
+
+	if (fstat(fd, &st_fd) < 0)
+		return -errno;
+
+	if (!S_ISSOCK(st_fd.st_mode))
+		return 0;
+
+	if (type != 0) {
+		int other_type = 0;
+		socklen_t l = sizeof(other_type);
+
+		if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &other_type, &l) < 0)
+			return -errno;
+
+		if (l != sizeof(other_type))
+			return -EINVAL;
+
+		if (other_type != type)
+			return 0;
+	}
+
+	return 1;
+}
+
+union sockaddr_union {
+        struct sockaddr sa;
+        struct sockaddr_in in4;
+        struct sockaddr_in6 in6;
+        struct sockaddr_un un;
+        struct sockaddr_storage storage;
+};
+
+static int sd_is_socket_unix(int fd, int type, const char *path) {
+	union sockaddr_union sockaddr;
+	socklen_t l;
+	int r;
+
+	if ((r = sd_is_socket_internal(fd, type)) <= 0)
+		return r;
+
+	memset(&sockaddr, 0, sizeof(sockaddr));
+	l = sizeof(sockaddr);
+
+	if (getsockname(fd, &sockaddr.sa, &l) < 0)
+		return -errno;
+
+	if (l < sizeof(sa_family_t))
+		return -EINVAL;
+
+	if (sockaddr.sa.sa_family != AF_UNIX)
+		return 0;
+
+	return (l >= offsetof(struct sockaddr_un, sun_path) + 1) &&
+		memcmp(path, sockaddr.un.sun_path, 1) == 0;
+}
+
+int xsystemd_unix_socket(const char *path) {
+	int r = sd_listen_fds();
+
+	if (r < 0)
+		bb_error_msg_and_die ("Failed to acquire systemd socket");
+	if (r > 1)
+		bb_error_msg_and_die ("Wrong number of systemd sockets passed");
+	if (r == 1) {
+		int fd = SD_LISTEN_FDS_START;
+
+		r = sd_is_socket_unix(fd, SOCK_DGRAM, path);
+		if (r < 0)
+			bb_error_msg_and_die ("Failed to verify systemd socket type");
+		if (!r)
+			bb_error_msg_and_die ("Passed systemd socket of wrong type");
+
+		return fd;
+	}
+
+	return -1;
+}
-- 
1.7.2.3

