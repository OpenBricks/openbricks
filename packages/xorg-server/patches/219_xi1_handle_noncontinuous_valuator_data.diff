From 8a67ba29b82e2a627172b7ee181091df59e4cace Mon Sep 17 00:00:00 2001
From: Chase Douglas <chase.douglas@canonical.com>
Date: Mon, 28 Mar 2011 12:08:46 -0400
Subject: [PATCH 2/2] Handle non continuous valuator data in getValuatorEvents

This allows for masked valuators to be handled properly in XI 1.x
events. Any unset valuators in the device event are set to the last
known value when transmitted on the wire through XI 1.x valuator events.

Fixes https://bugs.launchpad.net/ubuntu/+source/xorg-server/+bug/736500

Signed-off-by: Chase Douglas <chase.douglas@canonical.com>
---
 dix/eventconvert.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/dix/eventconvert.c b/dix/eventconvert.c
index 9192080..3285133 100644
--- a/dix/eventconvert.c
+++ b/dix/eventconvert.c
@@ -364,19 +364,18 @@ getValuatorEvents(DeviceEvent *ev, deviceValuator *xv)
     int i;
     int state = 0;
     int first_valuator, num_valuators;
+    DeviceIntPtr dev = NULL;
 
 
     num_valuators = countValuators(ev, &first_valuator);
     if (num_valuators > 0)
     {
-        DeviceIntPtr dev = NULL;
         dixLookupDevice(&dev, ev->deviceid, serverClient, DixUseAccess);
         /* State needs to be assembled BEFORE the device is updated. */
         state = (dev && dev->key) ? XkbStateFieldFromRec(&dev->key->xkbInfo->state) : 0;
         state |= (dev && dev->button) ? (dev->button->state) : 0;
     }
 
-    /* FIXME: non-continuous valuator data in internal events*/
     for (i = 0; i < num_valuators; i += 6, xv++) {
         INT32 *valuators = &xv->valuator0; // Treat all 6 vals as an array
         int j;
@@ -387,8 +386,12 @@ getValuatorEvents(DeviceEvent *ev, deviceValuator *xv)
         xv->deviceid = ev->deviceid;
         xv->device_state = state;
 
-        for (j = 0; j < xv->num_valuators; j++)
-            valuators[j] = ev->valuators.data[xv->first_valuator + j];
+        for (j = 0; j < xv->num_valuators; j++) {
+            if (BitIsOn(ev->valuators.mask, xv->first_valuator + j))
+                valuators[j] = ev->valuators.data[xv->first_valuator + j];
+            else
+                valuators[j] = dev->valuator->axisVal[xv->first_valuator + j];
+        }
 
         if (i + 6 < num_valuators)
             xv->deviceid |= MORE_EVENTS;
-- 
1.7.4.1

