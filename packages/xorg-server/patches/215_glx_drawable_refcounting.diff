diff -Naur xorg-server-1.10.3.orig//glx/glxcmds.c xorg-server-1.10.3/glx/glxcmds.c
--- xorg-server-1.10.3.orig//glx/glxcmds.c	2011-07-20 13:56:31.905565524 +0200
+++ xorg-server-1.10.3/glx/glxcmds.c	2011-07-20 13:59:17.655565616 +0200
@@ -453,8 +453,9 @@
 	    *error = BadMatch;
 	    return NULL;
 	}
+	pGlxDraw->refcnt++;
 
-	return pGlxDraw;
+        return pGlxDraw;
     }
 
     /* No active context and an unknown drawable, bail. */
@@ -1095,8 +1096,10 @@
     drawable->pDraw = pDraw;
     drawable->type = type;
     drawable->drawId = drawId;
+    drawable->otherId = 0;
     drawable->config = config;
     drawable->eventMask = 0;
+    drawable->refcnt = 0;
 
     return GL_TRUE;
 }
@@ -1126,15 +1129,22 @@
 	pGlxDraw->destroy (pGlxDraw);
 	return BadAlloc;
     }
+    pGlxDraw->refcnt++;
 
     /*
      * Windows aren't refcounted, so track both the X and the GLX window
      * so we get called regardless of destruction order.
      */
-    if (drawableId != glxDrawableId && type == GLX_DRAWABLE_WINDOW &&
-	!AddResource(pDraw->id, __glXDrawableRes, pGlxDraw)) {
-	pGlxDraw->destroy (pGlxDraw);
-	return BadAlloc;
+    if (drawableId != glxDrawableId) {
+       /* Add the glx drawable under the XID of the underlying X drawable
+        * too.  That way we'll get a callback in DrawableGone and can
+        * clean up properly when the drawable is destroyed. */
+       if (!AddResource(drawableId, __glXDrawableRes, pGlxDraw)) {
+           pGlxDraw->destroy (pGlxDraw);
+           return BadAlloc;
+       }
+       pGlxDraw->refcnt++;
+       pGlxDraw->otherId = drawableId;
     }
 
     return Success;
diff -Naur xorg-server-1.10.3.orig//glx/glxdrawable.h xorg-server-1.10.3/glx/glxdrawable.h
--- xorg-server-1.10.3.orig//glx/glxdrawable.h	2011-07-20 13:56:31.905565524 +0200
+++ xorg-server-1.10.3/glx/glxdrawable.h	2011-07-20 13:59:56.655565638 +0200
@@ -51,8 +51,11 @@
     void      (*waitX)(__GLXdrawable *);
     void      (*waitGL)(__GLXdrawable *);
 
+    int refcnt; /* number of resources handles referencing this */
+
     DrawablePtr pDraw;
     XID drawId;
+    XID otherId; /* for glx1.3 we need to track the original Drawable as well */
 
     /*
     ** Either GLX_DRAWABLE_PIXMAP, GLX_DRAWABLE_WINDOW or
diff -Naur xorg-server-1.10.3.orig//glx/glxext.c xorg-server-1.10.3/glx/glxext.c
--- xorg-server-1.10.3.orig//glx/glxext.c	2011-07-20 13:56:31.905565524 +0200
+++ xorg-server-1.10.3/glx/glxext.c	2011-07-20 14:01:58.995565706 +0200
@@ -126,13 +126,18 @@
 
     if (glxPriv->type == GLX_DRAWABLE_WINDOW) {
         /* If this was created by glXCreateWindow, free the matching resource */
-        if (glxPriv->drawId != glxPriv->pDraw->id) {
-            if (xid == glxPriv->drawId)
-                FreeResourceByType(glxPriv->pDraw->id, __glXDrawableRes, TRUE);
-            else
-                FreeResourceByType(glxPriv->drawId, __glXDrawableRes, TRUE);
-        }
-        /* otherwise this window was implicitly created by MakeCurrent */
+    if (glxPriv->otherId) {
+           XID other = glxPriv->otherId;
+           glxPriv->otherId = 0;
+           if (xid == other)
+                   FreeResourceByType(glxPriv->drawId, __glXDrawableRes, TRUE);
+           else
+                   FreeResourceByType(other, __glXDrawableRes, TRUE);
+    }
+
+    if (--glxPriv->refcnt)
+           return True;
+           /* otherwise this window was implicitly created by MakeCurrent */
     }
 
     for (c = glxAllContexts; c; c = next) {
