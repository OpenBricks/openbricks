From 57dfe13262845adbeb7dcd8285f848f32b7b0dd7 Mon Sep 17 00:00:00 2001
From: Tobias Arrskog <topfs2@xbmc.org>
Date: Tue, 12 Apr 2011 13:45:03 -0400
Subject: [PATCH 3/4] Added gstreamer decoder (not hooked up)

---
 .../DVDCodecs/Video/DVDVideoCodecGStreamer.cpp     |  276 ++++++++++++++++++++
 .../DVDCodecs/Video/DVDVideoCodecGStreamer.h       |   69 +++++
 .../cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp |  261 ++++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h  |   57 ++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |    6 +
 5 files changed, 669 insertions(+), 0 deletions(-)
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
new file mode 100644
index 0000000..8eb09cd
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
@@ -0,0 +1,276 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "DVDVideoCodecGStreamer.h"
+#include "DVDStreamInfo.h"
+#include "DVDClock.h"
+#include <gst/app/gstappsrc.h>
+#include <gst/app/gstappsink.h>
+
+bool CDVDVideoCodecGStreamer::gstinitialized = false;
+
+CDVDVideoCodecGStreamer::CDVDVideoCodecGStreamer()
+{
+  if (gstinitialized == false)
+ {
+    gst_init (NULL, NULL);
+    gstinitialized = true;
+  }
+
+  m_initialized = false;
+  m_pictureBuffer = NULL;
+
+  m_decoder = NULL;
+  m_needData = false;
+  m_AppSrc = NULL;
+  m_AppSrcCaps = NULL;
+  m_ptsinvalid = true;
+
+  m_timebase = 1000.0;
+}
+
+CDVDVideoCodecGStreamer::~CDVDVideoCodecGStreamer()
+{
+  Dispose();
+}
+
+bool CDVDVideoCodecGStreamer::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  Dispose();
+
+  m_ptsinvalid = hints.ptsinvalid;
+
+  m_AppSrcCaps = CreateVideoCaps(hints, options);
+
+  if (m_AppSrcCaps)
+  {
+    m_decoder = new CGstDecoder(this);
+    m_AppSrc = m_decoder->Open(m_AppSrcCaps);
+  }
+
+  return (m_AppSrc != NULL);
+}
+
+void CDVDVideoCodecGStreamer::Dispose()
+{
+  while (m_pictureQueue.size())
+  {
+    gst_buffer_unref(m_pictureQueue.front());
+    m_pictureQueue.pop();
+  }
+
+  if (m_pictureBuffer)
+  {
+    gst_buffer_unref(m_pictureBuffer);
+    m_pictureBuffer = NULL;
+  }
+
+  if (m_AppSrc)
+  {
+    GstFlowReturn ret;
+    g_signal_emit_by_name(m_AppSrc, "end-of-stream", &ret);
+
+    if (ret != GST_FLOW_OK)
+      printf("GStreamer: OnDispose. Flow error %i\n", ret);
+
+    gst_object_unref(m_AppSrc);
+    m_AppSrc = NULL;
+  }
+
+  if (m_AppSrcCaps)
+  {
+    gst_caps_unref(m_AppSrcCaps);
+    m_AppSrcCaps = NULL;
+  }
+
+  if (m_decoder)
+  {
+    m_decoder->StopThread();
+    delete m_decoder;
+    m_decoder = NULL;
+
+    m_initialized = false;
+  }
+}
+
+int CDVDVideoCodecGStreamer::Decode(BYTE* pData, int iSize, double dts, double pts)
+{
+  CSingleLock lock(m_monitorLock);
+  usleep(100);
+
+  GstBuffer *buffer = NULL;
+
+  if (pData)
+  {
+    buffer = gst_buffer_new_and_alloc(iSize);
+    if (buffer)
+    {
+      memcpy(GST_BUFFER_DATA(buffer), pData, iSize);
+
+      GST_BUFFER_TIMESTAMP(buffer) = pts * 1000.0;
+
+      GstFlowReturn ret;
+      g_signal_emit_by_name(m_AppSrc, "push-buffer", buffer, &ret);
+
+      if (ret != GST_FLOW_OK)
+        printf("GStreamer: OnDecode. Flow error %i\n", ret);
+
+      gst_buffer_unref(buffer);
+    }
+  }
+
+  if (m_pictureBuffer)
+ {
+    gst_buffer_unref(m_pictureBuffer);
+    m_pictureBuffer = NULL;
+  }
+
+  if (m_pictureQueue.size())
+    return VC_PICTURE;
+  else
+    return VC_BUFFER;
+}
+
+void CDVDVideoCodecGStreamer::Reset()
+{
+}
+
+bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  CSingleLock lock(m_monitorLock);
+  if (m_pictureQueue.size())
+  {
+    m_pictureBuffer = m_pictureQueue.front();
+    m_pictureQueue.pop();
+  }
+  else
+    return false;
+
+  GstCaps *caps = gst_buffer_get_caps(m_pictureBuffer);
+  if (caps == NULL)
+  {
+    printf("GStreamer: No caps on decoded buffer\n");
+    return false;
+  }
+
+  GstStructure *structure = gst_caps_get_structure (caps, 0);
+  int width = 0, height = 0;
+  if (structure == NULL ||
+      !gst_structure_get_int (structure, "width", (int *) &width) ||
+      !gst_structure_get_int (structure, "height", (int *) &height))
+  {
+    printf("GStreamer: invalid caps on decoded buffer\n");
+    return false;
+  }
+
+  pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth  = width;
+  pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight = height;
+
+  pDvdVideoPicture->format = DVDVideoPicture::FMT_YUV420P;
+
+#define ALIGN(x, n) (((x) + (n) - 1) & (~((n) - 1)))
+  pDvdVideoPicture->data[0] = m_pictureBuffer->data;
+  pDvdVideoPicture->iLineSize[0] = ALIGN (width, 4);
+  pDvdVideoPicture->data[1] = pDvdVideoPicture->data[0] + pDvdVideoPicture->iLineSize[0] * ALIGN (height, 2);
+  pDvdVideoPicture->iLineSize[1] = ALIGN (width, 8) / 2;
+  pDvdVideoPicture->data[2] = pDvdVideoPicture->data[1] + pDvdVideoPicture->iLineSize[1] * ALIGN (height, 2) / 2;
+  pDvdVideoPicture->iLineSize[2] = pDvdVideoPicture->iLineSize[1];
+  g_assert (pDvdVideoPicture->data[2] + pDvdVideoPicture->iLineSize[2] * ALIGN (height, 2) / 2 == pDvdVideoPicture->data[0] + m_pictureBuffer->size);
+#undef ALIGN
+
+  pDvdVideoPicture->pts = (double)GST_BUFFER_TIMESTAMP(m_pictureBuffer) / 1000.0;
+  pDvdVideoPicture->iDuration = (double)GST_BUFFER_DURATION(m_pictureBuffer) / 1000.0;
+
+  return true;
+}
+
+void CDVDVideoCodecGStreamer::SetDropState(bool bDrop)
+{
+}
+
+const char *CDVDVideoCodecGStreamer::GetName()
+{
+  return "GStreamer";
+}
+
+void CDVDVideoCodecGStreamer::OnDecodedBuffer(GstBuffer *buffer)
+{
+  if (buffer)
+  {
+    CSingleLock lock(m_monitorLock);
+    m_pictureQueue.push(buffer);
+  }
+  else
+    printf("GStreamer: Received null buffer?\n");
+}
+
+void CDVDVideoCodecGStreamer::OnNeedData()
+{
+  m_needData = true;
+}
+
+void CDVDVideoCodecGStreamer::OnEnoughData()
+{
+  m_needData = false;
+}
+
+GstCaps *CDVDVideoCodecGStreamer::CreateVideoCaps(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  GstCaps *caps = NULL;
+
+  switch (hints.codec)
+  {
+    case CODEC_ID_H264:
+      caps = gst_caps_new_simple ("video/x-h264", NULL);
+      break;
+
+    default:
+      printf("GStreamer: codec: unkown = %i\n", hints.codec);
+      break;
+  }
+
+  if (caps)
+  {
+    gst_caps_set_simple(caps, 
+                        "width", G_TYPE_INT, hints.width,
+                        "height", G_TYPE_INT, hints.height,
+                        "framerate", GST_TYPE_FRACTION,
+                          (hints.vfr ? 0 : hints.fpsrate),
+                          (hints.vfr ? 1 : hints.fpsscale),
+                        NULL);
+
+    if (hints.extradata && hints.extrasize > 0)
+    {
+      GstBuffer *data = NULL;
+      data = gst_buffer_new_and_alloc(hints.extrasize);
+      memcpy(GST_BUFFER_DATA(data), hints.extradata, hints.extrasize);
+
+      gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, data, NULL);
+      gst_buffer_unref(data);
+    }
+  }
+
+  return caps;
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
new file mode 100644
index 0000000..d7eb61e
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
@@ -0,0 +1,69 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDVideoCodec.h"
+#include "utils/SingleLock.h"
+#include <gst/gst.h>
+#include <queue>
+#include "utils/Thread.h"
+#include "GstDecoder.h"
+
+class CGstDecoder;
+
+class CDVDVideoCodecGStreamer : public CDVDVideoCodec, public IGstDecoderCallback
+{
+public:
+  CDVDVideoCodecGStreamer();
+  virtual ~CDVDVideoCodecGStreamer();
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName();
+
+  void OnDecodedBuffer(GstBuffer *buffer);
+  void OnNeedData();
+  void OnEnoughData();
+
+private:
+  static GstCaps *CreateVideoCaps(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+
+  static bool gstinitialized;
+
+  bool m_initialized;
+
+  std::queue<GstBuffer *> m_pictureQueue;
+  GstBuffer *m_pictureBuffer;
+
+  CCriticalSection m_needBuffer;
+  CCriticalSection m_monitorLock;
+
+  CGstDecoder *m_decoder;
+  GstElement *m_AppSrc;
+  GstCaps *m_AppSrcCaps;
+  double m_timebase;
+
+  bool m_needData;
+  bool m_ptsinvalid;
+};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
new file mode 100644
index 0000000..80e4e11
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
@@ -0,0 +1,261 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GstDecoder.h"
+#include <gst/app/gstappsrc.h>
+#include <gst/app/gstappsink.h>
+
+CGstDecoder::CGstDecoder(IGstDecoderCallback *callback) : m_callback(callback)
+{
+  m_loop      = NULL;
+  m_pipeline  = NULL;
+}
+
+CGstDecoder::~CGstDecoder()
+{
+  if (m_pipeline)
+  {
+    gst_object_unref(m_pipeline);
+    m_pipeline = NULL;
+  }
+}
+
+GstElement *CGstDecoder::Open(GstCaps *sourceCapabilities)
+{
+  m_loop = g_main_loop_new (NULL, FALSE);
+  if (m_loop == NULL)
+    return false;
+
+  gchar *capsString = gst_caps_to_string(sourceCapabilities);
+
+  printf("GStreamer: The capabilities from source are %s\n", capsString);
+
+  gchar *pipelineString = g_strdup_printf("appsrc caps=\"%s\" name=\"AppSrc\" ! decodebin2 ! ffmpegcolorspace ! appsink caps=\"video/x-raw-yuv,format=(fourcc)I420\" name=\"AppSink\"", capsString);
+
+  printf("GStreamer: Entire pipeline is %s\n", pipelineString);
+
+  m_pipeline = gst_parse_launch(pipelineString, NULL);
+  g_free(capsString);
+  g_free(pipelineString);
+
+  if (m_pipeline == NULL)
+    return NULL;
+
+  GstBus *bus = gst_element_get_bus(m_pipeline);
+  gst_bus_add_watch (bus, (GstBusFunc)BusCallback, this);
+  gst_object_unref (bus);
+
+  GstElement *AppSrc = gst_bin_get_by_name(GST_BIN(m_pipeline), "AppSrc");
+
+  if (AppSrc)
+  {
+    g_signal_connect(AppSrc, "need-data", G_CALLBACK (OnNeedData), this);
+    g_signal_connect(AppSrc, "enough-data", G_CALLBACK (OnEnoughData), this);
+  }
+  else
+    printf("GStreamer: Failure to hook up to AppSrc\n");
+
+  GstElement *AppSink = gst_bin_get_by_name(GST_BIN(m_pipeline), "AppSink");
+  if (AppSink)
+  {
+    g_object_set(G_OBJECT(AppSink), "emit-signals", TRUE, "sync", FALSE, NULL);
+    g_signal_connect(AppSink, "new-buffer", G_CALLBACK(CGstDecoder::OnDecodedBuffer), this);
+    gst_object_unref(AppSink);
+  }
+  else
+    printf("GStreamer: Failure to hook up to AppSink\n");
+
+  Create();
+
+  return AppSrc;
+}
+
+void CGstDecoder::StopThread(bool bWait)
+{
+  g_main_loop_quit(m_loop);
+  CThread::StopThread(bWait);
+}
+
+void CGstDecoder::Process()
+{
+  gst_element_set_state(m_pipeline, GST_STATE_PLAYING);
+
+  g_main_loop_run(m_loop);
+
+  gst_element_set_state(m_pipeline, GST_STATE_NULL);
+}
+
+void CGstDecoder::OnDecodedBuffer(GstElement *appsink, void *data)
+{
+  CGstDecoder *decoder = (CGstDecoder *)data;
+
+  GstBuffer *buffer = gst_app_sink_pull_buffer(GST_APP_SINK(appsink));
+  if (buffer)
+  {
+    if (decoder->m_callback)
+      decoder->m_callback->OnDecodedBuffer(buffer);
+    else
+      gst_buffer_unref(buffer);
+  }
+  else
+    printf("GStreamer: OnDecodedBuffer - Null Buffer\n");
+}
+
+void CGstDecoder::OnNeedData(GstElement *appsrc, guint size, void *data)
+{
+  CGstDecoder *decoder = (CGstDecoder *)data;
+
+  if (decoder->m_callback)
+    decoder->m_callback->OnNeedData();
+}
+
+/* This callback is called when appsrc has enough data and we can stop sending.
+ * We remove the idle handler from the mainloop */
+void CGstDecoder::OnEnoughData (GstElement *appsrc, void *data)
+{
+  CGstDecoder *decoder = (CGstDecoder *)data;
+
+  if (decoder->m_callback)
+    decoder->m_callback->OnEnoughData();
+}
+
+gboolean CGstDecoder::BusCallback(GstBus *bus, GstMessage *msg, gpointer data)
+{
+  CGstDecoder *decoder = (CGstDecoder *)data;
+  gchar  *str;
+
+  switch (GST_MESSAGE_TYPE(msg))
+  {
+    case GST_MESSAGE_EOS:
+      g_print ("GStreamer: End of stream\n");
+      g_main_loop_quit(decoder->m_loop);
+      break;
+
+    case GST_MESSAGE_ERROR:
+      GError *error;
+
+      gst_message_parse_error (msg, &error, &str);
+      g_free (str);
+
+      g_printerr ("GStreamer: Error - %s %s\n", str, error->message);
+      g_error_free (error);
+
+      g_main_loop_quit(decoder->m_loop);
+      break;
+
+    case GST_MESSAGE_WARNING:
+      GError *warning;
+
+      gst_message_parse_error (msg, &warning, &str);
+      g_free (str);
+
+      g_printerr ("GStreamer: Warning - %s %s\n", str, warning->message);
+      g_error_free (warning);
+      break;
+
+    case GST_MESSAGE_INFO:
+      GError *info;
+
+      gst_message_parse_error (msg, &info, &str);
+      g_free (str);
+
+      g_printerr ("GStreamer: Info - %s %s\n", str, info->message);
+      g_error_free (info);
+      break;
+
+    case GST_MESSAGE_TAG:
+      printf("GStreamer: Message TAG\n");
+      break;
+    case GST_MESSAGE_BUFFERING:
+      printf("GStreamer: Message BUFFERING\n");
+      break;
+    case GST_MESSAGE_STATE_CHANGED:
+      printf("GStreamer: Message STATE_CHANGED\n");
+      GstState old_state, new_state;
+      
+      gst_message_parse_state_changed (msg, &old_state, &new_state, NULL);
+      printf("GStreamer: Element %s changed state from %s to %s.\n",
+          GST_OBJECT_NAME (msg->src),
+          gst_element_state_get_name (old_state),
+          gst_element_state_get_name (new_state));
+      break;
+    case GST_MESSAGE_STATE_DIRTY:
+      printf("GStreamer: Message STATE_DIRTY\n");
+      break;
+    case GST_MESSAGE_STEP_DONE:
+      printf("GStreamer: Message STEP_DONE\n");
+      break;
+    case GST_MESSAGE_CLOCK_PROVIDE:
+      printf("GStreamer: Message CLOCK_PROVIDE\n");
+      break;
+    case GST_MESSAGE_CLOCK_LOST:
+      printf("GStreamer: Message CLOCK_LOST\n");
+      break;
+    case GST_MESSAGE_NEW_CLOCK:
+      printf("GStreamer: Message NEW_CLOCK\n");
+      break;
+    case GST_MESSAGE_STRUCTURE_CHANGE:
+      printf("GStreamer: Message STRUCTURE_CHANGE\n");
+      break;
+    case GST_MESSAGE_STREAM_STATUS:
+      printf("GStreamer: Message STREAM_STATUS\n");
+      break;
+    case GST_MESSAGE_APPLICATION:
+      printf("GStreamer: Message APPLICATION\n");
+      break;
+    case GST_MESSAGE_ELEMENT:
+      printf("GStreamer: Message ELEMENT\n");
+      break;
+    case GST_MESSAGE_SEGMENT_START:
+      printf("GStreamer: Message SEGMENT_START\n");
+      break;
+    case GST_MESSAGE_SEGMENT_DONE:
+      printf("GStreamer: Message SEGMENT_DONE\n");
+      break;
+    case GST_MESSAGE_DURATION:
+      printf("GStreamer: Message DURATION\n");
+      break;
+    case GST_MESSAGE_LATENCY:
+      printf("GStreamer: Message LATENCY\n");
+      break;
+    case GST_MESSAGE_ASYNC_START:
+      printf("GStreamer: Message ASYNC_START\n");
+      break;
+    case GST_MESSAGE_ASYNC_DONE:
+      printf("GStreamer: Message ASYNC_DONE\n");
+      break;
+    case GST_MESSAGE_REQUEST_STATE:
+      printf("GStreamer: Message REQUEST_STATE\n");
+      break;
+    case GST_MESSAGE_STEP_START:
+      printf("GStreamer: Message STEP_START\n");
+      break;
+    case GST_MESSAGE_QOS:
+      printf("GStreamer: Message QOS\n");
+      break;
+
+    default:
+      printf("GStreamer: Unknown message %i\n", GST_MESSAGE_TYPE(msg));
+      break;
+  }
+
+  return TRUE;
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
new file mode 100644
index 0000000..75ec2a5
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
@@ -0,0 +1,57 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <gst/gst.h>
+#include <queue>
+#include "utils/Thread.h"
+
+class IGstDecoderCallback
+{
+public:
+  virtual void OnDecodedBuffer(GstBuffer *buffer) = 0;
+  virtual void OnNeedData() = 0;
+  virtual void OnEnoughData() = 0;
+};
+
+class CGstDecoder : public CThread
+{
+public:
+  CGstDecoder(IGstDecoderCallback *callback);
+  ~CGstDecoder();
+
+  GstElement *Open(GstCaps *sourceCapabilities);
+  virtual void StopThread(bool bWait = true);
+
+protected:
+  virtual void Process();
+
+private:
+  static void OnDecodedBuffer(GstElement *appsink, void *data);
+  static void OnNeedData(GstElement *appsrc, guint size, void *data);
+  static void OnEnoughData (GstElement *appsrc, void *data);
+  static gboolean BusCallback(GstBus *bus, GstMessage *msg, gpointer data);
+
+  GstElement *m_pipeline;
+  GMainLoop *m_loop;
+
+  IGstDecoderCallback *m_callback;
+};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 1dce256..276ffde 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -28,6 +28,12 @@ SRCS += OpenMax.cpp \
 
 endif
 
+ifeq (@USE_GSTREAMER@,1)
+SRCS += GstDecoder.cpp \
+        DVDVideoCodecGStreamer.cpp \
+
+endif
+
 LIB=Video.a
 
 include @abs_top_srcdir@/Makefile.include
-- 
1.7.2.5

