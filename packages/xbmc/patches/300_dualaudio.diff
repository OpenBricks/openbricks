Dual Audio Output support for XBMC
http://forum.xbmc.org/showthread.php?t=86038

Based on xbmc-10.1-dualaudio-mod-source.rar

diff -Naur xbmc-10.1/guilib/AudioContext.cpp xbmc-10.1a/guilib/AudioContext.cpp
--- xbmc-10.1/guilib/AudioContext.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/guilib/AudioContext.cpp	2011-10-08 07:57:40.298976381 +0200
@@ -32,6 +32,7 @@
 
 
 CAudioContext& g_audioContext = g_SystemGlobals.m_audioContext;
+CAudioContext& g_audioContext2 = g_SystemGlobals.m_audioContext2;
 
 #ifdef _WIN32
 static GUID g_digitaldevice;
@@ -62,6 +63,21 @@
 #endif
   m_pDirectSoundDevice=NULL;
 #endif
+  m_bAudio2 = false;
+}
+
+CAudioContext::CAudioContext(bool bAudio2)
+{
+  m_bAC3EncoderActive=false;
+  m_iDevice=DEFAULT_DEVICE;
+  m_strDevice.clear();
+#ifdef HAS_AUDIO
+#ifdef HAS_AUDIO_PASS_THROUGH
+  m_pAC97Device=NULL;
+#endif
+  m_pDirectSoundDevice=NULL;
+#endif
+  m_bAudio2 = bAudio2;
 }
 
 CAudioContext::~CAudioContext()
@@ -71,7 +87,15 @@
 // \brief Create a new device by type (DEFAULT_DEVICE, DIRECTSOUND_DEVICE, AC97_DEVICE)
 void CAudioContext::SetActiveDevice(int iDevice)
 {
-  CStdString strAudioDev = g_guiSettings.GetString("audiooutput.audiodevice");
+  CStdString strAudioDev;
+  if(!m_bAudio2)
+  {
+    strAudioDev = g_guiSettings.GetString("audiooutput.audiodevice");
+  }
+  else
+  {
+    strAudioDev = g_guiSettings.GetString("audiooutput2.audiodevice");
+  }
 
   /* if device is the same, no need to bother */
 #ifdef _WIN32
@@ -185,7 +209,10 @@
     return;
   }
 #endif
-  g_audioManager.Initialize(m_iDevice);
+  if (!m_bAudio2)
+  {
+    g_audioManager.Initialize(m_iDevice);
+  }
 }
 
 // \brief Return the active device type (NONE, DEFAULT_DEVICE, DIRECTSOUND_DEVICE, AC97_DEVICE)
@@ -198,7 +225,10 @@
 void CAudioContext::RemoveActiveDevice()
 {
   CLog::Log(LOGDEBUG, "%s - Removing device %i", __FUNCTION__, m_iDevice);
-  g_audioManager.DeInitialize(m_iDevice);
+  if (!m_bAudio2)
+  {
+    g_audioManager.DeInitialize(m_iDevice);
+  }
   m_iDevice=NONE;
 
 #ifdef HAS_AUDIO
@@ -218,7 +248,16 @@
 #ifdef HAS_AUDIO
   return; //not implemented
   DWORD spconfig = DSSPEAKER_USE_DEFAULT;
-  if (AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode")))
+  bool bBitStream;
+  if (!m_bAudio2)
+  {
+    bBitStream = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode"));
+  }
+  else
+  {
+    bBitStream = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode"));
+  }
+  if (bBitStream)
   {
     if (g_settings.m_currentVideoSettings.m_OutputToAllSpeakers && !bIsMusic)
     {
diff -Naur xbmc-10.1/guilib/AudioContext.h xbmc-10.1a/guilib/AudioContext.h
--- xbmc-10.1/guilib/AudioContext.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/guilib/AudioContext.h	2011-10-08 07:57:40.298976381 +0200
@@ -41,6 +41,7 @@
 {
 public:
   CAudioContext();
+  CAudioContext(bool bAudio2);
   virtual ~CAudioContext();
 
   void                        SetActiveDevice(int iDevice);
@@ -71,6 +72,9 @@
   int                          m_iDevice;
   CStdString                   m_strDevice;
   bool                         m_bAC3EncoderActive;
+
+  bool                         m_bAudio2;
 };
 
 extern CAudioContext& g_audioContext;
+extern CAudioContext& g_audioContext2;
diff -Naur xbmc-10.1/guilib/GUIBaseContainer.cpp xbmc-10.1a/guilib/GUIBaseContainer.cpp
--- xbmc-10.1/guilib/GUIBaseContainer.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/guilib/GUIBaseContainer.cpp	2011-10-08 07:57:40.298976381 +0200
@@ -810,8 +810,8 @@
     CGUIListItemPtr item = m_items[i];
     // The letter offset jumping is only for ASCII characters at present, and
     // our checks are all done in uppercase
-    CStdString nextLetter = item->GetSortLabel().Left(1);
-    nextLetter.ToUpper();
+    CStdString nextLetter;
+    g_charsetConverter.wToUTF8(item->GetSortLabel().Left(1).ToUpper(), nextLetter);
     if (currentMatch != nextLetter)
     {
       currentMatch = nextLetter;
diff -Naur xbmc-10.1/guilib/GUIListItem.cpp xbmc-10.1a/guilib/GUIListItem.cpp
--- xbmc-10.1/guilib/GUIListItem.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/guilib/GUIListItem.cpp	2011-10-08 07:57:40.298976381 +0200
@@ -22,6 +22,8 @@
 #include "GUIListItem.h"
 #include "GUIListItemLayout.h"
 #include "utils/Archive.h"
+#include "utils/CharsetConverter.h"
+#include "utils/Variant.h"
 
 CGUIListItem::CGUIListItem(const CGUIListItem& item)
 {
@@ -49,7 +51,7 @@
   m_bIsFolder = false;
   m_strLabel2 = "";
   m_strLabel = strLabel;
-  m_sortLabel = strLabel;
+  SetSortLabel(strLabel);
   m_bSelected = false;
   m_strIcon = "";
   m_strThumbnailImage = "";
@@ -69,7 +71,7 @@
     return;
   m_strLabel = strLabel;
   if (m_sortLabel.IsEmpty())
-    m_sortLabel = strLabel;
+    SetSortLabel(strLabel);
   SetInvalid();
 }
 
@@ -94,11 +96,11 @@
 
 void CGUIListItem::SetSortLabel(const CStdString &label)
 {
-  m_sortLabel = label;
+  g_charsetConverter.utf8ToW(label, m_sortLabel);
   // no need to invalidate - this is never shown in the UI
 }
 
-const CStdString& CGUIListItem::GetSortLabel() const
+const CStdStringW& CGUIListItem::GetSortLabel() const
 {
   return m_sortLabel;
 }
diff -Naur xbmc-10.1/guilib/GUIListItem.h xbmc-10.1a/guilib/GUIListItem.h
--- xbmc-10.1/guilib/GUIListItem.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/guilib/GUIListItem.h	2011-10-08 07:57:40.298976381 +0200
@@ -79,7 +79,7 @@
   CStdString GetOverlayImage() const;
 
   void SetSortLabel(const CStdString &label);
-  const CStdString &GetSortLabel() const;
+  const CStdStringW &GetSortLabel() const;
 
   void Select(bool bOnOff);
   bool IsSelected() const;
@@ -144,7 +144,7 @@
   typedef std::map<CStdString, CStdString, icompare> PropertyMap;
   PropertyMap m_mapProperties;
 private:
-  CStdString m_sortLabel;     // text for sorting
+  CStdStringW m_sortLabel;    // text for sorting. Need to be UTF16 for proper sorting
   CStdString m_strLabel;      // text of column1
 };
 #endif
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/ALSADirectSound.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/ALSADirectSound.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/ALSADirectSound.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/ALSADirectSound.cpp	2011-10-08 07:57:40.310974243 +0200
@@ -42,6 +42,14 @@
   m_bIsAllocated = false;
 }
 
+CALSADirectSound::CALSADirectSound(bool bAudio2)
+{
+  m_pPlayHandle  = NULL;
+  m_bIsAllocated = false;
+  m_bAudio2 = bAudio2;
+  m_remap.SetAudio2(bAudio2);
+}
+
 bool CALSADirectSound::Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough)
 {
   enum PCMChannels *outLayout;
@@ -88,8 +96,16 @@
   }
 
   bool bAudioOnAllSpeakers(false);
-  g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
-  g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  if (!m_bAudio2)
+  {
+    g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  }
+  else
+  {
+    g_audioContext2.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  }
 
   m_pPlayHandle = NULL;
   m_bPause = false;
@@ -314,7 +330,10 @@
   }
 
   m_pPlayHandle=NULL;
-  g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  if (!m_bAudio2)
+    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  else
+    g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
   return true;
 }
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/ALSADirectSound.h xbmc-10.1a/xbmc/cores/AudioRenderers/ALSADirectSound.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/ALSADirectSound.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/ALSADirectSound.h	2011-10-08 07:57:40.310974243 +0200
@@ -51,6 +51,7 @@
   virtual float GetCacheTime();
   virtual float GetCacheTotal();
   CALSADirectSound();
+  CALSADirectSound(bool bAudio2);
   virtual bool Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic=false, bool bPassthrough = false);
   virtual ~CALSADirectSound();
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/AudioRendererFactory.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/AudioRendererFactory.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/AudioRendererFactory.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/AudioRendererFactory.cpp	2011-10-08 07:57:40.306974528 +0200
@@ -70,45 +70,68 @@
   }                                        \
 }
 
-#define CreateAndReturnOnValidInitialize(rendererClass) \
+#define CreateAndReturnOnValidInitialize(rendererClass, bAudio2) \
 { \
-  audioSink = new rendererClass(); \
+  audioSink = new rendererClass(bAudio2); \
   ReturnOnValidInitialize(#rendererClass); \
 }
 
-#define ReturnNewRenderer(rendererClass) \
+#define ReturnNewRenderer(rendererClass, bAudio2) \
 { \
   renderer = #rendererClass; \
-  return new rendererClass(); \
+  return new rendererClass(bAudio2); \
 }
 
-IAudioRenderer* CAudioRendererFactory::Create(IAudioCallback* pCallback, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough)
+IAudioRenderer* CAudioRendererFactory::Create(IAudioCallback* pCallback, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough, bool bAudio2)
 {
   IAudioRenderer* audioSink = NULL;
   CStdString renderer;
 
   CStdString deviceString, device;
-  if (bPassthrough)
+  if (!bAudio2)
   {
-#if defined(_LINUX) && !defined(__APPLE__)
-    deviceString = g_guiSettings.GetString("audiooutput.passthroughdevice");
-    if (deviceString.Equals("custom"))
-      deviceString = g_guiSettings.GetString("audiooutput.custompassthrough");
-#else
-    // osx/win platforms do not have an "audiooutput.passthroughdevice" setting but can do passthrough
-    deviceString = g_guiSettings.GetString("audiooutput.audiodevice");
-#endif
+    if (bPassthrough)
+    {
+  #if defined(_LINUX) && !defined(__APPLE__)
+      deviceString = g_guiSettings.GetString("audiooutput.passthroughdevice");
+      if (deviceString.Equals("custom"))
+        deviceString = g_guiSettings.GetString("audiooutput.custompassthrough");
+  #else
+      // osx/win platforms do not have an "audiooutput.passthroughdevice" setting but can do passthrough
+      deviceString = g_guiSettings.GetString("audiooutput.audiodevice");
+  #endif
+    }
+    else
+    {
+      deviceString = g_guiSettings.GetString("audiooutput.audiodevice");
+      if (deviceString.Equals("custom"))
+        deviceString = g_guiSettings.GetString("audiooutput.customdevice");
+    }
   }
   else
   {
-    deviceString = g_guiSettings.GetString("audiooutput.audiodevice");
-    if (deviceString.Equals("custom"))
-      deviceString = g_guiSettings.GetString("audiooutput.customdevice");
+    if (bPassthrough)
+    {
+#if defined(_LINUX) && !defined(__APPLE__)
+      deviceString = g_guiSettings.GetString("audiooutput2.passthroughdevice");
+      if (deviceString.Equals("custom"))
+        deviceString = g_guiSettings.GetString("audiooutput2.custompassthrough");
+#else
+      // osx/win platforms do not have an "audiooutput.passthroughdevice" setting but can do passthrough
+      deviceString = g_guiSettings.GetString("audiooutput2.audiodevice");
+#endif
+    }
+    else
+    {
+      deviceString = g_guiSettings.GetString("audiooutput2.audiodevice");
+      if (deviceString.Equals("custom"))
+        deviceString = g_guiSettings.GetString("audiooutput2.customdevice");
+    }
   }
   int iPos = deviceString.Find(":");
   if (iPos > 0)
   {
-    audioSink = CreateFromUri(deviceString.Left(iPos), renderer);
+    audioSink = CreateFromUri(deviceString.Left(iPos), renderer, bAudio2);
     if (audioSink)
     {
       device = deviceString.Right(deviceString.length() - iPos - 1);
@@ -118,12 +141,12 @@
       //If WASAPI failed try DirectSound.
       if(deviceString.Left(iPos).Equals("wasapi"))
       {
-        audioSink = CreateFromUri("directsound", renderer);
+        audioSink = CreateFromUri("directsound", renderer, bAudio2);
         ReturnOnValidInitialize(renderer.c_str());
       }
 #endif
 
-      CreateAndReturnOnValidInitialize(CNullDirectSound);
+      CreateAndReturnOnValidInitialize(CNullDirectSound, bAudio2);
       /* should never get here */
       assert(false);
     }
@@ -134,20 +157,20 @@
 
 /* First pass creation */
 #ifdef HAS_PULSEAUDIO
-  CreateAndReturnOnValidInitialize(CPulseAudioDirectSound);
+  CreateAndReturnOnValidInitialize(CPulseAudioDirectSound, bAudio2);
 #endif
 
 /* incase none in the first pass was able to be created, fall back to os specific */
 #ifdef WIN32
-  CreateAndReturnOnValidInitialize(CWin32DirectSound);
+  CreateAndReturnOnValidInitialize(CWin32DirectSound, bAudio2);
 #endif
 #ifdef __APPLE__
-  CreateAndReturnOnValidInitialize(CCoreAudioRenderer);
+  CreateAndReturnOnValidInitialize(CCoreAudioRenderer, bAudio2);
 #elif defined(_LINUX)
-  CreateAndReturnOnValidInitialize(CALSADirectSound);
+  CreateAndReturnOnValidInitialize(CALSADirectSound, bAudio2);
 #endif
 
-  CreateAndReturnOnValidInitialize(CNullDirectSound);
+  CreateAndReturnOnValidInitialize(CNullDirectSound, bAudio2);
   /* should never get here */
   assert(false);
   return NULL;
@@ -173,30 +196,30 @@
 #endif
 }
 
-IAudioRenderer *CAudioRendererFactory::CreateFromUri(const CStdString &soundsystem, CStdString &renderer)
+IAudioRenderer *CAudioRendererFactory::CreateFromUri(const CStdString &soundsystem, CStdString &renderer, bool bAudio2)
 {
 #ifdef HAS_PULSEAUDIO
   if (soundsystem.Equals("pulse"))
-    ReturnNewRenderer(CPulseAudioDirectSound);
+    ReturnNewRenderer(CPulseAudioDirectSound, bAudio2);
 #endif
 
 #ifdef WIN32
   if (soundsystem.Equals("wasapi"))
-    ReturnNewRenderer(CWin32WASAPI)
+    ReturnNewRenderer(CWin32WASAPI, bAudio2)
   else if (soundsystem.Equals("directsound"))
-    ReturnNewRenderer(CWin32DirectSound);
+    ReturnNewRenderer(CWin32DirectSound, bAudio2);
 #endif
 
 #ifdef __APPLE__
   if (soundsystem.Equals("coreaudio"))
-    ReturnNewRenderer(CCoreAudioRenderer);
+    ReturnNewRenderer(CCoreAudioRenderer, bAudio2);
 #elif defined(_LINUX)
   if (soundsystem.Equals("alsa"))
-    ReturnNewRenderer(CALSADirectSound);
+    ReturnNewRenderer(CALSADirectSound, bAudio2);
 #endif
 
   if (soundsystem.Equals("null"))
-    ReturnNewRenderer(CNullDirectSound);
+    ReturnNewRenderer(CNullDirectSound, bAudio2);
 
   return NULL;
 }
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/AudioRendererFactory.h xbmc-10.1a/xbmc/cores/AudioRenderers/AudioRendererFactory.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/AudioRendererFactory.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/AudioRendererFactory.h	2011-10-08 07:57:40.306974528 +0200
@@ -31,9 +31,9 @@
 class CAudioRendererFactory
 {
 public:
-  static IAudioRenderer *Create(IAudioCallback* pCallback, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough);
+  static IAudioRenderer *Create(IAudioCallback* pCallback, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough, bool bAudio2 = false);
   static void EnumerateAudioSinks(AudioSinkList& vAudioSinks, bool passthrough);
 private:
-  static IAudioRenderer *CreateFromUri(const CStdString &soundsystem, CStdString &renderer);
+  static IAudioRenderer *CreateFromUri(const CStdString &soundsystem, CStdString &renderer, bool bAudio2 = false);
 };
 #endif
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/CoreAudioRenderer.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/CoreAudioRenderer.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/CoreAudioRenderer.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/CoreAudioRenderer.cpp	2011-10-08 07:57:40.310974243 +0200
@@ -344,6 +344,43 @@
   }
 }
 
+CCoreAudioRenderer::CCoreAudioRenderer(bool bAudio2) :
+  m_Pause(false),
+  m_ChunkLen(0),
+  m_MaxCacheLen(0),
+  m_AvgBytesPerSec(0),
+  m_CurrentVolume(0),
+  m_Initialized(false),
+  m_Passthrough(false),
+  m_EnableVolumeControl(true),
+  m_OutputBufferIndex(0),
+  m_pCache(NULL),
+  m_RunoutEvent(kInvalidID),
+  m_DoRunout(0)
+{
+  SInt32 major,  minor;
+  Gestalt(gestaltSystemVersionMajor, &major);
+  Gestalt(gestaltSystemVersionMinor, &minor);
+
+  // By default, kAudioHardwarePropertyRunLoop points at the process's main thread on SnowLeopard,
+  // If your process lacks such a run loop, you can set kAudioHardwarePropertyRunLoop to NULL which
+  // tells the HAL to run it's own thread for notifications (which was the default prior to SnowLeopard).
+  // So tell the HAL to use its own thread for similar behavior under all supported versions of OSX.
+  if (major == 10 && minor >=6)
+  {
+    CFRunLoopRef theRunLoop = NULL;
+    AudioObjectPropertyAddress theAddress = { kAudioHardwarePropertyRunLoop, kAudioObjectPropertyScopeGlobal, kAudioObjectPropertyElementMaster };
+    OSStatus theError = AudioObjectSetPropertyData(kAudioObjectSystemObject, &theAddress, 0, NULL, sizeof(CFRunLoopRef), &theRunLoop);
+    if (theError != noErr)
+    {
+      CLog::Log(LOGERROR, "CoreAudioRenderer::constructor: kAudioHardwarePropertyRunLoop error.");
+    }
+  }
+
+  m_bAudio2 = bAudio2;
+  m_remap.SetAudio2(bAudio2);
+}
+
 CCoreAudioRenderer::~CCoreAudioRenderer()
 {
   Deinitialize();
@@ -363,15 +400,29 @@
   if (m_Initialized) // Have to clean house before we start again. TODO: Should we return failure instead?
     Deinitialize();
 
-  if(bPassthrough)
-    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE_DIGITAL);
+  if (!m_bAudio2)
+  {
+    if(bPassthrough)
+      g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE_DIGITAL);
+    else
+      g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  }
   else
-    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  {
+    if(bPassthrough)
+      g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE_DIGITAL);
+    else
+      g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  }
 
   // TODO: If debugging, output information about all devices/streams
 
   // Attempt to find the configured output device
-  AudioDeviceID outputDevice = CCoreAudioHardware::FindAudioDevice(g_guiSettings.GetString("audiooutput.audiodevice"));
+  AudioDeviceID outputDevice;
+  if (!m_bAudio2)
+    outputDevice = CCoreAudioHardware::FindAudioDevice(g_guiSettings.GetString("audiooutput.audiodevice"));
+  else
+    outputDevice = CCoreAudioHardware::FindAudioDevice(g_guiSettings.GetString("audiooutput2.audiodevice"));
   if (!outputDevice) // Fall back to the default device if no match is found
   {
     CLog::Log(LOGWARNING, "CoreAudioRenderer::Initialize: Unable to locate configured device, falling-back to the system default.");
@@ -505,7 +556,10 @@
   m_DoRunout = 0;
   m_EnableVolumeControl = true;
 
-  g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  if (!m_bAudio2)
+    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  else
+    g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
 
   CLog::Log(LOGINFO, "CoreAudioRenderer::Deinitialize: Renderer has been shut down.");
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/CoreAudioRenderer.h xbmc-10.1a/xbmc/cores/AudioRenderers/CoreAudioRenderer.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/CoreAudioRenderer.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/CoreAudioRenderer.h	2011-10-08 07:57:40.306974528 +0200
@@ -102,6 +102,7 @@
   {
   public:
     CCoreAudioRenderer();
+    CCoreAudioRenderer(bool bAudio2);
     virtual ~CCoreAudioRenderer();
     virtual unsigned int GetChunkLen();
     virtual float GetDelay();
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/IAudioRenderer.h xbmc-10.1a/xbmc/cores/AudioRenderers/IAudioRenderer.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/IAudioRenderer.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/IAudioRenderer.h	2011-10-08 07:57:40.306974528 +0200
@@ -41,7 +41,7 @@
 class IAudioRenderer
 {
 public:
-  IAudioRenderer() {};
+  IAudioRenderer() { m_bAudio2= false; };
   virtual ~IAudioRenderer() {};
   virtual bool Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic=false, bool bPassthrough = false) = 0;
   virtual void UnRegisterAudioCallback() = 0;
@@ -69,6 +69,7 @@
 
 protected:
   CPCMRemap m_remap;
+  bool m_bAudio2;
 
 private:
 };
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/NullDirectSound.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/NullDirectSound.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/NullDirectSound.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/NullDirectSound.cpp	2011-10-08 07:57:40.306974528 +0200
@@ -41,6 +41,11 @@
 CNullDirectSound::CNullDirectSound()
 {
 }
+CNullDirectSound::CNullDirectSound(bool bAudio2)
+{
+  m_bAudio2 = bAudio2;
+  m_remap.SetAudio2(bAudio2);
+}
 bool CNullDirectSound::Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough)
 {
   CLog::Log(LOGERROR,"Creating a Null Audio Renderer, Check your audio settings as this should not happen");
@@ -48,10 +53,21 @@
     iChannels = 2;
 
   bool bAudioOnAllSpeakers(false);
-  g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
-  g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  if (!m_bAudio2)
+  {
+    g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+
+    g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Error, "Failed to initialize audio device", "Check your audiosettings", TOAST_DISPLAY_TIME, false);
+  }
+  else
+  {
+    g_audioContext2.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+
+    g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Error, "Failed to initialize 2nd audio device", "Check your audiosettings", TOAST_DISPLAY_TIME, false);
+  }
 
-  g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Error, "Failed to initialize audio device", "Check your audiosettings", TOAST_DISPLAY_TIME, false);
   m_timePerPacket = 1.0f / (float)(iChannels*(uiBitsPerSample/8) * uiSamplesPerSec);
   m_packetsSent = 0;
   m_paused = 0;
@@ -69,7 +85,10 @@
 //***********************************************************************************************
 bool CNullDirectSound::Deinitialize()
 {
-  g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  if (!m_bAudio2)
+    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  else
+    g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
   return true;
 }
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/NullDirectSound.h xbmc-10.1a/xbmc/cores/AudioRenderers/NullDirectSound.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/NullDirectSound.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/NullDirectSound.h	2011-10-08 07:57:40.306974528 +0200
@@ -41,6 +41,7 @@
   virtual float GetDelay();
   virtual float GetCacheTime();
   CNullDirectSound();
+  CNullDirectSound(bool bAudio2);
   virtual bool Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic=false, bool bPassthrough = false);
   virtual ~CNullDirectSound();
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/PulseAudioDirectSound.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/PulseAudioDirectSound.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/PulseAudioDirectSound.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/PulseAudioDirectSound.cpp	2011-10-08 07:57:40.306974528 +0200
@@ -144,6 +144,12 @@
 {
 }
 
+CPulseAudioDirectSound::CPulseAudioDirectSound(bool bAudio2)
+{
+  m_bAudio2 = bAudio2;
+  m_remap.SetAudio2(bAudio2);
+}
+
 bool CPulseAudioDirectSound::Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels* channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bPassthrough)
 {
   m_remap.Reset();
@@ -165,8 +171,16 @@
   }
 
   bool bAudioOnAllSpeakers(false);
-  g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
-  g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  if (!m_bAudio2)
+  {
+    g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  }
+  else
+  {
+    g_audioContext2.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+  }
 
   m_Context = NULL;
   m_Stream = NULL;
@@ -363,7 +377,10 @@
     m_MainLoop = NULL;
   }
 
-  g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  if (!m_bAudio2)
+    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  else
+    g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
   return true;
 }
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/PulseAudioDirectSound.h xbmc-10.1a/xbmc/cores/AudioRenderers/PulseAudioDirectSound.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/PulseAudioDirectSound.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/PulseAudioDirectSound.h	2011-10-08 07:57:40.306974528 +0200
@@ -47,6 +47,7 @@
   virtual float GetCacheTime();
   virtual float GetCacheTotal();
   CPulseAudioDirectSound();
+  CPulseAudioDirectSound(bool bAudio2);
   virtual bool Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic=false, bool bPassthrough = false);
   virtual ~CPulseAudioDirectSound();
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/Win32DirectSound.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/Win32DirectSound.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/Win32DirectSound.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/Win32DirectSound.cpp	2011-10-08 07:57:40.306974528 +0200
@@ -80,6 +80,20 @@
 {
 }
 
+CWin32DirectSound::CWin32DirectSound(bool bAudio2) :
+  m_Passthrough(false),
+  m_AvgBytesPerSec(0),
+  m_CacheLen(0),
+  m_dwChunkSize(0),
+  m_dwDataChunkSize(0),
+  m_dwBufferLen(0),
+  m_PreCacheSize(0),
+  m_LastCacheCheck(0)
+{
+  m_bAudio2 = bAudio2;
+  m_remap.SetAudio2(bAudio2);
+}
+
 bool CWin32DirectSound::Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels* channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bAudioPassthrough)
 {
   m_uiDataChannels = iChannels;
@@ -99,12 +113,24 @@
   }
 
   bool bAudioOnAllSpeakers(false);
-  g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
-  if(bAudioPassthrough)
-    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE_DIGITAL);
+  if (!m_bAudio2)
+  {
+    g_audioContext.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    if(bAudioPassthrough)
+      g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE_DIGITAL);
+    else
+      g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+    m_pDSound=g_audioContext.GetDirectSoundDevice();
+  }
   else
-    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
-  m_pDSound=g_audioContext.GetDirectSoundDevice();
+  {
+    g_audioContext2.SetupSpeakerConfig(iChannels, bAudioOnAllSpeakers, bIsMusic);
+    if(bAudioPassthrough)
+      g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE_DIGITAL);
+    else
+      g_audioContext2.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+    m_pDSound=g_audioContext2.GetDirectSoundDevice();
+  }
 
   m_bPause = false;
   m_bIsAllocated = false;
@@ -243,7 +269,10 @@
     m_dwChunkSize = 0;
     m_dwBufferLen = 0;
 
-    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+    if (!m_bAudio2)
+      g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+    else
+      g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
   }
   return true;
 }
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/Win32DirectSound.h xbmc-10.1a/xbmc/cores/AudioRenderers/Win32DirectSound.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/Win32DirectSound.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/Win32DirectSound.h	2011-10-08 07:57:40.310974243 +0200
@@ -45,6 +45,7 @@
   virtual float GetCacheTime();
   virtual float GetCacheTotal();
   CWin32DirectSound();
+  CWin32DirectSound(bool bAudio2);
   virtual bool Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels* channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic=false, bool bPassthrough = false);
   virtual ~CWin32DirectSound();
 
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/Win32WASAPI.cpp xbmc-10.1a/xbmc/cores/AudioRenderers/Win32WASAPI.cpp
--- xbmc-10.1/xbmc/cores/AudioRenderers/Win32WASAPI.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/Win32WASAPI.cpp	2011-10-08 07:57:40.310974243 +0200
@@ -85,6 +85,23 @@
   m_pDevice(NULL)
 {
 }
+  
+CWin32WASAPI::CWin32WASAPI(bool bAudio2) :
+  m_bPassthrough(false),
+  m_uiAvgBytesPerSec(0),
+  m_CacheLen(0),
+  m_uiChunkSize(0),
+  m_uiSrcChunkSize(0),
+  m_uiBufferLen(0),
+  m_PreCacheSize(0),
+  m_LastCacheCheck(0),
+  m_pAudioClient(NULL),
+  m_pRenderClient(NULL),
+  m_pDevice(NULL)
+{
+  m_bAudio2 = bAudio2;
+  m_remap.SetAudio2(bAudio2);
+}
 
 bool CWin32WASAPI::Initialize(IAudioCallback* pCallback, const CStdString& device, int iChannels, enum PCMChannels *channelMap, unsigned int uiSamplesPerSec, unsigned int uiBitsPerSample, bool bResample, bool bIsMusic, bool bAudioPassthrough)
 {
@@ -180,7 +197,10 @@
   IMMDeviceCollection* pEnumDevices = NULL;
 
   //Shut down Directsound.
-  g_audioContext.SetActiveDevice(CAudioContext::NONE);
+  if (!m_bAudio2)
+    g_audioContext.SetActiveDevice(CAudioContext::NONE);
+  else
+    g_audioContext2.SetActiveDevice(CAudioContext::NONE);
 
   HRESULT hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pEnumerator);
   EXIT_ON_FAILURE(hr, __FUNCTION__": Could not allocate WASAPI device enumerator. CoCreateInstance error code: %i", hr)
@@ -289,7 +309,10 @@
   SAFE_RELEASE(m_pDevice);
 
   //Restart Directsound
-  g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  if (!m_bAudio2)
+    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  else
+    g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
 
   return false;
 }
@@ -320,7 +343,10 @@
     m_bIsAllocated = false;
 
     //Restart Directsound for the interface sounds.
-    g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+    if (!m_bAudio2)
+      g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+    else
+      g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
   }
   return true;
 }
diff -Naur xbmc-10.1/xbmc/cores/AudioRenderers/Win32WASAPI.h xbmc-10.1a/xbmc/cores/AudioRenderers/Win32WASAPI.h
--- xbmc-10.1/xbmc/cores/AudioRenderers/Win32WASAPI.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/AudioRenderers/Win32WASAPI.h	2011-10-08 07:57:40.310974243 +0200
@@ -40,6 +40,7 @@
 {
 public:
   CWin32WASAPI();
+  CWin32WASAPI(bool bAudio2);
   virtual ~CWin32WASAPI();
   virtual void UnRegisterAudioCallback();
   virtual void RegisterAudioCallback(IAudioCallback* pCallback);
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDAudio.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDAudio.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDAudio.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDAudio.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -70,13 +70,13 @@
   m_pCallback = NULL;
 }
 
-bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec)
+bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec, bool bAudio2/* = false*/)
 {
   CLog::Log(LOGNOTICE, "Creating audio device with codec id: %i, channels: %i, sample rate: %i, %s", codec, audioframe.channels, audioframe.sample_rate, audioframe.passthrough ? "pass-through" : "no pass-through");
 
   // if passthrough isset do something else
   CSingleLock lock (m_critSection);
-  m_pAudioDecoder = CAudioRendererFactory::Create(m_pCallback, audioframe.channels, audioframe.channel_map, audioframe.sample_rate, audioframe.bits_per_sample, false, false, audioframe.passthrough);
+  m_pAudioDecoder = CAudioRendererFactory::Create(m_pCallback, audioframe.channels, audioframe.channel_map, audioframe.sample_rate, audioframe.bits_per_sample, false, false, audioframe.passthrough, bAudio2);
 
   if (!m_pAudioDecoder) return false;
 
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDAudio.h xbmc-10.1a/xbmc/cores/dvdplayer/DVDAudio.h
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDAudio.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDAudio.h	2011-10-08 07:57:40.302974288 +0200
@@ -60,7 +60,7 @@
   void SetDynamicRangeCompression(long drc);
   void Pause();
   void Resume();
-  bool Create(const DVDAudioFrame &audioframe, CodecID codec);
+  bool Create(const DVDAudioFrame &audioframe, CodecID codec, bool bAudio2 = false);
   bool IsValidFormat(const DVDAudioFrame &audioframe);
   void Destroy();
   DWORD AddPackets(const DVDAudioFrame &audioframe);
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2011-10-08 07:57:40.302974288 +0200
@@ -55,7 +55,7 @@
 {
 public:
 
-  CDVDAudioCodec() {}
+  CDVDAudioCodec() { m_bAudio2 = false; }
   virtual ~CDVDAudioCodec() {}
 
   /*
@@ -119,4 +119,10 @@
    * should return amount of data decoded has buffered in preparation for next audio frame
    */
   virtual int GetBufferSize() { return 0; }
+
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; };
+
+protected:
+
+  bool m_bAudio2;
 };
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -176,13 +176,25 @@
 {
   bool bSupportsAC3Out = false;
   bool bSupportsDTSOut = false;
-  int audioMode = g_guiSettings.GetInt("audiooutput.mode");
+  int audioMode;
+  if (!m_bAudio2)
+    audioMode = g_guiSettings.GetInt("audiooutput.mode");
+  else
+    audioMode = g_guiSettings.GetInt("audiooutput2.mode");
 
   // TODO - move this stuff somewhere else
   if (AUDIO_IS_BITSTREAM(audioMode))
   {
-    bSupportsAC3Out = g_guiSettings.GetBool("audiooutput.ac3passthrough");
-    bSupportsDTSOut = g_guiSettings.GetBool("audiooutput.dtspassthrough");
+    if (!m_bAudio2)
+    {
+      bSupportsAC3Out = g_guiSettings.GetBool("audiooutput.ac3passthrough");
+      bSupportsDTSOut = g_guiSettings.GetBool("audiooutput.dtspassthrough");
+    }
+    else
+    {
+      bSupportsAC3Out = g_guiSettings.GetBool("audiooutput2.ac3passthrough");
+      bSupportsDTSOut = g_guiSettings.GetBool("audiooutput2.dtspassthrough");
+    }
   }
 
   //Samplerate cannot be checked here as we don't know it at this point in time.
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -309,6 +309,7 @@
 
   /* create and setup the encoder */
   m_Encoder     = new CDVDAudioEncoderFFmpeg();
+  m_Encoder->SetAudio2(m_bAudio2);
   m_InitEncoder = true;
 
   /* adjust the hints according to the encorders output */
@@ -322,17 +323,33 @@
 
 bool CDVDAudioCodecPassthroughFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  int audioMode = g_guiSettings.GetInt("audiooutput.mode");
+    int audioMode;
+    if (!m_bAudio2)
+      audioMode = g_guiSettings.GetInt("audiooutput.mode");
+    else
+      audioMode = g_guiSettings.GetInt("audiooutput2.mode");
 
   // TODO - move this stuff somewhere else
   if (AUDIO_IS_BITSTREAM(audioMode))
   {
-    m_bSupportsAC3Out = g_guiSettings.GetBool("audiooutput.ac3passthrough");
-    m_bSupportsDTSOut = g_guiSettings.GetBool("audiooutput.dtspassthrough");
-    m_bSupportsAACOut = g_guiSettings.GetBool("audiooutput.passthroughaac");
-    m_bSupportsMP1Out = g_guiSettings.GetBool("audiooutput.passthroughmp1");
-    m_bSupportsMP2Out = g_guiSettings.GetBool("audiooutput.passthroughmp2");
-    m_bSupportsMP3Out = g_guiSettings.GetBool("audiooutput.passthroughmp3");
+    if (!m_bAudio2)
+    {
+      m_bSupportsAC3Out = g_guiSettings.GetBool("audiooutput.ac3passthrough");
+      m_bSupportsDTSOut = g_guiSettings.GetBool("audiooutput.dtspassthrough");
+      m_bSupportsAACOut = g_guiSettings.GetBool("audiooutput.passthroughaac");
+      m_bSupportsMP1Out = g_guiSettings.GetBool("audiooutput.passthroughmp1");
+      m_bSupportsMP2Out = g_guiSettings.GetBool("audiooutput.passthroughmp2");
+      m_bSupportsMP3Out = g_guiSettings.GetBool("audiooutput.passthroughmp3");
+    }
+    else
+    {
+      m_bSupportsAC3Out = g_guiSettings.GetBool("audiooutput2.ac3passthrough");
+      m_bSupportsDTSOut = g_guiSettings.GetBool("audiooutput2.dtspassthrough");
+      m_bSupportsAACOut = g_guiSettings.GetBool("audiooutput2.passthroughaac");
+      m_bSupportsMP1Out = g_guiSettings.GetBool("audiooutput2.passthroughmp1");
+      m_bSupportsMP2Out = g_guiSettings.GetBool("audiooutput2.passthroughmp2");
+      m_bSupportsMP3Out = g_guiSettings.GetBool("audiooutput2.passthroughmp3");
+    }
   }
   else
     return false;
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -91,6 +91,7 @@
   if (m_CodecCtx->channel_layout & CH_TOP_BACK_CENTER      ) m_ChannelMap[index++] = PCM_TOP_BACK_CENTER      ;
   if (m_CodecCtx->channel_layout & CH_TOP_BACK_RIGHT       ) m_ChannelMap[index++] = PCM_TOP_BACK_RIGHT       ;
 
+  m_Remap.SetAudio2(m_bAudio2);
   m_Remap.SetInputFormat (channels, channelMap, bitsPerSample / 8);
   m_Remap.SetOutputFormat(index, m_ChannelMap, true);
 
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/IDVDAudioEncoder.h xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/IDVDAudioEncoder.h
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/IDVDAudioEncoder.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/IDVDAudioEncoder.h	2011-10-08 07:57:40.302974288 +0200
@@ -26,7 +26,7 @@
 class IDVDAudioEncoder
 {
 public:
-  IDVDAudioEncoder() {};
+  IDVDAudioEncoder() {m_bAudio2 = false;};
   virtual ~IDVDAudioEncoder() {};
   virtual bool Initialize(unsigned int channels, enum PCMChannels *channelMap, unsigned int bitsPerSample, unsigned int sampleRate) = 0;
   virtual void Reset() = 0;
@@ -39,5 +39,11 @@
   /* add/get packets to/from the DSP */
   virtual int Encode (uint8_t *data, int size) = 0;
   virtual int GetData(uint8_t **data) = 0;
+
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; };
+
+protected:
+
+  bool m_bAudio2;
 };
 
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -81,11 +81,12 @@
   return NULL;
 }
 
-CDVDAudioCodec* CDVDFactoryCodec::OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hints, CDVDCodecOptions &options )
+CDVDAudioCodec* CDVDFactoryCodec::OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hints, CDVDCodecOptions &options, bool bAudio2 /* = false */ )
 {
   try
   {
     CLog::Log(LOGDEBUG, "FactoryCodec - Audio: %s - Opening", pCodec->GetName());
+    pCodec->SetAudio2(bAudio2);
     if( pCodec->Open( hints, options ) )
     {
       CLog::Log(LOGDEBUG, "FactoryCodec - Audio: %s - Opened", pCodec->GetName());
@@ -234,7 +235,7 @@
   return NULL;
 }
 
-CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool passthrough /* = true */)
+CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool passthrough /* = true */, bool bAudio2 /* = false */)
 {
   CDVDAudioCodec* pCodec = NULL;
   CDVDCodecOptions options;
@@ -242,11 +243,11 @@
   if (passthrough)
   {
 #if (defined(USE_LIBA52_DECODER) || defined(USE_LIBDTS_DECODER)) && !defined(WIN32)
-    pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
+    pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options, bAudio2);
     if( pCodec ) return pCodec;
 #endif
 
-    pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options);
+    pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options, bAudio2);
     if ( pCodec ) return pCodec;
   }
 
@@ -255,7 +256,7 @@
 #ifdef USE_LIBA52_DECODER
   case CODEC_ID_AC3:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecLiba52(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecLiba52(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -263,7 +264,7 @@
 #ifdef USE_LIBDTS_DECODER
   case CODEC_ID_DTS:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecLibDts(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecLibDts(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -271,7 +272,7 @@
   case CODEC_ID_MP2:
   case CODEC_ID_MP3:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecLibMad(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecLibMad(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -279,7 +280,7 @@
   case CODEC_ID_AAC:
   //case CODEC_ID_MPEG4AAC:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecLibFaad(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecLibFaad(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -302,7 +303,7 @@
   case CODEC_ID_PCM_ALAW:
   case CODEC_ID_PCM_MULAW:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecPcm(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecPcm(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -323,7 +324,7 @@
     }
   }
 
-  pCodec = OpenCodec( new CDVDAudioCodecFFmpeg(), hint, options );
+  pCodec = OpenCodec( new CDVDAudioCodecFFmpeg(), hint, options, bAudio2 );
   if( pCodec ) return pCodec;
 
   return NULL;
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h	2011-10-08 07:57:40.302974288 +0200
@@ -36,10 +36,10 @@
 {
 public:
   static CDVDVideoCodec* CreateVideoCodec(CDVDStreamInfo &hint );
-  static CDVDAudioCodec* CreateAudioCodec(CDVDStreamInfo &hint, bool passthrough = true );
+  static CDVDAudioCodec* CreateAudioCodec(CDVDStreamInfo &hint, bool passthrough = true, bool bAudio2 = false);
   static CDVDOverlayCodec* CreateOverlayCodec(CDVDStreamInfo &hint );
 
-  static CDVDAudioCodec* OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
+  static CDVDAudioCodec* OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options, bool bAudio2 = false );
   static CDVDVideoCodec* OpenCodec(CDVDVideoCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
   static CDVDOverlayCodec* OpenCodec(CDVDOverlayCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
 };
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2011-10-08 07:57:40.306974528 +0200
@@ -95,3 +95,21 @@
   }
   return pPacket;
 }
+
+DemuxPacket* CDVDDemuxUtils::DuplicateDemuxPacket(DemuxPacket* pPacket)
+{
+  if (NULL ==pPacket || pPacket->iSize <= 0)
+    return NULL;
+  DemuxPacket* pPacketDup = AllocateDemuxPacket( pPacket->iSize );
+  if( pPacketDup )
+  {
+    memcpy(pPacketDup->pData, pPacket->pData, pPacket->iSize);
+    pPacketDup->iSize = pPacket->iSize;
+    pPacketDup->iStreamId = pPacket->iStreamId;
+    pPacketDup->iGroupId = pPacket->iGroupId;
+    pPacketDup->pts = pPacket->pts;
+    pPacketDup->dts = pPacket->dts;
+    pPacketDup->duration = pPacket->duration;
+  }
+  return pPacketDup;
+}
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h xbmc-10.1a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h	2011-10-08 07:57:40.306974528 +0200
@@ -28,5 +28,6 @@
 public:
   static void FreeDemuxPacket(DemuxPacket* pPacket);
   static DemuxPacket* AllocateDemuxPacket(int iDataSize = 0);
+  static DemuxPacket* DuplicateDemuxPacket(DemuxPacket* pPacket);
 };
 
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp xbmc-10.1a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2011-10-08 07:57:40.306974528 +0200
@@ -131,9 +131,14 @@
 , m_messageQueue("audio")
 , m_messageParent(parent)
 , m_dvdAudio((bool&)m_bStop)
+, m_dvdAudio2((bool&)m_bStop)
 {
   m_pClock = pClock;
   m_pAudioCodec = NULL;
+  m_pAudioCodec2 = NULL;
+  m_bAudio2 = false;
+  m_bAudio2Stuck = false;
+  m_bAudio2Pause = false;
   m_audioClock = 0;
   m_droptime = 0;
   m_speed = DVD_PLAYSPEED_NORMAL;
@@ -159,13 +164,17 @@
 
 bool CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints )
 {
+  bool bAudio2 = (g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE) ? false : true;
+
   // should alway's be NULL!!!!, it will probably crash anyway when deleting m_pAudioCodec here.
-  if (m_pAudioCodec)
+  if (m_pAudioCodec || (bAudio2 && m_pAudioCodec2))
   {
     CLog::Log(LOGFATAL, "CDVDPlayerAudio::OpenStream() m_pAudioCodec != NULL");
     return false;
   }
 
+  m_bAudio2 = bAudio2;
+
   /* try to open decoder without probing, we could actually allow us to continue here */
   if( !OpenDecoder(hints) ) return false;
 
@@ -217,9 +226,13 @@
   {
     m_bStop = false;
     m_dvdAudio.Drain();
+    if (m_bAudio2)
+      m_dvdAudio2.Drain();
     m_bStop = true;
   }
   m_dvdAudio.Destroy();
+  if (m_bAudio2)
+    m_dvdAudio2.Destroy();
 
   // uninit queue
   m_messageQueue.End();
@@ -231,6 +244,14 @@
     delete m_pAudioCodec;
     m_pAudioCodec = NULL;
   }
+  if (m_pAudioCodec2)
+  {
+    m_pAudioCodec2->Dispose();
+    delete m_pAudioCodec2;
+    m_pAudioCodec2 = NULL;
+  }
+
+  m_bAudio2 = false;
 
   // flush any remaining pts values
   m_ptsOutput.Flush();
@@ -246,10 +267,17 @@
     m_pAudioCodec->Dispose();
     SAFE_DELETE(m_pAudioCodec);
   }
+  if( m_pAudioCodec2 )
+  {
+    CLog::Log(LOGNOTICE, "Deleting 2nd audio codec");
+    m_pAudioCodec2->Dispose();
+    SAFE_DELETE(m_pAudioCodec2);
+  }
 
   /* store our stream hints */
   m_streaminfo = hints;
   bool passthrough = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode"));
+  bool passthrough2 = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode"));
 
   CLog::Log(LOGNOTICE, "Finding audio codec for: %i", m_streaminfo.codec);
   m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, passthrough);
@@ -260,6 +288,16 @@
     m_streaminfo.Clear();
     return false;
   }
+  if (m_bAudio2)
+  {
+    m_pAudioCodec2 = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, passthrough2, m_bAudio2);
+    if( !m_pAudioCodec2 )
+    {
+      CLog::Log(LOGERROR, "Unsupported 2nd audio codec");
+      m_dvdAudio2.Destroy();
+      m_bAudio2 = false;
+    }
+  }
 
   /* update codec information from what codec gave ut */
   m_streaminfo.channels = m_pAudioCodec->GetChannels();
@@ -269,19 +307,20 @@
 }
 
 // decode one audio frame and returns its uncompressed size
-int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
+int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2, bool bDropPacket)
 {
   int result = 0;
 
   // make sure the sent frame is clean
   memset(&audioframe, 0, sizeof(DVDAudioFrame));
+  memset(&audioframe2, 0, sizeof(DVDAudioFrame));
 
   while (!m_bStop)
   {
     /* NOTE: the audio packet can contain several frames */
     while( !m_bStop && m_decode.size > 0 )
     {
-      if( !m_pAudioCodec )
+      if( !m_pAudioCodec || (m_bAudio2 && !m_pAudioCodec2) )
         return DECODE_FLAG_ERROR;
 
       /* the packet dts refers to the first audioframe that starts in the packet */
@@ -290,6 +329,8 @@
         m_audioClock = dts;
 
       int len = m_pAudioCodec->Decode(m_decode.data, m_decode.size);
+      if (m_bAudio2)
+        m_pAudioCodec2->Decode(m_decode.data, m_decode.size);
       m_audioStats.AddSampleBytes(m_decode.size);
       if (len < 0)
       {
@@ -297,6 +338,8 @@
         CLog::Log(LOGERROR, "CDVDPlayerAudio::DecodeFrame - Decode Error. Skipping audio packet");
         m_decode.Release();
         m_pAudioCodec->Reset();
+        if (m_bAudio2)
+          m_pAudioCodec2->Reset();
         return DECODE_FLAG_ERROR;
       }
 
@@ -306,6 +349,8 @@
         CLog::Log(LOGERROR, "CDVDPlayerAudio:DecodeFrame - Codec tried to consume more data than available. Potential memory corruption");
         m_decode.Release();
         m_pAudioCodec->Reset();
+        if (m_bAudio2)
+          m_pAudioCodec2->Reset();
         assert(0);
       }
 
@@ -322,6 +367,17 @@
       audioframe.sample_rate = m_pAudioCodec->GetSampleRate();
       audioframe.passthrough = m_pAudioCodec->NeedPassthrough();
 
+      if (m_bAudio2)
+      {
+        audioframe2.size = m_pAudioCodec2->GetData(&audioframe2.data);
+        audioframe2.pts = m_audioClock;
+        audioframe2.channel_map = m_pAudioCodec2->GetChannelMap();
+        audioframe2.channels = m_pAudioCodec2->GetChannels(); /* get channels AFTER map so that it can be corrected if bad */
+        audioframe2.bits_per_sample = m_pAudioCodec2->GetBitsPerSample();
+        audioframe2.sample_rate = m_pAudioCodec2->GetSampleRate();
+        audioframe2.passthrough = m_pAudioCodec2->NeedPassthrough();
+      }
+
       if (audioframe.size <= 0)
         continue;
 
@@ -335,6 +391,15 @@
         // increase audioclock to after the packet
         m_audioClock += audioframe.duration;
       }
+      if (m_bAudio2)
+      {
+        n = (audioframe2.channels * audioframe2.bits_per_sample * audioframe2.sample_rate)>>3;
+        if (n > 0)
+        {
+          // safety check, if channels == 0, n will result in 0, and that will result in a nice devide exception
+          audioframe2.duration = ((double)audioframe2.size * DVD_TIME_BASE) / n;
+        }
+      }
 
       if(audioframe.duration > 0)
         m_duration = audioframe.duration;
@@ -415,12 +480,16 @@
     {
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
+      if (m_pAudioCodec2)
+        m_pAudioCodec2->Reset();
       m_decode.Release();
       m_started = false;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
     {
       m_dvdAudio.Flush();
+      if (m_bAudio2)
+        m_dvdAudio2.Flush();
       m_ptsOutput.Flush();
       m_ptsInput.Flush();
       m_resampler.Flush();
@@ -430,6 +499,8 @@
 
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
+      if (m_pAudioCodec2)
+        m_pAudioCodec2->Reset();
 
       m_decode.Release();
     }
@@ -442,6 +513,8 @@
     {
       CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_EOF");
       m_dvdAudio.Finish();
+      if (m_bAudio2)
+        m_dvdAudio2.Finish();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
     {
@@ -465,6 +538,8 @@
       if (m_speed == DVD_PLAYSPEED_NORMAL)
       {
         m_dvdAudio.Resume();
+        if (m_bAudio2)
+          m_dvdAudio2.Resume();
       }
       else
       {
@@ -472,8 +547,14 @@
         m_resampler.Flush();
         m_syncclock = true;
         if (m_speed != DVD_PLAYSPEED_PAUSE)
+        {
           m_dvdAudio.Flush();
+          if (m_bAudio2)
+            m_dvdAudio2.Flush();
+        }
         m_dvdAudio.Pause();
+        if (m_bAudio2)
+          m_dvdAudio2.Pause();
       }
     }
     pMsg->Release();
@@ -503,12 +584,16 @@
   bool packetadded(false);
 
   DVDAudioFrame audioframe;
+  DVDAudioFrame audioframe2;
   m_audioStats.Start();
+  m_audiodiff = 0.0;
+  m_bAudio2Stuck = false;
+  m_bAudio2Pause = false;
 
   while (!m_bStop)
   {
     //Don't let anybody mess with our global variables
-    result = DecodeFrame(audioframe, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0); // blocks if no audio is available, but leaves critical section before doing so
+    result = DecodeFrame(audioframe, audioframe2, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0); // blocks if no audio is available, but leaves critical section before doing so
 
     if( result & DECODE_FLAG_ERROR )
     {
@@ -522,7 +607,11 @@
 
       // Flush as the audio output may keep looping if we don't
       if(m_speed == DVD_PLAYSPEED_NORMAL)
+      {
         m_dvdAudio.Flush();
+        if (m_bAudio2)
+          m_dvdAudio2.Flush();
+      }
 
       continue;
     }
@@ -544,12 +633,34 @@
     packetadded = true;
 
     // we have succesfully decoded an audio frame, setup renderer to match
+    bool bCreate1 = false, bCreate2 = false;
+    double ct1 = 0.0, ct2 = 0.0;
     if (!m_dvdAudio.IsValidFormat(audioframe))
     {
       m_dvdAudio.Destroy();
       if(!m_dvdAudio.Create(audioframe, m_streaminfo.codec))
         CLog::Log(LOGERROR, "%s - failed to create audio renderer", __FUNCTION__);
-      m_messageQueue.SetMaxTimeSize(8.0 - m_dvdAudio.GetCacheTotal());
+      bCreate1 = true;
+    }
+    ct1 = m_dvdAudio.GetCacheTotal();
+    if (m_bAudio2)
+    {
+      if (!m_dvdAudio2.IsValidFormat(audioframe2))
+      {
+        m_dvdAudio2.Destroy();
+        if(!m_dvdAudio2.Create(audioframe2, m_streaminfo.codec, m_bAudio2))
+          CLog::Log(LOGERROR, "%s - failed to create 2nd audio renderer", __FUNCTION__);
+        bCreate2 = true;
+      }
+      ct2 = m_dvdAudio2.GetCacheTotal();
+    }
+    if(m_bAudio2 && (bCreate1 || bCreate2))
+    {
+      m_messageQueue.SetMaxTimeSize(8.0 - std::min(ct1, ct2));
+    }
+    else if(!m_bAudio2 && bCreate1)
+    {
+      m_messageQueue.SetMaxTimeSize(8.0 - ct1);
     }
 
     if( result & DECODE_FLAG_DROP )
@@ -573,10 +684,12 @@
       SetSyncType(audioframe.passthrough);
 
       // add any packets play
-      packetadded = OutputPacket(audioframe);
+      if (m_bAudio2)
+        HandleSyncAudio2(audioframe2);
+      packetadded = OutputPacket(audioframe, audioframe2);
 
       // we are not running until something is cached in output device
-      if(m_stalled && m_dvdAudio.GetCacheTime() > 0.0)
+      if(m_stalled && m_dvdAudio.GetCacheTime() > 0.0 && (!m_bAudio2 || m_dvdAudio2.GetCacheTime() > 0.0))
         m_stalled = false;
     }
 
@@ -712,11 +825,49 @@
   }
 }
 
-bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
+void CDVDPlayerAudio::HandleSyncAudio2(DVDAudioFrame &audioframe2)
+{
+  double dtm1 = m_dvdAudio.GetDelay();
+  double dtm2 = m_dvdAudio2.GetDelay();
+  double ddiff = (dtm1 - dtm2);
+
+  m_audiodiff = ddiff / DVD_TIME_BASE;
+
+  double mt = 50000.0/audioframe2.duration;
+  if (mt < 1.0) mt = 1.0;
+  double thresholdhigh = ((int)mt)*audioframe2.duration;
+  double thresholdlow = audioframe2.duration;
+  if (mt-((int)mt) >= 0.5)
+    thresholdhigh+=audioframe2.duration;
+
+  if (ddiff >= thresholdhigh)
+  {
+    m_dvdAudio2.Pause();
+    m_bAudio2Pause = true;
+  }
+  else if (m_bAudio2Pause && ddiff <= thresholdlow)
+  {
+    m_dvdAudio2.Resume();
+    m_bAudio2Pause = false;
+  }
+
+  if (ddiff <= -thresholdhigh)
+  {
+    m_bAudio2Stuck = true;
+  }
+  else if (m_bAudio2Stuck && ddiff >= -thresholdlow)
+  {
+    m_bAudio2Stuck = false;
+  }
+}
+
+bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2)
 {
   if (m_synctype == SYNC_DISCON)
   {
     m_dvdAudio.AddPackets(audioframe);
+    if (m_bAudio2 && !m_bAudio2Stuck)
+      m_dvdAudio2.AddPackets(audioframe2);
   }
   else if (m_synctype == SYNC_SKIPDUP)
   {
@@ -726,6 +877,8 @@
       if (!m_prevskipped)
       {
         m_dvdAudio.AddPackets(audioframe);
+        if (m_bAudio2 && !m_bAudio2Stuck)
+          m_dvdAudio2.AddPackets(audioframe2);
         m_skipdupcount++;
       }
     }
@@ -733,11 +886,18 @@
     {
       m_dvdAudio.AddPackets(audioframe);
       m_dvdAudio.AddPackets(audioframe);
+      if (m_bAudio2 && !m_bAudio2Stuck)
+      {
+        m_dvdAudio2.AddPackets(audioframe2);
+        m_dvdAudio2.AddPackets(audioframe2);
+      }
       m_skipdupcount--;
     }
     else if (m_skipdupcount == 0)
     {
       m_dvdAudio.AddPackets(audioframe);
+      if (m_bAudio2 && !m_bAudio2Stuck)
+        m_dvdAudio2.AddPackets(audioframe2);
     }
   }
   else if (m_synctype == SYNC_RESAMPLE)
@@ -762,6 +922,8 @@
     while(m_resampler.Retrieve(audioframe, audioframe.pts))
     {
       m_dvdAudio.AddPackets(audioframe);
+      if (m_bAudio2 && !m_bAudio2Stuck)
+        m_dvdAudio2.AddPackets(audioframe2);
       packetadded = true;
     }
     return packetadded;
@@ -812,6 +974,8 @@
   std::ostringstream s;
   s << "aq:"     << setw(2) << min(99,m_messageQueue.GetLevel()) << "%";
   s << ", kB/s:" << fixed << setprecision(2) << (double)GetAudioBitrate() / 1024.0;
+  if (m_bAudio2)
+    s << ", a1/a2:" << fixed << setprecision(3) << m_audiodiff;
   return s.str();
 }
 
@@ -822,5 +986,5 @@
 
 bool CDVDPlayerAudio::IsPassthrough() const
 {
-  return m_pAudioCodec && m_pAudioCodec->NeedPassthrough();
+  return m_pAudioCodec && m_pAudioCodec->NeedPassthrough() && (!m_bAudio2 || (m_pAudioCodec2 && m_pAudioCodec2->NeedPassthrough()));
 }
diff -Naur xbmc-10.1/xbmc/cores/dvdplayer/DVDPlayerAudio.h xbmc-10.1a/xbmc/cores/dvdplayer/DVDPlayerAudio.h
--- xbmc-10.1/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2011-10-08 07:57:40.302974288 +0200
@@ -107,8 +107,8 @@
   bool AcceptsData()                                    { return !m_messageQueue.IsFull(); }
   void SendMessage(CDVDMsg* pMsg, int priority = 0)     { m_messageQueue.Put(pMsg, priority); }
 
-  void SetVolume(long nVolume)                          { m_dvdAudio.SetVolume(nVolume); }
-  void SetDynamicRangeCompression(long drc)             { m_dvdAudio.SetDynamicRangeCompression(drc); }
+  void SetVolume(long nVolume)                          { m_dvdAudio.SetVolume(nVolume); if(m_bAudio2) m_dvdAudio2.SetVolume(nVolume); }
+  void SetDynamicRangeCompression(long drc)             { m_dvdAudio.SetDynamicRangeCompression(drc); if(m_bAudio2) m_dvdAudio2.SetDynamicRangeCompression(drc); }
 
   std::string GetPlayerInfo();
   int GetAudioBitrate();
@@ -131,7 +131,7 @@
   virtual void OnExit();
   virtual void Process();
 
-  int DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket);
+  int DecodeFrame(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2, bool bDropPacket);
 
   // tries to open a decoder for the given data.
   bool OpenDecoder(CDVDStreamInfo &hint, BYTE* buffer = NULL, unsigned int size = 0);
@@ -167,8 +167,10 @@
   } m_decode;
 
   CDVDAudio m_dvdAudio; // audio output device
+  CDVDAudio m_dvdAudio2; // audio output device 2
   CDVDClock* m_pClock; // dvd master clock
   CDVDAudioCodec* m_pAudioCodec; // audio codec
+  CDVDAudioCodec* m_pAudioCodec2; // audio codec 2
   BitstreamStats m_audioStats;
 
   int     m_speed;
@@ -179,7 +181,7 @@
 
   CDVDPlayerResampler m_resampler;
 
-  bool OutputPacket(DVDAudioFrame &audioframe);
+  bool OutputPacket(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2);
 
   //SYNC_DISCON, SYNC_SKIPDUP, SYNC_RESAMPLE
   int    m_synctype;
@@ -193,6 +195,7 @@
 
   void   SetSyncType(bool passthrough);
   void   HandleSyncError(double duration);
+  void   HandleSyncAudio2(DVDAudioFrame &audioframe2);
   double m_errorbuff; //place to store average errors
   int    m_errorcount;//number of errors stored
   bool   m_syncclock;
@@ -201,5 +204,10 @@
   int    m_skipdupcount; //counter for skip/duplicate synctype
   bool   m_prevskipped;
   double m_maxspeedadjust;
+
+  bool   m_bAudio2;
+  bool   m_bAudio2Stuck;
+  bool   m_bAudio2Pause;
+  double m_audiodiff;
 };
 
diff -Naur xbmc-10.1/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp xbmc-10.1a/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp
--- xbmc-10.1/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -254,6 +254,13 @@
     g_audioContext.SetActiveDevice(CAudioContext::NONE);
   }
 
+  int iActiveDevice2 = g_audioContext2.GetActiveDevice();
+  if (iActiveDevice2 != CAudioContext::NONE)
+  {
+    CLog::Log(LOGNOTICE, "%s: Releasing 2nd audio device %d", __FUNCTION__, iActiveDevice2);
+    g_audioContext2.SetActiveDevice(CAudioContext::NONE);
+  }
+
 #if defined(_WIN32)
   if (m_warpcursor)
   {
@@ -371,6 +378,12 @@
     g_audioContext.SetActiveDevice(iActiveDevice);
   }
 
+  if (iActiveDevice2 != CAudioContext::NONE)
+  {
+    CLog::Log(LOGNOTICE, "%s: Reclaiming 2nd audio device %d", __FUNCTION__, iActiveDevice2);
+    g_audioContext2.SetActiveDevice(iActiveDevice2);
+  }
+
   if (!ret || (m_playOneStackItem && g_application.CurrentFileItem().IsStack()))
     m_callback.OnPlayBackStopped();
   else
diff -Naur xbmc-10.1/xbmc/cores/paplayer/PAPlayer.cpp xbmc-10.1a/xbmc/cores/paplayer/PAPlayer.cpp
--- xbmc-10.1/xbmc/cores/paplayer/PAPlayer.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/paplayer/PAPlayer.cpp	2011-10-08 07:57:40.302974288 +0200
@@ -75,8 +75,15 @@
 
     m_pAudioDecoder[i] = NULL;
     m_pcmBuffer[i] = NULL;
+    m_pcmBufLen[i] = 0;
     m_bufferPos[i] = 0;
     m_Chunklen[i]  = PACKET_SIZE;
+
+    m_pAudioDecoder2[i] = NULL;
+    m_pcmBuffer2[i] = NULL;
+    m_pcmBufLen2[i] = 0;
+    m_bufferPos2[i] = 0;
+    m_Chunklen2[i]  = PACKET_SIZE;
   }
 
   m_currentStream = 0;
@@ -118,7 +125,7 @@
 
   m_crossFading = g_guiSettings.GetInt("musicplayer.crossfade");
   //WASAPI doesn't support multiple streams, no crossfading for cdda, cd-reading goes mad and no crossfading for last.fm doesn't like two connections
-  if (file.IsCDDA() || file.IsLastFM() || g_guiSettings.GetString("audiooutput.audiodevice").find("wasapi:") != CStdString::npos) m_crossFading = 0;
+  if (file.IsCDDA() || file.IsLastFM() || g_guiSettings.GetString("audiooutput.audiodevice").find("wasapi:") != CStdString::npos || g_guiSettings.GetString("audiooutput2.audiodevice").find("wasapi:") != CStdString::npos) m_crossFading = 0;
   if (m_crossFading && IsPlaying())
   {
     //do a short crossfade on trackskip
@@ -200,6 +207,7 @@
           (m_currentFile->GetMusicInfoTag()->GetTrackNumber() == file.GetMusicInfoTag()->GetTrackNumber() - 1)
         )
         || g_guiSettings.GetString("audiooutput.audiodevice").find("wasapi:") != CStdString::npos
+        || g_guiSettings.GetString("audiooutput2.audiodevice").find("wasapi:") != CStdString::npos
       )
     )
     {
@@ -297,7 +305,10 @@
   m_nextFile->Reset();
 
   if(bAudioDevice)
+  {
     g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+    g_audioContext2.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+  }
   else
     FlushStreams();
 
@@ -306,15 +317,8 @@
 
 void PAPlayer::FreeStream(int stream)
 {
-  if (m_pAudioDecoder[stream])
-  {
-    DrainStream(stream);
-
-    delete m_pAudioDecoder[stream];
-    free(m_pcmBuffer[stream]);
-  }
-  m_pAudioDecoder[stream] = NULL;
-  m_pcmBuffer[stream] = NULL;
+  FreeStreamRenderer(stream, false);
+  FreeStreamRenderer(stream, true);
 
   if (m_packet[stream][0].packet)
     free(m_packet[stream][0].packet);
@@ -327,41 +331,123 @@
   m_resampler[stream].DeInitialize();
 }
 
-void PAPlayer::DrainStream(int stream)
+void PAPlayer::FreeStreamRenderer(int stream, bool bAudio2)
 {
-  if(m_bStopPlaying || m_pAudioDecoder[1 - stream])
+  if (!bAudio2)
   {
-    m_pAudioDecoder[stream]->Stop();
-    return;
-  }
-
-  DWORD silence = m_pAudioDecoder[stream]->GetChunkLen() - m_bufferPos[stream] % m_pAudioDecoder[stream]->GetChunkLen();
+    if (m_pAudioDecoder[stream])
+    {
+      DrainStream(stream, bAudio2);
 
-  if(silence > 0 && m_bufferPos[stream] > 0)
+      delete m_pAudioDecoder[stream];
+      free(m_pcmBuffer[stream]);
+    }
+    m_pAudioDecoder[stream] = NULL;
+    m_pcmBuffer[stream] = NULL;
+    m_pcmBufLen[stream] = 0;
+  }
+  else
   {
-    CLog::Log(LOGDEBUG, "PAPlayer: Drain - adding %d bytes of silence, real pcmdata size: %d, chunk size: %d", silence, m_bufferPos[stream], m_pAudioDecoder[stream]->GetChunkLen());
-    memset(m_pcmBuffer[stream] + m_bufferPos[stream], 0, silence);
-    m_bufferPos[stream] += silence;
+    if (m_pAudioDecoder2[stream])
+    {
+      DrainStream(stream, bAudio2);
+
+      delete m_pAudioDecoder2[stream];
+      free(m_pcmBuffer2[stream]);
+    }
+    m_pAudioDecoder2[stream] = NULL;
+    m_pcmBuffer2[stream] = NULL;
+    m_pcmBufLen2[stream] = 0;
   }
+}
+
+void PAPlayer::DrainStream(int stream)
+{
+  DrainStream(stream, false);
+  DrainStream(stream, true);
+}
 
-  DWORD added = 0;
-  while(m_bufferPos[stream] - added >= m_pAudioDecoder[stream]->GetChunkLen())
+void PAPlayer::DrainStream(int stream, bool bAudio2)
+{
+  if (!bAudio2)
   {
-    added += m_pAudioDecoder[stream]->AddPackets(m_pcmBuffer[stream] + added, m_bufferPos[stream] - added);
-    Sleep(1);
+    if(m_bStopPlaying || m_pAudioDecoder[1 - stream])
+    {
+      m_pAudioDecoder[stream]->Stop();
+      return;
+    }
+
+    DWORD silence = m_pAudioDecoder[stream]->GetChunkLen() - m_bufferPos[stream] % m_pAudioDecoder[stream]->GetChunkLen();
+
+    if(silence > 0 && m_bufferPos[stream] > 0)
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer: Drain - adding %d bytes of silence, real pcmdata size: %d, chunk size: %d", silence, m_bufferPos[stream], m_pAudioDecoder[stream]->GetChunkLen());
+      memset(m_pcmBuffer[stream] + m_bufferPos[stream], 0, silence);
+      m_bufferPos[stream] += silence;
+    }
+
+    DWORD added = 0;
+    while(m_bufferPos[stream] - added >= m_pAudioDecoder[stream]->GetChunkLen())
+    {
+      added += m_pAudioDecoder[stream]->AddPackets(m_pcmBuffer[stream] + added, m_bufferPos[stream] - added);
+      Sleep(1);
+    }
+    m_bufferPos[stream] = 0;
+
+    m_pAudioDecoder[stream]->WaitCompletion();
   }
-  m_bufferPos[stream] = 0;
+  else
+  {
+    if(m_bStopPlaying || m_pAudioDecoder2[1 - stream])
+    {
+      m_pAudioDecoder2[stream]->Stop();
+      return;
+    }
+
+    DWORD silence = m_pAudioDecoder2[stream]->GetChunkLen() - m_bufferPos2[stream] % m_pAudioDecoder2[stream]->GetChunkLen();
+
+    if(silence > 0 && m_bufferPos2[stream] > 0)
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer: 2nd Audio Drain - adding %d bytes of silence, real pcmdata size: %d, chunk size: %d", silence, m_bufferPos2[stream], m_pAudioDecoder2[stream]->GetChunkLen());
+      memset(m_pcmBuffer2[stream] + m_bufferPos2[stream], 0, silence);
+      m_bufferPos2[stream] += silence;
+    }
+
+    DWORD added = 0;
+    while(m_bufferPos2[stream] - added >= m_pAudioDecoder2[stream]->GetChunkLen())
+    {
+      added += m_pAudioDecoder2[stream]->AddPackets(m_pcmBuffer2[stream] + added, m_bufferPos2[stream] - added);
+      Sleep(1);
+    }
+    m_bufferPos2[stream] = 0;
 
-  m_pAudioDecoder[stream]->WaitCompletion();
+    m_pAudioDecoder2[stream]->WaitCompletion();
+  }
 }
 
 bool PAPlayer::CreateStream(int num, unsigned int channels, unsigned int samplerate, unsigned int bitspersample, CStdString codec)
 {
   unsigned int outputSampleRate = (channels <= 2 && g_advancedSettings.m_musicResample) ? g_advancedSettings.m_musicResample : samplerate;
 
+  bool bCreate2 = true;
+  if (g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE)
+  {
+    if (m_pAudioDecoder2[num] != NULL)
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer: 2nd audio renderer now disabled");
+      FreeStreamRenderer(num, true);
+    }
+	bCreate2 = false;
+  }
+
   if (m_pAudioDecoder[num] != NULL && m_channelCount[num] == channels && m_sampleRate[num] == outputSampleRate /* && m_bitsPerSample[num] == bitspersample */)
   {
     CLog::Log(LOGDEBUG, "PAPlayer: Using existing audio renderer");
+    if( bCreate2 && m_pAudioDecoder2[num] != NULL )
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer: Using existing 2nd audio renderer");
+	  bCreate2 = false;
+    }
   }
   else
   {
@@ -385,17 +471,90 @@
       false                 //bPassthrough
     );
 
-    if (!m_pAudioDecoder[num]) return false;
+    if (m_pAudioDecoder[num] != NULL)
+    {
+      m_pcmBufLen[num] = (m_pAudioDecoder[num]->GetChunkLen() + PACKET_SIZE);
+      m_pcmBuffer[num] = (unsigned char*)malloc(m_pcmBufLen[num]);
+      m_bufferPos[num] = 0;
+      m_latency[num]   = m_pAudioDecoder[num]->GetDelay();
+      m_Chunklen[num]  = std::max(PACKET_SIZE, (int)m_pAudioDecoder[num]->GetChunkLen());
+      m_packet[num][0].packet = (BYTE*)malloc(PACKET_SIZE * PACKET_COUNT);
+      for (int i = 1; i < PACKET_COUNT ; i++)
+       m_packet[num][i].packet = m_packet[num][i - 1].packet + PACKET_SIZE;
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer: Creating new audio renderer failed");
+    }
+  }
 
-    m_pcmBuffer[num] = (unsigned char*)malloc((m_pAudioDecoder[num]->GetChunkLen() + PACKET_SIZE));
-    m_bufferPos[num] = 0;
-    m_latency[num]   = m_pAudioDecoder[num]->GetDelay();
-    m_Chunklen[num]  = std::max(PACKET_SIZE, (int)m_pAudioDecoder[num]->GetChunkLen());
-    m_packet[num][0].packet = (BYTE*)malloc(PACKET_SIZE * PACKET_COUNT);
-    for (int i = 1; i < PACKET_COUNT ; i++)
-      m_packet[num][i].packet = m_packet[num][i - 1].packet + PACKET_SIZE;
+  if (bCreate2)
+  {
+    CLog::Log(LOGDEBUG, "PAPlayer: Creating new 2nd audio renderer");
+
+    /* Open the device */
+    m_pAudioDecoder2[num] = CAudioRendererFactory::Create(
+      NULL                , //pCallback
+      m_channelCount [num], //iChannels
+      m_channelMap   [num], //channelMap
+      m_sampleRate   [num], //uiSamplesPerSec
+      m_bitsPerSample[num], //uiBitsPerSample
+      false               , //bResample
+      true                , //bIsMusic
+      false               , //bPassthrough
+      true                  //2nd renderer
+    );
+
+    if (m_pAudioDecoder2[num] != NULL)
+    {
+      m_pcmBufLen2[num] = (m_pAudioDecoder2[num]->GetChunkLen() + PACKET_SIZE);
+      m_pcmBuffer2[num] = (unsigned char*)malloc(m_pcmBufLen2[num]);
+      m_bufferPos2[num] = 0;
+      m_latency2[num] = m_pAudioDecoder2[num]->GetDelay();
+      m_Chunklen2[num]  = std::max(PACKET_SIZE, (int)m_pAudioDecoder2[num]->GetChunkLen());
+      if (m_packet[num][0].packet == NULL)
+      {
+        m_packet[num][0].packet = (BYTE*)malloc(PACKET_SIZE * PACKET_COUNT);
+        for (int i = 1; i < PACKET_COUNT ; i++)
+          m_packet[num][i].packet = m_packet[num][i - 1].packet + PACKET_SIZE;
+      }
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer: Creating new 2nd audio renderer failed");
+    }
   }
-  
+
+  int maxChunklen = std::max(m_Chunklen[num], m_Chunklen2[num]);
+  unsigned int pcmBufLen = (std::max(PACKET_SIZE, maxChunklen)) * 4 + PACKET_SIZE;
+  if (pcmBufLen > m_pcmBufLen[num])
+  {
+    unsigned char* bufTemp = m_pcmBuffer[num];
+    if (bufTemp)
+    {
+      m_pcmBuffer[num] = (unsigned char*)malloc(pcmBufLen);
+      memcpy (m_pcmBuffer[num], bufTemp, m_pcmBufLen[num]);
+      free(bufTemp);
+      m_pcmBufLen[num] = pcmBufLen;
+    }
+  }
+  if (pcmBufLen > m_pcmBufLen2[num])
+  {
+    unsigned char* bufTemp = m_pcmBuffer2[num];
+    if (bufTemp)
+    {
+      m_pcmBuffer2[num] = (unsigned char*)malloc(pcmBufLen);
+      memcpy (m_pcmBuffer2[num], bufTemp, m_pcmBufLen2[num]);
+      free(bufTemp);
+      m_pcmBufLen2[num] = pcmBufLen;
+    }
+  }
+
+  if (m_pAudioDecoder[num] == NULL && m_pAudioDecoder2[num] == NULL)
+  {
+    return false;
+  }
+
   // set initial volume
   SetStreamVolume(num, g_settings.m_nVolumeLevel);
 
@@ -426,6 +585,12 @@
     if (m_currentlyCrossFading && m_pAudioDecoder[1 - m_currentStream])
       m_pAudioDecoder[1 - m_currentStream]->Pause();
 
+    if (m_pAudioDecoder2[m_currentStream])
+      m_pAudioDecoder2[m_currentStream]->Pause();
+
+    if (m_currentlyCrossFading && m_pAudioDecoder2[1 - m_currentStream])
+      m_pAudioDecoder2[1 - m_currentStream]->Pause();
+
     m_callback.OnPlayBackPaused();
     CLog::Log(LOGDEBUG, "PAPlayer: Playback paused");
   }
@@ -437,6 +602,12 @@
     if (m_currentlyCrossFading && m_pAudioDecoder[1 - m_currentStream])
       m_pAudioDecoder[1 - m_currentStream]->Resume();
 
+    if (m_pAudioDecoder2[m_currentStream])
+      m_pAudioDecoder2[m_currentStream]->Resume();
+
+    if (m_currentlyCrossFading && m_pAudioDecoder2[1 - m_currentStream])
+      m_pAudioDecoder2[1 - m_currentStream]->Resume();
+
     m_callback.OnPlayBackResumed();
     CLog::Log(LOGDEBUG, "PAPlayer: Playback resumed");
   }
@@ -446,6 +617,8 @@
 {
   if (m_pAudioDecoder[m_currentStream])
     m_pAudioDecoder[m_currentStream]->SetCurrentVolume(nVolume);
+  if (m_pAudioDecoder2[m_currentStream])
+    m_pAudioDecoder2[m_currentStream]->SetCurrentVolume(nVolume);
 }
 
 void PAPlayer::SetDynamicRangeCompression(long drc)
@@ -554,7 +727,7 @@
     {
       if (((GetTotalTime64() - GetTime() < m_crossFading * 1000L) || (m_forceFadeToNext)) && !m_currentlyCrossFading)
       { // request the next file from our application
-        if (m_decoder[1 - m_currentDecoder].GetStatus() == STATUS_QUEUED && m_pAudioDecoder[1 - m_currentStream])
+        if (m_decoder[1 - m_currentDecoder].GetStatus() == STATUS_QUEUED && (m_pAudioDecoder[1 - m_currentStream] || m_pAudioDecoder2[1 - m_currentStream]))
         {
           m_currentlyCrossFading = true;
           if (m_forceFadeToNext)
@@ -571,7 +744,8 @@
           m_currentStream = 1 - m_currentStream;
           CLog::Log(LOGDEBUG, "Starting Crossfade - resuming stream %i", m_currentStream);
 
-          m_pAudioDecoder[m_currentStream]->Resume();
+          if (m_pAudioDecoder[m_currentStream]) m_pAudioDecoder[m_currentStream]->Resume();
+          if (m_pAudioDecoder2[m_currentStream]) m_pAudioDecoder2[m_currentStream]->Resume();
 
           m_callback.OnPlayBackStarted();
           m_timeOffset = m_nextFile->m_lStartOffset * 1000 / 75;
@@ -614,7 +788,8 @@
                 CLog::Log(LOGERROR, "PAPlayer: Error creating stream!");
                 return false;
               }
-              m_pAudioDecoder[m_currentStream]->Resume();
+              if (m_pAudioDecoder[m_currentStream]) m_pAudioDecoder[m_currentStream]->Resume();
+              if (m_pAudioDecoder2[m_currentStream]) m_pAudioDecoder2[m_currentStream]->Resume();
             }
             else if (samplerate != samplerate2 || bitspersample != bitspersample2)
             {
@@ -743,10 +918,15 @@
 
       if (retVal == RET_SLEEP && retVal2 == RET_SLEEP)
       {
-        float maximumSleepTime = m_pAudioDecoder[m_currentStream]->GetCacheTime();
-        
+        float maximumSleepTime = 0.0;
+        if (m_pAudioDecoder[m_currentStream])
+          maximumSleepTime = std::min(maximumSleepTime, m_pAudioDecoder[m_currentStream]->GetCacheTime());
         if (m_pAudioDecoder[1 - m_currentStream])
           maximumSleepTime = std::min(maximumSleepTime, m_pAudioDecoder[1 - m_currentStream]->GetCacheTime());
+        if (m_pAudioDecoder2[m_currentStream])
+          maximumSleepTime = std::min(maximumSleepTime, m_pAudioDecoder2[m_currentStream]->GetCacheTime());
+        if (m_pAudioDecoder2[1 - m_currentStream])
+          maximumSleepTime = std::min(maximumSleepTime, m_pAudioDecoder2[1 - m_currentStream]->GetCacheTime());
 
         int sleep = std::max((int)((maximumSleepTime / 2.0f) * 1000.0f), 1);
 
@@ -912,6 +1092,12 @@
       m_pAudioDecoder[stream]->Resume();
       m_bufferPos[stream] = 0;
     }
+    if (m_pAudioDecoder2[stream] && m_packet[stream])
+    {
+      m_pAudioDecoder2[stream]->Stop();
+      m_pAudioDecoder2[stream]->Resume();
+      m_bufferPos2[stream] = 0;
+    }
   }
 }
 
@@ -965,12 +1151,13 @@
 
 void PAPlayer::SetStreamVolume(int stream, long nVolume)
 {
-  m_pAudioDecoder[stream]->SetCurrentVolume(nVolume);
+  if(m_pAudioDecoder[stream] != NULL) m_pAudioDecoder[stream]->SetCurrentVolume(nVolume);
+  if(m_pAudioDecoder2[stream] != NULL) m_pAudioDecoder2[stream]->SetCurrentVolume(nVolume);
 }
 
 bool PAPlayer::AddPacketsToStream(int stream, CAudioDecoder &dec)
 {
-  if (!m_pAudioDecoder[stream] || dec.GetStatus() == STATUS_NO_FILE)
+  if ((!m_pAudioDecoder[stream] && !m_pAudioDecoder2[stream]) || dec.GetStatus() == STATUS_NO_FILE)
     return false;
 
   bool ret = false;
@@ -980,7 +1167,9 @@
     m_resampler[stream].PutFloatData((float *)dec.GetData(amount), amount);
     ret = true;
   }
-  else if (m_Chunklen[stream] > m_pAudioDecoder[stream]->GetSpace())
+  else if (( m_pAudioDecoder[stream] && m_pAudioDecoder2[stream] && m_Chunklen[stream] > m_pAudioDecoder[stream]->GetSpace() && m_Chunklen2[stream] > m_pAudioDecoder2[stream]->GetSpace()) ||
+           ( m_pAudioDecoder[stream] && !m_pAudioDecoder2[stream] && m_Chunklen[stream] > m_pAudioDecoder[stream]->GetSpace()) ||
+           ( !m_pAudioDecoder[stream] && m_pAudioDecoder2[stream] && m_Chunklen2[stream] > m_pAudioDecoder2[stream]->GetSpace()))
   { // resampler probably have data but wait until we can send atleast a packet
     ret = false;
   }
@@ -994,20 +1183,65 @@
     int len = m_packet[stream][0].length;
     StreamCallback(&m_packet[stream][0]);
 
-    memcpy(m_pcmBuffer[stream]+m_bufferPos[stream], pcmPtr, len);
-    m_bufferPos[stream] += len;
-
-    while (m_bufferPos[stream] >= (int)m_pAudioDecoder[stream]->GetChunkLen())
+    if (m_pAudioDecoder[stream])
     {
-      int rtn = m_pAudioDecoder[stream]->AddPackets(m_pcmBuffer[stream], m_bufferPos[stream]);
-      if (rtn == 0) //no pcm data added
+      if ((int)m_pcmBufLen[stream] >= m_bufferPos[stream] + len)
       {
-        Sleep(1);
-        continue;
+        memcpy(m_pcmBuffer[stream]+m_bufferPos[stream], pcmPtr, len);
+        m_bufferPos[stream] += len;
+      }
+      else
+      {
+        CLog::Log(LOGDEBUG, "PAPlayer: Buffer full for audio packet output, dropped.");
+        m_bufferPos[stream] = 0;
+      }
+      int stuckcnt = 0;
+      while (m_bufferPos[stream] >= (int)m_pAudioDecoder[stream]->GetChunkLen())
+      {
+        int rtn = m_pAudioDecoder[stream]->AddPackets(m_pcmBuffer[stream], m_bufferPos[stream]);
+        if( rtn == 0 ) //no pcm data added
+        {
+          Sleep(1);
+          if (stuckcnt++ > 50)
+            break;
+        }
+        else
+        {
+          stuckcnt = 0;
+        }
+        m_bufferPos[stream] -= rtn;
+        memmove(m_pcmBuffer[stream], m_pcmBuffer[stream] + rtn, m_bufferPos[stream]);
+      }
+    }
+    if (m_pAudioDecoder2[stream])
+    {
+      if ((int)m_pcmBufLen2[stream] >= m_bufferPos2[stream] + len)
+      {
+        memcpy(m_pcmBuffer2[stream]+m_bufferPos2[stream], pcmPtr, len);
+        m_bufferPos2[stream] += len;
+      }
+      else
+      {
+        CLog::Log(LOGDEBUG, "PAPlayer: Buffer full for 2nd audio packet output, dropped.");
+        m_bufferPos2[stream] = 0;
+      }
+      int stuckcnt = 0;
+      while (m_bufferPos2[stream] >= (int)m_pAudioDecoder2[stream]->GetChunkLen())
+      {
+        int rtn = m_pAudioDecoder2[stream]->AddPackets(m_pcmBuffer2[stream], m_bufferPos2[stream]);
+        if( rtn == 0 ) //no pcm data added
+        {
+          Sleep(1);
+          if (stuckcnt++ > 50)
+            break;
+        }
+        else
+        {
+          stuckcnt = 0;
+        }
+        m_bufferPos2[stream] -= rtn;
+        memmove(m_pcmBuffer2[stream], m_pcmBuffer2[stream] + rtn, m_bufferPos2[stream]);
       }
-
-      m_bufferPos[stream] -= rtn;
-      memmove(m_pcmBuffer[stream], m_pcmBuffer[stream] + rtn, m_bufferPos[stream]);
     }
 
     // something done
@@ -1101,4 +1335,8 @@
   {
     m_pAudioDecoder[m_currentStream]->WaitCompletion();
   }
+  if (m_pAudioDecoder2[m_currentStream])
+  {
+    m_pAudioDecoder2[m_currentStream]->WaitCompletion();
+  }
 }
diff -Naur xbmc-10.1/xbmc/cores/paplayer/PAPlayer.h xbmc-10.1a/xbmc/cores/paplayer/PAPlayer.h
--- xbmc-10.1/xbmc/cores/paplayer/PAPlayer.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/paplayer/PAPlayer.h	2011-10-08 07:57:40.298976381 +0200
@@ -141,8 +141,10 @@
   bool AddPacketsToStream(int stream, CAudioDecoder &dec);
   bool FindFreePacket(int stream, DWORD *pdwPacket );     // Looks for a free packet
   void FreeStream(int stream);
+  void FreeStreamRenderer(int stream, bool bAudio2);
 #if defined(_LINUX) || defined(_WIN32)
   void DrainStream(int stream);
+  void DrainStream(int stream, bool bAudio2);
 #endif
   bool CreateStream(int stream, unsigned int channels, unsigned int samplerate, unsigned int bitspersample, CStdString codec = "");
   void FlushStreams();
@@ -158,9 +160,17 @@
   IAudioRenderer*   m_pAudioDecoder[2];
   float             m_latency[2];
   unsigned char*    m_pcmBuffer[2];
+  unsigned int      m_pcmBufLen[2];
   int               m_bufferPos[2];
   unsigned int      m_Chunklen[2];
 
+  IAudioRenderer*   m_pAudioDecoder2[2];
+  float             m_latency2[2];
+  unsigned char*    m_pcmBuffer2[2];
+  unsigned int      m_pcmBufLen2[2];
+  int               m_bufferPos2[2];
+  unsigned int      m_Chunklen2[2];
+
   unsigned int     m_SampleRate;
   unsigned int     m_Channels;
   unsigned int     m_BitsPerSample;
diff -Naur xbmc-10.1/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp xbmc-10.1a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
--- xbmc-10.1/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp	2011-10-08 07:57:40.298976381 +0200
@@ -161,7 +161,7 @@
 
     if (bAdd)
     {
-      if( g_guiSettings.GetInt("audiooutput.mode") == AUDIO_ANALOG )
+      if( g_guiSettings.GetInt("audiooutput.mode") == AUDIO_ANALOG && !AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode")) )
       {
         CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: adding PAPlayer (%d)", EPC_PAPLAYER);
         vecCores.push_back(EPC_PAPLAYER);
diff -Naur xbmc-10.1/xbmc/GUISettings.cpp xbmc-10.1a/xbmc/GUISettings.cpp
--- xbmc-10.1/xbmc/GUISettings.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/GUISettings.cpp	2011-10-08 07:57:40.314974142 +0200
@@ -453,6 +453,46 @@
   AddString(ao, "audiooutput.audiodevice", 545, "Default", SPIN_CONTROL_TEXT);
 #endif
 
+#if defined(_LINUX)
+  AddSeparator(ao, "audiooutput.sep2");
+#else
+  AddSeparator(ao, "audiooutput.sep1");
+#endif
+
+	map<int,int> audiomode2;
+	audiomode2.insert(make_pair(13106,AUDIO_NONE));
+	audiomode2.insert(make_pair(338,AUDIO_ANALOG));
+	audiomode2.insert(make_pair(339,AUDIO_IEC958));
+	audiomode2.insert(make_pair(420,AUDIO_HDMI  ));
+	AddInt(ao, "audiooutput2.mode", 337, AUDIO_NONE, audiomode2, SPIN_CONTROL_TEXT);
+  
+	map<int,int> channelLayout2;
+	for(int layout2 = 0; layout2 < PCM_MAX_LAYOUT; ++layout2)
+	  channelLayout2.insert(make_pair(34101+layout2, layout2));
+	AddInt(ao, "audiooutput2.channellayout", 34100, PCM_LAYOUT_2_0, channelLayout2, SPIN_CONTROL_TEXT);
+	AddBool(ao, "audiooutput2.dontnormalizelevels", 346, true);
+  
+	AddBool(ao, "audiooutput2.ac3passthrough", 364, true);
+	AddBool(ao, "audiooutput2.dtspassthrough", 254, true);
+	AddBool(NULL, "audiooutput2.passthroughaac", 299, false);
+	AddBool(NULL, "audiooutput2.passthroughmp1", 300, false);
+	AddBool(NULL, "audiooutput2.passthroughmp2", 301, false);
+	AddBool(NULL, "audiooutput2.passthroughmp3", 302, false);
+  
+#ifdef __APPLE__
+	AddString(ao, "audiooutput2.audiodevice", 545, "Default", SPIN_CONTROL_TEXT);
+#elif defined(_LINUX)
+	AddSeparator(ao, "audiooutput2.sep3");
+	AddString(ao, "audiooutput2.audiodevice", 545, "default", SPIN_CONTROL_TEXT);
+	AddString(ao, "audiooutput2.customdevice", 1300, "", EDIT_CONTROL_INPUT);
+	AddSeparator(ao, "audiooutput2.sep4");
+	AddString(ao, "audiooutput2.passthroughdevice", 546, "iec958", SPIN_CONTROL_TEXT);
+	AddString(ao, "audiooutput2.custompassthrough", 1301, "", EDIT_CONTROL_INPUT);
+	AddSeparator(ao, "audiooutput2.sep5");
+#elif defined(_WIN32)
+	AddString(ao, "audiooutput2.audiodevice", 545, "Default", SPIN_CONTROL_TEXT);
+#endif
+
   CSettingsCategory* in = AddCategory(4, "input", 14094);
 #ifdef __APPLE__
   map<int,int> remotemode;
diff -Naur xbmc-10.1/xbmc/GUISettings.h xbmc-10.1a/xbmc/GUISettings.h
--- xbmc-10.1/xbmc/GUISettings.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/GUISettings.h	2011-10-08 07:57:40.314974142 +0200
@@ -79,6 +79,7 @@
 #define CDDARIP_QUALITY_STANDARD 2
 #define CDDARIP_QUALITY_EXTREME  3
 
+#define AUDIO_NONE        0xF
 #define AUDIO_ANALOG      0
 #define AUDIO_IEC958      1
 #define AUDIO_HDMI        2
diff -Naur xbmc-10.1/xbmc/GUIWindowSettingsCategory.cpp xbmc-10.1a/xbmc/GUIWindowSettingsCategory.cpp
--- xbmc-10.1/xbmc/GUIWindowSettingsCategory.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/GUIWindowSettingsCategory.cpp	2011-10-08 07:57:40.318974037 +0200
@@ -583,6 +583,14 @@
     {
       FillInAudioDevices(pSetting,true);
     }
+    else if (strSetting.Equals("audiooutput2.audiodevice"))
+    {
+      FillInAudioDevices(pSetting,false,true);
+    }
+    else if (strSetting.Equals("audiooutput2.passthroughdevice"))
+    {
+      FillInAudioDevices(pSetting,true,true);
+    }
     else if (strSetting.Equals("videoplayer.synctype"))
     {
       CSettingInt *pSettingInt = (CSettingInt*)pSetting;
@@ -796,6 +804,26 @@
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
       if (pControl) pControl->SetEnabled(AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode")));
     }
+    else if (
+             strSetting.Equals("audiooutput2.channellayout") ||
+             strSetting.Equals("audiooutput2.dontnormalizelevels") ||
+             strSetting.Equals("audiooutput2.audiodevice"))
+    { // only visible if audioouput2 is used
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiooutput2.mode") != AUDIO_NONE);
+    }
+    else if (
+             strSetting.Equals("audiooutput2.passthroughdevice") ||
+             strSetting.Equals("audiooutput2.ac3passthrough") ||
+             strSetting.Equals("audiooutput2.dtspassthrough") ||
+             strSetting.Equals("audiooutput2.passthroughaac") ||
+             strSetting.Equals("audiooutput2.passthroughmp1") ||
+             strSetting.Equals("audiooutput2.passthroughmp2") ||
+             strSetting.Equals("audiooutput2.passthroughmp3"))
+    { // only visible if we are in digital mode
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode")));
+    }
     else if (strSetting.Equals("musicplayer.crossfade"))
     {
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
@@ -1023,6 +1051,23 @@
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
       if (pControl) pControl->SetEnabled(g_guiSettings.GetString("audiooutput.audiodevice").Equals("custom"));
     }
+    else if (strSetting.Equals("audiooutput2.custompassthrough"))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode")))
+      {
+        if (pControl) pControl->SetEnabled(g_guiSettings.GetString("audiooutput2.passthroughdevice").Equals("custom"));
+      }
+      else
+      {
+        if (pControl) pControl->SetEnabled(false);
+      }
+    }
+    else if (strSetting.Equals("audiooutput2.customdevice"))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiooutput2.mode") != AUDIO_NONE && g_guiSettings.GetString("audiooutput2.audiodevice").Equals("custom"));
+    }
 #endif
   }
 }
@@ -1294,6 +1339,26 @@
 #endif
   }
 #endif
+  else if (strSetting.Equals("audiooutput2.audiodevice"))
+  {
+      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+#if !defined(__APPLE__)
+      g_guiSettings.SetString("audiooutput2.audiodevice", m_AnalogAudioSinkMap[pControl->GetCurrentLabel()]);
+#else
+      g_guiSettings.SetString("audiooutput2.audiodevice", pControl->GetCurrentLabel());
+#endif
+  }
+#if defined(_LINUX)
+  else if (strSetting.Equals("audiooutput2.passthroughdevice"))
+  {
+    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+#if defined(_LINUX) && !defined(__APPLE__)
+      g_guiSettings.SetString("audiooutput2.passthroughdevice", m_DigitalAudioSinkMap[pControl->GetCurrentLabel()]);
+#else
+      g_guiSettings.SetString("audiooutput2.passthroughdevice", pControl->GetCurrentLabel());
+#endif
+  }
+#endif
 #ifdef HAS_LCD
   else if (strSetting.Equals("videoscreen.haslcd"))
   {
@@ -2776,7 +2841,7 @@
   }
 }
 
-void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Passthrough)
+void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Passthrough, bool bAudio2)
 {
 #ifdef __APPLE__
   if (Passthrough)
@@ -2797,8 +2862,16 @@
     CCoreAudioDevice device(deviceList.front());
     pControl->AddLabel(device.GetName(deviceName), i);
 
-    if (g_guiSettings.GetString("audiooutput.audiodevice").Equals(deviceName))
-      activeDevice = i; // Tag this one
+    if(!bAudio2)
+    {
+      if (g_guiSettings.GetString("audiooutput.audiodevice").Equals(deviceName))
+        activeDevice = i; // Tag this one
+	}
+    else
+    {
+      if (g_guiSettings.GetString("audiooutput2.audiodevice").Equals(deviceName))
+        activeDevice = i; // Tag this one
+    }
 
     deviceList.pop_front();
   }
@@ -2807,7 +2880,15 @@
   CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
   pControl->Clear();
 
-  CStdString currentDevice = Passthrough ? g_guiSettings.GetString("audiooutput.passthroughdevice") : g_guiSettings.GetString("audiooutput.audiodevice");
+  CStdString currentDevice;
+  if(!bAudio2)
+  {
+    currentDevice = Passthrough ? g_guiSettings.GetString("audiooutput.passthroughdevice") : g_guiSettings.GetString("audiooutput.audiodevice");
+  }
+  else
+  {
+    currentDevice = Passthrough ? g_guiSettings.GetString("audiooutput2.passthroughdevice") : g_guiSettings.GetString("audiooutput2.audiodevice");
+  }
 
   if (Passthrough)
   {
diff -Naur xbmc-10.1/xbmc/GUIWindowSettingsCategory.h xbmc-10.1a/xbmc/GUIWindowSettingsCategory.h
--- xbmc-10.1/xbmc/GUIWindowSettingsCategory.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/GUIWindowSettingsCategory.h	2011-10-08 07:57:40.322974412 +0200
@@ -63,7 +63,7 @@
   void FillInNetworkInterfaces(CSetting *pSetting);
   void NetworkInterfaceChanged(void);
 
-  void FillInAudioDevices(CSetting* pSetting, bool Passthrough = false);
+  void FillInAudioDevices(CSetting* pSetting, bool Passthrough = false, bool bAudio2 = false);
 
   virtual void SetupControls();
   void CreateSettings();
diff -Naur xbmc-10.1/xbmc/LangCodeExpander.cpp xbmc-10.1a/xbmc/LangCodeExpander.cpp
--- xbmc-10.1/xbmc/LangCodeExpander.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/LangCodeExpander.cpp	2011-10-08 07:57:40.298976381 +0200
@@ -22,8 +22,13 @@
 #include "LangCodeExpander.h"
 #include "SectionLoader.h"
 #include "tinyXML/tinyxml.h"
+#include "utils/log.h" 
+
+#define MAKECODE(a, b, c, d)  ((((long)(a))<<24) | (((long)(b))<<16) | (((long)(c))<<8) | (long)(d))
+#define MAKETWOCHARCODE(a, b) ((((long)(a))<<8) | (long)(b)) 
+
+CLangCodeExpander  g_LangCodeExpander;
 
-#define MAKECODE(a, b, c, d) ((((long)(a))<<24) | (((long)(b))<<16) | (((long)(c))<<8) | (long)(d))
 typedef struct LCENTRY
 {
   long code;
@@ -33,8 +38,22 @@
 extern const struct LCENTRY g_iso639_1[143];
 extern const struct LCENTRY g_iso639_2[536];
 
+struct CharCodeConvertionWithHack
+{
+  const char* old;
+  const char* id;
+  const char* win_id;
+};
 
-CLangCodeExpander g_LangCodeExpander;
+struct CharCodeConvertion
+{
+  const char* old;
+  const char* id;
+};
+
+// declared as extern to allow forward declaration
+extern const CharCodeConvertionWithHack CharCode2To3[184];
+extern const CharCodeConvertion RegionCode2To3[246];
 
 CLangCodeExpander::CLangCodeExpander(void)
 {}
@@ -125,6 +144,61 @@
   return Lookup(desc, lang);
 }
 
+#ifdef _WIN32
+bool CLangCodeExpander::ConvertTwoToThreeCharCode(CStdString& strThreeCharCode, const CStdString& strTwoCharCode, bool localeHack /*= false*/)
+#else
+bool CLangCodeExpander::ConvertTwoToThreeCharCode(CStdString& strThreeCharCode, const CStdString& strTwoCharCode)
+#endif
+{       
+  if ( strTwoCharCode.length() == 2 )
+  {
+    CStdString strTwoCharCodeLower( strTwoCharCode );
+    strTwoCharCodeLower.MakeLower();
+    strTwoCharCodeLower.TrimLeft();
+    strTwoCharCodeLower.TrimRight();
+
+    for (unsigned int index = 0; index < sizeof(CharCode2To3) / sizeof(CharCode2To3[0]); ++index)
+    {
+      if (strTwoCharCodeLower.Equals(CharCode2To3[index].old))
+      {
+#ifdef _WIN32
+        if (localeHack && CharCode2To3[index].win_id)
+        {
+          strThreeCharCode = CharCode2To3[index].win_id;
+          return true;
+        }
+#endif
+        strThreeCharCode = CharCode2To3[index].id;
+        return true;
+      }
+    }
+  }
+
+  // not a 2 char code
+  return false;
+}
+
+bool CLangCodeExpander::ConvertLinuxToWindowsRegionCodes(const CStdString& strTwoCharCode, CStdString& strThreeCharCode)
+{
+  if (strTwoCharCode.length() != 2)
+    return false;
+
+  CStdString strLower( strTwoCharCode );
+  strLower.MakeLower();
+  strLower.TrimLeft();
+  strLower.TrimRight();
+  for (unsigned int index = 0; index < sizeof(RegionCode2To3) / sizeof(RegionCode2To3[0]); ++index)
+  {
+    if (strLower.Equals(RegionCode2To3[index].old))
+    {
+      strThreeCharCode = RegionCode2To3[index].id;
+      return true;
+    }
+  }
+
+  return true;
+}
+
 bool CLangCodeExpander::LookupInMap(CStdString& desc, const CStdString& code)
 {
   STRINGLOOKUPTABLE::iterator it;
@@ -869,3 +943,442 @@
   { MAKECODE('\0','z','u','l'), "Zulu" },
   { MAKECODE('\0','z','u','n'), "Zuni" },
 };
+
+const CharCodeConvertionWithHack CharCode2To3[184] =
+{
+  { "aa", "aar", NULL },
+  { "ab", "abk", NULL },
+  { "af", "afr", NULL },
+  { "ak", "aka", NULL },
+  { "am", "amh", NULL },
+  { "ar", "ara", NULL },
+  { "an", "arg", NULL },
+  { "as", "asm", NULL },
+  { "av", "ava", NULL },
+  { "ae", "ave", NULL },
+  { "ay", "aym", NULL },
+  { "az", "aze", NULL },
+  { "ba", "bak", NULL },
+  { "bm", "bam", NULL },
+  { "be", "bel", NULL },
+  { "bn", "ben", NULL },
+  { "bh", "bih", NULL },
+  { "bi", "bis", NULL },
+  { "bo", "tib", NULL },
+  { "bs", "bos", NULL },
+  { "br", "bre", NULL },
+  { "bg", "bul", NULL },
+  { "ca", "cat", NULL },
+  { "cs", "cze", "csy" },
+  { "ch", "cha", NULL },
+  { "ce", "che", NULL },
+  { "cu", "chu", NULL },
+  { "cv", "chv", NULL },
+  { "kw", "cor", NULL },
+  { "co", "cos", NULL },
+  { "cr", "cre", NULL },
+  { "cy", "wel", NULL },
+  { "da", "dan", NULL },
+  { "de", "ger", "deu" },
+  { "dv", "div", NULL },
+  { "dz", "dzo", NULL },
+  { "el", "gre", "ell" },
+  { "en", "eng", NULL },
+  { "eo", "epo", NULL },
+  { "et", "est", NULL },
+  { "eu", "baq", NULL },
+  { "ee", "ewe", NULL },
+  { "fo", "fao", NULL },
+  { "fa", "per", NULL },
+  { "fj", "fij", NULL },
+  { "fi", "fin", NULL },
+  { "fr", "fre", "fra" },
+  { "fy", "fry", NULL },
+  { "ff", "ful", NULL },
+  { "gd", "gla", NULL },
+  { "ga", "gle", NULL },
+  { "gl", "glg", NULL },
+  { "gv", "glv", NULL },
+  { "gn", "grn", NULL },
+  { "gu", "guj", NULL },
+  { "ht", "hat", NULL },
+  { "ha", "hau", NULL },
+  { "he", "heb", NULL },
+  { "hz", "her", NULL },
+  { "hi", "hin", NULL },
+  { "ho", "hmo", NULL },
+  { "hr", "hrv", NULL },
+  { "hu", "hun", NULL },
+  { "hy", "arm", NULL },
+  { "ig", "ibo", NULL },
+  { "io", "ido", NULL },
+  { "ii", "iii", NULL },
+  { "iu", "iku", NULL },
+  { "ie", "ile", NULL },
+  { "ia", "ina", NULL },
+  { "id", "ind", NULL },
+  { "ik", "ipk", NULL },
+  { "is", "ice", "isl" },
+  { "it", "ita", NULL },
+  { "jv", "jav", NULL },
+  { "ja", "jpn", NULL },
+  { "kl", "kal", NULL },
+  { "kn", "kan", NULL },
+  { "ks", "kas", NULL },
+  { "ka", "geo", NULL },
+  { "kr", "kau", NULL },
+  { "kk", "kaz", NULL },
+  { "km", "khm", NULL },
+  { "ki", "kik", NULL },
+  { "rw", "kin", NULL },
+  { "ky", "kir", NULL },
+  { "kv", "kom", NULL },
+  { "kg", "kon", NULL },
+  { "ko", "kor", NULL },
+  { "kj", "kua", NULL },
+  { "ku", "kur", NULL },
+  { "lo", "lao", NULL },
+  { "la", "lat", NULL },
+  { "lv", "lav", NULL },
+  { "li", "lim", NULL },
+  { "ln", "lin", NULL },
+  { "lt", "lit", NULL },
+  { "lb", "ltz", NULL },
+  { "lu", "lub", NULL },
+  { "lg", "lug", NULL },
+  { "mk", "mac", NULL },
+  { "mh", "mah", NULL },
+  { "ml", "mal", NULL },
+  { "mi", "mao", NULL },
+  { "mr", "mar", NULL },
+  { "ms", "may", NULL },
+  { "mg", "mlg", NULL },
+  { "mt", "mlt", NULL },
+  { "mn", "mon", NULL },
+  { "my", "bur", NULL },
+  { "na", "nau", NULL },
+  { "nv", "nav", NULL },
+  { "nr", "nbl", NULL },
+  { "nd", "nde", NULL },
+  { "ng", "ndo", NULL },
+  { "ne", "nep", NULL },
+  { "nl", "dut", "nld" },
+  { "nn", "nno", NULL },
+  { "nb", "nob", NULL },
+  { "no", "nor", NULL },
+  { "ny", "nya", NULL },
+  { "oc", "oci", NULL },
+  { "oj", "oji", NULL },
+  { "or", "ori", NULL },
+  { "om", "orm", NULL },
+  { "os", "oss", NULL },
+  { "pa", "pan", NULL },
+  { "pi", "pli", NULL },
+  { "pl", "pol", "plk" },
+  { "pt", "por", "ptg" },
+  { "ps", "pus", NULL },
+  { "qu", "que", NULL },
+  { "rm", "roh", NULL },
+  { "ro", "rum", "ron" },
+  { "rn", "run", NULL },
+  { "ru", "rus", NULL },
+  { "sg", "sag", NULL },
+  { "sa", "san", NULL },
+  { "si", "sin", NULL },
+  { "sk", "slo", "sky" },
+  { "sl", "slv", NULL },
+  { "se", "sme", NULL },
+  { "sm", "smo", NULL },
+  { "sn", "sna", NULL },
+  { "sd", "snd", NULL },
+  { "so", "som", NULL },
+  { "st", "sot", NULL },
+  { "es", "spa", "esp" },
+  { "sq", "alb", NULL },
+  { "sc", "srd", NULL },
+  { "sr", "srp", NULL },
+  { "ss", "ssw", NULL },
+  { "su", "sun", NULL },
+  { "sw", "swa", NULL },
+  { "sv", "swe", "sve" },
+  { "ty", "tah", NULL },
+  { "ta", "tam", NULL },
+  { "tt", "tat", NULL },
+  { "te", "tel", NULL },
+  { "tg", "tgk", NULL },
+  { "tl", "tgl", NULL },
+  { "th", "tha", NULL },
+  { "ti", "tir", NULL },
+  { "to", "ton", NULL },
+  { "tn", "tsn", NULL },
+  { "ts", "tso", NULL },
+  { "tk", "tuk", NULL },
+  { "tr", "tur", "trk" },
+  { "tw", "twi", NULL },
+  { "ug", "uig", NULL },
+  { "uk", "ukr", NULL },
+  { "ur", "urd", NULL },
+  { "uz", "uzb", NULL },
+  { "ve", "ven", NULL },
+  { "vi", "vie", NULL },
+  { "vo", "vol", NULL },
+  { "wa", "wln", NULL },
+  { "wo", "wol", NULL },
+  { "xh", "xho", NULL },
+  { "yi", "yid", NULL },
+  { "yo", "yor", NULL },
+  { "za", "zha", NULL },
+  { "zh", "chi", NULL },
+  { "zu", "zul", NULL }
+};
+
+// Based on ISO 3166
+const CharCodeConvertion RegionCode2To3[246] =
+{
+  { "af", "afg" },
+  { "ax", "ala" },
+  { "al", "alb" },
+  { "dz", "dza" },
+  { "as", "asm" },
+  { "ad", "and" },
+  { "ao", "ago" },
+  { "ai", "aia" },
+  { "aq", "ata" },
+  { "ag", "atg" },
+  { "ar", "arg" },
+  { "am", "arm" },
+  { "aw", "abw" },
+  { "au", "aus" },
+  { "at", "aut" },
+  { "az", "aze" },
+  { "bs", "bhs" },
+  { "bh", "bhr" },
+  { "bd", "bgd" },
+  { "bb", "brb" },
+  { "by", "blr" },
+  { "be", "bel" },
+  { "bz", "blz" },
+  { "bj", "ben" },
+  { "bm", "bmu" },
+  { "bt", "btn" },
+  { "bo", "bol" },
+  { "ba", "bih" },
+  { "bw", "bwa" },
+  { "bv", "bvt" },
+  { "br", "bra" },
+  { "io", "iot" },
+  { "bn", "brn" },
+  { "bg", "bgr" },
+  { "bf", "bfa" },
+  { "bi", "bdi" },
+  { "kh", "khm" },
+  { "cm", "cmr" },
+  { "ca", "can" },
+  { "cv", "cpv" },
+  { "ky", "cym" },
+  { "cf", "caf" },
+  { "td", "tcd" },
+  { "cl", "chl" },
+  { "cn", "chn" },
+  { "cx", "cxr" },
+  { "cc", "cck" },
+  { "co", "col" },
+  { "km", "com" },
+  { "cg", "cog" },
+  { "cd", "cod" },
+  { "ck", "cok" },
+  { "cr", "cri" },
+  { "ci", "civ" },
+  { "hr", "hrv" },
+  { "cu", "cub" },
+  { "cy", "cyp" },
+  { "cz", "cze" },
+  { "dk", "dnk" },
+  { "dj", "dji" },
+  { "dm", "dma" },
+  { "do", "dom" },
+  { "ec", "ecu" },
+  { "eg", "egy" },
+  { "sv", "slv" },
+  { "gq", "gnq" },
+  { "er", "eri" },
+  { "ee", "est" },
+  { "et", "eth" },
+  { "fk", "flk" },
+  { "fo", "fro" },
+  { "fj", "fji" },
+  { "fi", "fin" },
+  { "fr", "fra" },
+  { "gf", "guf" },
+  { "pf", "pyf" },
+  { "tf", "atf" },
+  { "ga", "gab" },
+  { "gm", "gmb" },
+  { "ge", "geo" },
+  { "de", "deu" },
+  { "gh", "gha" },
+  { "gi", "gib" },
+  { "gr", "grc" },
+  { "gl", "grl" },
+  { "gd", "grd" },
+  { "gp", "glp" },
+  { "gu", "gum" },
+  { "gt", "gtm" },
+  { "gg", "ggy" },
+  { "gn", "gin" },
+  { "gw", "gnb" },
+  { "gy", "guy" },
+  { "ht", "hti" },
+  { "hm", "hmd" },
+  { "va", "vat" },
+  { "hn", "hnd" },
+  { "hk", "hkg" },
+  { "hu", "hun" },
+  { "is", "isl" },
+  { "in", "ind" },
+  { "id", "idn" },
+  { "ir", "irn" },
+  { "iq", "irq" },
+  { "ie", "irl" },
+  { "im", "imn" },
+  { "il", "isr" },
+  { "it", "ita" },
+  { "jm", "jam" },
+  { "jp", "jpn" },
+  { "je", "jey" },
+  { "jo", "jor" },
+  { "kz", "kaz" },
+  { "ke", "ken" },
+  { "ki", "kir" },
+  { "kp", "prk" },
+  { "kr", "kor" },
+  { "kw", "kwt" },
+  { "kg", "kgz" },
+  { "la", "lao" },
+  { "lv", "lva" },
+  { "lb", "lbn" },
+  { "ls", "lso" },
+  { "lr", "lbr" },
+  { "ly", "lby" },
+  { "li", "lie" },
+  { "lt", "ltu" },
+  { "lu", "lux" },
+  { "mo", "mac" },
+  { "mk", "mkd" },
+  { "mg", "mdg" },
+  { "mw", "mwi" },
+  { "my", "mys" },
+  { "mv", "mdv" },
+  { "ml", "mli" },
+  { "mt", "mlt" },
+  { "mh", "mhl" },
+  { "mq", "mtq" },
+  { "mr", "mrt" },
+  { "mu", "mus" },
+  { "yt", "myt" },
+  { "mx", "mex" },
+  { "fm", "fsm" },
+  { "md", "mda" },
+  { "mc", "mco" },
+  { "mn", "mng" },
+  { "me", "mne" },
+  { "ms", "msr" },
+  { "ma", "mar" },
+  { "mz", "moz" },
+  { "mm", "mmr" },
+  { "na", "nam" },
+  { "nr", "nru" },
+  { "np", "npl" },
+  { "nl", "nld" },
+  { "an", "ant" },
+  { "nc", "ncl" },
+  { "nz", "nzl" },
+  { "ni", "nic" },
+  { "ne", "ner" },
+  { "ng", "nga" },
+  { "nu", "niu" },
+  { "nf", "nfk" },
+  { "mp", "mnp" },
+  { "no", "nor" },
+  { "om", "omn" },
+  { "pk", "pak" },
+  { "pw", "plw" },
+  { "ps", "pse" },
+  { "pa", "pan" },
+  { "pg", "png" },
+  { "py", "pry" },
+  { "pe", "per" },
+  { "ph", "phl" },
+  { "pn", "pcn" },
+  { "pl", "pol" },
+  { "pt", "prt" },
+  { "pr", "pri" },
+  { "qa", "qat" },
+  { "re", "reu" },
+  { "ro", "rou" },
+  { "ru", "rus" },
+  { "rw", "rwa" },
+  { "bl", "blm" },
+  { "sh", "shn" },
+  { "kn", "kna" },
+  { "lc", "lca" },
+  { "mf", "maf" },
+  { "pm", "spm" },
+  { "vc", "vct" },
+  { "ws", "wsm" },
+  { "sm", "smr" },
+  { "st", "stp" },
+  { "sa", "sau" },
+  { "sn", "sen" },
+  { "rs", "srb" },
+  { "sc", "syc" },
+  { "sl", "sle" },
+  { "sg", "sgp" },
+  { "sk", "svk" },
+  { "si", "svn" },
+  { "sb", "slb" },
+  { "so", "som" },
+  { "za", "zaf" },
+  { "gs", "sgs" },
+  { "es", "esp" },
+  { "lk", "lka" },
+  { "sd", "sdn" },
+  { "sr", "sur" },
+  { "sj", "sjm" },
+  { "sz", "swz" },
+  { "se", "swe" },
+  { "ch", "che" },
+  { "sy", "syr" },
+  { "tw", "twn" },
+  { "tj", "tjk" },
+  { "tz", "tza" },
+  { "th", "tha" },
+  { "tl", "tls" },
+  { "tg", "tgo" },
+  { "tk", "tkl" },
+  { "to", "ton" },
+  { "tt", "tto" },
+  { "tn", "tun" },
+  { "tr", "tur" },
+  { "tm", "tkm" },
+  { "tc", "tca" },
+  { "tv", "tuv" },
+  { "ug", "uga" },
+  { "ua", "ukr" },
+  { "ae", "are" },
+  { "gb", "gbr" },
+  { "us", "usa" },
+  { "um", "umi" },
+  { "uy", "ury" },
+  { "uz", "uzb" },
+  { "vu", "vut" },
+  { "ve", "ven" },
+  { "vn", "vnm" },
+  { "vg", "vgb" },
+  { "vi", "vir" },
+  { "wf", "wlf" },
+  { "eh", "esh" },
+  { "ye", "yem" },
+  { "zm", "zmb" },
+  { "zw", "zwe" }
+};
diff -Naur xbmc-10.1/xbmc/LangCodeExpander.h xbmc-10.1a/xbmc/LangCodeExpander.h
--- xbmc-10.1/xbmc/LangCodeExpander.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/LangCodeExpander.h	2011-10-08 07:57:40.322974412 +0200
@@ -34,6 +34,12 @@
 
   bool Lookup(CStdString& desc, const CStdString& code);
   bool Lookup(CStdString& desc, const int code);
+#ifdef _WIN32
+  bool ConvertTwoToThreeCharCode(CStdString& strThreeCharCode, const CStdString& strTwoCharCode, bool localeHack = false);
+#else
+  bool ConvertTwoToThreeCharCode(CStdString& strThreeCharCode, const CStdString& strTwoCharCode);
+#endif
+  bool ConvertLinuxToWindowsRegionCodes(const CStdString& strTwoCharCode, CStdString& strThreeCharCode);
 
   void LoadUserCodes(const TiXmlElement* pRootElement);
   void Clear();
diff -Naur xbmc-10.1/xbmc/LangInfo.cpp xbmc-10.1a/xbmc/LangInfo.cpp
--- xbmc-10.1/xbmc/LangInfo.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/LangInfo.cpp	2011-10-08 07:57:40.322974412 +0200
@@ -20,6 +20,7 @@
  */
 
 #include "LangInfo.h"
+#include "LangCodeExpander.h"
 #include "AdvancedSettings.h"
 #include "GUISettings.h"
 #include "LocalizeStrings.h"
@@ -43,6 +44,8 @@
   m_strDVDMenuLanguage=region.m_strDVDMenuLanguage;
   m_strDVDAudioLanguage=region.m_strDVDAudioLanguage;
   m_strDVDSubtitleLanguage=region.m_strDVDSubtitleLanguage;
+  m_strLangLocaleName = region.m_strLangLocaleName;
+  m_strRegionLocaleName = region.m_strRegionLocaleName;
 
   m_strDateFormatShort=region.m_strDateFormatShort;
   m_strDateFormatLong=region.m_strDateFormatLong;
@@ -74,6 +77,7 @@
   m_strDVDMenuLanguage="en";
   m_strDVDAudioLanguage="en";
   m_strDVDSubtitleLanguage="en";
+  m_strLangLocaleName = "English";
 
   m_strDateFormatShort="DD/MM/YYYY";
   m_strDateFormatLong="DDDD, D MMMM YYYY";
@@ -136,6 +140,43 @@
   m_strTimeZone = strTimeZone;
 }
 
+// set the locale associated with this region global. This affects string
+// sorting & transformations
+void CLangInfo::CRegion::SetGlobalLocale()
+{
+  CStdString strLocale;
+  if (m_strRegionLocaleName.length() > 0)
+  {
+    strLocale = m_strLangLocaleName + "_" + m_strRegionLocaleName;
+#ifdef _LINUX
+    strLocale += ".UTF-8";
+#endif
+  }
+
+  CLog::Log(LOGDEBUG, "trying to set locale to %s", strLocale.c_str());
+
+  // We need to set the locale to only change the collate. Otherwise,
+  // decimal separator is changed depending of the current language
+  // (ie. "," in French or Dutch instead of "."). This breaks atof() and
+  // others similar functions.
+  locale current_locale = locale::classic(); // C-Locale
+  try
+  {
+    locale lcl = locale(strLocale);
+    strLocale = lcl.name();
+    current_locale = current_locale.combine< collate<wchar_t> >(lcl);
+
+    assert(use_facet< numpunct<char> >(current_locale).decimal_point() == '.');
+
+  } catch(...) {
+    current_locale = locale::classic();
+    strLocale = "C";
+  }
+
+  locale::global(current_locale);
+  CLog::Log(LOGINFO, "global locale set to %s", strLocale.c_str());
+}
+
 CLangInfo::CLangInfo()
 {
   SetDefaults();
@@ -164,6 +205,18 @@
     return false;
   }
 
+  if (pRootElement->Attribute("locale"))
+    m_defaultRegion.m_strLangLocaleName = pRootElement->Attribute("locale");
+
+#ifdef _WIN32
+  // Windows need 3 chars isolang code
+  if (m_defaultRegion.m_strLangLocaleName.length() == 2)
+  {
+    if (! g_LangCodeExpander.ConvertTwoToThreeCharCode(m_defaultRegion.m_strLangLocaleName, m_defaultRegion.m_strLangLocaleName, true))
+      m_defaultRegion.m_strLangLocaleName = "";
+  }
+#endif
+
   const TiXmlNode *pCharSets = pRootElement->FirstChild("charsets");
   if (pCharSets && !pCharSets->NoChildren())
   {
@@ -210,6 +263,18 @@
       if (region.m_strName.IsEmpty())
         region.m_strName="N/A";
 
+      if (pRegion->Attribute("locale"))
+        region.m_strRegionLocaleName = pRegion->Attribute("locale");
+
+#ifdef _WIN32
+      // Windows need 3 chars regions code
+      if (region.m_strRegionLocaleName.length() == 2)
+      {
+        if (! g_LangCodeExpander.ConvertLinuxToWindowsRegionCodes(region.m_strRegionLocaleName, region.m_strRegionLocaleName))
+          region.m_strRegionLocaleName = "";
+      }
+#endif
+
       const TiXmlNode *pDateLong=pRegion->FirstChild("datelong");
       if (pDateLong && !pDateLong->NoChildren())
         region.m_strDateFormatLong=pDateLong->FirstChild()->Value();
@@ -323,6 +388,16 @@
   return m_currentRegion->m_strDVDSubtitleLanguage;
 }
 
+const CStdString& CLangInfo::GetLanguageLocale() const
+{
+  return m_currentRegion->m_strLangLocaleName;
+}
+
+const CStdString& CLangInfo::GetRegionLocale() const
+{
+  return m_currentRegion->m_strRegionLocaleName;
+}
+
 // Returns the format string for the date of the current language
 const CStdString& CLangInfo::GetDateFormat(bool bLongDate/*=false*/) const
 {
@@ -372,6 +447,8 @@
     m_currentRegion=&m_regions.begin()->second;
   else
     m_currentRegion=&m_defaultRegion;
+
+  m_currentRegion->SetGlobalLocale();
 }
 
 // Returns the current region set for this language
diff -Naur xbmc-10.1/xbmc/LangInfo.h xbmc-10.1a/xbmc/LangInfo.h
--- xbmc-10.1/xbmc/LangInfo.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/LangInfo.h	2011-10-08 07:57:40.314974142 +0200
@@ -42,6 +42,9 @@
   const CStdString& GetDVDSubtitleLanguage() const;
   const CStdString& GetTimeZone() const;
 
+  const CStdString& GetRegionLocale() const;
+  const CStdString& GetLanguageLocale() const;
+
   bool ForceUnicodeFont() const { return m_currentRegion->m_forceUnicodeFont; }
 
   const CStdString& GetDateFormat(bool bLongDate=false) const;
@@ -111,11 +114,14 @@
     void SetTempUnit(const CStdString& strUnit);
     void SetSpeedUnit(const CStdString& strUnit);
     void SetTimeZone(const CStdString& strTimeZone);
+    void SetGlobalLocale();
     CStdString m_strGuiCharSet;
     CStdString m_strSubtitleCharSet;
     CStdString m_strDVDMenuLanguage;
     CStdString m_strDVDAudioLanguage;
     CStdString m_strDVDSubtitleLanguage;
+    CStdString m_strLangLocaleName;
+    CStdString m_strRegionLocaleName;
     bool m_forceUnicodeFont;
     CStdString m_strName;
     CStdString m_strDateFormatLong;
diff -Naur xbmc-10.1/xbmc/StringUtils.cpp xbmc-10.1a/xbmc/StringUtils.cpp
--- xbmc-10.1/xbmc/StringUtils.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/StringUtils.cpp	2011-10-08 07:57:40.314974142 +0200
@@ -32,6 +32,9 @@
 
 #include "StringUtils.h"
 #include "utils/RegExp.h"
+#include "utils/fstrcmp.h"
+#include "LangInfo.h"
+#include <locale>
 
 #include <math.h>
 #include <sstream>
@@ -133,31 +136,33 @@
 // Compares separately the numeric and alphabetic parts of a string.
 // returns negative if left < right, positive if left > right
 // and 0 if they are identical (essentially calculates left - right)
-int64_t StringUtils::AlphaNumericCompare(const char *left, const char *right)
+int64_t StringUtils::AlphaNumericCompare(const wchar_t *left, const wchar_t *right)
 {
-  unsigned char *l = (unsigned char *)left;
-  unsigned char *r = (unsigned char *)right;
-  unsigned char *ld, *rd;
-  unsigned char lc, rc;
+  wchar_t *l = (wchar_t *)left;
+  wchar_t *r = (wchar_t *)right;
+  wchar_t *ld, *rd;
+  wchar_t lc, rc;
   int64_t lnum, rnum;
+  const collate<wchar_t>& coll = use_facet< collate<wchar_t> >( locale() );
+  int cmp_res = 0;
   while (*l != 0 && *r != 0)
   {
     // check if we have a numerical value
-    if (*l >= '0' && *l <= '9' && *r >= '0' && *r <= '9')
+    if (*l >= L'0' && *l <= L'9' && *r >= L'0' && *r <= L'9')
     {
       ld = l;
       lnum = 0;
-      while (*ld >= '0' && *ld <= '9' && ld < l + 15)
+      while (*ld >= L'0' && *ld <= L'9' && ld < l + 15)
       { // compare only up to 15 digits
         lnum *= 10;
         lnum += *ld++ - '0';
       }
       rd = r;
       rnum = 0;
-      while (*rd >= '0' && *rd <= '9' && rd < r + 15)
+      while (*rd >= L'0' && *rd <= L'9' && rd < r + 15)
       { // compare only up to 15 digits
         rnum *= 10;
-        rnum += *rd++ - '0';
+        rnum += *rd++ - L'0';
       }
       // do we have numbers?
       if (lnum != rnum)
@@ -170,15 +175,16 @@
     }
     // do case less comparison
     lc = *l;
-    if (lc >= 'A' && lc <= 'Z')
-      lc += 'a'-'A';
+    if (lc >= L'A' && lc <= L'Z')
+      lc += L'a'-L'A';
     rc = *r;
-    if (rc >= 'A' && rc <= 'Z')
-      rc += 'a'-'A';
-    // ok, do a normal comparison.  Add special case stuff (eg '(' characters)) in here later
-    if (lc  != rc)
+    if (rc >= L'A' && rc <= L'Z')
+      rc += L'a'- L'A';
+
+    // ok, do a normal comparison, taking current locale into account. Add special case stuff (eg '(' characters)) in here later
+    if ((cmp_res = coll.compare(&lc, &lc + 1, &rc, &rc + 1)) != 0)
     {
-      return lc - rc;
+      return cmp_res;
     }
     l++; r++;
   }
@@ -412,3 +418,26 @@
   return (guidRE.RegFind(uuid.c_str()) == 0);
 }
 
+double StringUtils::CompareFuzzy(const CStdString &left, const CStdString &right)
+{
+  return (0.5 + fstrcmp(left.c_str(), right.c_str(), 0.0) * (left.length() + right.length())) / 2.0;
+}
+
+int StringUtils::FindBestMatch(const CStdString &str, const CStdStringArray &strings, double &matchscore)
+{
+  int best = -1;
+  matchscore = 0;
+
+  int i = 0;
+  for (CStdStringArray::const_iterator it = strings.begin(); it != strings.end(); it++, i++)
+  {
+    int maxlength = max(str.length(), it->length());
+    double score = StringUtils::CompareFuzzy(str, *it) / maxlength;
+    if (score > matchscore)
+    {
+      matchscore = score;
+      best = i;
+    }
+  }
+  return best;
+}
diff -Naur xbmc-10.1/xbmc/StringUtils.h xbmc-10.1a/xbmc/StringUtils.h
--- xbmc-10.1/xbmc/StringUtils.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/StringUtils.h	2011-10-08 07:57:40.314974142 +0200
@@ -43,7 +43,7 @@
   static void JoinString(const CStdStringArray &strings, const CStdString& delimiter, CStdString& result);
   static int SplitString(const CStdString& input, const CStdString& delimiter, CStdStringArray &results, unsigned int iMaxStrings = 0);
   static int FindNumber(const CStdString& strInput, const CStdString &strFind);
-  static int64_t AlphaNumericCompare(const char *left, const char *right);
+  static int64_t AlphaNumericCompare(const wchar_t *left, const wchar_t *right);
   static long TimeStringToSeconds(const CStdString &timeString);
   static void RemoveCRLF(CStdString& strLine);
 
@@ -64,6 +64,8 @@
   static void WordToDigits(CStdString &word);
   static CStdString CreateUUID();
   static bool ValidateUUID(const CStdString &uuid); // NB only validates syntax
+  static double CompareFuzzy(const CStdString &left, const CStdString &right);
+  static int FindBestMatch(const CStdString &str, const CStdStringArray &strings, double &matchscore);
 private:
   static CStdString m_lastUUID;
 };
diff -Naur xbmc-10.1/xbmc/SystemGlobals.h xbmc-10.1a/xbmc/SystemGlobals.h
--- xbmc-10.1/xbmc/SystemGlobals.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/SystemGlobals.h	2011-10-08 07:57:40.314974142 +0200
@@ -33,6 +33,7 @@
 struct CSystemGlobals
 {
   // Classes that must be initialized/destructed in a specific order because of dependencies.
+  CSystemGlobals() : m_audioContext2(true) {}
 
   CGUISettings m_guiSettings;
 
@@ -55,6 +56,7 @@
   CGUILargeTextureManager m_largeTextureManager;
   CXBMCRenderManager m_renderManager;
   CAudioContext      m_audioContext;
+  CAudioContext      m_audioContext2;
   CGraphicContext    m_graphicsContext;
   CMouseStat         m_Mouse;
   CApplication       m_application;
diff -Naur xbmc-10.1/xbmc/utils/GUIInfoManager.cpp xbmc-10.1a/xbmc/utils/GUIInfoManager.cpp
--- xbmc-10.1/xbmc/utils/GUIInfoManager.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/utils/GUIInfoManager.cpp	2011-10-08 07:57:40.322974412 +0200
@@ -3965,8 +3965,8 @@
     break;
   case LISTITEM_SORT_LETTER:
     {
-      CStdString letter = g_charsetConverter.utf8Left(item->GetSortLabel(), 1);
-      letter.ToUpper();
+      CStdString letter;
+      g_charsetConverter.wToUTF8(item->GetSortLabel().Left(1).ToUpper(), letter);
       return letter;
     }
     break;
diff -Naur xbmc-10.1/xbmc/utils/PCMRemap.cpp xbmc-10.1a/xbmc/utils/PCMRemap.cpp
--- xbmc-10.1/xbmc/utils/PCMRemap.cpp	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/utils/PCMRemap.cpp	2011-10-08 07:57:40.318974037 +0200
@@ -167,7 +167,8 @@
   m_ignoreLayout(false),
   m_inChannels  (0),
   m_outChannels (0),
-  m_inSampleSize(0)
+  m_inSampleSize(0),
+  m_bAudio2     (false)
 {
   Dispose();
 }
@@ -350,7 +351,11 @@
   m_outStride = m_inSampleSize * m_outChannels;
 
   /* see if we need to normalize the levels */
-  bool dontnormalize = g_guiSettings.GetBool("audiooutput.dontnormalizelevels");
+  bool dontnormalize;
+  if (!m_bAudio2)
+    dontnormalize = g_guiSettings.GetBool("audiooutput.dontnormalizelevels");
+  else
+    dontnormalize = g_guiSettings.GetBool("audiooutput2.dontnormalizelevels");
   CLog::Log(LOGDEBUG, "CPCMRemap: Downmix normalization is %s", (dontnormalize ? "disabled" : "enabled"));
 
   ResolveChannels();
@@ -444,7 +449,10 @@
   assert(sampleSize == 2);
 
   /* get the audio layout, and count the channels in it */
-  m_channelLayout  = (enum PCMLayout)g_guiSettings.GetInt("audiooutput.channellayout");
+  if (!m_bAudio2)
+    m_channelLayout  = (enum PCMLayout)g_guiSettings.GetInt("audiooutput.channellayout");
+  else
+    m_channelLayout  = (enum PCMLayout)g_guiSettings.GetInt("audiooutput2.channellayout");
   if (m_channelLayout >= PCM_MAX_LAYOUT) m_channelLayout = PCM_LAYOUT_2_0;
 
   CLog::Log(LOGINFO, "CPCMRemap: Configured speaker layout: %s\n", PCMLayoutStr(m_channelLayout).c_str());
diff -Naur xbmc-10.1/xbmc/utils/PCMRemap.h xbmc-10.1a/xbmc/utils/PCMRemap.h
--- xbmc-10.1/xbmc/utils/PCMRemap.h	2011-03-05 04:33:37.000000000 +0100
+++ xbmc-10.1a/xbmc/utils/PCMRemap.h	2011-10-08 07:57:40.318974037 +0200
@@ -90,6 +90,7 @@
   int                m_inStride, m_outStride;
   struct PCMMapInfo  m_lookupMap[PCM_MAX_CH + 1][PCM_MAX_CH + 1];
   int                m_counts[PCM_MAX_CH];
+  bool               m_bAudio2;
 
   struct PCMMapInfo* ResolveChannel(enum PCMChannels channel, float level, bool ifExists, std::vector<enum PCMChannels> path, struct PCMMapInfo *tablePtr);
   void               ResolveChannels(); //!< Partial BuildMap(), just enough to see which output channels are active
@@ -111,6 +112,7 @@
   int  InBytesToFrames (int bytes );
   int  FramesToOutBytes(int frames);
   int  FramesToInBytes (int frames);
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; };
 };
 
 #endif
