diff -urN vdr-plugin-yaepghd/HISTORY yaepghd-0.0.3-ce/HISTORY
--- vdr-plugin-yaepghd/HISTORY	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/HISTORY	2010-11-20 17:55:05.000000000 +0100
@@ -17,3 +17,36 @@
 - Fixed a bug in channel listing (Rolf Ahrenberg).
 - Fixed theme selection on the setup page (Rolf Ahrenberg).
 - Fixed cPlugin::ConfigDirectory() to called only from main thread (Rolf Ahrenberg).
+
+2010-10-02: Version 0.0.2 Community Edition
+
+- Use vdr function for channel switching (Rolf Ahrenberg).
+- Add makefile option for debuging output (Rolf Ahrenberg).
+- Fixed a bug in setup menu (Rolf Ahrenberg).
+- Changed compile options in makefile (Rolf Ahrenberg).
+- Added ability to set timers and show event info (gnapheus,tomas))
+- Changed date generation (CR7, tomas))
+- Replace newlines with spaces in EPG Description for e.g tvmovieepg (tomas)
+- Changed makefile for vdr 1.7.10
+- fixed display of wrong week day (tomas) 
+- New MainMenuHooks patch (gnapheus, Joe_D).
+- Fixed hide main menu entry (gnapheus) 
+- Add record dialog and message box - theme files must be adapted  (duffy @ easyvdr)
+- Options for text color and font of the helpbar - theme files must be adapted (gnapheus)
+- Timers are not deleted anymore, but deactivated like in the original program guide (gnapheus)
+- EventInfo now uses 3 equally distributed boxes for T V and * (gnapheus)
+- EventInfo can use the symbols of the VDRSymbols font instead of T, V and * (gnapheus)
+- Changed original default theme according to new EventInfo, Record Dialog and MessageBox (gnapheus)
+- Switchtimer can be set via the epgsearch service interface (gnapheus)
+- The main menu entry can now be set by setup.
+  (Note: when changing the name to something different than the default, it is
+  no more dependent on the OSD language) (gnapheus, copied from epgsearch)
+
+2010-10-24: Version 0.0.3 Community Edition
+
+- added support for remote timers (schmirl, gnapheus)
+- fixed possible memory leak (schmirl)
+- setup option for record dialog with the red button (gnapheus)
+- setup option for switch with OK (gnapheus)
+- several small improvements
+- added support for epg images (gnapheus)
diff -urN vdr-plugin-yaepghd/Makefile yaepghd-0.0.3-ce/Makefile
--- vdr-plugin-yaepghd/Makefile	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/Makefile	2010-09-12 15:45:59.000000000 +0200
@@ -1,17 +1,18 @@
 #
 # Makefile for a Video Disk Recorder plugin
 #
-# $Id$
-
-# Use Reel eHD card
-#YAEPGHD_REEL_EHD = 1
+# $Id: Makefile 1.2 2010/02/06 14:50:03 kls Exp $
 
 # The official name of this plugin.
 # This name will be used in the '-P...' option of VDR to load the plugin.
 # By default the main source file also carries this name.
 # IMPORTANT: the presence of this macro is important for the Make.config
 # file. So it must be defined, even if it is not used here!
-#
+
+# Use Reel eHD card
+#YAEPGHD_REEL_EHD = 1
+
+
 PLUGIN = yaepghd
 
 ### The version number of this plugin (taken from the main source file):
@@ -29,6 +30,10 @@
 LIBDIR = ../../lib
 TMPDIR = /tmp
 
+### Make sure that necessary options are included:
+
+include $(VDRDIR)/Make.global
+
 ### Allow user defined options to overwrite defaults:
 
 -include $(VDRDIR)/Make.config
@@ -59,7 +64,7 @@
 
 ### The object files (add further files here):
 
-OBJS = $(PLUGIN).o
+OBJS = $(PLUGIN).o 
 
 ### The main target:
 
diff -urN vdr-plugin-yaepghd/patches/Make.global yaepghd-0.0.3-ce/patches/Make.global
--- vdr-plugin-yaepghd/patches/Make.global	1970-01-01 01:00:00.000000000 +0100
+++ yaepghd-0.0.3-ce/patches/Make.global	2010-07-24 18:31:34.000000000 +0200
@@ -0,0 +1,17 @@
+#
+# Strictly necessary Makefile options for the Video Disk Recorder
+#
+# See the main source file 'vdr.c' for copyright information and
+# how to reach the author.
+#
+# $Id: Make.global 1.1 2010/02/06 14:54:12 kls Exp $
+
+# Plugins need to be compiled with position independent code, otherwise linking
+# VDR against it will fail.
+
+ifdef PLUGIN
+CFLAGS   += -fPIC
+CXXFLAGS += -fPIC
+endif
+
+DEFINES += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
diff -urN vdr-plugin-yaepghd/patches/vdr-1.6.0-MainMenuHooks-v1_0_1.diff yaepghd-0.0.3-ce/patches/vdr-1.6.0-MainMenuHooks-v1_0_1.diff
--- vdr-plugin-yaepghd/patches/vdr-1.6.0-MainMenuHooks-v1_0_1.diff	1970-01-01 01:00:00.000000000 +0100
+++ yaepghd-0.0.3-ce/patches/vdr-1.6.0-MainMenuHooks-v1_0_1.diff	2010-10-23 19:25:10.000000000 +0200
@@ -0,0 +1,181 @@
+This is a "patch" for the Video Disk Recorder (VDR).
+
+* History
+2010-10-15: Version 1.0.1
+- return a cOsdObject instead of its subclass cOsdMenu (thanks to
+  Joe_D@vdrportal)
+- version number defines in config.h now follow the ususal conventions:
+  MAINMENUHOOKSVERSNUM is now a number, the newly added define
+  MAINMENUHOOKSVERSION is a string (suggested by gnapheus@vdrportal)
+- patch is now based on VDR 1.6.0
+- updated documentation
+
+2007-02-26: Version 1.0
+- Initial revision.
+
+* Authors:
+Tobias Grimm  <vdr at e-tobi dot net>
+Martin Prochnow  <nordlicht at martins-kabuff dot de>
+Frank Schmirler  <vdrdev at schmirler dot de>
+Christian Wieninger  <cwieninger at gmx dot de>
+
+* Description:
+This patch allows plugins to replace the VDR mainmenus "Schedule",
+"Channels", "Timers" and "Recordings" by a different implementation.
+
+The patch is based on a suggestion of Christian Wieninger back in 2006
+(http://www.linuxtv.org/pipermail/vdr/2006-March/008234.html). It is
+meant to be an interim solution for VDR 1.4 until (maybe) VDR 1.5
+introduces an official API for this purpose.
+
+* Installation
+Change into the VDR source directory, then issue
+  patch -p1 < path/to/MainMenuHooks-v1_0_1.patch
+and recompile.
+
+* Notes for plugin authors
+The following code sample shows the required plugin code for replacing
+the original Schedule menu:
+
+bool cMyPlugin::Service(const char *Id, void *Data)
+{
+  cOsdMenu **menu = (cOsdMenu**) Data;
+  if (MySetup.replaceSchedule &&
+            strcmp(Id, "MainMenuHooksPatch-v1.0::osSchedule") == 0) {
+    if (menu)
+      *menu = (cOsdMenu*) MainMenuAction();
+    return true;
+  }
+  return false;
+}
+
+Since patch version 1.0.1 the service call may return a cOsdObject
+instead of a cOsdMenu. Use "#ifdef MAINMENUHOOKSVERSION" to detect
+version 1.0.1.
+
+A plugin can replace more than one menu at a time. Simply replace the
+call to MainMenuAction() in the sample above by appropriate code.
+
+Note that a plugin *should* offer a setup option which allows the user
+to enable or disable the replacement. "Disabled" would be a reasonable
+default setting. By testing for define MAINMENUHOOKSVERSNUM, a plugin
+can leave the setup option out at compiletime.
+
+In case there is an internal problem when trying to open the replacement
+menu, it is safe to return true even though Data is NULL. However an
+OSD message should indicate the problem to the user.
+
+Feel free to ship this patch along with your plugin. However if you
+think you need to modify the patch, we'd encourage you to contact the
+authors first or at least use a service id which differs in more than
+just the version number.
+
+diff -ru vdr-1.6.0.orig/menu.c vdr-1.6.0/menu.c
+--- vdr-1.6.0.orig/menu.c	2008-03-16 12:15:28.000000000 +0100
++++ vdr-1.6.0/menu.c	2010-10-11 20:32:25.000000000 +0200
+@@ -2973,15 +2973,31 @@
+ 
+   // Initial submenus:
+ 
++  cOsdObject *menu = NULL;
+   switch (State) {
+-    case osSchedule:   AddSubMenu(new cMenuSchedule); break;
+-    case osChannels:   AddSubMenu(new cMenuChannels); break;
+-    case osTimers:     AddSubMenu(new cMenuTimers); break;
+-    case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
+-    case osSetup:      AddSubMenu(new cMenuSetup); break;
+-    case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
++    case osSchedule:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
++            menu = new cMenuSchedule;
++        break;
++    case osChannels:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
++            menu = new cMenuChannels;
++        break;
++    case osTimers:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
++            menu = new cMenuTimers;
++        break;
++    case osRecordings:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
++            menu = new cMenuRecordings(NULL, 0, true);
++        break;
++    case osSetup:      menu = new cMenuSetup; break;
++    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+     default: break;
+     }
++  if (menu)
++     if (menu->IsMenu())
++        AddSubMenu((cOsdMenu *) menu);
+ }
+ 
+ cOsdObject *cMenuMain::PluginOsdObject(void)
+@@ -3096,13 +3112,34 @@
+   eOSState state = cOsdMenu::ProcessKey(Key);
+   HadSubMenu |= HasSubMenu();
+ 
++  cOsdObject *menu = NULL;
+   switch (state) {
+-    case osSchedule:   return AddSubMenu(new cMenuSchedule);
+-    case osChannels:   return AddSubMenu(new cMenuChannels);
+-    case osTimers:     return AddSubMenu(new cMenuTimers);
+-    case osRecordings: return AddSubMenu(new cMenuRecordings);
+-    case osSetup:      return AddSubMenu(new cMenuSetup);
+-    case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
++    case osSchedule:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
++            menu = new cMenuSchedule;
++        else
++            state = osContinue;
++        break;
++    case osChannels:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
++            menu = new cMenuChannels;
++        else
++            state = osContinue;
++        break;
++    case osTimers:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
++            menu = new cMenuTimers;
++        else
++            state = osContinue;
++        break;
++    case osRecordings:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
++            menu = new cMenuRecordings;
++        else
++            state = osContinue;
++        break;
++    case osSetup:      menu = new cMenuSetup; break;
++    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+     case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
+                           cOsdItem *item = Get(Current());
+                           if (item) {
+@@ -3154,6 +3191,12 @@
+                default:      break;
+                }
+     }
++  if (menu) {
++     if (menu->IsMenu())
++        return AddSubMenu((cOsdMenu *) menu);
++     pluginOsdObject = menu;
++     return osPlugin;
++  } 
+   if (!HasSubMenu() && Update(HadSubMenu))
+      Display();
+   if (Key != kNone) {
+diff -ru vdr-1.6.0.orig/config.h vdr-1.6.0/config.h
+--- vdr-1.6.0.orig/config.h	2008-03-23 11:26:10.000000000 +0100
++++ vdr-1.6.0/config.h	2010-10-11 20:32:25.000000000 +0200
+@@ -36,6 +36,10 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++// The MainMenuHook Patch's version number:
++#define MAINMENUHOOKSVERSION "1.0.1"
++#define MAINMENUHOOKSVERSNUM 10001  // Version * 10000 + Major * 100 + Minor
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
diff -urN vdr-plugin-yaepghd/patches/vdr-1.6.0-yaepghd.patch yaepghd-0.0.3-ce/patches/vdr-1.6.0-yaepghd.patch
--- vdr-plugin-yaepghd/patches/vdr-1.6.0-yaepghd.patch	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/patches/vdr-1.6.0-yaepghd.patch	2010-08-08 17:39:34.000000000 +0200
@@ -5,29 +5,11 @@
  #define APIVERSION  "1.6.0"
  #define APIVERSNUM   10600  // Version * 10000 + Major * 100 + Minor
  
-+#define YAEPGHDVERSNUM 1
++#define YAEPGHDVERSNUM 2
 +
  // When loading plugins, VDR searches them by their APIVERSION, which
  // may be smaller than VDRVERSION in case there have been no changes to
  // VDR header files since the last APIVERSION. This allows compiled
-diff -Nru vdr-1.6.0-vanilla/device.h vdr-1.6.0-yaepghd/device.h
---- vdr-1.6.0-vanilla/device.h	2008-02-23 15:13:04.000000000 +0200
-+++ vdr-1.6.0-yaepghd/device.h	2009-01-24 23:34:01.000000000 +0200
-@@ -242,12 +242,12 @@
-          ///< Direction (only the sign of Direction is evaluated, positive values
-          ///< switch to higher channel numbers).
- private:
--  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
--         ///< Sets the device to the given channel (general setup).
- protected:
-   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
-          ///< Sets the device to the given channel (actual physical setup).
- public:
-+  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
-+         ///< Sets the device to the given channel (general setup).
-   static int CurrentChannel(void) { return primaryDevice ? currentChannel : 0; }
-          ///< Returns the number of the current channel on the primary device.
-   static void SetCurrentChannel(const cChannel *Channel) { currentChannel = Channel ? Channel->Number() : 0; }
 diff -Nru vdr-1.6.0-vanilla/dvbosd.c vdr-1.6.0-yaepghd/dvbosd.c
 --- vdr-1.6.0-vanilla/dvbosd.c	2007-09-16 11:55:54.000000000 +0300
 +++ vdr-1.6.0-yaepghd/dvbosd.c	2009-01-24 23:40:51.000000000 +0200
diff -urN vdr-plugin-yaepghd/patches/vdr-1.7.15-MainMenuHooks.patch yaepghd-0.0.3-ce/patches/vdr-1.7.15-MainMenuHooks.patch
--- vdr-plugin-yaepghd/patches/vdr-1.7.15-MainMenuHooks.patch	1970-01-01 01:00:00.000000000 +0100
+++ yaepghd-0.0.3-ce/patches/vdr-1.7.15-MainMenuHooks.patch	2010-09-12 19:05:21.000000000 +0200
@@ -0,0 +1,109 @@
+diff -Naur ./vdr-vanilla/config.h ./vdr-mainmenuhooks/config.h
+--- ./vdr-vanilla/config.h	2010-09-12 18:58:03.045298800 +0200
++++ ./vdr-mainmenuhooks/config.h	2010-09-12 18:57:27.766302622 +0200
+@@ -36,6 +36,10 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++// The MainMenuHook Patch's version number:
++#define MAINMENUHOOKSVERSION "1.0.1"
++#define MAINMENUHOOKSVERSNUM 10001  // Version * 10000 + Major * 100 + Minor
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
+diff -Naur ./vdr-vanilla/menu.c ./vdr-mainmenuhooks/menu.c
+--- ./vdr-vanilla/menu.c	2010-09-12 18:58:03.055298951 +0200
++++ ./vdr-mainmenuhooks/menu.c	2010-09-12 18:54:00.565296817 +0200
+@@ -3273,15 +3273,31 @@
+ 
+   // Initial submenus:
+ 
++  cOsdObject *menu = NULL;
+   switch (State) {
+-    case osSchedule:   AddSubMenu(new cMenuSchedule); break;
+-    case osChannels:   AddSubMenu(new cMenuChannels); break;
+-    case osTimers:     AddSubMenu(new cMenuTimers); break;
+-    case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
+-    case osSetup:      AddSubMenu(new cMenuSetup); break;
+-    case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
++    case osSchedule:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
++            menu = new cMenuSchedule;
++        break;
++    case osChannels:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
++            menu = new cMenuChannels;
++        break;
++    case osTimers:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
++            menu = new cMenuTimers;
++        break;
++    case osRecordings:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
++            menu = new cMenuRecordings(NULL, 0, true);
++        break;
++    case osSetup:      menu = new cMenuSetup; break;
++    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+     default: break;
+     }
++  if (menu)
++     if (menu->IsMenu())
++       AddSubMenu((cOsdMenu *) menu);
+ }
+ 
+ cOsdObject *cMenuMain::PluginOsdObject(void)
+@@ -3396,13 +3412,34 @@
+   eOSState state = cOsdMenu::ProcessKey(Key);
+   HadSubMenu |= HasSubMenu();
+ 
++  cOsdObject *menu = NULL;
+   switch (state) {
+-    case osSchedule:   return AddSubMenu(new cMenuSchedule);
+-    case osChannels:   return AddSubMenu(new cMenuChannels);
+-    case osTimers:     return AddSubMenu(new cMenuTimers);
+-    case osRecordings: return AddSubMenu(new cMenuRecordings);
+-    case osSetup:      return AddSubMenu(new cMenuSetup);
+-    case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
++    case osSchedule:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
++            menu = new cMenuSchedule;
++        else
++            state = osContinue;
++        break;
++    case osChannels:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
++            menu = new cMenuChannels;
++        else
++            state = osContinue;
++        break;
++    case osTimers:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
++            menu = new cMenuTimers;
++        else
++            state = osContinue;
++        break;
++    case osRecordings:
++        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
++            menu = new cMenuRecordings;
++        else
++            state = osContinue;
++        break;
++    case osSetup:      menu = new cMenuSetup; break;
++    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+     case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
+                           cOsdItem *item = Get(Current());
+                           if (item) {
+@@ -3454,6 +3491,12 @@
+                default:      break;
+                }
+     }
++  if (menu) {
++      if (menu->IsMenu())
++         return AddSubMenu((cOsdMenu *) menu);
++      pluginOsdObject = menu;
++      return osPlugin;
++  } 
+   if (!HasSubMenu() && Update(HadSubMenu))
+      Display();
+   if (Key != kNone) {
diff -urN vdr-plugin-yaepghd/patches/vdr-1.7.15-yaepghd.patch yaepghd-0.0.3-ce/patches/vdr-1.7.15-yaepghd.patch
--- vdr-plugin-yaepghd/patches/vdr-1.7.15-yaepghd.patch	1970-01-01 01:00:00.000000000 +0100
+++ yaepghd-0.0.3-ce/patches/vdr-1.7.15-yaepghd.patch	2010-09-12 19:21:04.000000000 +0200
@@ -0,0 +1,60 @@
+diff -Naur ./vdr-vanilla/config.h ./vdr-yaepghd/config.h
+--- ./vdr-vanilla/config.h	2010-09-12 18:58:03.045298800 +0200
++++ ./vdr-yaepghd/config.h	2010-09-12 19:19:50.575296412 +0200
+@@ -36,6 +36,8 @@
+ // plugins to work with newer versions of the core VDR as long as no
+ // VDR header files have changed.
+ 
++#define YAEPGHDVERSNUM 2
++
+ #define MAXPRIORITY 99
+ #define MAXLIFETIME 99
+ 
+diff -Naur ./vdr-vanilla/osd.c ./vdr-yaepghd/osd.c
+--- ./vdr-vanilla/osd.c	2010-09-12 18:58:03.055298951 +0200
++++ ./vdr-yaepghd/osd.c	2010-09-12 19:19:50.575296412 +0200
+@@ -753,6 +753,7 @@
+   width = height = 0;
+   level = Level;
+   active = false;
++  vidWin.bpp = 0;
+   for (int i = 0; i < Osds.Size(); i++) {
+       if (Osds[i]->level > level) {
+          Osds.Insert(this, i);
+diff -Naur ./vdr-vanilla/osd.h ./vdr-yaepghd/osd.h
+--- ./vdr-vanilla/osd.h	2010-09-12 18:58:03.055298951 +0200
++++ ./vdr-yaepghd/osd.h	2010-09-12 19:19:50.575296412 +0200
+@@ -270,6 +270,8 @@
+   int left, top, width, height;
+   uint level;
+   bool active;
++public:
++  tArea vidWin;
+ protected:
+   cOsd(int Left, int Top, uint Level);
+        ///< Initializes the OSD with the given coordinates.
+diff -Naur ./vdr-vanilla/PLUGINS/src/dvbsddevice/dvbsdffosd.c ./vdr-yaepghd/PLUGINS/src/dvbsddevice/dvbsdffosd.c
+--- ./vdr-vanilla/PLUGINS/src/dvbsddevice/dvbsdffosd.c	2010-09-12 18:58:03.035297477 +0200
++++ ./vdr-yaepghd/PLUGINS/src/dvbsddevice/dvbsdffosd.c	2010-09-12 19:16:54.645297211 +0200
+@@ -51,6 +51,10 @@
+         osdMem = cap.val;
+ #endif
+      }
++     if (vidWin.bpp != 0) {
++        Cmd(OSD_SetWindow, 0, 5);
++        Cmd(OSD_Close);
++     }
+ }
+ 
+ cDvbSdFfOsd::~cDvbSdFfOsd()
+@@ -196,6 +200,10 @@
+          Cmd(OSD_SetWindow, 0, i + 1);
+          Cmd(OSD_MoveWindow, 0, Left() + Bitmap->X0(), Top() + Bitmap->Y0());
+          }
++     if (vidWin.bpp != 0) {
++        Cmd(OSD_SetWindow, 0, 5);
++        Cmd(OSD_OpenRaw, vidWin.bpp, vidWin.x1, vidWin.y1, vidWin.x2, vidWin.y2, NULL);
++        }
+      shown = true;
+      }
+ }
diff -urN vdr-plugin-yaepghd/po/de_DE.po yaepghd-0.0.3-ce/po/de_DE.po
--- vdr-plugin-yaepghd/po/de_DE.po	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/po/de_DE.po	2010-11-20 18:47:58.000000000 +0100
@@ -6,37 +6,23 @@
 msgstr ""
 "Project-Id-Version: Yaepghd 0.0.1\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2009-01-30 20:42+0200\n"
-"PO-Revision-Date: 2009-01-28 10:51+0200\n"
-"Last-Translator: Klaus Schmidinger <kls@cadsoft.de>\n"
-"Language-Team: <vdr@linuxtv.org>\n"
+"POT-Creation-Date: 2010-11-08 17:14+0100\n"
+"PO-Revision-Date: 2010-11-03 07:21+0100\n"
+"Last-Translator: Tomas Saxer <tsaxer@gmx.de>\n"
+"Language-Team:  <vdr@linuxtv.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=ISO-8859-15\n"
 "Content-Transfer-Encoding: 8bit\n"
+"Language: \n"
 
 msgid "No Info"
 msgstr "Keine Daten verfügbar."
 
-msgid "Screenshot"
-msgstr ""
-
 msgid "Page up"
-msgstr ""
+msgstr "Seite hoch"
 
 msgid "Page down"
-msgstr ""
-
-msgid "Once"
-msgstr "Sobald"
-
-msgid "Every day"
-msgstr "Jeden Tag"
-
-msgid "Mon-Fri"
-msgstr "Mo-Fr"
-
-msgid "Sun-Sat"
-msgstr "So-Sa"
+msgstr "Seite runter"
 
 msgid "Start"
 msgstr "Anfang"
@@ -44,47 +30,104 @@
 msgid "Stop"
 msgstr "Halt"
 
-msgid "Frequency"
-msgstr "Frequenz"
+msgid "Switch timer added"
+msgstr "Umschalttimer angelegt"
+
+msgid "Switch timer deleted"
+msgstr "Umschalttimer gelöscht"
+
+msgid "Timer added"
+msgstr "Timer angelegt"
+
+msgid "Failed to add timer"
+msgstr "Timer konnte nicht angelegt werden"
+
+msgid "Remote timer deactivated"
+msgstr "Remote Timer deaktiviert"
+
+msgid "Timer deactivated"
+msgstr "Timer deaktiviert"
+
+msgid "YaepgHD"
+msgstr "YaepgHD"
 
 msgid "24h"
-msgstr ""
+msgstr "24h"
 
 msgid "12h"
-msgstr ""
+msgstr "12h"
 
 msgid "Up"
-msgstr ""
+msgstr "Hoch"
 
 msgid "Down"
-msgstr ""
+msgstr "Runter"
+
+msgid "Close YaepgHD"
+msgstr "YaepgHD wird geschlossen"
+
+msgid "Leave YaepgHD open"
+msgstr "YaepgHD bleibt geöffnet"
 
-msgid "Manual"
+msgid "Automatic"
+msgstr "Automatisch"
+
+msgid "pixel algo"
 msgstr ""
 
-msgid "Semi-automatic"
+msgid "ratio algo"
 msgstr ""
 
-msgid "Automatic"
+msgid "zoom image"
 msgstr ""
 
 msgid "Hide mainmenu entry"
 msgstr "Hauptmenüeintrag verstecken"
 
+msgid "Main menu entry"
+msgstr "Hauptmenüeintrag"
+
 msgid "Replace original schedule"
-msgstr ""
+msgstr "Ersetze original Programmführer"
 
 msgid "Channel change"
-msgstr ""
+msgstr "Kanal wechseln"
+
+msgid "Switch channel with OK"
+msgstr "Kanal umschalten mit OK"
+
+msgid "Record dialog with red button"
+msgstr "Aufnahmedialog bei roter Taste"
 
 msgid "Time format"
-msgstr "Zeit-Format"
+msgstr "Zeitformat"
 
 msgid "Channel order"
-msgstr ""
+msgstr "Kanalreihenfolge"
 
-msgid "Yet another EPG in HD"
-msgstr ""
+msgid "Channel number"
+msgstr "Kanalnummer"
 
-msgid "YaepgHD"
-msgstr ""
+msgid "Info symbols"
+msgstr "Info Symbole"
+
+msgid "EPG images"
+msgstr "EPG Bilder"
+
+msgid "  Resize images"
+msgstr " Bildergrößen anpassen "
+
+msgid "  Image format"
+msgstr " Bildformat"
+
+msgid "Switch timer"
+msgstr "Umschalttimer"
+
+msgid "  Switch ... minutes before start"
+msgstr "  Umschalten ... Minuten vor Start"
+
+msgid "Remote timer"
+msgstr "Remote Timer"
+
+msgid "Yet another EPG in HD"
+msgstr "Yet another EPG in HD"
diff -urN vdr-plugin-yaepghd/po/fi_FI.po yaepghd-0.0.3-ce/po/fi_FI.po
--- vdr-plugin-yaepghd/po/fi_FI.po	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/po/fi_FI.po	2010-11-20 18:47:58.000000000 +0100
@@ -7,7 +7,7 @@
 msgstr ""
 "Project-Id-Version: Yaepghd 0.0.1\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2009-01-30 20:42+0200\n"
+"POT-Creation-Date: 2010-11-20 18:16+0100\n"
 "PO-Revision-Date: 2009-01-28 10:51+0200\n"
 "Last-Translator: Rolf Ahrenberg <rahrenbe@cc.hut.fi>\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -18,35 +18,38 @@
 msgid "No Info"
 msgstr "Ei tietoja"
 
-msgid "Screenshot"
-msgstr "Ota kuva"
-
 msgid "Page up"
 msgstr "Sivu ylÃ¶s"
 
 msgid "Page down"
 msgstr "Sivu alas"
 
-msgid "Once"
-msgstr "kerran"
-
-msgid "Every day"
-msgstr "joka pÃ¤ivÃ¤"
-
-msgid "Mon-Fri"
-msgstr "ma-pe"
-
-msgid "Sun-Sat"
-msgstr "ma-su"
-
 msgid "Start"
 msgstr "Aloitus"
 
 msgid "Stop"
 msgstr "Lopetus"
 
-msgid "Frequency"
-msgstr "Toistuva"
+msgid "Switch timer added"
+msgstr ""
+
+msgid "Switch timer deleted"
+msgstr ""
+
+msgid "Timer added"
+msgstr ""
+
+msgid "Failed to add timer"
+msgstr ""
+
+msgid "Remote timer deactivated"
+msgstr ""
+
+msgid "Timer deactivated"
+msgstr ""
+
+msgid "YaepgHD"
+msgstr "Ohjelmaopas (YaepgHD)"
 
 msgid "24h"
 msgstr "24h"
@@ -60,32 +63,79 @@
 msgid "Down"
 msgstr "laskeva"
 
-msgid "Manual"
-msgstr "manuaalinen"
+#, fuzzy
+msgid "Close YaepgHD"
+msgstr "Ohjelmaopas (YaepgHD)"
 
-msgid "Semi-automatic"
-msgstr "puoliautomaattinen"
+msgid "Leave YaepgHD open"
+msgstr ""
 
 msgid "Automatic"
 msgstr "automaattinen"
 
+msgid "pixel algo"
+msgstr ""
+
+msgid "ratio algo"
+msgstr ""
+
+msgid "zoom image"
+msgstr ""
+
 msgid "Hide mainmenu entry"
 msgstr "Piilota valinta pÃ¤Ã¤valikosta"
 
+msgid "Main menu entry"
+msgstr "PÃ¤Ã¤valikko merkintÃ¤"
+
 msgid "Replace original schedule"
-msgstr "Korvaa alkuperÃ¤inen ohjelmaopas"
+msgstr ""
 
 msgid "Channel change"
 msgstr "Kanavanvaihto"
 
+msgid "Switch channel with OK"
+msgstr ""
+
+msgid "Record dialog with red button"
+msgstr ""
+
 msgid "Time format"
 msgstr "Kellonajan esitysmuoto"
 
 msgid "Channel order"
-msgstr "KanavajÃ¤rjetys"
+msgstr "KanavajÃ¤rjestys"
+
+msgid "Channel number"
+msgstr "Kanavanumero"
+
+msgid "Info symbols"
+msgstr ""
+
+msgid "EPG images"
+msgstr ""
+
+msgid "  Resize images"
+msgstr ""
+
+#, fuzzy
+msgid "  Image format"
+msgstr "Kellonajan esitysmuoto"
+
+msgid "Switch timer"
+msgstr ""
+
+msgid "  Switch ... minutes before start"
+msgstr ""
+
+msgid "Remote timer"
+msgstr ""
 
 msgid "Yet another EPG in HD"
 msgstr "Vaihtoehtoinen ohjelmaopas"
 
-msgid "YaepgHD"
-msgstr "Ohjelmaopas (YaepgHD)"
+#~ msgid "Manual"
+#~ msgstr "manuaalinen"
+
+#~ msgid "Semi-automatic"
+#~ msgstr "puoliautomaattinen"
diff -urN vdr-plugin-yaepghd/po/fr_FR.po yaepghd-0.0.3-ce/po/fr_FR.po
--- vdr-plugin-yaepghd/po/fr_FR.po	1970-01-01 01:00:00.000000000 +0100
+++ yaepghd-0.0.3-ce/po/fr_FR.po	2010-11-20 18:47:58.000000000 +0100
@@ -0,0 +1,140 @@
+# VDR plugin language source file.
+# Copyright (C) 2009 bball <bball950@yahoo.com>
+# This file is distributed under the same license as the yaepghd package.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: Yaepghd 0.0.1\n"
+"Report-Msgid-Bugs-To: <see README>\n"
+"POT-Creation-Date: 2010-11-20 18:16+0100\n"
+"PO-Revision-Date: 2009-01-28 10:51+0200\n"
+"Last-Translator: Klaus Schmidinger <kls@cadsoft.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "No Info"
+msgstr "Aucune données."
+
+msgid "Page up"
+msgstr "Page vers le haut"
+
+msgid "Page down"
+msgstr "Page vers le bas"
+
+msgid "Start"
+msgstr "Démarrer"
+
+msgid "Stop"
+msgstr "Arreter"
+
+msgid "Switch timer added"
+msgstr ""
+
+msgid "Switch timer deleted"
+msgstr ""
+
+msgid "Timer added"
+msgstr ""
+
+msgid "Failed to add timer"
+msgstr ""
+
+msgid "Remote timer deactivated"
+msgstr ""
+
+msgid "Timer deactivated"
+msgstr ""
+
+msgid "YaepgHD"
+msgstr "YaepgHD"
+
+msgid "24h"
+msgstr "24h"
+
+msgid "12h"
+msgstr "12h"
+
+msgid "Up"
+msgstr "Haut"
+
+msgid "Down"
+msgstr "Bas"
+
+#, fuzzy
+msgid "Close YaepgHD"
+msgstr "YaepgHD"
+
+msgid "Leave YaepgHD open"
+msgstr ""
+
+msgid "Automatic"
+msgstr "Automatique"
+
+msgid "pixel algo"
+msgstr ""
+
+msgid "ratio algo"
+msgstr ""
+
+msgid "zoom image"
+msgstr ""
+
+msgid "Hide mainmenu entry"
+msgstr "Cacher dans le menu principal"
+
+msgid "Main menu entry"
+msgstr "entrée dans le menu principal"
+
+msgid "Replace original schedule"
+msgstr "Remplacer le guide des programmes original"
+
+msgid "Channel change"
+msgstr "Changement de chaîne"
+
+msgid "Switch channel with OK"
+msgstr ""
+
+msgid "Record dialog with red button"
+msgstr ""
+
+msgid "Time format"
+msgstr "Format horaire"
+
+msgid "Channel order"
+msgstr "Ordre des chaînes"
+
+msgid "Channel number"
+msgstr ""
+
+msgid "Info symbols"
+msgstr ""
+
+msgid "EPG images"
+msgstr ""
+
+msgid "  Resize images"
+msgstr ""
+
+#, fuzzy
+msgid "  Image format"
+msgstr "Format horaire"
+
+msgid "Switch timer"
+msgstr ""
+
+msgid "  Switch ... minutes before start"
+msgstr ""
+
+msgid "Remote timer"
+msgstr ""
+
+msgid "Yet another EPG in HD"
+msgstr "Yet another EPG in HD"
+
+#~ msgid "Manual"
+#~ msgstr "Manuel"
+
+#~ msgid "Semi-automatic"
+#~ msgstr "Semi-automatique"
diff -urN vdr-plugin-yaepghd/po/it_IT.po yaepghd-0.0.3-ce/po/it_IT.po
--- vdr-plugin-yaepghd/po/it_IT.po	1970-01-01 01:00:00.000000000 +0100
+++ yaepghd-0.0.3-ce/po/it_IT.po	2010-11-20 18:47:58.000000000 +0100
@@ -0,0 +1,148 @@
+# VDR plugin language source file.
+# Copyright (C) 2009 bball <bball950@yahoo.com>
+# This file is distributed under the same license as the yaepghd package.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: Yaepghd 0.0.1\n"
+"Report-Msgid-Bugs-To: <see README>\n"
+"POT-Creation-Date: 2010-11-20 18:16+0100\n"
+"PO-Revision-Date: 2009-02-08 23:04+0100\n"
+"Last-Translator: Diego Pierotto <vdr-italian@tiscali.it>\n"
+"Language-Team:  <vdr@linuxtv.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=utf-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Poedit-Language: Italian\n"
+"X-Poedit-Country: ITALY\n"
+"X-Poedit-SourceCharset: utf-8\n"
+
+msgid "No Info"
+msgstr "Nessuna informazione"
+
+msgid "Page up"
+msgstr "Pagina su"
+
+msgid "Page down"
+msgstr "Pagina giÃ¹"
+
+msgid "Start"
+msgstr "Inizio"
+
+msgid "Stop"
+msgstr "Fine"
+
+msgid "Switch timer added"
+msgstr ""
+
+msgid "Switch timer deleted"
+msgstr ""
+
+msgid "Timer added"
+msgstr "Formato ora"
+
+msgid "Failed to add timer"
+msgstr ""
+
+msgid "Remote timer deactivated"
+msgstr ""
+
+#, fuzzy
+msgid "Timer deactivated"
+msgstr "Formato ora"
+
+msgid "YaepgHD"
+msgstr "YaepgHD"
+
+msgid "24h"
+msgstr "24h"
+
+msgid "12h"
+msgstr "12h"
+
+msgid "Up"
+msgstr "Su"
+
+msgid "Down"
+msgstr "GiÃ¹"
+
+#, fuzzy
+msgid "Close YaepgHD"
+msgstr "YaepgHD"
+
+msgid "Leave YaepgHD open"
+msgstr ""
+
+msgid "Automatic"
+msgstr "Automatico"
+
+msgid "pixel algo"
+msgstr ""
+
+msgid "ratio algo"
+msgstr ""
+
+msgid "zoom image"
+msgstr ""
+
+msgid "Hide mainmenu entry"
+msgstr "Nascondi voce menu principale"
+
+msgid "Main menu entry"
+msgstr ""
+
+msgid "Replace original schedule"
+msgstr "Sostituisci programmazione originale"
+
+msgid "Channel change"
+msgstr "Cambio canale"
+
+msgid "Switch channel with OK"
+msgstr ""
+
+msgid "Record dialog with red button"
+msgstr ""
+
+msgid "Time format"
+msgstr "Formato ora"
+
+msgid "Channel order"
+msgstr "Ordine canale"
+
+msgid "Channel number"
+msgstr ""
+
+msgid "Info symbols"
+msgstr ""
+
+msgid "EPG images"
+msgstr ""
+
+msgid "  Resize images"
+msgstr ""
+
+#, fuzzy
+msgid "  Image format"
+msgstr "Formato ora"
+
+msgid "Switch timer"
+msgstr ""
+
+msgid "  Switch ... minutes before start"
+msgstr ""
+
+msgid "Remote timer"
+msgstr ""
+
+msgid "Yet another EPG in HD"
+msgstr "Un altro gestore EPG in HD"
+
+#, fuzzy
+#~ msgid "Timer deaktivated"
+#~ msgstr "Formato ora"
+
+#~ msgid "Manual"
+#~ msgstr "Manuale"
+
+#~ msgid "Semi-automatic"
+#~ msgstr "Semi automatico"
diff -urN vdr-plugin-yaepghd/README yaepghd-0.0.3-ce/README
--- vdr-plugin-yaepghd/README	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/README	2010-11-20 17:54:12.000000000 +0100
@@ -1,8 +1,8 @@
 This is a "plugin" for the Video Disk Recorder (VDR).
 
-Written by:                  bball <bball950@yahoo.com>
+Written by:                  bball <bball950@yahoo.com>, Community Edition
 
-Project's homepage:          http://projects.vdr-developer.org/projects/show/plg-yaepghd
+Project's homepage:          http://projects.vdr-developer.org/projects/show/plg-yaepghd (original)
 
 Latest version available at: URL
 
@@ -39,9 +39,12 @@
 Up/Down         - Move the cursor up/down in the grid.
 Left/Right      - Move the cursor left/right in the grid.
 Ok              - Tune to the selected channel and exit the plugin.
-Red             - Take a screenshot (yaepghd.jpg).
+                  Record dialog.
+Red             - Add timer / delete timer.
+                  Record dialog.
 Green/Yellow    - Page up/down within the grid.
 Blue            - Switch to the selected channel.
+                  Switch timer.
 FastRew/FastFwd - Scroll -12/+12 hours in the grid.
 Back/Exit       - Exit the plugin.
 0-9             - Perform direct channel change.
@@ -59,21 +62,32 @@
 tar -xzf /put/your/path/here/vdr-yaepghd-X.Y.Z.tgz
 ln -s yaepghd-X.Y.Z yaepghd
 cd /put/your/path/here/VDR
-patch -p1 < PLUGINS/src/yaepghd/patches/vdr-X.Y.Z-yaepghd.patch
+patch -p1 < PLUGINS/src/yaepghd/patches/vdr-X.Y.Z-yaepghd.patch # Optional
+
+cp PLUGINS/src/yaepghd/patches/make.global ./  # only for vdr < 1.7.13
+
 cp -R PLUGINS/src/yaepghd/yaepghd /path/to/vdrconf/plugins/
 make
 make plugins
-./vdr -P yaepghd
+./vdr -P yaepghd 
+
+Options:
+
+  -i path, --epgimages=path
+      Path to the epgimages (Default: /video/epgimages).
 
 Notes:
+- This README has to be updated !
+
+- Yaepghd patch provides an optional VDR API modications for scaling
+  video window. The video stays untouched without the patch.
 
 - Video window doesn't scale back to normal when quiting the plugin
   with FF cards.
 
-- The default theme contains a font whose license is not compatible
-  with the GPL.  From the font's license:
+- Yaepghd may need a few seconds to set a switch timer, as it has to wait for
+  the EPGSearch plugin.
+
+- The colors of the epg images may be distorted if AntiAliasing is enabled in vdr osd setup.
 
-  "Tepid Monkey Fonts typefaces may be used for free in work
-   that will not generate a profit. If you intend to use the
-   font on an item or project that will be sold, please send
-   me an email first."
+  
I file binari vdr-plugin-yaepghd/yaepghd/default/accid___.ttf e yaepghd-0.0.3-ce/yaepghd/default/accid___.ttf sono diversi
I file binari vdr-plugin-yaepghd/yaepghd/default/bg.png e yaepghd-0.0.3-ce/yaepghd/default/bg.png sono diversi
I file binari vdr-plugin-yaepghd/yaepghd/default/msg.png e yaepghd-0.0.3-ce/yaepghd/default/msg.png sono diversi
I file binari vdr-plugin-yaepghd/yaepghd/default/rec.png e yaepghd-0.0.3-ce/yaepghd/default/rec.png sono diversi
diff -urN vdr-plugin-yaepghd/yaepghd/default.theme yaepghd-0.0.3-ce/yaepghd/default.theme
--- vdr-plugin-yaepghd/yaepghd/default.theme	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/yaepghd/default.theme	2010-11-08 18:25:13.000000000 +0100
@@ -1,13 +1,13 @@
 # Guide Widgets
 bgImage=default/bg.png
-gridEventFont="Accidental Presidency;20"
-gridChanFont="Accidental Presidency;20"
-gridTimeFont="Accidental Presidency;20"
-gridDateFont="Accidental Presidency;20"
-eventTitleFont="Accidental Presidency;26"
-eventTimeFont="Accidental Presidency;20"
-eventDescFont="Accidental Presidency;20"
-eventDateFont="Accidental Presidency;20"
+gridEventFont="VDRSymbols Sans;20"
+gridChanFont="VDRSymbols Sans;20"
+gridTimeFont="VDRSymbols Sans;20"
+gridDateFont="VDRSymbols Sans;20"
+eventTitleFont="VDRSymbols Sans;26"
+eventTimeFont="VDRSymbols Sans;20"
+eventDescFont="VDRSymbols Sans;20"
+eventDateFont="VDRSymbols Sans;20"
 gridEventColor=FFFFFFFF
 gridSelFg=FF000000
 gridSelBg=FFF8AF31
@@ -24,14 +24,15 @@
 gridChanGeom=25,288,113,234
 gridTimeGeom=154,251,516,32
 gridDateGeom=25,251,113,32
-eventTitleGeom=144,20,306,70
-eventTimeGeom=144,96,306,37
+eventTitleGeom=25,20,405,70
+eventTimeGeom=144,96,146,37
 eventDescGeom=25,135,425,115
 eventDateGeom=25,96,117,37
+# neu fÃ¼r epg-bilder
+eventEpgImageGeom=456,32,196,130
 tlineLocGeom=154,283,516,3
 tlineBoxGeom=0,0,9,3
 vidWinGeom=456,32,196,130
-helpGeom=25,526,645,32
 gridHorizSpace=4
 gridNumChans=7
 leftArrowWidth=16
@@ -39,6 +40,36 @@
 textBorder=4
 textSpace=0
 
-# Record Dialog Widgets
+# Help Bar
+helpFont="VDRSymbols Sans;20"
+helpGeom=25,526,695,32
+helpColor=FFFFFFFF
+
+# Info
+eventInfoFont="VDRSymbols Sans:Book;20"
+eventInfoColor=FFfe0000
+eventInfoGeom=292,96,162,37
+eventInfoAlign=2
+#    1 = Timer | VPS | Running  (default)
+#    2 = Running | VPS | Timer
+
+# Record Dialog
+recDlgImage=default/rec.png
+recDlgFont="VDRSymbols Sans;20"
+recDlgColor=FFFFFFFF
+recDlgGeom=240,350,240,96
+recTitleGeom=0,0,240,48
+recTimeGeom=0,1,0,1
+recStartGeom=20,46,120,24
+recEndGeom=20,70,120,24
+recFreqGeom=0,1,0,1
+recStInpGeom=120,46,120,24
+recEnInpGeom=120,70,120,24
+recFrInpGeom=0,1,0,1
+
+# Message Box
+msgBgImage=default/msg.png
+msgBoxFont="VDRSymbols Sans;20"
+msgBoxColor=FFFFFFFF
+msgBoxGeom=160,390,400,32
 
-# Message Box Widgets
diff -urN vdr-plugin-yaepghd/yaepghd.c yaepghd-0.0.3-ce/yaepghd.c
--- vdr-plugin-yaepghd/yaepghd.c	2013-03-24 21:32:03.280174049 +0100
+++ yaepghd-0.0.3-ce/yaepghd.c	2010-11-20 18:47:48.000000000 +0100
@@ -3,40 +3,41 @@
  *
  * See the README file for copyright information and how to reach the author.
  *
- * $Id$
+ * Community Edition
  */
 
 /**
  * Includes
  */
+#include <locale.h>
+#include <langinfo.h>
 #include <string>
 #include <vector>
 #include <map>
 #include <assert.h>
 #include <Magick++.h>
+#include <getopt.h>
 #ifdef YAEPGHD_REEL_EHD
 #include <curl/curl.h>
 #endif
 
 #include <vdr/config.h>
-#include <vdr/tools.h>
 #include <vdr/plugin.h>
 #include <vdr/osd.h>
+#include <vdr/timers.h>
 #include <vdr/device.h>
-#include <vdr/thread.h>
-
-#ifndef YAEPGHDVERSNUM
-#error "You must apply the yaepghd patch for VDR!"
-#endif
 
 #if defined(APIVERSNUM) && APIVERSNUM < 10600
 #error "VDR-1.6.0 API version or greater is required!"
 #endif
 
+// To avoid problems with the old MainMenuHooks-v1.0 patch uncomment next line.
+// #undef MAINMENUHOOKSVERSNUM 
+
 /**
  * Macros
  */
-
+//#define DEBUG
 #ifdef DEBUG
 #define ASSERT                   assert
 #define YAEPG_ERROR(...)         yaepg_error(__PRETTY_FUNCTION__, __VA_ARGS__)
@@ -70,9 +71,11 @@
 #define GRID_TIME_FONT           THEME_FONT("gridTimeFont")
 #define GRID_DATE_FONT           THEME_FONT("gridDateFont")
 #define EVENT_TITLE_FONT         THEME_FONT("eventTitleFont")
+#define EVENT_INFO_FONT          THEME_FONT("eventInfoFont")
 #define EVENT_TIME_FONT          THEME_FONT("eventTimeFont")
 #define EVENT_DESC_FONT          THEME_FONT("eventDescFont")
 #define EVENT_DATE_FONT          THEME_FONT("eventDateFont")
+#define HELP_BAR_FONT            THEME_FONT("helpFont")
 #define GRID_EVENT_COLOR         THEME_COLOR("gridEventColor")
 #define GRID_SEL_FG              THEME_COLOR("gridSelFg")
 #define GRID_SEL_BG              THEME_COLOR("gridSelBg")
@@ -81,18 +84,22 @@
 #define GRID_DATE_COLOR          THEME_COLOR("gridDateColor")
 #define GRID_SEP_COLOR           THEME_COLOR("gridSepColor")
 #define EVENT_TITLE_COLOR        THEME_COLOR("eventTitleColor")
+#define EVENT_INFO_COLOR         THEME_COLOR("eventInfoColor")
 #define EVENT_TIME_COLOR         THEME_COLOR("eventTimeColor")
 #define EVENT_DESC_COLOR         THEME_COLOR("eventDescColor")
 #define EVENT_DATE_COLOR         THEME_COLOR("eventDateColor")
 #define TLINE_BOX_COLOR          THEME_COLOR("tlineBoxColor")
+#define HELP_BAR_COLOR           THEME_COLOR("helpColor")
 #define GRID_EVENT_GEOM          THEME_GEOM("gridEventGeom")
 #define GRID_CHAN_GEOM           THEME_GEOM("gridChanGeom")
 #define GRID_TIME_GEOM           THEME_GEOM("gridTimeGeom")
 #define GRID_DATE_GEOM           THEME_GEOM("gridDateGeom")
 #define EVENT_TITLE_GEOM         THEME_GEOM("eventTitleGeom")
+#define EVENT_INFO_GEOM          THEME_GEOM("eventInfoGeom")
 #define EVENT_TIME_GEOM          THEME_GEOM("eventTimeGeom")
 #define EVENT_DESC_GEOM          THEME_GEOM("eventDescGeom")
 #define EVENT_DATE_GEOM          THEME_GEOM("eventDateGeom")
+#define EVENT_EPGIMAGE_GEOM      THEME_GEOM("eventEpgImageGeom")
 #define TLINE_LOC_GEOM           THEME_GEOM("tlineLocGeom")
 #define TLINE_BOX_GEOM           THEME_GEOM("tlineBoxGeom")
 #define VID_WIN_GEOM             THEME_GEOM("vidWinGeom")
@@ -103,6 +110,7 @@
 #define GRID_HORIZ_SPACE         THEME_IVAL("gridHorizSpace")
 #define TEXT_BORDER              THEME_IVAL("textBorder")
 #define TEXT_SPACE               THEME_IVAL("textSpace")
+#define EVENT_INFO_ALIGN         THEME_IVAL("eventInfoAlign")
 
 #define REC_DLG_IMG              THEME_IMAGE("recDlgImage")
 #define REC_DLG_FONT             THEME_FONT("recDlgFont")
@@ -122,10 +130,10 @@
 #define MSG_BOX_COLOR            THEME_COLOR("msgBoxColor")
 #define MSG_BOX_GEOM             THEME_GEOM("msgBoxGeom")
 
-/* Manner in which channel is changed while in YAEPG */
+/* Manner in which channel is changed while in YAEPGHD */
 enum eChanneChangeType {
-   CHANNEL_CHANGE_MANUAL,
-   CHANNEL_CHANGE_SEMIAUTOMATIC,
+   CHANNEL_CHANGE_CLOSE,
+   CHANNEL_CHANGE_OPEN,
    CHANNEL_CHANGE_AUTOMATIC,
    CHANNEL_CHANGE_COUNT
 };
@@ -152,12 +160,33 @@
  * Private Data
  */
 static int         iHideMenuEntry           = false;
+static char        sMainMenuEntry[MaxFileName] = "";
+#if defined(MAINMENUHOOKSVERSION) 
+#if MAINMENUHOOKSVERSNUM >= 10001
 static int         iReplaceOrgSchedule      = false;
-static int         iChannelChange           = CHANNEL_CHANGE_MANUAL;
+#endif
+#endif
+static int         iChannelChange           = CHANNEL_CHANGE_CLOSE;
+static int         iSwitchOK                = false;  
 static int         iTimeFormat              = TIME_FORMAT_12H;
 static int         iChannelOrder            = CHANNEL_ORDER_DOWN;
+static int         iChannelNumber           = false;
+static int         iRecDlgRed               = false;  
+static int         iInfoSymbols             = false;  
+static int         iSwitchTimer             = false;  
+static int         iSwitchMinsBefore        = 1;
+static int         iRemoteTimer             = false;  
+static int         iEpgImages               = false;  
+static int         iResizeImages            = 0;
+static int         iImageExtension          = 0;
 static std::string sThemeName               = "default";
 static std::string sThemeDir                = "";
+static std::string sEpgImagesDir            = "/video/epgimages";
+static int         iVDRSymbols              = false;  
+cPlugin*           pEPGSearch              = NULL;
+cPlugin*           pRemoteTimers           = NULL;
+
+const char *imageExtensionTexts[3] = { "png", "jpg", "xpm" };
 
 /**
  * Pirvate Classes/Function Prototypes
@@ -173,6 +202,45 @@
    int h;
 };
 
+// Data structure for service "Epgsearch-switchtimer-v1.0"
+struct Epgsearch_switchtimer_v1_0
+{
+// in
+      const cEvent* event;
+      int mode;                  // mode (0=query existance, 1=add/modify, 2=delete)
+// in/out
+      int switchMinsBefore;
+      int announceOnly;
+// out   		
+      bool success;              // result
+};
+
+// Data structure for RemoteTimers services
+struct RemoteTimers_Event_v1_0 {
+//in
+        const cEvent    *event;
+//out
+        cTimer          *timer;
+        cString         errorMsg;
+};
+
+struct RemoteTimers_GetMatch_v1_0 {
+//in
+	const cEvent	*event;
+//out
+	cTimer		*timer;
+	int		timerMatch;
+	int		timerType;
+	bool		isRemote;
+};
+
+struct RemoteTimers_Timer_v1_0 {
+//in+out
+	cTimer		*timer;
+//out
+	cString		errorMsg;
+};
+
 /* Logging functions */
 void
 yaepg_error(const char *func, const char *fmt, ...)
@@ -202,6 +270,57 @@
 
 /*
  *****************************************************************************
+ * Icons
+ *****************************************************************************
+ */
+class Icons
+{
+  private:
+    static bool IsUTF8;
+  public:
+    static void InitCharSet();
+    static const char* ArrowCCW(){return IsUTF8?"\ue000":"\x80";}
+    static const char* Recording(){return IsUTF8?"\ue00b":"\x8b";}
+    static const char* Watch(){return IsUTF8?"\ue00c":"\x8c";}
+    static const char* WatchUpperHalf(){return IsUTF8?"\ue014":"\x94";}
+    static const char* WatchLowerHalf(){return IsUTF8?"\ue015":"\x95";}
+    static const char* Running(){return IsUTF8?"\ue012":"\x92";}
+    static const char* VPS(){return IsUTF8?"\ue013":"\x93";}
+    static const char* Blank(){return IsUTF8?"\ue003":"\x83";}
+};
+
+bool Icons::IsUTF8=false;
+
+void Icons::InitCharSet()
+{
+  // Taken from VDR's vdr.c
+  char *CodeSet=NULL;
+  if(setlocale(LC_CTYPE, ""))
+    CodeSet=nl_langinfo(CODESET);
+  else
+  {
+    char *LangEnv=getenv("LANG"); // last resort in case locale stuff isn't installed
+    if(LangEnv)
+    {
+      CodeSet=strchr(LangEnv,'.');
+      if(CodeSet)
+        CodeSet++; // skip the dot
+    }
+  }
+
+  if(CodeSet && strcasestr(CodeSet,"UTF-8")!=0)
+    IsUTF8=true;
+    
+  cStringList fontlist;
+  cFont::GetAvailableFontNames(&fontlist);
+  if (fontlist.Find("VDRSymbols Sans:Book") > 0) {
+     iVDRSymbols =true;
+     YAEPG_INFO("Found VDRSymbols font. InfoSymbols enabled");
+  }
+}
+
+/*
+ *****************************************************************************
  * cYaepgTheme
  *****************************************************************************
  */
@@ -272,9 +391,11 @@
    AddElement("gridTimeFont", THEME_FONT);
    AddElement("gridDateFont", THEME_FONT);
    AddElement("eventTitleFont", THEME_FONT);
+   AddElement("eventInfoFont", THEME_FONT);
    AddElement("eventTimeFont", THEME_FONT);
    AddElement("eventDescFont", THEME_FONT);
    AddElement("eventDateFont", THEME_FONT);
+   AddElement("helpFont", THEME_FONT);
    AddElement("gridEventColor", THEME_COLOR);
    AddElement("gridSelFg", THEME_COLOR);
    AddElement("gridSelBg", THEME_COLOR);
@@ -283,18 +404,22 @@
    AddElement("gridTimeColor", THEME_COLOR);
    AddElement("gridDateColor", THEME_COLOR);
    AddElement("eventTitleColor", THEME_COLOR);
+   AddElement("eventInfoColor", THEME_COLOR);
    AddElement("eventTimeColor", THEME_COLOR);
    AddElement("eventDescColor", THEME_COLOR);
    AddElement("eventDateColor", THEME_COLOR);
    AddElement("tlineBoxColor", THEME_COLOR);
+   AddElement("helpColor", THEME_COLOR);
    AddElement("gridEventGeom", THEME_GEOM);
    AddElement("gridChanGeom", THEME_GEOM);
    AddElement("gridTimeGeom", THEME_GEOM);
    AddElement("gridDateGeom", THEME_GEOM);
    AddElement("eventTitleGeom", THEME_GEOM);
+   AddElement("eventInfoGeom", THEME_GEOM);
    AddElement("eventTimeGeom", THEME_GEOM);
    AddElement("eventDescGeom", THEME_GEOM);
    AddElement("eventDateGeom", THEME_GEOM);
+   AddElement("eventEpgImageGeom", THEME_GEOM);
    AddElement("tlineLocGeom", THEME_GEOM);
    AddElement("tlineBoxGeom", THEME_GEOM);
    AddElement("vidWinGeom", THEME_GEOM);
@@ -305,6 +430,7 @@
    AddElement("rightArrowWidth", THEME_IVAL);
    AddElement("textBorder", THEME_IVAL);
    AddElement("textSpace", THEME_IVAL);
+   AddElement("eventInfoAlign", THEME_IVAL);
 
    AddElement("recDlgImage", THEME_IMAGE);
    AddElement("recDlgGeom", THEME_GEOM);
@@ -566,7 +692,7 @@
             tColor col = (~(int)(pix->opacity * 255 / MaxRGB) << 24) |
                           ((int)(pix->red * 255 / MaxRGB) << 16) |
                           ((int)(pix->green * 255 / MaxRGB) << 8) |
-                           (pix->blue * 255 / MaxRGB);
+                           (int)(pix->blue * 255 / MaxRGB);
             bmp->DrawPixel(ix, iy, col);
             ++pix;
          }
@@ -765,6 +891,10 @@
       *s-- = '\0';
    }
 
+      /* Remove newlines in descriptions */
+   char *newlineText = tokText;
+   strreplace(newlineText, '\n', ' ');
+   
    /* Break text up into lines */
    char *line, *nextLine = tokText;
 
@@ -1334,9 +1464,19 @@
       chanInfo[i].nameBox.FgColor(GRID_CHAN_COLOR);
       chanInfo[i].nameBox.BgColor(clrTransparent);
       chanInfo[i].nameBox.Flags((eTextFlags)(TBOX_VALIGN_LEFT | TBOX_HALIGN_CENTER));
-      chanInfo[i].nameBox.X(geom.x + (geom.w / 2));
+      
+	  if (iChannelNumber)
+	  {
+	     chanInfo[i].nameBox.X(geom.x + (geom.w / 2));
+		 chanInfo[i].nameBox.W(geom.w / 2);
+	  }
+	  else
+	  {
+	     chanInfo[i].nameBox.X(geom.x);
+		 chanInfo[i].nameBox.W(geom.w );
+	  }
+	  
       chanInfo[i].nameBox.Y(geom.y + ROUND((float)i * (chanRowHeight + (float)horizSpace)));
-      chanInfo[i].nameBox.W(geom.w / 2);
       chanInfo[i].nameBox.H(ROUND(chanRowHeight));
       chanInfo[i].nameBox.Generate();
 
@@ -1354,8 +1494,9 @@
    YAEPG_INFO("Drawing grid channels at (%d %d)", geom.x, geom.y);
 
    for (int i = 0; i < (int)chanInfo.size(); i++) {
-      chanInfo[i].numBox.Draw(bmp);
-      chanInfo[i].nameBox.Draw(bmp);
+       if (iChannelNumber)
+	      chanInfo[i].numBox.Draw(bmp);
+       chanInfo[i].nameBox.Draw(bmp);
    }
 }
 
@@ -1460,12 +1601,7 @@
 void
 cYaepgGridDate::UpdateTime(time_t _t)
 {
-   struct tm locTime;
-
-   t = _t;
-   localtime_r(&t, &locTime);
-   snprintf(dateStr, sizeof(dateStr), "%s %d/%d",
-            *WeekDayName((locTime.tm_wday + 6) % 6), locTime.tm_mon, locTime.tm_mday);
+   sprintf(dateStr,"%s", *DateString(_t));
    Generate();
 }
 
@@ -1553,6 +1689,242 @@
 
 /*
  *****************************************************************************
+ * cYaepgEventInfo
+ *****************************************************************************
+ */
+class cYaepgEventInfo {
+private:
+   tGeom geom;
+   const cEvent *event;
+   cYaepgTextBox boxes[3];
+
+public:
+   cYaepgEventInfo(const cEvent *_event);
+   void UpdateEvent(const cEvent *_event) { event = _event; Generate(); }
+   void Generate(void);
+   void Draw(cBitmap *bmp);
+};
+
+cYaepgEventInfo::cYaepgEventInfo(const cEvent *_event) :
+   event(_event)
+{
+   geom = EVENT_INFO_GEOM;
+   Generate();
+}
+
+void
+cYaepgEventInfo::Generate(void)
+{
+   cString buffer[3];
+   const char* t=NULL;
+   const char* v=NULL;
+   const char* r=NULL;
+   
+   int timerMatch=tmNone; 
+   cTimer* ti;
+
+   if (iRemoteTimer && pRemoteTimers && event) {  
+      RemoteTimers_GetMatch_v1_0 rtMatch;
+      rtMatch.event = event;
+      pRemoteTimers->Service("RemoteTimers::GetMatch-v1.0", &rtMatch);
+      timerMatch = rtMatch.timerMatch;
+      ti = rtMatch.timer;
+   }
+   else
+      ti=Timers.GetMatch(event, &timerMatch);
+   
+   switch (timerMatch) {
+      case tmFull:
+         if (iInfoSymbols && iVDRSymbols) 
+            t=ti->Recording()?Icons::Recording():Icons::Watch();    
+         else 
+            t=ti->Recording()?"R":"T";  
+         break;
+      case tmPartial:
+         if (iInfoSymbols && iVDRSymbols) 
+            t=ti->Recording()?Icons::Recording():Icons::WatchUpperHalf();    
+         else
+            t=ti->Recording()?"R":"t";
+         break;
+      default:
+         t=" ";
+         break;
+   }   
+      
+   if (iSwitchTimer && pEPGSearch && event) {
+      Epgsearch_switchtimer_v1_0* serviceData = new Epgsearch_switchtimer_v1_0;
+	  serviceData->event = event;
+	  serviceData->mode = 0;
+      if (pEPGSearch->Service("Epgsearch-switchtimer-v1.0", serviceData)){
+         if(serviceData->success){
+            t=(iInfoSymbols && iVDRSymbols)?Icons::ArrowCCW():"S" ;
+		 }
+         delete serviceData;
+      }   
+   }   
+   if (event->Vps() && (event->Vps() - event->StartTime()))
+      v=(iInfoSymbols && iVDRSymbols)?Icons::VPS():"V";
+   else
+      v=" ";
+         
+   if (event->SeenWithin(30) && event->IsRunning())
+      r=(iInfoSymbols && iVDRSymbols)?Icons::Running():"*";
+   else
+      r=" " ;
+      
+   switch (EVENT_INFO_ALIGN){
+      case 2:
+         buffer[0] = cString::sprintf("%s", r);
+         buffer[1] = cString::sprintf("%s", v);
+         buffer[2] = cString::sprintf("%s", t);
+         break;
+      case 1:
+      default:
+         buffer[0] = cString::sprintf("%s", t);
+         buffer[1] = cString::sprintf("%s", v);
+         buffer[2] = cString::sprintf("%s", r);
+         break;
+   }
+   
+   int boxWidth = geom.w / 3;
+   for (int i = 0; i < 3; i++) {
+      boxes[i].Text(buffer[i]);
+      boxes[i].Font(EVENT_INFO_FONT);
+      boxes[i].FgColor(EVENT_INFO_COLOR);
+      boxes[i].BgColor(clrTransparent);
+      boxes[i].Flags((eTextFlags)(TBOX_VALIGN_CENTER | TBOX_HALIGN_CENTER));
+      boxes[i].X(geom.x + (i * boxWidth));
+      boxes[i].Y(geom.y);
+      boxes[i].W(boxWidth );
+      boxes[i].H(geom.h);
+      boxes[i].Generate();
+   }
+}
+
+void
+cYaepgEventInfo::Draw(cBitmap *bmp)
+{
+   YAEPG_INFO("Drawing event info at (%d %d)", geom.x, geom.y);
+   
+   for (int i = 0; i < 3; i++) {
+      boxes[i].Draw(bmp);
+   }
+}
+
+/*
+ *****************************************************************************
+ * cYaepgEventEpgImage
+ *****************************************************************************
+ */
+class cYaepgEventEpgImage {
+private:
+   tGeom geom;
+   const cEvent *event;
+   cBitmap *EpgImage;
+
+public:
+   cYaepgEventEpgImage(const cEvent *_event);
+   void UpdateEvent(const cEvent *_event) { event = _event; Generate(); }
+   void Generate(void);
+   void Draw(cBitmap *bmp);
+};
+
+cYaepgEventEpgImage::cYaepgEventEpgImage(const cEvent *_event) :
+   event(_event), EpgImage(NULL)
+{
+   geom = EVENT_EPGIMAGE_GEOM;
+   Generate();
+}
+
+void
+cYaepgEventEpgImage::Generate(void)
+{
+   Magick::Image image;
+  
+   char *strFilename = NULL;
+   
+   if (-1 == asprintf(&strFilename, "%s/%d.%s",sEpgImagesDir.c_str(),event->EventID(), imageExtensionTexts[iImageExtension]))
+   {
+	   YAEPG_ERROR("Couldn't built epg image filename!");
+	   delete strFilename;
+	   return;
+   }
+   
+   try {
+	  Geometry geo;
+      image.read(strFilename);
+      geo = image.size();
+      int w = geo.width();
+      int h = geo.height();
+      if (geom.h != h || geom.w != w) {
+         switch (iResizeImages) {
+         case 0:
+            image.sample(Geometry(geom.w, geom.h));
+            break;
+         case 1:
+            image.scale(Geometry(geom.w, geom.h));
+            break;
+         case 2:
+            image.zoom(Geometry(geom.w, geom.h));
+            break;
+         default:
+             YAEPG_ERROR("ERROR: unknown resize mode %d", iResizeImages);
+             break;
+         }
+         geo = image.size();
+         w = geo.width();
+         h = geo.height();
+      }
+      
+      image.opacity(OpaqueOpacity);
+      image.backgroundColor(Color(0, 0, 0, 0));
+      image.quantizeColorSpace(RGBColorspace);
+      image.quantizeColors(255);
+      image.quantize();
+     
+      EpgImage = new cBitmap(geom.w, geom.h, image.depth());
+      
+      // center image
+      int x = 0;
+      int y = 0;
+      x += ((geom.w - w) / 2);
+      y += ((geom.h - h) / 2);
+
+      const Magick::PixelPacket *pix = image.getConstPixels(0, 0, w, h);
+      for (int iy = 0; iy < h; ++iy) {
+        for (int ix = 0; ix < w; ++ix) {
+          tColor col = (~(int)(pix->opacity * 255 / MaxRGB) << 24)
+                     | ((int)(pix->red * 255 / MaxRGB) << 16)
+                     | ((int)(pix->green * 255 / MaxRGB) << 8)
+                     | (int)(pix->blue * 255 / MaxRGB);
+          EpgImage->DrawPixel(x + ix, y + iy, col);
+          ++pix;
+        }
+      }
+      delete strFilename;
+   } catch (Magick::Exception &e) {
+      YAEPG_ERROR("Couldn't load epg image %s, %s ", fullFilePath, e.what());
+      delete strFilename;
+      delete EpgImage;
+      EpgImage=NULL;
+   } catch (...) {
+      YAEPG_ERROR("Couldn't load %s: Unknown exception caught", fullFilePath);
+      delete strFilename;
+      delete EpgImage;
+      EpgImage=NULL;
+   }
+}
+
+void
+cYaepgEventEpgImage::Draw(cBitmap *bmp)
+{
+   YAEPG_INFO("Drawing event epg image at (%d %d)", geom.x, geom.y);
+   if (EpgImage)
+      bmp->DrawBitmap(geom.x, geom.y, *EpgImage);
+}
+
+/*
+ *****************************************************************************
  * cYaepgEventTime
  *****************************************************************************
  */
@@ -1700,10 +2072,10 @@
    localtime_r(&t, &locTime);
    if (iTimeFormat == TIME_FORMAT_24H) {
       snprintf(timeStr, sizeof(timeStr), "%s %02d:%02d",
-               *WeekDayName((locTime.tm_wday + 6) % 6), locTime.tm_hour, locTime.tm_min);
+               *WeekDayName((locTime.tm_wday + 7) % 7), locTime.tm_hour, locTime.tm_min);
    } else {
       snprintf(timeStr, sizeof(timeStr), "%s %d:%02d%s",
-               *WeekDayName((locTime.tm_wday + 6) % 6),
+               *WeekDayName((locTime.tm_wday + 7) % 7),
                FMT_12HR(locTime.tm_hour), locTime.tm_min,
                FMT_AMPM(locTime.tm_hour));
    }
@@ -1803,17 +2175,8 @@
  */
 class cYaepgHelpBar {
 private:
-   struct {
-      int x1;
-      int x2;
-      int y1;
-      int y2;
-      tColor color;
-   } dots[4];
-   int dotDiam;
    cYaepgTextBox boxes[4];
    static const char *helpStrs[4];
-   static const tColor dotColors[4];
    tGeom geom;
 
 public:
@@ -1822,55 +2185,38 @@
 };
 
 const char *cYaepgHelpBar::helpStrs[4] = {
-   trNOOP("Screenshot"),
+   trVDR("Button$Record"),
    trNOOP("Page up"),
    trNOOP("Page down"),
    trVDR("Button$Switch")
 };
 
-const tColor cYaepgHelpBar::dotColors[4] = {
-   (tColor)0xFFFF0000,
-   (tColor)0xFF00FF00,
-   (tColor)0xFFFFFF00,
-   (tColor)0xFF0000FF
-};
-
-cYaepgHelpBar::cYaepgHelpBar(void) :
-   dotDiam(10)
+cYaepgHelpBar::cYaepgHelpBar(void) 
 {
    geom = HELP_BAR_GEOM;
    int boxWidth = geom.w / 4;
    for (int i = 0; i < 4; i++) {
       boxes[i].Text(tr(helpStrs[i]));
-      boxes[i].Font(GRID_EVENT_FONT);
-      boxes[i].FgColor(GRID_EVENT_COLOR);
+      boxes[i].Font(HELP_BAR_FONT);
+      boxes[i].FgColor(HELP_BAR_COLOR);
       boxes[i].BgColor(clrTransparent);
-      boxes[i].Flags((eTextFlags)(TBOX_VALIGN_LEFT | TBOX_HALIGN_CENTER));
-      boxes[i].X(geom.x + (i * boxWidth) + dotDiam);
+      boxes[i].Flags((eTextFlags)(TBOX_VALIGN_CENTER | TBOX_HALIGN_CENTER));
+      boxes[i].X(geom.x + (i * boxWidth));
       boxes[i].Y(geom.y);
-      boxes[i].W(boxWidth - dotDiam);
+      boxes[i].W(boxWidth );
       boxes[i].H(geom.h);
       boxes[i].Generate();
-
-      dots[i].x1 = geom.x + (i * boxWidth);
-      dots[i].y1 = geom.y + ((geom.h - dotDiam) / 2);
-      dots[i].x2 = dots[i].x1 + dotDiam;
-      dots[i].y2 = dots[i].y1 + dotDiam;
-      dots[i].color = dotColors[i];
    }
 }
 
 void
 cYaepgHelpBar::Draw(cBitmap *bmp)
 {
-   if (geom.w < (4 * dotDiam)) {
+   if (geom.w < 40) {
       return;
    }
    
    for (int i = 0; i < 4; i++) {
-      bmp->DrawEllipse(dots[i].x1, dots[i].y1,
-                       dots[i].x2, dots[i].y2,
-                       dots[i].color);
       boxes[i].Draw(bmp);
    }
 }
@@ -1888,6 +2234,7 @@
    cYaepgInputTime(void) : t(0) {}
    void UpdateTime(time_t _t);
    eOSState ProcessKey(eKeys key);
+   struct tm recTime;   
 };
 
 void
@@ -1898,6 +2245,7 @@
 
    t = _t;
    localtime_r(&t, &locTime);
+   recTime = locTime;
    if (iTimeFormat == TIME_FORMAT_24H) {
       snprintf(timeStr, sizeof(timeStr), "%02d:%02d",
                locTime.tm_hour, locTime.tm_min);
@@ -2000,18 +2348,14 @@
  */
 class cYaepgRecDlg {
 private:
-   static const char *freqStra[4];
-   char freqs[4][32];
    const cEvent *event;
    tGeom geom;
    cYaepgTextBox titleBox;
    cYaepgTextBox timeBox;
    cYaepgTextBox startBox;
    cYaepgTextBox endBox;
-   cYaepgTextBox freqBox;
    cYaepgInputTime startInput;
    cYaepgInputTime endInput;
-   cYaepgInputStra freqInput;
    int curY;
 
 public:
@@ -2019,13 +2363,7 @@
    void UpdateEvent(const cEvent *_event);
    eOSState ProcessKey(eKeys key);
    void Draw(cBitmap *bmp);
-};
-
-const char *cYaepgRecDlg::freqStra[4] = {
-   trNOOP("Once"),
-   trNOOP("Every day"),
-   trNOOP("Mon-Fri"),
-   trNOOP("Sun-Sat"),
+   bool AddTimer(void);
 };
 
 cYaepgRecDlg::cYaepgRecDlg(void) :
@@ -2042,7 +2380,7 @@
    titleBox.Font(REC_DLG_FONT);
    titleBox.FgColor(REC_DLG_COLOR);
    titleBox.BgColor(clrTransparent);
-   titleBox.Flags((eTextFlags)(TBOX_VALIGN_LEFT | TBOX_HALIGN_CENTER));
+   titleBox.Flags((eTextFlags)(TBOX_VALIGN_CENTER | TBOX_HALIGN_CENTER));
    titleBox.X(REC_DLG_GEOM.x + REC_TITLE_GEOM.x);
    titleBox.Y(REC_DLG_GEOM.y + REC_TITLE_GEOM.y);
    titleBox.W(REC_TITLE_GEOM.w);
@@ -2078,16 +2416,6 @@
    endBox.W(REC_END_GEOM.w);
    endBox.H(REC_END_GEOM.h);
 
-   freqBox.Text(tr("Frequency"));
-   freqBox.Font(REC_DLG_FONT);
-   freqBox.FgColor(REC_DLG_COLOR);
-   freqBox.BgColor(clrTransparent);
-   freqBox.Flags((eTextFlags)(TBOX_VALIGN_LEFT | TBOX_HALIGN_CENTER));
-   freqBox.X(REC_DLG_GEOM.x + REC_FREQ_GEOM.x);
-   freqBox.Y(REC_DLG_GEOM.y + REC_FREQ_GEOM.y);
-   freqBox.W(REC_FREQ_GEOM.w);
-   freqBox.H(REC_FREQ_GEOM.h);
-
    startInput.Text("");
    startInput.Font(REC_DLG_FONT);
    startInput.FgColor(REC_DLG_COLOR);
@@ -2108,21 +2436,53 @@
    endInput.W(REC_ENINP_GEOM.w);
    endInput.H(REC_ENINP_GEOM.h);
 
-   freqInput.Text("");
-   freqInput.Font(REC_DLG_FONT);
-   freqInput.FgColor(REC_DLG_COLOR);
-   freqInput.BgColor(clrTransparent);
-   freqInput.Flags((eTextFlags)(TBOX_VALIGN_RIGHT | TBOX_HALIGN_CENTER));
-   freqInput.X(REC_DLG_GEOM.x + REC_FRINP_GEOM.x);
-   freqInput.Y(REC_DLG_GEOM.y + REC_FRINP_GEOM.y);
-   freqInput.W(REC_FRINP_GEOM.w);
-   freqInput.H(REC_FRINP_GEOM.h);
+}
 
-   for (int i = 0; i < 4; i++) {
-      strncpy(freqs[i], tr(freqStra[i]), sizeof(freqs[i]));
-   }
+bool
+cYaepgRecDlg::AddTimer(void)
+{
+    cTimer *recTimer;
+    char dayStr[8], file[MaxFileName], eventStr[256];
+    int flags, channel, start, stop, priority, lifetime;
+
+    /* Create the timer */
+    recTimer = new cTimer;
+
+    /* Construct the string that represent the event */
+    flags = tfActive;
+    channel = Channels.GetByChannelID(event->ChannelID(), true)->Number();
+    snprintf(dayStr, 8, "%d", startInput.recTime.tm_mday);
+    start = (startInput.recTime.tm_hour * 100) + startInput.recTime.tm_min;
+    stop = (endInput.recTime.tm_hour * 100) + endInput.recTime.tm_min;
+    priority = Setup.DefaultPriority;
+    lifetime = Setup.DefaultLifetime; 
+    *file = '\0';
+    if (!isempty(event->Title())) {
+         strncpy(file, event->Title(), sizeof(file));
+    }
+    snprintf(eventStr, 256, "%d:%d:%s:%04d:%04d:%d:%d:%s:",
+             flags, channel, dayStr, start, stop,
+	     priority, lifetime, file);
+    if (recTimer->Parse(eventStr) == false) {
+      delete recTimer;
+      return false;
+    }
+    if (iRemoteTimer && pRemoteTimers) {
+       RemoteTimers_Timer_v1_0 rt;
+       rt.timer = recTimer;
+       if (!pRemoteTimers->Service("RemoteTimers::NewTimer-v1.0", &rt)) {
+          YAEPG_ERROR(*rt.errorMsg);
+          return false;
+       }
+    }
+    else {
+      Timers.Add(recTimer);
+      Timers.Save();
+    }    
+    return true;
 }
 
+
 eOSState
 cYaepgRecDlg::ProcessKey(eKeys key)
 {
@@ -2136,9 +2496,6 @@
    case 1:
       state = endInput.ProcessKey(key);
       break;
-   case 2:
-      state = freqInput.ProcessKey(key);
-      break;
    default:
       ASSERT(0);
       break;
@@ -2148,8 +2505,16 @@
    if (state == osUnknown) {
       switch (key & ~k_Repeat) {
       case kUp:
+         if (curY > 0) {
+           curY--;
+           state = osContinue;
+       	 }
          break;
-      case kRight:
+      case kDown:
+         if (curY < 1) {
+           curY++;
+           state = osContinue;
+      	 }
          break;
       default:
          state = osUnknown;
@@ -2168,6 +2533,9 @@
    /* Update the event title */
    titleBox.Text(event->Title());
    titleBox.Generate();
+   
+   startBox.Generate();
+   endBox.Generate();
 
    /* Update the start/end time */
    struct tm locStart, locEnd;
@@ -2196,13 +2564,6 @@
    startInput.UpdateTime(event->StartTime() - (Setup.MarginStart * 60));
    endInput.UpdateTime(event->StartTime() + _event->Duration() + (Setup.MarginStart * 60));
 
-   /* Update the frequency string array */
-   struct tm locTime;
-   t = event->StartTime();
-   localtime_r(&t, &locTime);
-   freqs[1][5] = ' ';
-   strcpy(&freqs[1][6], *WeekDayName((locTime.tm_wday + 6) % 6));
-   freqInput.UpdateStra((char **)freqs);
 }
 
 void
@@ -2213,11 +2574,20 @@
    timeBox.Draw(bmp);
    startBox.Draw(bmp);
    endBox.Draw(bmp);
-   freqBox.Draw(bmp);
+   
+   switch (curY) {
+   case 0:
+      endInput.BgColor(clrTransparent);
+      startInput.BgColor(GRID_SEL_BG);
+      break;
+   case 1:
+      startInput.BgColor(clrTransparent);
+      endInput.BgColor(GRID_SEL_BG);
+      break;
+   }
 
    startInput.Draw(bmp);
    endInput.Draw(bmp);
-   freqInput.Draw(bmp);
 }
 
 /*
@@ -2232,7 +2602,7 @@
 
 public:
    cYaepgMsg(void);
-   void UpdateMsg(char *msg);
+   void UpdateMsg(const char *msg);
    void Draw(cBitmap *bmp);
 };
 
@@ -2251,7 +2621,7 @@
 }
 
 void
-cYaepgMsg::UpdateMsg(char *msg)
+cYaepgMsg::UpdateMsg(const char *msg)
 {
    msgBox.Text(msg);
    msgBox.Generate();
@@ -2476,7 +2846,6 @@
    time_t startTime;
    tArea mainWin;
    cBitmap *mainBmp;
-
    std::vector< cChannel * > chanVec;
    const cEvent *event;
    cTimeMs lastInput;
@@ -2488,11 +2857,16 @@
    cYaepgGridTime *gridTime;
    cYaepgGridDate *gridDate;
    cYaepgEventTitle *eventTitle;
+   cYaepgEventInfo *eventInfo;
    cYaepgEventTime *eventTime;
    cYaepgEventDesc *eventDesc;
    cYaepgEventDate *eventDate;
+   cYaepgEventEpgImage *eventEpgImage;
    cYaepgTimeLine *timeLine;
    cYaepgHelpBar *helpBar;
+   cYaepgRecDlg *recordDlg;
+   cYaepgMsg *messageBox;
+   uint64_t msgBoxStart;
 
 public:
    cYaepghd(void);
@@ -2506,6 +2880,9 @@
    void UpdateEvent(const cEvent *newEvent);
    void MoveCursor(eCursorDir dir);
    void SwitchToCurrentChannel(bool closeVidWin = false);
+   void AddDelTimer(void);
+   void AddDelSwitchTimer(void);
+   void AddDelRemoteTimer(void);
    void Draw(void);
 };
 
@@ -2523,11 +2900,15 @@
    gridTime(NULL),
    gridDate(NULL),
    eventTitle(NULL),
+   eventInfo(NULL),
    eventTime(NULL),
    eventDesc(NULL),
    eventDate(NULL),
+   eventEpgImage(NULL),
    timeLine(NULL),
-   helpBar(NULL)
+   helpBar(NULL),
+   recordDlg(NULL),
+   messageBox(NULL)
 {
    memset(&mainWin, 0, sizeof(mainWin));
    chanVec.clear();
@@ -2543,10 +2924,15 @@
    delete gridDate;
    delete timeLine;
    delete eventTitle;
+   delete eventInfo;
    delete eventTime;
    delete eventDesc;
    delete eventDate;
+   if (eventEpgImage)
+      delete eventEpgImage;
    delete helpBar;
+   delete recordDlg;
+   delete messageBox;
 #ifdef YAEPGHD_REEL_EHD
    reelVidWin->Close();
 #endif
@@ -2581,6 +2967,7 @@
                          BG_IMAGE->Bpp());
    osd->SetAreas(&mainWin, 1);
 
+#ifdef YAEPGHDVERSNUM
    /* Set up the video window parameters */
    if (VID_WIN_GEOM.w != 0 && VID_WIN_GEOM.h != 0) {
       osd->vidWin.x1 = VID_WIN_GEOM.x;
@@ -2589,6 +2976,7 @@
       osd->vidWin.y2 = VID_WIN_GEOM.y + VID_WIN_GEOM.h;
       osd->vidWin.bpp = 12;
    }
+#endif
 
 #ifdef YAEPGHD_REEL_EHD
    reelVidWin->Open(VID_WIN_GEOM);
@@ -2605,20 +2993,218 @@
    timeLine = new cYaepgTimeLine(t);
    const cEvent *e = gridEvents->Event();
    eventTitle = new cYaepgEventTitle(e);
+   eventInfo = new cYaepgEventInfo(e);
    eventTime = new cYaepgEventTime(e);
    eventDesc = new cYaepgEventDesc(e);
    eventDate = new cYaepgEventDate();
+   if (iEpgImages)
+      eventEpgImage = new cYaepgEventEpgImage(e);
    helpBar = new cYaepgHelpBar();
-
-   Draw();
+   recordDlg = NULL;
+   messageBox = NULL;
+   
+   if (iRemoteTimer && pRemoteTimers) {
+      cString errorMsg;
+      if (!pRemoteTimers->Service("RemoteTimers::RefreshTimers-v1.0", &errorMsg)) {
+         messageBox = new cYaepgMsg();
+         messageBox->UpdateMsg((char*)*errorMsg);
+         msgBoxStart = cTimeMs::Now();
+      }
+   }
+
+   Draw(); 
+}
+
+void
+cYaepghd::AddDelTimer(void)
+ {
+      const cEvent *event=gridEvents->Event();
+	  int timerMatch;
+	  cTimer *ti;
+	  ti=Timers.GetMatch(event, &timerMatch);
+	  if (timerMatch==tmFull)
+	  {
+         if (ti) 
+		 {
+            ti->OnOff();
+		 }   
+      }
+	  else
+	  {
+         cTimer *timer = new cTimer(event);
+         cTimer *t = Timers.GetTimer(timer);
+         if (t) {
+            t->OnOff();
+            delete timer;
+         }
+         else {
+            Timers.Add(timer);
+	     }
+      }
+      Timers.SetModified();
+      eventInfo->UpdateEvent(event);     
+ }
+
+void 
+cYaepghd::AddDelSwitchTimer()
+{
+	const cEvent *event = gridEvents->Event();
+	bool SwitchTimerExits = false;
+    if (pEPGSearch && event) {
+	   Epgsearch_switchtimer_v1_0* serviceData = new Epgsearch_switchtimer_v1_0;
+	   serviceData->event = event;
+	   serviceData->mode = 0;
+       if (pEPGSearch->Service("Epgsearch-switchtimer-v1.0", serviceData)){
+          SwitchTimerExits=serviceData->success;
+          delete serviceData;
+       } 
+       else {
+          delete serviceData;
+	      YAEPG_ERROR("Epgsearch-switchtimer-v1.0: EPGSearch does not support this service!");
+	      return;
+	   }   
+       if (!SwitchTimerExits) {
+          serviceData = new Epgsearch_switchtimer_v1_0;
+	      serviceData->event = event;
+	      serviceData->mode = 1;
+	      serviceData->switchMinsBefore = iSwitchMinsBefore;	 
+	      serviceData->announceOnly = false;
+          if (pEPGSearch->Service("Epgsearch-switchtimer-v1.0", serviceData)){
+             if (serviceData->success) {
+  	 	        messageBox = new cYaepgMsg();
+        	    const char *msgtext;
+	            msgtext = tr("Switch timer added");
+	            messageBox->UpdateMsg(msgtext);
+	            msgBoxStart = cTimeMs::Now();
+         	    needsRedraw = true; 
+    	        delete serviceData;
+    	     }   
+    	  }   
+    	  else {
+		     delete serviceData;
+	         YAEPG_ERROR("Epgsearch-switchtimer-v1.0: EPGSearch does not support this service!");
+	         return;
+	      }   
+    	}
+        else {
+       	   serviceData = new Epgsearch_switchtimer_v1_0;
+	       serviceData->event = event;
+	       serviceData->mode = 2;
+           if (pEPGSearch->Service("Epgsearch-switchtimer-v1.0", serviceData)){
+              if (serviceData->success) {
+				 messageBox = new cYaepgMsg();
+                 const char *msgtext;
+	             msgtext = tr("Switch timer deleted");
+	             messageBox->UpdateMsg(msgtext);
+	             msgBoxStart = cTimeMs::Now();
+         	     needsRedraw = true; 
+    	         delete serviceData;
+    	      }   
+		   }
+    	   else {
+		      delete serviceData;
+	          YAEPG_ERROR("Epgsearch-switchtimer-v1.0: EPGSearch does not support this service!");
+	          return;
+	       }    
+	    }   
+    }
+    else { 
+	   YAEPG_ERROR("EPGSearch does not exist!");
+    }
+}
+
+void 
+cYaepghd::AddDelRemoteTimer()
+{
+   const cEvent *event=gridEvents->Event();
+   if (pRemoteTimers) {
+      RemoteTimers_GetMatch_v1_0 rtMatch;
+      rtMatch.event = event;
+      pRemoteTimers->Service("RemoteTimers::GetMatch-v1.0", &rtMatch);
+      if (rtMatch.timerMatch == tmFull) {
+         if (rtMatch.timer) {
+            rtMatch.timer->OnOff();
+            RemoteTimers_Timer_v1_0 rt;
+            rt.timer = rtMatch.timer;
+            if (!pRemoteTimers->Service("RemoteTimers::ModTimer-v1.0", &rt)) {
+               messageBox = new cYaepgMsg();
+               messageBox->UpdateMsg((char*)*rt.errorMsg);
+               msgBoxStart = cTimeMs::Now();
+               needsRedraw = true;
+            }
+         }
+      }
+      else {
+         cTimer *timer = new cTimer(event);
+         RemoteTimers_Timer_v1_0 rt;
+         rt.timer = timer;
+         pRemoteTimers->Service("RemoteTimers::GetTimer-v1.0", &rt.timer);
+         if (rt.timer) {
+            rt.timer->OnOff();
+            if (!pRemoteTimers->Service("RemoteTimers::ModTimer-v1.0", &rt)) {
+               messageBox = new cYaepgMsg();
+               messageBox->UpdateMsg((char*)*rt.errorMsg);
+               msgBoxStart = cTimeMs::Now();
+               needsRedraw = true;
+            }
+            delete timer;
+         }
+         else {
+            rt.timer = timer;
+            if (!pRemoteTimers->Service("RemoteTimers::NewTimer-v1.0", &rt)) {
+               messageBox = new cYaepgMsg();
+               messageBox->UpdateMsg((char*)*rt.errorMsg);
+               msgBoxStart = cTimeMs::Now();
+               needsRedraw = true;
+            }
+         }
+      }
+      eventInfo->UpdateEvent(event);
+   }
 }
 
+
 eOSState
 cYaepghd::ProcessKey(eKeys key)
 {
    eOSState state = cOsdObject::ProcessKey(key);
-
+     
    needsRedraw = false;
+   
+   if (recordDlg != NULL && state == osUnknown) {
+	  state=recordDlg->ProcessKey(key);
+	  if (state == osContinue) {
+	       needsRedraw = true;
+      }
+      switch (key & ~k_Repeat) {
+      case kOk:
+      {
+         const char *msgtext;
+         msgtext = recordDlg->AddTimer() ? tr("Timer added") : tr("Failed to add timer");
+         delete recordDlg;
+	     recordDlg = NULL;
+	     messageBox = new cYaepgMsg();
+	     messageBox->UpdateMsg(msgtext);
+	     msgBoxStart = cTimeMs::Now();
+	     eventInfo->UpdateEvent(event);     
+	     needsRedraw = true;
+         state = osContinue;
+	     break;
+	  } 
+      case kBack:
+      {
+         delete recordDlg;
+	     recordDlg = NULL;
+	     needsRedraw = true;
+         state = osContinue;
+	     break;
+	  }   
+      default:
+         state = osContinue;
+	     break;
+       }
+   }
+   
    if (state == osUnknown) {
       switch (key & ~k_Repeat) {
       case kBack:
@@ -2651,14 +3237,106 @@
          state = osContinue;
          break;
       case kOk:
-         SwitchToCurrentChannel(true);
-         if (iChannelChange == CHANNEL_CHANGE_SEMIAUTOMATIC)
+         if (iSwitchOK){
+            SwitchToCurrentChannel(true);
+            if (iChannelChange == CHANNEL_CHANGE_OPEN)
+               state = osContinue;
+            else
+               state = osEnd;
+		 }
+         else{
+		    int timerMatch;
+			Timers.GetMatch(event, &timerMatch);
+		    if (!(timerMatch==tmFull)){
+				
+	           if (iRemoteTimer && pRemoteTimers) {
+                  RemoteTimers_Event_v1_0 rtEvent;
+                  rtEvent.event = event;
+                  pRemoteTimers->Service("RemoteTimers::GetTimerByEvent-v1.0", &rtEvent);
+                  if (!(rtEvent.timer)){
+                     recordDlg = new cYaepgRecDlg();
+	                 recordDlg->UpdateEvent(gridEvents->Event());
+		          }
+		          else{
+		             AddDelRemoteTimer();  // delete remote timer
+		             pRemoteTimers->Service("RemoteTimers::GetTimerByEvent-v1.0", &rtEvent);
+                     if (!(rtEvent.timer)) {
+			            messageBox = new cYaepgMsg();
+                        messageBox->UpdateMsg(tr("Remote timer deactivated"));
+                        msgBoxStart = cTimeMs::Now();
+                        needsRedraw = true;
+			         }
+			      }
+  	           }       
+  	           else {
+                  recordDlg = new cYaepgRecDlg();
+	              recordDlg->UpdateEvent(gridEvents->Event());				   
+  	           }
+		    }
+ 	        else {
+			   AddDelTimer();  // delete timer
+			   int timerMatch;
+			   Timers.GetMatch(event, &timerMatch);
+               if (timerMatch==tmNone){	
+			      messageBox = new cYaepgMsg();
+                  messageBox->UpdateMsg(tr("Timer deactivated"));
+                  msgBoxStart = cTimeMs::Now();
+                  needsRedraw = true;
+			   }
+            }
+            needsRedraw = true;	           
             state = osContinue;
-         else
-            state = osEnd;
-         break;
+         }  
+		 break;
       case kRed:
-         cDevice::PrimaryDevice()->GrabImageFile("yaepghd.jpg", true, 256, -1, -1);
+         if (event && event->EventID()!=0){
+            if (iRecDlgRed) {
+               int timerMatch;
+			   Timers.GetMatch(event, &timerMatch);
+               if (!(timerMatch==tmFull)){				
+	              if (iRemoteTimer && pRemoteTimers) {
+                     RemoteTimers_Event_v1_0 rtEvent;
+                     rtEvent.event = event;
+                     pRemoteTimers->Service("RemoteTimers::GetTimerByEvent-v1.0", &rtEvent);
+                     if (!(rtEvent.timer)){
+                        recordDlg = new cYaepgRecDlg();
+	                    recordDlg->UpdateEvent(gridEvents->Event());
+		             }
+		             else{
+		                AddDelRemoteTimer();  // delete remote timer
+		                pRemoteTimers->Service("RemoteTimers::GetTimerByEvent-v1.0", &rtEvent);
+                        if (!(rtEvent.timer)) {
+			               messageBox = new cYaepgMsg();
+                           messageBox->UpdateMsg(tr("Remote timer deactivated"));
+                           msgBoxStart = cTimeMs::Now();
+                           needsRedraw = true;
+			            }
+			         }
+  	              }       
+  	              else {
+                     recordDlg = new cYaepgRecDlg();
+	                 recordDlg->UpdateEvent(gridEvents->Event());				   
+  	              }
+		       }
+ 	           else {
+			      AddDelTimer();  // delete timer
+			      int timerMatch;
+			      Timers.GetMatch(event, &timerMatch);
+                  if (timerMatch==tmNone){	
+			         messageBox = new cYaepgMsg();
+                     messageBox->UpdateMsg(tr("Timer deactivated"));
+                     msgBoxStart = cTimeMs::Now();
+			      }
+               }
+            }  
+            else { 
+               if (iRemoteTimer && pRemoteTimers)
+			      AddDelRemoteTimer(); 
+			   else
+	              AddDelTimer(); 
+		    }
+		    needsRedraw = true;
+		 }   
          state = osContinue;
          break;
       case kGreen:
@@ -2672,16 +3350,41 @@
          state = osContinue;
          break;
       case kBlue:
-         SwitchToCurrentChannel();
-         state = osContinue;
-         break;
+         if (iSwitchTimer && pEPGSearch){
+            if (event && (event->EventID() != 0)){
+               if (event->IsRunning(true)){
+	              SwitchToCurrentChannel(true);
+                  if (iChannelChange == CHANNEL_CHANGE_OPEN)
+                     state = osContinue;
+                  else
+                     state = osEnd;
+	           } 
+	           else if (iSwitchTimer){ 
+	              AddDelSwitchTimer(); 
+	              needsRedraw = true;
+	              state = osContinue;
+	           }
+		    }
+		 }
+		 else {
+         SwitchToCurrentChannel(true);
+            if (iChannelChange == CHANNEL_CHANGE_OPEN )
+              state = osContinue;
+            else
+               state = osEnd;
+		 }
+  	     break;
       case kFastFwd:
+         // +24 hours
+         UpdateTime(+86400); 
+         needsRedraw = true;
          state = osContinue;
-         // +12 hours
-         break;
+	     break;
       case kFastRew:
+         // -24 hours
+         UpdateTime(-86400);
+	     needsRedraw = true;
          state = osContinue;
-         // -12 hours
          break;
       case k0 ... k9:
          if (directChan || (key != k0)) {
@@ -2734,6 +3437,12 @@
          SetTime(now);
       }
    }
+   
+   if (messageBox != NULL && (cTimeMs::Now() - msgBoxStart) > 1000) {
+       delete messageBox;
+       messageBox = NULL;
+       needsRedraw = true;
+   }    
 
    /* Redraw the screen if needed */
    if (needsRedraw) {
@@ -2852,8 +3561,11 @@
    }
    event = newEvent;
    eventTitle->UpdateEvent(event);
+   eventInfo->UpdateEvent(event);
    eventTime->UpdateEvent(event);
    eventDesc->UpdateEvent(event);
+   if (iEpgImages)
+      eventEpgImage->UpdateEvent(event);
 }
 
 void
@@ -2863,14 +3575,6 @@
 
    if (gridChan && (gridChan->Number() != cDevice::CurrentChannel())) {
       /*
-       * The "Channel not availaible message" will cause vdr to crash. Do a
-       * "lower level" channel switch to avoid the error message.
-       *
-       * XXX Is this still true ? XXX
-       */
-      eSetChannelResult ret;
-
-      /*
        * The eHD card doesn't seem to like changing channels while the video
        * plane is sacled down.  To get around this problem we close/reopen the
        * video window across channel changes.
@@ -2880,10 +3584,7 @@
       cCondWait::SleepMs(100);
 #endif
 
-      ret = cDevice::PrimaryDevice()->SetChannel(gridChan, true);
-      if (ret != scrOk) {
-         fprintf(stderr, "SetChannel(): %d\n", ret);
-      }
+      Channels.SwitchTo(gridChan->Number());
 
 #ifdef YAEPGHD_REEL_EHD
       if (closeVidWin == false) {
@@ -2933,11 +3634,20 @@
    gridDate->Draw(mainBmp);
    timeLine->Draw(mainBmp);
    eventTitle->Draw(mainBmp);
+   eventInfo->Draw(mainBmp);
    eventTime->Draw(mainBmp);
    eventDesc->Draw(mainBmp);
    eventDate->Draw(mainBmp);
+   if (iEpgImages)
+      eventEpgImage->Draw(mainBmp);
    helpBar->Draw(mainBmp);
-
+   if (recordDlg != NULL) {
+       recordDlg->Draw(mainBmp);
+   }
+   if (messageBox != NULL) {
+       messageBox->Draw(mainBmp);
+   }  
+   
    osd->DrawBitmap(0, 0, *mainBmp);
    osd->Flush();
 }
@@ -2950,16 +3660,32 @@
 class cMenuSetupYaepg : public cMenuSetupPage {
 private:
    int iNewHideMenuEntry;
+   char sNewMainMenuEntry[MaxFileName];
+#if defined(MAINMENUHOOKSVERSION) 
+#if MAINMENUHOOKSVERSNUM >= 10001
    int iNewReplaceOrgSchedule;
+#endif
+#endif
    int iNewChannelChange;
+   int iNewSwitchOK;
+   int iNewRecDlgRed;
    int iNewTimeFormat;
    int iNewChannelOrder;
+   int iNewChannelNumber;
+   int iNewInfoSymbols;
+   int iNewSwitchTimer;
+   int iNewSwitchMinsBefore;
+   int iNewRemoteTimer;
+   int iNewEpgImages;
+   int iNewResizeImages;
+   int iNewImageExtension;
    int iNewThemeIndex;
    char **themes;
    int numThemes;
    const char *TIME_FORMATS[TIME_FORMAT_COUNT];
    const char *CH_ORDER_FORMATS[CHANNEL_ORDER_COUNT];
    const char *CH_CHANGE_MODES[CHANNEL_CHANGE_COUNT];
+   const char *resizeImagesTexts[3];
    
 protected:
    virtual void Store(void);
@@ -2973,17 +3699,53 @@
 void cMenuSetupYaepg::Store(void)
 {
    iHideMenuEntry      = iNewHideMenuEntry;
+ #if defined(MAINMENUHOOKSVERSION) 
+ #if MAINMENUHOOKSVERSNUM >= 10001
    iReplaceOrgSchedule = iNewReplaceOrgSchedule;
+ #endif
+ #endif
    iChannelChange      = iNewChannelChange;
+   iSwitchOK           = iNewSwitchOK;  
+   iRecDlgRed          = iNewRecDlgRed;
    iTimeFormat         = iNewTimeFormat;
    iChannelOrder       = iNewChannelOrder;
+   iChannelNumber      = iNewChannelNumber;
+   iInfoSymbols        = iNewInfoSymbols;
+   iSwitchTimer        = iNewSwitchTimer;
+   iRemoteTimer        = iNewRemoteTimer;
+   iEpgImages          = iNewEpgImages;
+   iResizeImages       = iNewResizeImages;
+   iImageExtension  = iNewImageExtension;
+   iSwitchMinsBefore = iNewSwitchMinsBefore;
    sThemeName          = themes[iNewThemeIndex];
+   
+   if (strcmp(sMainMenuEntry, tr("YaepgHD")) == 0) {
+      strcpy(sMainMenuEntry,"");
+   }
+   else{
+      strcpy(sMainMenuEntry,sNewMainMenuEntry);
+   }
 
    SetupStore("HideMenuEntry",      iHideMenuEntry);
+   SetupStore("MainMenuEntry",      sMainMenuEntry);
+ #if defined(MAINMENUHOOKSVERSION) 
+ #if MAINMENUHOOKSVERSNUM >= 10001
    SetupStore("ReplaceOrgSchedule", iReplaceOrgSchedule);
+ #endif
+ #endif
    SetupStore("ChannelChange",      iChannelChange);
+   SetupStore("SwitchOk",           iSwitchOK);
+   SetupStore("RecDlgRed",           iRecDlgRed);
    SetupStore("TimeFormat",         iTimeFormat);
    SetupStore("ChannelOrder",       iChannelOrder);
+   SetupStore("ChannelNumber",      iChannelNumber);
+   SetupStore("InfoSymbols",        iInfoSymbols);
+   SetupStore("SwitchTimer",        iSwitchTimer);
+   SetupStore("SwitchMinsBefore",   iSwitchMinsBefore);
+   SetupStore("RemoteTimer",        iRemoteTimer);
+   SetupStore("EpgImages",          iEpgImages);
+   SetupStore("ResizeImages",       iResizeImages);
+   SetupStore("ImageExtension",     iImageExtension);
    SetupStore("Theme",              sThemeName.c_str());
 }
 
@@ -2995,9 +3757,13 @@
    CH_ORDER_FORMATS[CHANNEL_ORDER_UP]   = tr("Up");
    CH_ORDER_FORMATS[CHANNEL_ORDER_DOWN] = tr("Down");
 
-   CH_CHANGE_MODES[CHANNEL_CHANGE_MANUAL]        = tr("Manual");
-   CH_CHANGE_MODES[CHANNEL_CHANGE_SEMIAUTOMATIC] = tr("Semi-automatic");
+   CH_CHANGE_MODES[CHANNEL_CHANGE_CLOSE]        = tr("Close YaepgHD");
+   CH_CHANGE_MODES[CHANNEL_CHANGE_OPEN] = tr("Leave YaepgHD open");
    CH_CHANGE_MODES[CHANNEL_CHANGE_AUTOMATIC]     = tr("Automatic");
+   
+   resizeImagesTexts[0] = tr("pixel algo");
+   resizeImagesTexts[1] = tr("ratio algo");
+   resizeImagesTexts[2] = tr("zoom image");
 
    cYaepgTheme::Themes(&themes, &numThemes);
    iNewThemeIndex = 0;
@@ -3010,19 +3776,73 @@
    } else {
       iNewThemeIndex = 0;
    }
+   
+   strcpy(sNewMainMenuEntry,sMainMenuEntry);
+  if (isempty(sNewMainMenuEntry)){
+     strcpy(sNewMainMenuEntry,tr("YaepgHD"));
+  }   
+
 
    iNewHideMenuEntry = iHideMenuEntry;
-   iNewChannelChange = iChannelChange;
-   iNewTimeFormat    = iTimeFormat;
-   iNewChannelOrder  = iChannelOrder;
+   #if defined(MAINMENUHOOKSVERSION) 
+   #if MAINMENUHOOKSVERSNUM >= 10001
    iNewReplaceOrgSchedule = iReplaceOrgSchedule;
+   #endif
+   #endif
+   iNewChannelChange   = iChannelChange;
+   iNewSwitchOK        = iSwitchOK; 
+   iNewRecDlgRed       = iRecDlgRed;
+   iNewTimeFormat      = iTimeFormat;
+   iNewChannelOrder    = iChannelOrder;
+   iNewChannelNumber   = iChannelNumber;
+   iNewInfoSymbols     = iInfoSymbols;
+   iNewSwitchTimer     = iSwitchTimer;
+   iNewRemoteTimer     = iRemoteTimer;
+   iNewEpgImages       = iEpgImages;
+   iNewResizeImages    = iResizeImages;
+   iNewImageExtension  = iImageExtension;
+   iNewSwitchMinsBefore= iSwitchMinsBefore;
 
    Add(new cMenuEditBoolItem (tr("Hide mainmenu entry"), &iNewHideMenuEntry));
+   Add(new cMenuEditStrItem(tr("Main menu entry"), sNewMainMenuEntry, sizeof(sNewMainMenuEntry),trVDR(FileNameChars)));
+   #if defined(MAINMENUHOOKSVERSION) 
+   #if MAINMENUHOOKSVERSNUM >= 10001
    Add(new cMenuEditBoolItem (tr("Replace original schedule"), &iNewReplaceOrgSchedule));
+   #endif
+   #endif
    Add(new cMenuEditStraItem (tr("Channel change"), &iNewChannelChange, CHANNEL_CHANGE_COUNT, CH_CHANGE_MODES));
+   Add(new cMenuEditBoolItem (tr("Switch channel with OK"), &iNewSwitchOK));
+   Add(new cMenuEditBoolItem (tr("Record dialog with red button"), &iNewRecDlgRed));
    Add(new cMenuEditStraItem (tr("Time format"), &iNewTimeFormat, TIME_FORMAT_COUNT, TIME_FORMATS));
    Add(new cMenuEditStraItem (tr("Channel order"), &iNewChannelOrder, CHANNEL_ORDER_COUNT, CH_ORDER_FORMATS));
-   Add(new cMenuEditStraItem (trVDR("Setup.OSD$Theme"), &iNewThemeIndex, numThemes, themes));
+   Add(new cMenuEditBoolItem (tr("Channel number"), &iNewChannelNumber));
+
+   if (iVDRSymbols){
+      Add(new cMenuEditBoolItem (tr("Info symbols"), &iNewInfoSymbols));
+   }
+   Add(new cMenuEditBoolItem (tr("EPG images"), &iNewEpgImages));
+   Add(new cMenuEditStraItem(tr("  Resize images"), &iNewResizeImages, 3, resizeImagesTexts));
+   Add(new cMenuEditStraItem(tr("  Image format"), &iNewImageExtension, 3, imageExtensionTexts));
+   
+   if (pEPGSearch) {
+      Add(new cMenuEditBoolItem (tr("Switch timer"), &iNewSwitchTimer)); 
+      Add(new cMenuEditIntItem( tr("  Switch ... minutes before start"), &iNewSwitchMinsBefore));
+   }
+   else {
+      YAEPG_INFO("EPGSearch not found (Switch Timer disabled)!");
+   }
+   if (pRemoteTimers) {
+      Add(new cMenuEditBoolItem (tr("Remote timer"), &iNewRemoteTimer)); 
+   }
+   else {
+      YAEPG_INFO("RemoteTimers not found (Remote Timer disabled)!");
+   }
+   
+   
+   
+   if (numThemes > 0) {
+      Add(new cMenuEditStraItem (trVDR("Setup.OSD$Theme"), &iNewThemeIndex, numThemes, themes));
+   }
 }
 
 cMenuSetupYaepg::~cMenuSetupYaepg()
@@ -3040,9 +3860,8 @@
  * cPluginYaepghd
  *****************************************************************************
  */
-static const char *VERSION        = "0.0.1";
+static const char *VERSION        = "0.0.3-ce";
 static const char *DESCRIPTION    = trNOOP("Yet another EPG in HD");
-static const char *MAINMENUENTRY  = trNOOP("YaepgHD");
 
 class cPluginYaepghd : public cPlugin {
 public:
@@ -3059,7 +3878,7 @@
    virtual void MainThreadHook(void);
    virtual cString Active(void);
    virtual time_t WakeupTime(void);
-   virtual const char *MainMenuEntry(void) { return tr(MAINMENUENTRY); }
+   virtual const char *MainMenuEntry(void);
    virtual cOsdObject *MainMenuAction(void);
    virtual cMenuSetupPage *SetupMenu(void);
    virtual bool SetupParse(const char *Name, const char *Value);
@@ -3084,14 +3903,40 @@
 cPluginYaepghd::CommandLineHelp(void)
 {
    // Return a string that describes all known command line options.
-   return NULL;
+     return 
+         "  -i <IMAGESDIR>, --epgimages=<IMAGESDIR> Set directory where epgimages are stored\n";
+}
+
+const char *cPluginYaepghd::MainMenuEntry(void)
+{
+   if (iHideMenuEntry)
+      return NULL;
+   if (isempty(sMainMenuEntry))
+      return tr("YaepgHD");
+   else
+      return sMainMenuEntry;   
 }
 
+
 bool
 cPluginYaepghd::ProcessArgs(int argc, char *argv[])
 {
    // Implement command line argument processing here if applicable.
-   return true;
+  static const struct option long_options[] = {
+    { "epgimages", required_argument, NULL, 'i' },
+    { 0, 0, 0, 0 }
+  };
+  int c;
+  while ((c = getopt_long(argc, argv, "i:", long_options, NULL)) != -1) {
+    switch (c) {
+      case 'i':
+        sEpgImagesDir=optarg;
+        break;
+      default:
+        return false;
+    }
+  }
+  return true;
 }
 
 bool
@@ -3110,6 +3955,16 @@
    reelVidWin = new cReelVidWin;
    reelVidWin->Init();
 #endif
+   Icons::InitCharSet();
+   pEPGSearch = cPluginManager::GetPlugin("epgsearch");
+   if (!pEPGSearch) {
+   	   YAEPG_ERROR("EPGSearch does not exist (switch timer disabled)!");
+   }
+
+   pRemoteTimers = cPluginManager::CallFirstService("RemoteTimers::RefreshTimers-v1.0", NULL);
+   if (!pRemoteTimers) {
+   	   YAEPG_ERROR("RemoteTimers does not exist!");
+   }
    return true;
 }
 
@@ -3169,9 +4024,25 @@
 
    // Parse your own setup parameters and store their values.
    if      (!strcasecmp(Name, "HideMenuEntry")) { iHideMenuEntry = atoi(Value); }
+   if      (!strcasecmp(Name, "MainMenuEntry")) { strcpy(sMainMenuEntry, Value); }
+   #if defined(MAINMENUHOOKSVERSION) 
+   #if MAINMENUHOOKSVERSNUM >= 10001
+   else if (!strcasecmp(Name, "ReplaceOrgSchedule")) { iReplaceOrgSchedule = atoi(Value); }
+   #endif 
+   #endif
    else if (!strcasecmp(Name, "ChannelChange")) { iChannelChange = atoi(Value); }
+   else if (!strcasecmp(Name, "SwitchOk")) { iSwitchOK = atoi(Value); }
+   else if (!strcasecmp(Name, "RecDlgRed")) { iRecDlgRed = atoi(Value); }
    else if (!strcasecmp(Name, "TimeFormat"))    { iTimeFormat = atoi(Value); }
    else if (!strcasecmp(Name, "ChannelOrder"))  { iChannelOrder = atoi(Value); }
+   else if (!strcasecmp(Name, "ChannelNumber")) { iChannelNumber = atoi(Value); }
+   else if (!strcasecmp(Name, "InfoSymbols"))   { iInfoSymbols = atoi(Value); }
+   else if (!strcasecmp(Name, "SwitchTimer"))   { iSwitchTimer = atoi(Value); }
+   else if (!strcasecmp(Name, "SwitchMinsBefore")){ iSwitchMinsBefore = atoi(Value); }
+   else if (!strcasecmp(Name, "RemoteTimer"))   { iRemoteTimer = atoi(Value); }
+   else if (!strcasecmp(Name, "EpgImages"))     { iEpgImages = atoi(Value); }
+   else if (!strcasecmp(Name, "ResizeImages"))    { iResizeImages = atoi(Value); }
+   else if (!strcasecmp(Name, "ImageExtension"))  { iImageExtension = atoi(Value); }
    else if (!strcasecmp(Name, "Theme"))         { Utf8Strn0Cpy(themeName, Value, sizeof(themeName)); sThemeName = themeName; }
    else                                         { return false; }
 
@@ -3181,18 +4052,21 @@
 bool
 cPluginYaepghd::Service(const char *Id, void *Data)
 {
-   if (strcmp(Id, "MainMenuHooksPatch-v1.0::osSchedule") == 0 && iReplaceOrgSchedule)
+#if defined(MAINMENUHOOKSVERSION) 
+#if MAINMENUHOOKSVERSNUM >= 10001
+   if (strcmp(Id, "MainMenuHooksPatch-v1.0::osSchedule") == 0  && iReplaceOrgSchedule)
    {
       if (!Data) {
          return true;
       }
-      cOsdMenu **menu = (cOsdMenu**)Data;
-      if (menu) {
-         *menu = (cOsdMenu*)MainMenuAction();
+      cOsdObject **osd = (cOsdObject**)Data;
+      if (osd) {
+         *osd = (cOsdObject*)MainMenuAction();
       }
       return true;
    }
-
+#endif
+#endif
    return false;
 }
 
