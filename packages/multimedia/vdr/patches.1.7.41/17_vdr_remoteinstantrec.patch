diff -urN vdr-1.7.40.orig/config.h vdr-1.7.40/config.h
--- vdr-1.7.40.orig/config.h	2013-03-10 21:03:58.572168478 +0100
+++ vdr-1.7.40/config.h	2013-03-10 21:04:48.904169344 +0100
@@ -33,6 +33,8 @@
 // When loading plugins, VDR searches them by their APIVERSION, which
 // may be smaller than VDRVERSION in case there have been no changes to
 // VDR header files since the last APIVERSION. This allows compiled
+#define REMOTEINSTANTVERSION 1.0
+
 // plugins to work with newer versions of the core VDR as long as no
 // VDR header files have changed.
 
diff -urN vdr-1.7.40.orig/menu.c vdr-1.7.40/menu.c
--- vdr-1.7.40.orig/menu.c	2013-03-10 21:03:58.564168476 +0100
+++ vdr-1.7.40/menu.c	2013-03-10 21:04:48.912169342 +0100
@@ -34,6 +34,8 @@
 #include "transfer.h"
 #include "videodir.h"
 
+#include "remotetimers.h"
+
 #define MAXWAIT4EPGINFO   3 // seconds
 #define MODETIMEOUT       3 // seconds
 #define NEWTIMERLIMIT   120 // seconds until the start time of a new timer created from the Schedule menu,
@@ -4523,6 +4525,50 @@
 
 bool cRecordControls::Start(cTimer *Timer, bool Pause, bool* reused)
 {
+  if (!Timer) {
+     cTimer *t = new cTimer(true, Pause);
+
+     //get event
+     cSchedulesLock SchedulesLock;
+     const cEvent *event = NULL;;
+    const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
+     if (Schedules) {
+        const cSchedule *Schedule = Schedules->GetSchedule(t->Channel());
+        if (Schedule) {
+           event = Schedule->GetEventAround(t->StartTime() + INSTANT_REC_EPG_LOOKAHEAD);
+       }
+     }
+
+     if (cPluginManager::GetPlugin("timersync")) {
+        // sets the file name
+        cRecording recording(t, event);
+        Timers.Add(t);
+        Timers.SetModified();
+        if (!cReplayControl::LastReplayed())
+           cReplayControl::SetRecording(recording.FileName());
+       return true;
+     }
+     else {
+        RemoteTimers_InstantRecording_v1_0 ir;
+        ir.timer = t;
+        ir.pause = Pause;
+        ir.event = event;
+        ir.name = NULL;
+       ir.fileName = NULL;
+
+        if (cPluginManager::CallFirstService("RemoteTimers::InstantRecording-v1.0", &ir)) {
+           if (!cReplayControl::LastReplayed())
+              cReplayControl::SetRecording(ir.fileName);
+         delete t;
+         // empty names indicate an error
+         return *ir.fileName && *ir.name;
+        }
+        // service disabled or an error occured and the user confirmed local recording
+        // fall through to local instant recording
+     }
+     delete t;
+  }
+
   static time_t LastNoDiskSpaceMessage = 0;
   int FreeMB = 0;
   if (Timer) {
diff -urN vdr-1.7.40.orig/remotetimers.h vdr-1.7.40/remotetimers.h
--- vdr-1.7.40.orig/remotetimers.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.40/remotetimers.h	2013-03-10 21:04:48.912169342 +0100
@@ -0,0 +1,25 @@
+/*
+ * remotetimers.h: Public interface of the plugin's services
+ *
+ * See the README file for copyright information and how to reach the author.
+ */
+
+#ifndef _SERVICE__H
+#define _SERVICE__H
+
+#ifndef __TIMERS_H
+#include <vdr/timer.h>
+#include <vdr/epg.h>
+#endif
+
+struct RemoteTimers_InstantRecording_v1_0 {
+//in
+	const cTimer	*timer;
+	bool		pause;
+	const cEvent	*event;
+//out
+	cString		name;
+	cString		fileName;
+};
+
+#endif //_SERVICE__H
