diff -urN vdr-2.0.1/channels.c vdr-2.0.1.reel/channels.c
--- vdr-2.0.1/channels.c	2012-07-14 14:34:47.000000000 +0200
+++ vdr-2.0.1.reel/channels.c	2013-05-09 18:09:51.267874141 +0200
@@ -408,11 +408,34 @@
      }
 }
 
+void cChannel::SetTeletextSubtitlePages(tTeletextSubtitlePage pages[], int numberOfPages)
+{
+  int mod = CHANNELMOD_NONE;
+  if (totalTtxtSubtitlePages != (fixedTtxtSubtitlePages + numberOfPages))
+     mod |= CHANNELMOD_PIDS;
+  totalTtxtSubtitlePages = fixedTtxtSubtitlePages;
+  for (int i = 0; (i < numberOfPages) && (totalTtxtSubtitlePages < MAXTXTPAGES); i++) {
+      if (teletextSubtitlePages[totalTtxtSubtitlePages].ttxtMagazine != pages[i].ttxtMagazine ||
+          teletextSubtitlePages[totalTtxtSubtitlePages].ttxtPage != pages[i].ttxtPage ||
+          teletextSubtitlePages[totalTtxtSubtitlePages].ttxtType != pages[i].ttxtType ||
+          strcmp(teletextSubtitlePages[totalTtxtSubtitlePages].ttxtLanguage, pages[i].ttxtLanguage)) {
+         mod |= CHANNELMOD_PIDS;
+         teletextSubtitlePages[totalTtxtSubtitlePages] = pages[i];
+         }
+      totalTtxtSubtitlePages++;
+      }
+  modification |= mod;
+  Channels.SetModified();
+}
+
 void cChannel::SetCaIds(const int *CaIds)
 {
   if (caids[0] && caids[0] <= CA_USER_MAX)
      return; // special values will not be overwritten
   if (IntArraysDiffer(caids, CaIds)) {
+#ifdef USE_MCLI
+     bool fta_chg = ((0==caids[0]) || (CA_ENCRYPTED_MAX==caids[0])) != ((0==CaIds[0]) || (CA_ENCRYPTED_MAX==CaIds[0]));
+#endif /*USE_MCLI*/
      char OldCaIdsBuf[MAXCAIDS * 5 + 10]; // 5: 4 digits plus delimiting ',', 10: paranoia
      char NewCaIdsBuf[MAXCAIDS * 5 + 10];
      IntArrayToString(OldCaIdsBuf, caids, 16);
@@ -425,6 +448,9 @@
             break;
          }
      modification |= CHANNELMOD_CA;
+#ifdef USE_MCLI
+     if(fta_chg) modification |= CHANNELMOD_RETUNE; // Not correct, but we need to force a retune for mcli here (and avoid it if only ca changed)
+#endif /*USE_MCLI*/
      Channels.SetModified();
      }
 }
@@ -536,10 +562,17 @@
         q += IntArrayToString(q, Channel->dpids, 10, Channel->dlangs, Channel->dtypes);
         }
      *q = 0;
-     const int TBufferSize = MAXSPIDS * (5 + 1 + MAXLANGCODE2) + 10; // 5 digits plus delimiting ',' or ';' plus optional '=cod+cod', +10: paranoia and tpid
+     const int TBufferSize = (MAXTXTPAGES * MAXSPIDS) * (5 + 1 + MAXLANGCODE2) + 10; // 5 digits plus delimiting ',' or ';' plus optional '=cod+cod', +10: paranoia and tpid
      char tpidbuf[TBufferSize];
      q = tpidbuf;
      q += snprintf(q, sizeof(tpidbuf), "%d", Channel->tpid);
+     if (Channel->fixedTtxtSubtitlePages > 0) {
+        *q++ = '+';
+        for (int i = 0; i < Channel->fixedTtxtSubtitlePages; ++i) {
+            tTeletextSubtitlePage page = Channel->teletextSubtitlePages[i];
+            q += snprintf(q, sizeof(tpidbuf) - (q - tpidbuf), "%d=%s", page.PageNumber(), page.ttxtLanguage);
+            }
+        }
      if (Channel->spids[0]) {
         *q++ = ';';
         q += IntArrayToString(q, Channel->spids, 10, Channel->slangs);
@@ -710,6 +743,32 @@
                     }
               spids[NumSpids] = 0;
               }
+           fixedTtxtSubtitlePages = 0;
+           if ((p = strchr(tpidbuf, '+')) != NULL) {
+              *p++ = 0;
+              char *q;
+              char *strtok_next;
+              while ((q = strtok_r(p, ",", &strtok_next)) != NULL) {
+                    if (fixedTtxtSubtitlePages < MAXTXTPAGES) {
+                       int page;
+                       char *l = strchr(q, '=');
+                       if (l)
+                          *l++ = 0;
+                       if (sscanf(q, "%d", &page) == 1) {
+                          teletextSubtitlePages[fixedTtxtSubtitlePages] = tTeletextSubtitlePage(page);
+                          if (l)
+                             strn0cpy(teletextSubtitlePages[fixedTtxtSubtitlePages].ttxtLanguage, l, MAXLANGCODE2);
+                          fixedTtxtSubtitlePages++;
+                          }
+                       else
+                          esyslog("ERROR: invalid Teletext page!"); // no need to set ok to 'false'
+                       }
+                    else
+                       esyslog("ERROR: too many Teletext pages!"); // no need to set ok to 'false'
+                    p = NULL;
+                    }
+              totalTtxtSubtitlePages = fixedTtxtSubtitlePages;
+              }
            if (sscanf(tpidbuf, "%d", &tpid) != 1)
               return false;
            if (caidbuf) {
diff -urN vdr-2.0.1/channels.h vdr-2.0.1.reel/channels.h
--- vdr-2.0.1/channels.h	2012-06-17 13:21:33.000000000 +0200
+++ vdr-2.0.1.reel/channels.h	2013-05-09 18:09:51.267874141 +0200
@@ -35,6 +35,7 @@
 #define MAXDPIDS 16 // dolby (AC3 + DTS)
 #define MAXSPIDS 32 // subtitles
 #define MAXCAIDS 12 // conditional access
+#define MAXTXTPAGES 8 // teletext pages
 
 #define MAXLANGCODE1 4 // a 3 letter language code, zero terminated
 #define MAXLANGCODE2 8 // up to two 3 letter language codes, separated by '+' and zero terminated
@@ -47,6 +48,13 @@
 #define CA_ENCRYPTED_MIN 0x0100
 #define CA_ENCRYPTED_MAX 0xFFFF
 
+#ifdef USE_MCLI
+#define CA_MCLI_LOWER       (CA_USER_MIN+1)
+#define CA_MCLI_UPPER       (CA_USER_MIN+2)
+#define CA_MCLI_MIN         CA_MCLI_LOWER
+#define CA_MCLI_MAX         CA_MCLI_UPPER
+#endif /*USE_MCLI*/
+
 struct tChannelID {
 private:
   int source;
@@ -71,6 +79,16 @@
   static const tChannelID InvalidID;
   };
 
+struct tTeletextSubtitlePage {
+  tTeletextSubtitlePage(void) { ttxtPage = ttxtMagazine = 0; ttxtType = 0x02; strcpy(ttxtLanguage, "und"); }
+  tTeletextSubtitlePage(int page) { ttxtMagazine = (page / 100) & 0x7; ttxtPage = (((page % 100) / 10) << 4) + (page % 10); ttxtType = 0x02; strcpy(ttxtLanguage, "und"); }
+  char ttxtLanguage[MAXLANGCODE1];
+  uchar ttxtPage;
+  uchar ttxtMagazine;
+  uchar ttxtType;
+  int PageNumber(void) const { return BCDCHARTOINT(ttxtMagazine) * 100 + BCDCHARTOINT(ttxtPage); }
+  };
+
 class cChannel;
 
 class cLinkChannel : public cListObject {
@@ -115,6 +133,9 @@
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   int tpid;
+  int fixedTtxtSubtitlePages;
+  int totalTtxtSubtitlePages;
+  tTeletextSubtitlePage teletextSubtitlePages[MAXTXTPAGES];
   int caids[MAXCAIDS + 1]; // list is zero-terminated
   int nid;
   int tid;
@@ -166,6 +187,8 @@
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
   int Tpid(void) const { return tpid; }
+  const tTeletextSubtitlePage *TeletextSubtitlePages() const { return teletextSubtitlePages; }
+  int TotalTeletextSubtitlePages() const { return totalTtxtSubtitlePages; }
   const int *Caids(void) const { return caids; }
   int Ca(int Index = 0) const { return Index < MAXCAIDS ? caids[Index] : 0; }
   int Nid(void) const { return nid; }
@@ -192,6 +215,7 @@
   void SetName(const char *Name, const char *ShortName, const char *Provider);
   void SetPortalName(const char *PortalName);
   void SetPids(int Vpid, int Ppid, int Vtype, int *Apids, int *Atypes, char ALangs[][MAXLANGCODE2], int *Dpids, int *Dtypes, char DLangs[][MAXLANGCODE2], int *Spids, char SLangs[][MAXLANGCODE2], int Tpid);
+  void SetTeletextSubtitlePages(tTeletextSubtitlePage pages[], int numberOfPages);
   void SetCaIds(const int *CaIds); // list must be zero-terminated
   void SetCaDescriptors(int Level);
   void SetLinkChannels(cLinkChannels *LinkChannels);
diff -urN vdr-2.0.1/ci.c vdr-2.0.1.reel/ci.c
--- vdr-2.0.1/ci.c	2013-02-17 14:17:28.000000000 +0100
+++ vdr-2.0.1.reel/ci.c	2013-05-09 18:09:51.271874143 +0200
@@ -1914,6 +1914,8 @@
          AddPid(Channel->Sid(), *Dpid, STREAM_TYPE_PRIVATE);
      for (const int *Spid = Channel->Spids(); *Spid; Spid++)
          AddPid(Channel->Sid(), *Spid, STREAM_TYPE_PRIVATE);
+     if (Channel->Tpid() && Setup.SupportTeletext)
+        AddPid(Channel->Sid(), Channel->Tpid(), STREAM_TYPE_PRIVATE);
      }
 }
 
@@ -1937,6 +1939,8 @@
          CaPmt.AddPid(*Dpid, STREAM_TYPE_PRIVATE);
      for (const int *Spid = Channel->Spids(); *Spid; Spid++)
          CaPmt.AddPid(*Spid, STREAM_TYPE_PRIVATE);
+     if (Channel->Tpid() && Setup.SupportTeletext)
+        CaPmt.AddPid(Channel->Tpid(), STREAM_TYPE_PRIVATE);
      cas->SendPMT(&CaPmt);
      cTimeMs Timeout(QUERY_REPLY_TIMEOUT);
      do {
diff -urN vdr-2.0.1/config.c vdr-2.0.1.reel/config.c
--- vdr-2.0.1/config.c	2013-03-18 09:57:50.000000000 +0100
+++ vdr-2.0.1.reel/config.c	2013-05-09 18:09:51.271874143 +0200
@@ -23,6 +23,87 @@
 
 #define ChkDoublePlausibility(Variable, Default) { if (Variable < 0.00001) Variable = Default; }
 
+#ifdef REELVDR
+namespace setup
+{
+  using namespace std;
+
+  string FileNameFactory(string FileType)
+  {
+    string configDir = cPlugin::ConfigDirectory();
+    string::size_type pos = configDir.find("plugin");
+    configDir.erase(pos-1);
+
+#ifdef EXTRA_VERBOSE_DEBUG
+    cout << " Config Dir : " << configDir  <<  endl;
+#endif
+
+    if (FileType == "configDirecory") // vdr config base directory
+    {
+#if EXTRA_VERBOSE_DEBUG
+       cout << "DEBUG [setup]: ConfigDirectory   " << configDir <<   endl;
+#endif
+       return configDir;
+    }
+    if (FileType == "help") // returns symbolic link
+    {
+       string configFile;
+       configFile = cPlugin::ConfigDirectory();
+       configFile += "/setup/help/help.";
+       string tmp = I18nLanguageCode(I18nCurrentLanguage());
+       // if two token given we take the first one.
+       string::size_type pos = tmp.find(',');
+       if (pos != string::npos)
+       {
+         configFile += tmp.substr(0,pos);
+       }
+       else
+       {
+         configFile += tmp;
+       }
+       configFile += ".xml";
+#ifdef EXTRA_VERBOSE_DEBUG
+       cout << " debug config file: " << configFile <<   endl;
+#endif
+       return configFile;
+    }
+
+    //else if (FileType == "channelsFile") // returns  channels.conf
+    else if (FileType == "link") // returns symbolic link
+    {
+#ifdef EXTRA_VERBOSE_DEBUG
+       cout << " Config Dir : " << configDir  << "/channels.conf" <<  endl;
+#endif
+       return configDir += "/channels.conf";
+    }
+    else if (FileType == "channels") // returns channels dir;
+    {
+#ifdef EXTRA_VERBOSE_DEBUG
+       cout << " Config Dir : " << configDir  << "/channels" <<  endl;
+#endif
+       return configDir += "/channels";
+    }
+    else if (FileType == "setup") // returns plugins/setup dir; change to  "configDir"
+    {
+#ifdef EXTRA_VERBOSE_DEBUG
+       cout << " Config Dir : " << configDir  << "/plugins/setup" <<  endl;
+#endif
+       return configDir += "/plugins/setup";
+    }
+
+    configDir.append("/");
+    configDir += "/channels/";
+    configDir += FileType;
+#ifdef EXTRA_VERBOSE_DEBUG
+    cout << " Config Dir end  : " << configDir << ".conf"  <<  endl;
+#endif
+
+    return configDir += ".conf";
+  }
+}
+
+#endif /* REELVDR */
+
 // --- cSVDRPhost ------------------------------------------------------------
 
 cSVDRPhost::cSVDRPhost(void)
@@ -376,6 +457,7 @@
   strcpy(OSDLanguage, ""); // default is taken from environment
   strcpy(OSDSkin, "lcars");
   strcpy(OSDTheme, "default");
+  WarEagleIcons = 1;
   PrimaryDVB = 1;
   ShowInfoOnChSwitch = 1;
   TimeoutRequChInfo = 1;
@@ -395,8 +477,12 @@
   StandardCompliance = STANDARD_DVB;
   MarginStart = 2;
   MarginStop = 10;
+  JumpSeconds = 60;
+  JumpSecondsSlow = 10;
+  JumpSecondsRepeat = 300;
   AudioLanguages[0] = -1;
   DisplaySubtitles = 0;
+  SupportTeletext = 0;
   SubtitleLanguages[0] = -1;
   SubtitleOffset = 0;
   SubtitleFgTransparency = 0;
@@ -447,12 +533,21 @@
   strcpy(FontOsd, DefaultFontOsd);
   strcpy(FontSml, DefaultFontSml);
   strcpy(FontFix, DefaultFontFix);
+#ifdef REELVDR
   FontOsdSizeP = 0.031;
-  FontSmlSizeP = 0.028;
-  FontFixSizeP = 0.030;
+  FontSmlSizeP = 0.024;
+  FontFixSizeP = 0.027;
+  FontOsdSize = 18;
+  FontSmlSize = 14;
+  FontFixSize = 16;
+#else
+  FontOsdSizeP = 0.038;
+  FontSmlSizeP = 0.035;
+  FontFixSizeP = 0.031;
   FontOsdSize = 22;
   FontSmlSize = 18;
   FontFixSize = 20;
+#endif
   MaxVideoFileSize = MAXVIDEOFILESIZEDEFAULT;
   SplitEditedFiles = 0;
   DelTimeshiftRec = 0;
@@ -465,6 +560,9 @@
   ProgressDisplayTime = 0;
   PauseOnMarkSet = 0;
   ResumeID = 0;
+  JumpPlay = 0;
+  PlayJump = 0;
+  PauseLastMark = 0;
   CurrentChannel = -1;
   CurrentVolume = MAXVOLUME;
   CurrentDolby = 0;
@@ -474,6 +572,11 @@
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+#ifdef REELVDR
+  ExpertOptions  = 1;
+  ReelboxModeTemp = ReelboxMode = eModeStandalone;
+#endif /* REELVDR */
+
 }
 
 cSetup& cSetup::operator= (const cSetup &s)
@@ -579,8 +682,31 @@
 bool cSetup::Parse(const char *Name, const char *Value)
 {
   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
+#ifdef REELVDR
+  else if (!strcasecmp(Name, "ExpertOptions"))       ExpertOptions      = atoi(Value);
+  else if (!strcasecmp(Name, "OSDRandom"))           OSDRandom          = atoi(Value);
+  else if (!strcasecmp(Name, "OSDRemainTime"))       OSDRemainTime      = atoi(Value);
+  else if (!strcasecmp(Name, "OSDUseSymbol"))        OSDUseSymbol       = atoi(Value);
+  else if (!strcasecmp(Name, "OSDScrollBarWidth"))   OSDScrollBarWidth  = atoi(Value);
+  else if (!strcasecmp(Name, "FontSizes"))           FontSizes          = atoi(Value);
+  else if (!strcasecmp(Name, "AddNewChannels"))      AddNewChannels     = atoi(Value);
+  else if (!strcasecmp(Name, "NetServerIP"))         Utf8Strn0Cpy(NetServerIP, Value, MAXHOSTIP);
+  else if (!strcasecmp(Name, "ReelboxMode"))         ReelboxMode        = (eReelboxMode)atoi(Value);
+  else if (!strcasecmp(Name, "RequestShutDownMode")) RequestShutDownMode= atoi(Value);
+  else if (!strcasecmp(Name, "StandbyOrQuickshutdown")) StandbyOrQuickshutdown  = atoi(Value);
+  else if (!strcasecmp(Name, "UseBouquetList"))      UseBouquetList     = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyRadioChannels"))   OnlyRadioChannels  = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyEncryptedChannels"))OnlyEncryptedChannels = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyHDChannels"))      OnlyHDChannels       = atoi(Value);
+  else if (!strcasecmp(Name, "ExpertNavi"))          ExpertNavi         = atoi(Value);
+  else if (!strcasecmp(Name, "WantChListOnOk"))      WantChListOnOk     = atoi(Value);
+  else if (!strcasecmp(Name, "ChannelUpDownKeyMode"))  ChannelUpDownKeyMode = atoi(Value);
+  else if (!strcasecmp(Name, "JumpWidth"))           JumpWidth          = atoi(Value);
+  else if (!strcasecmp(Name, "UseZonedChannelList"))  UseZonedChannelList    = atoi(Value);
+#endif /* REELVDR */
   else if (!strcasecmp(Name, "OSDSkin"))             Utf8Strn0Cpy(OSDSkin, Value, MaxSkinName);
   else if (!strcasecmp(Name, "OSDTheme"))            Utf8Strn0Cpy(OSDTheme, Value, MaxThemeName);
+  else if (!strcasecmp(Name, "WarEagleIcons"))       WarEagleIcons      = atoi(Value);
   else if (!strcasecmp(Name, "PrimaryDVB"))          PrimaryDVB         = atoi(Value);
   else if (!strcasecmp(Name, "ShowInfoOnChSwitch"))  ShowInfoOnChSwitch = atoi(Value);
   else if (!strcasecmp(Name, "TimeoutRequChInfo"))   TimeoutRequChInfo  = atoi(Value);
@@ -600,8 +726,12 @@
   else if (!strcasecmp(Name, "StandardCompliance"))  StandardCompliance = atoi(Value);
   else if (!strcasecmp(Name, "MarginStart"))         MarginStart        = atoi(Value);
   else if (!strcasecmp(Name, "MarginStop"))          MarginStop         = atoi(Value);
+  else if (!strcasecmp(Name, "JumpSeconds"))         JumpSeconds        = atoi(Value); 
+  else if (!strcasecmp(Name, "JumpSecondsSlow"))     JumpSecondsSlow    = atoi(Value);
+  else if (!strcasecmp(Name, "JumpSecondsRepeat"))   JumpSecondsRepeat  = atoi(Value);
   else if (!strcasecmp(Name, "AudioLanguages"))      return ParseLanguages(Value, AudioLanguages);
   else if (!strcasecmp(Name, "DisplaySubtitles"))    DisplaySubtitles   = atoi(Value);
+  else if (!strcasecmp(Name, "SupportTeletext"))     SupportTeletext    = atoi(Value);
   else if (!strcasecmp(Name, "SubtitleLanguages"))   return ParseLanguages(Value, SubtitleLanguages);
   else if (!strcasecmp(Name, "SubtitleOffset"))      SubtitleOffset     = atoi(Value);
   else if (!strcasecmp(Name, "SubtitleFgTransparency")) SubtitleFgTransparency = atoi(Value);
@@ -670,6 +800,9 @@
   else if (!strcasecmp(Name, "ProgressDisplayTime")) ProgressDisplayTime= atoi(Value);
   else if (!strcasecmp(Name, "PauseOnMarkSet"))      PauseOnMarkSet     = atoi(Value);
   else if (!strcasecmp(Name, "ResumeID"))            ResumeID           = atoi(Value);
+  else if (!strcasecmp(Name, "JumpPlay"))            JumpPlay           = atoi(Value);
+  else if (!strcasecmp(Name, "PlayJump"))            PlayJump           = atoi(Value);
+  else if (!strcasecmp(Name, "PauseLastMark"))       PauseLastMark      = atoi(Value);
   else if (!strcasecmp(Name, "CurrentChannel"))      CurrentChannel     = atoi(Value);
   else if (!strcasecmp(Name, "CurrentVolume"))       CurrentVolume      = atoi(Value);
   else if (!strcasecmp(Name, "CurrentDolby"))        CurrentDolby       = atoi(Value);
@@ -690,6 +823,7 @@
   Store("OSDLanguage",        OSDLanguage);
   Store("OSDSkin",            OSDSkin);
   Store("OSDTheme",           OSDTheme);
+  Store("WarEagleIcons",      WarEagleIcons);
   Store("PrimaryDVB",         PrimaryDVB);
   Store("ShowInfoOnChSwitch", ShowInfoOnChSwitch);
   Store("TimeoutRequChInfo",  TimeoutRequChInfo);
@@ -709,8 +843,12 @@
   Store("StandardCompliance", StandardCompliance);
   Store("MarginStart",        MarginStart);
   Store("MarginStop",         MarginStop);
+  Store("JumpSeconds",        JumpSeconds);
+  Store("JumpSecondsSlow",    JumpSecondsSlow);
+  Store("JumpSecondsRepeat",  JumpSecondsRepeat);
   StoreLanguages("AudioLanguages", AudioLanguages);
   Store("DisplaySubtitles",   DisplaySubtitles);
+  Store("SupportTeletext",    SupportTeletext);
   StoreLanguages("SubtitleLanguages", SubtitleLanguages);
   Store("SubtitleOffset",     SubtitleOffset);
   Store("SubtitleFgTransparency", SubtitleFgTransparency);
@@ -779,6 +917,9 @@
   Store("ProgressDisplayTime",ProgressDisplayTime);
   Store("PauseOnMarkSet",     PauseOnMarkSet);
   Store("ResumeID",           ResumeID);
+  Store("JumpPlay",           JumpPlay);
+  Store("PlayJump",           PlayJump);
+  Store("PauseLastMark",      PauseLastMark);
   Store("CurrentChannel",     CurrentChannel);
   Store("CurrentVolume",      CurrentVolume);
   Store("CurrentDolby",       CurrentDolby);
@@ -789,6 +930,36 @@
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
   Store("LastReplayed",       cReplayControl::LastReplayed());
+#ifdef REELVDR
+  Store("PreviewVideos",      PreviewVideos);
+  Store("LiveTvOnAvg",        LiveTvOnAvg);
+  Store("ReceptionMode",      ReceptionMode);
+  Store("NetServerName",      NetServerName);
+  Store("NetServerMAC",       NetServerMAC);
+  Store("MaxMultiRoomClients",MaxMultiRoomClients);
+  Store("ExpertOptions",      ExpertOptions);
+  Store("OSDRandom",          OSDRandom);
+  Store("OSDRemainTime",      OSDRemainTime);
+  Store("OSDUseSymbol",       OSDUseSymbol);
+  Store("OSDScrollBarWidth",  OSDScrollBarWidth);
+  Store("FontSizes",          FontSizes);
+  Store("AddNewChannels",     AddNewChannels);
+  Store("NetServerIP",        NetServerIP);
+  Store("ReelboxMode",        ReelboxMode);
+  Store("RequestShutDownMode",RequestShutDownMode);
+  Store("StandbyOrQuickshutdown", StandbyOrQuickshutdown);
+  Store("EnergySaveOn", EnergySaveOn);
+  Store("StandbyTimeout", StandbyTimeout);
+  Store("UseBouquetList",     UseBouquetList);
+  Store("OnlyRadioChannels",  OnlyRadioChannels);
+  Store("OnlyEncryptedChannels", OnlyEncryptedChannels);
+  Store("OnlyHDChannels", OnlyHDChannels);
+  Store("ExpertNavi",         ExpertNavi);
+  Store("WantChListOnOk",     WantChListOnOk);
+  Store("ChannelUpDownKeyMode", ChannelUpDownKeyMode);
+  Store("JumpWidth",          JumpWidth);
+  Store("UseZonedChannelList", UseZonedChannelList);
+#endif /* REELVDR */
 
   Sort();
 
@@ -798,3 +969,22 @@
      }
   return false;
 }
+
+#ifdef REELVDR
+/*call script with appropriate filename and copy the file to tftp root*/
+void CopyToTftpRoot(const char* path)
+{
+    /*strip the filename from path*/
+    const char* p = strrchr(path, '/');
+    if ( !p ||!*p ) return;
+    ++p;
+
+#define CMP(x) strcasecmp(x,p)
+    if ( CMP("channels.conf") &&  CMP("setup.conf") && CMP("sysconfig") && CMP("diseqc.conf") && CMP("favourites.conf") )
+        // interested in only one of these files
+        return;
+
+    std::string command = std::string("CopytoTftpRoot.sh ") + p;
+    SystemExec(command.c_str());
+}
+#endif /* REELVDR */
diff -urN vdr-2.0.1/config.h vdr-2.0.1.reel/config.h
--- vdr-2.0.1/config.h	2013-04-05 12:41:32.000000000 +0200
+++ vdr-2.0.1.reel/config.h	2013-05-09 18:09:51.271874143 +0200
@@ -13,7 +13,11 @@
 #include <arpa/inet.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef REELVDR
+#include <string>
+#else
 #include <string.h>
+#endif /*REELVDR*/
 #include <time.h>
 #include <unistd.h>
 #include "i18n.h"
@@ -36,6 +40,14 @@
 // plugins to work with newer versions of the core VDR as long as no
 // VDR header files have changed.
 
+#define JUMPPLAYVERSNUM 110
+
+// The MainMenuHook Patch's version number:
+#define MAINMENUHOOKSVERSION "1.0.1"
+#define MAINMENUHOOKSVERSNUM 10001  // Version * 10000 + Major * 100 + Minor
+
+#define REMOTEINSTANTVERSION 1.0
+
 #define MAXPRIORITY       99
 #define MINPRIORITY       (-MAXPRIORITY)
 #define LIVEPRIORITY      0                  // priority used when selecting a device for live viewing
@@ -68,6 +80,23 @@
 
 typedef uint32_t in_addr_t; //XXX from /usr/include/netinet/in.h (apparently this is not defined on systems with glibc < 2.2)
 
+#ifdef REELVDR
+#define MAXHOSTIP 16
+#define MAXHOSTNAME 64
+#define MACLENGTH 18
+
+enum eReelboxMode { eModeStandalone=0, eModeClient=1, eModeServer=2, eModeHotel=3 };
+enum eReceiverType { eModeDVB = 0, eModeMcli = 1, eModeStreamdev = 2 };
+
+void CopyToTftpRoot(const char* filename);
+
+namespace setup
+{
+  extern std::string FileNameFactory(std::string FileType);
+}
+
+#endif /* REELVDR */
+
 class cSVDRPhost : public cListObject {
 private:
   struct in_addr addr;
@@ -159,7 +188,7 @@
        fprintf(stderr, "vdr: error while reading '%s'\n", fileName);
     return result;
   }
-  bool Save(void)
+  bool Save(const char* FileName = NULL)
   {
     bool result = true;
     T *l = (T *)this->First();
@@ -174,9 +203,15 @@
              }
        if (!f.Close())
           result = false;
+#if REELVDR
+       CopyToTftpRoot(FileName);
+#endif
        }
-    else
+    else {
        result = false;
+       LOG_ERROR_STR(FileName);
+       esyslog("could not open file %s", FileName);
+    }
     return result;
   }
   };
@@ -243,7 +278,13 @@
   void StoreLanguages(const char *Name, int *Values);
   bool ParseLanguages(const char *Value, int *Values);
   bool Parse(const char *Name, const char *Value);
+#ifdef REELVDR
+public:
+  cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+private:
+#else
   cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+#endif
   void Store(const char *Name, const char *Value, const char *Plugin = NULL, bool AllowMultiple = false);
   void Store(const char *Name, int Value, const char *Plugin = NULL);
   void Store(const char *Name, double &Value, const char *Plugin = NULL);
@@ -253,6 +294,7 @@
   char OSDLanguage[I18N_MAX_LOCALE_LEN];
   char OSDSkin[MaxSkinName];
   char OSDTheme[MaxThemeName];
+  int WarEagleIcons;
   int PrimaryDVB;
   int ShowInfoOnChSwitch;
   int TimeoutRequChInfo;
@@ -271,8 +313,10 @@
   int TimeTransponder;
   int StandardCompliance;
   int MarginStart, MarginStop;
+  int JumpSeconds, JumpSecondsSlow, JumpSecondsRepeat;
   int AudioLanguages[I18N_MAX_LANGUAGES + 1];
   int DisplaySubtitles;
+  int SupportTeletext;
   int SubtitleLanguages[I18N_MAX_LANGUAGES + 1];
   int SubtitleOffset;
   int SubtitleFgTransparency, SubtitleBgTransparency;
@@ -328,6 +372,9 @@
   int ProgressDisplayTime;
   int PauseOnMarkSet;
   int ResumeID;
+  int JumpPlay;
+  int PlayJump;
+  int PauseLastMark;
   int CurrentChannel;
   int CurrentVolume;
   int CurrentDolby;
@@ -335,6 +382,46 @@
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+#ifdef REELVDR
+  int LiveTvOnAvg;
+  int PreviewVideos;
+  eReceiverType ReceptionMode;
+  char NetServerName[MAXHOSTNAME];
+  char NetServerMAC[MACLENGTH];
+  int MaxMultiRoomClients; // Maximum number of MultiRoom clients served by Reelbox in serverMode
+  int ExpertOptions;
+  int OSDRandom;
+  int OSDRemainTime;
+  int OSDUseSymbol;
+  int OSDScrollBarWidth;
+  int FontSizes;
+  int AddNewChannels;
+  char NetServerIP[MAXHOSTIP];
+  eReelboxMode ReelboxModeTemp; // 0=standalone, 1=Client, 2=Server, 3=HotelMode (for Temporary use)
+  eReelboxMode ReelboxMode; // 0=standalone, 1=Client, 2=Server, 3=HotelMode
+  int RequestShutDownMode;
+  int StandbyOrQuickshutdown;
+  int EnergySaveOn; // 1 => MinUserInactivity sends vdr into (hot)standby and then into poweroff
+  int StandbyTimeout; //(in mins) after which poweroff;  effective only  when EnergySaveOn is 1, 
+  int UseBouquetList;
+  int OnlyRadioChannels;
+  int OnlyEncryptedChannels;
+  int OnlyHDChannels;
+  int ExpertNavi;
+  int WantChListOnOk;
+  int ChannelUpDownKeyMode; // 0 Normal, jumps to next or previous channel
+                            // 1 opens bouquet / channel list
+  int JumpWidth;
+  // should vdr allow plugin to restrict channel list to which it can zap to?
+  bool UseZonedChannelList;
+  int EPGScanMaxChannel;
+  int EPGScanMaxDevices;
+  int EPGScanMaxBusyDevices;
+  int EPGScanMode;
+  int EPGScanDailyTime;
+  int EPGScanDailyNext;
+#endif /* REELVDR */
+
   int __EndData__;
   cString InitialChannel;
   cString DeviceBondings;
@@ -344,6 +431,15 @@
   bool Save(void);
   };
 
+#ifdef REELVDR
+// Additional defines for skinreel3-pi
+// FontSizes:
+#define FONT_SIZE_USER 0
+#define FONT_SIZE_SMALL 1
+#define FONT_SIZE_NORMAL 2
+#define FONT_SIZE_LARGE 3
+#endif
+
 extern cSetup Setup;
 
 #endif //__CONFIG_H
diff -urN vdr-2.0.1/cutter.c vdr-2.0.1.reel/cutter.c
--- vdr-2.0.1/cutter.c	2013-03-18 10:40:49.000000000 +0100
+++ vdr-2.0.1.reel/cutter.c	2013-05-09 18:09:51.275874144 +0200
@@ -8,6 +8,7 @@
  */
 
 #include "cutter.h"
+#include "interface.h"
 #include "menu.h"
 #include "recording.h"
 #include "remux.h"
@@ -649,7 +650,7 @@
 bool cCutter::error = false;
 bool cCutter::ended = false;
 
-bool cCutter::Start(const char *FileName)
+bool cCutter::Start(const char *FileName, const char *TargetFileName, bool Overwrite)
 {
   cMutexLock MutexLock(&mutex);
   if (!cuttingThread) {
@@ -663,11 +664,16 @@
      if (cMark *First = FromMarks.GetNextBegin())
         Recording.SetStartTime(Recording.Start() + (int(First->Position() / Recording.FramesPerSecond() + 30) / 60) * 60);
 
-     const char *evn = Recording.PrefixFileName('%');
-     if (evn && RemoveVideoFile(evn) && MakeDirs(evn, true)) {
+     cString evn = (TargetFileName && *TargetFileName) ? Recording.UpdateFileName(TargetFileName) : Recording.PrefixFileName('%');
+     if (!Overwrite && *evn && (access(*evn, F_OK) == 0) && !Interface->Confirm(tr("File already exists - overwrite?"))) {
+        do {
+           evn = PrefixVideoFileName(*evn, '%');
+        } while (*evn && (access(*evn, F_OK) == 0));
+        }
+     if (*evn && RemoveVideoFile(*evn) && MakeDirs(*evn, true)) {
         // XXX this can be removed once RenameVideoFile() follows symlinks (see videodir.c)
         // remove a possible deleted recording with the same name to avoid symlink mixups:
-        char *s = strdup(evn);
+        char *s = strdup(*evn);
         char *e = strrchr(s, '.');
         if (e) {
            if (strcmp(e, ".rec") == 0) {
diff -urN vdr-2.0.1/cutter.h vdr-2.0.1.reel/cutter.h
--- vdr-2.0.1/cutter.h	2012-02-16 13:05:33.000000000 +0100
+++ vdr-2.0.1.reel/cutter.h	2013-05-09 18:09:51.275874144 +0200
@@ -24,7 +24,7 @@
   static bool error;
   static bool ended;
 public:
-  static bool Start(const char *FileName);
+  static bool Start(const char *FileName, const char *TargetFileName = NULL, bool Overwrite = true);
   static void Stop(void);
   static bool Active(const char *FileName = NULL);
          ///< Returns true if the cutter is currently active.
diff -urN vdr-2.0.1/debug.h vdr-2.0.1.reel/debug.h
--- vdr-2.0.1/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/debug.h	2013-05-09 18:09:51.275874144 +0200
@@ -0,0 +1,44 @@
+
+#ifndef DEBUG_H
+#define DEBUG_H
+#include <assert.h>
+
+#ifdef DBG
+  #undef DBG
+  #undef DERR
+  #undef DLOG
+  #undef PRINTF
+#endif
+
+
+#if defined DEBUG
+    #ifdef PLUGIN_NAME_I18N
+        #define CONTEXT PLUGIN_NAME_I18N
+    #else
+        #define CONTEXT "VDR"
+    #endif
+
+    // standard debug macro
+    #define DDD(x...) { printf("["CONTEXT": %s +%d, %s()]: ",__FILE__, __LINE__, __FUNCTION__); \
+                         printf(x); printf("\n"); }
+
+    // standard error macro (red background)
+    #define DERR(x...) { printf("\033[0;37m\033[1;41m["CONTEXT"]: "x); printf("\033[0m\n"); }
+
+    // special macro: logs to syslog AND console
+    #define DLOG(x...) { printf("["CONTEXT"]: "x); printf("\n"); dsyslog("["CONTEXT"]: "x); }
+
+    // for automatic conversion of printf's - i.e. use sed s/" printf"/" PRINTF"/
+    #define PRINTF(x...) printf("["CONTEXT"]: "x)
+#else
+    #define DDD(x...)
+    #define DERR(x...)
+    #define DLOG(x...)
+    #define PRINTF(x...)
+#endif
+
+//only here for compatibility reasons, don't use any more
+#define ERR "Error"
+#define DBG(x...)
+
+#endif /* DEBUG_H */
diff -urN vdr-2.0.1/debugmacros.h vdr-2.0.1.reel/debugmacros.h
--- vdr-2.0.1/debugmacros.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/debugmacros.h	2013-05-09 18:09:51.275874144 +0200
@@ -0,0 +1,40 @@
+
+
+#ifndef __DEBUG_MACROS__H
+#define __DEBUG_MACROS__H
+
+#include<cstdio>
+#include<iostream>
+
+
+
+#if 1
+
+
+/* just a helper for code location */
+#define LOC std::cout << "DEBUG: \t\t(" << __FILE__ << ":" << __LINE__ << ")  "<<__PRETTY_FUNCTION__<<"  ";
+
+#define HERE LOC printf("\n");
+
+/* macro using var args */
+#define DEBUG_PRINT(fmt,...) LOC printf(fmt,__VA_ARGS__);
+
+/* macro for general debug print statements. */
+#define DEBUG_VAL(text) LOC std::cout << text << std::endl;
+
+/* macro that dumps a variable name and its actual value */
+#define DEBUG_VAR(text) LOC std::cout << (#text) << "=" << text << std::endl;
+
+
+
+#else
+
+/* when debug isn't defined all the macro calls do absolutely nothing */
+#define DEBUG_PRINT(fmt,...)
+#define DEBUG_VAL(text)
+#define DEBUG_VAR(text)
+#define HERE 
+
+#endif
+#endif
+
diff -urN vdr-2.0.1/device.c vdr-2.0.1.reel/device.c
--- vdr-2.0.1/device.c	2013-04-05 12:47:38.000000000 +0200
+++ vdr-2.0.1.reel/device.c	2013-05-09 18:09:51.279874144 +0200
@@ -18,9 +18,32 @@
 #include "receiver.h"
 #include "status.h"
 #include "transfer.h"
+#include "vdrttxtsubshooks.h"
 
 // --- cLiveSubtitle ---------------------------------------------------------
 
+#ifdef REELVDR
+/***
+*  returns True if Tuner-device with priority < 0 is found
+*  priority < 0 implies No recording
+*  live Viewing = -1 priority
+*/
+bool AnyFreeTuners()
+{
+    cDevice* device=NULL;
+    for (int tuner=0; tuner<MAXDEVICES ; tuner++)
+    {
+        device = cDevice::GetDevice(tuner);
+        printf("tuner#%d : priority %d \n",tuner, device?device->Priority():-100 );
+        if ( device &&
+             ( device->ProvidesSource(cSource::stSat) || device->ProvidesSource(cSource::stCable) || device->ProvidesSource(cSource::stTerr) ) && // device is a Tuner
+             device->Priority()<0 ) // free Tuner: ie. with no recordings in this tuner
+            return true;
+    } // end for
+    return false; // no device found
+}
+#endif /* REELVDR */
+
 class cLiveSubtitle : public cReceiver {
 protected:
   virtual void Receive(uchar *Data, int Length);
@@ -242,7 +265,9 @@
   int NumCamSlots = CamSlots.Count();
   int SlotPriority[NumCamSlots];
   int NumUsableSlots = 0;
+#ifdef USE_MCLI
   bool InternalCamNeeded = false;
+#endif /* MCLI */
   if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
      for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
          SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
@@ -256,8 +281,16 @@
             }
          }
      if (!NumUsableSlots)
+#ifdef USE_MCLI
         InternalCamNeeded = true; // no CAM is able to decrypt this channel
-     }
+#else
+        return NULL; // no CAM is able to decrypt this channel
+#endif /* MCLI */
+     }
+#ifdef USE_MCLI
+  if ((Channel->Ca() >= CA_MCLI_MIN) && (Channel->Ca() <= CA_MCLI_MAX))
+        InternalCamNeeded = true; // CAM Slot assigned -> use internal cam if device provides it
+#endif
 
   bool NeedsDetachReceivers = false;
   cDevice *d = NULL;
@@ -268,16 +301,28 @@
       if (NumUsableSlots && SlotPriority[j] > MAXPRIORITY)
          continue; // there is no CAM available in this slot
       for (int i = 0; i < numDevices; i++) {
+          #ifdef USE_MCLI
+          if (!(InternalCamNeeded && device[i]->HasInternalCam()) && Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
+             continue; // a specific card was requested, but not this one
+#else
           if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
              continue; // a specific card was requested, but not this one
-          bool HasInternalCam = device[i]->HasInternalCam();
-          if (InternalCamNeeded && !HasInternalCam)
+#endif /*USE_MCLI*/
+#ifdef USE_MCLI
+          if (InternalCamNeeded && !device[i]->HasInternalCam())
              continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
-          if (NumUsableSlots && !HasInternalCam && !CamSlots.Get(j)->Assign(device[i], true))
+          if (NumUsableSlots && !(InternalCamNeeded && device[i]->HasInternalCam()) && !CamSlots.Get(j)->Assign(device[i], true))
+#else
+          if (NumUsableSlots && !CamSlots.Get(j)->Assign(device[i], true))
+#endif /* MCLI */
              continue; // CAM slot can't be used with this device
           bool ndr;
           if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basically able to do the job
-             if (NumUsableSlots && !HasInternalCam && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#ifdef USE_MCLI
+             if (NumUsableSlots && !(InternalCamNeeded && device[i]->HasInternalCam()) && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#else
+             if (NumUsableSlots && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#endif /* MCLI */
                 ndr = true; // using a different CAM slot requires detaching receivers
              // Put together an integer number that reflects the "impact" using
              // this device would have on the overall system. Each condition is represented
@@ -291,19 +336,35 @@
              imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
              imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
              imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
-             imp <<= 8; imp |= device[i]->Priority() - IDLEPRIORITY;                                                 // use the device with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
-             imp <<= 8; imp |= ((NumUsableSlots && !HasInternalCam) ? SlotPriority[j] : IDLEPRIORITY) - IDLEPRIORITY;// use the CAM slot with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
+#ifdef USE_MCLI
+             imp <<= 8; imp |= min(max(((NumUsableSlots && !(InternalCamNeeded && device[i]->HasInternalCam())) ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#else
+             imp <<= 8; imp |= min(max((NumUsableSlots ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#endif /* MCLI */
              imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
+#ifdef USE_MCLI
              imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
+             imp <<= 1; imp |= (NumUsableSlots && !(InternalCamNeeded && device[i]->HasInternalCam())) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#else
+             imp <<= 1; imp |= NumUsableSlots ? 0 : device[i]->HasCi();                                              // avoid cards with Common Interface for FTA channels
+             imp <<= 1; imp |= NumUsableSlots ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#endif /* MCLI */
              imp <<= 1; imp |= device[i]->AvoidRecording();                                                          // avoid SD full featured cards
-             imp <<= 1; imp |= (NumUsableSlots && !HasInternalCam) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+//             imp <<= 1; imp |= (NumUsableSlots && !HasInternalCam) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
              imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
+#ifdef REELVDR
+             if(device[i]->IsTunedToTransponder(Channel)) imp = 0; // Use this device if it is already tuned to the correct transponder
+#endif /*REELVDR*/
              if (imp < Impact) {
                 // This device has less impact than any previous one, so we take it.
                 Impact = imp;
                 d = device[i];
                 NeedsDetachReceivers = ndr;
-                if (NumUsableSlots && !HasInternalCam)
+#ifdef USE_MCLI
+                if (NumUsableSlots && !(InternalCamNeeded && device[i]->HasInternalCam()))
+#else
+                if (NumUsableSlots)
+#endif /* MCLI */
                    s = CamSlots.Get(j);
                 }
              }
@@ -598,10 +659,12 @@
   return -1;
 }
 
+#ifdef USE_MCLI
 int cDevice::ReadFilter(int Handle, void *Buffer, size_t Length)
 {
   return safe_read(Handle, Buffer, Length);
 }
+#endif /* MCLI */
 
 void cDevice::CloseFilter(int Handle)
 {
@@ -680,7 +743,7 @@
   return NULL;
 }
 
-bool cDevice::IsTunedToTransponder(const cChannel *Channel) const
+bool cDevice::IsTunedToTransponder(const cChannel *Channel)
 {
   return false;
 }
@@ -722,6 +785,7 @@
      cChannel *channel;
      while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
            // try only channels which are currently available
+           if (!cStatus::MsgChannelProtected(0, channel))      // PIN PATCH
            if (GetDevice(channel, LIVEPRIORITY, true, true))
               break;
            n = channel->Number() + Direction;
@@ -743,6 +807,12 @@
 
 eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
 {
+  // I hope 'LiveView = false' indicates a channel switch for recording, // PIN PATCH
+  // I really don't know, but it works ...                               // PIN PATCH
+
+  if (LiveView && cStatus::MsgChannelProtected(this, Channel))           // PIN PATCH
+     return scrNotAvailable;                                             // PIN PATCH
+
   cStatus::MsgChannelSwitch(this, 0, LiveView);
 
   if (LiveView) {
@@ -845,7 +915,7 @@
   return false;
 }
 
-bool cDevice::HasLock(int TimeoutMs) const
+bool cDevice::HasLock(int TimeoutMs) 
 {
   return true;
 }
@@ -1312,6 +1382,13 @@
                   }
                break;
           case 0xBD: { // private stream 1
+               // EBU Teletext data, ETSI EN 300 472
+               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
+               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
+                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
+                  break;
+                  }
+
                int PayloadOffset = Data[8] + 9;
 
                // Compatibility mode for old subtitles plugin:
@@ -1471,6 +1548,7 @@
      tsToPesVideo.Reset();
      tsToPesAudio.Reset();
      tsToPesSubtitle.Reset();
+     tsToPesTeletext.Reset();
      }
   else if (Length < TS_SIZE) {
      esyslog("ERROR: skipped %d bytes of TS fragment", Length);
@@ -1515,6 +1593,17 @@
                     if (!VideoOnly || HasIBPTrickSpeed())
                        PlayTsSubtitle(Data, TS_SIZE);
                     }
+                 else if (Pid == patPmtParser.Tpid()) {
+                    if (!VideoOnly || HasIBPTrickSpeed()) {
+                       int l;
+                       tsToPesTeletext.PutTs(Data, Length);
+                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
+                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
+                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false, patPmtParser.TeletextSubtitlePages(), patPmtParser.TotalTeletextSubtitlePages());
+                          tsToPesTeletext.Reset();
+                          }
+                       }
+                    }
                  }
               }
            else if (Pid == patPmtParser.Ppid()) {
@@ -1579,7 +1668,11 @@
                  if (startScrambleDetection) {
                     cCamSlot *cs = CamSlot();
                     CamSlotNumber = cs ? cs->SlotNumber() : 0;
+#ifdef USE_MCLI
+                    if (CamSlotNumber || HasInternalCam()) {
+#else
                     if (CamSlotNumber) {
+#endif
                        bool Scrambled = b[3] & TS_SCRAMBLING_CONTROL;
                        int t = time(NULL) - startScrambleDetection;
                        if (Scrambled) {
diff -urN vdr-2.0.1/device.h vdr-2.0.1.reel/device.h
--- vdr-2.0.1/device.h	2013-02-16 16:20:01.000000000 +0100
+++ vdr-2.0.1.reel/device.h	2013-05-09 18:09:51.279874144 +0200
@@ -24,6 +24,12 @@
 #include "spu.h"
 #include "thread.h"
 #include "tools.h"
+#include <asm/types.h>
+#include <linux/dvb/frontend.h>
+
+#ifdef REELVDR
+bool AnyFreeTuners(); // returns true if a tuner without recording is found
+#endif /* REELVDR */
 
 #define MAXDEVICES         16 // the maximum number of devices in the system
 #define MAXPIDHANDLES      64 // the maximum number of different PIDs per device
@@ -288,7 +294,7 @@
          ///< This is not one of the channels in the global cChannels list, but rather
          ///< a local copy. The result may be NULL if the device is not tuned to any
          ///< transponder.
-  virtual bool IsTunedToTransponder(const cChannel *Channel) const;
+  virtual bool IsTunedToTransponder(const cChannel *Channel);
          ///< Returns true if this device is currently tuned to the given Channel's
          ///< transponder.
   virtual bool MaySwitchTransponder(const cChannel *Channel) const;
@@ -328,7 +334,7 @@
          ///< after the device has been successfully tuned to the requested transponder.
          ///< Seconds will be silently limited to MAXOCCUPIEDTIMEOUT. Values less than
          ///< 0 will be silently ignored.
-  virtual bool HasLock(int TimeoutMs = 0) const;
+  virtual bool HasLock(int TimeoutMs = 0);
          ///< Returns true if the device has a lock on the requested transponder.
          ///< Default is true, a specific device implementation may return false
          ///< to indicate that it is not ready yet.
@@ -337,6 +343,7 @@
   virtual bool HasProgramme(void) const;
          ///< Returns true if the device is currently showing any programme to
          ///< the user, either through replaying or live.
+  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd) {return false;}
 
 // PID handle facilities
 
@@ -393,10 +400,12 @@
        ///< Opens a file handle for the given filter data.
        ///< A derived device that provides section data must
        ///< implement this function.
+ #ifdef USE_MCLI
   virtual int ReadFilter(int Handle, void *Buffer, size_t Length);
-       ///< Reads data from a handle for the given filter.
-       ///< A derived class need not implement this function, because this
+       ///< Read from a handle for the given filter data.
+       ///< a derived class need not implement this function, because this
        ///< is done by the default implementation.
+#endif /* MCLI */
   virtual void CloseFilter(int Handle);
        ///< Closes a file handle that has previously been opened
        ///< by OpenFilter(). If this is as simple as calling close(Handle),
@@ -415,12 +424,14 @@
 public:
   virtual bool HasCi(void);
          ///< Returns true if this device has a Common Interface.
+#ifdef USE_MCLI
   virtual bool HasInternalCam(void) { return false; }
          ///< Returns true if this device handles encrypted channels itself
-         ///< without VDR assistance. This can be e.g. if the device is a
+         ///< without VDR assistance. This can be e.g. when the device is a
          ///< client that gets the stream from another VDR instance that has
          ///< already decrypted the stream. In this case ProvidesChannel()
          ///< shall check whether the channel can be decrypted.
+#endif /* MCLI */
   void SetCamSlot(cCamSlot *CamSlot);
          ///< Sets the given CamSlot to be used with this device.
   cCamSlot *CamSlot(void) const { return camSlot; }
@@ -584,6 +595,7 @@
   cTsToPes tsToPesVideo;
   cTsToPes tsToPesAudio;
   cTsToPes tsToPesSubtitle;
+  cTsToPes tsToPesTeletext;
   bool isPlayingVideo;
 protected:
   const cPatPmtParser *PatPmtParser(void) const { return &patPmtParser; }
diff -urN vdr-2.0.1/dvbdevice.c vdr-2.0.1.reel/dvbdevice.c
--- vdr-2.0.1/dvbdevice.c	2013-04-09 15:42:26.000000000 +0200
+++ vdr-2.0.1.reel/dvbdevice.c	2013-05-09 18:09:51.279874144 +0200
@@ -285,6 +285,7 @@
 private:
   static cMutex bondMutex;
   enum eTunerStatus { tsIdle, tsSet, tsTuned, tsLocked };
+  bool SendDiseqc;
   int frontendType;
   const cDvbDevice *device;
   int fd_frontend;
@@ -301,6 +302,7 @@
   cMutex mutex;
   cCondVar locked;
   cCondVar newSet;
+  dvb_diseqc_master_cmd diseqc_cmd;
   cDvbTuner *bondedTuner;
   bool bondedMaster;
   bool SetFrontendType(const cChannel *Channel);
@@ -327,12 +329,16 @@
   bool Locked(int TimeoutMs = 0);
   int GetSignalStrength(void) const;
   int GetSignalQuality(void) const;
+  bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+private:
+  int GetCurrentDeliverySystem(void);
   };
 
 cMutex cDvbTuner::bondMutex;
 
 cDvbTuner::cDvbTuner(const cDvbDevice *Device, int Fd_Frontend, int Adapter, int Frontend)
 {
+  SendDiseqc = false;
   frontendType = SYS_UNDEFINED;
   device = Device;
   fd_frontend = Fd_Frontend;
@@ -655,6 +661,35 @@
   return -1;
 }
 
+int cDvbTuner::GetCurrentDeliverySystem()
+{
+  dtv_property Frontend[1];
+  memset(&Frontend, 0, sizeof(Frontend));
+  dtv_properties CmdSeq;
+  memset(&CmdSeq, 0, sizeof(CmdSeq));
+  CmdSeq.props = Frontend;
+  Frontend[0].cmd = DTV_DELIVERY_SYSTEM;
+  Frontend[0].u.data = 0;
+  if (ioctl(fd_frontend, FE_GET_PROPERTY, &CmdSeq) < 0) {
+     esyslog("ERROR: frontend %d/%d: %m", adapter, frontend);
+     return SYS_UNDEFINED;
+     }
+  return Frontend[0].u.data;
+}
+
+bool cDvbTuner::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
+{
+  cMutexLock MutexLock(&mutex);
+  int frontendType = GetCurrentDeliverySystem();
+  if ((frontendType != SYS_DVBS && frontendType != SYS_DVBS2) || SendDiseqc)
+    return false;
+  diseqc_cmd=cmd;
+  SendDiseqc=true;
+  newSet.Broadcast();
+  return true;
+}
+
+
 static unsigned int FrequencyToHz(unsigned int f)
 {
   while (f && f < 1000000)
@@ -874,6 +909,10 @@
         if (GetFrontendStatus(NewStatus))
            Status = NewStatus;
         cMutexLock MutexLock(&mutex);
+        if (SendDiseqc) {
+           CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &diseqc_cmd));
+           SendDiseqc=false;
+           }
         int WaitTime = 1000;
         switch (tunerStatus) {
           case tsIdle:
@@ -1554,7 +1593,7 @@
   return dvbTuner ? dvbTuner->GetTransponder() : NULL;
 }
 
-bool cDvbDevice::IsTunedToTransponder(const cChannel *Channel) const
+bool cDvbDevice::IsTunedToTransponder(const cChannel *Channel)
 {
   return dvbTuner ? dvbTuner->IsTunedTo(Channel) : false;
 }
@@ -1571,11 +1610,16 @@
   return true;
 }
 
-bool cDvbDevice::HasLock(int TimeoutMs) const
+bool cDvbDevice::HasLock(int TimeoutMs) 
 {
   return dvbTuner ? dvbTuner->Locked(TimeoutMs) : false;
 }
 
+bool cDvbDevice::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
+{
+  return dvbTuner->SendDiseqcCmd(cmd);
+}
+
 void cDvbDevice::SetTransferModeForDolbyDigital(int Mode)
 {
   setTransferModeForDolbyDigital = Mode;
diff -urN vdr-2.0.1/dvbdevice.h vdr-2.0.1.reel/dvbdevice.h
--- vdr-2.0.1/dvbdevice.h	2013-04-09 15:43:33.000000000 +0200
+++ vdr-2.0.1.reel/dvbdevice.h	2013-05-09 18:09:51.283874142 +0200
@@ -236,12 +236,13 @@
   virtual int SignalStrength(void) const;
   virtual int SignalQuality(void) const;
   virtual const cChannel *GetCurrentlyTunedTransponder(void) const;
-  virtual bool IsTunedToTransponder(const cChannel *Channel) const;
+  virtual bool IsTunedToTransponder(const cChannel *Channel);
   virtual bool MaySwitchTransponder(const cChannel *Channel) const;
 protected:
   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
 public:
-  virtual bool HasLock(int TimeoutMs = 0) const;
+  virtual bool HasLock(int TimeoutMs = 0);
+  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
 
 // PID handle facilities
 
diff -urN vdr-2.0.1/dvbplayer.c vdr-2.0.1.reel/dvbplayer.c
--- vdr-2.0.1/dvbplayer.c	2013-03-08 14:44:19.000000000 +0100
+++ vdr-2.0.1.reel/dvbplayer.c	2013-05-09 18:09:51.283874142 +0200
@@ -211,12 +211,14 @@
   cNonBlockingFileReader *nonBlockingFileReader;
   cRingBufferFrame *ringBuffer;
   cPtsIndex ptsIndex;
+  cMarks marks;
   cFileName *fileName;
   cIndexFile *index;
   cUnbufferedFile *replayFile;
   double framesPerSecond;
   bool isPesRecording;
   bool pauseLive;
+  bool reusedPauseLive;
   bool eof;
   bool firstPacket;
   ePlayModes playMode;
@@ -237,7 +239,7 @@
   virtual void Activate(bool On);
   virtual void Action(void);
 public:
-  cDvbPlayer(const char *FileName, bool PauseLive);
+  cDvbPlayer(const char *FileName, bool PauseLive, bool ReusedPauseLive = false);
   virtual ~cDvbPlayer();
   bool Active(void) { return cThread::Running(); }
   void Pause(void);
@@ -259,7 +261,7 @@
 #define SPEED_MULT   12 // the speed multiplier
 int cDvbPlayer::Speeds[] = { 0, -2, -4, -8, 1, 2, 4, 12, 0 };
 
-cDvbPlayer::cDvbPlayer(const char *FileName, bool PauseLive)
+cDvbPlayer::cDvbPlayer(const char *FileName, bool PauseLive, bool ReusedPauseLive)
 :cThread("dvbplayer")
 {
   nonBlockingFileReader = NULL;
@@ -269,6 +271,7 @@
   framesPerSecond = Recording.FramesPerSecond();
   isPesRecording = Recording.IsPesRecording();
   pauseLive = PauseLive;
+  reusedPauseLive = ReusedPauseLive;
   eof = false;
   firstPacket = true;
   playMode = pmPlay;
@@ -296,6 +299,7 @@
      }
   else if (PauseLive)
      framesPerSecond = cRecording(FileName).FramesPerSecond(); // the fps rate might have changed from the default
+  marks.Load(FileName, framesPerSecond, isPesRecording);
 }
 
 cDvbPlayer::~cDvbPlayer()
@@ -374,11 +378,20 @@
   if (index) {
      int Index = ptsIndex.FindIndex(DeviceGetSTC());
      if (Index >= 0) {
-        Index -= int(round(RESUMEBACKUP * framesPerSecond));
-        if (Index > 0)
-           Index = index->GetNextIFrame(Index, false);
-        else
+        // set resume position to 0 if replay stops at the first mark
+        if (Setup.PlayJump && marks.First() &&
+            abs(Index - marks.First()->Position()) <= int(round(RESUMEBACKUP * framesPerSecond)))
+           Index = 0;
+        int backup = int(round(RESUMEBACKUP * framesPerSecond));
+        if (Index >= index->Last() - backup)
            Index = 0;
+        else {
+           Index -= backup;
+           if (Index > 0)
+              Index = index->GetNextIFrame(Index, false);
+           else
+              Index = 0;
+           }
         if (Index >= 0)
            return index->StoreResume(Index);
         }
@@ -400,11 +413,26 @@
 {
   uchar *p = NULL;
   int pc = 0;
+  bool cutIn = false;
+  int total = -1;
 
   readIndex = Resume();
   if (readIndex >= 0)
      isyslog("resuming replay at index %d (%s)", readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
 
+  if (Setup.PlayJump && readIndex <= 0 && marks.First() && index) {
+     int Index = marks.First()->Position();
+     uint16_t FileNumber;
+     off_t FileOffset;
+     if (index->Get(Index, &FileNumber, &FileOffset) &&
+         NextFile(FileNumber, FileOffset)) {
+        isyslog("PlayJump: start replay at first mark %d (%s)",
+                Index, *IndexToHMSF(Index, true, framesPerSecond));
+        readIndex = Index;
+        }
+     }
+
+  bool LastMarkPause = false;
   nonBlockingFileReader = new cNonBlockingFileReader;
   int Length = 0;
   bool Sleep = false;
@@ -414,8 +442,17 @@
   int LastReadIFrame = -1;
   int SwitchToPlayFrame = 0;
 
-  if (pauseLive)
-     Goto(0, true);
+  if (reusedPauseLive) {
+    int Current, Total;
+    GetIndex(Current, Total, false);
+    readIndex = max(Total - 1, 0);
+    Goto(readIndex, true);
+    playMode = pmStill;
+    }
+  else if (pauseLive) {
+    Goto(0, true);
+  }
+  
   while (Running()) {
         if (WaitingForData)
            WaitingForData = !nonBlockingFileReader->WaitForDataMs(3); // this keeps the CPU load low, but reacts immediately on new data
@@ -431,7 +468,7 @@
 
           // Read the next frame from the file:
 
-          if (playMode != pmStill && playMode != pmPause) {
+          if (playMode != pmStill && playMode != pmPause && !LastMarkPause) {
              if (!readFrame && (replayFile || readIndex >= 0)) {
                 if (!nonBlockingFileReader->Reading()) {
                    if (!SwitchToPlayFrame && (playMode == pmFast || (playMode == pmSlow && playDir == pdBackward))) {
@@ -468,6 +505,44 @@
                    else if (index) {
                       uint16_t FileNumber;
                       off_t FileOffset;
+                      if (Setup.PlayJump || Setup.PauseLastMark) {
+                         // check for end mark - jump to next mark or pause
+                         readIndex++;
+                         marks.Update();
+                         cMark *m = marks.Get(readIndex);
+                         if (m && (m->Index() & 0x01) != 0) {
+                            m = marks.Next(m);
+                            int Index;
+                            if (m)
+                               Index = m->Position();
+                            else if (Setup.PauseLastMark) {
+                               // pause at last mark
+                               isyslog("PauseLastMark: pause at position %d (%s)",
+                                       readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
+                               LastMarkPause = true;
+                               Index = -1;
+                               }
+                            else if (total == index->Last())
+                               // at last mark jump to end of recording
+                               Index = index->Last() - 1;
+                            else
+                               // jump but stay off end of live-recordings
+                               Index = index->GetNextIFrame(index->Last() - int(round(MAXSTUCKATEOF * framesPerSecond)), true);
+                            // don't jump in edited recordings
+                            if (Setup.PlayJump && Index > readIndex &&
+                                Index > index->GetNextIFrame(readIndex, true)) {
+                               isyslog("PlayJump: %d frames to %d (%s)",
+                                       Index - readIndex, Index,
+                                       *IndexToHMSF(Index, true, framesPerSecond));
+                               readIndex = Index;
+                               cutIn = true;
+                               }
+                            }
+                         readIndex--;
+                      }
+                      // for detecting growing length of live-recordings
+                      if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent) && readIndependent)
+                         total = index->Last();
                       if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent, &Length) && NextFile(FileNumber, FileOffset))
                          readIndex++;
                       else
@@ -512,6 +587,13 @@
              // Store the frame in the buffer:
 
              if (readFrame) {
+                if (cutIn) {
+                   if (isPesRecording)
+                      cRemux::SetBrokenLink(readFrame->Data(), readFrame->Count());
+                   //else
+                   //   TsSetTeiOnBrokenPackets(readFrame->Data(), readFrame->Count());
+                   cutIn = false;
+                   }
                 if (ringBuffer->Put(readFrame))
                    readFrame = NULL;
                 else
@@ -578,8 +660,13 @@
                 p = NULL;
                 }
              }
-          else
+          else {
+             if (LastMarkPause) {
+                LastMarkPause = false;
+                playMode = pmPause;
+                }
              Sleep = true;
+             }
 
           // Handle hitting begin/end of recording:
 
@@ -859,8 +946,8 @@
 
 // --- cDvbPlayerControl -----------------------------------------------------
 
-cDvbPlayerControl::cDvbPlayerControl(const char *FileName, bool PauseLive)
-:cControl(player = new cDvbPlayer(FileName, PauseLive))
+cDvbPlayerControl::cDvbPlayerControl(const char *FileName, bool PauseLive, bool ReusedPauseLive)
+:cControl(player = new cDvbPlayer(FileName, PauseLive, ReusedPauseLive))
 {
 }
 
diff -urN vdr-2.0.1/dvbplayer.h vdr-2.0.1.reel/dvbplayer.h
--- vdr-2.0.1/dvbplayer.h	2012-02-19 12:40:36.000000000 +0100
+++ vdr-2.0.1.reel/dvbplayer.h	2013-05-09 18:09:51.283874142 +0200
@@ -19,7 +19,7 @@
 private:
   cDvbPlayer *player;
 public:
-  cDvbPlayerControl(const char *FileName, bool PauseLive = false);
+  cDvbPlayerControl(const char *FileName, bool PauseLive = false, bool ReusedPauseLive = false);
        // Sets up a player for the given file.
        // If PauseLive is true, special care is taken to make sure the index
        // file of the recording is long enough to allow the player to display
diff -urN vdr-2.0.1/eitscan.c vdr-2.0.1.reel/eitscan.c
--- vdr-2.0.1/eitscan.c	2012-04-07 16:39:28.000000000 +0200
+++ vdr-2.0.1.reel/eitscan.c	2013-05-09 18:09:51.283874142 +0200
@@ -126,7 +126,49 @@
 
 void cEITScanner::Process(void)
 {
-  if (Setup.EPGScanTimeout || !lastActivity) { // !lastActivity means a scan was forced
+#ifdef REELVDR
+  #define EPGSacnModeText()                                                                  \
+      (Setup.EPGScanMode == 0) ? (lastActivity ? "Disabled!":"Forced by user") :             \
+      (Setup.EPGScanMode == 1) ? (lastActivity ? "Permanent":"Permanent (forced by user)") : \
+      (Setup.EPGScanMode == 2) ? (lastActivity ? "Daily"    :"Daily (forced by user") :      \
+      "Unknown scan mode"
+  #define ReportEPGScanDailyNext(text) {           \
+      struct tm lt;                                \
+      char ltc[32];                                \
+      time_t ltt = (time_t)Setup.EPGScanDailyNext; \
+      localtime_r(&ltt, &lt);                      \
+      asctime_r(&lt, ltc);                         \
+      isyslog(text, ltc);                          \
+  }
+  if(Setup.EPGScanMode == 2) {
+     time_t now = time(NULL);
+     if(!Setup.EPGScanDailyNext || (Setup.EPGScanDailyNext > now+25*60*60)) {
+        struct tm tm_r;
+        if(localtime_r(&now, &tm_r)) {
+           tm_r.tm_hour = Setup.EPGScanDailyTime / 100;
+           tm_r.tm_min  = Setup.EPGScanDailyTime % 100;
+           tm_r.tm_sec  = 0;
+           Setup.EPGScanDailyNext =  mktime(&tm_r);
+           if(Setup.EPGScanDailyNext <= now)
+              Setup.EPGScanDailyNext += 24*60*60;
+           ReportEPGScanDailyNext("Set next daily EPG scan time to %s");
+        } // if
+     } // if
+     if(Setup.EPGScanDailyNext <= now) {
+        Setup.EPGScanDailyNext += 24*60*60;
+        ReportEPGScanDailyNext("Daily EPG scan triggered. Set next scan time to %s");
+        dailyScanActive = true;
+        if (scanList) // begin with a fresh list
+           delete scanList;
+        scanList = NULL;
+     } // if
+  } // if
+  if ((Setup.EPGScanMode == 1) || dailyScanActive || !lastActivity) { // !lastActivity means a scan was forced
+     if(!Setup.EPGScanTimeout) // Just make sure a value is set
+        Setup.EPGScanTimeout = 4;
+#else
+  if ( Setup.EPGScanTimeout || !lastActivity) { // !lastActivity means a scan was forced
+#endif
      time_t now = time(NULL);
      if (now - lastScan > ScanTimeout && now - lastActivity > ActivityTimeout) {
         if (Channels.Lock(false, 10)) {
diff -urN vdr-2.0.1/eitscan.h vdr-2.0.1.reel/eitscan.h
--- vdr-2.0.1/eitscan.h	2012-03-07 14:54:16.000000000 +0100
+++ vdr-2.0.1.reel/eitscan.h	2013-05-09 18:09:51.283874142 +0200
@@ -24,13 +24,22 @@
          ScanTimeout = 20
        };
   time_t lastScan, lastActivity;
+  cDevice *currentDevice;
   int currentChannel;
+#ifdef REELVDR
+  bool dailyScanActive;
+#endif
   cScanList *scanList;
   cTransponderList *transponderList;
 public:
   cEITScanner(void);
   ~cEITScanner();
+#ifdef REELVDR
+  bool Active(void) { return currentChannel || lastActivity == 0 || dailyScanActive; }
+#else
   bool Active(void) { return currentChannel || lastActivity == 0; }
+#endif
+  bool UsesDevice(const cDevice *Device) { return currentDevice == Device; }
   void AddTransponder(cChannel *Channel);
   void ForceScan(void);
   void Activity(void);
diff -urN vdr-2.0.1/filetransfer.c vdr-2.0.1.reel/filetransfer.c
--- vdr-2.0.1/filetransfer.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/filetransfer.c	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,278 @@
+/*
+ * filetransfer.c: The video file transfer facilities
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: $
+ */
+
+#include "videodir.h"
+#include "filetransfer.h"
+
+static cString StripLastDirectory(const char *DirName)
+{
+  if (DirName && *DirName) {
+     cString s(DirName);
+     int l = strlen(*s);
+     const char *p = *s + l;
+     while (l > 0) {
+           if (*p-- == '/')
+              break;
+           l--;
+           }
+     if (l)
+        s = s.Truncate(l);
+     return s;
+     }
+  return NULL;
+}
+
+// --- cCopyingThread --------------------------------------------------------
+
+class cCopyingThread : public cThread {
+private:
+  const char *error;
+  bool deleteSource;
+  cString source;
+  cString target;
+protected:
+  virtual void Action(void);
+public:
+  cCopyingThread(const char *SourceName, const char *ToFileName, bool DeleteSource = false);
+  virtual ~cCopyingThread();
+  const char *Error(void) { return error; }
+  };
+
+cCopyingThread::cCopyingThread(const char *SourceName, const char *TargetName, bool DeleteSource)
+:cThread("copying"),
+ error(NULL),
+ deleteSource(DeleteSource),
+ source(SourceName),
+ target(TargetName)
+{
+  // add missing directory delimiters
+  const char *delim = "/";
+  if (!endswith(*source, delim))
+     source = cString::sprintf("%s%s", *source, delim);
+  if (!endswith(*target, delim))
+     target = cString::sprintf("%s%s", *target, delim);
+
+  Start();
+}
+
+cCopyingThread::~cCopyingThread()
+{
+  Cancel(3);
+}
+
+void cCopyingThread::Action(void)
+{
+  SetPriority(19);
+  SetIOPriority(7);
+
+  if (strcmp(*source, *target)) {
+     // validate target directory
+     if (strstr(*target, *source)) {
+        error = "invalid target";
+        return;
+        }
+
+     // recordings methods require the last directory delimiter to be stripped off
+     cString recname = target;
+     recname.Truncate(strlen(*recname) - 1);
+     Recordings.AddByName(*recname, false);
+
+     RemoveFileOrDir(*target);
+     if (!MakeDirs(*target, true)) {
+        error = "MakeDirs";
+        return;
+        }
+
+     if (deleteSource && EntriesOnSameFileSystem(*source, *target)) {
+        if (rename(*source, *target) == -1) {
+           error = "rename";
+           return;
+           }
+        // delete all empty source directories
+        recname = source;
+        recname.Truncate(strlen(*recname) - 1);
+        recname = StripLastDirectory(*recname);
+        do {
+           if (!RemoveEmptyDirectories(*recname, true))
+              break;
+           recname = StripLastDirectory(*recname);
+           }
+        while (strcmp(*recname, VideoDirectory));
+        }
+     else {
+        int required = DirSizeMB(*source);
+        int available = FreeDiskSpaceMB(*target);
+
+        // validate free space
+        if (required < available) {
+           cReadDir d(*source);
+           struct dirent *e;
+           bool success = true;
+
+           // allocate copying buffer
+           const int len = 1024 * 1024;
+           char *buffer = MALLOC(char, len);
+           if (!buffer) {
+              error = "MALLOC";
+              return;
+              }
+
+           // loop through all files, but skip all sub-directories
+           while (Running() && (e = d.Next()) != NULL) {
+                 // skip generic entries
+                 if (strcmp(e->d_name, ".") && strcmp(e->d_name, "..") && strcmp(e->d_name, "lost+found")) {
+                    cString sourceFile = cString::sprintf("%s%s", *source, e->d_name);
+                    cString targetFile = cString::sprintf("%s%s", *target, e->d_name);
+
+                    // copy only regular files
+                    struct stat sts;
+                    if (!stat(*sourceFile, &sts) && S_ISREG(sts.st_mode)) {
+                       int r = -1, w = -1;
+                       cUnbufferedFile *inputFile = cUnbufferedFile::Create(*sourceFile, O_RDONLY | O_LARGEFILE);
+                       cUnbufferedFile *outputFile = cUnbufferedFile::Create(*targetFile, O_RDWR | O_CREAT | O_LARGEFILE);
+
+                       // validate files
+                       if (!inputFile || !outputFile) {
+                          success = false;
+                          break;
+                          }
+
+                       // do actual copy
+                       do {
+                         r = inputFile->Read(buffer, len);
+                         if (r > 0)
+                            w = outputFile->Write(buffer, r);
+                         else
+                            w = 0;
+                       } while (Running() && r > 0 && w > 0);
+                       DELETENULL(inputFile);
+                       DELETENULL(outputFile);
+
+                       // validate result
+                       if (!Running() || r < 0 || w < 0) {
+                          success = false;
+                          break;
+                          }
+                       }
+                   }
+                }
+
+           // release allocated buffer
+           free(buffer);
+
+           // delete all created target files and directories
+           if (!success) {
+              target = StripLastDirectory(*target);
+              RemoveFileOrDir(*target, true);
+              target = StripLastDirectory(*target);
+              RemoveEmptyDirectories(*target, true);
+              error = "copy failed";
+              return;
+              }
+           }
+        else {
+           // delete all created empty target directories
+           recname = target;
+           recname.Truncate(strlen(*recname) - 1);
+           recname = StripLastDirectory(*recname);
+           do {
+              if (!RemoveEmptyDirectories(*recname, true))
+                 break;
+              recname = StripLastDirectory(*recname);
+              }
+           while (strcmp(*recname, VideoDirectory));
+           error = "insufficient free space";
+           return;
+           }
+        }
+
+     if (deleteSource) {
+        // Recordings' methods require the last directory delimiter to be stripped off
+        source.Truncate(strlen(*source) - 1);
+        cRecording *recording = Recordings.GetByName(*source);
+        if (recording->Delete())
+           Recordings.DelByName(*source, false);
+        }
+     else
+        Recordings.TouchUpdate();
+     }
+}
+
+// --- cFileTransfer ----------------------------------------------------------------
+
+cMutex cFileTransfer::mutex;
+char *cFileTransfer::copiedVersionName = NULL;
+cCopyingThread *cFileTransfer::copyingThread = NULL;
+bool cFileTransfer::error = false;
+bool cFileTransfer::ended = false;
+
+bool cFileTransfer::Start(cRecording *Recording, const char *FileName, bool CopyOnly)
+{
+  cMutexLock MutexLock(&mutex);
+  if (!copyingThread) {
+     cString NewName = NewVideoFileName(Recording->FileName(), FileName);
+     error = false;
+     ended = false;
+     if (strlen(*NewName)) {
+        copiedVersionName = strdup(*NewName);
+        copyingThread = new cCopyingThread(Recording->FileName(), copiedVersionName, !CopyOnly);
+        return true;
+        }
+     }
+  return false;
+}
+
+void cFileTransfer::Stop(void)
+{
+  cMutexLock MutexLock(&mutex);
+  bool Interrupted = copyingThread && copyingThread->Active();
+  const char *Error = copyingThread ? copyingThread->Error() : NULL;
+  DELETENULL(copyingThread);
+  if (Interrupted || Error) {
+     if (Interrupted)
+        isyslog("file transfer has been interrupted");
+     if (Error)
+        esyslog("ERROR: '%s' during file transfer", Error);
+     RemoveVideoFile(copiedVersionName); //XXX what if this file is currently being replayed?
+     Recordings.DelByName(copiedVersionName);
+     free(copiedVersionName);
+     copiedVersionName = NULL;
+     }
+}
+
+bool cFileTransfer::Active(void)
+{
+  cMutexLock MutexLock(&mutex);
+  if (copyingThread) {
+     if (copyingThread->Active())
+        return true;
+     error = copyingThread->Error();
+     Stop();
+     free(copiedVersionName);
+     copiedVersionName = NULL;
+     ended = true;
+     }
+  return false;
+}
+
+bool cFileTransfer::Error(void)
+{
+  cMutexLock MutexLock(&mutex);
+  bool result = error;
+  error = false;
+  return result;
+}
+
+bool cFileTransfer::Ended(void)
+{
+  cMutexLock MutexLock(&mutex);
+  bool result = ended;
+  ended = false;
+  return result;
+}
diff -urN vdr-2.0.1/filetransfer.h vdr-2.0.1.reel/filetransfer.h
--- vdr-2.0.1/filetransfer.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/filetransfer.h	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,33 @@
+/*
+ * filetransfer.h: The video file transfer facilities
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: $
+ */
+
+#ifndef __FILETRANSFER_H
+#define __FILETRANSFER_H
+
+#include "recording.h"
+#include "thread.h"
+
+class cCopyingThread;
+
+class cFileTransfer {
+private:
+  static cMutex mutex;
+  static char *copiedVersionName;
+  static cCopyingThread *copyingThread;
+  static bool error;
+  static bool ended;
+public:
+  static bool Start(cRecording *Recording, const char *NewName, bool CopyOnly = false);
+  static void Stop(void);
+  static bool Active(void);
+  static bool Error(void);
+  static bool Ended(void);
+  };
+
+#endif //__FILETRANSFER_H
diff -urN vdr-2.0.1/help.c vdr-2.0.1.reel/help.c
--- vdr-2.0.1/help.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/help.c	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,494 @@
+#ifdef REELVDR
+#include <string>
+#include <vector>
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "debug.h"
+#include "i18n.h"
+#include "submenu.h" // dynamicmenuEnt
+#include <tinyxml/tinyxml.h>
+#include "help.h"
+#include "skins.h"
+
+
+using std::string;
+
+cHelp::cHelp()
+{
+  editableWidth_ = cSkinDisplay::Current()->EditableWidth();
+  // dsyslog(DBG_PREFIX "   edw: %d", editableWidth_);
+  std::string helpDocument = setup::FileNameFactory("help");
+  //node_
+}
+
+cHelp::~cHelp()
+{
+
+}
+
+
+void cHelp::Load(std::string HelpFile)
+{
+  //load with cMenuMain() && cMenuSetupOSD (if lang changed)
+  dsyslog(" SUBMENU cHelp::Load (parse help.de.xml)  %s ",HelpFile.c_str());
+
+
+
+//http://www.grinninglizard.com/tinyxmldocs/tutorial0.html
+
+
+#if 0
+  text_.clear();
+
+  dsyslog (" TR test: tr(eng)  %s  \n", I18nLanguageCode(::Setup.OSDLanguage));   // const char *s = I18nLanguageCode(Values[i]);
+  string helpfileEnding  = I18nLanguageCode(::Setup.OSDLanguage);   // const char *s = I18nLanguageCode(Values[i]);
+  helpfileEnding = helpfileEnding.substr(0, 3);
+
+  string baseName = setup::FileNameFactory("help");
+  baseName += HelpFile;
+  string trHelpFile = baseName;
+  trHelpFile += '.';
+  trHelpFile += helpfileEnding;
+
+  std::ifstream inFile(trHelpFile.c_str());
+
+  if (!inFile.is_open())
+  {
+    esyslog ("Setup Erorr: Can`t open  help file %s ", trHelpFile.c_str());
+    inFile.close();
+    inFile.clear();
+
+    inFile.open(baseName.c_str());
+    if (!inFile.is_open())
+       esyslog ("Setup Erorr: Can`t open  default help file  %s. Please check xmlConfig file ",baseName.c_str());
+
+  }
+
+  char line[255];
+
+  while (inFile)
+  {
+    inFile.getline(line,255);
+     // skip comments
+    const char *res = NULL;
+    res = strchr(line, '#');
+    title_ = tr("Help");  //XX TODO
+    if (res != &line[0])
+    {
+       for (unsigned int i = 0; i < strlen(&line[0]); i++)
+           text_.push_back(line[i]);
+
+       text_.push_back('\n');
+    }
+  }
+
+  text_.push_back('\0');
+  inFile.close();
+
+  /*
+  std::cout << " Dump Help Text \n";
+  for(vector<char>::const_iterator iter = text_.begin(); iter != text_.end(); ++iter)
+  std::cout << *iter;
+  */
+#endif
+
+}
+
+cHelpPages HelpMenus;
+
+// --- class cHelpSection -----------------------------------------------------
+
+cHelpPage *cHelpSection::GetHelpByTitle(const char *Title) const
+{
+  for (cHelpPage *hp = this->First();hp; hp=this->cList<cHelpPage>::Next(hp))
+  {
+    if (strcmp(Title,hp->Title()) == 0)
+    {
+       return hp;
+    }
+  } 
+  // if nothing found we give first dummy page back
+  return this->First();
+}
+
+// --- class cHelpPages -----------------------------------------------------
+
+void cHelpPages::DumpHelp()
+{
+  /*
+  DLOG (" Dump HelpMenus \n");
+  for (cHelpSection *hs = HelpMenus.First();hs; hs=HelpMenus.Next(hs))
+ {
+    DLOG ("\t +++ Section %s +++\n", hs->Section());
+    for (cHelpPage *hp = hs->First();hp; hp=hs->cList<cHelpPage>::Next(hp))
+    {
+       DLOG ("\t\t -- Title %s\n", hp->Title());
+    } 
+  }
+  DLOG (" Dump HelpMenus End \n\n\n\n");
+  */
+}
+
+
+bool cHelpPages::Load()
+{
+  bool ok = false;
+
+  std::string fileName =  setup::FileNameFactory("help");
+  int fd = open(fileName.c_str(), O_RDONLY);
+  if(fd != -1) {
+     struct stat stat_;
+     if(fstat(fd, &stat_) == 0) {
+        if((lastModified_ != 0) && (lastModified_ == stat_.st_mtime)) {
+           return true;
+        } else {
+           lastModified_ = stat_.st_mtime;
+        }
+     }
+  }
+     
+  HelpMenus.Clear();
+  const char *notAvailable = tr("No help available");
+  cHelpSection *s = new cHelpSection(notAvailable);
+  cHelpPage *help = new cHelpPage(notAvailable, notAvailable); 
+  s->Add(help);
+  HelpMenus.Add(s);
+  
+  DLOG (" Parse file %s", fileName.c_str());
+  TiXmlDocument doc(fileName.c_str());
+  ok = doc.LoadFile(); // args encoding
+  
+  if (ok)
+  {
+    DLOG (" Load OK");
+
+    TiXmlHandle docHandle( &doc);
+    TiXmlHandle handleSection = docHandle.FirstChild("help").FirstChild("section");
+    ParseSection(handleSection);
+  }
+  else 
+  {
+    ok = false;
+
+    DERR (" Error parsing %s : %s", fileName.c_str(), doc.ErrorDesc());
+    DLOG (" \t Col=%d Row=%d\n",doc.ErrorCol(), doc.ErrorRow());
+    esyslog(" Error parsing %s : %s ", fileName.c_str(), doc.ErrorDesc());
+    esyslog(" Col=%d Row=%d\n",doc.ErrorCol(), doc.ErrorRow());
+  }
+
+  //DumpHelp();
+
+  return ok;
+}
+    
+void cHelpPages::ParseSection(TiXmlHandle HandleSection, int Level) 
+{
+  
+  TiXmlElement *elemSection = HandleSection.ToElement();
+  if (!elemSection) 
+  { 
+      //DLOG (" \t get Out ");
+      return; 
+  }
+
+  int sec=1;
+  int t=1; 
+  
+  for(; elemSection; elemSection=elemSection->NextSiblingElement("section"))
+  {
+       //DLOG (" ping 1\n");
+       try 
+       {
+          const char *text =  NULL;
+          const char *section = NULL;
+          TiXmlAttribute *attr = elemSection->FirstAttribute();
+          if (attr) 
+          {
+             section = attr->Value();
+             text = elemSection->GetText();
+             //DLOG ("  %2d.) Get section: <%s> \n",Level, section);
+          }
+
+          // we have to parse each line for <br> resp. <br />
+          std::vector<string>vText;
+          if (text)
+          { 
+             string tmp = text;
+             tmp.append("\n");
+             vText.push_back(tmp);
+             text = NULL;
+             //TiXmlNode* paragraph = elemSection->FirstChild("p");
+             TiXmlNode* nextLine = elemSection->FirstChild("br");
+             //DLOG ("Text: [%s] \n", nextLine?"has <br />":"");
+             for (; nextLine; nextLine = nextLine->NextSibling()) 
+			 {
+                if (nextLine->Type() == TiXmlNode::TINYXML_TEXT)
+                {
+                   text = NULL;
+                   TiXmlText *pText = nextLine->ToText();
+                   text = pText->Value(); 
+                   //DLOG( "Text: [%s] \n", text);
+                   //vText.push_back(string(text) +"\n");
+                   vText.push_back(text);
+                }
+                else if (nextLine->Type() ==TiXmlNode::TINYXML_ELEMENT)
+                {
+                    //DLOG (" is Element Node Val: %s \n", nextLine->Value());
+                    if (strstr(nextLine->Value(), "br") ==  nextLine->Value())
+                        vText.push_back("\n");
+                    else if (strstr(nextLine->Value(), "p") ==  nextLine->Value())
+                        vText.push_back("\n\n  ");
+
+                    else if (strstr(nextLine->Value(), "li") ==  nextLine->Value())
+                    {
+                      if (nextLine->Type() == TiXmlNode::TINYXML_ELEMENT)
+                      {
+                        TiXmlElement *e = nextLine->ToElement();
+                        TiXmlAttribute *attr = e->FirstAttribute();
+
+                        string tmp("\n");
+                        const char *symbol = attr->Value();
+                        if (!symbol)
+                            string tmp("\n ");
+                        else 
+                        tmp += symbol;
+                        vText.push_back(tmp);
+                      }
+                   }
+                }
+			 }
+             /*
+             TiXmlNode* paragraph = elemSection->FirstChild("p");
+             //DLOG ("Text: [%s] \n", paragraph?"has <br />":"");
+             for (; paragraph; paragraph = paragraph->NextSibling()) 
+			 {
+                if (paragraph->Type() == TiXmlNode::TINYXML_TEXT)
+                {
+                   text = NULL;
+                   TiXmlText *pText = paragraph->ToText();
+                   text = pText->Value(); 
+                   //DLOG( "Text: [%s] \n", text);
+                   vText.push_back(string(text) +"\n");
+                }
+			 } */
+          }
+
+          cHelpSection *s = new cHelpSection(section);
+          if (!vText.empty())
+          {
+             cHelpPage *h = new cHelpPage(section, vStringToString(vText)); 
+             s->Add(h);
+             vText.clear();
+          }
+
+          TiXmlNode* nodePage= elemSection->FirstChild("page");
+
+          for (; nodePage; nodePage = nodePage->NextSibling("page"))
+          {
+            try 
+            {
+              vText.clear();
+              text = NULL;
+              const char *title = nodePage->ToElement()->Attribute("title");
+              const char *text = nodePage->ToElement()->GetText();
+              //DLOG ("\t  %2d.) page title: <%s>  \n",t, title);
+              if (text) vText.push_back(string(text) +"\n");
+              TiXmlNode* nextLine = nodePage->FirstChild("br");
+              for (; nextLine; nextLine = nextLine->NextSibling()) 
+              {
+                if (nextLine->Type() == TiXmlNode::TINYXML_TEXT)
+                {
+                   text = NULL;
+                   TiXmlText *pText = nextLine->ToText();
+                   text = pText->Value(); 
+                   //DLOG( "Text: [%s] \n", text);
+                   vText.push_back(string(text) +"\n");
+                }
+              }
+              cHelpPage *help = new cHelpPage(title, vStringToString(vText)); 
+              s->Add(help);
+              t++; 
+            }
+            catch (char *message)
+            {
+              esyslog("ERROR: while decoding XML Node. msg: \"%s\"",message);
+              //ok=false;
+            }
+         }
+         HelpMenus.Add(s);
+
+       }
+       catch (char *message)
+       {
+          esyslog("ERROR: while decoding XML Node. msg: \"%s\"",message);
+          //ok=false;
+       }
+       sec++;
+       //ok = true;
+   }
+
+   ParseSection(HandleSection.FirstChild("section"), Level+1);
+}
+   
+
+cHelpPage *cHelpPages::GetByTitle(const char *Title) const
+{
+  //DLOG (" GetByTitle:  Title %s +++\n", Title);
+  for (cHelpSection *hs = HelpMenus.First();hs; hs=HelpMenus.Next(hs))
+  {
+    //DLOG ("\t parse HelpMenus:  Section %s +++\n", hs->Section());
+    for (cHelpPage *hp = hs->First();hp; hp=hs->cList<cHelpPage>::Next(hp))
+    {
+       if (strcmp(Title,hp->Title()) == 0)
+       {
+           //DLOG("\t\t -- Title %s\n", hp->Title());
+           return hp;
+       }
+    } 
+  }
+  return HelpMenus.First()->First();
+}
+
+cHelpSection *cHelpPages::GetSectionByTitle(const char *Title) const
+{
+
+  //DLOG (" GetSectioniByTitle:  Title %s +++\n", Title);
+  for (cHelpSection *hs = HelpMenus.First();hs; hs=HelpMenus.Next(hs))
+  {
+     // DLOG ("\t parse HelpMenus:  Section %s +++\n", hs->Section());
+
+    for (cHelpPage *hp = hs->First();hp; hp=hs->cList<cHelpPage>::Next(hp))
+    {
+       if (strcmp(Title,hp->Title()) == 0)
+       {
+           //DLOG("\t\t -- Title %s\n", hp->Title());
+           return hs;
+       }
+    } 
+  }
+  return HelpMenus.First();
+}
+
+// --- cMenuHelp --------------------------------------------------------
+
+cMenuHelp::cMenuHelp(cHelpSection *Section, const char *Title)
+:cOsdMenu(Title)
+{
+
+  text = NULL;
+  helpPage = NULL;
+  section = Section;
+  char buffer[128];
+  snprintf(buffer,128, "%s - %s",tr("Help"), Title);
+  SetTitle(buffer);
+
+  if (Section)
+     helpPage = Section->GetHelpByTitle(Title);
+
+  if (helpPage)
+    SetText(helpPage->Text());
+
+  Display();
+}
+
+cMenuHelp::~cMenuHelp()
+{
+  if (text) free(text);
+}
+
+void cMenuHelp::SetText(const char *Text)
+{
+  if (text) free(text);
+  text = Text ? strdup(Text) : NULL;
+}
+void cMenuHelp::SetNextHelp()
+{
+
+  SetStatus(NULL);
+  cHelpPage *h =  static_cast<cHelpPage *>(helpPage->cListObject::Next());
+  if (h) // aviod malloc/free!
+  {
+    helpPage = h;
+    const char *myTitle = helpPage->Title();
+    SetText(helpPage->Text());
+    char buffer[128];
+    snprintf(buffer,128,"%s - %s",tr("Help"), myTitle);
+    SetTitle(buffer);
+    Display();
+  }
+  else
+  {
+     SetStatus(tr("Already first help item"));
+  }
+}
+
+void cMenuHelp::SetPrevHelp()
+{
+  SetStatus(NULL);
+  cHelpPage *h = static_cast<cHelpPage *>(helpPage->cListObject::Prev());
+  if (h)
+  {
+    helpPage = h;
+    const char *myTitle = helpPage->Title();
+    SetText(helpPage->Text());
+
+    char buffer[1024];
+    snprintf(buffer,1024, "%s - %s",tr("Help"), myTitle);
+    SetTitle(buffer);
+    Display();
+  }
+  else
+  {
+     SetStatus(tr("Already last help item"));
+  }
+}
+
+void cMenuHelp::Display(void)
+{
+  cOsdMenu::Display();
+  DisplayMenu()->SetText(text, font == fontFix); //XXX define control character in text to choose the font???
+  if (text)
+     cStatus::MsgOsdTextItem(text);
+}
+
+eOSState cMenuHelp::ProcessKey(eKeys Key)
+{
+  switch (Key) {
+    case kUp|k_Repeat:
+    case kUp:
+
+                  SetNextHelp();
+                  break;
+    case kDown|k_Repeat:
+    case kDown:
+                  SetPrevHelp();
+                  break;
+    case kLeft|k_Repeat:
+    case kLeft:
+    case kRight|k_Repeat:
+    case kRight:
+                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
+                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp);
+                  return osContinue;
+    case kInfo: return osBack; // XXX TOTEST
+    default: break;
+    }
+
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  if (state == osUnknown) {
+     switch (Key) {
+       case kInfo: return osBack;
+       case kOk: return osBack;
+       default:  state = osContinue;
+       }
+     }
+  return state;
+}
+#endif /*REELVDR*/
diff -urN vdr-2.0.1/help.h vdr-2.0.1.reel/help.h
--- vdr-2.0.1/help.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/help.h	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,155 @@
+#ifdef REELVDR
+/*
+ * sources.h: Source handling
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: sources.h 1.4 2005/05/14 09:30:41 kls Exp $
+ */
+
+#ifndef __HELP_H
+#define __HELP_H
+
+#include <vector>
+#include <string>
+#include <sstream>
+#include "tools.h"
+#include "font.h"
+#include "status.h"
+#include "osdbase.h"
+#include <tinyxml/tinyxml.h>
+
+typedef std::vector<std::string>::const_iterator  iterString;
+
+inline std::string vStringToString(std::vector<std::string>& s)
+{
+  std::ostringstream o(std::ostringstream::out);
+  for (iterString iter = s.begin(); iter != s.end(); ++iter)
+  {
+      o << *iter;
+  }
+  std::string tmp = o.str();
+  //printf (" vStringToString ret %s ", tmp.c_str());
+  return o.str();
+}
+
+class cHelp
+{
+public:
+  cHelp();
+  ~cHelp();
+  void Load(std::string Filename);
+  const char *Text();
+  const char *Title();
+private:
+  int editableWidth_;
+  std::vector<char> text_;
+  std::vector<std::string> strText_;
+  std::string title_;
+};
+
+inline const char *cHelp::Text()
+{
+  return &text_[0];
+}
+
+inline const char *cHelp::Title()
+{
+   return title_.c_str();
+}
+
+// --- class cHelpPage 
+class cHelpPage : public cListObject
+{
+public:
+
+cHelpPage(std::string Title, std::string Text)
+  :title_(Title),text_(Text)
+{
+  section_ = "";
+};
+  const char *Title() const;
+  const char *Text() const;
+private:
+  std::string title_;
+  std::string text_;
+  std::string section_;
+};
+
+inline const char *cHelpPage::Title() const
+{
+   return strdup(title_.c_str());
+}
+inline const char *cHelpPage::Text() const
+{
+   return strdup(text_.c_str());
+}
+/*
+inline const char *cHelpPage::Section() const
+{
+   return strdup(section_.c_str());
+}
+*/
+
+// --- class cHelpSection  ------
+
+class cHelpSection : public cList<cHelpPage>, public cListObject
+{
+public:
+  cHelpSection(const char *Section)
+    :section_(Section)
+  {
+  };
+  const char *Section() const;
+  cHelpPage *GetHelpByTitle(const char *Title) const;
+private:
+ std::string section_;
+    
+};
+
+inline const char *cHelpSection::Section() const
+{
+  return strdup(section_.c_str());
+}
+
+// --- class cHelpPages   ------
+class cHelpPages : public cList<cHelpSection> 
+{
+public:
+  cHelpPage *GetByTitle(const char *Title) const;
+  cHelpPage *GetBySection(const char *Section) const;
+  cHelpSection *GetSectionByTitle(const char *Title) const;
+  ///< returns first help page of section
+  bool Load();
+  cHelpPages() { lastModified_ = 0; };
+private:
+  void ParseSection(TiXmlHandle HandleSection, int Level = 0);
+  ///< recursiv parsing of xmlNodes "section" 
+  void DumpHelp();
+  ///< for debug purposes 
+  time_t lastModified_; /** the time of the last modification on the file */
+};
+
+
+extern cHelpPages HelpMenus;
+///< unfortunately "HelpPages" is reserved in svdrp already 
+
+class cMenuHelp : public cOsdMenu {
+private:
+  char *text;
+  cHelpSection *section;
+  cHelpPage *helpPage;
+  eDvbFont font;
+public:
+  cMenuHelp(cHelpSection *Section, const char *Title);
+  virtual ~cMenuHelp();
+  void SetText(const char *Text);
+  void SetNextHelp();
+  void SetPrevHelp();
+  virtual void Display(void);
+  virtual eOSState ProcessKey(eKeys Key);
+  };
+
+#endif //__HELP_H
+#endif /*REELVDR*/
diff -urN vdr-2.0.1/i18n.h vdr-2.0.1.reel/i18n.h
--- vdr-2.0.1/i18n.h	2012-03-11 15:07:45.000000000 +0100
+++ vdr-2.0.1.reel/i18n.h	2013-05-09 18:09:51.283874142 +0200
@@ -12,6 +12,13 @@
 
 #include <stdio.h>
 #include "tools.h"
+#ifdef REELVDR
+const int I18nNumLanguages = 22;
+
+typedef const char *tI18nPhrase[I18nNumLanguages];
+#else
+typedef const char *tI18nPhrase[22]; ///< obsolete - switch to 'gettext'!
+#endif
 
 #define I18N_DEFAULT_LOCALE "en_US"
 #define I18N_MAX_LOCALE_LEN 16       // for buffers that hold en_US etc.
diff -urN vdr-2.0.1/iconpatch.c vdr-2.0.1.reel/iconpatch.c
--- vdr-2.0.1/iconpatch.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/iconpatch.c	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,28 @@
+
+#include "iconpatch.h"
+
+#include <langinfo.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+bool IsLangUtf8(void)
+{
+  char *CodeSet = NULL;
+  if (setlocale(LC_CTYPE, ""))
+     CodeSet = nl_langinfo(CODESET);
+  else {
+     char *LangEnv = getenv("LANG"); // last resort in case locale stuff isn't installed
+     if (LangEnv) {
+        CodeSet = strchr(LangEnv, '.');
+        if (CodeSet)
+           CodeSet++; // skip the dot
+        }
+     }
+
+  if (CodeSet && strcasestr(CodeSet, "UTF-8") != 0)
+     return true;
+
+  return false;
+}
diff -urN vdr-2.0.1/iconpatch.h vdr-2.0.1.reel/iconpatch.h
--- vdr-2.0.1/iconpatch.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/iconpatch.h	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,72 @@
+/*
+ * iconpatch.h: Information of iconpatch
+ *
+ * Diese Datei ist die bersichtsdatei fr den Iconpatch.
+ * Hier werden kleine Infos abgelegt.
+ * Der Iconpatch ndert die Dateien:
+ *   iconpatch.h
+ *   menu.c
+ *   recording.c
+ *   fontosd.c
+ *
+ */
+
+// Iconpatch-Variablen - Anfang
+#define ICON_NUMBERSIGN        "\x23"
+#define ICON_ASTERISK          "\x2A"
+#define ICON_GREATER           "\x3E"
+#define ICON_EXCLAM            "\x21"
+#define ICON_PLUSMINUS         "\xB1"
+
+#define ICON_RESUME            "\x80"
+#define ICON_DVD               "\x81"
+#define ICON_FOLDER            "\x82"
+#define ICON_BLANK             "\x83"
+#define ICON_CUTTING           "\x84"
+#define ICON_MOVE_FILE         "\x85"
+#define ICON_MOVE_FOLDER       "\x86"
+#define ICON_BAR_START         "\x87"
+#define ICON_BAR_FILLED        "\x88"
+#define ICON_BAR_CLEAR         "\x89"
+#define ICON_BAR_END           "\x8A"
+#define ICON_REC               "\x8B"
+#define ICON_CLOCK             "\x8C"
+#define ICON_TV_CRYPTED        "\x8D"
+#define ICON_RADIO             "\x8E"
+#define ICON_TV                "\x8F"
+#define ICON_NEW               "\x90"
+#define ICON_ARROW             "\x91"
+#define ICON_RUNNING           "\x92"
+#define ICON_VPS               "\x93"
+#define ICON_CLOCK_UH          "\x94"
+#define ICON_CLOCK_LH          "\x95"
+
+// UTF-8 Icons
+#define ICON_RESUME_UTF8       "\uE000"
+#define ICON_DVD_UTF8          "\uE001"
+#define ICON_FOLDER_UTF8       "\uE002"
+#define ICON_BLANK_UTF8        "\uE003"
+#define ICON_CUTTING_UTF8      "\uE004"
+#define ICON_MOVE_FILE_UTF8    "\uE005"
+#define ICON_MOVE_FOLDER_UTF8  "\uE006"
+#define ICON_BAR_START_UTF8    "\uE007"
+#define ICON_BAR_FILLED_UTF8   "\uE008"
+#define ICON_BAR_EMPTY_UTF8    "\uE009"
+#define ICON_BAR_CLOSE_UTF8    "\uE00A"
+#define ICON_REC_UTF8          "\uE00B"
+#define ICON_CLOCK_UTF8        "\uE00C"
+#define ICON_TV_CRYPTED_UTF8   "\uE00D"
+#define ICON_RADIO_UTF8        "\uE00E"
+#define ICON_TV_UTF8           "\uE00F"
+#define ICON_NEW_UTF8          "\uE010"
+#define ICON_ARROW_UTF8        "\uE011"
+#define ICON_RUNNING_UTF8      "\uE012"
+#define ICON_VPS_UTF8          "\uE013"
+#define ICON_CLOCK_UH_UTF8     "\uE014"
+#define ICON_CLOCK_LH_UTF8     "\uE015"
+
+// Iconpatch-Variablen - Ende
+
+bool IsLangUtf8(void);
+
+
diff -urN vdr-2.0.1/keys.c vdr-2.0.1.reel/keys.c
--- vdr-2.0.1/keys.c	2012-12-04 13:52:52.000000000 +0100
+++ vdr-2.0.1.reel/keys.c	2013-05-09 18:09:51.283874142 +0200
@@ -57,6 +57,29 @@
                     { kRecordings,    trNOOP("Key$Recordings")  },
                     { kSetup,         trNOOP("Key$Setup")       },
                     { kCommands,      trNOOP("Key$Commands")    },
+#ifdef REELVDR
+                    { kGreater,       trNOOP("Key$Greater")     },
+                    { kLess,          trNOOP("Key$Less")        },
+                    { k2digit,        trNOOP("Key$2digit")      },
+                    { kDVD,           trNOOP("Key$DVD")         },
+                    { kDVB,           trNOOP("Key$DVB")         },
+                    { kPVR,           trNOOP("Key$PVR")         },
+                    { kReel,          trNOOP("Key$Reel")        },
+                    { kTT,            trNOOP("Key$TT")          },
+                    { kPiP,           trNOOP("Key$PiP")         },
+                    { kHelp,          trNOOP("Key$Help")        },
+                    { kEject,         trNOOP("Key$Eject")       },
+                    { kAspect,        trNOOP("Key$Aspect")      },
+                    { kSearch,        trNOOP("Key$Search")      },
+                    { kSearchtimers,  trNOOP("Key$Searchtimers")},
+                    { kInternet,      trNOOP("Key$Internet")    },
+                    { kGuide,         trNOOP("Key$Guide")       },
+                    { kMultimedia,    trNOOP("Key$Multimedia")  },
+                    { kRadio,         trNOOP("Key$Radio")       },
+                    { kHeart,         trNOOP("Key$Heart")       }, //heart symbol
+                    { kFavourites,    trNOOP("Key$Favourites")  },
+                    { kAddFavorite,   trNOOP("Key$AddFavorite") }, //Fav+
+#endif /* REELVDR */
                     { kUser0,         trNOOP("Key$User0")       },
                     { kUser1,         trNOOP("Key$User1")       },
                     { kUser2,         trNOOP("Key$User2")       },
@@ -204,11 +227,17 @@
   for (int i = 0; i < MAXKEYSINMACRO; i++)
       macro[i] = kNone; // for compatibility with old code that doesn't know about NumKeys()
   plugin = NULL;
+#ifdef REELVDR
+  command = NULL;
+#endif
 }
 
 cKeyMacro::~cKeyMacro()
 {
   free(plugin);
+#ifdef REELVDR
+  free(command);
+#endif
 }
 
 bool cKeyMacro::Parse(char *s)
@@ -241,6 +270,17 @@
                  return false;
                  }
               }
+#ifdef REELVDR
+           else if (*p == '!') {
+               command = strdup(p+1);
+           }
+         else {
+           if (command) {
+               command = (char*)realloc(command, strlen(command) + strlen(p) + 1);
+               command = strcat(command, " ");
+               command = strcat(command, p);
+           }
+#endif
            else {
               macro[n] = cKey::FromString(p);
               if (macro[n] == kNone) {
@@ -248,6 +288,9 @@
                  return false;
                  }
               }
+#ifdef REELVDR
+           }
+#endif
            n++;
            s = NULL;
            }
diff -urN vdr-2.0.1/keys.h vdr-2.0.1.reel/keys.h
--- vdr-2.0.1/keys.h	2012-12-04 13:51:25.000000000 +0100
+++ vdr-2.0.1.reel/keys.h	2013-05-09 18:09:51.283874142 +0200
@@ -51,6 +51,16 @@
              kRecordings,
              kSetup,
              kCommands,
+#ifdef REELVDR
+             kGreater, kLess, k2digit,
+             kDVD, kDVB, kPVR, kReel, //51
+             kTT, kPiP,
+             kHelp, kEject, kAspect, kSearch, //57
+             kSearchtimers, kInternet, kGuide, kMultimedia, kRadio, // 63
+             kHeart,
+             kFavourites, //65
+             kAddFavorite,
+#endif /* REELVDR */
              kUser0, kUser1, kUser2, kUser3, kUser4, kUser5, kUser6, kUser7, kUser8, kUser9,
              kNone,
              kKbd,
@@ -122,6 +132,9 @@
   eKeys macro[MAXKEYSINMACRO];
   int numKeys;
   char *plugin;
+#ifdef REELVDR
+  char *command;
+#endif
 public:
   cKeyMacro(void);
   ~cKeyMacro();
@@ -132,6 +145,9 @@
       ///< start at index 1 and go to NumKeys() - 1.
   const eKeys *Macro(void) const { return macro; }
   const char *Plugin(void) const { return plugin; }
+#ifdef REELVDR
+  const char *Command(void) const { return command; }
+#endif
   };
 
 class cKeyMacros : public cConfig<cKeyMacro> {
diff -urN vdr-2.0.1/Make.common vdr-2.0.1.reel/Make.common
--- vdr-2.0.1/Make.common	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/Make.common	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,156 @@
+
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+APIVERSION = $(shell grep 'define APIVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+APIVERSNUM = $(shell grep 'define APIVERSNUM ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g' )
+
+VDRLOCALE = $(shell grep '^LOCALEDIR' $(VDRDIR)/Makefile)
+
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include -I$(DVBDIR)/include
+DEFINES  += -D_GNU_SOURCE -D_LARGEFILE_SOURCE
+DEFINES  += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -DAPIVERSNUM=$(APIVERSNUM)
+
+#ifdef DEBUG
+#  DEFINES += -DDEBUG
+#  CXXFLAGS += -g
+#endif
+
+#ifdef RBLITE
+#  DEFINES += -DRBLITE
+#endif
+
+#ifdef RBMINI
+#  DEFINES += -DRBMINI
+#endif
+
+#ifdef REELVDR
+#  DEFINES += -DREELVDR
+#endif
+
+### Targets:
+
+plug: libvdr-$(PLUGIN).so
+
+all: libvdr-$(PLUGIN).so i18n
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DPLUGIN_NAME='"$(PLUGIN)"' -DPLUGIN_NAME_I18N='"$(PLUGIN)"' $(INCLUDES) -o $@ $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c)   > $@
+
+-include $(DEPFILE)
+
+
+### Internationalization (I18N):
+ifneq ($(strip $(VDRLOCALE)),)
+### do gettext based i18n stuff
+
+PODIR     = po
+LOCALEDIR = $(VDRDIR)/locale
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, \
+		$(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/$(PLUGIN).pot
+
+#%.mo: %.po
+#	msgfmt -c -o $@ $<
+
+.PHONY: $(I18Npot)-rule
+$(I18Npot): $(wildcard *.c $(PLUGIN).h $(EXTRA_I18N))
+	@echo "making: $@"
+	@#echo $(I18Nmsgs)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --from-code=utf-8 --msgid-bugs-address='<reelbox-devel@mailings.reelbox.org>' $^ -o $(I18Npot)
+
+%.po:
+#%.po: $(I18Npot)
+	@echo "making: $@"
+	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
+	@touch $@
+
+$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.po
+	@echo "making: $@"
+	@mkdir -p $(dir $@)
+	msgfmt -c -o $@ $<
+
+.PHONY: i18n
+i18n: $(I18Npot) i18n-pofiles $(I18Nmsgs)
+
+i18n-pofiles: $(I18Npot)
+	@echo "making: $@"
+	@for i in $(I18Npo) ; do \
+		echo msgmerge -U --no-wrap --no-location --backup=none -q $$i $(I18Npot) ;\
+		msgmerge -U -N --no-wrap --no-location --backup=none -q $$i $(I18Npot) ;\
+	done
+
+i18n-dist: $(I18Nmsgs)
+
+#i18n-dist:
+#	@echo "making: $@"
+#	for i in `ls po/*.po` ; do \
+#		odir=`echo $$i | cut -b4-8` ;\
+#		msgfmt -c -o $(LOCALEDIR)/$$odir/LC_MESSAGES/vdr-$(PLUGIN).mo $$i ;\
+#	done
+
+else ### do i18n.c based i18n stuff
+
+i18n:
+	@### nothing to do
+
+#i18n compatibility generator:
+i18n.c: i18n-template.c po2i18n.pl $(I18Npo)
+	./po2i18n.pl < i18n-template.c > i18n.c
+
+endif
+
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LDFLAGS) $(LIBS) -o $@
+	@cp $@ $(LIBDIR)/$@.$(APIVERSION)
+
+dist: distclean
+	@rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.filelist
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.pcs
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevses
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Examples/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Patch/CVS
+	@ln -s $(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE) $(PLUGIN)
+	@rm -rf $(TMPDIR)/$(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(PODIR)/*.mo
+	@-rm -f $(OBJS) $(MAIN) $(DEPFILE) *.so *.tgz core* *~
+	@-rm -f $(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION)
+
+distclean: clean
+	@-rm -f $(PODIR)/*.pot
+
+MAKECOMMON_IS_SOURCED = 1
diff -urN vdr-2.0.1/Make.config vdr-2.0.1.reel/Make.config
--- vdr-2.0.1/Make.config	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/Make.config	2013-05-09 18:09:51.283874142 +0200
@@ -0,0 +1,359 @@
+#
+# User defined Makefile options for the Video Disk Recorder
+#
+# Copy this file to 'Make.config' and change the parameters as necessary.
+#
+# See the main source file 'vdr.c' for copyright information and
+# how to reach the author.
+#
+# $Id: Make.config.template 1.4 2005/05/14 10:32:33 kls Exp $
+
+#uncomment this if you are compiling for RB Lite - not needed if u use makeall.sh for building!
+#RBLITE=1
+
+#uncomment this if you are compiling for RB Mini/NetClient
+#RBMINI=1
+
+#always use this for ReelBox
+REELVDR=1
+
+#don't commit this - just for internal use
+#DEBUG = 1
+
+#default vdr directory version
+VDRVER ?= 2.0.1
+
+### The C compiler and options:
+CCACHE := $(shell which ccache)
+
+# DISTCC = distcc
+MAKE  += -j3
+
+LSB_RELEASE := $(shell lsb_release -sr)
+
+
+ifdef RBMINI
+	CROSS   = arm-linux-gnueabi-
+	MACHINE = -mcpu=arm1176jz-s
+	HOST    = arm9
+	ARCH    = arm
+else ifdef RBLITE
+	MACHINE = -m32 -march=pentium-mmx -mmmx
+	# gcc-3.3 has fomit-frame-pointer bug
+	CXXFLAGS = -g -O2 -funroll-loops $(MACHINE) -Wall -Woverloaded-virtual
+	# gcc-4.x
+	#CXXFLAGS ?= -g -O2 -funroll-loops -fomit-frame-pointer $(MACHINE) -Wall -Woverloaded-virtual
+else
+	#For RB AVG
+	#MACHINE ?= -m32 -march=pentium4m -mmmx -msse2 -mfpmath=sse
+	MACHINE  ?= -m32 -march=pentium3 -mmmx -msse -mfpmath=sse -fPIC
+endif
+
+CC       = $(CCACHE) $(DISTCC) $(CROSS)gcc
+CFLAGS   = -O2 -g -pg $(MACHINE)
+
+CXX      = $(CCACHE) $(DISTCC) $(CROSS)g++
+CXXFLAGS = -g -O2 -funroll-loops -fomit-frame-pointer $(MACHINE) -Wall -Woverloaded-virtual -fpermissive
+
+ifdef RBMINI
+	# used for backtrace
+	CFLAGS   += -funwind-tables
+	CXXFLAGS += -funwind-tables
+endif
+
+STRIP    = $(CROSS)strip
+
+export CC CXX CFLAGS CXXFLAGS
+
+
+### common defines
+
+ifdef RBLITE
+	DVBDIR   = ../kernel/linux-2.6.11.11
+	DEFINES += -DGET_TS_PACKETS
+	DEFINES += -DRBLITE
+
+else ifdef RBMINI
+	DVBDIR   = ../kernel/linux-2.6.18.5
+	DEFINES += -DALWAYS_TS -DRBMINI
+	ifneq ($(VDRVER),1.7)
+		DEFINES += -DGET_TS_PACKETS
+	endif
+	DEFINES += -DRBMINI
+	USEMYSQL = 1
+	#DEVICE_ATTRIBUTES = 1
+		
+else ifeq ($(shell lsb_release -sr), 7.0)
+	CC  := $(CC)-4.7
+	CXX := $(CXX)-4.7
+	DEFINES += -DDVBAPI_V5
+	DEFINES += -DNEW_FFMPEG
+	USEMYSQL = 1
+	#DEVICE_ATTRIBUTES = 1
+	DVBDIR  := /usr/src/linux-headers-3.2.0-4-686-pae
+	VDRVER  := 2.0.1
+
+else ifeq ($(shell lsb_release -sr), 8.04)
+	CC  := $(CC)-4.2
+	CXX := $(CXX)-4.2
+	USEMYSQL = 1
+	DEVICE_ATTRIBUTES = 1
+	DVBDIR   := ../kernel/linux-2.6.24
+	VDRVER  := 1.4
+else
+	#original reelbox release based on ubuntu 7.10, default
+	USEMYSQL = 1
+	DEVICE_ATTRIBUTES = 1
+	DVBDIR   := ../kernel/linux-2.6.22
+endif
+
+
+ifeq ($(VDRVER),2.0.1)
+	USE_BOUQUETS=1
+	#USE_CRASHLOG=1
+	#USE_CUTTERLIMIT=1
+	#USE_CUTTIME = 1
+	#USE_DELAYED_TRICKMODE=1
+	#USE_JUMPPLAY=1
+	USE_LIEMIEXT=1
+	USE_MCLI=1
+	#USE_NOEPG=1
+	USE_PINPLUGIN=1
+	#USE_PLUGINMISSING=1
+	USE_SETUP=1
+	USE_TINYXML=1
+	#USE_TTXTSUBS=1
+	#USE_YAEPG=1 
+	#USE_LIVEBUFFER=1
+       # USE_GRAPHTFT=1
+	#USE_PROVIDERCHARSET=1
+#	dont check for cams in epgsearch
+	CFLC=1
+	EXCLUDE_PLUGINS= -e ipkg -e reelcam -e timeline -e vdrcd
+	PREFIX=/usr
+	LOCDIR=$(PREFIX)/share/locale
+	ifdef RBMINI
+		INCLUDES += -I/usr/arm-linux-gnueabi/include/freetype2 -I$(DVBDIR)/include
+		LIBS     += -lfreetype -lfontconfig
+		EXCLUDE_PLUGINS += -e burn -e graphlcd -e mediad -e netcvrotor -e osdpip -e vlcclient -e xinemediaplayer
+	endif
+endif
+
+ifdef DEBUG
+	DEFINES += -DDEBUG
+	CXXFLAGS += -g
+endif
+
+ifdef RBMINI
+	EXCLUDE_PLUGINS += -e reelbox
+else
+	EXCLUDE_PLUGINS += -e rbmini
+endif
+
+ifdef REELVDR
+	DEFINES  += -DREELVDR
+endif
+
+ifdef USEMYSQL
+	DEFINES  += -DUSEMYSQL
+endif
+
+ifdef DEVICE_ATTRIBUTES
+	DEFINES  += -DDEVICE_ATTRIBUTES
+endif
+
+ifdef USE_CRASHLOG
+	DEFINES += -DUSE_CRASHLOG
+endif
+
+ifdef USE_ALTERNATECHANNEL 
+	DEFINES += -DUSE_ALTERNATECHANNEL
+endif
+
+ifdef USE_CHANNELBIND
+	DEFINES += -DUSE_CHANNELBIND
+endif
+
+ifdef USE_CHANNELPROVIDE
+	DEFINES += -DUSE_CHANNELPROVIDE
+endif
+
+ifdef USE_CUTTERLIMIT
+	DEFINES += -DUSE_CUTTERLIMIT
+endif
+
+ifdef USE_CUTTIME
+	DEFINES += -DUSE_CUTTIME
+endif
+
+ifdef USE_DDEPGENTRY
+	DEFINES += -DUSE_DDEPGENTRY
+endif
+
+ifdef USE_DVLSCRIPTADDON
+	DEFINES += -DUSE_DVLSCRIPTADDON
+endif
+
+ifdef USE_DVLVIDPREFER
+	DEFINES += -DUSE_DVLVIDPREFER
+endif
+
+ifdef USE_GRAPHTFT
+	DEFINES += -DUSE_GRAPHTFT
+endif
+
+ifdef USE_HARDLINKCUTTER
+	DEFINES += -DUSE_HARDLINKCUTTER
+endif
+
+ifdef USE_JUMPINGSECONDS
+	DEFINES += -DUSE_JUMPINGSECONDS
+endif
+
+ifdef USE_JUMPPLAY
+	DEFINES += -DUSE_JUMPPLAY
+endif
+
+ifdef USE_LIEMIEXT
+	DEFINES += -DUSE_LIEMIEXT
+endif
+
+ifdef USE_LIRCSETTINGS
+	DEFINES += -DUSE_LIRCSETTINGS
+endif
+
+ifdef USE_LNBSHARE
+	DEFINES += -DUSE_LNBSHARE
+endif
+
+ifdef USE_MAINMENUHOOKS
+	DEFINES += -DUSE_MAINMENUHOOKS
+endif
+
+ifdef USE_MCLI
+	DEFINES += -DUSE_MCLI
+endif
+
+ifdef USE_MENUORG
+	DEFINES += -DUSE_MENUORG
+endif
+
+ifdef USE_NOEPG
+	DEFINES += -DUSE_NOEPG
+endif
+
+ifdef USE_PINPLUGIN
+	DEFINES += -DUSE_PINPLUGIN
+endif
+
+ifdef USE_PLUGINMISSING
+	DEFINES += -DUSE_PLUGINMISSING
+endif
+
+ifdef USE_ROTOR
+	DEFINES += -DUSE_ROTOR
+endif
+
+ifdef USE_SETUP
+	DEFINES += -DUSE_SETUP
+endif
+
+ifdef USE_TIMERINFO
+	DEFINES += -DUSE_TIMERINFO
+endif
+
+ifdef USE_TTXTSUBS
+	DEFINES += -DUSE_TTXTSUBS
+endif
+
+ifdef USE_VALIDINPUT
+	DEFINES += -DUSE_VALIDINPUT
+endif
+
+ifdef USE_VOLCTRL
+	DEFINES += -DUSE_VOLCTRL
+endif
+
+ifdef USE_WAREAGLEICON
+	DEFINES += -DUSE_WAREAGLEICON
+endif
+
+ifdef USE_YAEPG
+	DEFINES += -DUSE_YAEPG
+endif
+
+ifdef USE_BOUQUETS
+	DEFINES += -DUSE_BOUQUETS
+endif
+
+ifdef USE_DELAYED_TRICKMODE
+	DEFINES += -DUSE_DELAYED_TRICKMODE
+endif
+
+ifdef USE_LIVEBUFFER
+	DEFINES += -DUSE_LIVEBUFFER
+endif
+
+ifdef USE_PROVIDERCHARSET
+        DEFINES += -DUSE_PROVIDERCHARSET=$(USE_PROVIDERCHARSET)
+endif
+
+### The directory environment:
+
+MANDIR   = /usr/man
+BINDIR   = /usr/sbin
+SBINDIR  = /usr/sbin
+
+#only used by plugins
+VDRDIR        = ../../../vdr-$(VDRVER)
+PLUGINDIR     = ../vdr-plugins
+PLUGINLIBDIR  = /usr/lib/vdr
+
+VIDEODIR       = /media/reel/recordings
+CONFIGDIR      = /etc/vdr
+SYSCONFIGFNAME = /etc/default/sysconfig
+
+WITHOUT_MPLAYER=1
+REMOTE=LIRC
+
+# for DVD resume
+RESUMEDIR=/tmp
+
+# defines for burn-pi
+REPLEX_ONLY = 1
+BURN_USE_ISHD = 1
+#USE_PATCHFONT = 1
+
+# for mcli pi
+MCLI_SHARED=1
+
+# for vdr itself
+ifdef REELVDR
+	# for modified TT card (4MB) and ReelBox
+	MAXOSDMEMORY=1000000
+else
+	# for normal TT card (2MB)
+	MAXOSDMEMORY=92000
+endif
+
+#BSPSHM = ../../../bspshm
+
+
+ifdef RBLITE
+	LIRC_DEVICE = /tmp/lircd
+	FP_DEVICE   = /dev/ttyS1
+        FONTPATH    = "/usr/share/graphlcd/fonts/verdanab-009.fnt"
+	LIBCDIO    ?= ../../../../temp/docimage/libs/libcdio
+	LIBMAD     ?= ../../../../temp/docimage/libs/libmad
+	LIBASOUND  ?= ../../../../temp/docimage/libs/alsa-lib
+	LIBDVDNAV  ?= ../../../../temp/docimage/libs/libdvdnav
+	LIBGLCD    ?= ../../../../temp/libs/graphlcd-base
+else
+	LIRC_DEVICE       = /dev/lircd
+	FP_DEVICE         = /dev/frontpanel
+	USER_INPUT_DEVICE = /dev/input/uinput
+	FONTPATH          = "/etc/vdr/plugins/graphlcd/fonts/verdanab-009.fnt"
+endif
+
+export FP_DEVICE LIRC_DEVICE FONTPATH
+
diff -urN vdr-2.0.1/Makefile vdr-2.0.1.reel/Makefile
--- vdr-2.0.1/Makefile	2013-03-11 16:01:01.000000000 +0100
+++ vdr-2.0.1.reel/Makefile	2013-05-09 18:54:34.543920203 +0200
@@ -67,7 +67,7 @@
 SILIB    = $(LSIDIR)/libsi.a
 
 OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbci.o\
-       dvbplayer.o dvbspu.o dvbsubtitle.o eit.o eitscan.o epg.o filter.o font.o i18n.o interface.o keys.o\
+       dvbplayer.o dvbspu.o dvbsubtitle.o eit.o eitscan.o epg.o filetransfer.o filter.o font.o i18n.o interface.o keys.o\
        lirc.o menu.o menuitems.o nit.o osdbase.o osd.o pat.o player.o plugin.o\
        receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sdt.o sections.o shutdown.o\
        skinclassic.o skinlcars.o skins.o skinsttng.o sourceparams.o sources.o spu.o status.o svdrp.o themes.o thread.o\
@@ -103,13 +103,48 @@
 DEFINES += -DRESDIR=\"$(RESDIR)\"
 DEFINES += -DPLUGINDIR=\"$(LIBDIR)\"
 DEFINES += -DLOCDIR=\"$(LOCDIR)\"
+DEFINES += -DSYSCONFIGFNAME=\"$(SYSCONFIGFNAME)\"
+
+
+ifdef USE_LIVEBUFFER
+        OBJS += livebuffer.o
+endif
+
+
+TINYXMLLIB = tinyxml/libtinyxml.a
+        LIBS += $(TINYXMLLIB)
+        INCLUDES += -I.
+
+
+ifdef USE_PROVIDERCHARSET
+        OBJS += providercharsets.o
+endif
+
+
+
+    OBJS += vdrmysql.o
+    LIBS += -lmysqlclient_r
+
+
+
+    OBJS += vdrttxtsubshooks.o
+    OBJS += iconpatch.o
+    OBJS += submenu.o
+    OBJS += help.o
+    OBJS += sysconfig_vdr.o
+#ifdef REELVDR
+        #OBJS += help.o resumeDvd.o reelboxbase.o dvdIndex.o
+        #OBJS += dummyplayer.o
+        #OBJS += menushutdown.o
+        #OBJS += sysconfig_vdr.o
+#endif
 
 # The version numbers of VDR and the plugin API (taken from VDR's "config.h"):
 
 VDRVERSION = $(shell sed -ne '/define VDRVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
 APIVERSION = $(shell sed -ne '/define APIVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
 
-all: vdr i18n plugins
+all: vdr i18n plugins i18n-plugins-dist
 
 # Implicit rules:
 
@@ -125,9 +160,13 @@
 
 -include $(DEPFILE)
 
+# tinyxml lib
+$(TINYXMLLIB):
+	@make -C tinyxml
+
 # The main program:
 
-vdr: $(OBJS) $(SILIB)
+vdr: $(OBJS) $(SILIB) $(TINYXMLLIB)
 	$(CXX) $(CXXFLAGS) -rdynamic $(LDFLAGS) $(OBJS) $(LIBS) $(SILIB) -o vdr
 
 # The libsi library:
@@ -194,6 +233,10 @@
 	@(cd include/vdr; for i in ../../*.h; do ln -fs $$i .; done)
 	@mkdir -p include/libsi
 	@(cd include/libsi; for i in ../../libsi/*.h; do ln -fs $$i .; done)
+ifdef USE_TINYXML
+	@mkdir -p include/tinyxml
+	@(cd include/tinyxml; for i in ../../tinyxml/*.h; do ln -fs $$i .; done)
+endif
 
 # Plugins:
 
diff -urN vdr-2.0.1/Makefile.reel vdr-2.0.1.reel/Makefile.reel
--- vdr-2.0.1/Makefile.reel	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/Makefile.reel	2013-05-09 18:27:39.771892484 +0200
@@ -0,0 +1,382 @@
+#
+# Makefile for the Video Disk Recorder
+#
+# See the main source file 'vdr.c' for copyright information and
+# how to reach the author.
+#
+# $Id: Makefile 2.22 2011/12/04 14:41:00 kls Exp $
+
+.DELETE_ON_ERROR:
+
+CC       ?= gcc
+CFLAGS   ?= -g -O3 -Wall
+
+CXX      ?= g++
+CXXFLAGS ?= -g -O3 -Wall -Woverloaded-virtual -Wno-parentheses
+
+LSIDIR   = ./libsi
+DESTDIR ?=
+PREFIX  ?= /usr/local
+MANDIR   = $(PREFIX)/share/man
+BINDIR   = $(PREFIX)/bin
+INCDIR   = $(PREFIX)/include
+LOCDIR   = ./locale
+LIBS     = -ljpeg -lpthread -ldl -lcap -lrt $(shell pkg-config --libs freetype2 fontconfig)
+INCLUDES ?= $(shell pkg-config --cflags freetype2 fontconfig)
+
+PLUGINDIR= ./PLUGINS
+PLUGINLIBDIR= $(PLUGINDIR)/lib
+
+VIDEODIR = /video
+CONFDIR   ?= /var/lib/vdr
+CACHEDIR  ?= /var/cache/vdr
+
+PREFIX    ?= /usr/local
+BINDIR    ?= $(PREFIX)/bin
+INCDIR    ?= $(PREFIX)/include
+LIBDIR    ?= $(PREFIX)/lib/vdr
+LOCDIR    ?= $(PREFIX)/share/locale
+MANDIR    ?= $(PREFIX)/share/man
+PCDIR     ?= $(PREFIX)/lib/pkgconfig
+RESDIR    ?= $(PREFIX)/share/vdr
+
+
+
+
+DOXYGEN  = /usr/bin/doxygen
+DOXYFILE = Doxyfile
+
+PCDIR   ?= $(firstword $(subst :, , ${PKG_CONFIG_PATH}:$(shell pkg-config --variable=pc_path pkg-config):$(PREFIX)/lib/pkgconfig))
+
+include Make.global
+-include Make.config
+
+SILIB    = $(LSIDIR)/libsi.a
+
+OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbci.o\
+       dvbplayer.o dvbspu.o dvbsubtitle.o eit.o eitscan.o epg.o filetransfer.o filter.o font.o i18n.o\
+       interface.o keys.o lirc.o menu.o menuitems.o nit.o osdbase.o osd.o pat.o player.o plugin.o\
+       receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sdt.o sections.o shutdown.o\
+       skinclassic.o skinlcars.o skins.o skinsttng.o sourceparams.o sources.o spu.o status.o svdrp.o themes.o thread.o\
+       timers.o tools.o transfer.o vdr.o videodir.o
+
+ifndef NO_KBD
+    DEFINES += -DREMOTE_KBD
+endif
+
+ifdef REMOTE
+    DEFINES += -DREMOTE_$(REMOTE)
+endif
+
+ifdef VDR_USER
+    DEFINES += -DVDR_USER=\"$(VDR_USER)\"
+endif
+
+ifdef BIDI
+    INCLUDES += $(shell pkg-config --cflags fribidi)
+    DEFINES += -DBIDI
+    LIBS += $(shell pkg-config --libs fribidi)
+endif
+
+ifdef DEBUG
+    DEFINES += -DDEBUG
+    DEFINES += -DTIME_DEBUG
+endif
+DEFINES += -DLIRC_DEVICE=\"$(LIRC_DEVICE)\"
+DEFINES += -DVIDEODIR=\"$(VIDEODIR)\"
+DEFINES += -DCONFDIR=\"$(CONFDIR)\"
+DEFINES += -DCACHEDIR=\"$(CACHEDIR)\"
+DEFINES += -DRESDIR=\"$(RESDIR)\"
+DEFINES += -DPLUGINDIR=\"$(LIBDIR)\"
+DEFINES += -DLOCDIR=\"$(LOCDIR)\"
+
+
+
+
+ifdef USE_LIVEBUFFER
+        OBJS += livebuffer.o
+endif
+
+
+TINYXMLLIB = tinyxml/libtinyxml.a
+	LIBS += $(TINYXMLLIB)
+	INCLUDES += -I.
+
+
+ifdef USE_PROVIDERCHARSET
+	OBJS += providercharsets.o
+endif
+
+
+
+    OBJS += vdrmysql.o
+    LIBS += -lmysqlclient_r
+
+
+
+    OBJS += vdrttxtsubshooks.o
+    OBJS += iconpatch.o
+    OBJS += submenu.o
+    OBJS += help.o
+    OBJS += sysconfig_vdr.o
+#ifdef REELVDR
+	#OBJS += help.o resumeDvd.o reelboxbase.o dvdIndex.o
+	#OBJS += dummyplayer.o
+	#OBJS += menushutdown.o
+	#OBJS += sysconfig_vdr.o
+#endif
+LIRC_DEVICE ?= /var/run/lirc/lircd
+RCU_DEVICE  ?= /dev/ttyS1
+
+DEFINES += -DLIRC_DEVICE=\"$(LIRC_DEVICE)\" -DRCU_DEVICE=\"$(RCU_DEVICE)\"
+
+DEFINES += -D_GNU_SOURCE
+
+DEFINES += -DVIDEODIR=\"$(VIDEODIR)\"
+DEFINES += -DCONFDIR=\"$(CONFDIR)\"
+DEFINES += -DPLUGINDIR=\"$(PLUGINLIBDIR)\"
+DEFINES += -DLOCDIR=\"$(LOCDIR)\"
+DEFINES += -DSYSCONFIGFNAME=\"$(SYSCONFIGFNAME)\"
+
+# The version numbers of VDR and the plugin API (taken from VDR's "config.h"):
+
+VDRVERSION = $(shell sed -ne '/define VDRVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
+APIVERSION = $(shell sed -ne '/define APIVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
+
+default: vdr
+
+all: vdr i18n plugins i18n-plugins-dist
+
+# Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
+
+-include $(DEPFILE)
+
+# tinyxml lib
+$(TINYXMLLIB):
+	@make -C tinyxml
+
+# The main program:
+
+vdr: $(OBJS) $(SILIB) $(TINYXMLLIB)
+	$(CXX) $(CXXFLAGS) -rdynamic $(LDFLAGS) $(OBJS) $(LIBS) $(LIBDIRS) $(SILIB) -o vdr
+
+# The libsi library:
+
+$(SILIB):
+	$(MAKE) -C $(LSIDIR) all
+
+# pkg-config file:
+
+.PHONY: vdr.pc
+vdr.pc: Makefile Make.global
+	@echo "bindir=$(BINDIR)" > $@
+	@echo "includedir=$(INCDIR)" >> $@
+	@echo "configdir=$(CONFDIR)" >> $@
+	@echo "videodir=$(VIDEODIR)" >> $@
+	@echo "plugindir=$(PLUGINLIBDIR)" >> $@
+	@echo "localedir=$(LOCDIR)" >> $@
+	@echo "apiversion=$(APIVERSION)" >> $@
+	@echo "cflags=$(CXXFLAGS) $(DEFINES) -I\$${includedir}" >> $@
+	@echo "plugincflags=\$${cflags} -fPIC" >> $@
+	@echo "" >> $@
+	@echo "Name: VDR" >> $@
+	@echo "Description: Video Disk Recorder" >> $@
+	@echo "URL: http://www.tvdr.de/" >> $@
+	@echo "Version: $(VDRVERSION)" >> $@
+	@echo "Cflags: \$${cflags}" >> $@
+
+# Internationalization (I18N):
+
+PODIR     = po
+LOCALEDIR = locale
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr.mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/vdr.pot
+
+%.mo: %.po
+	msgfmt -c -o $@ $<
+
+$(I18Npot): $(wildcard *.c)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=VDR --package-version=$(VDRVERSION) --msgid-bugs-address='<vdr-bugs@tvdr.de>' -o $@ `ls $^`
+
+%.po: $(I18Npot)
+	msgmerge -U -N --no-wrap --no-location --backup=none -q $@ $<
+	@touch $@
+
+$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr.mo: $(PODIR)/%.mo
+	@mkdir -p $(dir $@)
+	cp $< $@
+
+.PHONY: i18n
+i18n: $(I18Nmsgs)
+
+install-i18n:
+	@mkdir -p $(DESTDIR)$(LOCDIR)
+	@(cd $(LOCALEDIR); cp -r --parents * $(DESTDIR)$(LOCDIR))
+
+ifdef REELVDR
+i18n-dist: i18n-vdr-dist i18n-plugins-dist
+
+i18n-vdr-dist:
+	@echo making $(@F)
+	@for i in po/*.po ; do \
+		odir=`echo $$i | cut -b4-8` ;\
+		[ -d  $(LOCALEDIR)/$$odir/LC_MESSAGES ] || mkdir -p $(LOCALEDIR)/$$odir/LC_MESSAGES ;\
+		echo msgfmt -c $$i -o $(LOCALEDIR)/$$odir/LC_MESSAGES/vdr.mo ;\
+		msgfmt -c $$i -o $(LOCALEDIR)/$$odir/LC_MESSAGES/vdr.mo ;\
+	done
+
+i18n-plugins:
+	@echo making $(@F)
+	for i in `ls $(PLUGINDIR)/src | grep -ve '[^a-z0-9]' $(EXCLUDE_PLUGINS)`; do\
+		$(MAKE) -C "$(PLUGINDIR)/src/$$i" i18n || exit 1 ;\
+	done
+
+i18n-plugins-dist:
+	@echo making $(@F)
+	for i in `ls $(PLUGINDIR)/src | grep -ve '[^a-z0-9]' $(EXCLUDE_PLUGINS)`; do\
+		$(MAKE) -C "$(PLUGINDIR)/src/$$i" i18n-dist || exit 1 ;\
+	done
+
+endif
+
+# The 'include' directory (for plugins):
+
+include-dir:
+	@mkdir -p include/vdr
+	@(cd include/vdr; for i in ../../*.h; do ln -fs $$i .; done)
+	@mkdir -p include/libsi
+	@(cd include/libsi; for i in ../../libsi/*.h; do ln -fs $$i .; done)
+ifdef USE_TINYXML
+	@mkdir -p include/tinyxml
+	@(cd include/tinyxml; for i in ../../tinyxml/*.h; do ln -fs $$i .; done)
+endif
+
+# Plugins:
+
+ifdef REELVDR
+plugins: include-dir vdr.pc
+	@failed="";\
+	noapiv="";\
+	nocommon="";\
+	for i in `ls $(PLUGINDIR)/src | grep -ve '[^a-z0-9]' $(EXCLUDE_PLUGINS)`; do\
+	    echo "Plugin $$i:";\
+	    if ! grep -q "^[-]\?include \$$(VDRDIR)/Make.common" "$(PLUGINDIR)/src/$$i/Makefile" ; then\
+	       if ! grep -q "\$$(LIBDIR)/.*\$$(APIVERSION)" "$(PLUGINDIR)/src/$$i/Makefile" ; then\
+	         echo "ERROR: plugin $$i doesn't honor APIVERSION - not compiled!";\
+	         noapiv="$$noapiv $$i";\
+	         continue;\
+	       else \
+	         echo "WARNING: plugin $$i doesn't honor Make.common!";\
+	         nocommon="$$nocommon $$i";\
+	       fi;\
+	    fi; \
+	    $(MAKE) -C "$(PLUGINDIR)/src/$$i" plug i18n-dist || failed="$$failed $$i";\
+	done;\
+	if [ -n "$$nocommon" ] ; then echo; echo "*** plugins without Make.common:$$nocommon"; echo; fi; \
+	if [ -n "$$noapiv" ] ; then echo; echo "*** plugins without APIVERSION:$$noapiv"; echo; fi;\
+	if [ -n "$$failed" ] ; then echo; echo "*** failed plugins:$$failed"; echo; exit 1; fi
+else
+plugins: include-dir
+	@failed="";\
+	noapiv="";\
+	for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do\
+	    echo "Plugin $$i:";\
+	    if ! grep -q "\$$(LIBDIR)/.*\$$(APIVERSION)" "$(PLUGINDIR)/src/$$i/Makefile" ; then\
+	       echo "ERROR: plugin $$i doesn't honor APIVERSION - not compiled!";\
+	       noapiv="$$noapiv $$i";\
+	       continue;\
+	    fi \
+	    $(MAKE) -C "$(PLUGINDIR)/src/$$i" all || failed="$$failed $$i";\
+	    done;\
+	if [ -n "$$noapiv" ] ; then echo; echo "*** plugins without APIVERSION:$$noapiv"; echo; fi;\
+	if [ -n "$$failed" ] ; then echo; echo "*** failed plugins:$$failed"; echo; exit 1; fi
+endif
+
+clean-plugins plugins-clean:
+	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" clean; done
+	@-rm -f $(PLUGINDIR)/lib/lib*-*.so.$(APIVERSION)
+
+# Install the files:
+
+install: install-bin install-conf install-doc install-plugins install-i18n install-includes
+
+# VDR binary:
+
+install-bin: vdr
+	@echo "Install bin to $(DESTDIR)$(BINDIR)"
+	@mkdir -p $(DESTDIR)$(BINDIR)
+	@cp --remove-destination vdr svdrpsend $(DESTDIR)$(BINDIR)
+
+# Configuration files:
+
+install-dirs:
+	@mkdir -p $(DESTDIR)$(VIDEODIR)
+	@mkdir -p $(DESTDIR)$(CONFDIR)
+	@mkdir -p $(DESTDIR)$(CACHEDIR)
+	@mkdir -p $(DESTDIR)$(RESDIR)
+
+install-conf:
+	@mkdir -p $(DESTDIR)$(VIDEODIR)
+	@mkdir -p $(DESTDIR)$(CONFDIR)
+	@mkdir -p $(DESTDIR)$(CACHEDIR)
+	@mkdir -p $(DESTDIR)$(RESDIR)
+	@cp -pn *.conf $(DESTDIR)$(CONFDIR)
+
+# Documentation:
+
+install-doc:
+	@mkdir -p $(DESTDIR)$(MANDIR)/man1
+	@mkdir -p $(DESTDIR)$(MANDIR)/man5
+	@gzip -c vdr.1 > $(DESTDIR)$(MANDIR)/man1/vdr.1.gz
+	@gzip -c vdr.5 > $(DESTDIR)$(MANDIR)/man5/vdr.5.gz
+
+# Plugins:
+
+install-plugins: plugins
+	@echo "Install plugins to $(DESTDIR)$(PLUGINLIBDIR)"
+	@mkdir -p $(DESTDIR)$(PLUGINLIBDIR)
+
+# Includes:
+
+install-includes: include-dir
+	@mkdir -p $(DESTDIR)$(INCDIR)
+	@cp -pLR include/vdr include/libsi $(DESTDIR)$(INCDIR)
+
+# pkg-config file:
+
+install-pc: vdr.pc
+	if [ -n "$(PCDIR)" ] ; then \
+	    mkdir -p $(DESTDIR)$(PCDIR) ; \
+	    cp vdr.pc $(DESTDIR)$(PCDIR) ; \
+	    fi
+
+# Source documentation:
+
+srcdoc:
+	@cp $(DOXYFILE) $(DOXYFILE).tmp
+	@echo PROJECT_NUMBER = $(VDRVERSION) >> $(DOXYFILE).tmp
+	$(DOXYGEN) $(DOXYFILE).tmp
+	@rm $(DOXYFILE).tmp
+
+# Housekeeping:
+
+clean: clean-vdr clean-plugins
+
+clean-vdr vdr-clean:
+	$(MAKE) -C $(LSIDIR) clean
+	-rm -f $(OBJS) $(DEPFILE) vdr vdr.pc core* *~
+	-rm -rf $(LOCALEDIR) $(PODIR)/*.mo $(PODIR)/*.pot
+	-rm -rf srcdoc
+CLEAN: clean
+
diff -urN vdr-2.0.1/Make.global vdr-2.0.1.reel/Make.global
--- vdr-2.0.1/Make.global	2012-12-29 13:03:01.000000000 +0100
+++ vdr-2.0.1.reel/Make.global	2013-05-09 18:09:51.283874142 +0200
@@ -4,7 +4,14 @@
 # See the main source file 'vdr.c' for copyright information and
 # how to reach the author.
 #
-# $Id: Make.global 1.2 2012/12/29 12:03:01 kls Exp $
+# $Id: Make.global 1.1 2010/02/06 14:54:12 kls Exp $
 
-# This is just a dummy file for plugins that use old style (version 1.7.33
-# or earlier) Makefiles.
+# Plugins need to be compiled with position independent code, otherwise linking
+# VDR against it will fail.
+
+ifdef PLUGIN
+CFLAGS   += -fPIC
+CXXFLAGS += -fPIC
+endif
+
+DEFINES += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
diff -urN vdr-2.0.1/MANUAL vdr-2.0.1.reel/MANUAL
--- vdr-2.0.1/MANUAL	2013-03-11 13:01:11.000000000 +0100
+++ vdr-2.0.1.reel/MANUAL	2013-05-09 18:09:51.287874141 +0200
@@ -48,7 +48,7 @@
   FastRew     fast rewind
 
   Next        Next/previous channel group (in live tv mode)
-  Prev        or next/previous editing mark (in replay mode)
+  Prev        or binary skipping (in replay mode)
 
   Channel+    channel up
   Channel-    channel down
@@ -761,6 +761,9 @@
                          background transparency. By default the values as broadcast
                          are used.
 
+  Record Teletext Subtitles = no
+                         If set to 'yes', teletext subtitles will be recorded.
+
   LNB:
 
   Use DiSEqC = no        Generally turns DiSEqC support on or off.
@@ -902,6 +905,25 @@
                          0 resulting in a file named 'resume', and any other
                          value resulting in 'resume.n'.
 
+  Jump&Play = no         Turns playing on or off after jumping forward to the
+                         next editing mark with the '9' key.
+
+  Play&Jump = no         Turns automatic jumping over commercial breaks on or
+                         off. This includes jumping to the first mark, if the
+                         replay starts at the beginning of a recording - and
+                         stopping the replay at the last mark.
+                         With this setting enabled, the behaviour of the '8'
+                         key during replay is changed too. It moves the actual
+                         replay position not only three seconds before the
+                         next "start" mark, but also before the next "end"
+                         mark. This can be used to test, if the editing marks
+                         are correctly positioned for a "smooth" jump over a
+                         commercial break.
+
+  Pause at last mark = no
+                         Turns pausing of replay at the last editing mark on or
+                         off.
+
   Miscellaneous:
 
   Min. event timeout = 30
diff -urN vdr-2.0.1/menu.c vdr-2.0.1.reel/menu.c
--- vdr-2.0.1/menu.c	2013-03-18 10:11:48.000000000 +0100
+++ vdr-2.0.1.reel/menu.c	2013-05-09 18:09:51.287874141 +0200
@@ -8,6 +8,7 @@
  */
 
 #include "menu.h"
+#include "iconpatch.h"
 #include <ctype.h>
 #include <limits.h>
 #include <math.h>
@@ -18,6 +19,7 @@
 #include "config.h"
 #include "cutter.h"
 #include "eitscan.h"
+#include "filetransfer.h"
 #include "i18n.h"
 #include "interface.h"
 #include "plugin.h"
@@ -32,6 +34,8 @@
 #include "transfer.h"
 #include "videodir.h"
 
+#include "remotetimers.h"
+
 #define MAXWAIT4EPGINFO   3 // seconds
 #define MODETIMEOUT       3 // seconds
 #define NEWTIMERLIMIT   120 // seconds until the start time of a new timer created from the Schedule menu,
@@ -94,6 +98,7 @@
 
 // --- cMenuEditSrcItem ------------------------------------------------------
 
+#ifndef REELVDR
 class cMenuEditSrcItem : public cMenuEditIntItem {
 private:
   const cSource *source;
@@ -103,6 +108,7 @@
   cMenuEditSrcItem(const char *Name, int *Value);
   eOSState ProcessKey(eKeys Key);
   };
+#endif
 
 cMenuEditSrcItem::cMenuEditSrcItem(const char *Name, int *Value)
 :cMenuEditIntItem(Name, Value, 0)
@@ -167,6 +173,7 @@
 public:
   cMenuEditChannel(cChannel *Channel, bool New = false);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuEditChannel"; }
   };
 
 cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
@@ -316,6 +323,14 @@
   if (!channel->GroupSep()) {
      if (sortMode == csmProvider)
         buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
+        else if (Setup.WarEagleIcons) {
+           if (channel->Vpid() == 1 || channel->Vpid() == 0)
+              buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_RADIO_UTF8 : ICON_RADIO, channel->Name());
+           else if (channel->Ca() == 0)
+              buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_UTF8 : ICON_TV, channel->Name());
+        else
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_CRYPTED_UTF8 : ICON_TV_CRYPTED, channel->Name());
+        }
      else
         buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
      }
@@ -352,6 +367,7 @@
   cMenuChannels(void);
   ~cMenuChannels();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuChannels"; }
   };
 
 cMenuChannels::cMenuChannels(void)
@@ -896,6 +912,15 @@
      Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
      Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
      Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
+     if (cOsd::pinValid || !data.fskProtection) Add(new cMenuEditBoolItem(tr("Childlock"),&data.fskProtection));
+     else { 
+        char* buf = 0;
+        if (asprintf(&buf, "%s\t%s", tr("Childlock"), data.fskProtection ? tr("yes") : tr("no")) >= 0){
+           Add(new cOsdItem(buf));
+           free(buf);
+           }
+        }
+
      Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
      SetFirstDayItem();
      }
@@ -1044,8 +1069,8 @@
      File++;
   else
      File = timer->File();
-  SetText(cString::sprintf("%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
-                    !(timer->HasFlags(tfActive)) ? ' ' : timer->FirstDay() ? '!' : timer->Recording() ? '#' : '>',
+  SetText(cString::sprintf("%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+		    !(timer->HasFlags(tfActive)) ? " " : timer->FirstDay() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_ARROW_UTF8 : ICON_ARROW : "!" : timer->Recording() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_REC_UTF8 : ICON_REC : "#" : Setup.WarEagleIcons ? IsLangUtf8() ? ICON_CLOCK_UTF8 : ICON_CLOCK : ">",
                     timer->Channel()->Number(),
                     *name,
                     *name && **name ? " " : "",
@@ -1079,6 +1104,7 @@
   cMenuTimers(void);
   virtual ~cMenuTimers();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuTimers"; }
   };
 
 cMenuTimers::cMenuTimers(void)
@@ -1241,6 +1267,7 @@
 {
   cOsdMenu::Display();
   DisplayMenu()->SetEvent(event);
+  cStatus::MsgOsdSetEvent(event);
   if (event->Description())
      cStatus::MsgOsdTextItem(event->Description());
 }
@@ -1319,7 +1346,12 @@
   return r;
 }
 
-static const char *TimerMatchChars = " tT";
+static const char *TimerMatchChars[9] =
+{
+  " ", "t", "T",
+  ICON_BLANK, ICON_CLOCK_UH, ICON_CLOCK,
+  ICON_BLANK_UTF8, ICON_CLOCK_UH_UTF8, ICON_CLOCK_UTF8
+};
 
 bool cMenuScheduleItem::Update(bool Force)
 {
@@ -1328,17 +1360,17 @@
   Timers.GetMatch(event, &timerMatch);
   if (Force || timerMatch != OldTimerMatch) {
      cString buffer;
-     char t = TimerMatchChars[timerMatch];
-     char v = event->Vps() && (event->Vps() - event->StartTime()) ? 'V' : ' ';
-     char r = event->SeenWithin(30) && event->IsRunning() ? '*' : ' ';
+     const char *t = Setup.WarEagleIcons ? IsLangUtf8() ? TimerMatchChars[timerMatch+6] : TimerMatchChars[timerMatch+3] : TimerMatchChars[timerMatch];
+     const char *v = event->Vps() && (event->Vps() - event->StartTime()) ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_VPS_UTF8 : ICON_VPS : "V" : " ";
+     const char *r = event->SeenWithin(30) && event->IsRunning() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_RUNNING_UTF8 : ICON_RUNNING : "*" : " ";
      const char *csn = channel ? channel->ShortName(true) : NULL;
      cString eds = event->GetDateString();
      if (channel && withDate)
-        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
      else if (channel)
-        buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
+        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
      else
-        buffer = cString::sprintf("%.*s\t%s\t%c%c%c\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+        buffer = cString::sprintf("%.*s\t%s\t%s%s%s\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
      SetText(buffer);
      result = true;
      }
@@ -1370,6 +1402,8 @@
   static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
   static const cEvent *ScheduleEvent(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
+  virtual void Display(void);
   };
 
 int cMenuWhatsOn::currentChannel = 0;
@@ -1398,6 +1432,18 @@
   SetHelpKeys();
 }
 
+void cMenuWhatsOn::Display(void)
+{
+   cOsdMenu::Display();
+
+   if (Count() > 0) {
+      int ni = 0;
+      for (cOsdItem *item = First(); item; item = Next(item)) {
+         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
+      }
+   }
+}
+
 bool cMenuWhatsOn::Update(void)
 {
   bool result = false;
@@ -1538,6 +1584,8 @@
   cMenuSchedule(void);
   virtual ~cMenuSchedule();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSchedule"; }
+  virtual void Display(void);
   };
 
 cMenuSchedule::cMenuSchedule(void)
@@ -1564,6 +1612,18 @@
   cMenuWhatsOn::ScheduleEvent(); // makes sure any posted data is cleared
 }
 
+void cMenuSchedule::Display(void)
+{
+   cOsdMenu::Display();
+
+   if (Count() > 0) {
+      int ni = 0;
+      for (cOsdItem *item = First(); item; item = Next(item)) {
+         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
+      }
+   }
+}
+
 void cMenuSchedule::PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel)
 {
   Clear();
@@ -1928,6 +1988,7 @@
   cMenuCam(cCamSlot *CamSlot);
   virtual ~cMenuCam();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuCam"; }
   };
 
 cMenuCam::cMenuCam(cCamSlot *CamSlot)
@@ -2115,6 +2176,7 @@
   cMenuRecording(const cRecording *Recording, bool WithButtons = false);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuRecording"; }
 };
 
 cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
@@ -2131,6 +2193,7 @@
 {
   cOsdMenu::Display();
   DisplayMenu()->SetRecording(recording);
+  cStatus::MsgOsdSetRecording(recording);
   if (recording->Info()->Description())
      cStatus::MsgOsdTextItem(recording->Info()->Description());
 }
@@ -2218,6 +2281,167 @@
      DisplayMenu->SetItem(Text(), Index, Current, Selectable);
 }
 
+// --- cMenuEditRecording ----------------------------------------------------
+
+class cMenuEditRecording : public cOsdMenu {
+private:
+  char name[MaxFileName];
+  cMenuEditStrItem *file;
+  cOsdItem *marksItem, *resumeItem;
+  bool isResume, isMarks;
+  cRecording *recording;
+  void SetHelpKeys(void);
+  eOSState SetFolder(void);
+public:
+  cMenuEditRecording(cRecording *Recording);
+  virtual eOSState ProcessKey(eKeys Key);
+};
+
+cMenuEditRecording::cMenuEditRecording(cRecording *Recording)
+:cOsdMenu(tr("Edit recording"), 14)
+{
+  cMarks marks;
+
+  file = NULL;
+  recording = Recording;
+
+  if (recording) {
+     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
+     Add(file = new cMenuEditStrItem(tr("File"), name, sizeof(name)));
+
+     Add(new cOsdItem("", osUnknown, false));
+
+     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->Start())), osUnknown, false));
+
+     cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
+     if (channel)
+        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
+
+     int recLen = recording->LengthInSeconds();
+     if (recLen >= 0)
+        Add(new cOsdItem(cString::sprintf("%s:\t%d:%02d:%02d", tr("Length"), recLen / 3600, recLen / 60 % 60, recLen % 60), osUnknown, false));
+     else
+        recLen = 0;
+
+     int dirSize = DirSizeMB(recording->FileName());
+     cString bitRate = recLen ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / recLen) : cString("");
+     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Format"), recording->IsPesRecording() ? tr("PES") : tr("TS")), osUnknown, false));
+     Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
+
+     Add(new cOsdItem("", osUnknown, false));
+
+     isMarks = marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && marks.Count();
+     marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
+     Add(marksItem);
+
+     cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
+     isResume = (ResumeFile.Read() != -1);
+     resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
+     Add(resumeItem);
+     }
+
+  SetHelpKeys();
+}
+
+void cMenuEditRecording::SetHelpKeys(void)
+{
+  SetHelp(tr("Button$Folder"), tr("Button$Cut"), tr("Button$Copy"), tr("Button$Rename/Move"));
+}
+
+eOSState cMenuEditRecording::SetFolder(void)
+{
+  cMenuFolder *mf = (cMenuFolder *)SubMenu();
+  if (mf) {
+     cString Folder = mf->GetFolder();
+     char *p = strrchr(name, FOLDERDELIMCHAR);
+     if (p)
+        p++;
+     else
+        p = name;
+     if (!isempty(*Folder))
+        strn0cpy(name, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(name));
+     else if (p != name)
+        memmove(name, p, strlen(p) + 1);
+     SetCurrent(file);
+     Display();
+     }
+  return CloseSubMenu();
+}
+
+eOSState cMenuEditRecording::ProcessKey(eKeys Key)
+{
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  if (state == osUnknown) {
+     switch (Key) {
+       case kRed:
+            return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, name));
+            break;
+       case kGreen:
+            if (!cCutter::Active()) {
+               if (!isMarks)
+                  Skins.Message(mtError, tr("No editing marks defined!"));
+               else if (!cCutter::Start(recording->FileName(), strcmp(recording->Name(), name) ? *NewVideoFileName(recording->FileName(), name) : NULL, false))
+                  Skins.Message(mtError, tr("Can't start editing process!"));
+               else
+                  Skins.Message(mtInfo, tr("Editing process started"));
+               }
+            else
+               Skins.Message(mtError, tr("Editing process already active!"));
+            return osContinue;
+       case kYellow:
+       case kBlue:
+            if (strcmp(recording->Name(), name)) {
+               if (!cFileTransfer::Active()) {
+                  if (cFileTransfer::Start(recording, name, (Key == kYellow)))
+                     Skins.Message(mtInfo, tr("File transfer started"));
+                  else
+                     Skins.Message(mtError, tr("Can't start file transfer!"));
+                  }
+               else
+                  Skins.Message(mtError, tr("File transfer already active!"));
+               }
+            return osRecordings;
+       default:
+            break;
+       }
+     return osContinue;
+     }
+  else if (state == osEnd && HasSubMenu())
+     state = SetFolder();
+  else if (state == osUser1) {
+     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
+        cMarks marks;
+        marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording());
+        cMark *mark = marks.First();
+        while (mark) {
+              cMark *nextmark = marks.Next(mark);
+              marks.Del(mark);
+              mark = nextmark;
+              }
+        marks.Save();
+        isMarks = false;
+        marksItem->SetSelectable(isMarks);
+        SetCurrent(First());
+        Display();
+        }
+     return osContinue;
+     }
+  else if (state == osUser2) {
+     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
+        cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
+        ResumeFile.Delete();
+        isResume = false;
+        resumeItem->SetSelectable(isResume);
+        SetCurrent(First());
+        Display();
+        }
+     return osContinue;
+     }
+
+  return state;
+}
+
 // --- cMenuRecordings -------------------------------------------------------
 
 cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
@@ -2294,7 +2518,8 @@
                    }
                 }
             }
-         if (*Item->Text() && !LastDir) {
+         if (*Item->Text() && !LastDir
+            && (!cStatus::MsgReplayProtected(Item->Recording(), Item->Name(), base, Item->IsDirectory(), true))) { // PIN PATCH
             Add(Item);
             LastItem = Item;
             if (Item->IsDirectory())
@@ -2347,6 +2572,9 @@
 {
   cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
   if (ri) {
+     if (cStatus::MsgReplayProtected(ri->Recording(), ri->Name(), base,
+                                     ri->IsDirectory()) == true)
+        return osContinue;
      if (ri->IsDirectory())
         Open();
      else {
@@ -2460,6 +2688,16 @@
   return osContinue;
 }
 
+eOSState cMenuRecordings::Edit(void)
+{
+  if (HasSubMenu() || Count() == 0)
+     return osContinue;
+  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
+  if (ri && !ri->IsDirectory() && ri->Recording())
+     return AddSubMenu(new cMenuEditRecording(ri->Recording()));
+  return osContinue;
+}
+
 eOSState cMenuRecordings::ProcessKey(eKeys Key)
 {
   bool HadSubMenu = HasSubMenu();
@@ -2473,7 +2711,7 @@
        case kRed:    return (helpKeys > 1 && RecordingCommands.Count()) ? Commands() : Play();
        case kGreen:  return Rewind();
        case kYellow: return Delete();
-       case kInfo:
+       case kInfo:   return Edit();
        case kBlue:   return Info();
        case k0:      return Sort();
        case k1...k9: return Commands(Key);
@@ -2540,6 +2778,7 @@
   cMenuSetupOSD(void);
   virtual ~cMenuSetupOSD();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetupOsd"; }
   };
 
 cMenuSetupOSD::cMenuSetupOSD(void)
@@ -2586,6 +2825,7 @@
   Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
   if (themes.NumThemes())
   Add(new cMenuEditStraItem(tr("Setup.OSD$Theme"),                  &themeIndex, themes.NumThemes(), themes.Descriptions()));
+  Add(new cMenuEditBoolItem(tr("Setup.OSD$WarEagle icons"),         &data.WarEagleIcons));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Left (%)"),               &data.OSDLeftP, 0.0, 0.5));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Top (%)"),                &data.OSDTopP, 0.0, 0.5));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Width (%)"),              &data.OSDWidthP, 0.5, 1.0));
@@ -2693,6 +2933,7 @@
 public:
   cMenuSetupEPG(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetupEpg"; }
   };
 
 cMenuSetupEPG::cMenuSetupEPG(void)
@@ -2790,6 +3031,7 @@
 public:
   cMenuSetupDVB(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetupDvb"; }
   };
 
 cMenuSetupDVB::cMenuSetupDVB(void)
@@ -2843,6 +3085,7 @@
      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
      }
+  Add(new cMenuEditBoolItem(tr("Setup.DVB$Enable teletext support"), &data.SupportTeletext));
 
   SetCurrent(Get(current));
   Display();
@@ -2935,6 +3178,7 @@
 public:
   cMenuSetupLNB(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetupLnb"; }
   };
 
 cMenuSetupLNB::cMenuSetupLNB(void)
@@ -3040,6 +3284,7 @@
 public:
   cMenuSetupCAM(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetupCam"; }
   };
 
 cMenuSetupCAM::cMenuSetupCAM(void)
@@ -3168,6 +3413,12 @@
   Add(new cMenuEditIntItem( tr("Setup.Replay$Progress display time (s)"), &data.ProgressDisplayTime, 0, 60));
   Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause replay when setting mark"), &data.PauseOnMarkSet));
   Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"), &data.JumpPlay));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"), &data.PlayJump));
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds"), &data.JumpSeconds));
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds Slow"), &data.JumpSecondsSlow));
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds (Repeat)"), &data.JumpSecondsRepeat));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
 }
 
 void cMenuSetupReplay::Store(void)
@@ -3204,6 +3455,7 @@
 
 // --- cMenuSetupPluginItem --------------------------------------------------
 
+#ifndef REELVDR
 class cMenuSetupPluginItem : public cOsdItem {
 private:
   int pluginIndex;
@@ -3211,6 +3463,7 @@
   cMenuSetupPluginItem(const char *Name, int Index);
   int PluginIndex(void) { return pluginIndex; }
   };
+#endif
 
 cMenuSetupPluginItem::cMenuSetupPluginItem(const char *Name, int Index)
 :cOsdItem(Name)
@@ -3224,6 +3477,7 @@
 public:
   cMenuSetupPlugins(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
   };
 
 cMenuSetupPlugins::cMenuSetupPlugins(void)
@@ -3279,6 +3533,7 @@
 public:
   cMenuSetup(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuSetup"; }
   };
 
 cMenuSetup::cMenuSetup(void)
@@ -3369,25 +3624,61 @@
 cMenuMain::cMenuMain(eOSState State)
 :cOsdMenu("")
 {
+  // Load Menu Configuration
+  cString menuXML = cString::sprintf("%s/setup/vdr-menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+  if (access(menuXML, 04) == -1)
+     menuXML = cString::sprintf("%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
+  subMenu.LoadXml(menuXML);
+  nrDynamicMenuEntries = 0;
   SetMenuCategory(mcMain);
   replaying = false;
   stopReplayItem = NULL;
   cancelEditingItem = NULL;
+  cancelFileTransferItem = NULL;
   stopRecordingItem = NULL;
   recordControlsState = 0;
   Set();
 
   // Initial submenus:
-
+  cOsdObject *menu = NULL;
   switch (State) {
+#ifdef USE_MAINMENUHOOKS
+    case osSchedule:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
+            menu = new cMenuSchedule;
+        break;
+    case osChannels:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
+            menu = new cMenuChannels;
+        break;
+    case osTimers:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
+            menu = new cMenuTimers;
+        break;
+    case osRecordings:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
+            menu = new cMenuRecordings(NULL, 0, true);
+        break;
+    case osSetup:      menu = new cMenuSetup; break;
+    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+#else
     case osSchedule:   AddSubMenu(new cMenuSchedule); break;
     case osChannels:   AddSubMenu(new cMenuChannels); break;
     case osTimers:     AddSubMenu(new cMenuTimers); break;
     case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
     case osSetup:      AddSubMenu(new cMenuSetup); break;
     case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
+#endif /* MAINMENUHOOKS */
+#ifdef REELVDR
+    //TODO: implement cMenuActiveEvent from old vdr, but is obsolete
+    //case osActiveEvent: AddSubMenu(new cMenuActiveEvent); break;
+#endif
     default: break;
     }
+#ifdef USE_MAINMENUHOOKS
+  if (menu)
+      AddSubMenu(menu);
+#endif /* MAINMENUHOOKS */
 }
 
 cOsdObject *cMenuMain::PluginOsdObject(void)
@@ -3397,37 +3688,64 @@
   return o;
 }
 
+#ifdef USE_SETUP
+void cMenuMain::Set(int current)
+#else
 void cMenuMain::Set(void)
+#endif /* SETUP */
 {
   Clear();
   SetTitle("VDR");
   SetHasHotkeys();
 
-  // Basic menu items:
-
-  Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  Add(new cOsdItem(hk(tr("Timers")),     osTimers));
-  Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
-
-  // Plugins:
+  stopReplayItem = NULL;
+  cancelEditingItem = NULL;
+  stopRecordingItem = NULL;
 
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p) {
-         const char *item = p->MainMenuEntry();
-         if (item)
-            Add(new cMenuPluginItem(hk(item), i));
+  // remember initial dynamic MenuEntries added
+  nrDynamicMenuEntries = Count();
+  for (cSubMenuNode *node = subMenu.GetMenuTree()->First(); node; node = subMenu.GetMenuTree()->Next(node)) {
+      cSubMenuNode::Type type = node->GetType();
+      if (type==cSubMenuNode::PLUGIN) {
+         const char *item = node->GetPluginMainMenuEntry();
+         if (item && !cStatus::MsgPluginProtected(cPluginManager::GetPlugin(node->GetPluginIndex()), true))
+            Add(new cMenuPluginItem(hk(item), node->GetPluginIndex()));
          }
-      else
-         break;
-      }
-
-  // More basic menu items:
-
-  Add(new cOsdItem(hk(tr("Setup")),      osSetup));
-  if (Commands.Count())
-     Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+      else if (type==cSubMenuNode::MENU) {
+         cString item = cString::sprintf("%s%s", node->GetName(), *subMenu.GetMenuSuffix());
+         if (!cStatus::MsgMenuItemProtected(item, true))
+            Add(new cOsdItem(hk(item), osUnknown, node));
+         }
+      else if ((type==cSubMenuNode::COMMAND) || (type==cSubMenuNode::THREAD)) {
+         if (!cStatus::MsgMenuItemProtected(node->GetName(), true))
+            Add(new cOsdItem(hk(node->GetName()), osUnknown, node));
+         }
+      else if (type==cSubMenuNode::SYSTEM) {
+         const char *item = node->GetName();
+         if (cStatus::MsgMenuItemProtected(item, true))
+            ; // nothing to do ;)
+         else
+         if (strcmp(item, "Schedule") == 0)
+            Add(new cOsdItem(hk(tr("Schedule")), osSchedule));
+         else if (strcmp(item, "Channels") == 0)
+            Add(new cOsdItem(hk(tr("Channels")), osChannels));
+         else if (strcmp(item, "Timers") == 0)
+            Add(new cOsdItem(hk(tr("Timers")), osTimers));
+         else if (strcmp(item, "Recordings") == 0)
+            Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+         else if (strcmp(item, "Setup") == 0) {
+            cString itemSetup = cString::sprintf("%s%s", tr("Setup"), *subMenu.GetMenuSuffix());
+            Add(new cOsdItem(hk(itemSetup), osSetup));
+            }
+         else if (strcmp(item, "Commands") == 0 && Commands.Count() > 0) {
+            cString itemCommands = cString::sprintf("%s%s", tr("Commands"), *subMenu.GetMenuSuffix());
+            Add(new cOsdItem(hk(itemCommands), osCommands));
+            }
+         }
+     }
+  if (current >=0 && current<Count()) {
+     SetCurrent(Get(current));
+     }
 
   Update(true);
 
@@ -3438,6 +3756,17 @@
 {
   bool result = false;
 
+  cOsdItem *fMenu = NULL;
+  if (Force && subMenu.isTopMenu()) {
+     fMenu = First();
+     nrDynamicMenuEntries = 0;
+     }
+
+  if (!subMenu.isTopMenu()) {
+     SetTitle(cString::sprintf("%s  -  %s", tr("VDR"), subMenu.GetParentMenuTitel()));
+     result = true;
+     }
+
   bool NewReplaying = cControl::Control() != NULL;
   if (Force || NewReplaying != replaying) {
      replaying = NewReplaying;
@@ -3467,6 +3796,19 @@
      result = true;
      }
 
+  // File transfer control:
+  bool FileTransferActive = cFileTransfer::Active();
+  if (FileTransferActive && !cancelFileTransferItem) {
+     // TRANSLATORS: note the leading blank!
+     Add(cancelFileTransferItem = new cOsdItem(tr(" Cancel file transfer"), osCancelTransfer));
+     result = true;
+     }
+  else if (cancelFileTransferItem && !FileTransferActive) {
+     Del(cancelFileTransferItem->Index());
+     cancelFileTransferItem = NULL;
+     result = true;
+     }
+
   // Record control:
   if (cRecordControls::StateChanged(recordControlsState)) {
      while (stopRecordingItem) {
@@ -3485,6 +3827,10 @@
      result = true;
      }
 
+  // adjust nrDynamicMenuEntries
+  if (fMenu != NULL)
+     nrDynamicMenuEntries = fMenu->Index();
+
   return result;
 }
 
@@ -3495,13 +3841,53 @@
   eOSState state = cOsdMenu::ProcessKey(Key);
   HadSubMenu |= HasSubMenu();
 
+
+  cOsdMenu *menu = NULL;
+
+
+  cOsdItem* item = Get(Current());
+
+  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
+     if (cStatus::MsgMenuItemProtected(item->Text()))
+        return osContinue;
+
+
   switch (state) {
+#ifdef USE_MAINMENUHOOKS
+    case osSchedule:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
+            menu = new cMenuSchedule;
+        else
+            state = osContinue;
+        break;
+    case osChannels:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
+            menu = new cMenuChannels;
+        else
+            state = osContinue;
+        break;
+    case osTimers:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
+            menu = new cMenuTimers;
+        else
+            state = osContinue;
+        break;
+    case osRecordings:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
+            menu = new cMenuRecordings;
+        else
+            state = osContinue;
+        break;
+    case osSetup:      menu = new cMenuSetup; break;
+    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+#else
     case osSchedule:   return AddSubMenu(new cMenuSchedule);
     case osChannels:   return AddSubMenu(new cMenuChannels);
     case osTimers:     return AddSubMenu(new cMenuTimers);
     case osRecordings: return AddSubMenu(new cMenuRecordings);
     case osSetup:      return AddSubMenu(new cMenuSetup);
     case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
+#endif /* MAINMENUHOOKS */
     case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
                           cOsdItem *item = Get(Current());
                           if (item) {
@@ -3515,11 +3901,18 @@
                           return osEnd;
                           }
                        break;
+    case osCancelTransfer:
+                       if (Interface->Confirm(tr("Cancel file transfer?"))) {
+                          cFileTransfer::Stop();
+                          return osEnd;
+                          }
+                       break;
     case osPlugin:     {
                          cMenuPluginItem *item = (cMenuPluginItem *)Get(Current());
                          if (item) {
                             cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
                             if (p) {
+                               if (!cStatus::MsgPluginProtected(p)) {
                                cOsdObject *menu = p->MainMenuAction();
                                if (menu) {
                                   if (menu->IsMenu())
@@ -3530,10 +3923,21 @@
                                      }
                                   }
                                }
+                               }
                             }
                          state = osEnd;
                        }
                        break;
+    case osBack:       {
+                         int newCurrent = 0;
+                         if (subMenu.Up(&newCurrent)) {
+                            Set(newCurrent);
+                            return osContinue;
+                            }
+                         else
+                            return osEnd;
+                       }
+                       break;
     default: switch (Key) {
                case kRecord:
                case kRed:    if (!HadSubMenu)
@@ -3550,9 +3954,59 @@
                case kBlue:   if (!HadSubMenu)
                                 state = replaying ? osStopReplay : cReplayControl::LastReplayed() ? osReplay : osRecordings;
                              break;
+               case kOk:     if (state == osUnknown) {
+                                cString buffer;
+                                int index = Current()-nrDynamicMenuEntries;
+                                cSubMenuNode *node = subMenu.GetNode(index);
+
+                                if (node != NULL) {
+                                   if (node->GetType() == cSubMenuNode::MENU) {
+                                      subMenu.Down(node, Current());
+                                      }
+                                   else if (node->GetType() == cSubMenuNode::COMMAND) {
+                                      bool confirmed = true;
+                                      if (node->CommandConfirm()) {
+                                         buffer = cString::sprintf("%s?", node->GetName());
+                                         confirmed = Interface->Confirm(buffer);
+                                         }
+                                      if (confirmed) {
+                                         const char *Result = subMenu.ExecuteCommand(node->GetCommand());
+                                         if (Result)
+                                            return AddSubMenu(new cMenuText(node->GetName(), Result, fontFix));
+                                         return osEnd;
+                                         }
+                                      }
+                                   else if (node->GetType() == cSubMenuNode::THREAD) {
+                                      bool confirmed = true;
+                                      if (node->CommandConfirm()) {
+                                         buffer = cString::sprintf("%s?", node->GetName());
+                                         confirmed = Interface->Confirm(buffer);
+                                         }
+                                      if (confirmed) {
+                                         buffer = cString::sprintf("%s", node->GetCommand());
+                                         cExecCmdThread *execcmd = new cExecCmdThread(node->GetCommand());
+                                         if (execcmd->Start())
+                                            dsyslog("executing command '%s'", *buffer);
+                                         else
+                                            esyslog("ERROR: can't execute command '%s'", *buffer);
+                                         return osEnd;
+                                         }
+                                      }
+                                   }
+
+                                Set();
+                                return osContinue;
+                                }
+                             break;
                default:      break;
                }
     }
+  if (menu) {
+     if (menu->IsMenu())
+        return AddSubMenu((cOsdMenu *) menu);
+     pluginOsdObject = menu;
+     return osPlugin;
+  }
   if (!HasSubMenu() && Update(HadSubMenu))
      Display();
   if (Key != kNone) {
@@ -3699,6 +4153,7 @@
   if (Direction) {
      while (Channel) {
            Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
+        if (!cStatus::MsgChannelProtected(0, Channel))
            if (!Channel && Setup.ChannelsWrap)
               Channel = Direction > 0 ? Channels.First() : Channels.Last();
            if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, LIVEPRIORITY, true, true))
@@ -4314,8 +4769,52 @@
 cRecordControl *cRecordControls::RecordControls[MAXRECORDCONTROLS] = { NULL };
 int cRecordControls::state = 0;
 
-bool cRecordControls::Start(cTimer *Timer, bool Pause)
+bool cRecordControls::Start(cTimer *Timer, bool Pause, bool* reused)
 {
+  if (!Timer) {
+     cTimer *t = new cTimer(true, Pause);
+
+     //get event
+     cSchedulesLock SchedulesLock;
+     const cEvent *event = NULL;;
+     const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
+     if (Schedules) {
+        const cSchedule *Schedule = Schedules->GetSchedule(t->Channel());
+        if (Schedule) {
+           event = Schedule->GetEventAround(t->StartTime() + INSTANT_REC_EPG_LOOKAHEAD);
+        }
+     }
+
+     if (cPluginManager::GetPlugin("timersync")) {
+        // sets the file name
+        cRecording recording(t, event);
+        Timers.Add(t);
+        Timers.SetModified();
+        if (!cReplayControl::LastReplayed())
+           cReplayControl::SetRecording(recording.FileName());
+        return true;
+     }
+     else {
+        RemoteTimers_InstantRecording_v1_0 ir;
+        ir.timer = t;
+        ir.pause = Pause;
+        ir.event = event;
+        ir.name = NULL;
+        ir.fileName = NULL;
+
+        if (cPluginManager::CallFirstService("RemoteTimers::InstantRecording-v1.0", &ir)) {
+           if (!cReplayControl::LastReplayed())
+              cReplayControl::SetRecording(ir.fileName);
+ 	  delete t;
+ 	  // empty names indicate an error
+ 	  return *ir.fileName && *ir.name;
+        }
+        // service disabled or an error occured and the user confirmed local recording
+        // fall through to local instant recording
+     }
+     delete t;
+  }
+
   static time_t LastNoDiskSpaceMessage = 0;
   int FreeMB = 0;
   if (Timer) {
@@ -4323,6 +4822,10 @@
      Timer->SetPending(true);
      }
   VideoDiskSpace(&FreeMB);
+#if REELVDR
+  if(Setup.ReelboxModeTemp != eModeClient) // Don't check disk usage on Clients
+  {
+#endif
   if (FreeMB < MINFREEDISK) {
      if (!Timer || time(NULL) - LastNoDiskSpaceMessage > NODISKSPACEDELTA) {
         isyslog("not enough disk space to start recording%s%s", Timer ? " timer " : "", Timer ? *Timer->ToDescr() : "");
@@ -4333,7 +4836,17 @@
      }
   LastNoDiskSpaceMessage = 0;
 
+  if (Timer == NULL) {
+    if (TryReuseRecording(Pause)) {
+      if (reused != NULL) *reused = true;
+      return true;
+      }
+    }
+  
   ChangeState();
+#if REELVDR
+  }
+#endif
   int ch = Timer ? Timer->Channel()->Number() : cDevice::CurrentChannel();
   cChannel *channel = Channels.GetByNumber(ch);
 
@@ -4347,9 +4860,56 @@
            return false;
            }
         if (!Timer || Timer->Matches()) {
+#ifdef USEMYSQL
+            // On Clients, just create new timer since AVG will record
+            if(Setup.ReelboxModeTemp == eModeClient)
+            {
+                if (!Timer)
+                {
+                    std::vector<cTimer*> InstantRecordings;
+                    Timers.GetInstantRecordings(&InstantRecordings);
+                    bool InstantRecordingExists = false;
+
+                    if(InstantRecordings.size())
+                    {
+                        unsigned int i = 0;
+                        while(!InstantRecordingExists && i < InstantRecordings.size())
+                        {
+                            if(InstantRecordings.at(i)->Channel() == channel)
+                                InstantRecordingExists = true;
+                            ++i;
+                        }
+                    }
+
+                    // Don't record if there is already a running recording
+                    if(InstantRecordingExists)
+                    {
+                        isyslog("an instant recording is already running '%s'", channel->Name());
+                        Skins.Message(mtWarning, tr("An instant recording is already active!"));
+                        Timer = NULL;
+                    }
+                    else
+                        Timer = new cTimer(true, Pause);
+
+                    if(Timer)
+                    {
+                        if(!Timers.Add(Timer))
+                        {
+                            Skins.Message(mtError, tr("Could not add timer"));
+                            delete Timer;
+                            return false;
+                        }
+                        Timers.SetModified();
+                        return true;
+                    }
+                }
+            }
+            else
+#endif
            for (int i = 0; i < MAXRECORDCONTROLS; i++) {
                if (!RecordControls[i]) {
                   RecordControls[i] = new cRecordControl(device, Timer, Pause);
+                  cStatus::MsgRecordingFile(RecordControls[i]->FileName());
                   return RecordControls[i]->Process(time(NULL));
                   }
                }
@@ -4385,12 +4945,53 @@
       }
 }
 
+bool cRecordControls::TryReuseRecording(bool Pause)
+{
+  cRecordControl* runningRecording = cRecordControls::GetRecordControl(cDevice::CurrentChannel());
+  if (runningRecording != NULL && runningRecording->Timer() != NULL) {
+    cTimer *reuseTimer = runningRecording->Timer();
+    // calculate length from current time
+    time_t t = time(NULL);
+    struct tm *tmNow = localtime(&t);
+    int now = tmNow->tm_hour * 60 + tmNow->tm_min;
+    int stop = reuseTimer->Stop();
+    stop = stop / 100 * 60 + stop % 100;
+    int lengthFromNow = stop - now;
+    if (lengthFromNow < 0)
+      lengthFromNow += 24 * 60;
+    // Only use low priority recordings or, for pause, recordings which are long enough.
+    if (runningRecording->Timer()->Priority() <= LIVEPRIORITY || (Pause && lengthFromNow >= Setup.InstantRecordTime)) {
+      // always adapt recording time for instant recording, only raise stop time for pause
+      if (!Pause || lengthFromNow < Setup.InstantRecordTime) {
+        int stop = now + Setup.InstantRecordTime;
+        stop = (stop / 60) * 100 + (stop % 60);
+        if (stop >= 2400) stop -= 2400;
+        reuseTimer->SetStop(stop);
+        }
+      ChangeState();
+      // for pause, set replay to the recording
+      if (Pause) {
+        cReplayControl::SetRecording(runningRecording->FileName());
+        }
+      // for instant recording, raise priority and lifetime
+      else {
+        reuseTimer->SetPriority(max(Setup.DefaultPriority, reuseTimer->Priority()));
+        reuseTimer->SetLifetime(max(Setup.DefaultLifetime, reuseTimer->Lifetime()));
+        }
+      // We found a usable recording, don't create a new one.
+      return true;
+      }
+    }
+  return false;
+}
+
 bool cRecordControls::PauseLiveVideo(void)
 {
   Skins.Message(mtStatus, tr("Pausing live video..."));
+  bool reused = false;
   cReplayControl::SetRecording(NULL); // make sure the new cRecordControl will set cReplayControl::LastReplayed()
-  if (Start(NULL, true)) {
-     cReplayControl *rc = new cReplayControl(true);
+  if (Start(NULL, true, &reused)) {
+     cReplayControl *rc = new cReplayControl(true, reused);
      cControl::Launch(rc);
      cControl::Attach();
      Skins.Message(mtStatus, NULL);
@@ -4400,9 +5001,15 @@
   return false;
 }
 
+#ifdef REELVDR
+const char *cRecordControls::GetInstantId(const char *LastInstantId, bool LIFO)
+{
+  for (int i = LIFO?MAXRECORDCONTROLS-1:0; LIFO? i>=0:i < MAXRECORDCONTROLS; LIFO?--i:i++) {
+#else
 const char *cRecordControls::GetInstantId(const char *LastInstantId)
 {
   for (int i = 0; i < MAXRECORDCONTROLS; i++) {
+#endif /* REELVDR */
       if (RecordControls[i]) {
          if (!LastInstantId && RecordControls[i]->InstantId())
             return RecordControls[i]->InstantId();
@@ -4433,6 +5040,23 @@
   return NULL;
 }
 
+cRecordControl *cRecordControls::GetRecordControl(int channelNo)
+{
+  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
+    if (RecordControls[i] != NULL) {
+      cTimer* existentTimer = RecordControls[i]->Timer();
+      if (existentTimer != NULL && existentTimer->Channel() != NULL) {
+        if (RecordControls[i]->Timer()->Channel()->Number() == channelNo) {
+          if (existentTimer->Recording()) {
+            return RecordControls[i];
+            }
+          }
+        }
+      }
+    }
+  return NULL;
+}
+
 void cRecordControls::Process(time_t t)
 {
   for (int i = 0; i < MAXRECORDCONTROLS; i++) {
@@ -4488,11 +5112,15 @@
 
 // --- cReplayControl --------------------------------------------------------
 
+#define REPLAYCONTROLSKIPLIMIT   9    // s
+#define REPLAYCONTROLSKIPSECONDS 90   // s
+#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
+
 cReplayControl *cReplayControl::currentReplayControl = NULL;
 cString cReplayControl::fileName;
 
-cReplayControl::cReplayControl(bool PauseLive)
-:cDvbPlayerControl(fileName, PauseLive)
+cReplayControl::cReplayControl(bool PauseLive, bool ReusedPauseLive)
+:cDvbPlayerControl(fileName, PauseLive, ReusedPauseLive)
 {
   cDevice::PrimaryDevice()->SetKeepTracks(PauseLive);
   currentReplayControl = this;
@@ -4502,6 +5130,9 @@
   lastCurrent = lastTotal = -1;
   lastPlay = lastForward = false;
   lastSpeed = -2; // an invalid value
+  lastSkipKey = kNone;
+  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+  lastSkipTimeout.Set(0);
   timeoutShow = 0;
   timeSearchActive = false;
   cRecording Recording(fileName);
@@ -4779,8 +5410,10 @@
         marks.Add(Current);
         bool Play, Forward;
         int Speed;
-        if (Setup.PauseOnMarkSet || GetReplayMode(Play, Forward, Speed) && !Play)
+        if (Setup.PauseOnMarkSet || GetReplayMode(Play, Forward, Speed) && !Play) {
            Goto(Current, true);
+           displayFrames = true;
+           }
         }
      ShowTimed(2);
      marksModified = true;
@@ -4793,8 +5426,17 @@
   if (GetIndex(Current, Total)) {
      if (marks.Count()) {
         if (cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current)) {
-           Goto(m->Position(), true);
-           displayFrames = true;
+           bool Play2, Forward2;
+           int Speed;
+           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
+               Play2 && Forward && m->Position() < Total - SecondsToFrames(3, FramesPerSecond())) {
+              Goto(m->Position());
+              Play();
+              }
+           else {
+              Goto(m->Position(), true);
+              displayFrames = true;
+              }
            return;
            }
         }
@@ -4836,7 +5478,7 @@
            Skins.Message(mtError, tr("No editing marks defined!"));
         else if (!marks.GetNumSequences())
            Skins.Message(mtError, tr("No editing sequences defined!"));
-        else if (!cCutter::Start(fileName))
+        else if (!cCutter::Start(fileName, NULL, false))
            Skins.Message(mtError, tr("Can't start editing process!"));
         else
            Skins.Message(mtInfo, tr("Editing process started"));
@@ -4855,7 +5497,7 @@
      if (!m)
         m = marks.GetNext(Current);
      if (m) {
-        if ((m->Index() & 0x01) != 0)
+        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
            m = marks.Next(m);
         if (m) {
            Goto(m->Position() - SecondsToFrames(3, FramesPerSecond()));
@@ -4931,24 +5573,80 @@
     case kRight:   Forward(); break;
     case kRed:     TimeSearch(); break;
     case kGreen|k_Repeat:
-    case kGreen:   SkipSeconds(-60); break;
+                   SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
+    case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
     case kYellow|k_Repeat:
-    case kYellow:  SkipSeconds( 60); break;
+                   SkipSeconds(Setup.JumpSecondsRepeat); break;
+    case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
+    case kPrev|k_Repeat:
+    case kPrev:    if (lastSkipTimeout.TimedOut()) {
+                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                      lastSkipKey = kPrev;
+                   }
+                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                      lastSkipSeconds /= 2;
+                      lastSkipKey = kNone;
+                   }
+                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                   SkipSeconds(-lastSkipSeconds); break;
+    case kNext|k_Repeat:
+    case kNext:    if (lastSkipTimeout.TimedOut()) {
+                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                      lastSkipKey = kNext;	
+                   }
+                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                      lastSkipSeconds /= 2;
+                      lastSkipKey = kNone;
+                   }
+                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                   SkipSeconds(lastSkipSeconds); break;
     case kStop:
     case kBlue:    Hide();
                    Stop();
                    return osEnd;
     default: {
+      bool play, forward;
+      int speed;
+      int Current, Total;
+      cMark *m;
+
       DoShowMode = false;
       switch (int(Key)) {
         // Editing:
-        case kMarkToggle:      MarkToggle(); break;
-        case kPrev|k_Repeat:
-        case kPrev:
+        case k1|k_Repeat:
+        case k1:               if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
+                                  displayFrames = true;
+                                  int p = SkipFrames(-SecondsToFrames(5, FramesPerSecond()));
+                                  cMark *m2;
+                                  if ((m2 = marks.Prev(m)) != NULL && m2->Position() >= p)
+                                     break;
+                                  m->SetPosition(p); Goto(p, true);
+                                  marks.Save();
+                                  }
+                               else
+                                  SkipSeconds(-Setup.JumpSecondsSlow);
+                               break;
+        case k3|k_Repeat:
+        case k3:               if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
+                                  displayFrames = true;
+                                  int p = SkipFrames(SecondsToFrames(5, FramesPerSecond()));
+                                  cMark *m2;
+                                  if ((m2 = marks.Next(m)) != NULL && m2->Position() <= p)
+                                     break;
+                                  m->SetPosition(p); Goto(p, true);
+                                  marks.Save();
+                                  }
+                               else
+                                  SkipSeconds(Setup.JumpSecondsSlow);
+                               break;
+        case kMarkToggle:      if (GetReplayMode(play, forward, speed) && play) {
+                                  displayFrames = true;
+                                  Pause();
+                                  }
+                               MarkToggle();
+                               break;
         case kMarkJumpBack|k_Repeat:
         case kMarkJumpBack:    MarkJump(false); break;
-        case kNext|k_Repeat:
-        case kNext:
         case kMarkJumpForward|k_Repeat:
         case kMarkJumpForward: MarkJump(true); break;
         case kMarkMoveBack|k_Repeat:
diff -urN vdr-2.0.1/menu.h vdr-2.0.1.reel/menu.h
--- vdr-2.0.1/menu.h	2012-12-07 14:44:13.000000000 +0100
+++ vdr-2.0.1.reel/menu.h	2013-05-09 18:09:51.287874141 +0200
@@ -18,6 +18,19 @@
 #include "menuitems.h"
 #include "recorder.h"
 #include "skins.h"
+#include "submenu.h"
+
+#ifdef REELVDR
+class cMenuEditSrcItem : public cMenuEditIntItem {
+private:
+  const cSource *source;
+protected:
+  virtual void Set(void);
+public:
+  cMenuEditSrcItem(const char *Name, int *Value);
+  eOSState ProcessKey(eKeys Key);
+  };
+#endif
 
 class cMenuText : public cOsdMenu {
 private:
@@ -29,6 +42,7 @@
   void SetText(const char *Text);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuText"; }
   };
 
 class cMenuFolder : public cOsdMenu {
@@ -67,6 +81,7 @@
   cMenuCommands(const char *Title, cList<cNestedItem> *Commands, const char *Parameters = NULL);
   virtual ~cMenuCommands();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuCommands"; }
   };
 
 class cMenuEditTimer : public cOsdMenu {
@@ -85,6 +100,7 @@
   cMenuEditTimer(cTimer *Timer, bool New = false);
   virtual ~cMenuEditTimer();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuTimerEdit"; }
   };
 
 class cMenuEvent : public cOsdMenu {
@@ -94,22 +110,53 @@
   cMenuEvent(const cEvent *Event, bool CanSwitch = false, bool Buttons = false);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuEvent"; }
   };
 
+#ifdef REELVDR
+struct MenuMainHook_Data_V1_0 {
+  eOSState  Function;    /*IN*/
+  cOsdMenu *pResultMenu; /*OUT*/
+};
+#define CREATE_MENU_MAIN(function,menu) {                              \
+  MenuMainHook_Data_V1_0 data;                                         \
+  memset(&data, 0, sizeof(data));                                      \
+  data.Function = function;                                            \
+  if (!cPluginManager::CallFirstService("MenuMainHook-V1.0", &data))   \
+    menu = new cMenuMain(function);                                    \
+  else                                                                 \
+    menu = data.pResultMenu;                                           \
+}
+#endif /* REELVDR*/
+
 class cMenuMain : public cOsdMenu {
+#ifdef REELVDR
+protected:
+  cMenuMain(const char *Title):cOsdMenu(Title){}; // Allow custom constructor
+#else
 private:
+#endif
+
+  int    nrDynamicMenuEntries;
   bool replaying;
   cOsdItem *stopReplayItem;
   cOsdItem *cancelEditingItem;
+  cOsdItem *cancelFileTransferItem;
   cOsdItem *stopRecordingItem;
   int recordControlsState;
   static cOsdObject *pluginOsdObject;
-  void Set(void);
+  void Set(int current=0);
   bool Update(bool Force = false);
+  cSubMenu subMenu;
 public:
   cMenuMain(eOSState State = osUnknown);
   virtual eOSState ProcessKey(eKeys Key);
   static cOsdObject *PluginOsdObject(void);
+#ifdef REELVDR
+  static void SetPluginOsdObject(cOsdObject *PluginOsdObject)
+      { pluginOsdObject = PluginOsdObject ; }
+#endif /* REELVDR */
+  virtual const char* MenuKind() { return "MenuMain"; }
   };
 
 class cDisplayChannel : public cOsdObject {
@@ -206,12 +253,14 @@
   eOSState Info(void);
   eOSState Sort(void);
   eOSState Commands(eKeys Key = kNone);
+  eOSState Edit(void);
 protected:
   cString DirectoryName(void);
 public:
   cMenuRecordings(const char *Base = NULL, int Level = 0, bool OpenSubMenus = false);
   ~cMenuRecordings();
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuRecordings"; }
   };
 
 class cRecordControl {
@@ -238,15 +287,25 @@
 private:
   static cRecordControl *RecordControls[];
   static int state;
+  static bool TryReuseRecording(bool Pause);
+         ///< Tries to reuse an existing recording instead of creating a second one in parallel.
+         ///< Returns true if successful.
 public:
-  static bool Start(cTimer *Timer = NULL, bool Pause = false);
+  static bool Start(cTimer *Timer = NULL, bool Pause = false, bool* reused = NULL);
   static void Stop(const char *InstantId);
   static bool PauseLiveVideo(void);
+#ifdef REELVDR
+  static const char *GetInstantId(const char *LastInstantId, bool LIFO=false);
+#else
   static const char *GetInstantId(const char *LastInstantId);
+#endif
   static cRecordControl *GetRecordControl(const char *FileName);
   static cRecordControl *GetRecordControl(const cTimer *Timer);
          ///< Returns the cRecordControl for the given Timer.
          ///< If there is no cRecordControl for Timer, NULL is returned.
+  static cRecordControl *GetRecordControl(int channelNo);
+         ///< Returns the cRecordControl for the given channel number.
+         ///< If there is no cRecordControl, NULL is returned.
   static void Process(time_t t);
   static void ChannelDataModified(cChannel *Channel);
   static bool Active(void);
@@ -264,6 +323,9 @@
   int lastCurrent, lastTotal;
   bool lastPlay, lastForward;
   int lastSpeed;
+  int lastSkipSeconds;
+  eKeys lastSkipKey;
+  cTimeMs lastSkipTimeout;
   time_t timeoutShow;
   bool timeSearchActive, timeSearchHide;
   int timeSearchTime, timeSearchPos;
@@ -281,7 +343,7 @@
   void EditCut(void);
   void EditTest(void);
 public:
-  cReplayControl(bool PauseLive = false);
+  cReplayControl(bool PauseLive = false, bool ReusedPauseLive = false);
   virtual ~cReplayControl();
   void Stop(void);
   virtual cOsdObject *GetInfo(void);
@@ -296,4 +358,16 @@
   static void ClearLastReplayed(const char *FileName);
   };
 
+#ifdef REELVDR
+// --- cMenuSetupPluginItem --------------------------------------------------
+
+class cMenuSetupPluginItem : public cOsdItem {
+  private:
+    int pluginIndex;
+  public:
+    cMenuSetupPluginItem(const char *Name, int Index);
+    int PluginIndex(void) { return pluginIndex; }
+};
+#endif //REELVDR
+
 #endif //__MENU_H
diff -urN vdr-2.0.1/menuitems.c vdr-2.0.1.reel/menuitems.c
--- vdr-2.0.1/menuitems.c	2013-02-15 15:20:29.000000000 +0100
+++ vdr-2.0.1.reel/menuitems.c	2013-05-09 18:09:51.287874141 +0200
@@ -1154,7 +1154,14 @@
 {
   SetMenuCategory(mcPluginSetup);
   plugin = Plugin;
+#ifdef REELVDR
+  if (plugin->MenuSetupPluginEntry())
+      SetSection(cString::sprintf("%s", plugin->MenuSetupPluginEntry()));
+  else
+      SetSection(cString::sprintf("%s", plugin->MainMenuEntry()));
+#else
   SetSection(cString::sprintf("%s '%s'", tr("Plugin"), plugin->Name()));
+#endif
 }
 
 void cMenuSetupPage::SetupStore(const char *Name, const char *Value)
@@ -1168,3 +1175,12 @@
   if (plugin)
      plugin->SetupStore(Name, Value);
 }
+
+#ifdef REELVDR
+void cMenuSetupPage::SetupStore(const char *Name, const char *PluginName, int Value)
+{
+  if (cPluginManager::GetPlugin(PluginName))
+     cPluginManager::GetPlugin(PluginName)->SetupStore(Name, PluginName, Value);
+}
+#endif /* REELVDR */
+
diff -urN vdr-2.0.1/menuitems.h vdr-2.0.1.reel/menuitems.h
--- vdr-2.0.1/menuitems.h	2012-03-13 12:19:11.000000000 +0100
+++ vdr-2.0.1.reel/menuitems.h	2013-05-09 18:09:51.287874141 +0200
@@ -203,12 +203,16 @@
 protected:
   void SetSection(const char *Section);
   virtual void Store(void) = 0;
+#ifdef REELVDR
+  void SetupStore(const char *Name, const char *PluginName, int Value);
+#endif /* REELVDR */
   void SetupStore(const char *Name, const char *Value = NULL);
   void SetupStore(const char *Name, int Value);
 public:
   cMenuSetupPage(void);
   virtual eOSState ProcessKey(eKeys Key);
   void SetPlugin(cPlugin *Plugin);
+  const char* MenuKind() { return "MenuSetupPage"; }
   };
 
 #endif //__MENUITEMS_H
diff -urN vdr-2.0.1/osdbase.c vdr-2.0.1.reel/osdbase.c
--- vdr-2.0.1/osdbase.c	2012-12-07 10:50:47.000000000 +0100
+++ vdr-2.0.1.reel/osdbase.c	2013-05-09 18:09:51.287874141 +0200
@@ -14,6 +14,8 @@
 #include "menuitems.h"
 #include "remote.h"
 #include "status.h"
+#include "help.h"
+
 
 // --- cOsdItem --------------------------------------------------------------
 
@@ -23,6 +25,7 @@
   state = State;
   selectable = true;
   fresh = true;
+  subMenu = 0;
 }
 
 cOsdItem::cOsdItem(const char *Text, eOSState State, bool Selectable)
@@ -32,6 +35,17 @@
   selectable = Selectable;
   fresh = true;
   SetText(Text);
+  subMenu = 0;
+}
+
+cOsdItem::cOsdItem(const char *Text, eOSState State, cSubMenuNode* SubMenu)
+{
+  text = NULL;
+  state = State;
+  selectable = true;
+  fresh = true;
+  SetText(Text);
+  subMenu = SubMenu;
 }
 
 cOsdItem::~cOsdItem()
@@ -82,6 +96,7 @@
 {
   isMenu = true;
   digit = 0;
+  key_nr = -1;
   hasHotkeys = false;
   displayMenuItems = 0;
   title = NULL;
@@ -105,6 +120,7 @@
   free(status);
   displayMenu->Clear();
   cStatus::MsgOsdClear();
+  cStatus::MsgOsdMenuDestroy();
   if (!--displayMenuCount)
      DELETENULL(displayMenu);
 }
@@ -131,7 +147,7 @@
         digit = -1; // prevents automatic hotkeys - input already has them
      if (digit >= 0) {
         digit++;
-        buffer = cString::sprintf(" %c %s", (digit < 10) ? '0' + digit : ' ' , s);
+        buffer = cString::sprintf(" %2d%s %s", digit, (digit > 9) ? "" : " ", s);
         s = buffer;
         }
      }
@@ -213,6 +229,106 @@
      current = Item->Index();
 }
 
+#ifdef REELVDR
+// create a new string on the heap that has a maximum 'maxlen' number of
+// characters (each can span multiple bytes)
+//
+// tries to find end of words to break the string
+// returned char* (if not NULL) must be freed by caller
+//
+// bytesCopied used by the caller to jump in the input string
+char* BreakString(const char*str, int maxlen, int &bytesCopied)
+{
+	bytesCopied = 0;
+	if (!str) return NULL;
+
+	// number of chars
+	int symCount = Utf8StrLen(str);
+
+	// convert UTF-8 multi-byte char to a single uint number
+	uint *inp_sym = new uint[symCount+1]; // +1 for the '\0'
+	int inp_sym_len = Utf8ToArray(str, inp_sym, symCount+1);
+
+	// number of chars in the string less than the maxlen
+	// TODO: if there is a '\n' in this part!
+	if (inp_sym_len <= maxlen)
+	{
+		// copy the input string
+		bytesCopied = strlen(str);
+
+		delete[] inp_sym;
+		//printf("** just copied **\n");
+		return strdup(str);
+	}
+
+	// create string on heap that can hold maxlen (multi-byte)chars
+	char *s = (char*) malloc((4*maxlen+1)*sizeof(char)); //+1 for '\0'
+
+	int i = 0;
+
+	// if no wordbreaks found, break after maxlen characters
+	int line_end = maxlen;
+
+	// donot show the char that was used to break the string
+	// for eg. ' ' is unnecessary at the end/beginning of a line
+	int skip_symbol = 0;
+
+	//the string here is longer than requested. Break it down.
+	for (i = 0; i < maxlen; ++i)
+	{
+		//look for word breaks and new lines
+		if (inp_sym[i] == '\0' || inp_sym[i] == '\n')
+		{
+			line_end = i;
+			if (inp_sym[i] != '\0')
+				skip_symbol = 1;
+			break; // found end of line exit loop
+		}
+		else if (inp_sym[i] == ' ') //space
+		{
+			line_end = i;
+			skip_symbol = 1;
+		}
+	}//for
+
+	// create char from uint array, since the char* is large enough
+	// 	it will be '\0' terminated
+	bytesCopied = Utf8FromArray(inp_sym, s, 4*maxlen-1,line_end);
+
+	if (skip_symbol)// jump over the last symbol since it is a ' ' or '\n'
+		++bytesCopied;
+
+	delete[] inp_sym;
+	return s;
+}
+
+// breaks given text into smaller 'maxChar' length strings and
+// displays them as unselectable text on OSD
+void cOsdMenu::AddFloatingText(const char* text, int maxChars)
+{
+	// empty string; display nothing
+	if(!text) return;
+
+	char *p = NULL;
+	int copied = 0;
+
+	//printf("\tFloating Text (%i): '%s'\n", maxChars, text);
+	while(*text)
+	{
+		// returns a pointer to a char string with atmost maxChars characters (not bytes)
+		// p has to be freed; p is NULL if text was null
+		p = BreakString(text, maxChars, copied);
+		text += copied; //jump bytes not chars
+		if(p)
+		{
+			Add(new cOsdItem(p, osUnknown,false)); // unselectable text
+			free(p); p = NULL;
+		}
+	}
+}
+#endif /* REELVDR */
+
+
 void cOsdMenu::Display(void)
 {
   if (subMenu) {
@@ -225,6 +341,7 @@
   if (menuCategory != displayMenu->MenuCategory())
      displayMenu->SetMenuCategory(menuCategory);
   displayMenuItems = displayMenu->MaxItems();
+  cStatus::MsgOsdMenuDisplay(MenuKind());
   displayMenu->SetTabs(cols[0], cols[1], cols[2], cols[3], cols[4]);//XXX
   displayMenu->SetTitle(title);
   cStatus::MsgOsdTitle(title);
@@ -325,6 +442,7 @@
 
 void cOsdMenu::CursorUp(void)
 {
+  displayMenuItems = displayMenu->MaxItems();
   int tmpCurrent = current;
   int lastOnScreen = first + displayMenuItems - 1;
   int last = Count() - 1;
@@ -363,6 +481,7 @@
 
 void cOsdMenu::CursorDown(void)
 {
+  displayMenuItems = displayMenu->MaxItems();
   int tmpCurrent = current;
   int lastOnScreen = first + displayMenuItems - 1;
   int last = Count() - 1;
@@ -403,6 +522,7 @@
 
 void cOsdMenu::PageUp(void)
 {
+  displayMenuItems = displayMenu->MaxItems();
   int oldCurrent = current;
   int oldFirst = first;
   current -= displayMenuItems;
@@ -437,6 +557,7 @@
 
 void cOsdMenu::PageDown(void)
 {
+  displayMenuItems = displayMenu->MaxItems();
   int oldCurrent = current;
   int oldFirst = first;
   current += displayMenuItems;
@@ -477,20 +598,60 @@
      }
 }
 
+#define MENUKEY_TIMEOUT 1500
+
 eOSState cOsdMenu::HotKey(eKeys Key)
 {
-  for (cOsdItem *item = First(); item; item = Next(item)) {
+  bool match = false;
+  bool highlight = false;
+  int  item_nr;
+  int  i;
+
+  if (Key == kNone) {
+     if (lastActivity.TimedOut())
+        Key = kOk;
+     else
+        return osContinue;
+     }
+  else
+     lastActivity.Set(MENUKEY_TIMEOUT);
+  for (cOsdItem *item = Last(); item; item = Prev(item)) {
       const char *s = item->Text();
-      if (s && (s = skipspace(s)) != NULL) {
-         if (*s == Key - k1 + '1') {
+      i = 0;
+      item_nr = 0;
+      if (s && (s = skipspace(s)) != '\0' && '0' <= s[i] && s[i] <= '9') {
+         do {
+            item_nr = item_nr * 10 + (s[i] - '0');
+            }
+         while ( !((s[++i] == '\t')||(s[i] == ' ')) && (s[i] != '\0') && ('0' <= s[i]) && (s[i] <= '9'));
+         if ((Key == kOk) && (item_nr == key_nr)) {
             current = item->Index();
             RefreshCurrent();
             Display();
             cRemote::Put(kOk, true);
+            key_nr = -1;
             break;
             }
+         else if (Key != kOk) {
+            if (!highlight && (item_nr == (Key - k0))) {
+               highlight = true;
+               current = item->Index();
+               }
+            if (!match && (key_nr == -1) && ((item_nr / 10) == (Key - k0))) {
+               match = true;
+               key_nr = (Key - k0);
+               }
+            else if (((key_nr == -1) && (item_nr == (Key - k0))) || (!match && (key_nr >= 0) && (item_nr == (10 * key_nr + Key - k0)))) {
+               current = item->Index();
+               cRemote::Put(kOk, true);
+               key_nr = -1;
+               break;
+               }
+            }
          }
       }
+  if ((!match) && (Key != kNone))
+     key_nr = -1;
   return osContinue;
 }
 
@@ -529,8 +690,8 @@
         }
      }
   switch (int(Key)) {
-    case k0:      return osUnknown;
-    case k1...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
+    case kNone:
+    case k0...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
     case kUp|k_Repeat:
     case kUp:   CursorUp();   break;
     case kDown|k_Repeat:
diff -urN vdr-2.0.1/osdbase.h vdr-2.0.1.reel/osdbase.h
--- vdr-2.0.1/osdbase.h	2012-12-07 10:49:35.000000000 +0100
+++ vdr-2.0.1.reel/osdbase.h	2013-05-09 18:09:51.287874141 +0200
@@ -14,6 +14,7 @@
 #include "osd.h"
 #include "skins.h"
 #include "tools.h"
+#include "submenu.h"
 
 enum eOSState { osUnknown,
                 osContinue,
@@ -30,9 +31,29 @@
                 osStopRecord,
                 osStopReplay,
                 osCancelEdit,
+                osCancelTransfer,
                 osSwitchDvb,
                 osBack,
                 osEnd,
+#ifdef REELVDR
+                osEditChannels,
+                osOSDSetup,
+                osLanguage,
+                osTimezone,
+                osTimeshift,
+                osActiveEvent,
+                osLiveBuffer,
+                osSearchtimers,
+#endif /* REELVDR */
+#ifdef USE_LIVEBUFFER
+                osSwitchChannel,
+#endif /*USE_LIVEBUFFER*/
+#ifdef USE_BOUQUETS
+                osBouquets,
+                osActiveBouquet,
+                osFavourites,
+                osAddFavourite,
+#endif
                 os_User, // the following values can be used locally
                 osUser1,
                 osUser2,
@@ -51,16 +72,20 @@
   char *text;
   eOSState state;
   bool selectable;
+  cSubMenuNode* subMenu;
 protected:
   bool fresh;
 public:
   cOsdItem(eOSState State = osUnknown);
   cOsdItem(const char *Text, eOSState State = osUnknown, bool Selectable = true);
+  cOsdItem(const char *Text, eOSState State, cSubMenuNode* SubMenu);
   virtual ~cOsdItem();
   bool Selectable(void) const { return selectable; }
   void SetText(const char *Text, bool Copy = true);
   void SetSelectable(bool Selectable);
   void SetFresh(bool Fresh);
+  void SetSubMenu(cSubMenuNode* SubMenu) { subMenu = SubMenu; }
+  cSubMenuNode* SubMenu() { return subMenu; }
   const char *Text(void) const { return text; }
   virtual void Set(void) {}
   virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
@@ -85,7 +110,15 @@
 
 class cOsdMenu : public cOsdObject, public cList<cOsdItem> {
 private:
+#ifdef REELVDR
+public:
+  static cSkinDisplayMenu *displayMenu;
+private:
+    bool enableSideNote;
+#else
+private:
   static cSkinDisplayMenu *displayMenu;
+#endif
   static int displayMenuCount;
   int displayMenuItems;
   char *title;
@@ -98,6 +131,8 @@
   char *status;
   int digit;
   bool hasHotkeys;
+  int key_nr;
+  cTimeMs lastActivity;
   void DisplayHelp(bool Force = false);
 protected:
   void SetDisplayMenu(void);
@@ -134,8 +169,13 @@
   int Current(void) const { return current; }
   void Add(cOsdItem *Item, bool Current = false, cOsdItem *After = NULL);
   void Ins(cOsdItem *Item, bool Current = false, cOsdItem *Before = NULL);
+#ifdef REELVDR
+  void AddFloatingText(const char* text, int maxlen); 
+  // breaks the given string into smaller strings of maxlen chars and displays them as unselectable text
+#endif /* REELVDR */
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+  virtual const char* MenuKind() { return "MenuUnknown"; }
   };
 
 #endif //__OSDBASE_H
diff -urN vdr-2.0.1/osd.c vdr-2.0.1.reel/osd.c
--- vdr-2.0.1/osd.c	2013-02-14 16:50:19.000000000 +0100
+++ vdr-2.0.1.reel/osd.c	2013-05-09 18:09:51.291874141 +0200
@@ -1623,6 +1623,8 @@
 int cOsd::osdHeight = 0;
 cVector<cOsd *> cOsd::Osds;
 cMutex cOsd::mutex;
+bool cOsd::pinValid = false;
+
 
 cOsd::cOsd(int Left, int Top, uint Level)
 {
diff -urN vdr-2.0.1/osd.h vdr-2.0.1.reel/osd.h
--- vdr-2.0.1/osd.h	2013-02-12 14:39:08.000000000 +0100
+++ vdr-2.0.1.reel/osd.h	2013-05-09 18:09:51.291874141 +0200
@@ -926,6 +926,7 @@
        ///<        MyOsdDrawPixmap(Left() + pm->ViewPort().X(), Top() + pm->ViewPort().Y(), pm->Data(), w, h, h * d);
        ///<        delete pm;
        ///<        }
+       static bool pinValid;
   };
 
 #define MAXOSDIMAGES 64
diff -urN vdr-2.0.1/pat.c vdr-2.0.1.reel/pat.c
--- vdr-2.0.1/pat.c	2012-11-25 15:12:21.000000000 +0100
+++ vdr-2.0.1.reel/pat.c	2013-05-09 18:09:51.291874141 +0200
@@ -13,6 +13,7 @@
 #include "libsi/section.h"
 #include "libsi/descriptor.h"
 #include "thread.h"
+#include "vdrttxtsubshooks.h"
 
 #define PMT_SCAN_TIMEOUT  10 // seconds
 
@@ -343,6 +344,8 @@
         char DLangs[MAXDPIDS][MAXLANGCODE2] = { "" };
         char SLangs[MAXSPIDS][MAXLANGCODE2] = { "" };
         int Tpid = 0;
+        tTeletextSubtitlePage TeletextSubtitlePages[MAXTXTPAGES];
+        int NumTPages = 0;
         int NumApids = 0;
         int NumDpids = 0;
         int NumSpids = 0;
@@ -434,8 +437,21 @@
                                     NumSpids++;
                                     }
                                  break;
-                            case SI::TeletextDescriptorTag:
+                            case SI::TeletextDescriptorTag: {
                                  Tpid = esPid;
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                     bool isSubtitlePage = (ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05);
+                                     if ((NumTPages < MAXTXTPAGES) && ttxt.languageCode[0] && isSubtitlePage) {
+                                        strn0cpy(TeletextSubtitlePages[NumTPages].ttxtLanguage, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                        TeletextSubtitlePages[NumTPages].ttxtPage = ttxt.getTeletextPageNumber();
+                                        TeletextSubtitlePages[NumTPages].ttxtMagazine = ttxt.getTeletextMagazineNumber();
+                                        TeletextSubtitlePages[NumTPages].ttxtType = ttxt.getTeletextType();
+                                        NumTPages++;
+                                        }
+                                     }
+                                 }
                                  break;
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
@@ -547,6 +563,12 @@
             }
         if (Setup.UpdateChannels >= 2) {
            Channel->SetPids(Vpid, Ppid, Vtype, Apids, Atypes, ALangs, Dpids, Dtypes, DLangs, Spids, SLangs, Tpid);
+           if (NumTPages < MAXTXTPAGES) {
+              int manualPageNumber = cVDRTtxtsubsHookListener::Hook()->ManualPageNumber(Channel);
+              if (manualPageNumber)
+                 TeletextSubtitlePages[NumTPages++] = tTeletextSubtitlePage(manualPageNumber);
+              }
+           Channel->SetTeletextSubtitlePages(TeletextSubtitlePages, NumTPages);
            Channel->SetCaIds(CaDescriptors->CaIds());
            Channel->SetSubtitlingDescriptors(SubtitlingTypes, CompositionPageIds, AncillaryPageIds);
            }
diff -urN vdr-2.0.1/plugin.c vdr-2.0.1.reel/plugin.c
--- vdr-2.0.1/plugin.c	2012-09-01 15:10:27.000000000 +0200
+++ vdr-2.0.1.reel/plugin.c	2013-05-09 18:09:51.291874141 +0200
@@ -107,6 +107,13 @@
   return false;
 }
 
+#ifdef REELVDR
+void cPlugin::SetupStore(const char *Name, const char *PluginName, int Value)
+{
+  Setup.Store(Name, Value, PluginName);
+}
+#endif /* REELVDR */
+
 void cPlugin::SetupStore(const char *Name, const char *Value)
 {
   Setup.Store(Name, Value, this->Name());
diff -urN vdr-2.0.1/plugin.h vdr-2.0.1.reel/plugin.h
--- vdr-2.0.1/plugin.h	2012-09-01 15:08:54.000000000 +0200
+++ vdr-2.0.1.reel/plugin.h	2013-05-09 18:09:51.291874141 +0200
@@ -47,9 +47,17 @@
 
   virtual const char *MainMenuEntry(void);
   virtual cOsdObject *MainMenuAction(void);
+#ifdef USE_MCLI
+  virtual cOsdObject *AltMenuAction(void) { return NULL; };
+#endif /* MCLI */
 
   virtual cMenuSetupPage *SetupMenu(void);
   virtual bool SetupParse(const char *Name, const char *Value);
+#ifdef REELVDR
+  virtual bool HasSetupOptions(void) { return true; };
+  virtual const char *MenuSetupPluginEntry(void) { return NULL; };
+  void SetupStore(const char *Name, const char *PluginName, int Value);
+#endif /* REELVDR */
   void SetupStore(const char *Name, const char *Value = NULL);
   void SetupStore(const char *Name, int Value);
 
diff -urN vdr-2.0.1/po/ca_ES.po vdr-2.0.1.reel/po/ca_ES.po
--- vdr-2.0.1/po/ca_ES.po	2013-03-11 14:10:23.000000000 +0100
+++ vdr-2.0.1.reel/po/ca_ES.po	2013-05-09 18:10:01.583874320 +0200
@@ -974,6 +974,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparncia fons subttols"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "Configuraci de l'LNB"
 
diff -urN vdr-2.0.1/po/cs_CZ.po vdr-2.0.1.reel/po/cs_CZ.po
--- vdr-2.0.1/po/cs_CZ.po	2013-03-11 14:10:35.000000000 +0100
+++ vdr-2.0.1.reel/po/cs_CZ.po	2013-05-09 18:10:01.583874320 +0200
@@ -974,6 +974,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Prhlednost pozad titulk"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/da_DK.po vdr-2.0.1.reel/po/da_DK.po
--- vdr-2.0.1/po/da_DK.po	2013-03-11 14:11:19.000000000 +0100
+++ vdr-2.0.1.reel/po/da_DK.po	2013-05-09 18:10:01.583874320 +0200
@@ -971,6 +971,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Undertekst baggrundsgennemsigtighed"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/de_DE.po vdr-2.0.1.reel/po/de_DE.po
--- vdr-2.0.1/po/de_DE.po	2013-03-11 14:11:24.000000000 +0100
+++ vdr-2.0.1.reel/po/de_DE.po	2013-05-09 18:10:01.587874320 +0200
@@ -870,6 +870,15 @@
 msgid "Button$Scan"
 msgstr "Scan"
 
+msgid "Setup.Recording$Jump Seconds"
+msgstr "Sprungweite in Sekunden"
+
+msgid "Setup.Recording$Jump Seconds Slow"
+msgstr "Sprungweite in Sekunden langsam"
+
+msgid "Setup.Recording$Jump Seconds (Repeated)"
+msgstr "Sprungweite in Sek. (wiederh.)"
+
 msgid "Setup.EPG$EPG scan timeout (h)"
 msgstr "Zeit bis zur EPG-Aktualisierung (h)"
 
@@ -971,6 +980,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Untertitel-Transparenz Hintergrund"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr "Videotext-Untersttzung aktivieren"
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1095,6 +1107,15 @@
 msgid "Replay"
 msgstr "Wiedergabe"
 
+msgid "Setup.Replay$Jump&Play"
+msgstr "Wiedergabe nach Sprung"
+
+msgid "Setup.Replay$Play&Jump"
+msgstr "Sprung bei Schnittmarke"
+
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Pause bei letzter Marke"
+
 msgid "Setup.Replay$Multi speed mode"
 msgstr "Mehrstufiger Vor-/Rcklauf"
 
@@ -1398,3 +1419,70 @@
 
 msgid "free"
 msgstr "frei"
+
+msgid "Edit recording"
+msgstr "Aufnahme bearbeiten"
+
+msgid "Button$Cut"
+msgstr "Schneiden"
+
+msgid "Button$Copy"
+msgstr "Kopieren"
+
+msgid "Button$Rename/Move"
+msgstr "Umbenennen/Bewegen"
+
+msgid "Date"
+msgstr "Datum"
+
+msgid "Length"
+msgstr "Lnge"
+
+msgid "Format"
+msgstr "Format"
+
+msgid "PES"
+msgstr "PES"
+
+msgid "TS"
+msgstr "TS"
+
+msgid "Size"
+msgstr "Gre"
+
+msgid "Delete marks information?"
+msgstr "Gespeicherte Schnittmarken lschen?"
+
+msgid "Delete resume information?"
+msgstr "Gespeicherten Zeitpunkt der letzten Wiedergabe lschen?"
+
+msgid "File transfer started"
+msgstr "Dateibertragung gestartet"
+
+msgid "Can't start file transfer!"
+msgstr "Dateibertragung kann nicht gestartet werden!"
+
+msgid "File transfer already active!"
+msgstr "Dateibertragung bereits aktiv!"
+ 
+#. TRANSLATORS: note the leading blank!
+msgid " Cancel file transfer"
+msgstr " Dateibertragung beenden"
+
+msgid "Cancel file transfer?"
+msgstr "Dateibertragung beenden?"
+
+msgid "Transfering file - shut down anyway?"
+msgstr "bertrage Datei - trotzdem ausschalten?"
+
+msgid "Transfering file - restart anyway?"
+msgstr "bertrage Datei - trotzdem neustarten?"
+
+msgid "File transfer failed!"
+msgstr "Dateibertragung fehlgeschlagen!"
+
+msgid "File transfer finished"
+msgstr "Dateibertragung fertiggestellt"
+
+msgid "File already exists - overwrite?"
+msgstr "Datei besteht bereits - berschreiben?"
diff -urN vdr-2.0.1/po/el_GR.po vdr-2.0.1.reel/po/el_GR.po
--- vdr-2.0.1/po/el_GR.po	2013-03-11 14:11:28.000000000 +0100
+++ vdr-2.0.1.reel/po/el_GR.po	2013-05-09 18:10:01.587874320 +0200
@@ -971,6 +971,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr ""
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/es_ES.po vdr-2.0.1.reel/po/es_ES.po
--- vdr-2.0.1/po/es_ES.po	2013-03-11 14:11:35.000000000 +0100
+++ vdr-2.0.1.reel/po/es_ES.po	2013-05-09 18:10:01.587874320 +0200
@@ -972,6 +972,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparencia fondo subttulos"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/et_EE.po vdr-2.0.1.reel/po/et_EE.po
--- vdr-2.0.1/po/et_EE.po	2013-03-11 14:11:39.000000000 +0100
+++ vdr-2.0.1.reel/po/et_EE.po	2013-05-09 18:10:01.587874320 +0200
@@ -971,6 +971,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Subtiitri tausta lbipaistvus"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr "Teleteksti tugi"
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/fi_FI.po vdr-2.0.1.reel/po/fi_FI.po
--- vdr-2.0.1/po/fi_FI.po	2013-03-17 15:07:35.000000000 +0100
+++ vdr-2.0.1.reel/po/fi_FI.po	2013-05-09 18:10:01.591874320 +0200
@@ -975,6 +975,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Tekstityksen taustan lpinkyvyys"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr "Salli teksti-TV-tuki"
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1402,3 +1405,70 @@
 
 msgid "free"
 msgstr "vapaana"
+
+msgid "Edit recording"
+msgstr "Muokkaa tallennetta"
+
+msgid "Button$Cut"
+msgstr "Leikkaa"
+
+msgid "Button$Copy"
+msgstr "Kopioi"
+
+msgid "Button$Rename/Move"
+msgstr "Nime/Siirr"
+
+msgid "Date"
+msgstr "Pivys"
+
+msgid "Length"
+msgstr "Pituus"
+
+msgid "Format"
+msgstr "Tiedostomuoto"
+
+msgid "PES"
+msgstr "PES"
+
+msgid "TS"
+msgstr "TS"
+
+msgid "Size"
+msgstr "Koko"
+
+msgid "Delete marks information?"
+msgstr "Poista tallenteen merkinnt?"
+
+msgid "Delete resume information?"
+msgstr "Poista tallenteen paluutiedot?"
+
+msgid "File transfer started"
+msgstr "Tiedoston siirto aloitettu"
+
+msgid "Can't start file transfer!"
+msgstr "Tiedoston siirron aloitus eponnistui!"
+
+msgid "File transfer already active!"
+msgstr "Tiedoston siirto on jo kynniss!"
+ 
+#. TRANSLATORS: note the leading blank!
+msgid " Cancel file transfer"
+msgstr " Peru tiedoston siirto"
+
+msgid "Cancel file transfer?"
+msgstr "Perutaanko tiedoston siirto?"
+
+msgid "Transfering file - shut down anyway?"
+msgstr "Tiedoston siirto kesken - sammutetaanko?"
+
+msgid "Transfering file - restart anyway?"
+msgstr "Tiedoston siirto kesken - kynnistetnk uudelleen?"
+
+msgid "File transfer failed!"
+msgstr "Tiedoston siirto eponnistui!"
+
+msgid "File transfer finished"
+msgstr "Tiedoston siirto valmis"
+
+msgid "File already exists - overwrite?"
+msgstr "Tiedosto on jo olemassa - ylikirjoitetaanko?"
diff -urN vdr-2.0.1/po/fr_FR.po vdr-2.0.1.reel/po/fr_FR.po
--- vdr-2.0.1/po/fr_FR.po	2013-03-29 11:27:47.000000000 +0100
+++ vdr-2.0.1.reel/po/fr_FR.po	2013-05-09 18:10:01.591874320 +0200
@@ -981,6 +981,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparence du fond des sous-titres"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1105,6 +1108,15 @@
 msgid "Replay"
 msgstr "Lecture"
 
+msgid "Setup.Replay$Jump&Play"
+msgstr "Lecture aprs saut"
+
+msgid "Setup.Replay$Play&Jump"
+msgstr "Saut sur les marques de dcoupes"
+
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Pause aprs la dernire marque"
+
 msgid "Setup.Replay$Multi speed mode"
 msgstr "Mode multi-vitesses"
 
diff -urN vdr-2.0.1/po/hr_HR.po vdr-2.0.1.reel/po/hr_HR.po
--- vdr-2.0.1/po/hr_HR.po	2013-03-11 14:12:04.000000000 +0100
+++ vdr-2.0.1.reel/po/hr_HR.po	2013-05-09 18:10:01.591874320 +0200
@@ -973,6 +973,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparentnost pozadine titla"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/hu_HU.po vdr-2.0.1.reel/po/hu_HU.po
--- vdr-2.0.1/po/hu_HU.po	2013-03-11 14:12:14.000000000 +0100
+++ vdr-2.0.1.reel/po/hu_HU.po	2013-05-09 18:10:01.595874320 +0200
@@ -975,6 +975,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Felirat htternek transzparencija"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/it_IT.po vdr-2.0.1.reel/po/it_IT.po
--- vdr-2.0.1/po/it_IT.po	2013-03-11 14:12:16.000000000 +0100
+++ vdr-2.0.1.reel/po/it_IT.po	2013-05-09 18:10:01.595874320 +0200
@@ -978,6 +978,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Trasparenza sfondo sottotitoli"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/lt_LT.po vdr-2.0.1.reel/po/lt_LT.po
--- vdr-2.0.1/po/lt_LT.po	2013-03-28 10:01:52.000000000 +0100
+++ vdr-2.0.1.reel/po/lt_LT.po	2013-05-09 18:10:01.595874320 +0200
@@ -971,6 +971,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Subtitr fono permatomumas"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "Konverteris (LNB)"
 
diff -urN vdr-2.0.1/po/nl_NL.po vdr-2.0.1.reel/po/nl_NL.po
--- vdr-2.0.1/po/nl_NL.po	2013-03-11 14:12:56.000000000 +0100
+++ vdr-2.0.1.reel/po/nl_NL.po	2013-05-09 18:10:01.599874320 +0200
@@ -976,6 +976,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparantie achtergrond ondertiteling"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/nn_NO.po vdr-2.0.1.reel/po/nn_NO.po
--- vdr-2.0.1/po/nn_NO.po	2013-03-11 14:13:05.000000000 +0100
+++ vdr-2.0.1.reel/po/nn_NO.po	2013-05-09 18:10:01.599874320 +0200
@@ -972,6 +972,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr ""
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/pl_PL.po vdr-2.0.1.reel/po/pl_PL.po
--- vdr-2.0.1/po/pl_PL.po	2013-03-11 14:13:08.000000000 +0100
+++ vdr-2.0.1.reel/po/pl_PL.po	2013-05-09 18:10:01.599874320 +0200
@@ -973,6 +973,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Przerocze podtytuw: To"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/pt_PT.po vdr-2.0.1.reel/po/pt_PT.po
--- vdr-2.0.1/po/pt_PT.po	2013-03-11 14:13:14.000000000 +0100
+++ vdr-2.0.1.reel/po/pt_PT.po	2013-05-09 18:10:01.599874320 +0200
@@ -972,6 +972,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparncia de fundo das legendas"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/ro_RO.po vdr-2.0.1.reel/po/ro_RO.po
--- vdr-2.0.1/po/ro_RO.po	2013-03-11 14:13:23.000000000 +0100
+++ vdr-2.0.1.reel/po/ro_RO.po	2013-05-09 18:10:01.603874320 +0200
@@ -973,6 +973,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparena fundalului subtitrrii"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/ru_RU.po vdr-2.0.1.reel/po/ru_RU.po
--- vdr-2.0.1/po/ru_RU.po	2013-03-11 14:13:26.000000000 +0100
+++ vdr-2.0.1.reel/po/ru_RU.po	2013-05-09 18:10:01.603874320 +0200
@@ -972,6 +972,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "  "
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr ""
 
diff -urN vdr-2.0.1/po/sk_SK.po vdr-2.0.1.reel/po/sk_SK.po
--- vdr-2.0.1/po/sk_SK.po	2013-03-11 14:13:32.000000000 +0100
+++ vdr-2.0.1.reel/po/sk_SK.po	2013-05-09 18:10:01.603874320 +0200
@@ -971,6 +971,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Priehadnos pozadia titulkov"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB (nzko umov jednotka)"
 
diff -urN vdr-2.0.1/po/sl_SI.po vdr-2.0.1.reel/po/sl_SI.po
--- vdr-2.0.1/po/sl_SI.po	2013-03-11 14:13:47.000000000 +0100
+++ vdr-2.0.1.reel/po/sl_SI.po	2013-05-09 18:10:01.603874320 +0200
@@ -972,6 +972,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparentnost ozadja podnapisov"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/sv_SE.po vdr-2.0.1.reel/po/sv_SE.po
--- vdr-2.0.1/po/sv_SE.po	2013-03-11 14:13:53.000000000 +0100
+++ vdr-2.0.1.reel/po/sv_SE.po	2013-05-09 18:10:01.603874320 +0200
@@ -975,6 +975,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparent bakgrund textremsa"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/tr_TR.po vdr-2.0.1.reel/po/tr_TR.po
--- vdr-2.0.1/po/tr_TR.po	2013-03-11 14:13:56.000000000 +0100
+++ vdr-2.0.1.reel/po/tr_TR.po	2013-05-09 18:10:01.603874320 +0200
@@ -971,6 +971,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Altyaz arka effaflk"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
diff -urN vdr-2.0.1/po/uk_UA.po vdr-2.0.1.reel/po/uk_UA.po
--- vdr-2.0.1/po/uk_UA.po	2013-03-11 14:13:58.000000000 +0100
+++ vdr-2.0.1.reel/po/uk_UA.po	2013-05-09 18:10:01.603874320 +0200
@@ -972,6 +972,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "   "
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr ""
 
diff -urN vdr-2.0.1/po/zh_CN.po vdr-2.0.1.reel/po/zh_CN.po
--- vdr-2.0.1/po/zh_CN.po	2013-03-11 14:14:04.000000000 +0100
+++ vdr-2.0.1.reel/po/zh_CN.po	2013-05-09 18:10:01.603874320 +0200
@@ -973,6 +973,9 @@
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr ""
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr ""
 
diff -urN vdr-2.0.1/README.jumpplay vdr-2.0.1.reel/README.jumpplay
--- vdr-2.0.1/README.jumpplay	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/README.jumpplay	2013-05-09 18:10:01.603874320 +0200
@@ -0,0 +1,92 @@
+JumpPlay patch for VDR
+----------------------
+
+This patch changes the replay behaviour for recordings that contain editing
+marks. It allows to immediately continue the replay after jumping forward to
+the next mark, and to automatically jump over the commercial break to the next
+"start" mark, if an "end" mark is reached.
+
+The features of this patch can be turned on or off with parameters in the replay
+setup. See MANUAL for description of this parameters: "Jump&Play", "Play&Jump",
+"Pause at last mark" and "Reload marks".
+
+
+* History
+
+  2003-07-04: jumpandrun.diff - the Noad <theNoad@SoftHome.net>
+    Jump&Play
+
+  2003-12-06: Version 0.0 - Torsten Kunkel <vdr@tkunkel.de>
+    Play&Jump (only if progressbar is visible)
+    Setup parameters Jump&Play and Play&Jump in the replay setup
+
+  2004-01-20: Version 0.1 - Thomas Gnther <tom@toms-cafe.de>
+    Jump&Play:
+      - fixed speed after jump
+      - fixed removing of marks
+    Play&Jump:
+      - jump only on "end" marks
+
+  2004-01-27: Version 0.2 - Thomas Gnther <tom@toms-cafe.de>
+    Jump&Play:
+      - fixed double jump
+    Play&Jump:
+      - fixed mark detection: fuzzy detection (until 3 seconds after mark)
+      - jump without progressbar
+      - mode "progressbar only" for old behaviour
+
+  2004-01-31: Version 0.3 - Thomas Gnther <tom@toms-cafe.de>
+    Jump&Play:
+      - fixed display frames
+    Play&Jump:
+      - fixed end of playing at last mark
+
+  2004-07-11: Version 0.4 - Thomas Gnther <tom@toms-cafe.de>
+    Jump&Play:
+      - don't play after jump to end
+    Play&Jump:
+      - don't prevent jumping after hide or show
+    Less conflicts with other patches (Elchi/AutoPID)
+
+  2004-08-21: Version 0.5 - Thomas Gnther <tom@toms-cafe.de>
+    Play&Jump:
+      - exact jumps, replay like edited recording (no fuzzy mark detection)
+      - jump to first mark if replay starts at the beginning
+      - check jump marks with '8' key
+      - mode "progressbar only" removed
+    Description in README.jumpplay
+
+  2004-12-28: Version 0.6 - Thomas Gnther <tom@toms-cafe.de>
+    Adapted noad extensions (from the Noad <theNoad@SoftHome.net>) to
+    jumpplay-0.5:
+      - cyclic reloading of marks found by noad online-scan
+      - don't stop after the last mark in case of live-recordings
+    New setup parameter "Load marks interval (s)"
+    Updated description in README.jumpplay
+
+  2006-04-14: Version 0.7 - Thomas Gnther <tom@toms-cafe.de>
+    Fixed jump to first mark (crashed with plugin extrecmenu-0.9)
+    Added version define JUMPPLAYVERSNUM
+    Added placeholders for Czech language texts
+    Cleaned up i18n entries (support only VDR >= 1.3.29)
+    Improved description of i18n placeholders - hoping for real language texts
+
+  2006-05-12: Version 0.8 - Thomas Gnther <tom@toms-cafe.de>
+    Fixed segfault in dvbplayer thread while the replaycontrol thread is
+    reloading the marks (thanks to horchi at vdrportal.de for reporting this -
+    see http://vdrportal.de/board/thread.php?postid=450463#post450463):
+    New class cMarksReload checks the timestamp of marks.vdr in 10 seconds
+    intervals, so the marks in the threads dvbplayer and replaycontrol can be
+    reloaded independently
+    Changed setup parameter "Load marks interval (s)" to "Reload marks"
+    Updated description in README.jumpplay
+
+  2006-05-28: Version 0.9 - Thomas Gnther <tom@toms-cafe.de>
+    New setup parameter "Pause at last mark"
+    Updated description in README.jumpplay
+    Moved parameters description to MANUAL
+
+  2009-03-31: Version 1.0 - Thomas Gnther <tom@toms-cafe.de>
+    Play&Jump:
+      - set resume position to 0 if replay stops at the first mark
+    Added French language texts (thanks to Michal Nival)
diff -urN vdr-2.0.1/receiver.c vdr-2.0.1.reel/receiver.c
--- vdr-2.0.1/receiver.c	2012-06-02 15:20:38.000000000 +0200
+++ vdr-2.0.1.reel/receiver.c	2013-05-09 18:10:01.603874320 +0200
@@ -67,7 +67,8 @@
             (Channel->Ppid() == Channel->Vpid() || AddPid(Channel->Ppid())) &&
             AddPids(Channel->Apids()) &&
             AddPids(Channel->Dpids()) &&
-            AddPids(Channel->Spids());
+            AddPids(Channel->Spids()) &&
+            (!Setup.SupportTeletext || AddPid(Channel->Tpid()));
      }
   return true;
 }
diff -urN vdr-2.0.1/recording.c vdr-2.0.1.reel/recording.c
--- vdr-2.0.1/recording.c	2013-04-11 10:20:03.000000000 +0200
+++ vdr-2.0.1.reel/recording.c	2013-05-09 18:10:01.603874320 +0200
@@ -8,6 +8,7 @@
  */
 
 #include "recording.h"
+#include "iconpatch.h"
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -998,7 +999,7 @@
 
 const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level) const
 {
-  char New = NewIndicator && IsNew() ? '*' : ' ';
+  const char *New = NewIndicator && IsNew() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_NEW_UTF8 : ICON_NEW : "*" : " ";
   free(titleBuffer);
   titleBuffer = NULL;
   if (Level < 0 || Level == HierarchyLevels()) {
@@ -1018,7 +1019,7 @@
                    Minutes % 60
                    );
         }
-     titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%s%c%c%s",
+     titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%s%s%c%s",
                             t->tm_mday,
                             t->tm_mon + 1,
                             t->tm_year % 100,
@@ -1068,6 +1069,16 @@
   return NULL;
 }
 
+const char *cRecording::UpdateFileName(const char *FileName)
+{
+  if (FileName && *FileName) {
+     free(fileName);
+     fileName = strdup(FileName);
+     return fileName;
+     }
+  return NULL;
+}
+
 int cRecording::HierarchyLevels(void) const
 {
   const char *s = name;
@@ -1360,7 +1371,7 @@
      }
 }
 
-void cRecordings::DelByName(const char *FileName)
+void cRecordings::DelByName(const char *FileName, bool RemoveRecording)
 {
   LOCK_THREAD;
   cRecording *recording = GetByName(FileName);
@@ -1368,7 +1379,7 @@
      cThreadLock DeletedRecordingsLock(&DeletedRecordings);
      Del(recording, false);
      char *ext = strrchr(recording->fileName, '.');
-     if (ext) {
+     if (ext && RemoveRecording) {
         strncpy(ext, DELEXT, strlen(ext));
         if (access(recording->FileName(), F_OK) == 0) {
            recording->deleted = time(NULL);
diff -urN vdr-2.0.1/recording.h vdr-2.0.1.reel/recording.h
--- vdr-2.0.1/recording.h	2013-03-04 15:01:23.000000000 +0100
+++ vdr-2.0.1.reel/recording.h	2013-05-09 18:10:01.603874320 +0200
@@ -68,6 +68,7 @@
   const cEvent *GetEvent(void) const { return event; }
   const char *Title(void) const { return event->Title(); }
   const char *ShortText(void) const { return event->ShortText(); }
+  tEventID EventID(void) const { return event->EventID(); }
   const char *Description(void) const { return event->Description(); }
   const cComponents *Components(void) const { return event->Components(); }
   const char *Aux(void) const { return aux; }
@@ -119,6 +120,7 @@
   const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1) const;
   const cRecordingInfo *Info(void) const { return info; }
   const char *PrefixFileName(char Prefix);
+  const char *UpdateFileName(const char *FileName);
   int HierarchyLevels(void) const;
   void ResetResume(void) const;
   double FramesPerSecond(void) const { return framesPerSecond; }
@@ -130,7 +132,7 @@
   int FileSizeMB(void) const;
        ///< Returns the total file size of this recording (in MB), or -1 if the file
        ///< size is unknown.
-  bool IsNew(void) const { return GetResume() <= 0; }
+  bool IsNew(void) const { return GetResume() < 0; }
   bool IsEdited(void) const;
   bool IsPesRecording(void) const { return isPesRecording; }
   bool IsOnVideoDirectoryFileSystem(void) const;
@@ -191,7 +193,7 @@
   void ClearSortNames(void);
   cRecording *GetByName(const char *FileName);
   void AddByName(const char *FileName, bool TriggerUpdate = true);
-  void DelByName(const char *FileName);
+  void DelByName(const char *FileName, bool RemoveRecording = true);
   void UpdateByName(const char *FileName);
   int TotalFileSizeMB(void);
   double MBperMinute(void);
diff -urN vdr-2.0.1/remotetimers.h vdr-2.0.1.reel/remotetimers.h
--- vdr-2.0.1/remotetimers.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/remotetimers.h	2013-05-09 18:10:01.603874320 +0200
@@ -0,0 +1,25 @@
+/*
+ * remotetimers.h: Public interface of the plugin's services
+ *
+ * See the README file for copyright information and how to reach the author.
+ */
+
+#ifndef _SERVICE__H
+#define _SERVICE__H
+
+#ifndef __TIMERS_H
+#include <vdr/timer.h>
+#include <vdr/epg.h>
+#endif
+
+struct RemoteTimers_InstantRecording_v1_0 {
+//in
+	const cTimer	*timer;
+	bool		pause;
+	const cEvent	*event;
+//out
+	cString		name;
+	cString		fileName;
+};
+
+#endif //_SERVICE__H
diff -urN vdr-2.0.1/remux.c vdr-2.0.1.reel/remux.c
--- vdr-2.0.1/remux.c	2013-03-03 11:37:58.000000000 +0100
+++ vdr-2.0.1.reel/remux.c	2013-05-09 18:10:01.603874320 +0200
@@ -385,6 +385,29 @@
   return i;
 }
 
+int cPatPmtGenerator::MakeTeletextDescriptor(uchar *Target, const tTeletextSubtitlePage *pages, int pageCount)
+{
+  int i = 0, j = 0;
+  Target[i++] = SI::TeletextDescriptorTag;
+  int l = i;
+  Target[i++] = 0x00; // length
+  for (int n = 0; n < pageCount; n++) {
+      const char* Language = pages[n].ttxtLanguage;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = (pages[n].ttxtType << 3) + pages[n].ttxtMagazine;
+      Target[i++] = pages[n].ttxtPage;
+      j++;
+      }
+  if (j > 0) {
+     Target[l] = j * 5; // update length
+     IncEsInfoLength(i);
+     return i;
+     }
+  return 0;
+}
+
 int cPatPmtGenerator::MakeLanguageDescriptor(uchar *Target, const char *Language)
 {
   int i = 0;
@@ -472,6 +495,7 @@
   if (Channel) {
      int Vpid = Channel->Vpid();
      int Ppid = Channel->Ppid();
+     int Tpid = Channel->Tpid();
      uchar *p = buf;
      int i = 0;
      p[i++] = 0x02; // table id
@@ -504,6 +528,10 @@
          i += MakeStream(buf + i, 0x06, Channel->Spid(n));
          i += MakeSubtitlingDescriptor(buf + i, Channel->Slang(n), Channel->SubtitlingType(n), Channel->CompositionPageId(n), Channel->AncillaryPageId(n));
          }
+     if (Tpid) {
+        i += MakeStream(buf + i, 0x06, Tpid);
+        i += MakeTeletextDescriptor(buf + i, Channel->TeletextSubtitlePages(), Channel->TotalTeletextSubtitlePages());
+        }
 
      int sl = i - SectionLength - 2 + 4; // -2 = SectionLength storage, +4 = length of CRC
      buf[SectionLength] |= (sl >> 8) & 0x0F;
@@ -577,6 +605,7 @@
   pmtPids[0] = 0;
   vpid = vtype = 0;
   ppid = 0;
+  tpid = 0;
 }
 
 void cPatPmtParser::ParsePat(const uchar *Data, int Length)
@@ -665,11 +694,13 @@
      int NumSpids = 0;
      vpid = vtype = 0;
      ppid = 0;
+     tpid = 0;
      apids[0] = 0;
      dpids[0] = 0;
      spids[0] = 0;
      atypes[0] = 0;
      dtypes[0] = 0;
+     totalTtxtSubtitlePages = 0;
      SI::PMT::Stream stream;
      for (SI::Loop::Iterator it; Pmt.streamLoop.getNext(stream, it); ) {
          dbgpatpmt("     stream type = %02X, pid = %d", stream.getStreamType(), stream.getPid());
@@ -768,6 +799,28 @@
                                     spids[NumSpids] = 0;
                                     }
                                  break;
+                            case SI::TeletextDescriptorTag: {
+                                 dbgpatpmt(" teletext");
+                                 tpid = stream.getPid();
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 if (totalTtxtSubtitlePages < MAXTXTPAGES) {
+                                    for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                        bool isSubtitlePage = (ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05);
+                                        if (isSubtitlePage && ttxt.languageCode[0]) {
+                                           dbgpatpmt(" '%s:%x.%x'", ttxt.languageCode, ttxt.getTeletextMagazineNumber(), ttxt.getTeletextPageNumber());
+                                           strn0cpy(teletextSubtitlePages[totalTtxtSubtitlePages].ttxtLanguage, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtPage = ttxt.getTeletextPageNumber();
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtMagazine = ttxt.getTeletextMagazineNumber();
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtType = ttxt.getTeletextType();
+                                           totalTtxtSubtitlePages++;
+                                           if (totalTtxtSubtitlePages >= MAXTXTPAGES)
+                                              break;
+                                           }
+                                        }
+                                    }
+                                 }
+                                 break;
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
                                  dbgpatpmt(" '%s'", ld->languageCode);
diff -urN vdr-2.0.1/remux.h vdr-2.0.1.reel/remux.h
--- vdr-2.0.1/remux.h	2013-01-20 12:43:59.000000000 +0100
+++ vdr-2.0.1.reel/remux.h	2013-05-09 18:10:01.607874320 +0200
@@ -294,6 +294,7 @@
   int MakeStream(uchar *Target, uchar Type, int Pid);
   int MakeAC3Descriptor(uchar *Target, uchar Type);
   int MakeSubtitlingDescriptor(uchar *Target, const char *Language, uchar SubtitlingType, uint16_t CompositionPageId, uint16_t AncillaryPageId);
+  int MakeTeletextDescriptor(uchar *Target, const tTeletextSubtitlePage *pages, int pageCount);
   int MakeLanguageDescriptor(uchar *Target, const char *Language);
   int MakeCRC(uchar *Target, const uchar *Data, int Length);
   void GeneratePmtPid(const cChannel *Channel);
@@ -341,6 +342,7 @@
   int vpid;
   int ppid;
   int vtype;
+  int tpid;
   int apids[MAXAPIDS + 1]; // list is zero-terminated
   int atypes[MAXAPIDS + 1]; // list is zero-terminated
   char alangs[MAXAPIDS][MAXLANGCODE2];
@@ -353,6 +355,8 @@
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   bool updatePrimaryDevice;
+  int totalTtxtSubtitlePages;
+  tTeletextSubtitlePage teletextSubtitlePages[MAXTXTPAGES];
 protected:
   int SectionLength(const uchar *Data, int Length) { return (Length >= 3) ? ((int(Data[1]) & 0x0F) << 8)| Data[2] : 0; }
 public:
@@ -389,6 +393,9 @@
   int Vtype(void) const { return vtype; }
        ///< Returns the video stream type as defined by the current PMT, or 0 if no video
        ///< stream type has been detected, yet.
+  int Tpid(void) { return tpid; }
+       ///< Returns the teletext pid as defined by the current PMT, or 0 if no teletext
+       ///< pid has been detected, yet.
   const int *Apids(void) const { return apids; }
   const int *Dpids(void) const { return dpids; }
   const int *Spids(void) const { return spids; }
@@ -403,6 +410,8 @@
   uchar SubtitlingType(int i) const { return (0 <= i && i < MAXSPIDS) ? subtitlingTypes[i] : uchar(0); }
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
+  const tTeletextSubtitlePage *TeletextSubtitlePages() const { return teletextSubtitlePages; }
+  int TotalTeletextSubtitlePages() const { return totalTtxtSubtitlePages; }
   };
 
 // TS to PES converter:
diff -urN vdr-2.0.1/s2reel_compat.h vdr-2.0.1.reel/s2reel_compat.h
--- vdr-2.0.1/s2reel_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/s2reel_compat.h	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,25 @@
+#ifdef REELVDR
+/*
+   provide compatibility between S2API (DVB API V5) and older Reel S2 API
+   RC, 24.08.2010
+*/
+
+#ifdef DVBAPI_V5
+//FIXME: really ugly hack to extend enum fe_type
+#define FE_DVBS2 (FE_ATSC+1)
+
+//DVB V5: PSK_8+4 = DQPSK+1 = one more than last modulation
+#define QPSK_S2 (PSK_8+4)
+
+#else // for API V3 + Reel S2 extensions
+
+//      API V5     Reel
+#define ROLLOFF_20 FE_ROLLOFF_20
+#define ROLLOFF_25 FE_ROLLOFF_25
+#define ROLLOFF_35 FE_ROLLOFF_35
+
+#define PSK_8 PSK8
+
+#endif
+
+#endif /*REELVDR*/
diff -urN vdr-2.0.1/sections.c vdr-2.0.1.reel/sections.c
--- vdr-2.0.1/sections.c	2012-10-04 14:21:59.000000000 +0200
+++ vdr-2.0.1.reel/sections.c	2013-05-09 18:10:01.607874320 +0200
@@ -197,7 +197,11 @@
                   if (fh) {
                      // Read section data:
                      unsigned char buf[4096]; // max. allowed size for any EIT section
+#ifdef USE_MCLI
                      int r = device->ReadFilter(fh->handle, buf, sizeof(buf));
+#else
+                     int r = safe_read(fh->handle, buf, sizeof(buf));
+#endif /* MCLI */
                      if (!DeviceHasLock)
                         continue; // we do the read anyway, to flush any data that might have come from a different transponder
                      if (r > 3) { // minimum number of bytes necessary to get section length
diff -urN vdr-2.0.1/shutdown.c vdr-2.0.1.reel/shutdown.c
--- vdr-2.0.1/shutdown.c	2013-02-18 11:33:26.000000000 +0100
+++ vdr-2.0.1.reel/shutdown.c	2013-05-09 18:10:01.607874320 +0200
@@ -17,6 +17,7 @@
 #include "channels.h"
 #include "config.h"
 #include "cutter.h"
+#include "filetransfer.h"
 #include "i18n.h"
 #include "interface.h"
 #include "menu.h"
@@ -171,6 +172,10 @@
      if (!Interactive || !Interface->Confirm(tr("Editing - shut down anyway?")))
         return false;
      }
+  if (cFileTransfer::Active()) {
+     if (!Interactive || !Interface->Confirm(tr("Transfering file - shut down anyway?")))
+        return false;
+     }
 
   cTimer *timer = Timers.GetNextActiveTimer();
   time_t Next = timer ? timer->StartTime() : 0;
@@ -214,6 +219,10 @@
      if (!Interactive || !Interface->Confirm(tr("Editing - restart anyway?")))
         return false;
      }
+  if (cFileTransfer::Active()) {
+     if (!Interactive || !Interface->Confirm(tr("Transfering file - restart anyway?")))
+        return false;
+     }
 
   cTimer *timer = Timers.GetNextActiveTimer();
   time_t Next  = timer ? timer->StartTime() : 0;
diff -urN vdr-2.0.1/status.c vdr-2.0.1.reel/status.c
--- vdr-2.0.1/status.c	2012-03-07 15:17:24.000000000 +0100
+++ vdr-2.0.1.reel/status.c	2013-05-09 18:10:01.607874320 +0200
@@ -124,3 +124,84 @@
   for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
       sm->OsdProgramme(PresentTime, PresentTitle, PresentSubtitle, FollowingTime, FollowingTitle, FollowingSubtitle);
 }
+
+void cStatus::MsgOsdSetEvent(const cEvent* event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetEvent(event);
+}
+
+void cStatus::MsgOsdSetRecording(const cRecording* recording)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetRecording(recording);
+}
+
+void cStatus::MsgOsdMenuDisplay(const char* kind)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDisplay(kind);
+}
+
+void cStatus::MsgOsdMenuDestroy()
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDestroy();
+}
+void cStatus::MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->OsdEventItem(Event, Text, Index, Count);
+}
+
+bool cStatus::MsgChannelProtected(const cDevice* Device, const cChannel* Channel)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      if (sm->ChannelProtected(Device, Channel) == true)
+          return true;
+
+  return false;
+}
+
+bool cStatus::MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->ReplayProtected(Recording, Name, Base, isDirectory, menuView) == true)
+         return true;
+     return false;
+}
+
+void cStatus::MsgRecordingFile(const char* FileName)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->RecordingFile(FileName);
+}
+
+void cStatus::MsgTimerCreation(cTimer* Timer, const cEvent *Event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->TimerCreation(Timer, Event);
+}
+
+bool cStatus::MsgPluginProtected(cPlugin* Plugin, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->PluginProtected(Plugin, menuView) == true)
+         return true;
+     return false;
+}
+
+void cStatus::MsgUserAction(const eKeys key, const cOsdObject* Interact)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->UserAction(key, Interact);
+}
+
+bool cStatus::MsgMenuItemProtected(const char* Name, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->MenuItemProtected(Name, menuView) == true)
+         return true;
+     return false;
+}
diff -urN vdr-2.0.1/status.h vdr-2.0.1.reel/status.h
--- vdr-2.0.1/status.h	2012-03-07 15:16:57.000000000 +0100
+++ vdr-2.0.1.reel/status.h	2013-05-09 18:10:01.607874320 +0200
@@ -14,6 +14,7 @@
 #include "device.h"
 #include "player.h"
 #include "tools.h"
+#include "plugin.h"
 
 enum eTimerChange { tcMod, tcAdd, tcDel };
 
@@ -81,6 +82,34 @@
                // The OSD displays the single line Text with the current channel information.
   virtual void OsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle) {}
                // The OSD displays the given programme information.
+  virtual void OsdSetRecording(const cRecording* recording) {}
+               // The OSD displays the recording information.
+  virtual void OsdSetEvent(const cEvent* event) {}
+               // The OSD displays the event information.
+  virtual void OsdMenuDisplay(const char* kind) {}
+               // report menu creation
+  virtual void OsdMenuDestroy() {}
+               // report menu destruvtion
+  virtual void OsdEventItem(const cEvent* Event, const char *Text, int Index, int Count) {}
+               // The OSD displays the given single line Event as menu item at Index.
+  virtual bool ChannelProtected(const cDevice *Device, const cChannel* Channel)  { return false; }
+               // Checks if a channel is protected.
+  virtual bool ReplayProtected(const cRecording* Recording, const char* Name,
+                               const char* Base, bool isDirectory, int menuView = false) { return false; }
+               // Checks if a recording is protected.
+  virtual void RecordingFile(const char* FileName) {}
+               // The given DVB device has started recording to FileName. FileName is the name of the
+               // recording directory
+  virtual void TimerCreation(cTimer* Timer, const cEvent *Event) {}
+               // The given timer is created
+  virtual bool PluginProtected(cPlugin* Plugin, int menuView = false)  { return false; }
+               // Checks if a plugin is protected.
+  virtual void UserAction(const eKeys key, const cOsdObject* Interact) {}
+               // report user action
+  virtual bool MenuItemProtected(const char* Name, int menuView = false)  { return false; }
+               // Checks if a menu entry is protected.
+
+
 public:
   cStatus(void);
   virtual ~cStatus();
@@ -102,6 +131,19 @@
   static void MsgOsdTextItem(const char *Text,  bool Scroll = false);
   static void MsgOsdChannel(const char *Text);
   static void MsgOsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle);
+  static void MsgOsdSetEvent(const cEvent* event);
+  static void MsgOsdSetRecording(const cRecording* recording);
+  static void MsgOsdMenuDisplay(const char* kind);
+  static void MsgOsdMenuDestroy();
+  static void MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count);
+  static bool MsgChannelProtected(const cDevice* Device, const cChannel* Channel);
+  static bool MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView = false);
+  static void MsgRecordingFile(const char* FileName);
+  static void MsgTimerCreation(cTimer* Timer, const cEvent *Event);
+  static bool MsgPluginProtected(cPlugin* Plugin, int menuView = false);
+  static void MsgUserAction(const eKeys key, const cOsdObject* Interact);
+  static bool MsgMenuItemProtected(const char* Name, int menuView = false);
   };
 
 #endif //__STATUS_H
diff -urN vdr-2.0.1/submenu.c vdr-2.0.1.reel/submenu.c
--- vdr-2.0.1/submenu.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/submenu.c	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,1214 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Submenu
+ *
+ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004, 2005 by Ralf Dotzert
+ *
+ * modified for the VDR Extensions Patch by zulu @vdr-portal
+ ****************************************************************************/
+
+#ifndef SUBMENU_H
+#include "submenu.h"
+#include "plugin.h"
+#include "iconpatch.h"
+
+static const char* TAG_SYSTEM      = "system";
+static const char* TAG_PLUGIN      = "plugin";
+static const char* TAG_COMMAND     = "command";
+static const char* TAG_THREAD      = "thread";
+static const char* TAG_MENU        = "menu";
+#ifdef REELVDR
+static const char* TAG_INCLUDE     = "include";
+#endif /*REELVDR*/
+static const char* TAG_UNDEFINED   = "undefined";
+static const char* TRUE_STR        = "yes";
+
+#ifdef REELVDR
+bool getfiles(const char *string, std::vector<char*> *files)
+{
+#if 0
+    char command[128];
+    FILE *file;
+
+    sprintf(command, "ls %s 2>/dev/null", string);
+    file = popen(command, "r");
+    if(file)
+    {
+        char *strBuff;
+        cReadLine readline;
+        strBuff = readline.Read(file);
+        while(strBuff)
+        {
+            files->push_back(strdup(strBuff));
+            strBuff = readline.Read(file);
+        }
+        pclose(file);
+    }
+    else
+        return false;
+
+    return true;
+#else
+	// Speedup by not using shell command (but currently limiting to a single wildcard)
+	DIR *dp;
+	struct dirent *dirp;
+	char *search = strdup(string);
+	char *dir=search;
+	char *name=strrchr(dir, '/');
+	if(!name) {
+		free(search);
+		return false;
+	} // if
+	*name++=0;
+	char *last=strrchr(name, '*');
+	if(last) *last++=0;
+	unsigned int name_len = strlen(name);
+	unsigned int last_len = last ? strlen(last) : 0;
+	if((dp  = opendir(dir)) == NULL) {
+		free(search);
+		return false;
+	} // if
+	while ((dirp = readdir(dp)) != NULL) {
+		if(strncmp(dirp->d_name, name, name_len))
+			continue;
+		if (last && ((strlen(dirp->d_name)<last_len) || strcmp(&dirp->d_name[strlen(dirp->d_name)-last_len], last)))
+			continue;
+		char *new_name=NULL;
+		asprintf(&new_name, "%s/%s", dir, dirp->d_name);
+		files->push_back(new_name);
+	} // while
+	free(search);
+	return true;
+#endif
+}
+#endif /* REELVDR */
+
+//################################################################################
+//# SubMenuNode
+//################################################################################
+
+cSubMenuNode::cSubMenuNode(TiXmlElement *xml, int level,  cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
+{
+  init();
+  _parentMenu  = parentMenu;
+  _currentMenu = currentMenu;
+  _level       = level;
+
+  if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT) {
+     const char *tag = xml->Value();
+
+     if (cSubMenuNode::IsType(tag) != cSubMenuNode::UNDEFINED) {
+        SetType(tag);
+#ifdef REELVDR
+        const char *name = xml->Attribute("name");
+        const char *info = xml->Attribute("info");
+        const char *help = xml->Attribute("help");
+        const char *iconNumber = xml->Attribute("icon_number");
+        SetName(name);
+        SetIconNumber(iconNumber);
+        if (info) SetInfo(info);
+        if (help) {
+           if (!info) SetInfo("(?)");
+           SetHelp(help); 
+        }
+        if (strcmp(name,"setup") == 0) 
+            SetSetupLink(xml->Attribute("link"));
+#else
+        SetName(xml->Attribute("name"));
+#endif /* REELVDR */
+        if ((_type == COMMAND) || (_type == THREAD)) {
+           SetCommand(xml->Attribute("execute"));
+           const char *confirmStr = xml->Attribute("confirm");
+           if (confirmStr != NULL && strcmp(confirmStr, TRUE_STR) == 0)
+              _commandConfirm = true;
+           }
+        else if (_type == PLUGIN) { // Add Plugin Index
+           SetCustomTitle(xml->Attribute("title"));
+#ifdef REELVDR
+           SetPlugin(GetSetupLink());
+#else
+           SetPlugin();
+#endif
+           }
+#ifdef REELVDR
+        else if(_type == INCLUDE) {
+            char *includeXML;
+            asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
+            if(strchr(includeXML, '*'))
+            {
+                std::vector<char*> includeXMLs;
+                getfiles(includeXML, &includeXMLs);
+                for(unsigned int i=0; i<includeXMLs.size(); ++i)
+                    IncludeXml(includeXMLs.at(i));
+            }
+            else
+                IncludeXml(includeXML);
+            free(includeXML);
+            }
+#endif /* REELVDR */
+        else if (_type == MENU && xml->NoChildren() == false) {
+           xml = xml->FirstChildElement();
+           do {
+#ifdef REELVDR
+              if(cSubMenuNode::IsType(xml->Value()) == cSubMenuNode::INCLUDE)
+              {
+                  char *includeXML;
+                  asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
+                  if(strchr(includeXML, '*'))
+                  {
+                      std::vector<char*> includeXMLs;
+                      getfiles(includeXML, &includeXMLs);
+                      for(unsigned int i=0; i<includeXMLs.size(); ++i)
+                          IncludeXml(includeXMLs.at(i));
+                  }
+                  else
+                      IncludeXml(includeXML);
+                  free(includeXML);
+              }
+              else
+              {
+                  cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
+                  _subMenus.Add(node);
+              }
+#else
+              cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
+              _subMenus.Add(node);
+#endif
+              } while ((xml=xml->NextSiblingElement()) != NULL);
+           }
+        }
+     }
+  else
+     throw "Invalid XML Node";
+}
+
+/**
+ * Construct new Node empty Node
+ *
+ *
+ */
+cSubMenuNode::cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
+{
+  init();
+  _parentMenu  = parentMenu;
+  _currentMenu = currentMenu;
+
+}
+
+
+/**
+ *
+ */
+void cSubMenuNode::init()
+{
+  _name                = NULL;
+  _command             = NULL;
+  _title               = NULL;
+  _pluginMainMenuEntry = NULL;
+  _type                = UNDEFINED;
+  _level               = 0;
+  _parentMenu          = NULL;
+  _currentMenu         = NULL;
+  _pluginIndex         = 0;
+  _commandConfirm      = false;
+#ifdef REELVDR
+  _help                = NULL;
+  _info                = NULL;
+  _iconNumber          = NULL;
+  _setupLink           = NULL;
+#endif /* REELVDR */
+}
+
+
+cSubMenuNode::~ cSubMenuNode()
+{
+  if (_name != NULL)
+     free((void*)_name);
+  if (_command != NULL)
+     free((void*)_command);
+  if (_title != NULL)
+     free((void*)_title);
+  if (_pluginMainMenuEntry != NULL)
+     free((void*)_pluginMainMenuEntry);
+#ifdef REELVDR
+  if (_help != NULL)
+     free((void*)_help);
+  if (_info != NULL)
+     free((void*)_info);
+  if (_iconNumber != NULL)
+     free((void*)_iconNumber);
+  if (_setupLink != NULL)
+     free((void*)_setupLink);
+#endif /* REELVDR */
+}
+
+#ifdef REELVDR
+bool cSubMenuNode::IncludeXml(const char *includeXML)
+{
+    TiXmlDocument  xmlDoc = TiXmlDocument(includeXML);
+    TiXmlElement *xml;
+    bool  ok =true;
+
+    if ((ok=xmlDoc.LoadFile()))
+    { 
+        if ((xml = xmlDoc.FirstChildElement()) != NULL)
+        {
+            do
+            {
+                if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT)
+                {     
+                    int type = IsType(xml->Value());
+
+                    if ((type == PLUGIN) || (type == COMMAND) || (type == MENU && xml->NoChildren() == false))
+                    {
+                        cSubMenuNode *node = new cSubMenuNode(xml, _level+1, &_subMenus, _currentMenu);
+                        _subMenus.Add(node);
+                    }
+                    else if(type == INCLUDE)
+                    {
+                        char *includeXML;
+                        asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
+                        if(strchr(includeXML, '*'))
+                        {
+                            std::vector<char*> includeXMLs;
+                            getfiles(includeXML, &includeXMLs);
+                            for(unsigned int i=0; i<includeXMLs.size(); ++i)
+                                IncludeXml(includeXMLs.at(i));
+                        }
+                        else
+                            IncludeXml(includeXML);
+                        free(includeXML);
+                    }
+                }
+                else
+                    throw "Invalid XML Node";
+            }
+            while(ok==true && (xml=xml->NextSiblingElement()) !=NULL);
+        }
+    }
+    else
+    {
+        esyslog("ERROR: in %s : %s  Col=%d Row=%d\n", includeXML,
+                xmlDoc.ErrorDesc(),
+                xmlDoc.ErrorCol(),
+                xmlDoc.ErrorRow());
+
+        ok=false;
+    }
+
+    return ok;
+}
+
+void cSubMenuNode::SetSetupLink(const char *link)
+{
+  if (_setupLink) free (_setupLink);
+
+  if (link && strlen(link) > 0 )  
+  {
+    _setupLink = strdup(link);
+  }
+  else 
+  {
+    _setupLink = NULL;
+  }
+}
+
+void cSubMenuNode::SetPlugin(const char *link)
+{
+  bool found = false;
+   
+  for (unsigned int pIndex = 0; ; pIndex++)
+  {
+     cPlugin *p = cPluginManager::GetPlugin(pIndex);
+     if (p)
+     {
+        if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL)
+        {
+           if (strcmp("setup",p->Name()) == 0 && p->MainMenuEntry() != NULL)
+           {
+              if (link) 
+              {
+                SetPluginMainMenuEntry(link);
+                _pluginIndex = pIndex;
+                found=true;
+                break;
+              }
+           }
+                 
+           SetPluginMainMenuEntry(p->MainMenuEntry());
+           _pluginIndex = pIndex;
+           found=true;
+           break;
+        }
+    }
+    else
+    {
+      break;
+    } 
+  }
+
+  if (!found)
+  {
+     _type=UNDEFINED;
+  }
+}
+
+void cSubMenuNode::SetHelp(const char *help)
+{
+  if (_help) free ((void*)_help);
+  help? _help = strdup(help):help = NULL;
+}
+
+void cSubMenuNode::SetInfo(const char *info)
+{
+  if (_info) free((void*)_info);
+
+  //info? _info = strdup(info):info = NULL;
+  if (info)
+      _info = strdup(tr(info));
+  else _info = NULL;
+}
+
+void cSubMenuNode::SetIconNumber(const char*icon)
+{
+    if (_iconNumber) 
+    {
+        free((void*)_iconNumber); 
+        _iconNumber = NULL;
+    }
+    if (icon) _iconNumber = strdup(icon);
+}
+
+#else
+
+/**
+ *
+ */
+void cSubMenuNode::SetPlugin()
+{
+  bool found = false;
+  for (int i = 0; ; i++) {
+      cPlugin *p = cPluginManager::GetPlugin(i);
+      if (p) {
+         if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL) {
+            SetPluginMainMenuEntry(p->MainMenuEntry());
+            _pluginIndex = i;
+            found = true;
+            break;
+            }
+         }
+      else
+         break;
+      }
+
+      if (!found)
+         _type = UNDEFINED;
+}
+#endif /* REELVDR */
+
+
+bool cSubMenuNode::SaveXml(TiXmlElement *root)
+{
+  bool ok = true;
+
+  if (root!=NULL) {
+     TiXmlElement *e = NULL;
+     switch(_type) {
+        case SYSTEM:
+           e = new TiXmlElement(TAG_SYSTEM);
+           e->SetAttribute("name", GetName());
+           break;
+        case COMMAND:
+           e = new TiXmlElement(TAG_COMMAND);
+           e->SetAttribute("name", GetName());
+           e->SetAttribute("execute", GetCommand());
+           if (_commandConfirm)
+              e->SetAttribute("confirm", TRUE_STR);
+           break;
+        case THREAD:
+           e = new TiXmlElement(TAG_THREAD);
+           e->SetAttribute("name", GetName());
+           e->SetAttribute("execute", GetCommand());
+           if (_commandConfirm)
+              e->SetAttribute("confirm", TRUE_STR);
+           break;
+        case PLUGIN:
+           e = new TiXmlElement(TAG_PLUGIN);
+           e->SetAttribute("name", GetName());
+           if (GetCustomTitle() != NULL && strcmp(GetCustomTitle(), "") != 0)
+              e->SetAttribute("title", GetCustomTitle());
+           break;
+        case MENU:
+           e = new TiXmlElement(TAG_MENU);
+           e->SetAttribute("name", GetName());
+           break;
+        case UNDEFINED:
+        default:
+           ok = false;
+           break;
+        }
+        if (ok) {
+           root->LinkEndChild(e);
+           if (HasSubMenus())
+              for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+                  node->SaveXml(e);
+           }
+     }
+
+  return(ok);
+}
+
+
+cSubMenuNode::Type cSubMenuNode::IsType(const char *name)
+{
+  Type type = UNDEFINED;
+
+  if (strcmp(name ,TAG_SYSTEM) == 0)
+     type = cSubMenuNode::SYSTEM;
+  else if (strcmp(name ,TAG_PLUGIN) == 0)
+     type = cSubMenuNode::PLUGIN;
+  else if (strcmp(name ,TAG_COMMAND) == 0)
+     type = cSubMenuNode::COMMAND;
+  else if (strcmp(name ,TAG_THREAD) == 0)
+     type = cSubMenuNode::THREAD;
+  else if (strcmp(name ,TAG_MENU) == 0)
+     type = cSubMenuNode::MENU;
+#ifdef REELVDR
+  else if (strcmp(name ,TAG_INCLUDE) == 0)
+    type =  cSubMenuNode::INCLUDE;
+#endif /* REELVDR */
+
+  return(type);
+}
+
+void cSubMenuNode::SetType(const char *name)
+{
+   _type = IsType(name);
+}
+
+void cSubMenuNode::SetType(enum Type type)
+{
+  _type = type;
+}
+
+
+cSubMenuNode::Type cSubMenuNode::GetType()
+{
+  return(_type);
+}
+
+const char *cSubMenuNode::GetTypeAsString()
+{
+  const char *str=NULL;
+  switch(_type) {
+     case SYSTEM:
+        str = TAG_SYSTEM;
+        break;
+     case COMMAND:
+        str = TAG_COMMAND;
+        break;
+     case THREAD:
+        str = TAG_THREAD;
+        break;
+     case PLUGIN:
+        str = TAG_PLUGIN;
+        break;
+     case MENU:
+        str = TAG_MENU;
+        break;
+     case UNDEFINED:
+        str = TAG_UNDEFINED;
+     default:
+        break;
+    }
+
+  return(str);
+}
+
+void cSubMenuNode::SetCommand(const char *command)
+{
+  if (_command != NULL)
+     free((void*)_command);
+
+  if (command != NULL)
+     _command = strdup(command);
+  else
+     _command = NULL;
+}
+
+const char *cSubMenuNode::GetCommand()
+{
+  return(_command);
+}
+
+bool cSubMenuNode::CommandConfirm()
+{
+  return(_commandConfirm);
+}
+
+void cSubMenuNode::SetCommandConfirm(int val)
+{
+  if (val == 1)
+     _commandConfirm = true;
+  else
+     _commandConfirm = false;
+}
+
+void cSubMenuNode::SetCustomTitle(const char *title)
+{
+  if (_title != NULL)
+     free((void*)_title);
+
+  if (title != NULL)
+     _title = strdup(title);
+  else
+     _title = NULL;
+}
+
+const char *cSubMenuNode::GetCustomTitle()
+{
+  return(_title);
+}
+
+void cSubMenuNode::SetName(const char *name)
+{
+  if (_name)
+     free ((void*)_name);
+
+  if (name != NULL)
+     _name = strdup(name);
+  else
+     _name = NULL;
+}
+
+const char *cSubMenuNode::GetName()
+{
+  return(_name);
+}
+
+int cSubMenuNode::GetLevel()
+{
+  return(_level);
+}
+
+void cSubMenuNode::SetLevel(int level)
+{
+  _level = level;
+  if (HasSubMenus()) { //Adjust Levels of Subnodesnode
+     for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+         node->SetLevel(level+1);
+     }
+}
+
+int cSubMenuNode::GetPluginIndex()
+{
+  return(_pluginIndex);
+}
+
+void cSubMenuNode::SetPluginIndex(int index)
+{
+  _pluginIndex = index;
+}
+
+void cSubMenuNode::SetPluginMainMenuEntry(const char *mainMenuEntry)
+{
+  if (_pluginMainMenuEntry != NULL)
+     free((void*)_pluginMainMenuEntry);
+
+  if (_title != NULL && strcmp(_title, "") != 0)
+     _pluginMainMenuEntry = strdup(_title);
+  else if (mainMenuEntry != NULL)
+     _pluginMainMenuEntry = strdup(mainMenuEntry);
+  else
+     _pluginMainMenuEntry = NULL;
+}
+
+const char *cSubMenuNode::GetPluginMainMenuEntry()
+{
+  return(_pluginMainMenuEntry);
+}
+
+
+cSubMenuNodes *cSubMenuNode::GetParentMenu()
+{
+  return(_parentMenu);
+}
+
+void cSubMenuNode::SetParentMenu(cSubMenuNodes *parent)
+{
+  _parentMenu = parent;
+}
+
+cSubMenuNodes *cSubMenuNode::GetCurrentMenu()
+{
+  return(_currentMenu);
+}
+
+void cSubMenuNode::SetCurrentMenu(cSubMenuNodes *current)
+{
+  _currentMenu = current;
+}
+
+
+cSubMenuNodes *cSubMenuNode::GetSubMenus()
+{
+  return(&_subMenus);
+}
+
+bool cSubMenuNode::HasSubMenus()
+{
+  if (_subMenus.Count() > 0)
+     return(true);
+  else
+     return(false);
+}
+
+
+void cSubMenuNode::Print(int index)
+{
+  for (int i = 0; i < index; i++)
+      printf(" ");
+
+  printf("Name=%s Type=%s Level=%d", _name, GetTypeAsString(), _level);
+  if (_type == COMMAND || _type == THREAD)
+     printf(" Command=%s", _command);
+  else if (_type == PLUGIN && _title != NULL)
+     printf(" Title=%s", _title);
+  printf("\n");
+
+  for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+      node->Print(index+4);
+}
+
+
+//################################################################################
+//#
+//################################################################################
+cSubMenu::cSubMenu()
+{
+  _commandResult         = NULL;
+  _currentMenuTree       = &_menuTree;
+  _currentParentMenuTree = NULL;
+  _currentParentIndex    = -1;
+  _nodeArray             = NULL;
+  _nrNodes               = 0;
+}
+
+
+cSubMenu::~cSubMenu()
+{
+  if (_commandResult)
+     free(_commandResult);
+  if (_nodeArray)
+     free(_nodeArray);
+  _nrNodes = 0;
+}
+
+
+bool cSubMenu::LoadXml(cString fname)
+{
+  TiXmlDocument  xmlDoc = TiXmlDocument(fname);
+  TiXmlElement  *root   = NULL;
+  cSubMenuNode  *node   = NULL;
+
+  bool  ok = true;
+  // Clear previously loaded Menu
+  _menuTree.Clear();
+  _fname = fname;
+
+  if ((ok = xmlDoc.LoadFile())) {
+     if ((root = xmlDoc.FirstChildElement("menus")) != NULL) {
+        cString tmp = root->Attribute("suffix");
+        if (*tmp)
+           _menuSuffix = tmp;
+        else
+           _menuSuffix = cString::sprintf(" ");
+
+        if ((root = root->FirstChildElement()) != NULL) {
+           do {
+              try {
+                 node = new cSubMenuNode(root, 0,  &_menuTree, NULL);
+#ifdef REELVDR
+                 const char* tmp_name = root->Attribute("name");
+                 //printf("%s : %i \n",tmp_name, node->SubMenuSize());
+                 if (tmp_name && strcmp("Additional Software",tmp_name) == 0 /*no translation of "Additional Software" here*/
+                              && node->SubMenuSize() <= 0) // empty submenu;
+                 // no additional plugins installed
+                 {
+                   delete node;
+                   node = NULL;
+                 }
+                 else
+#endif /* REELVDR */
+                 _menuTree.Add(node);
+                 }
+              catch (char *message) {
+                 esyslog("ERROR: while decoding XML Node");
+                 ok = false;
+                 }
+              } while (ok == true && (root = root->NextSiblingElement()) != NULL);
+#ifndef REELVDR
+           addMissingPlugins();
+#endif /* REELVDR */
+           removeUndefinedNodes();
+           }
+        }
+     else {
+        esyslog("ERROR: in %s, missing Tag <menus>\n", *fname);
+        ok = false;
+        }
+     }
+  else {
+     esyslog("ERROR: in %s : %s  Col=%d Row=%d\n",
+            *fname,
+            xmlDoc.ErrorDesc(),
+            xmlDoc.ErrorCol(),
+            xmlDoc.ErrorRow());
+     ok = false;
+     }
+
+  return(ok);
+}
+
+
+bool cSubMenu::SaveXml()
+{
+  return(SaveXml(_fname));
+}
+
+
+bool cSubMenu::SaveXml(cString fname)
+{
+  bool ok = true;
+
+  if (*_fname) {
+     TiXmlDocument xml = TiXmlDocument(fname);
+     TiXmlComment  comment;
+     comment.SetValue("\n\
+-    VDR Menu-Configuration File\n\
+-\n\
+-\n\
+-   Example:\n\
+-\n\
+ <menus>\n\
+    <system name=\"Schedule\" />\n\
+    <system name=\"Channels\" />\n\
+    <system name=\"Timers\" />\n\
+    <system name=\"Recordings\" />\n\
+    <menu name=\"System\">\n\
+        <system name=\"Setup\" />\n\
+        <system name=\"Commands\" />\n\
+        <plugin name=\"setup\" title=\"My Setup\" />\n\
+        <command name=\"myCommand1\" execute=\"/usr/bin/mycommand1\" />\n\
+        <command name=\"myCommand2\" execute=\"/usr/bin/mycommand2\" confirm=\"yes\" />\n\
+        <thread name=\"myCommand3\" execute=\"/usr/bin/mycommand3\" confirm=\"yes\" />\n\
+        <plugin name=\"epgsearch\" title=\"myProgram\" />\n\
+        <menu name=\"mySubSubMenu\">\n\
+            ...\n\
+        </menu>\n\
+    </menu>\n\
+     <menu name=\"Suche\">\n\
+        <plugin name=\"epgsearch\" />\n\
+        ...\n\
+    </menu>\n\
+ </menus>\n\
+");
+
+     TiXmlElement root("menus");
+     root.SetAttribute("suffix", _menuSuffix);
+     for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
+         node->SaveXml(&root);
+
+         if (xml.InsertEndChild(comment) != NULL && xml.InsertEndChild(root) != NULL)
+            ok = xml.SaveFile(fname);
+     }
+  else
+     ok = false;
+
+  return(ok);
+}
+
+
+cSubMenuNodes *cSubMenu::GetMenuTree()
+{
+  return(_currentMenuTree);
+}
+
+
+void cSubMenu::PrintMenuTree()
+{
+  for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
+      node->Print();
+}
+
+
+int cSubMenu::GetNrOfNodes()
+{
+  if (_nrNodes == 0) {
+     if ((_nrNodes = countNodes(&_menuTree)) > 0) {
+        _nodeArray = (cSubMenuNode**) malloc(sizeof(cSubMenuNode*)*_nrNodes);
+        int index = 0;
+        tree2Array(&_menuTree, index);
+        }
+     }
+
+  return(_nrNodes);
+}
+
+
+/**
+ * returns the specified node within the current menu
+ * @param index position in the current menu
+ * @return node or null if not found
+ */
+cSubMenuNode *cSubMenu::GetNode(int index)
+{
+  cSubMenuNode *node = NULL;
+  if (_currentMenuTree == NULL || (node=_currentMenuTree->Get(index)) == NULL)
+     esyslog("ERROR: illegal call of cSubMenu::GetNode(%d)", index);
+
+  return(node);
+}
+
+
+/**
+ * Get the specified Node
+ * @param index specfies the absolut indes in the list of all nodes
+ * @return node or NULL if not found
+ */
+cSubMenuNode *cSubMenu::GetAbsNode(int index)
+{
+  cSubMenuNode *node = NULL;
+  GetNrOfNodes();
+  if (_nrNodes > 0 && index >= 0 && index < _nrNodes)
+     node = _nodeArray[index];
+
+  return(node);
+}
+
+
+#ifdef USE_PINPLUGIN
+bool cSubMenu::Down(cSubMenuNode *node, int currentIndex)
+#else
+bool cSubMenu::Down(int index)
+#endif /* PINPLUGIN */
+{
+  bool ok = true;
+  if (_currentMenuTree != NULL && node && node->GetType() == cSubMenuNode::MENU) {
+     _currentParentMenuTree = _currentMenuTree;
+     _currentParentIndex = currentIndex;
+     _currentMenuTree = node->GetSubMenus();
+     }
+  else {
+     ok = false;
+#ifdef USE_PINPLUGIN
+     esyslog("ERROR: illegal call of cSubMenu::Down");
+#else
+     esyslog("ERROR: illegal call of cSubMenu::Down(%d)", index);
+#endif /* PINPLUGIN */
+     }
+
+  return(ok);
+}
+
+bool cSubMenu::Up(int *parentIndex)
+{
+  bool ok = true;
+
+  if (_currentMenuTree != NULL && parentIndex != NULL) {
+     cSubMenuNode *node = NULL;
+     *parentIndex = 0;
+     if (_currentParentIndex >= 0)
+        *parentIndex = _currentParentIndex;
+
+     _currentMenuTree = _currentParentMenuTree;
+     if (_currentMenuTree != NULL)
+        _currentParentMenuTree = _currentMenuTree->Get(0)->GetParentMenu();
+     else
+        ok = false;
+     }
+  else {
+     ok = false;
+     esyslog("ERROR: illegal call of cSubMenu::Up()");
+     }
+
+  return(ok);
+}
+
+const char *cSubMenu::ExecuteCommand(const char *cmd)
+{
+  free(_commandResult);
+  _commandResult = NULL;
+
+  dsyslog("executing command '%s'", cmd);
+  FILE *p = popen(cmd, "r");
+  if (p) {
+     int l = 0;
+     int c;
+     while ((c = fgetc(p)) != EOF) {
+           if (l % 20 == 0)
+              _commandResult = (char *)realloc(_commandResult, l + 21);
+           _commandResult[l++] = c;
+           }
+     if (_commandResult)
+        _commandResult[l] = 0;
+     pclose(p);
+     }
+  else
+     esyslog("ERROR: can't open pipe for command '%s'", cmd);
+
+  return _commandResult;
+}
+
+/**
+ * Move Menu Entry to new Position
+ * @param index  index of menu entry to move
+ * @param toIndex index of destination
+ * @param where After ore before the destination index
+ */
+void cSubMenu::MoveMenu(int index, int toIndex, enum Where where)
+{
+  if (index < 0 || index > _nrNodes || // invalid index is ignored
+     toIndex < 0 || toIndex > _nrNodes || index == toIndex)
+     return;
+
+  cSubMenuNode *srcNode  = GetAbsNode(index);
+  cSubMenuNode *destNode = GetAbsNode(toIndex);
+
+  if (where == cSubMenu::INTO && destNode->GetType() != cSubMenuNode::MENU)
+     return;
+
+  if (where == cSubMenu::INTO) {
+     if (destNode->GetType() == cSubMenuNode::MENU) {
+        srcNode->GetCurrentMenu()->Del(srcNode, false);
+        srcNode->SetLevel(destNode->GetLevel()+1);
+        srcNode->SetParentMenu(destNode->GetCurrentMenu());
+        srcNode->SetCurrentMenu(destNode->GetSubMenus());
+
+        destNode->GetSubMenus()->Add(srcNode);
+        reloadNodeArray();
+        }
+     }
+  else {
+     srcNode->GetCurrentMenu()->Del(srcNode, false);
+     srcNode->SetLevel(destNode->GetLevel());
+     srcNode->SetParentMenu(destNode->GetParentMenu());
+     srcNode->SetCurrentMenu(destNode->GetCurrentMenu());
+
+     if (where == cSubMenu::BEHIND) {
+        destNode->GetCurrentMenu()->Add(srcNode, GetAbsNode(toIndex));
+        reloadNodeArray();
+        }
+     else {
+        destNode->GetCurrentMenu()->Ins(srcNode, GetAbsNode(toIndex));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * Create a new Menu Entry
+ * @param index index of destination
+ * @param menuTitle  Titel of new Menu entry
+ */
+void cSubMenu::CreateMenu(int index, const char *menuTitle)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(menuTitle);
+        newNode->SetType(cSubMenuNode::MENU);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * delete the specified entry, or subtree if the specified entry is a menu
+ * @param index destion index
+ */
+void cSubMenu::DeleteMenu(int index)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode = GetAbsNode(index);
+     srcNode->GetCurrentMenu()->Del(srcNode, true);
+     reloadNodeArray();
+     }
+}
+
+
+// Private Methods
+
+int cSubMenu::countNodes(cSubMenuNodes *tree)
+{
+  int count = 0;
+  if (tree != NULL) {
+     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
+         count++;
+         if (node->HasSubMenus())
+            count += countNodes(node->GetSubMenus());
+         }
+     }
+  return(count);
+}
+
+
+void cSubMenu::tree2Array(cSubMenuNodes *tree, int &index)
+{
+  if (tree != NULL) {
+     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
+         _nodeArray[index++]=node;
+         if (node->HasSubMenus())
+            tree2Array(node->GetSubMenus(), index);
+         }
+     }
+
+}
+
+bool cSubMenu::IsPluginInMenu(const char *name)
+{
+  bool found = false;
+  for (int i = 0; i < _nrNodes && found == false; i++) {
+      cSubMenuNode *node = GetAbsNode(i);
+      if (node != NULL && node->GetType() == cSubMenuNode::PLUGIN && strcmp(name, node->GetName()) == 0)
+         found = true;
+      }
+  return(found);
+}
+
+/**
+ * Adds the given plugin to the Menu-Tree if not allready in List
+ * @param name specifies the name of the plugin
+ */
+void cSubMenu::AddPlugin(const char *name)
+{
+  if (! IsPluginInMenu(name)) {
+     cSubMenuNode *node = new  cSubMenuNode(&_menuTree, NULL);
+     node->SetName(name);
+     node->SetType("plugin");
+     node->SetPlugin();
+     _menuTree.Add(node);
+     }
+}
+
+void cSubMenu::addMissingPlugins()
+{
+  _nrNodes = GetNrOfNodes();
+  for (int i = 0; ; i++) {
+      cPlugin *p = cPluginManager::GetPlugin(i);
+      if (p)
+         AddPlugin(p->Name());
+      else
+         break;
+      }
+  reloadNodeArray();
+}
+
+/**
+ * Adds the given command to the Menu-Tree
+ * @param name specifies the name of the command
+ */
+void cSubMenu::CreateCommand(int index, const char *name, const char *execute, int confirm)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(name);
+        newNode->SetType("command");
+        newNode->SetCommand(execute);
+        newNode->SetCommandConfirm(confirm);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+void cSubMenu::CreateThread(int index, const char *name, const char *execute, int confirm)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(name);
+        newNode->SetType("thread");
+        newNode->SetCommand(execute);
+        newNode->SetCommandConfirm(confirm);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * reloads the internal Array of Nodes
+ */
+void cSubMenu::reloadNodeArray()
+{
+  if (_nrNodes > 0)
+     free(_nodeArray);
+  _nodeArray = NULL;
+  _nrNodes = 0;
+  _nrNodes = GetNrOfNodes();
+}
+
+/**
+ * remove Undefined Nodes
+ */
+void cSubMenu::removeUndefinedNodes()
+{
+  bool remove = false;
+
+  reloadNodeArray();
+  for (int i = 0; i < _nrNodes; i++) {
+      cSubMenuNode *node = GetAbsNode(i);
+      if (node != NULL && node->GetType() == cSubMenuNode::UNDEFINED) {
+         cSubMenuNodes *pMenu = node->GetCurrentMenu();
+         pMenu->Del(node, true);
+         remove = true;
+         }
+      }
+  if (remove)
+     reloadNodeArray();
+}
+
+
+/**
+* Retrieves the Menutitel of the parent Menu
+*/
+const char *cSubMenu::GetParentMenuTitel()
+{
+  const char *result = "";
+
+  if (_currentMenuTree != NULL && _currentParentMenuTree != NULL) {
+     cSubMenuNode *node = NULL;
+     for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
+         if (_currentMenuTree == node->GetSubMenus()) {
+            result = node->GetName();
+            break;
+            }
+         }
+     }
+
+  return(result);
+}
+
+#endif
diff -urN vdr-2.0.1/submenu.h vdr-2.0.1.reel/submenu.h
--- vdr-2.0.1/submenu.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/submenu.h	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,178 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Submenu
+ *
+ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004, 2005 by Ralf Dotzert
+ *
+ * modified for the VDR Extensions Patch by zulu @vdr-portal
+ ****************************************************************************/
+
+#ifndef SUBMENU_H
+#define SUBMENU_H
+
+#include "thread.h"
+#include "tools.h"
+#include <vector>
+#include <tinyxml/tinystr.h>
+#include <tinyxml/tinyxml.h>
+
+
+class cSubMenuNode;
+class cSubMenuNodes;
+class cSubMenu;
+
+
+class cSubMenuNodes : public cList<cSubMenuNode> {};
+
+// execute cmd thread
+class cExecCmdThread : public cThread {
+private:
+  cString ExecCmd;
+protected:
+  virtual void Action(void) {
+     if (system(ExecCmd) == 0)
+        esyslog("%s - finished", *ExecCmd);
+     delete(this);
+     };
+public:
+  cExecCmdThread(char *cmd) {
+     ExecCmd = cString::sprintf("%s", cmd);
+     }
+  cExecCmdThread(const char *cmd) {
+     ExecCmd = cString::sprintf("%s", cmd);
+     }
+  ~cExecCmdThread() {
+     };
+  };
+
+//################################################################################
+//# SubMenuNode
+//################################################################################
+class cSubMenuNode : public cListObject {
+public:
+#ifdef REELVDR
+  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU, INCLUDE };
+#else
+  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU };
+#endif /* REELVDR */
+  cSubMenuNode(TiXmlElement *xml, int level, cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
+  cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
+  ~cSubMenuNode();
+  bool SaveXml(TiXmlElement *root);
+  static cSubMenuNode::Type IsType(const char *name);
+  void  SetType(const char *name);
+  void  SetType(enum Type type);
+#ifdef REELVDR
+  int SubMenuSize(){return _subMenus.Count();}
+  bool IncludeXml(const char *includeXML);
+  void SetHelp(const char *Help);
+  const char *GetHelp() {return _help;};
+  void SetInfo(const char *Info);
+  const char *GetInfo() {return _info;};
+  void SetIconNumber(const char* iconNumber);
+  const char *GetIconNumber() {return _iconNumber;};
+  void SetSetupLink(const char*name);
+  const char *GetSetupLink() {return _setupLink;};
+  void  SetPlugin(const char *link=NULL);
+#else
+  void  SetPlugin();
+#endif /* REELVDR */
+  cSubMenuNode::Type GetType();
+  const char *GetTypeAsString();
+  void SetCommand(const char *command);
+  bool CommandConfirm();
+  void SetCommandConfirm(int val);
+  const char *GetCommand();
+  void SetCustomTitle(const char *title);
+  const char *GetCustomTitle();
+  void SetName(const char *name);
+  const char*GetName();
+  int  GetLevel();
+  void SetLevel(int level);
+  int  GetPluginIndex();
+  void SetPluginIndex(int index);
+  void SetPluginMainMenuEntry(const char *mainMenuEntry);
+  const char *GetPluginMainMenuEntry();
+  cSubMenuNodes *GetParentMenu();
+  void SetParentMenu(cSubMenuNodes *parent);
+  cSubMenuNodes *GetCurrentMenu();
+  void SetCurrentMenu(cSubMenuNodes *current);
+  cSubMenuNodes *GetSubMenus();
+  bool HasSubMenus();
+  void Print(int index = 0);
+private:
+  Type _type;
+  int _level;
+  // Plugin Variables
+  int _pluginIndex;
+  const char *_pluginMainMenuEntry;
+  // common
+  const char *_name;
+  const char *_command;
+  bool _commandConfirm;
+  const char *_title;
+#ifdef REELVDR
+  const char *_help;
+  const char *_info;
+  const char *_iconNumber;
+  char *_setupLink;
+#endif /* REELVDR */
+  cSubMenuNodes _subMenus;
+  cSubMenuNodes *_parentMenu;
+  cSubMenuNodes *_currentMenu;
+  void init();
+  };
+
+
+//################################################################################
+//# SubMenu Class
+//################################################################################
+class cSubMenu {
+public:
+  cSubMenu();
+  ~cSubMenu();
+  enum Where { BEFORE, BEHIND, INTO};
+  bool LoadXml(cString fname);
+  bool SaveXml(cString fname);
+  bool SaveXml();
+  cSubMenuNodes *GetMenuTree();
+  bool Up(int *ParentIndex);
+  bool Down(cSubMenuNode* node, int currentIndex);
+  int  GetNrOfNodes();
+  cSubMenuNode* GetAbsNode(int index);
+  cSubMenuNode* GetNode(int index);
+  void PrintMenuTree();
+  bool IsPluginInMenu(const char *name);
+  void AddPlugin(const char *name);
+  void CreateCommand(int index, const char *name, const char *execute, int confirm);
+  void CreateThread(int index, const char *name, const char *execute, int confirm);
+  const char *ExecuteCommand(const char *command);
+  void MoveMenu(int index, int toindex, enum Where);
+  void CreateMenu(int index, const char *menuTitle);
+  void DeleteMenu(int index);
+  cString GetMenuSuffix() { return _menuSuffix; }
+  void SetMenuSuffix(char *suffix) { _menuSuffix = suffix; }
+  bool isTopMenu() { return (_currentParentMenuTree == NULL); }
+  const char *GetParentMenuTitel();
+private:
+  cSubMenuNodes _menuTree;
+  cSubMenuNodes *_currentMenuTree;
+  cSubMenuNodes *_currentParentMenuTree;
+  int _currentParentIndex;
+  cString _fname;
+  char *_commandResult;
+  int _nrNodes;
+  cSubMenuNode **_nodeArray;
+  cString _menuSuffix;
+  int countNodes(cSubMenuNodes *tree);
+  void tree2Array(cSubMenuNodes *tree, int &index);
+  void addMissingPlugins();
+  void reloadNodeArray();
+  void removeUndefinedNodes();
+  };
+
+#endif //__SUBMENU_H
diff -urN vdr-2.0.1/svdrp.c vdr-2.0.1.reel/svdrp.c
--- vdr-2.0.1/svdrp.c	2013-02-17 14:18:01.000000000 +0100
+++ vdr-2.0.1.reel/svdrp.c	2013-05-09 18:10:01.607874320 +0200
@@ -31,6 +31,7 @@
 #include "cutter.h"
 #include "device.h"
 #include "eitscan.h"
+#include "filetransfer.h"
 #include "keys.h"
 #include "menu.h"
 #include "plugin.h"
@@ -193,6 +194,11 @@
   "    After a CLRE command, no further EPG processing is done for 10\n"
   "    seconds, so that data sent with subsequent PUTE commands doesn't\n"
   "    interfere with data from the broadcasters.",
+  "CPYR <number> <new name>\n"
+  "    Copy the recording with the given number. Before a recording can be\n"
+  "    copied, an LSTR command must have been executed in order to retrieve\n"
+  "    the recording numbers. The numbers don't change during subsequent CPYR\n"
+  "    commands.",
   "DELC <number>\n"
   "    Delete channel.",
   "DELR <number>\n"
@@ -258,6 +264,11 @@
   "    used to easily activate or deactivate a timer.",
   "MOVC <number> <to>\n"
   "    Move a channel to a new position.",
+  "MOVR <number> <new name>\n"
+  "    Move the recording with the given number. Before a recording can be\n"
+  "    moved, an LSTR command must have been executed in order to retrieve\n"
+  "    the recording numbers. The numbers don't change during subsequent MOVR\n"
+  "    commands.",
   "NEWC <settings>\n"
   "    Create a new channel. Settings must be in the same format as returned\n"
   "    by the LSTC command.",
@@ -612,6 +623,32 @@
      }
 }
 
+void cSVDRP::CmdCPYR(const char *Option)
+{
+  if (*Option) {
+     char *tail;
+     int n = strtol(Option, &tail, 10);
+     cRecording *recording = Recordings.Get(n - 1);
+     if (recording && tail && tail != Option) {
+        char *oldName = strdup(recording->Name());
+        tail = skipspace(tail);
+        if (!cFileTransfer::Active()) {
+           if (cFileTransfer::Start(recording, tail, true))
+              Reply(250, "Copying recording \"%s\" to \"%s\"", oldName, tail);
+           else
+              Reply(554, "Can't start file transfer");
+           }
+        else
+           Reply(554, "File transfer already active");
+        free(oldName);
+        }
+     else
+        Reply(550, "Recording \"%d\" not found%s", n, Recordings.Count() ? "" : " (use LSTR before copying)");
+     }
+  else
+     Reply(501, "Invalid Option \"%s\"", Option);
+}
+
 void cSVDRP::CmdDELC(const char *Option)
 {
   if (*Option) {
@@ -1320,6 +1357,32 @@
      Reply(501, "Missing channel number");
 }
 
+void cSVDRP::CmdMOVR(const char *Option)
+{
+  if (*Option) {
+     char *tail;
+     int n = strtol(Option, &tail, 10);
+     cRecording *recording = Recordings.Get(n - 1);
+     if (recording && tail && tail != Option) {
+        char *oldName = strdup(recording->Name());
+        tail = skipspace(tail);
+        if (!cFileTransfer::Active()) {
+           if (cFileTransfer::Start(recording, tail))
+              Reply(250, "Moving recording \"%s\" to \"%s\"", oldName, tail);
+           else
+              Reply(554, "Can't start file transfer");
+           }
+        else
+           Reply(554, "File transfer already active");
+        free(oldName);
+        }
+     else
+        Reply(550, "Recording \"%d\" not found%s", n, Recordings.Count() ? "" : " (use LSTR before moving)");
+     }
+  else
+     Reply(501, "Invalid Option \"%s\"", Option);
+}
+
 void cSVDRP::CmdNEWC(const char *Option)
 {
   if (*Option) {
@@ -1644,6 +1707,7 @@
   s = skipspace(s);
   if      (CMD("CHAN"))  CmdCHAN(s);
   else if (CMD("CLRE"))  CmdCLRE(s);
+  else if (CMD("CPYR"))  CmdCPYR(s);
   else if (CMD("DELC"))  CmdDELC(s);
   else if (CMD("DELR"))  CmdDELR(s);
   else if (CMD("DELT"))  CmdDELT(s);
@@ -1659,6 +1723,7 @@
   else if (CMD("MODC"))  CmdMODC(s);
   else if (CMD("MODT"))  CmdMODT(s);
   else if (CMD("MOVC"))  CmdMOVC(s);
+  else if (CMD("MOVR"))  CmdMOVR(s);
   else if (CMD("NEWC"))  CmdNEWC(s);
   else if (CMD("NEWT"))  CmdNEWT(s);
   else if (CMD("NEXT"))  CmdNEXT(s);
diff -urN vdr-2.0.1/svdrp.h vdr-2.0.1.reel/svdrp.h
--- vdr-2.0.1/svdrp.h	2012-04-26 12:30:06.000000000 +0200
+++ vdr-2.0.1.reel/svdrp.h	2013-05-09 18:10:01.607874320 +0200
@@ -56,6 +56,7 @@
   void PrintHelpTopics(const char **hp);
   void CmdCHAN(const char *Option);
   void CmdCLRE(const char *Option);
+  void CmdCPYR(const char *Option);
   void CmdDELC(const char *Option);
   void CmdDELR(const char *Option);
   void CmdDELT(const char *Option);
@@ -71,6 +72,7 @@
   void CmdMODC(const char *Option);
   void CmdMODT(const char *Option);
   void CmdMOVC(const char *Option);
+  void CmdMOVR(const char *Option);
   void CmdNEWC(const char *Option);
   void CmdNEWT(const char *Option);
   void CmdNEXT(const char *Option);
diff -urN vdr-2.0.1/sysconfig_vdr.c vdr-2.0.1.reel/sysconfig_vdr.c
--- vdr-2.0.1/sysconfig_vdr.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/sysconfig_vdr.c	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,297 @@
+#ifdef REELVDR
+/****************************************************************************
+ * DESCRIPTION:
+ *             Handles sysconfig File
+ *
+ * $Id: sysconfig.cpp,v 1.4 2005/10/03 14:05:20 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert
+ ****************************************************************************/
+
+#include <map>
+#include <string>
+#include <vector>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include "config.h"
+#include "debug.h"
+//#include "plugin.h"
+#include "sysconfig_vdr.h"
+//#include "util.h"
+
+using std::pair;
+using std::map;
+using std::string;
+using std::vector;
+
+#if VDRVERSNUM >= 10716
+cSysConfig_vdr* cSysConfig_vdr::instance_ = NULL;
+#endif
+
+#define MAXLENGTH 256
+
+// ----- class cSysConfig_vdr ------------------------------------------------------
+
+cSysConfig_vdr::cSysConfig_vdr()
+{
+}
+
+cSysConfig_vdr &cSysConfig_vdr::GetInstance()
+{
+    if (!instance_) {
+        Create();
+        
+        // load the sysconfig file
+        instance_->Reload();
+    }
+    return *instance_;
+}
+
+void cSysConfig_vdr::Create()
+{
+    if (!instance_)
+        instance_ = new cSysConfig_vdr;
+}
+
+void cSysConfig_vdr::Destroy()
+{
+    if (instance_)
+    delete instance_;
+    instance_ = NULL;
+}
+
+const char * cSysConfig_vdr::FileName() const
+{
+    return fileName_.c_str();
+}
+
+void cSysConfig_vdr::AddVariable(const char *key, char *value)
+{
+    if (key)
+       sysMap_.insert(std::map < std::string, char *>::value_type(key, value));
+}
+
+void cSysConfig_vdr::SetVariable(const char *key, const char *value)
+{
+    //dsyslog(DBG_PREFIX " cSysConfig_vdr::SetVariable@%s: %s ",key ,value);
+    if (!key) return;
+    
+    if (sysMap_[key]) 
+    {
+       free (sysMap_[key]);
+       sysMap_[key] = NULL;
+    }
+    
+    if (value)
+        sysMap_[key] = strdup(value);
+}
+
+const char *cSysConfig_vdr::GetVariable(const char *key) const
+{
+    if (!key) return NULL;
+    
+    mapConstIter_t iter = sysMap_.find(key);
+
+    if (iter != sysMap_.end())
+        return iter->second;
+
+    //printf (" cSysConfig_vdr::GetVariable(%s) not found. \n", key);
+    return NULL;
+}
+
+
+cSysConfig_vdr::~cSysConfig_vdr()
+{
+    for (mapConstIter_t iter = sysMap_.begin(); iter != sysMap_.end(); ++iter)
+    {
+        if (iter->second) free(iter->second);
+    }
+}
+
+bool cSysConfig_vdr::Reload()
+{
+    return Load(SYSCONFIGFNAME);
+}
+
+
+/**
+ * @brief cSysConfig_vdr::SetVariable
+ * @param key
+ * @param value : New value for 
+ * @param changed : increment 'changed' if sysconfig was modified
+ *
+ *---------------------------------------------------
+ *  prev. Value      Given Value          changed?
+ *---------------------------------------------------
+ *      NULL           NULL                 0
+ *      NULL           "..."                1
+ *      "..."           NULL                1
+ *      "..."          "..."              strcmp to find if they are the same
+ */
+void cSysConfig_vdr::SetVariable(const char *key, const char *value, int& changed)
+{
+    if(!key)
+        return;
+    
+    // previous value for 'key'
+    char* prevValue = sysMap_[key];
+    
+    /// No change to sysconfig ?
+    // given and prev. 'values' both are NULL OR both are the same non-NULL string
+    if ( (!prevValue && !value) 
+         || (prevValue && value && strcmp(prevValue, value) == 0) )
+        return;
+
+    // discard old value for 'key'    
+    if (prevValue) 
+    {
+        free(prevValue);
+        sysMap_[key] = NULL;
+    } // if
+    
+    // new 'value' for 'key'
+    if (value)
+        sysMap_[key] = strdup(value);
+    // else sysMap_[key] remains NULL
+    
+    //sysconfig has changed
+    changed++;
+}
+
+
+bool
+cSysConfig_vdr::Load(const char *fname)
+{
+    if (!fname) {
+        esyslog("(%s:%d) sysconfig filename cannot be null", __FILE__, __LINE__);
+        return false;
+    }
+    
+    int count = 0;
+    const char *line;
+
+    int fp = open(fname, O_RDONLY);
+
+    // discard the old values in sysMap_ and load the new values from
+    // given file.
+    // AddLine() uses std::map::insert() which when a key is already available
+    // does *NOT* change the corresponding value. So, first discard map
+    // to get the latest key,value pairs from the given file
+    sysMap_.clear();
+
+    if (fp)
+    {
+        while ((line = ReadLine(fp)) != NULL)
+        {
+            AddLine(line);
+            delete[]line;
+            count++;
+        }
+        close(fp);
+        
+        fileName_ = fname;
+    } 
+    else 
+    {
+        esyslog("(%s:%d) cannot open sysconfig file '%s'", __FILE__, __LINE__, fname);
+        return false;
+    }
+    
+    return true;
+}
+
+
+/**
+ * Save cSysConfig_vdr file
+ * @return true on success
+ */
+bool
+cSysConfig_vdr::Save()
+{
+    FILE *fp = fopen(fileName_.c_str(), "w");
+    if (!fp)
+    {
+        DLOG("%s: Could not write file: %s, errno=%d\n", ERR,
+             fileName_.c_str(), errno);
+        return false;
+    }
+
+    fprintf(fp, "#\n"
+            "# Generated by Setup-Plugin, \n"
+            "# (c) 2005 by Ralf Dotzert and MiniVDR.de\n"
+            "# (c) 2006-2012 by Reel-Multimedia http://www.reel-multimedia.com\n" "#\n\n");
+
+    for (mapConstIter_t iter = sysMap_.begin(); iter != sysMap_.end(); ++iter)
+    {
+        if (!iter->first.empty() && iter->second != NULL)
+        fprintf(fp, "%s=\"%s\"\n", iter->first.c_str(), iter->second);
+    }
+    fclose(fp);
+
+    CopyToTftpRoot(fileName_.c_str());
+
+    return true;
+}
+
+/**
+ * read one line from opened file
+ * @param fp opened filepointer
+ * @return null if EOF or allocated character String holding one line
+ */
+const char *cSysConfig_vdr::ReadLine(int fd)
+{
+    char c;
+    char buf[1024];
+    int i = 0;
+    int maxLen = static_cast < int >(sizeof(buf)) - 1;
+    char *line = NULL;
+    while (read(fd, &c, 1))
+    {
+        if (c == '\n' || i == maxLen)
+        {
+            line = new char[i + 1];
+            strncpy(line, buf, i);
+            line[i] = '\0';
+            //dsyslog (DBG " cSysConfig_vdr readline %s ",line);
+            return line;
+        }
+        else
+            buf[i++] = c;
+    }
+    return line;
+}
+
+/**
+ * Add the given line from sysconfig file an split it in Name an Variable
+ * @param line allocated buffer holding one line
+ */
+
+void
+cSysConfig_vdr::AddLine(const char *line)
+{
+    //dsyslog(DBG  "   AddLine   %s", line);
+    vector < char >v(strlen(line) + 1);
+    char *l = &v[0];
+    strcpy(l, line);
+    char *key = NULL;
+    char *val = new char[MAXLENGTH];    //XXX!
+
+    if (strlen(l) > 0 && l[0] != '#')   // comment line
+    {
+        char *tmp = NULL;
+        char *strtok_next;
+        if ((key = strtok_r(l, "=", &strtok_next)) != NULL &&
+            (tmp = strtok_r(NULL, "\"", &strtok_next)) != NULL)
+        {
+            strncpy(val, tmp, MAXLENGTH - 1);   //XXX!
+            //dsyslog(DBG " SysConf Insert key \"%s\"-> \"%s\" ",key, val);
+            sysMap_.insert(map < string, char *>::value_type(key, val));
+        }
+    }
+}
+#endif /*REELVDR*/
+
diff -urN vdr-2.0.1/sysconfig_vdr.h vdr-2.0.1.reel/sysconfig_vdr.h
--- vdr-2.0.1/sysconfig_vdr.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/sysconfig_vdr.h	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,65 @@
+#ifdef REELVDR
+/*********************************************************
+ * DESCRIPTION:
+ *             Header File
+ *
+ * $Id: sysconfig.h,v 1.3 2005/10/03 14:05:20 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert
+ *********************************************************/
+
+#include <string>
+#include <map>
+//#include "debug.h"
+//#include "util.h"
+
+#ifndef SYSCONFIG_VDR_H
+#define SYSCONFIG_VDR_H
+
+//#define mapConstIter_t std::map<std::string, char *>::const_iterator
+//#define MAP_ITER std::map<std::string, char *>::iterator
+
+
+typedef std::map < std::string, char *>::const_iterator mapConstIter_t;
+typedef std::map < std::string, char *>::iterator mapIter_t;
+
+
+class cSysConfig_vdr
+{
+  public:
+    static void Create();
+    static void Destroy();
+    static cSysConfig_vdr & GetInstance();
+
+    bool Reload();
+    bool Load(const char *fname);
+    bool Save();
+    void SetVariable(const char *key, const char *value);
+    
+     // increments 'changed' if sysconfig was modified
+    void SetVariable(const char *key, const char *value, int& changed);
+    
+    const char * GetVariable(const char *key) const;
+    const char * FileName() const;
+  private:
+    cSysConfig_vdr();
+    ~cSysConfig_vdr();
+    cSysConfig_vdr(const cSysConfig_vdr &);
+    cSysConfig_vdr & operator=(const cSysConfig_vdr &);
+
+    static cSysConfig_vdr * instance_;
+    std::map < std::string, char *> sysMap_;
+    std::string fileName_;
+
+    const char * ReadLine(int fp);
+    void AddLine(const char *line);
+    void AddVariable(const char *key, char *value);
+};
+
+
+
+#endif
+#endif /*REELVDR*/
+
diff -urN vdr-2.0.1/timers.c vdr-2.0.1.reel/timers.c
--- vdr-2.0.1/timers.c	2013-03-29 16:37:16.000000000 +0100
+++ vdr-2.0.1.reel/timers.c	2013-05-09 18:10:01.607874320 +0200
@@ -16,6 +16,11 @@
 #include "recording.h"
 #include "remote.h"
 #include "status.h"
+#ifdef USEMYSQL
+#include "vdrmysql.h"
+#endif /* USEMYSQL */
+
+#define VFAT_MAX_FILENAME 40 // same as MAX_SUBTITLE_LENGTH in recording.c
 
 // IMPORTANT NOTE: in the 'sscanf()' calls there is a blank after the '%d'
 // format characters in order to allow any number of blanks after a numeric
@@ -25,6 +30,9 @@
 
 cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel)
 {
+#ifdef USEMYSQL
+    ID = 0;
+#endif
   startTime = stopTime = 0;
   lastSetEvent = 0;
   deferred = 0;
@@ -33,6 +41,7 @@
   *file = 0;
   aux = NULL;
   event = NULL;
+  fskProtection = 0;
   if (Instant)
      SetFlags(tfActive | tfInstant);
   channel = Channel ? Channel : Channels.GetByNumber(cDevice::CurrentChannel());
@@ -82,6 +91,9 @@
 
 cTimer::cTimer(const cEvent *Event)
 {
+#ifdef USEMYSQL
+    ID = 0;
+#endif
   startTime = stopTime = 0;
   lastSetEvent = 0;
   deferred = 0;
@@ -90,6 +102,7 @@
   *file = 0;
   aux = NULL;
   event = NULL;
+  fskProtection = 0;
   if (Event->Vps() && Setup.UseVps)
      SetFlags(tfVps);
   channel = Channels.GetByChannelID(Event->ChannelID(), true);
@@ -113,11 +126,15 @@
   const char *Title = Event->Title();
   if (!isempty(Title))
      Utf8Strn0Cpy(file, Event->Title(), sizeof(file));
+  cStatus::MsgTimerCreation(this, Event);
   SetEvent(Event);
 }
 
 cTimer::cTimer(const cTimer &Timer)
 {
+#ifdef USEMYSQL
+    ID = 0;
+#endif
   channel = NULL;
   aux = NULL;
   event = NULL;
@@ -149,10 +166,15 @@
      stop         = Timer.stop;
      priority     = Timer.priority;
      lifetime     = Timer.lifetime;
+     fskProtection = Timer.fskProtection;
      strncpy(file, Timer.file, sizeof(file));
      free(aux);
      aux = Timer.aux ? strdup(Timer.aux) : NULL;
      event = NULL;
+#ifdef USEMYSQL
+     ID = Timer.GetID();
+#endif
+
      }
   return *this;
 }
@@ -289,8 +311,20 @@
   return ""; // not NULL, so the caller can always use the result
 }
 
+#ifdef USEMYSQL
+bool cTimer::Parse(const char *s, unsigned int id)
+#else
 bool cTimer::Parse(const char *s)
+#endif /* USEMYSQL */
 {
+#ifdef USEMYSQL
+  bool UpdateDB = false;
+  if(ID)
+    UpdateDB = true;
+  else
+    ID = id;
+#endif /* USEMYSQL */
+
   char *channelbuffer = NULL;
   char *daybuffer = NULL;
   char *filebuffer = NULL;
@@ -313,7 +347,55 @@
      }
   bool result = false;
   if (8 <= sscanf(s, "%u :%a[^:]:%a[^:]:%d :%d :%d :%d :%a[^:\n]:%a[^\n]", &flags, &channelbuffer, &daybuffer, &start, &stop, &priority, &lifetime, &filebuffer, &aux)) {
+#ifdef USEMYSQL
+     if(Setup.ReelboxModeTemp == eModeClient || Setup.ReelboxModeTemp == eModeServer) // Client & Server (see comment below)
+     {
+         if(HasFlags(tfRecording) && HasFlags(tfActive))
+         {
+             recording = true;
+             SetFlags(tfRecording);
+         }
+         else
+         {
+             recording = false;
+             if(!UpdateDB)
+                 ClrFlags(tfRecording);
+         }
+     }
+
+     /* Why clear recording flag when in Server mode ?
+      * Since the server also reads its own updates from db!
+      * So, server set the recording-flag, updates timer in db and since entry
+      * into vdr_event is triggered, it reads its own update from db(!) and
+      * parses the 'changes' to timer. Clearing recording flag stops the
+      * recording of the timer immediately after it starts. Hence issue #453 */
+
+     /*else if (Setup.ReelboxModeTemp == eModeServer)
+     {
+         if(!UpdateDB)
+         {
+             recording = false;
+             ClrFlags(tfRecording);
+         }
+     }*/
+     else
+         ClrFlags(tfRecording);
+
+     /*
+     if(UpdateDB && Setup.DatabaseHost && HasFlags(tfRecording) && HasFlags(tfActive))
+     {
+        recording = true;
+        SetFlags(tfRecording);
+     }
+     else if(!UpdateDB)
+     {
+        recording = false;
+        ClrFlags(tfRecording);
+     }
+     */
+#else
      ClrFlags(tfRecording);
+#endif /* USEMYSQL */
      if (aux && !*skipspace(aux)) {
         free(aux);
         aux = NULL;
@@ -331,6 +413,11 @@
         result = false;
         }
      }
+  fskProtection = aux && strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>");
+#ifdef USEMYSQL
+  if(UpdateDB && ((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxModeTemp == eModeServer))) // Client & Server
+      UpdateTimerDB();
+#endif /* USEMYSQL */
   free(channelbuffer);
   free(daybuffer);
   free(filebuffer);
@@ -584,12 +671,25 @@
 
 void cTimer::SetRecording(bool Recording)
 {
+uint old_flags = flags;
   recording = Recording;
   if (recording)
      SetFlags(tfRecording);
   else
      ClrFlags(tfRecording);
   isyslog("timer %s %s", *ToDescr(), recording ? "start" : "stop");
+#ifdef USEMYSQL
+  /* if nothing was modified, do not update db */
+  if (old_flags == flags) 
+     return;
+
+  // Maybe not working :(
+  if(Setup.ReelboxMode == eModeServer) // Only Server should write state of recording into DB
+      UpdateTimerDB();
+  //TODO: Timers.SetModified() NEEDS TESTING!!! It may cause problem if a timer is enabled/disabled while running record
+  if((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxModeTemp == eModeServer)) // Client & Server
+      Timers.SetModified(); // Needed for sync with Database
+#endif /* USEMYSQL */
 }
 
 void cTimer::SetPending(bool Pending)
@@ -687,6 +787,56 @@
      SetFlags(tfActive);
   SetEvent(NULL);
   Matches(); // refresh start and end time
+#ifdef USEMYSQL
+  if((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxMode == eModeServer)) // Client
+      UpdateTimerDB();
+#endif /* USEMYSQL */
+}
+
+#ifdef USEMYSQL
+void cTimer::UpdateTimerDB()
+{
+    bool SetServer = false;
+    // Update Timer in Database if neccessary
+    cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+    if((Setup.ReelboxModeTemp == eModeClient) && Setup.NetServerIP && strlen(Setup.NetServerIP)) // Client
+        SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+    else
+        SetServer = TimersMysql->SetServer("localhost");
+    if(SetServer)
+        TimersMysql->UpdateTimer(this);
+    delete TimersMysql;
+}
+#endif /* USEMYSQL */
+
+
+void cTimer::SetFskProtection(int aFlag)
+{
+   char* p;
+   char* tmp = 0;
+
+   fskProtection = aFlag;
+
+   if (fskProtection && (!aux || !strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // add protection info to aux
+
+      if (aux) { tmp = strdup(aux); free(aux); }
+      if (asprintf(&aux,"%s<pin-plugin><protected>yes</protected></pin-plugin>", tmp ? tmp : "") < 0 )
+         aux = NULL;
+   }
+   else if (!fskProtection && aux && (p = strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // remove protection info to aux
+
+      if (asprintf(&tmp, "%.*s%s", p-aux, aux, p+strlen("<pin-plugin><protected>yes</protected></pin-plugin>")) >= 0 ) {
+         free(aux);
+         aux = strdup(tmp);
+         }
+   }
+
+   if (tmp)
+      free(tmp);
 }
 
 // --- cTimers ---------------------------------------------------------------
@@ -699,8 +849,24 @@
   beingEdited = 0;;
   lastSetEvents = 0;
   lastDeleteExpired = 0;
+#ifdef USEMYSQL
+  LastEventID = 0;
+#endif /* USEMYSQL */
 }
 
+#ifdef USEMYSQL
+cTimer *cTimers::GetTimer(cTimer *Timer, bool CheckID)
+{
+  for (cTimer *ti = First(); ti; ti = Next(ti)) {
+      if ((!CheckID || (ti->GetID() == Timer->GetID())) && ti->Channel() == Timer->Channel() &&
+          ((ti->WeekDays() && ti->WeekDays() == Timer->WeekDays()) || (!ti->WeekDays() && ti->Day() == Timer->Day())) &&
+          ti->Start() == Timer->Start() &&
+          ti->Stop() == Timer->Stop())
+         return ti;
+      }
+  return NULL;
+}
+#else
 cTimer *cTimers::GetTimer(cTimer *Timer)
 {
   for (cTimer *ti = First(); ti; ti = Next(ti)) {
@@ -712,6 +878,32 @@
       }
   return NULL;
 }
+#endif
+
+#ifdef USEMYSQL
+cTimer *cTimers::GetTimerByID(unsigned int id)
+{
+    for(cTimer *ti=First(); ti; ti=Next(ti))
+    {
+        if(ti->GetID() == id)
+            return ti;
+    }
+    return NULL;
+}
+
+void cTimers::GetInstantRecordings(std::vector<cTimer*> *InstantRecordings)
+{
+    bool SetServer = false;
+    cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+    if((Setup.ReelboxModeTemp == eModeClient) && Setup.NetServerIP && strlen(Setup.NetServerIP)) // Client
+        SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+    else if(Setup.ReelboxModeTemp == eModeServer)
+        SetServer = TimersMysql->SetServer("localhost");
+    if(SetServer)
+        TimersMysql->GetInstantRecordings(InstantRecordings);
+    delete TimersMysql;
+}
+#endif /* USEMYSQL */
 
 cTimer *cTimers::GetMatch(time_t t)
 {
@@ -771,23 +963,210 @@
   state++;
 }
 
+#ifdef USEMYSQL
+extern int DBCounter;
+#endif /* USEMYSQL */
+
+#ifdef USEMYSQL
+bool cTimers::Add(cTimer *Timer, cTimer *After)
+#else
 void cTimers::Add(cTimer *Timer, cTimer *After)
+#endif /* USEMYSQL */
 {
+#ifdef USEMYSQL
+  if((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxModeTemp == eModeServer)) // Client & Server
+  {
+    bool SetServer = false;
+    bool res = false;
+    // Add Timer to Database
+    cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+    if((Setup.ReelboxModeTemp == eModeClient) && Setup.NetServerIP && strlen(Setup.NetServerIP)) // Client
+      SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+    else
+      SetServer = TimersMysql->SetServer("localhost");
+    if(SetServer)
+      res = TimersMysql->InsertTimer(Timer);
+    if(res)
+      DBCounter++;
+    delete TimersMysql;
+    if(res)
+    {
+        cConfig<cTimer>::Add(Timer, After);
+        cStatus::MsgTimerChange(Timer, tcAdd);
+    }
+    return res;
+  }
+  else if((Setup.ReelboxMode == eModeClient) && (Setup.ReelboxModeTemp == eModeStandalone))
+  {
+      Skins.QueueMessage(mtError, tr("Database not available!"));
+      esyslog("ERROR: Database not available!");
+      return false;
+  }
+  else
+  {
+    cConfig<cTimer>::Add(Timer, After);
+    cStatus::MsgTimerChange(Timer, tcAdd);
+  }
+  return true;
+#else
   cConfig<cTimer>::Add(Timer, After);
   cStatus::MsgTimerChange(Timer, tcAdd);
+#endif /* USEMYSQL */
 }
 
+#ifdef USEMYSQL
+bool cTimers::Ins(cTimer *Timer, cTimer *Before)
+#else
 void cTimers::Ins(cTimer *Timer, cTimer *Before)
+#endif /* USEMYSQL */
 {
+#ifdef USEMYSQL
+  if((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxModeTemp == eModeServer)) // Client & Server
+  {
+    bool SetServer = false;
+    bool res = false;
+    // Add Timer to Database
+    cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+    if((Setup.ReelboxModeTemp == eModeClient) && Setup.NetServerIP && strlen(Setup.NetServerIP)) // Client
+      SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+    else
+      SetServer = TimersMysql->SetServer("localhost");
+    if(SetServer)
+      res = TimersMysql->InsertTimer(Timer);
+    delete TimersMysql;
+    if(res)
+    {
+        cConfig<cTimer>::Ins(Timer, Before);
+        cStatus::MsgTimerChange(Timer, tcAdd);
+    }
+    return res;
+  }
+  else if((Setup.ReelboxMode == eModeClient) && (Setup.ReelboxModeTemp == eModeStandalone))
+  {
+      Skins.QueueMessage(mtError, tr("Database not available!"));
+      esyslog("ERROR: Database not available!");
+      return false;
+  }
+  else
+  {
+    cConfig<cTimer>::Ins(Timer, Before);
+    cStatus::MsgTimerChange(Timer, tcAdd);
+  }
+  return true;
+#else
   cConfig<cTimer>::Ins(Timer, Before);
   cStatus::MsgTimerChange(Timer, tcAdd);
+#endif /* USEMYSQL */
 }
 
+#ifdef USEMYSQL
+bool cTimers::Del(cTimer *Timer, bool DeleteObject)
+#else
 void cTimers::Del(cTimer *Timer, bool DeleteObject)
+#endif
 {
+#ifdef USEMYSQL
+  if((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxModeTemp == eModeServer)) // Client & Server
+  {
+    bool SetServer = false;
+    bool res = false;
+    // Remove Timer from Database
+    cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+    if((Setup.ReelboxModeTemp == eModeClient) && Setup.NetServerIP && strlen(Setup.NetServerIP)) // Client
+      SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+    else
+      SetServer = TimersMysql->SetServer("localhost");
+    if(SetServer)
+      res = TimersMysql->DeleteTimer(Timer->GetID());
+    delete TimersMysql;
+    cStatus::MsgTimerChange(Timer, tcDel);
+    cConfig<cTimer>::Del(Timer, DeleteObject);
+    return res;
+  }
+  else
+  {
+      cStatus::MsgTimerChange(Timer, tcDel);
+      cConfig<cTimer>::Del(Timer, DeleteObject);
+  }
+  return true;
+#else
   cStatus::MsgTimerChange(Timer, tcDel);
   cConfig<cTimer>::Del(Timer, DeleteObject);
+#endif /* USEMYSQL */
+}
+
+#ifdef USEMYSQL
+bool cTimers::LoadDB()
+{
+  bool SetServer = false;
+
+  cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+ 
+  if(Setup.ReelboxModeTemp == eModeClient) // Client
+  {
+      if(Setup.NetServerIP && strlen(Setup.NetServerIP)) // Client
+          SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+      else
+          SetServer = false;
+  }
+  else
+    SetServer = TimersMysql->SetServer("localhost");
+
+  if(SetServer)
+  {
+    std::vector<StringTimer> StringTimers;
+    TimersMysql->LoadDB(&StringTimers, &LastEventID);
+
+    for(unsigned int i=0; i < StringTimers.size(); ++i)
+    {
+      cTimer *timer = new cTimer;
+      if(timer->Parse(StringTimers.at(i).s, StringTimers.at(i).ID))
+        cConfig<cTimer>::Add(timer);
+      else
+        delete timer;
+      free(StringTimers.at(i).s); // clear memory
+    }
+    delete TimersMysql;
+    return true;
+  }
+
+  delete TimersMysql;
+  esyslog("ERROR (%s,%i): LoadDB failed\n", __FILE__, __LINE__);
+  return false;
+}
+
+void cTimers::SyncData()
+{
+    bool SetServer = false;
+
+    static int TimerState = 0;
+    int oldState = state;
+    bool modified = Modified(TimerState);
+
+    cTimersMysql *TimersMysql = new cTimersMysql(MYSQLREELUSER, MYSQLREELPWD, "vdr");
+
+    if(Setup.ReelboxModeTemp == eModeClient) // Client
+    {
+        if(Setup.NetServerIP && strlen(Setup.NetServerIP)) // Got NetServerIP?
+            SetServer = TimersMysql->SetServer(Setup.NetServerIP);
+    }
+    else
+        SetServer = TimersMysql->SetServer("localhost");
+
+    if(SetServer)
+    {
+        TimersMysql->Sync(&LastEventID);
+// UpdateDB() is obsolete
+//        if(modified)
+//            TimersMysql->UpdateDB();
+//        else
+        if(!modified)
+            state = oldState; // undo change in state, caused by TimersMysql->Sync()
+    }
+
+    delete TimersMysql;
 }
+#endif /* USEMYSQL */
 
 bool cTimers::Modified(int &State)
 {
diff -urN vdr-2.0.1/timers.h vdr-2.0.1.reel/timers.h
--- vdr-2.0.1/timers.h	2013-03-11 11:35:53.000000000 +0100
+++ vdr-2.0.1.reel/timers.h	2013-05-09 18:10:01.607874320 +0200
@@ -14,6 +14,9 @@
 #include "config.h"
 #include "epg.h"
 #include "tools.h"
+#ifdef USEMYSQL
+#include <vector>
+#endif /* USEMYSQL */
 
 enum eTimerFlags { tfNone      = 0x0000,
                    tfActive    = 0x0001,
@@ -26,6 +29,14 @@
 
 class cTimer : public cListObject {
   friend class cMenuEditTimer;
+#ifdef USEMYSQL
+private:
+  unsigned int ID;
+  void UpdateTimerDB();
+public:
+  void SetID(unsigned int id) { ID=id; }
+  unsigned int GetID(void) const { return ID; }
+#endif /* USEMYSQL */
 private:
   mutable time_t startTime, stopTime;
   time_t lastSetEvent;
@@ -38,6 +49,7 @@
   int start;
   int stop;
   int priority;
+  int fskProtection;
   int lifetime;
   mutable char file[NAME_MAX * 2 + 1]; // *2 to be able to hold 'title' and 'episode', which can each be up to 255 characters long
   char *aux;
@@ -54,11 +66,16 @@
   bool InVpsMargin(void) const { return inVpsMargin; }
   uint Flags(void) const { return flags; }
   const cChannel *Channel(void) const { return channel; }
+#ifdef REELVDR
+  void SetChannel(cChannel *chan) { channel = chan; }
+  void ClearRecording() { recording = false; ClrFlags(tfRecording);}
+#endif /* REELVDR */
   time_t Day(void) const { return day; }
   int WeekDays(void) const { return weekdays; }
   int Start(void) const { return start; }
   int Stop(void) const { return stop; }
   int Priority(void) const { return priority; }
+  int FskProtection(void) const { return fskProtection; }
   int Lifetime(void) const { return lifetime; }
   const char *File(void) const { return file; }
   time_t FirstDay(void) const { return weekdays ? day : 0; }
@@ -67,7 +84,11 @@
   cString ToText(bool UseChannelID = false) const;
   cString ToDescr(void) const;
   const cEvent *Event(void) const { return event; }
+#ifdef USEMYSQL
+  bool Parse(const char *s, unsigned int id=0);
+#else
   bool Parse(const char *s);
+#endif /* USEMYSQL */
   bool Save(FILE *f);
   bool IsSingleEvent(void) const;
   static int GetMDay(time_t t);
@@ -95,6 +116,7 @@
   void SetAux(const char *Aux);
   void SetDeferred(int Seconds);
   void SetFlags(uint Flags);
+  void SetFskProtection(int aFlag);
   void ClrFlags(uint Flags);
   void InvFlags(uint Flags);
   bool HasFlags(uint Flags) const;
@@ -112,9 +134,16 @@
   int beingEdited;
   time_t lastSetEvents;
   time_t lastDeleteExpired;
+#ifdef USEMYSQL
+  int LastEventID;
+#endif /* USEMYSQL */
 public:
   cTimers(void);
+#ifdef USEMYSQL
+  cTimer *GetTimer(cTimer *Timer, bool CheckID=true);
+#else
   cTimer *GetTimer(cTimer *Timer);
+#endif
   cTimer *GetMatch(time_t t);
   cTimer *GetMatch(const cEvent *Event, eTimerMatch *Match = NULL);
   cTimer *GetNextActiveTimer(void);
@@ -128,9 +157,29 @@
       ///< Upon return the internal state will be stored in State.
   void SetEvents(void);
   void DeleteExpired(void);
+#ifdef USEMYSQL
+  int GetLastEventID() const { return LastEventID; };
+  cTimer *GetTimerByID(unsigned int id);
+  void GetInstantRecordings(std::vector<cTimer*> *InstantRecordings);
+  bool LoadDB();
+  void SyncData();
+  bool Add(cTimer *Timer, cTimer *After = NULL);
+  bool Ins(cTimer *Timer, cTimer *Before = NULL);
+  bool Del(cTimer *Timer, bool DeleteObject = true);
+#else
   void Add(cTimer *Timer, cTimer *After = NULL);
   void Ins(cTimer *Timer, cTimer *Before = NULL);
   void Del(cTimer *Timer, bool DeleteObject = true);
+#endif /* USEMYSQL */
+#if REELVDR
+  void ClearAllRecordingFlags() {
+      cTimer *ti = First();
+      while (ti) {
+          ti->ClearRecording();
+          ti = Next(ti);
+      }
+  }
+#endif
   };
 
 extern cTimers Timers;
diff -urN vdr-2.0.1/tinystr.c vdr-2.0.1.reel/tinystr.c
--- vdr-2.0.1/tinystr.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinystr.c	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,299 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+#ifndef TIXML_USE_STL
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "tinystr.h"
+
+// TiXmlString constructor, based on a C string
+TiXmlString::TiXmlString (const char* instring)
+{
+    unsigned newlen;
+    char * newstring;
+
+    if (!instring)
+    {
+        allocated = 0;
+        cstring = NULL;
+        current_length = 0;
+        return;
+    }
+    newlen = strlen (instring) + 1;
+    newstring = new char [newlen];
+    memcpy (newstring, instring, newlen);
+    // strcpy (newstring, instring);
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+// TiXmlString copy constructor
+TiXmlString::TiXmlString (const TiXmlString& copy)
+{
+    unsigned newlen;
+    char * newstring;
+
+	// Prevent copy to self!
+	if ( &copy == this )
+		return;
+
+    if (! copy . allocated)
+    {
+        allocated = 0;
+        cstring = NULL;
+        current_length = 0;
+        return;
+    }
+    newlen = copy . length () + 1;
+    newstring = new char [newlen];
+    // strcpy (newstring, copy . cstring);
+    memcpy (newstring, copy . cstring, newlen);
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+// TiXmlString = operator. Safe when assign own content
+void TiXmlString ::operator = (const char * content)
+{
+    unsigned newlen;
+    char * newstring;
+
+    if (! content)
+    {
+        empty_it ();
+        return;
+    }
+    newlen = strlen (content) + 1;
+    newstring = new char [newlen];
+    // strcpy (newstring, content);
+    memcpy (newstring, content, newlen);
+    empty_it ();
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+// = operator. Safe when assign own content
+void TiXmlString ::operator = (const TiXmlString & copy)
+{
+    unsigned newlen;
+    char * newstring;
+
+    if (! copy . length ())
+    {
+        empty_it ();
+        return;
+    }
+    newlen = copy . length () + 1;
+    newstring = new char [newlen];
+    // strcpy (newstring, copy . c_str ());
+    memcpy (newstring, copy . c_str (), newlen);
+    empty_it ();
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+
+// append a const char * to an existing TiXmlString
+void TiXmlString::append( const char* str, int len )
+{
+    char * new_string;
+    unsigned new_alloc, new_size, size_suffix;
+
+	// don't use strlen - it can overrun the len passed in!
+	const char* p = str;
+	size_suffix = 0;
+
+	while ( *p && size_suffix < (unsigned)len )
+	{
+		++p;
+		++size_suffix;
+	}
+    if ( !size_suffix)
+        return;
+
+    new_size = length () + size_suffix + 1;
+    // check if we need to expand
+    if (new_size > allocated)
+    {
+        // compute new size
+        new_alloc = assign_new_size (new_size);
+
+        // allocate new buffer
+        new_string = new char [new_alloc];
+        new_string [0] = 0;
+
+        // copy the previous allocated buffer into this one
+        if (allocated && cstring)
+            // strcpy (new_string, cstring);
+            memcpy (new_string, cstring, length ());
+
+        // append the suffix. It does exist, otherwize we wouldn't be expanding
+        // strncat (new_string, str, len);
+        memcpy (new_string + length (),
+                str,
+                size_suffix);
+
+        // return previsously allocated buffer if any
+        if (allocated && cstring)
+            delete [] cstring;
+
+        // update member variables
+        cstring = new_string;
+        allocated = new_alloc;
+    }
+    else
+    {
+        // we know we can safely append the new string
+        // strncat (cstring, str, len);
+        memcpy (cstring + length (),
+                str,
+                size_suffix);
+    }
+    current_length = new_size - 1;
+    cstring [current_length] = 0;
+}
+
+
+// append a const char * to an existing TiXmlString
+void TiXmlString::append( const char * suffix )
+{
+    char * new_string;
+    unsigned new_alloc, new_size;
+
+    new_size = length () + strlen (suffix) + 1;
+    // check if we need to expand
+    if (new_size > allocated)
+    {
+        // compute new size
+        new_alloc = assign_new_size (new_size);
+
+        // allocate new buffer
+        new_string = new char [new_alloc];
+        new_string [0] = 0;
+
+        // copy the previous allocated buffer into this one
+        if (allocated && cstring)
+            memcpy (new_string, cstring, 1 + length ());
+            // strcpy (new_string, cstring);
+
+        // append the suffix. It does exist, otherwize we wouldn't be expanding
+        // strcat (new_string, suffix);
+        memcpy (new_string + length (),
+                suffix,
+                strlen (suffix) + 1);
+
+        // return previsously allocated buffer if any
+        if (allocated && cstring)
+            delete [] cstring;
+
+        // update member variables
+        cstring = new_string;
+        allocated = new_alloc;
+    }
+    else
+    {
+        // we know we can safely append the new string
+        // strcat (cstring, suffix);
+        memcpy (cstring + length (),
+                suffix,
+                strlen (suffix) + 1);
+    }
+    current_length = new_size - 1;
+}
+
+// Check for TiXmlString equuivalence
+//bool TiXmlString::operator == (const TiXmlString & compare) const
+//{
+//    return (! strcmp (c_str (), compare . c_str ()));
+//}
+
+//unsigned TiXmlString::length () const
+//{
+//    if (allocated)
+//        // return strlen (cstring);
+//        return current_length;
+//    return 0;
+//}
+
+
+unsigned TiXmlString::find (char tofind, unsigned offset) const
+{
+    char * lookup;
+
+    if (offset >= length ())
+        return (unsigned) notfound;
+    for (lookup = cstring + offset; * lookup; lookup++)
+        if (* lookup == tofind)
+            return lookup - cstring;
+    return (unsigned) notfound;
+}
+
+
+bool TiXmlString::operator == (const TiXmlString & compare) const
+{
+	if ( allocated && compare.allocated )
+	{
+		assert( cstring );
+		assert( compare.cstring );
+		return ( strcmp( cstring, compare.cstring ) == 0 );
+ 	}
+	return false;
+}
+
+
+bool TiXmlString::operator < (const TiXmlString & compare) const
+{
+	if ( allocated && compare.allocated )
+	{
+		assert( cstring );
+		assert( compare.cstring );
+		return ( strcmp( cstring, compare.cstring ) > 0 );
+ 	}
+	return false;
+}
+
+
+bool TiXmlString::operator > (const TiXmlString & compare) const
+{
+	if ( allocated && compare.allocated )
+	{
+		assert( cstring );
+		assert( compare.cstring );
+		return ( strcmp( cstring, compare.cstring ) < 0 );
+ 	}
+	return false;
+}
+
+
+#endif	// TIXML_USE_STL
diff -urN vdr-2.0.1/tinystr.h vdr-2.0.1.reel/tinystr.h
--- vdr-2.0.1/tinystr.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinystr.h	2013-05-09 18:10:01.607874320 +0200
@@ -0,0 +1,242 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786 )	// Debugger truncating names.
+#endif
+
+#include <assert.h>
+
+/*
+   TiXmlString is an emulation of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TiXmlString
+{
+  public :
+    // TiXmlString constructor, based on a string
+    TiXmlString (const char * instring);
+
+    // TiXmlString empty constructor
+    TiXmlString ()
+    {
+        allocated = 0;
+        cstring = NULL;
+        current_length = 0;
+    }
+
+    // TiXmlString copy constructor
+    TiXmlString (const TiXmlString& copy);
+
+    // TiXmlString destructor
+    ~ TiXmlString ()
+    {
+        empty_it ();
+    }
+
+    // Convert a TiXmlString into a classical char *
+    const char * c_str () const
+    {
+        if (allocated)
+            return cstring;
+        return "";
+    }
+
+    // Return the length of a TiXmlString
+    unsigned length () const
+	{
+		return ( allocated ) ? current_length : 0;
+	}
+
+    // TiXmlString = operator
+    void operator = (const char * content);
+
+    // = operator
+    void operator = (const TiXmlString & copy);
+
+    // += operator. Maps to append
+    TiXmlString& operator += (const char * suffix)
+    {
+        append (suffix);
+		return *this;
+    }
+
+    // += operator. Maps to append
+    TiXmlString& operator += (char single)
+    {
+        append (single);
+		return *this;
+    }
+
+    // += operator. Maps to append
+    TiXmlString& operator += (TiXmlString & suffix)
+    {
+        append (suffix);
+		return *this;
+    }
+    bool operator == (const TiXmlString & compare) const;
+    bool operator < (const TiXmlString & compare) const;
+    bool operator > (const TiXmlString & compare) const;
+
+    // Checks if a TiXmlString is empty
+    bool empty () const
+    {
+        return length () ? false : true;
+    }
+
+    // single char extraction
+    const char& at (unsigned index) const
+    {
+        assert( index < length ());
+        return cstring [index];
+    }
+
+    // find a char in a string. Return TiXmlString::notfound if not found
+    unsigned find (char lookup) const
+    {
+        return find (lookup, 0);
+    }
+
+    // find a char in a string from an offset. Return TiXmlString::notfound if not found
+    unsigned find (char tofind, unsigned offset) const;
+
+    /*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function clears the content of the TiXmlString if any exists.
+    */
+    void reserve (unsigned size)
+    {
+        empty_it ();
+        if (size)
+        {
+            allocated = size;
+            cstring = new char [size];
+            cstring [0] = 0;
+            current_length = 0;
+        }
+    }
+
+    // [] operator
+    char& operator [] (unsigned index) const
+    {
+        assert( index < length ());
+        return cstring [index];
+    }
+
+    // Error value for find primitive
+    enum {	notfound = 0xffffffff,
+            npos = notfound };
+
+    void append (const char *str, int len );
+
+  protected :
+
+    // The base string
+    char * cstring;
+    // Number of chars allocated
+    unsigned allocated;
+    // Current string size
+    unsigned current_length;
+
+    // New size computation. It is simplistic right now : it returns twice the amount
+    // we need
+    unsigned assign_new_size (unsigned minimum_to_allocate)
+    {
+        return minimum_to_allocate * 2;
+    }
+
+    // Internal function that clears the content of a TiXmlString
+    void empty_it ()
+    {
+        if (cstring)
+            delete [] cstring;
+        cstring = NULL;
+        allocated = 0;
+        current_length = 0;
+    }
+
+    void append (const char *suffix );
+
+    // append function for another TiXmlString
+    void append (const TiXmlString & suffix)
+    {
+        append (suffix . c_str ());
+    }
+
+    // append for a single char.
+    void append (char single)
+    {
+        if ( cstring && current_length < (allocated-1) )
+		{
+			cstring[ current_length ] = single;
+			++current_length;
+			cstring[ current_length ] = 0;
+		}
+		else
+		{
+			char smallstr [2];
+			smallstr [0] = single;
+			smallstr [1] = 0;
+			append (smallstr);
+		}
+    }
+
+} ;
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TiXmlOutStream : public TiXmlString
+{
+public :
+    TiXmlOutStream () : TiXmlString () {}
+
+    // TiXmlOutStream << operator. Maps to TiXmlString::append
+    TiXmlOutStream & operator << (const char * in)
+    {
+        append (in);
+        return (* this);
+    }
+
+    // TiXmlOutStream << operator. Maps to TiXmlString::append
+    TiXmlOutStream & operator << (const TiXmlString & in)
+    {
+        append (in . c_str ());
+        return (* this);
+    }
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL
diff -urN vdr-2.0.1/tinyxml/changes.txt vdr-2.0.1.reel/tinyxml/changes.txt
--- vdr-2.0.1/tinyxml/changes.txt	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/changes.txt	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,290 @@
+Changes in version 1.0.1:
+- Fixed comment tags which were outputing as '<?--' instead of 
+  the correct '<!--'.
+- Implemented the Next and Prev methods of the TiXmlAttribute class.
+- Renamed 'LastAttribtute' to 'LastAttribute'
+- Fixed bad pointer to 'isspace' that could occur while parsing text.
+- Errors finding beginning and end of tags no longer throw it into an
+  infinite loop. (Hopefully.)
+
+Changes in version 1.0.2
+- Minor documentation fixes.
+
+Changes in version 1.0.3
+- After nodes are added to a document, they return a pointer
+  to the new node instead of a bool for success.
+- Elements can be constructed with a value, which is the
+  element name. Every element must have a value or it will be
+  invalid, but the code changes to enforce this are not fully
+  in place.
+
+Changes in version 1.1.0
+- Added the	TiXmlAttributeSet class to pull the attributes into
+  a seperate container.
+- Moved the doubly liked list out of XmlBase. Now XmlBase only
+  requires the Print() function and defines some utility functions.
+- Moved errors into a seperate file. (With the idea of internationalization
+  to the other latin-1 languages.)
+- Added the "NodeType"
+- Fixed white space parsing in text to conform with the standard. 
+  Basically, all white space becomes just one space.
+- Added the TiXmlDeclaration class to read xml declarations.
+
+Changes in version 1.2.0
+- Removed the factory. The factory was not really in the spirit 
+  of small and simple, confused the code, and was of limited value.
+- Added FirstChildElement and NextSiblingElement, because they
+  are such common functions.
+- Re-wrote the example to test and demonstrate more functionality.
+
+Changes in version 1.2.1
+- Fixed a bug where comments couldn't be inside elements.
+- Loading now clears out existing XML rather than appending.
+- Added the "Clear" method on a node to delete all its children.
+
+Changes in version 1.2.2
+- Fixed TiXmlAttribute::Previous actually returning "next." Thanks
+  to Rickard Troedsson for the bug fix.
+
+Changes in version 1.2.3
+- Added the TIXML prefix to the error strings to resolve conflicts
+  with #defines in OS headers. Thanks to Steve Lhomme.
+- Fixed a delete buf that should be a delete [] buf. 
+  Thanks to Ephi Sinowitz.
+
+Changes in version 1.2.4
+- ReplaceChild() was almost guarenteed to fail. Should be fixed,
+  thanks to Joe Smith. Joe also pointed out that the Print() functions
+  should take stream references: I agree, and would like to overload
+  the Print() method to take either format, but I don't want to do 
+  this in a dot release.
+- Some compilers seem to need an extra <ctype.h> include. Thanks
+  to Steve Lhomme for that.
+
+Changes in version 2.0.0 BETA
+- Made the ToXXX() casts safe if 'this' is null. 
+  When "LoadFile" is called with a filename, the value will correctly get set.
+  Thanks to Brian Yoder.
+- Fixed bug where isalpha() and isalnum() would get called with a negative value for 
+  high ascii numbers. Thanks to Alesky Aksenov.
+- Fixed some errors codes that were not getting set.
+- Made methods "const" that were not.
+- Added a switch to enable or disable the ignoring of white space. ( TiXmlDocument::SetIgnoreWhiteSpace() )
+- Greater standardization and code re-use in the parser.
+- Added a stream out operator.
+- Added a stream in operator.
+- Entity support, of predefined entites. &#x entities are untouched by input or output.
+- Improved text out formatting.
+- Fixed ReplaceChild bug, thanks to Tao Chen.
+
+Changes in version 2.0.1
+- Fixed hanging on loading a 0 length file. Thanks to Jeff Scozzafava.
+- Fixed crashing on InsertBeforeChild and InsertAfterChild. Also possibility of bad links being
+  created by same function. Thanks to Frank De prins.
+- Added missing licence text. Thanks to Lars Willemsens.
+- Added <ctype.h> include, at the suggestion of Steve Walters.
+
+Changes in version 2.1.0
+- Yves Berquin brings us the STL switch. The forum on SourceForge, and various emails to
+  me, have long debated all out STL vs. no STL at all. And now you can have it both ways.
+  TinyXml will compile either way.
+
+Changes in version 2.1.1
+- Compilation warnings.
+
+Changes in version 2.1.2
+- Uneeded code is not compiled in the STL case.
+- Changed headers so that STL can be turned on or off in tinyxml.h
+
+Changes in version 2.1.3
+- Fixed non-const reference in API; now uses a pointer.
+- Copy constructor of TiXmlString not checking for assignment to self.
+- Nimrod Cohen found a truly evil bug in the STL implementation that occurs
+  when a string is converted to a c_str and then assigned to self. Search for
+  STL_STRING_BUG for a full description. I'm asserting this is a Microsoft STL
+  bug, since &string and string.c_str() should never be the same. Nevertheless,
+  the code works around it.
+- Urivan Saaib pointed out a compiler conflict, where the C headers define
+  the isblank macro, which was wiping out the TiXmlString::isblank() method.
+  The method was unused and has been removed.
+
+Changes in version 2.1.4
+- Reworked the entity code. Entities were not correctly surving round trip input and output.
+  Will now automatically create entities for high ascii in output.
+
+Changes in version 2.1.5
+- Bug fix by kylotan : infinite loop on some input (tinyxmlparser.cpp rev 1.27)
+- Contributed by Ivica Aracic (bytelord) : 1 new VC++ project to compile versions as static libraries (tinyxml_lib.dsp), 
+  and an example usage in xmltest.dsp
+  (Patch request ID 678605)
+- A suggestion by Ronald Fenner Jr (dormlock) to add #include <istream> and <ostream> for Apple's Project Builder 
+  (Patch request ID 697642)
+- A patch from ohommes that allows to parse correctly dots in element names and attribute names
+  (Patch request 602600 and kylotan 701728)
+- A patch from  hermitgeek ( James ) and wasteland for improper error reporting
+- Reviewed by Lee, with the following changes:
+	- Got sick of fighting the STL/non-STL thing in the windows build. Broke
+	  them out as seperate projects.
+	- I have too long not included the dsw. Added.
+	- TinyXmlText had a protected Print. Odd.
+	- Made LinkEndChild public, with docs and appropriate warnings.
+	- Updated the docs.
+
+2.2.0
+- Fixed an uninitialized pointer in the TiXmlAttributes
+- Fixed STL compilation problem in MinGW (and gcc 3?) - thanks Brian Yoder for finding this one
+- Fixed a syntax error in TiXmlDeclaration - thanks Brian Yoder
+- Fletcher Dunn proposed and submitted new error handling that tracked the row and column. Lee
+  modified it to not have performance impact.
+- General cleanup suggestions from Fletcher Dunn.
+- In error handling, general errors will no longer clear the error state of specific ones.
+- Fix error in documentation : comments starting with "<?--" instead of "<!--" (thanks ion_pulse)
+- Added the TiXmlHandle. An easy, safe way to browse XML DOMs with less code.
+- Added QueryAttribute calls which have better error messaging. (Proposed by Fletcher Dunn)
+- Nodes and attributes can now print themselves to strings. (Yves suggestion)
+- Fixed bug where entities with one character would confuse parser. (Thanks Roman)
+
+2.2.1
+- Additional testing (no more bugs found to be fixed in this release)
+- Significant performance improvement to the cursor code.
+
+2.3.0
+- User Data are now defined in TiXmlBase instead of TiXmlNode
+- Character Entities are now UCS-2
+- Character Entities can be decimal or hexadecimal
+- UTF-8 conversion.
+- Fixed many, many bugs.
+
+2.3.1
+- Fixed bug in handling nulls embedded in the input.
+- Make UTF-8 parser tolerant of bad text encoding.
+- Added encoding detection. 
+- Many fixes and input from John-Philip Leonard Johansson (JP) and Ellers, 
+  including UTF-8 feedback, bug reports, and patches. Thanks!
+- Added version # constants - a suggestion from JP and Ellers.
+- [ 979180 ] Missing ; in entity reference, fix from Rob Laveaux.
+- Copy constructors and assignment have been a long time coming. Thanks to
+  Fokke and JP.
+
+2.3.2
+- Made the IsAlpha and IsAlphaNum much more tolerant of non-UTF-8 encodings. Thanks
+  Volker Boerchers for finding the issue.
+- Ran the program though the magnificent Valgrind - http://valgrind.kde.org - to check
+  for memory errors. Fixed some minor issues.
+
+2.3.3
+- Fixed crash when test program was run from incorrect directory.
+- Fixed bug 1070717 - empty document not returned correctly - thanks Katsuhisa Yuasa.
+- Bug 1079301 resolved - deprecated stdlib calls. Thanks Adrian Boeing.
+- Bug 1035218 fixed - documentation errors. Xunji Luo
+- Other bug fixes have accumulated and been fixed on the way as well; my apologies to
+  authors not credited!
+- Big fix / addition is to correctly return const values. TinyXml could basically
+  remove const in a method like this: TiXmlElement* Foo() const, where the returned element
+  was a pointer to internal data. That is now: const TiXmlElement* Foo() const and
+  TiXmlElement* Foo().
+
+2.3.4
+- Fixed additional const errors, thanks Kent Gibson.
+- Correctly re-enable warnings after tinyxml header. Thanks Cory Nelson.
+- Variety of type cleanup and warning fixes. Thanks Warren Stevens.
+- Cleaned up unneeded constructor calls in TinyString - thanks to Geoff Carlton and
+  the discussion group on sourceforge.
+
+2.4.0
+- Improved string class, thanks Tyge Lovset (whose name gets mangled in English - sorry)
+- Type cast compiler warning, thanks Rob van den Bogaard
+- Added GetText() convenience function. Thanks Ilya Parniuk & Andrew Ellers for input.
+- Many thanks to marlonism for finding an infinite loop in bad xml.
+- A patch to cleanup warnings from Robert Gebis.
+- Added ValueStr() to get the value of a node as a string.
+- TiXmlText can now parse and output as CDATA
+- Additional string improvement from James (z2895)
+- Removed extraneous 'const', thanks David Aldrich
+- First pass at switching to the "safe" stdlib functions. Many people have suggested and
+  pushed on this, but Warren Stevens put together the first proposal.
+- TinyXml now will do EOL normalization before parsing, consistent with the W3C XML spec.
+- Documents loaded with the UTF-8 BOM will now save with the UTF-8 BOM. Good suggestion 
+  from 'instructor_'
+- Ellers submitted his very popular tutorials, which have been added to the distribution.
+
+2.4.1
+- Fixed CDATA output formatting
+- Fixed memory allocators in TinyString to work with overloaded new/delete
+
+2.4.2
+- solosnake pointed out that TIXML_LOG causes problems on an XBOX. The definition in the header
+  was superflous and was moved inside of DEBUG_PARSING
+
+2.4.3
+- Fixed a test bug that caused a crash in 'xmltest'. TinyXML was fine, but it isn't good
+  to ship with a broken test suite.
+- Started converting some functions to not cast between std::string and const char* 
+  quite as often.
+- Added FILE* versions of the document loads - good suggestion from Wade Brainerd
+- Empty documents might not always return the errors they should. [1398915] Thanks to igor v.
+- Added some asserts for multiply adding a node, regardng bug [1391937] suggested by Paco Arjonilla.
+
+2.4.4
+- Bug find thanks to andre-gross found a memory leak that occured when a document failed to load.
+- Bug find (and good analysis) by VirtualJim who found a case where attribute parsing 
+  should be throwing an error and wasn't.
+- Steve Hyatt suggested the QueryValueAttribute method, which is now implemented.
+- DavidA identified a chunk of dead code.
+- Andrew Baxter sent in some compiler warnings that were good clean up points.
+
+2.5
+- Added the Visit() API. Many thanks to both Andrew Ellerton and John-Philip for all their
+  work, code, suggestion, and just general pushing that it should be done.
+- Removed existing streaming code and use TiXmlPrinter instead.
+- [ tinyxml-Bugs-1527079 ] Compile error in tinystr.cpp fixed, thanks to Paul Suggs
+- [ tinyxml-Bugs-1522890 ] SaveFile has no error checks fixed, thanks to Ivan Dobrokotov
+- Ivan Dobrokotov also reported redundant memory allocation in the Attribute() method, which
+  upon investigation was a mess. The attribute should now be fixed for both const char* and 
+  std::string, and the return types match the input parameters.
+- Feature [ 1511105 ] Make TiXmlComment constructor accept a string / char*, implemented.
+  Thanks to Karl Itschen for the feedback.
+- [ 1480108 ] Stream parsing fails when CDATA contains tags was found by Tobias Grimm, who also
+  submitted a test case and patch. A significant bug in CDATA streaming (operator>>) has now
+  been fixed.
+
+2.5.2
+- Lieven, and others, pointed out a missing const-cast that upset the Open Watcom compiler.
+  Should now be fixed.
+- ErrorRow and ErrorCol should have been const, and weren't. Fixed thanks to Dmitry Polutov.
+
+2.5.3
+- zloe_zlo identified a missing string specialization for QueryValueAttribute() [ 1695429 ]. Worked
+  on this bug, but not sure how to fix it in a safe, cross-compiler way.
+- increased warning level to 4 and turned on detect 64 bit portability issues for VC2005.
+  May address [ 1677737 ] VS2005: /Wp64 warnings
+- grosheck identified several problems with the Document copy. Many thanks for [ 1660367 ]
+- Nice catch, and suggested fix, be Gilad Novik on the Printer dropping entities.
+  "[ 1600650 ] Bug when printing xml text" is now fixed.
+- A subtle fix from Nicos Gollan in the tinystring initializer: 
+  [ 1581449 ] Fix initialiser of TiXmlString::nullrep_
+- Great catch, although there isn't a submitter for the bug. [ 1475201 ] TinyXML parses entities in comments. 
+  Comments should not, in fact, parse entities. Fixed the code path and added tests.
+- We were not catching all the returns from ftell. Thanks to Bernard for catching that.
+  
+2.5.4
+- A TiXMLDocument can't be a sub-node. Block this from happening in the 'replace'. Thanks Noam.
+- [ 1714831 ] TiXmlBase::location is not copied by copy-ctors, fix reported and suggested by Nicola Civran.
+- Fixed possible memory overrun in the comment reading code - thanks gcarlton77
+
+2.5.5
+- Alex van der Wal spotted incorrect types (lf) being used in print and scan. robertnestor pointed out some problems with the simple solution. Types updated.
+- Johannes Hillert pointed out some bug typos.
+- Christian Mueller identified inconsistent error handling with Attributes.
+- olivier barthelemy also reported a problem with double truncation, also related to the %lf issue.
+- zaelsius came up with a great (and simple) suggestion to fix QueryValueAttribute truncating strings.
+- added some null pointer checks suggested by hansenk
+- Sami Visnen found a (rare) buffer overrun that could occur in parsing.
+- vi tri filed a bug that led to a refactoring of the attribute setting mess (as well as adding a missing SetDoubleAttribute() )
+- removed TIXML_ERROR_OUT_OF_MEMORY. TinyXML does not systematically address OOO, and the notion it does is misleading.
+- vanneto, keithmarshall, others all reported the warning from IsWhiteSpace() usage. Cleaned this up - many thanks to everyone who reported this one.
+- tibur found a bug in end tag parsing
+
+
+
+
diff -urN vdr-2.0.1/tinyxml/docs/annotated.html vdr-2.0.1.reel/tinyxml/docs/annotated.html
--- vdr-2.0.1/tinyxml/docs/annotated.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/annotated.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,48 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td class="indexvalue">An attribute is a name-value pair </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td class="indexvalue"><a class="el" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a> is a base class for every class in TinyXml </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td class="indexvalue">An XML comment </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td class="indexvalue">In correct XML the declaration is the first entry in the file </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td class="indexvalue">Always the top level node </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td class="indexvalue">The element is a container class </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td class="indexvalue">A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td class="indexvalue">The parent class for everything in the Document Object Model </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td class="indexvalue">Print to memory functionality </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td class="indexvalue">XML text </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td class="indexvalue">Any tag that tinyXml doesn't recognize is saved as an unknown </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td class="indexvalue">Implements the interface to the "Visitor pattern" (see the Accept() method </td></tr>
+</table>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classes.html vdr-2.0.1.reel/tinyxml/docs/classes.html
--- vdr-2.0.1/tinyxml/docs/classes.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classes.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,38 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Alphabetical List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Class Index</h1><div class="qindex"><a class="qindex" href="#letter_T">T</a></div>
+<table align="center" width="95%" border="0" cellspacing="0" cellpadding="0">
+<tr><td><a name="letter_T"></a><table border="0" cellspacing="0" cellpadding="0"><tr><td><div class="ah">&nbsp;&nbsp;T&nbsp;&nbsp;</div></td></tr></table>
+</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>&nbsp;&nbsp;&nbsp;</td></tr><tr><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a>&nbsp;&nbsp;&nbsp;</td></tr><tr><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a>&nbsp;&nbsp;&nbsp;</td></tr></table><div class="qindex"><a class="qindex" href="#letter_T">T</a></div>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlAttribute.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlAttribute.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlAttribute.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlAttribute.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,173 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlAttribute Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlAttribute Class Reference</h1><!-- doxytag: class="TiXmlAttribute" --><!-- doxytag: inherits="TiXmlBase" -->
+<p>An attribute is a name-value pair.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlAttribute:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlAttribute.png" usemap="#TiXmlAttribute_map" alt=""/>
+  <map id="TiXmlAttribute_map" name="TiXmlAttribute_map">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,90,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlAttribute-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cfa3c8179873fd485d83003b114f8e1"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="a9cfa3c8179873fd485d83003b114f8e1" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a052213522caac3979960e0714063861d"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="a052213522caac3979960e0714063861d" args="(const std::string &amp;_name, const std::string &amp;_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a052213522caac3979960e0714063861d">TiXmlAttribute</a> (const std::string &amp;_name, const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::string constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a759d0b76fb8fcf765ecab243bc14f05e"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="a759d0b76fb8fcf765ecab243bc14f05e" args="(const char *_name, const char *_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a> (const char *_name, const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an attribute with a name and value. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a298a57287d305904ba6bd96ae6f78d3d"></a><!-- doxytag: member="TiXmlAttribute::Name" ref="a298a57287d305904ba6bd96ae6f78d3d" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">Name</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f874490eac8ca00ee0070765d0e97e3"></a><!-- doxytag: member="TiXmlAttribute::Value" ref="a0f874490eac8ca00ee0070765d0e97e3" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">Value</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87705c3ccf9ee9417beb4f7cbacd4d33"></a><!-- doxytag: member="TiXmlAttribute::ValueStr" ref="a87705c3ccf9ee9417beb4f7cbacd4d33" args="() const " -->
+const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a20ad59dc7e89a0ab265396360d50f"></a><!-- doxytag: member="TiXmlAttribute::IntValue" ref="aa1a20ad59dc7e89a0ab265396360d50f" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">IntValue</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute, converted to an integer. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2880ddef53fc7522c99535273954d230"></a><!-- doxytag: member="TiXmlAttribute::DoubleValue" ref="a2880ddef53fc7522c99535273954d230" args="() const " -->
+double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">DoubleValue</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute, converted to a double. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">QueryIntValue</a> (int *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryIntValue examines the value string.  <a href="#ad6c93088ee21af41a107931223339344"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac87b2a8489906a5d7aa2875f20be3513"></a><!-- doxytag: member="TiXmlAttribute::QueryDoubleValue" ref="ac87b2a8489906a5d7aa2875f20be3513" args="(double *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a> (double *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryDoubleValue examines the value string. See <a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344" title="QueryIntValue examines the value string.">QueryIntValue()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7fa3d21ff8d7c5764cf9af15b667a99"></a><!-- doxytag: member="TiXmlAttribute::SetName" ref="ab7fa3d21ff8d7c5764cf9af15b667a99" args="(const char *_name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">SetName</a> (const char *_name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dae44178f668b3cb48101be4f2236a0"></a><!-- doxytag: member="TiXmlAttribute::SetValue" ref="a2dae44178f668b3cb48101be4f2236a0" args="(const char *_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">SetValue</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e065df640116a62ea4f4b7da5449cc8"></a><!-- doxytag: member="TiXmlAttribute::SetIntValue" ref="a7e065df640116a62ea4f4b7da5449cc8" args="(int _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a> (int _value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value from an integer. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0316da31373496c4368ad549bf711394"></a><!-- doxytag: member="TiXmlAttribute::SetDoubleValue" ref="a0316da31373496c4368ad549bf711394" args="(double _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">SetDoubleValue</a> (double _value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value from a double. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab296ff0c9a8c701055cd257a8a976e57"></a><!-- doxytag: member="TiXmlAttribute::SetName" ref="ab296ff0c9a8c701055cd257a8a976e57" args="(const std::string &amp;_name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ab296ff0c9a8c701055cd257a8a976e57">SetName</a> (const std::string &amp;_name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab43f67a0cc3ec1d80e62606500f0925f"></a><!-- doxytag: member="TiXmlAttribute::SetValue" ref="ab43f67a0cc3ec1d80e62606500f0925f" args="(const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">SetValue</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c78e92e223a40843f644ba48ef69f67"></a><!-- doxytag: member="TiXmlAttribute::Next" ref="a1c78e92e223a40843f644ba48ef69f67" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">Next</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next sibling attribute in the DOM. Returns null at end. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ebbfe333fe76cd834bd6cbcca3130cf"></a><!-- doxytag: member="TiXmlAttribute::Previous" ref="a6ebbfe333fe76cd834bd6cbcca3130cf" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the previous sibling attribute in the DOM. Returns null at beginning. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#acc04956c1d5c4c31fe74f7a7528d109a"></a><br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>An attribute is a name-value pair. </p>
+<p>Elements have an arbitrary number of attributes, each with a unique name.</p>
+<dl class="note"><dt><b>Note:</b></dt><dd>The attributes are not TiXmlNodes, since they are not part of the tinyXML document object model. There are other suggested ways to look at this problem. </dd></dl>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="acc04956c1d5c4c31fe74f7a7528d109a"></a><!-- doxytag: member="TiXmlAttribute::Print" ref="acc04956c1d5c4c31fe74f7a7528d109a" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlAttribute::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ad6c93088ee21af41a107931223339344"></a><!-- doxytag: member="TiXmlAttribute::QueryIntValue" ref="ad6c93088ee21af41a107931223339344" args="(int *_value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlAttribute::QueryIntValue </td>
+          <td>(</td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>QueryIntValue examines the value string. </p>
+<p>It is an alternative to the <a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f" title="Return the value of this attribute, converted to an integer.">IntValue()</a> method with richer error checking. If the value is an integer, it is stored in 'value' and the call returns TIXML_SUCCESS. If it is not an integer, it returns TIXML_WRONG_TYPE.</p>
+<p>A specialized but useful call. Note that for success it returns 0, which is the opposite of almost all other TinyXml calls. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlAttribute-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlAttribute-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlAttribute-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlAttribute-members.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,63 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlAttribute Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">DoubleValue</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">IntValue</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">Name</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">Next</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a>(double *_value) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">QueryIntValue</a>(int *_value) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">SetDoubleValue</a>(double _value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a>(int _value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">SetName</a>(const char *_name)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ab296ff0c9a8c701055cd257a8a976e57">SetName</a>(const std::string &amp;_name)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>()</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a052213522caac3979960e0714063861d">TiXmlAttribute</a>(const std::string &amp;_name, const std::string &amp;_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a>(const char *_name, const char *_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">Value</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlBase.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlBase.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlBase.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlBase.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,226 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlBase Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlBase Class Reference</h1><!-- doxytag: class="TiXmlBase" -->
+<p><a class="el" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a> is a base class for every class in TinyXml.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlBase:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlBase.png" usemap="#TiXmlBase_map" alt=""/>
+  <map id="TiXmlBase_map" name="TiXmlBase_map">
+<area href="classTiXmlAttribute.html" alt="TiXmlAttribute" shape="rect" coords="0,56,108,80"/>
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="295,56,403,80"/>
+<area href="classTiXmlComment.html" alt="TiXmlComment" shape="rect" coords="0,112,108,136"/>
+<area href="classTiXmlDeclaration.html" alt="TiXmlDeclaration" shape="rect" coords="118,112,226,136"/>
+<area href="classTiXmlDocument.html" alt="TiXmlDocument" shape="rect" coords="236,112,344,136"/>
+<area href="classTiXmlElement.html" alt="TiXmlElement" shape="rect" coords="354,112,462,136"/>
+<area href="classTiXmlText.html" alt="TiXmlText" shape="rect" coords="472,112,580,136"/>
+<area href="classTiXmlUnknown.html" alt="TiXmlUnknown" shape="rect" coords="590,112,698,136"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlBase-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">Print</a> (FILE *cfile, int depth) const =0</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a0de56b3f2ef14c65091a3b916437b512"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the position, in the original source file, of this node or attribute.  <a href="#a024bceb070188df92c2a8d8852dd0853"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54bfb9b70fe6dd276e7b279cab7f003"></a><!-- doxytag: member="TiXmlBase::Column" ref="ab54bfb9b70fe6dd276e7b279cab7f003" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6b3e0f790930d4970ec30764e937b5d"></a><!-- doxytag: member="TiXmlBase::SetUserData" ref="ac6b3e0f790930d4970ec30764e937b5d" args="(void *user)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a> (void *user)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a pointer to arbitrary user data. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6559a530ca6763fc301a14d77ed28c17"></a><!-- doxytag: member="TiXmlBase::GetUserData" ref="a6559a530ca6763fc301a14d77ed28c17" args="()" -->
+void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to arbitrary user data. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0120210e4680ef2088601753ce0ede4"></a><!-- doxytag: member="TiXmlBase::GetUserData" ref="ad0120210e4680ef2088601753ce0ede4" args="() const " -->
+const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to arbitrary user data. <br/></td></tr>
+<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a> (bool condense)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The world does not agree on whether white space should be kept or not.  <a href="#a0f799ec645bfb8d8a969e83478f379c1"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4b1472531c647a25b1840a87ae42438"></a><!-- doxytag: member="TiXmlBase::IsWhiteSpaceCondensed" ref="ad4b1472531c647a25b1840a87ae42438" args="()" -->
+static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current white space setting. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a> (const TIXML_STRING &amp;str, TIXML_STRING *out)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands entities in a string.  <a href="#a6bd8c315c1acb09e34107b8736505948"></a><br/></td></tr>
+<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab242c01590191f644569fa89a080d97c"></a><!-- doxytag: member="TiXmlBase::userData" ref="ab242c01590191f644569fa89a080d97c" args="" -->
+void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Field containing a generic user pointer. <br/></td></tr>
+<tr><td colspan="2"><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a218872a0d985ae30e78c55adc4bdb196"></a><!-- doxytag: member="TiXmlBase::TiXmlNode" ref="a218872a0d985ae30e78c55adc4bdb196" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a218872a0d985ae30e78c55adc4bdb196">TiXmlNode</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlBase::TiXmlElement" ref="ab6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ab6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173617f6dfe902cf484ce5552b950475"></a><!-- doxytag: member="TiXmlBase::TiXmlDocument" ref="a173617f6dfe902cf484ce5552b950475" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a173617f6dfe902cf484ce5552b950475">TiXmlDocument</a></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p><a class="el" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a> is a base class for every class in TinyXml. </p>
+<p>It does little except to establish that TinyXml classes can be printed and provide some utility functions.</p>
+<p>In XML, the document and elements can contain other elements and other types of nodes.</p>
+<div class="fragment"><pre class="fragment">
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	</pre></div> <hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a6bd8c315c1acb09e34107b8736505948"></a><!-- doxytag: member="TiXmlBase::EncodeString" ref="a6bd8c315c1acb09e34107b8736505948" args="(const TIXML_STRING &amp;str, TIXML_STRING *out)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">static void TiXmlBase::EncodeString </td>
+          <td>(</td>
+          <td class="paramtype">const TIXML_STRING &amp;&nbsp;</td>
+          <td class="paramname"> <em>str</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TIXML_STRING *&nbsp;</td>
+          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [static]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Expands entities in a string. </p>
+<p>Note this should not contian the tag's '&lt;', '&gt;', etc, or they will be transformed into entities! </p>
+
+</div>
+</div>
+<a class="anchor" id="a0de56b3f2ef14c65091a3b916437b512"></a><!-- doxytag: member="TiXmlBase::Print" ref="a0de56b3f2ef14c65091a3b916437b512" args="(FILE *cfile, int depth) const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlBase::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implemented in <a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>, <a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a024bceb070188df92c2a8d8852dd0853"></a><!-- doxytag: member="TiXmlBase::Row" ref="a024bceb070188df92c2a8d8852dd0853" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlBase::Row </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the position, in the original source file, of this node or attribute. </p>
+<p>The row and column are 1-based. (That is the first row and first column is 1,1). If the returns values are 0 or less, then the parser does not have a row and column value.</p>
+<p>Generally, the row and column value will be set when the TiXmlDocument::Load(), <a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">TiXmlDocument::LoadFile()</a>, or any TiXmlNode::Parse() is called. It will NOT be set when the DOM was created from operator&gt;&gt;.</p>
+<p>The values reflect the initial load. Once the DOM is modified programmatically (by adding or changing nodes and attributes) the new values will NOT update to reflect changes in the document.</p>
+<p>There is a minor performance cost to computing the row and column. Computation can be disabled if <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">TiXmlDocument::SetTabSize()</a> is called with 0 as the value.</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">TiXmlDocument::SetTabSize()</a> </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="a0f799ec645bfb8d8a969e83478f379c1"></a><!-- doxytag: member="TiXmlBase::SetCondenseWhiteSpace" ref="a0f799ec645bfb8d8a969e83478f379c1" args="(bool condense)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">static void TiXmlBase::SetCondenseWhiteSpace </td>
+          <td>(</td>
+          <td class="paramtype">bool&nbsp;</td>
+          <td class="paramname"> <em>condense</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline, static]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The world does not agree on whether white space should be kept or not. </p>
+<p>In order to make everyone happy, these global, static functions are provided to set whether or not TinyXml will condense all white space into a single space or not. The default is to condense. Note changing this value is not thread safe. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlBase-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlBase-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlBase-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlBase-members.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,45 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlBase Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlBase.html">TiXmlBase</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">Print</a>(FILE *cfile, int depth) const =0</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlComment.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlComment.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlComment.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlComment.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,115 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlComment Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlComment Class Reference</h1><!-- doxytag: class="TiXmlComment" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>An XML comment.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlComment:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlComment.png" usemap="#TiXmlComment_map" alt=""/>
+  <map id="TiXmlComment_map" name="TiXmlComment_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,94,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,94,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlComment-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa3252031d3e8bd3a2bf51a1c61201b7"></a><!-- doxytag: member="TiXmlComment::TiXmlComment" ref="aaa3252031d3e8bd3a2bf51a1c61201b7" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty comment. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37e7802ef17bc03ebe5ae79bf0713d47"></a><!-- doxytag: member="TiXmlComment::TiXmlComment" ref="a37e7802ef17bc03ebe5ae79bf0713d47" args="(const char *_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a comment from text. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d6662bdc52488b9e12b3c7a0453d028"></a><!-- doxytag: member="TiXmlComment::Clone" ref="a0d6662bdc52488b9e12b3c7a0453d028" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of this Comment. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a6b316527aaa8da0370cd68c22a5a0f5f"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00fb4215c20a2399ea05ac9b9e7e68a0"></a><!-- doxytag: member="TiXmlComment::ToComment" ref="a00fb4215c20a2399ea05ac9b9e7e68a0" args="() const " -->
+virtual const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc7c7e07e13c23f17797d642981511df"></a><!-- doxytag: member="TiXmlComment::ToComment" ref="acc7c7e07e13c23f17797d642981511df" args="()" -->
+virtual <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df">ToComment</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3ac1b99fbbe9ea4fb6e14146156e43e"></a><!-- doxytag: member="TiXmlComment::Accept" ref="af3ac1b99fbbe9ea4fb6e14146156e43e" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>An XML comment. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a6b316527aaa8da0370cd68c22a5a0f5f"></a><!-- doxytag: member="TiXmlComment::Print" ref="a6b316527aaa8da0370cd68c22a5a0f5f" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlComment::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlComment-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlComment-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlComment-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlComment-members.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,109 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlComment Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlComment.html">TiXmlComment</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">Clone</a>() const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>()</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a>(const char *_value)</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a>() const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df">ToComment</a>()</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlDeclaration.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlDeclaration.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlDeclaration.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlDeclaration.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,131 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlDeclaration Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDeclaration Class Reference</h1><!-- doxytag: class="TiXmlDeclaration" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>In correct XML the declaration is the first entry in the file.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlDeclaration:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlDeclaration.png" usemap="#TiXmlDeclaration_map" alt=""/>
+  <map id="TiXmlDeclaration_map" name="TiXmlDeclaration_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,108,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,108,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlDeclaration-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0484d059bea0ea1acb47c9094382d79"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="aa0484d059bea0ea1acb47c9094382d79" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty declaration. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5556007c3c72209465081de39d9836"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="acd5556007c3c72209465081de39d9836" args="(const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a> (const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b618d1c30c25e4b7a71f31a595ee298"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="a3b618d1c30c25e4b7a71f31a595ee298" args="(const char *_version, const char *_encoding, const char *_standalone)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a> (const char *_version, const char *_encoding, const char *_standalone)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02ee557b1a4545c3219ed377c103ec76"></a><!-- doxytag: member="TiXmlDeclaration::Version" ref="a02ee557b1a4545c3219ed377c103ec76" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">Version</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version. Will return an empty string if none was found. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d974231f9e9a2f0542f15f3a46cdb76"></a><!-- doxytag: member="TiXmlDeclaration::Encoding" ref="a5d974231f9e9a2f0542f15f3a46cdb76" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encoding. Will return an empty string if none was found. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff06afc033d7ef730ec7c6825b97ad9"></a><!-- doxytag: member="TiXmlDeclaration::Standalone" ref="a9ff06afc033d7ef730ec7c6825b97ad9" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a standalone document? <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf459186040141cda7a180a6585ce2e"></a><!-- doxytag: member="TiXmlDeclaration::Clone" ref="a7cf459186040141cda7a180a6585ce2e" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this Declaration and returns it. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#abf6303db4bd05b5be554036817ff1cb4"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e085d3fefd1dbf5ccdbff729931a967"></a><!-- doxytag: member="TiXmlDeclaration::ToDeclaration" ref="a1e085d3fefd1dbf5ccdbff729931a967" args="() const " -->
+virtual const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd3d1daddcaeb9543c24bfd090969ce"></a><!-- doxytag: member="TiXmlDeclaration::ToDeclaration" ref="a6bd3d1daddcaeb9543c24bfd090969ce" args="()" -->
+virtual <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce">ToDeclaration</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22315a535983b86535cdba3458669e3e"></a><!-- doxytag: member="TiXmlDeclaration::Accept" ref="a22315a535983b86535cdba3458669e3e" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>In correct XML the declaration is the first entry in the file. </p>
+<div class="fragment"><pre class="fragment">
+		&lt;?xml version="1.0" standalone="yes"?&gt;
+	</pre></div><p>TinyXml will happily read or write files without a declaration, however. There are 3 possible attributes to the declaration: version, encoding, and standalone.</p>
+<p>Note: In this version of the code, the attributes are handled as special cases, not generic attributes, simply because there can only be at most 3 and they are always the same. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="abf6303db4bd05b5be554036817ff1cb4"></a><!-- doxytag: member="TiXmlDeclaration::Print" ref="abf6303db4bd05b5be554036817ff1cb4" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlDeclaration::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlDeclaration-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlDeclaration-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlDeclaration-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlDeclaration-members.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,113 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDeclaration Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">Clone</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a>()</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>(const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a>(const char *_version, const char *_encoding, const char *_standalone)</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">Version</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlDocument.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlDocument.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlDocument.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlDocument.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,437 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlDocument Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDocument Class Reference</h1><!-- doxytag: class="TiXmlDocument" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>Always the top level node.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlDocument:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlDocument.png" usemap="#TiXmlDocument_map" alt=""/>
+  <map id="TiXmlDocument_map" name="TiXmlDocument_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,99,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,99,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlDocument-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f5e84335708fde98400230f9f12659c"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="a9f5e84335708fde98400230f9f12659c" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty document, that has no name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4508b452d0c3061db085f3db27b8396"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="ae4508b452d0c3061db085f3db27b8396" args="(const char *documentName)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ae4508b452d0c3061db085f3db27b8396">TiXmlDocument</a> (const char *documentName)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a document with a name. The name of the document is also the filename of the xml. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6e58fb99bfa76cc613f16840022225"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="a2c6e58fb99bfa76cc613f16840022225" args="(const std::string &amp;documentName)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a> (const std::string &amp;documentName)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f">LoadFile</a> (TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the current document value.  <a href="#a4c852a889c02cf251117fd1d9fe1845f"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21c0aeb0d0a720169ad4ac89523ebe93"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="a21c0aeb0d0a720169ad4ac89523ebe93" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the current document value. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a879cdf5e981b8b2d2ef82f2546dd28fb"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a879cdf5e981b8b2d2ef82f2546dd28fb" args="(const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a879cdf5e981b8b2d2ef82f2546dd28fb">LoadFile</a> (const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the given filename. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae869f5ebf7fc54c4a1d737fb4689fd44"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="ae869f5ebf7fc54c4a1d737fb4689fd44" args="(const char *filename) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ae869f5ebf7fc54c4a1d737fb4689fd44">SaveFile</a> (const char *filename) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the given filename. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">LoadFile</a> (FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the given FILE*.  <a href="#a41f6fe7200864d1dca663d230caf8db6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf1672b4538c6d1d441f9f108aea2bf4"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="acf1672b4538c6d1d441f9f108aea2bf4" args="(FILE *) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#acf1672b4538c6d1d441f9f108aea2bf4">SaveFile</a> (FILE *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the given FILE*. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a18ae6ed34fed7991ebc220862dfac884">LoadFile</a> (const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d4fae0463f3f03679ba0b7cf6f2df52"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="a3d4fae0463f3f03679ba0b7cf6f2df52" args="(const std::string &amp;filename) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a3d4fae0463f3f03679ba0b7cf6f2df52">SaveFile</a> (const std::string &amp;filename) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; STL std::string version. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">Parse</a> (const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the given null terminated block of xml data.  <a href="#a17ebabe36926ef398e78dec0d0ad0378"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">RootElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the root element -- the only top level element -- of the document.  <a href="#ad09d17927f908f40efb406af2fb873be"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If an error occurs, Error will be set to true.  <a href="#a6dfc01a6e5d58e56acd537dfd3bdeb29"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0f689f6e09ea494ea547be8d79c25e"></a><!-- doxytag: member="TiXmlDocument::ErrorDesc" ref="a9d0f689f6e09ea494ea547be8d79c25e" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains a textual (english) description of the error if one occurs. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generally, you probably want the error string ( <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc()</a> ).  <a href="#af96fc2f3f9ec6422782bfe916c9e778f"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the location (if known) of the error.  <a href="#af30efc75e804aa2e92fb8be3a8cb676e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa90bc630ee5203c6109ca5fad3323649"></a><!-- doxytag: member="TiXmlDocument::ErrorCol" ref="aa90bc630ee5203c6109ca5fad3323649" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">ErrorCol</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The column where the error occured. See <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a> (int _tabsize)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize()</a> allows the error reporting functions (<a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol()</a>) to report the correct values for row and column.  <a href="#a51dac56316f89b35bdb7d0d433ba988e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">ClearError</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you have handled the error, it can be reset with this call.  <a href="#ac66b8c28db86363315712a3574e87c35"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">Print</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the document to standard out using formatted printing ("pretty print").  <a href="#af08389ec70ee9b2de7f800e206a18510"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8701fda1fa31b25abbc9c0df42da10e8"></a><!-- doxytag: member="TiXmlDocument::Print" ref="a8701fda1fa31b25abbc9c0df42da10e8" args="(FILE *cfile, int depth=0) const " -->
+virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">Print</a> (FILE *cfile, int depth=0) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print this Document to a FILE stream. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc977bde3e4fe85a8eb9d88a35ef5a4"></a><!-- doxytag: member="TiXmlDocument::ToDocument" ref="a1dc977bde3e4fe85a8eb9d88a35ef5a4" args="() const " -->
+virtual const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1025d942a1f328fd742d545e37efdd42"></a><!-- doxytag: member="TiXmlDocument::ToDocument" ref="a1025d942a1f328fd742d545e37efdd42" args="()" -->
+virtual <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42">ToDocument</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa545aae325d9752ad64120bc4ecf939a"></a><!-- doxytag: member="TiXmlDocument::Accept" ref="aa545aae325d9752ad64120bc4ecf939a" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exact duplicate of this node and return it.  <a href="#a4968661cab4a1f44a23329c6f8db1907"></a><br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Always the top level node. </p>
+<p>A document binds together all the XML pieces. It can be saved, loaded, and printed to the screen. The 'value' of a document node is the xml file name. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="ac66b8c28db86363315712a3574e87c35"></a><!-- doxytag: member="TiXmlDocument::ClearError" ref="ac66b8c28db86363315712a3574e87c35" args="()" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::ClearError </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>If you have handled the error, it can be reset with this call. </p>
+<p>The error state is automatically cleared if you Parse a new XML block. </p>
+
+</div>
+</div>
+<a class="anchor" id="a4968661cab4a1f44a23329c6f8db1907"></a><!-- doxytag: member="TiXmlDocument::Clone" ref="a4968661cab4a1f44a23329c6f8db1907" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlDocument::Clone </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [protected, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Create an exact duplicate of this node and return it. </p>
+<p>The memory must be deleted by the caller. </p>
+
+<p>Implements <a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a6dfc01a6e5d58e56acd537dfd3bdeb29"></a><!-- doxytag: member="TiXmlDocument::Error" ref="a6dfc01a6e5d58e56acd537dfd3bdeb29" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::Error </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>If an error occurs, Error will be set to true. </p>
+<p>Also,</p>
+<ul>
+<li>The <a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f" title="Generally, you probably want the error string ( ErrorDesc() ).">ErrorId()</a> will contain the integer identifier of the error (not generally useful)</li>
+<li>The <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc()</a> method will return the name of the error. (very useful)</li>
+<li>The <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol()</a> will return the location of the error (if known) </li>
+</ul>
+
+</div>
+</div>
+<a class="anchor" id="af96fc2f3f9ec6422782bfe916c9e778f"></a><!-- doxytag: member="TiXmlDocument::ErrorId" ref="af96fc2f3f9ec6422782bfe916c9e778f" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlDocument::ErrorId </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Generally, you probably want the error string ( <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc()</a> ). </p>
+<p>But if you prefer the ErrorId, this function will fetch it. </p>
+
+</div>
+</div>
+<a class="anchor" id="af30efc75e804aa2e92fb8be3a8cb676e"></a><!-- doxytag: member="TiXmlDocument::ErrorRow" ref="af30efc75e804aa2e92fb8be3a8cb676e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlDocument::ErrorRow </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Returns the location (if known) of the error. </p>
+<p>The first column is column 1, and the first row is row 1. A value of 0 means the row and column wasn't applicable (memory errors, for example, have no row/column) or the parser lost the error. (An error in the error reporting, in that case.)</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize</a>, <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row</a>, <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">Column</a> </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="a18ae6ed34fed7991ebc220862dfac884"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a18ae6ed34fed7991ebc220862dfac884" args="(const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>filename</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl><dt><b>Parameters:</b></dt><dd>
+  <table border="0" cellspacing="2" cellpadding="0">
+    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>STL std::string version. </td></tr>
+  </table>
+  </dd>
+</dl>
+
+<p>References <a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f">LoadFile()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a41f6fe7200864d1dca663d230caf8db6"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a41f6fe7200864d1dca663d230caf8db6" args="(FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname">, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Load a file using the given FILE*. </p>
+<p>Returns true if successful. Note that this method doesn't stream - the entire object pointed at by the FILE* will be interpreted as an XML file. TinyXML doesn't stream in XML from the current file location. Streaming may be added in the future. </p>
+
+</div>
+</div>
+<a class="anchor" id="a4c852a889c02cf251117fd1d9fe1845f"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a4c852a889c02cf251117fd1d9fe1845f" args="(TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile </td>
+          <td>(</td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Load a file using the current document value. </p>
+<p>Returns true if successful. Will delete any existing document data before loading. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01425">LoadFile()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a17ebabe36926ef398e78dec0d0ad0378"></a><!-- doxytag: member="TiXmlDocument::Parse" ref="a17ebabe36926ef398e78dec0d0ad0378" args="(const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual const char* TiXmlDocument::Parse </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>p</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlParsingData *&nbsp;</td>
+          <td class="paramname"> <em>data</em> = <code>0</code>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Parse the given null terminated block of xml data. </p>
+<p>Passing in an encoding to this method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml to use that encoding, regardless of what TinyXml might otherwise try to detect. </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="af08389ec70ee9b2de7f800e206a18510"></a><!-- doxytag: member="TiXmlDocument::Print" ref="af08389ec70ee9b2de7f800e206a18510" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::Print </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Write the document to standard out using formatted printing ("pretty print"). </p>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01512">Print()</a>.</p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01512">Print()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ad09d17927f908f40efb406af2fb873be"></a><!-- doxytag: member="TiXmlDocument::RootElement" ref="ad09d17927f908f40efb406af2fb873be" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlDocument::RootElement </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Get the root element -- the only top level element -- of the document. </p>
+<p>In well formed XML, there should only be one. TinyXml is tolerant of multiple elements at the document level. </p>
+
+<p>References <a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">TiXmlNode::FirstChildElement()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a51dac56316f89b35bdb7d0d433ba988e"></a><!-- doxytag: member="TiXmlDocument::SetTabSize" ref="a51dac56316f89b35bdb7d0d433ba988e" args="(int _tabsize)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::SetTabSize </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>_tabsize</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize()</a> allows the error reporting functions (<a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol()</a>) to report the correct values for row and column. </p>
+<p>It does not change the output or input in any way.</p>
+<p>By calling this method, with a tab size greater than 0, the row and column of each node and attribute is stored when the file is loaded. Very useful for tracking the DOM back in to the source file.</p>
+<p>The tab size is required for calculating the location of nodes. If not set, the default of 4 is used. The tabsize is set per document. Setting the tabsize to 0 disables row/column tracking.</p>
+<p>Note that row and column tracking is not supported when using operator&gt;&gt;.</p>
+<p>The tab size needs to be enabled before the parse or load. Correct usage: </p>
+<div class="fragment"><pre class="fragment">
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row</a>, <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">Column</a> </dd></dl>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlDocument-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlDocument-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlDocument-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlDocument-members.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,128 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDocument Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">ClearError</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">Clone</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [protected, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">ErrorCol</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>(TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a879cdf5e981b8b2d2ef82f2546dd28fb">LoadFile</a>(const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">LoadFile</a>(FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a18ae6ed34fed7991ebc220862dfac884">LoadFile</a>(const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">Parse</a>(const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">Print</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">Print</a>(FILE *cfile, int depth=0) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">RootElement</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ae869f5ebf7fc54c4a1d737fb4689fd44">SaveFile</a>(const char *filename) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#acf1672b4538c6d1d441f9f108aea2bf4">SaveFile</a>(FILE *) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a3d4fae0463f3f03679ba0b7cf6f2df52">SaveFile</a>(const std::string &amp;filename) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a>(int _tabsize)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ae4508b452d0c3061db085f3db27b8396">TiXmlDocument</a>(const char *documentName)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a>(const std::string &amp;documentName)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42">ToDocument</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlElement.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlElement.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlElement.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlElement.html	2013-05-09 18:10:01.611874320 +0200
@@ -0,0 +1,439 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlElement Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlElement Class Reference</h1><!-- doxytag: class="TiXmlElement" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>The element is a container class.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlElement:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlElement.png" usemap="#TiXmlElement_map" alt=""/>
+  <map id="TiXmlElement_map" name="TiXmlElement_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,87,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,87,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlElement-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01bc3ab372d35da08efcbbe65ad90c60"></a><!-- doxytag: member="TiXmlElement::TiXmlElement" ref="a01bc3ab372d35da08efcbbe65ad90c60" args="(const char *in_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a> (const char *in_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fc2e3c1a955e2f78e1a32350d180e7"></a><!-- doxytag: member="TiXmlElement::TiXmlElement" ref="a40fc2e3c1a955e2f78e1a32350d180e7" args="(const std::string &amp;_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::string constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae419a442a9701a62b0c3d8fd1cbdd12d"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="ae419a442a9701a62b0c3d8fd1cbdd12d" args="(const char *name) const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a> (const char *name) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a0ed8348fdc56b72a6b4900ce5bac1849">Attribute</a> (const char *name, int *i) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists.  <a href="#a0ed8348fdc56b72a6b4900ce5bac1849"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">Attribute</a> (const char *name, double *d) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists.  <a href="#aeaff99d4f0ea5b34f7aee202aad457ba"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a> (const char *name, int *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryIntAttribute examines the attribute - it is an alternative to the <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> method with richer error checking.  <a href="#aea0bfe471380f281c5945770ddbf52b9"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a898d7730ecc341f0bffc7a9dadbf1ce7"></a><!-- doxytag: member="TiXmlElement::QueryDoubleAttribute" ref="a898d7730ecc341f0bffc7a9dadbf1ce7" args="(const char *name, double *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a> (const char *name, double *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryDoubleAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04d3af11601ef5a5f88295203a843be"></a><!-- doxytag: member="TiXmlElement::QueryFloatAttribute" ref="aa04d3af11601ef5a5f88295203a843be" args="(const char *name, float *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a> (const char *name, float *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryFloatAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14321ac360efe906ed449d9db3fd9961"></a><!-- doxytag: member="TiXmlElement::QueryStringAttribute" ref="a14321ac360efe906ed449d9db3fd9961" args="(const char *name, std::string *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">QueryStringAttribute</a> (const char *name, std::string *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryStringAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute()</a>. <br/></td></tr>
+<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
+<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a> (const std::string &amp;name, T *outValue) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template form of the attribute query which will try to read the attribute into the specified type.  <a href="#ae3b9a03b0a56663a40801c7256683576"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#abf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a> (const char *name, const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#abf0b3bd7f0e4c746a89ec6e7f101fc32"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a80ed65b1d194c71c6c9986ae42337d7d">SetAttribute</a> (const std::string &amp;name, const std::string &amp;_value)</td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f18d54fbe25bbc527936ee65363b3c5"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="a6f18d54fbe25bbc527936ee65363b3c5" args="(const std::string &amp;name, int _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a6f18d54fbe25bbc527936ee65363b3c5">SetAttribute</a> (const std::string &amp;name, int _value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">SetAttribute</a> (const char *name, int value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#ace6f4be75e373726d4774073d666d1a7"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a> (const char *name, double value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#a0d1dd975d75496778177e35abfe0ec0b"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56979767deca794376b1dfa69a525b2a"></a><!-- doxytag: member="TiXmlElement::RemoveAttribute" ref="a56979767deca794376b1dfa69a525b2a" args="(const char *name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">RemoveAttribute</a> (const char *name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an attribute with the given name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1afa6aea716511326a608e4c05df4f3a"></a><!-- doxytag: member="TiXmlElement::RemoveAttribute" ref="a1afa6aea716511326a608e4c05df4f3a" args="(const std::string &amp;name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a">RemoveAttribute</a> (const std::string &amp;name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a516054c9073647d6cb29b6abe9fa0592"></a><!-- doxytag: member="TiXmlElement::FirstAttribute" ref="a516054c9073647d6cb29b6abe9fa0592" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first attribute in this element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86191b49f9177be132b85b14655f1381"></a><!-- doxytag: member="TiXmlElement::LastAttribute" ref="a86191b49f9177be132b85b14655f1381" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">LastAttribute</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last attribute in this element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">GetText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function for easy access to the text inside an element.  <a href="#af3282294986cdb216646ea1f67af2c87"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa464535ea1994db337cb6a8ce4b588b5"></a><!-- doxytag: member="TiXmlElement::Clone" ref="aa464535ea1994db337cb6a8ce4b588b5" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new Element and returns it - the returned element is a copy. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#afbf52736e70fc91ec9d760721d6f4fd2"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5b8d0e25fa23fd9acbb6d146082901c"></a><!-- doxytag: member="TiXmlElement::ToElement" ref="ac5b8d0e25fa23fd9acbb6d146082901c" args="() const " -->
+virtual const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">ToElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9def86337ea7a755eb41cac980f60c7a"></a><!-- doxytag: member="TiXmlElement::ToElement" ref="a9def86337ea7a755eb41cac980f60c7a" args="()" -->
+virtual <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a">ToElement</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a81b2afb0d42be1543d1c404dee6f5"></a><!-- doxytag: member="TiXmlElement::Accept" ref="a71a81b2afb0d42be1543d1c404dee6f5" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>The element is a container class. </p>
+<p>It has a value, the element name, and can contain other elements, text, comments, and unknowns. Elements also contain an arbitrary number of attributes. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="aeaff99d4f0ea5b34f7aee202aad457ba"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="aeaff99d4f0ea5b34f7aee202aad457ba" args="(const char *name, double *d) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::Attribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">double *&nbsp;</td>
+          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists. </p>
+<p>If the attribute exists and can be converted to an double, the double value will be put in the return 'd', if 'd' is non-null. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0ed8348fdc56b72a6b4900ce5bac1849"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="a0ed8348fdc56b72a6b4900ce5bac1849" args="(const char *name, int *i) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::Attribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists. </p>
+<p>If the attribute exists and can be converted to an integer, the integer value will be put in the return 'i', if 'i' is non-null. </p>
+
+</div>
+</div>
+<a class="anchor" id="af3282294986cdb216646ea1f67af2c87"></a><!-- doxytag: member="TiXmlElement::GetText" ref="af3282294986cdb216646ea1f67af2c87" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::GetText </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Convenience function for easy access to the text inside an element. </p>
+<p>Although easy and concise, <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> is limited compared to getting the <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a> child and accessing it directly.</p>
+<p>If the first child of 'this' is a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>, the <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> returns the character string of the Text node, else null is returned.</p>
+<p>This is a convenient method for getting the text of simple contained text: </p>
+<div class="fragment"><pre class="fragment">
+		&lt;foo&gt;This is text&lt;/foo&gt;
+		const char* str = fooElement-&gt;GetText();
+		</pre></div><p>'str' will be a pointer to "This is text".</p>
+<p>Note that this function can be misleading. If the element foo was created from this XML: </p>
+<div class="fragment"><pre class="fragment">
+		&lt;foo&gt;&lt;b&gt;This is text&lt;/b&gt;&lt;/foo&gt; 
+		</pre></div><p>then the value of str would be null. The first child node isn't a text node, it is another element. From this XML: </p>
+<div class="fragment"><pre class="fragment">
+		&lt;foo&gt;This is &lt;b&gt;text&lt;/b&gt;&lt;/foo&gt; 
+		</pre></div><p> <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> will return "This is ".</p>
+<p>WARNING: <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> accesses a child node - don't become confused with the similarly named <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle::Text()</a> and <a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03" title="Cast to a more defined type. Will return null if not of the requested type.">TiXmlNode::ToText()</a> which are safe type casts on the referenced node. </p>
+
+</div>
+</div>
+<a class="anchor" id="afbf52736e70fc91ec9d760721d6f4fd2"></a><!-- doxytag: member="TiXmlElement::Print" ref="afbf52736e70fc91ec9d760721d6f4fd2" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlElement::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="aea0bfe471380f281c5945770ddbf52b9"></a><!-- doxytag: member="TiXmlElement::QueryIntAttribute" ref="aea0bfe471380f281c5945770ddbf52b9" args="(const char *name, int *_value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlElement::QueryIntAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>QueryIntAttribute examines the attribute - it is an alternative to the <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> method with richer error checking. </p>
+<p>If the attribute is an integer, it is stored in 'value' and the call returns TIXML_SUCCESS. If it is not an integer, it returns TIXML_WRONG_TYPE. If the attribute does not exist, then TIXML_NO_ATTRIBUTE is returned. </p>
+
+</div>
+</div>
+<a class="anchor" id="ae3b9a03b0a56663a40801c7256683576"></a><!-- doxytag: member="TiXmlElement::QueryValueAttribute" ref="ae3b9a03b0a56663a40801c7256683576" args="(const std::string &amp;name, T *outValue) const " -->
+<div class="memitem">
+<div class="memproto">
+<div class="memtemplate">
+template&lt;typename T &gt; </div>
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlElement::QueryValueAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">T *&nbsp;</td>
+          <td class="paramname"> <em>outValue</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Template form of the attribute query which will try to read the attribute into the specified type. </p>
+<p>Very easy, very powerful, but be careful to make sure to call this with the correct type.</p>
+<p>NOTE: This method doesn't work correctly for 'string' types that contain spaces.</p>
+<dl class="return"><dt><b>Returns:</b></dt><dd>TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l00814">TiXmlAttribute::ValueStr()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ace6f4be75e373726d4774073d666d1a7"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="ace6f4be75e373726d4774073d666d1a7" args="(const char *name, int value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Sets an attribute of name to a given value. </p>
+<p>The attribute will be created if it does not exist, or changed if it does. </p>
+
+</div>
+</div>
+<a class="anchor" id="a80ed65b1d194c71c6c9986ae42337d7d"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="a80ed65b1d194c71c6c9986ae42337d7d" args="(const std::string &amp;name, const std::string &amp;_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<p>STL std::string form. </p>
+
+</div>
+</div>
+<a class="anchor" id="abf0b3bd7f0e4c746a89ec6e7f101fc32"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="abf0b3bd7f0e4c746a89ec6e7f101fc32" args="(const char *name, const char *_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Sets an attribute of name to a given value. </p>
+<p>The attribute will be created if it does not exist, or changed if it does. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0d1dd975d75496778177e35abfe0ec0b"></a><!-- doxytag: member="TiXmlElement::SetDoubleAttribute" ref="a0d1dd975d75496778177e35abfe0ec0b" args="(const char *name, double value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetDoubleAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">double&nbsp;</td>
+          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Sets an attribute of name to a given value. </p>
+<p>The attribute will be created if it does not exist, or changed if it does. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlElement-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlElement-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlElement-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlElement-members.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,127 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlElement Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlElement.html">TiXmlElement</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>(const char *name) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a0ed8348fdc56b72a6b4900ce5bac1849">Attribute</a>(const char *name, int *i) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">Attribute</a>(const char *name, double *d) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">Clone</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">GetText</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">LastAttribute</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a>(const char *name, double *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a>(const char *name, float *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a>(const char *name, int *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">QueryStringAttribute</a>(const char *name, std::string *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a>(const std::string &amp;name, T *outValue) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">RemoveAttribute</a>(const char *name)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a">RemoveAttribute</a>(const std::string &amp;name)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#abf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>(const char *name, const char *_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a80ed65b1d194c71c6c9986ae42337d7d">SetAttribute</a>(const std::string &amp;name, const std::string &amp;_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a6f18d54fbe25bbc527936ee65363b3c5">SetAttribute</a>(const std::string &amp;name, int _value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">SetAttribute</a>(const char *name, int value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a>(const char *name, double value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>(const char *in_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">ToElement</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a">ToElement</a>()</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlHandle.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlHandle.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlHandle.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlHandle.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,412 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlHandle Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlHandle Class Reference</h1><!-- doxytag: class="TiXmlHandle" -->
+<p>A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+
+<p><a href="classTiXmlHandle-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba18fd7bdefb942ecdea4bf4b8e29ec8"></a><!-- doxytag: member="TiXmlHandle::TiXmlHandle" ref="aba18fd7bdefb942ecdea4bf4b8e29ec8" args="(TiXmlNode *_node)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *_node)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a handle from any node (at any depth of the tree.) This can be a null pointer. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a236d7855e1e56ccc7b980630c48c7fd7"></a><!-- doxytag: member="TiXmlHandle::TiXmlHandle" ref="a236d7855e1e56ccc7b980630c48c7fd7" args="(const TiXmlHandle &amp;ref)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a> (const <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> &amp;ref)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb1faaf88a700b40ca2c8d9aee21139"></a><!-- doxytag: member="TiXmlHandle::FirstChild" ref="acdb1faaf88a700b40ca2c8d9aee21139" args="() const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c61f64ae9365d89c264f289085541f8"></a><!-- doxytag: member="TiXmlHandle::FirstChild" ref="a8c61f64ae9365d89c264f289085541f8" args="(const char *value) const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">FirstChild</a> (const char *value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child node with the given name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d1112e995e937e4dddb202d4113d4a"></a><!-- doxytag: member="TiXmlHandle::FirstChildElement" ref="a24d1112e995e937e4dddb202d4113d4a" args="() const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0aea751320f5e430fac6f8fff3b8dd4"></a><!-- doxytag: member="TiXmlHandle::FirstChildElement" ref="af0aea751320f5e430fac6f8fff3b8dd4" args="(const char *value) const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#af0aea751320f5e430fac6f8fff3b8dd4">FirstChildElement</a> (const char *value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child element with the given name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">Child</a> (const char *value, int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child with the given name.  <a href="#a072492b4be1acdb0db2d03cd8f71ccc4"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#af9cf6a7d08a5da94a8924425ad0cd5ac">Child</a> (int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child.  <a href="#af9cf6a7d08a5da94a8924425ad0cd5ac"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">ChildElement</a> (const char *value, int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child element with the given name.  <a href="#a979a3f850984a176ee884e394c7eed2d"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a8786475b9d1f1518492e3a46704c7ef0">ChildElement</a> (int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child element.  <a href="#a8786475b9d1f1518492e3a46704c7ef0"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">ToNode</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>.  <a href="#af678e5088e83be67baf76f699756f2c3"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>.  <a href="#abc6e7ed383a5fe1e52b0c0004b457b9e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">ToText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>.  <a href="#a4ac53a652296203a5b5e13854d923586"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">ToUnknown</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>.  <a href="#a1381c17507a130767b1e23afc93b3674"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">Node</a> () const </td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">Element</a> () const </td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">Text</a> () const </td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">Unknown</a> () const </td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing. </p>
+<p>Note that <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is not part of the TinyXml DOM structure. It is a separate utility class.</p>
+<p>Take an example: </p>
+<div class="fragment"><pre class="fragment">
+	&lt;Document&gt;
+		&lt;Element attributeA = "valueA"&gt;
+			&lt;Child attributeB = "value1" /&gt;
+			&lt;Child attributeB = "value2" /&gt;
+		&lt;/Element&gt;
+	&lt;Document&gt;
+	</pre></div><p>Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very easy to write a *lot* of code that looks like:</p>
+<div class="fragment"><pre class="fragment">
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root-&gt;FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element-&gt;FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child-&gt;NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	</pre></div><p>And that doesn't even cover "else" cases. <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> addresses the verbosity of such code. A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> checks for null pointers so it is perfectly safe and correct to use:</p>
+<div class="fragment"><pre class="fragment">
+	TiXmlHandle docHandle( &amp;document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	</pre></div><p>Which is MUCH more concise and useful.</p>
+<p>It is also safe to copy handles - internally they are nothing more than node pointers. </p>
+<div class="fragment"><pre class="fragment">
+	TiXmlHandle handleCopy = handle;
+	</pre></div><p>What they should not be used for is iteration:</p>
+<div class="fragment"><pre class="fragment">
+	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	</pre></div><p>It seems reasonable, but it is in fact two embedded while loops. The Child method is a linear walk to find the element, so this code would iterate much more than it needs to. Instead, prefer:</p>
+<div class="fragment"><pre class="fragment">
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child-&gt;NextSiblingElement() )
+	{
+		// do something
+	}
+	</pre></div> <hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="af9cf6a7d08a5da94a8924425ad0cd5ac"></a><!-- doxytag: member="TiXmlHandle::Child" ref="af9cf6a7d08a5da94a8924425ad0cd5ac" args="(int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::Child </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child. </p>
+<p>The first child is 0, the second 1, etc. </p>
+
+</div>
+</div>
+<a class="anchor" id="a072492b4be1acdb0db2d03cd8f71ccc4"></a><!-- doxytag: member="TiXmlHandle::Child" ref="a072492b4be1acdb0db2d03cd8f71ccc4" args="(const char *value, int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::Child </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child with the given name. </p>
+<p>The first child is 0, the second 1, etc. </p>
+
+</div>
+</div>
+<a class="anchor" id="a8786475b9d1f1518492e3a46704c7ef0"></a><!-- doxytag: member="TiXmlHandle::ChildElement" ref="a8786475b9d1f1518492e3a46704c7ef0" args="(int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::ChildElement </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child element. </p>
+<p>The first child element is 0, the second 1, etc. Note that only TiXmlElements are indexed: other types are not counted. </p>
+
+</div>
+</div>
+<a class="anchor" id="a979a3f850984a176ee884e394c7eed2d"></a><!-- doxytag: member="TiXmlHandle::ChildElement" ref="a979a3f850984a176ee884e394c7eed2d" args="(const char *value, int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::ChildElement </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child element with the given name. </p>
+<p>The first child element is 0, the second 1, etc. Note that only TiXmlElements are indexed: other types are not counted. </p>
+
+</div>
+</div>
+<a class="anchor" id="acb5fe8388a526289ea65e817a51e05e7"></a><!-- doxytag: member="TiXmlHandle::Element" ref="acb5fe8388a526289ea65e817a51e05e7" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlHandle::Element </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>use ToElement. Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01681">ToElement()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ab44b723a8dc9af72838a303c079d0376"></a><!-- doxytag: member="TiXmlHandle::Node" ref="ab44b723a8dc9af72838a303c079d0376" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlHandle::Node </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use ToNode. Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01678">ToNode()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a9fc739c8a18d160006f82572fc143d13"></a><!-- doxytag: member="TiXmlHandle::Text" ref="a9fc739c8a18d160006f82572fc143d13" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlText.html">TiXmlText</a>* TiXmlHandle::Text </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586" title="Return the handle as a TiXmlText.">ToText()</a> Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01684">ToText()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="abc6e7ed383a5fe1e52b0c0004b457b9e"></a><!-- doxytag: member="TiXmlHandle::ToElement" ref="abc6e7ed383a5fe1e52b0c0004b457b9e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlHandle::ToElement </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01696">Element()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="af678e5088e83be67baf76f699756f2c3"></a><!-- doxytag: member="TiXmlHandle::ToNode" ref="af678e5088e83be67baf76f699756f2c3" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlHandle::ToNode </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01692">Node()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a4ac53a652296203a5b5e13854d923586"></a><!-- doxytag: member="TiXmlHandle::ToText" ref="a4ac53a652296203a5b5e13854d923586" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlText.html">TiXmlText</a>* TiXmlHandle::ToText </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01700">Text()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a1381c17507a130767b1e23afc93b3674"></a><!-- doxytag: member="TiXmlHandle::ToUnknown" ref="a1381c17507a130767b1e23afc93b3674" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>* TiXmlHandle::ToUnknown </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01704">Unknown()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a49675b74357ba2aae124657a9a1ef465"></a><!-- doxytag: member="TiXmlHandle::Unknown" ref="a49675b74357ba2aae124657a9a1ef465" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>* TiXmlHandle::Unknown </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>use <a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674" title="Return the handle as a TiXmlUnknown.">ToUnknown()</a> Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01687">ToUnknown()</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlHandle-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlHandle-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlHandle-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlHandle-members.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,53 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlHandle Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">Child</a>(const char *value, int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#af9cf6a7d08a5da94a8924425ad0cd5ac">Child</a>(int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">ChildElement</a>(const char *value, int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a8786475b9d1f1518492e3a46704c7ef0">ChildElement</a>(int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">Element</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#af0aea751320f5e430fac6f8fff3b8dd4">FirstChildElement</a>(const char *value) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">Node</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">Text</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a>(TiXmlNode *_node)</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>(const TiXmlHandle &amp;ref)</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">ToNode</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">ToText</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">Unknown</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlNode.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlNode.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlNode.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlNode.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,718 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlNode Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlNode Class Reference</h1><!-- doxytag: class="TiXmlNode" --><!-- doxytag: inherits="TiXmlBase" -->
+<p>The parent class for everything in the Document Object Model.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlNode:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlNode.png" usemap="#TiXmlNode_map" alt=""/>
+  <map id="TiXmlNode_map" name="TiXmlNode_map">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="295,0,403,24"/>
+<area href="classTiXmlComment.html" alt="TiXmlComment" shape="rect" coords="0,112,108,136"/>
+<area href="classTiXmlDeclaration.html" alt="TiXmlDeclaration" shape="rect" coords="118,112,226,136"/>
+<area href="classTiXmlDocument.html" alt="TiXmlDocument" shape="rect" coords="236,112,344,136"/>
+<area href="classTiXmlElement.html" alt="TiXmlElement" shape="rect" coords="354,112,462,136"/>
+<area href="classTiXmlText.html" alt="TiXmlText" shape="rect" coords="472,112,580,136"/>
+<area href="classTiXmlUnknown.html" alt="TiXmlUnknown" shape="rect" coords="590,112,698,136"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlNode-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Types</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The types of XML nodes supported by TinyXml. </p>
+ <a href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">More...</a><br/></td></tr>
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The meaning of 'value' changes for the specific type of <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>.  <a href="#a77943eb90d12c2892b1337a9f5918b41"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &#39;value&#39; changes for the specific type of TiXmlNode.">Value()</a> as a std::string.  <a href="#a6d9e505619d39bf50bfd9609c9169ea5"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the value of the node.  <a href="#a2a38329ca5d3f28f98ce932b8299ae90"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2598d5f448042c1abbeae4503dd45ff2"></a><!-- doxytag: member="TiXmlNode::SetValue" ref="a2598d5f448042c1abbeae4503dd45ff2" args="(const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a708e7f953df61d4d2d12f73171550a4b"></a><!-- doxytag: member="TiXmlNode::Clear" ref="a708e7f953df61d4d2d12f73171550a4b" args="()" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all the children of this node. Does not affect 'this'. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab643043132ffd794f8602685d34a982e"></a><!-- doxytag: member="TiXmlNode::Parent" ref="ab643043132ffd794f8602685d34a982e" args="()" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One step up the DOM. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44c8eee26bbe2d1b2762038df9dde2f0"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a44c8eee26bbe2d1b2762038df9dde2f0" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node. Will be null if there are no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a> (const char *value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node with the matching 'value'.  <a href="#a1f05828d023150706eeb16d6fb3f6355"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc8bf32be6419ec453a731868de19554"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="abc8bf32be6419ec453a731868de19554" args="(const char *_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node with the matching 'value'. Will be null if none found. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6432d2b2495f6caf9cb4278df706a031"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="a6432d2b2495f6caf9cb4278df706a031" args="()" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last child of this node. Will be null if there are no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abad5bf1059c48127b958711ef89e8e5d"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="abad5bf1059c48127b958711ef89e8e5d" args="(const char *_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last child of this node matching 'value'. Will be null if there are no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07f6200a5956c723c5b52d70f29c46f6"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a07f6200a5956c723c5b52d70f29c46f6" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10d2669ccb5e29e02fcb0e4408685ef6"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a10d2669ccb5e29e02fcb0e4408685ef6" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a256d0cdbfcfeccae83f3a1c9747a8b63"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="a256d0cdbfcfeccae83f3a1c9747a8b63" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69772c9202f70553f940b15c06b07be3"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="a69772c9202f70553f940b15c06b07be3" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a> (const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alternate way to walk the children of a node.  <a href="#a8621196ba3705fa226bef4a761cc51b6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfaef35a076b9343adc1420757376c39"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="adfaef35a076b9343adc1420757376c39" args="(const char *value, const TiXmlNode *previous) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a> (const char *value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This flavor of IterateChildren searches for children with a particular 'value'. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cbaaf8e82c09ad763d52616d75724df"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="a1cbaaf8e82c09ad763d52616d75724df" args="(const std::string &amp;_value, const TiXmlNode *previous) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a> (const std::string &amp;_value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e9ad53e2f5445b14bf325c90aa862c"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="a16e9ad53e2f5445b14bf325c90aa862c" args="(const std::string &amp;_value, const TiXmlNode *previous)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a> (const std::string &amp;_value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a> (const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#ad7d4630e1a2a916edda16be22448a8ba"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#a5d29442ae46de6d0168429156197bfc6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *beforeThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#a0c146fa2fff0157b681594102f48cbc7"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *afterThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#ad9b75e54ec19301c8b4d5ff583d0b3d5"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *replaceThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;withThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a child of this node.  <a href="#a0c49e739a17b9938050c22cd89617fbd"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19d8510efc90596552f4feeac9a8fbf"></a><!-- doxytag: member="TiXmlNode::RemoveChild" ref="ae19d8510efc90596552f4feeac9a8fbf" args="(TiXmlNode *removeThis)" -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *removeThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a child of this node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2cd892768726270e511b2ab32de4d10"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="ac2cd892768726270e511b2ab32de4d10" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bdd49327eec1e609b7d22af706b8316"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="a5bdd49327eec1e609b7d22af706b8316" args="(const char *) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a> (const char *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a658276f57d35d5d4256d1dc1a2c398ab"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="a658276f57d35d5d4256d1dc1a2c398ab" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8a0434c7f401d4a3b6dee77c1a5912"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="acc8a0434c7f401d4a3b6dee77c1a5912" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b94d2f7fa7ab25a5a8e8d4340c449c9"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="a1b94d2f7fa7ab25a5a8e8d4340c449c9" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1757c1f4d01e8c9596ffdbd561c76aea"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="a1757c1f4d01e8c9596ffdbd561c76aea" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af854baeba384f5fe9859f5aee03b548e"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="af854baeba384f5fe9859f5aee03b548e" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e61c0b89a77e36a0e8c60490003cb46"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="a2e61c0b89a77e36a0e8c60490003cb46" args="(const char *) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a> (const char *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node with the given 'value'. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements.  <a href="#a73acf929d49d10bd0e5fb3d31b0372d1"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a> (const char *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements.  <a href="#a071ba77fd7ab79402fa84b7e9b8607b3"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7572d0af9d1e696ee3f05d8bb5ebb463"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a7572d0af9d1e696ee3f05d8bb5ebb463" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a506958e34406729a4e4c5326ea39d081"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a506958e34406729a4e4c5326ea39d081" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4fb652f6bd79ae0d5ce7d0f7d3c0fba"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="af4fb652f6bd79ae0d5ce7d0f7d3c0fba" args="() const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accda2c6b45c25bb5a6f9c3407a644e61"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="accda2c6b45c25bb5a6f9c3407a644e61" args="(const char *_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a> (const char *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327ad4bbd90073c5dfc931b07314f5f7"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="a327ad4bbd90073c5dfc931b07314f5f7" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f1d7291880534c1e5cdeb392d8c1f45"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="a7f1d7291880534c1e5cdeb392d8c1f45" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the type (as an enumerated value, above) of this node.  <a href="#a57b99d5c97d67a42b9752f5210a1ba5e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the Document this node lives in.  <a href="#a80e397fa973cf5323e33b07154b024f3"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed21ad30630ef6e7faf096127edc9f3"></a><!-- doxytag: member="TiXmlNode::NoChildren" ref="aeed21ad30630ef6e7faf096127edc9f3" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node has no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a4cda4b15c29f64cff419309aebed08"></a><!-- doxytag: member="TiXmlNode::ToDocument" ref="a8a4cda4b15c29f64cff419309aebed08" args="() const " -->
+virtual const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72abed96dc9667ab9e0a2a275301bb1c"></a><!-- doxytag: member="TiXmlNode::ToElement" ref="a72abed96dc9667ab9e0a2a275301bb1c" args="() const " -->
+virtual const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a5086f9eaee910bbfdc7f975e26574"></a><!-- doxytag: member="TiXmlNode::ToComment" ref="aa0a5086f9eaee910bbfdc7f975e26574" args="() const " -->
+virtual const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd7205cf31d7a376929f8a36930627a2"></a><!-- doxytag: member="TiXmlNode::ToUnknown" ref="afd7205cf31d7a376929f8a36930627a2" args="() const " -->
+virtual const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a46a52c525992d6b4ee08beb14cd69"></a><!-- doxytag: member="TiXmlNode::ToText" ref="a95a46a52c525992d6b4ee08beb14cd69" args="() const " -->
+virtual const <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f43e6984fc7d4afd6eb32714c6b7b72"></a><!-- doxytag: member="TiXmlNode::ToDeclaration" ref="a9f43e6984fc7d4afd6eb32714c6b7b72" args="() const " -->
+virtual const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a4c8ac28ee7a745d059db6691e03bae"></a><!-- doxytag: member="TiXmlNode::ToDocument" ref="a6a4c8ac28ee7a745d059db6691e03bae" args="()" -->
+virtual <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa65d000223187d22a4dcebd7479e9ebc"></a><!-- doxytag: member="TiXmlNode::ToElement" ref="aa65d000223187d22a4dcebd7479e9ebc" args="()" -->
+virtual <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a383e06a0787f7063953934867990f849"></a><!-- doxytag: member="TiXmlNode::ToComment" ref="a383e06a0787f7063953934867990f849" args="()" -->
+virtual <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06de5af852668c7e4af0d09c205f0b0d"></a><!-- doxytag: member="TiXmlNode::ToUnknown" ref="a06de5af852668c7e4af0d09c205f0b0d" args="()" -->
+virtual <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ddfbcac78fbea041fad57e5c6d60a03"></a><!-- doxytag: member="TiXmlNode::ToText" ref="a3ddfbcac78fbea041fad57e5c6d60a03" args="()" -->
+virtual <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4027136ca820ff4a636b607231b6a6df"></a><!-- doxytag: member="TiXmlNode::ToDeclaration" ref="a4027136ca820ff4a636b607231b6a6df" args="()" -->
+virtual <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a> () const =0</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exact duplicate of this node and return it.  <a href="#a4508cc3a2d7a98e96a54cc09c37a78a4"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const =0</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a hierchical visit the nodes in the TinyXML DOM.  <a href="#acc0f88b7462c6cb73809d410a4f5bb86"></a><br/></td></tr>
+<tr><td colspan="2"><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173617f6dfe902cf484ce5552b950475"></a><!-- doxytag: member="TiXmlNode::TiXmlDocument" ref="a173617f6dfe902cf484ce5552b950475" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a173617f6dfe902cf484ce5552b950475">TiXmlDocument</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlNode::TiXmlElement" ref="ab6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ab6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An input stream operator, for every class.  <a href="#ab57bd426563c926844f65a78412e18b9"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An output stream operator, for every class.  <a href="#a86cd49cfb17a844c0010b3136ac966c7"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ef17e7080df2490cf87bde380685ab"></a><!-- doxytag: member="TiXmlNode::operator&lt;&lt;" ref="a52ef17e7080df2490cf87bde380685ab" args="(std::string &amp;out, const TiXmlNode &amp;base)" -->
+std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a> (std::string &amp;out, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the XML node or attribute to a std::string. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>The parent class for everything in the Document Object Model. </p>
+<p>(Except for attributes). Nodes have siblings, a parent, and children. A node can be in a document, or stand on its own. The type of a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a> can be queried, and it can be cast to its more defined type. </p>
+<hr/><h2>Member Enumeration Documentation</h2>
+<a class="anchor" id="a836eded4920ab9e9ef28496f48cd95a2"></a><!-- doxytag: member="TiXmlNode::NodeType" ref="a836eded4920ab9e9ef28496f48cd95a2" args="" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">enum <a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">TiXmlNode::NodeType</a></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The types of XML nodes supported by TinyXml. </p>
+<p>(All the unsupported types are picked up by UNKNOWN.) </p>
+
+</div>
+</div>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="acc0f88b7462c6cb73809d410a4f5bb86"></a><!-- doxytag: member="TiXmlNode::Accept" ref="acc0f88b7462c6cb73809d410a4f5bb86" args="(TiXmlVisitor *visitor) const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual bool TiXmlNode::Accept </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *&nbsp;</td>
+          <td class="paramname"> <em>visitor</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Accept a hierchical visit the nodes in the TinyXML DOM. </p>
+<p>Every node in the XML tree will be conditionally visited and the host will be called back via the <a class="el" href="classTiXmlVisitor.html" title="Implements the interface to the &quot;Visitor pattern&quot; (see the Accept() method...">TiXmlVisitor</a> interface.</p>
+<p>This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML is unchanged by using this interface versus any other.)</p>
+<p>The interface has been based on ideas from:</p>
+<ul>
+<li><a href="http://www.saxproject.org/">http://www.saxproject.org/</a></li>
+<li><a href="http://c2.com/cgi/wiki?HierarchicalVisitorPattern">http://c2.com/cgi/wiki?HierarchicalVisitorPattern</a></li>
+</ul>
+<p>Which are both good references for "visiting".</p>
+<p>An example of using <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">Accept()</a>: </p>
+<div class="fragment"><pre class="fragment">
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &amp;printer );
+		const char* xmlcstr = printer.CStr();
+		</pre></div> 
+<p>Implemented in <a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a4508cc3a2d7a98e96a54cc09c37a78a4"></a><!-- doxytag: member="TiXmlNode::Clone" ref="a4508cc3a2d7a98e96a54cc09c37a78a4" args="() const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::Clone </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Create an exact duplicate of this node and return it. </p>
+<p>The memory must be deleted by the caller. </p>
+
+<p>Implemented in <a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a1f05828d023150706eeb16d6fb3f6355"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a1f05828d023150706eeb16d6fb3f6355" args="(const char *value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::FirstChild </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The first child of this node with the matching 'value'. </p>
+<p>Will be null if none found. </p>
+
+</div>
+</div>
+<a class="anchor" id="a80e397fa973cf5323e33b07154b024f3"></a><!-- doxytag: member="TiXmlNode::GetDocument" ref="a80e397fa973cf5323e33b07154b024f3" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>* TiXmlNode::GetDocument </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a pointer to the Document this node lives in. </p>
+<p>Returns null if not in a document. </p>
+
+</div>
+</div>
+<a class="anchor" id="ad9b75e54ec19301c8b4d5ff583d0b3d5"></a><!-- doxytag: member="TiXmlNode::InsertAfterChild" ref="ad9b75e54ec19301c8b4d5ff583d0b3d5" args="(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertAfterChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>afterThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child after the specified child. Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0c146fa2fff0157b681594102f48cbc7"></a><!-- doxytag: member="TiXmlNode::InsertBeforeChild" ref="a0c146fa2fff0157b681594102f48cbc7" args="(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertBeforeChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>beforeThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child before the specified child. Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="ad7d4630e1a2a916edda16be22448a8ba"></a><!-- doxytag: member="TiXmlNode::InsertEndChild" ref="ad7d4630e1a2a916edda16be22448a8ba" args="(const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertEndChild </td>
+          <td>(</td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child past the LastChild. Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="a8621196ba3705fa226bef4a761cc51b6"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="a8621196ba3705fa226bef4a761cc51b6" args="(const TiXmlNode *previous) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::IterateChildren </td>
+          <td>(</td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>previous</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>An alternate way to walk the children of a node. </p>
+<p>One way to iterate over nodes is: </p>
+<div class="fragment"><pre class="fragment">
+			for( child = parent-&gt;FirstChild(); child; child = child-&gt;NextSibling() )
+		</pre></div><p>IterateChildren does the same thing with the syntax: </p>
+<div class="fragment"><pre class="fragment">
+			child = 0;
+			while( child = parent-&gt;IterateChildren( child ) )
+		</pre></div><p>IterateChildren takes the previous child as input and finds the next one. If the previous child is null, it returns the first. IterateChildren will return null when done. </p>
+
+</div>
+</div>
+<a class="anchor" id="a5d29442ae46de6d0168429156197bfc6"></a><!-- doxytag: member="TiXmlNode::LinkEndChild" ref="a5d29442ae46de6d0168429156197bfc6" args="(TiXmlNode *addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::LinkEndChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child past the LastChild.</p>
+<p>NOTE: the node to be added is passed by pointer, and will be henceforth owned (and deleted) by tinyXml. This method is efficient and avoids an extra copy, but should be used with care as it uses a different memory model than the other insert functions.</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba" title="Add a new node related to this.">InsertEndChild</a> </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="a071ba77fd7ab79402fa84b7e9b8607b3"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a071ba77fd7ab79402fa84b7e9b8607b3" args="(const char *) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlNode::NextSiblingElement </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Convenience function to get through elements. </p>
+<p>Calls NextSibling and ToElement. Will skip all non-Element nodes. Returns 0 if there is not another element. </p>
+
+</div>
+</div>
+<a class="anchor" id="a73acf929d49d10bd0e5fb3d31b0372d1"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a73acf929d49d10bd0e5fb3d31b0372d1" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlNode::NextSiblingElement </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Convenience function to get through elements. </p>
+<p>Calls NextSibling and ToElement. Will skip all non-Element nodes. Returns 0 if there is not another element. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0c49e739a17b9938050c22cd89617fbd"></a><!-- doxytag: member="TiXmlNode::ReplaceChild" ref="a0c49e739a17b9938050c22cd89617fbd" args="(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::ReplaceChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>replaceThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>withThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Replace a child of this node. </p>
+<p>Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="a2a38329ca5d3f28f98ce932b8299ae90"></a><!-- doxytag: member="TiXmlNode::SetValue" ref="a2a38329ca5d3f28f98ce932b8299ae90" args="(const char *_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlNode::SetValue </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Changes the value of the node. </p>
+<p>Defined as: </p>
+<div class="fragment"><pre class="fragment">
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		</pre></div> 
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01161">TiXmlComment::TiXmlComment()</a>, and <a class="el" href="tinyxml_8h_source.html#l01213">TiXmlText::TiXmlText()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a57b99d5c97d67a42b9752f5210a1ba5e"></a><!-- doxytag: member="TiXmlNode::Type" ref="a57b99d5c97d67a42b9752f5210a1ba5e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlNode::Type </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Query the type (as an enumerated value, above) of this node. </p>
+<p>The possible types are: DOCUMENT, ELEMENT, COMMENT, UNKNOWN, TEXT, and DECLARATION. </p>
+
+</div>
+</div>
+<a class="anchor" id="a77943eb90d12c2892b1337a9f5918b41"></a><!-- doxytag: member="TiXmlNode::Value" ref="a77943eb90d12c2892b1337a9f5918b41" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlNode::Value </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The meaning of 'value' changes for the specific type of <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. </p>
+<div class="fragment"><pre class="fragment">
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		</pre></div><p>The subclasses will wrap this function. </p>
+
+</div>
+</div>
+<a class="anchor" id="a6d9e505619d39bf50bfd9609c9169ea5"></a><!-- doxytag: member="TiXmlNode::ValueStr" ref="a6d9e505619d39bf50bfd9609c9169ea5" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const std::string&amp; TiXmlNode::ValueStr </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &#39;value&#39; changes for the specific type of TiXmlNode.">Value()</a> as a std::string. </p>
+<p>If you only use STL, this is more efficient than calling <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &#39;value&#39; changes for the specific type of TiXmlNode.">Value()</a>. Only available in STL mode. </p>
+
+</div>
+</div>
+<hr/><h2>Friends And Related Function Documentation</h2>
+<a class="anchor" id="a86cd49cfb17a844c0010b3136ac966c7"></a><!-- doxytag: member="TiXmlNode::operator&lt;&lt;" ref="a86cd49cfb17a844c0010b3136ac966c7" args="(std::ostream &amp;out, const TiXmlNode &amp;base)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
+          <td>(</td>
+          <td class="paramtype">std::ostream &amp;&nbsp;</td>
+          <td class="paramname"> <em>out</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [friend]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>An output stream operator, for every class. </p>
+<p>Note that this outputs without any newlines or formatting, as opposed to <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print()</a>, which includes tabs and new lines.</p>
+<p>The operator&lt;&lt; and operator&gt;&gt; are not completely symmetric. Writing a node to a stream is very well defined. You'll get a nice stream of output, without any extra whitespace or newlines.</p>
+<p>But reading is not as well defined. (As it always is.) If you create a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> (for example) and read that from an input stream, the text needs to define an element or junk will result. This is true of all input streams, but it's worth keeping in mind.</p>
+<p>A <a class="el" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> will read nodes until it reads a root element, and all the children of that root element. </p>
+
+</div>
+</div>
+<a class="anchor" id="ab57bd426563c926844f65a78412e18b9"></a><!-- doxytag: member="TiXmlNode::operator&gt;&gt;" ref="ab57bd426563c926844f65a78412e18b9" args="(std::istream &amp;in, TiXmlNode &amp;base)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
+          <td>(</td>
+          <td class="paramtype">std::istream &amp;&nbsp;</td>
+          <td class="paramname"> <em>in</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [friend]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>An input stream operator, for every class. </p>
+<p>Tolerant of newlines and formatting, but doesn't expect them. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlNode-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlNode-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlNode-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlNode-members.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,107 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlNode Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlNode.html">TiXmlNode</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">Accept</a>(TiXmlVisitor *visitor) const =0</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a>() const =0</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">Print</a>(FILE *cfile, int depth) const =0</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlPrinter.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlPrinter.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlPrinter.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlPrinter.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,181 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlPrinter Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlPrinter Class Reference</h1><!-- doxytag: class="TiXmlPrinter" --><!-- doxytag: inherits="TiXmlVisitor" -->
+<p>Print to memory functionality.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlPrinter:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlPrinter.png" usemap="#TiXmlPrinter_map" alt=""/>
+  <map id="TiXmlPrinter_map" name="TiXmlPrinter_map">
+<area href="classTiXmlVisitor.html" alt="TiXmlVisitor" shape="rect" coords="0,0,81,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlPrinter-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a799f4f0388570cbb54c0d3c345fef7c1"></a><!-- doxytag: member="TiXmlPrinter::VisitEnter" ref="a799f4f0388570cbb54c0d3c345fef7c1" args="(const TiXmlDocument &amp;doc)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;doc)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66b33edd76c538b462f789b797a4fdf2"></a><!-- doxytag: member="TiXmlPrinter::VisitExit" ref="a66b33edd76c538b462f789b797a4fdf2" args="(const TiXmlDocument &amp;doc)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">VisitExit</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;doc)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c5e7bf8622838417a0d0bfb8f433854"></a><!-- doxytag: member="TiXmlPrinter::VisitEnter" ref="a0c5e7bf8622838417a0d0bfb8f433854" args="(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">VisitEnter</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;element, const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *firstAttribute)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1853cf2f6e63ad4b4232b4835e0acaf0"></a><!-- doxytag: member="TiXmlPrinter::VisitExit" ref="a1853cf2f6e63ad4b4232b4835e0acaf0" args="(const TiXmlElement &amp;element)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">VisitExit</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;element)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1b14d33eede2575c0743e2350f6a38"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="ace1b14d33eede2575c0743e2350f6a38" args="(const TiXmlDeclaration &amp;declaration)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">Visit</a> (const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> &amp;declaration)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a declaration. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a711e7d65d4af9ec70977568d2451fb1c"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="a711e7d65d4af9ec70977568d2451fb1c" args="(const TiXmlText &amp;text)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a711e7d65d4af9ec70977568d2451fb1c">Visit</a> (const <a class="el" href="classTiXmlText.html">TiXmlText</a> &amp;text)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a text node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83c13d6b980064b30f989f9a35498979"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="a83c13d6b980064b30f989f9a35498979" args="(const TiXmlComment &amp;comment)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">Visit</a> (const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> &amp;comment)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a comment node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2dca6dd106e8982fd3c7db1f3330970"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="ad2dca6dd106e8982fd3c7db1f3330970" args="(const TiXmlUnknown &amp;unknown)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ad2dca6dd106e8982fd3c7db1f3330970">Visit</a> (const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> &amp;unknown)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an unknow node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">SetIndent</a> (const char *_indent)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the indent characters for printing.  <a href="#a213377a4070c7e625bae59716b089e5e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb33ec7d4bad6aaeb57f4304394b133d"></a><!-- doxytag: member="TiXmlPrinter::Indent" ref="abb33ec7d4bad6aaeb57f4304394b133d" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">Indent</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the indention string. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a> (const char *_lineBreak)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the line breaking string.  <a href="#a4be1e37e69e3858c59635aa947174fe6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f1b4804a460b175ec244eb5724d96d"></a><!-- doxytag: member="TiXmlPrinter::LineBreak" ref="a11f1b4804a460b175ec244eb5724d96d" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">LineBreak</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the current line breaking string. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch over to "stream printing" which is the most dense formatting without linebreaks.  <a href="#ab23a90629e374cb1cadca090468bbd19"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859eede9597d3e0355b77757be48735e"></a><!-- doxytag: member="TiXmlPrinter::CStr" ref="a859eede9597d3e0355b77757be48735e" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">CStr</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad01375ae9199bd2f48252eaddce3039d"></a><!-- doxytag: member="TiXmlPrinter::Size" ref="ad01375ae9199bd2f48252eaddce3039d" args="()" -->
+size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">Size</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length of the result string. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bd4daf44309b41f5813a833caa0d1c9"></a><!-- doxytag: member="TiXmlPrinter::Str" ref="a3bd4daf44309b41f5813a833caa0d1c9" args="()" -->
+const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">Str</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Print to memory functionality. </p>
+<p>The <a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> is useful when you need to:</p>
+<ol type="1">
+<li>Print to memory (especially in non-STL mode)</li>
+<li>Control formatting (line endings, etc.)</li>
+</ol>
+<p>When constructed, the <a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> is in its default "pretty printing" mode. Before calling Accept() you can call methods to control the printing of the XML document. After <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">TiXmlNode::Accept()</a> is called, the printed document can be accessed via the <a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e" title="Return the result.">CStr()</a>, <a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9" title="Return the result.">Str()</a>, and <a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d" title="Return the length of the result string.">Size()</a> methods.</p>
+<p><a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> uses the Visitor API. </p>
+<div class="fragment"><pre class="fragment">
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &amp;printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	</pre></div> <hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a213377a4070c7e625bae59716b089e5e"></a><!-- doxytag: member="TiXmlPrinter::SetIndent" ref="a213377a4070c7e625bae59716b089e5e" args="(const char *_indent)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetIndent </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_indent</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Set the indent characters for printing. </p>
+<p>By default 4 spaces but tab () is also useful, or null/empty string for no indentation. </p>
+
+</div>
+</div>
+<a class="anchor" id="a4be1e37e69e3858c59635aa947174fe6"></a><!-- doxytag: member="TiXmlPrinter::SetLineBreak" ref="a4be1e37e69e3858c59635aa947174fe6" args="(const char *_lineBreak)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetLineBreak </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_lineBreak</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Set the line breaking string. </p>
+<p>By default set to newline (<br/>
+). Some operating systems prefer other characters, or can be set to the null/empty string for no indenation. </p>
+
+</div>
+</div>
+<a class="anchor" id="ab23a90629e374cb1cadca090468bbd19"></a><!-- doxytag: member="TiXmlPrinter::SetStreamPrinting" ref="ab23a90629e374cb1cadca090468bbd19" args="()" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetStreamPrinting </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Switch over to "stream printing" which is the most dense formatting without linebreaks. </p>
+<p>Common when the XML is needed for network transmission. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlPrinter-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlPrinter-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlPrinter-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlPrinter-members.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,51 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlPrinter Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">CStr</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">Indent</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">LineBreak</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">SetIndent</a>(const char *_indent)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a>(const char *_lineBreak)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">Size</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">Str</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">Visit</a>(const TiXmlDeclaration &amp;declaration)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a711e7d65d4af9ec70977568d2451fb1c">Visit</a>(const TiXmlText &amp;text)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">Visit</a>(const TiXmlComment &amp;comment)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ad2dca6dd106e8982fd3c7db1f3330970">Visit</a>(const TiXmlUnknown &amp;unknown)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a>(const TiXmlDocument &amp;doc)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">VisitEnter</a>(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">VisitExit</a>(const TiXmlDocument &amp;doc)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">VisitExit</a>(const TiXmlElement &amp;element)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlText.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlText.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlText.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlText.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,149 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlText Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlText Class Reference</h1><!-- doxytag: class="TiXmlText" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>XML text.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlText:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlText.png" usemap="#TiXmlText_map" alt=""/>
+  <map id="TiXmlText_map" name="TiXmlText_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,73,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,73,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlText-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a> (const char *initValue)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for text element.  <a href="#af659e77c6b87d684827f35a8f4895960"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a439792f6183a3d3fb6f2bc2b16fa5691"></a><!-- doxytag: member="TiXmlText::TiXmlText" ref="a439792f6183a3d3fb6f2bc2b16fa5691" args="(const std::string &amp;initValue)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a> (const std::string &amp;initValue)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a0cafbf6f236c7f02d12b2bffc2b7976b"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a6a6b83fa2271022dd97c072a2b586"></a><!-- doxytag: member="TiXmlText::CDATA" ref="ad1a6a6b83fa2271022dd97c072a2b586" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">CDATA</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether this represents text using a CDATA section. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb17ff7c5d09b2c839393445a3de5ea9"></a><!-- doxytag: member="TiXmlText::SetCDATA" ref="acb17ff7c5d09b2c839393445a3de5ea9" args="(bool _cdata)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a> (bool _cdata)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on or off a CDATA representation of text. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a895bf34ffad17f7439ab2a52b9651648"></a><!-- doxytag: member="TiXmlText::ToText" ref="a895bf34ffad17f7439ab2a52b9651648" args="() const " -->
+virtual const <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">ToText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c3a8fd3e4dbf6c0c4363a943d72f5b"></a><!-- doxytag: member="TiXmlText::ToText" ref="ae7c3a8fd3e4dbf6c0c4363a943d72f5b" args="()" -->
+virtual <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">ToText</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8483d4415ce9de6c4fa8f63d067d5de6"></a><!-- doxytag: member="TiXmlText::Accept" ref="a8483d4415ce9de6c4fa8f63d067d5de6" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c411e93a27537369479d034cc82da3b"></a><!-- doxytag: member="TiXmlText::Clone" ref="a0c411e93a27537369479d034cc82da3b" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[internal use] Creates a new Element and returns it. <br/></td></tr>
+<tr><td colspan="2"><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlText::TiXmlElement" ref="ab6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#ab6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>XML text. </p>
+<p>A text node can have 2 ways to output the next. "normal" output and CDATA. It will default to the mode it was parsed from the XML file and you generally want to leave it alone, but you can change the output mode with <a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9" title="Turns on or off a CDATA representation of text.">SetCDATA()</a> and query it with <a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586" title="Queries whether this represents text using a CDATA section.">CDATA()</a>. </p>
+<hr/><h2>Constructor &amp; Destructor Documentation</h2>
+<a class="anchor" id="af659e77c6b87d684827f35a8f4895960"></a><!-- doxytag: member="TiXmlText::TiXmlText" ref="af659e77c6b87d684827f35a8f4895960" args="(const char *initValue)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">TiXmlText::TiXmlText </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>initValue</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Constructor for text element. </p>
+<p>By default, it is treated as normal, encoded text. If you want it be output as a CDATA text element, set the parameter _cdata to 'true' </p>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l00508">TiXmlNode::SetValue()</a>.</p>
+
+</div>
+</div>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a0cafbf6f236c7f02d12b2bffc2b7976b"></a><!-- doxytag: member="TiXmlText::Print" ref="a0cafbf6f236c7f02d12b2bffc2b7976b" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlText::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlText-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlText-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlText-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlText-members.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,111 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlText Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlText.html">TiXmlText</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">CDATA</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">Clone</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [protected, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a>(bool _cdata)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a>(const char *initValue)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a>(const std::string &amp;initValue)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">ToText</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">ToText</a>()</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlUnknown.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlUnknown.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlUnknown.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlUnknown.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,111 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlUnknown Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlUnknown Class Reference</h1><!-- doxytag: class="TiXmlUnknown" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>Any tag that tinyXml doesn't recognize is saved as an unknown.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlUnknown:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlUnknown.png" usemap="#TiXmlUnknown_map" alt=""/>
+  <map id="TiXmlUnknown_map" name="TiXmlUnknown_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,94,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,94,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlUnknown-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0960bb7428b3f341da46244229604d73"></a><!-- doxytag: member="TiXmlUnknown::Clone" ref="a0960bb7428b3f341da46244229604d73" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this Unknown and returns it. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a31ba089a40fb5a1869750fce09b0bacb"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0313e5fe77987d746ac1a97a254419d"></a><!-- doxytag: member="TiXmlUnknown::ToUnknown" ref="ab0313e5fe77987d746ac1a97a254419d" args="() const " -->
+virtual const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">ToUnknown</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67c9fd22940e8c47f706a72cdd2e332c"></a><!-- doxytag: member="TiXmlUnknown::ToUnknown" ref="a67c9fd22940e8c47f706a72cdd2e332c" args="()" -->
+virtual <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c">ToUnknown</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7122e5135581b3c832a1a3217760a93"></a><!-- doxytag: member="TiXmlUnknown::Accept" ref="ad7122e5135581b3c832a1a3217760a93" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Any tag that tinyXml doesn't recognize is saved as an unknown. </p>
+<p>It is a tag of text, but should not be modified. It will be written back to the XML, unchanged, when the file is saved.</p>
+<p>DTD tags get thrown into TiXmlUnknowns. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a31ba089a40fb5a1869750fce09b0bacb"></a><!-- doxytag: member="TiXmlUnknown::Print" ref="a31ba089a40fb5a1869750fce09b0bacb" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlUnknown::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlUnknown-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlUnknown-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlUnknown-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlUnknown-members.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,107 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlUnknown Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">Clone</a>() const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c">ToUnknown</a>()</td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlVisitor.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlVisitor.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlVisitor.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlVisitor.html	2013-05-09 18:10:01.615874319 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlVisitor Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlVisitor Class Reference</h1><!-- doxytag: class="TiXmlVisitor" -->
+<p>Implements the interface to the "Visitor pattern" (see the Accept() method.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlVisitor:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlVisitor.png" usemap="#TiXmlVisitor_map" alt=""/>
+  <map id="TiXmlVisitor_map" name="TiXmlVisitor_map">
+<area href="classTiXmlPrinter.html" alt="TiXmlPrinter" shape="rect" coords="0,56,81,80"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlVisitor-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07baecb52dd7d8716ae2a48ad0956ee0"></a><!-- doxytag: member="TiXmlVisitor::VisitEnter" ref="a07baecb52dd7d8716ae2a48ad0956ee0" args="(const TiXmlDocument &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ade4f27087447e93974e975c3246ad"></a><!-- doxytag: member="TiXmlVisitor::VisitExit" ref="aa0ade4f27087447e93974e975c3246ad" args="(const TiXmlDocument &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">VisitExit</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6c6178ffa517bbdba95d70490875fff"></a><!-- doxytag: member="TiXmlVisitor::VisitEnter" ref="af6c6178ffa517bbdba95d70490875fff" args="(const TiXmlElement &amp;, const TiXmlAttribute *)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">VisitEnter</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;, const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec2b1f8116226d52f3a1b95dafd3a32c"></a><!-- doxytag: member="TiXmlVisitor::VisitExit" ref="aec2b1f8116226d52f3a1b95dafd3a32c" args="(const TiXmlElement &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">VisitExit</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad71c71ce6473fb9b4b64cd92de4a19"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="afad71c71ce6473fb9b4b64cd92de4a19" args="(const TiXmlDeclaration &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">Visit</a> (const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a declaration. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a399b8ebca5cd14664974a32d2ce029e5"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="a399b8ebca5cd14664974a32d2ce029e5" args="(const TiXmlText &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">Visit</a> (const <a class="el" href="classTiXmlText.html">TiXmlText</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a text node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a60e7a528627b31af3161972cc7fa2"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="a53a60e7a528627b31af3161972cc7fa2" args="(const TiXmlComment &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">Visit</a> (const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a comment node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e284d607d275c51dac1adb58159ce28"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="a7e284d607d275c51dac1adb58159ce28" args="(const TiXmlUnknown &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28">Visit</a> (const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an unknow node. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Implements the interface to the "Visitor pattern" (see the Accept() method. </p>
+<p>) If you call the Accept() method, it requires being passed a <a class="el" href="classTiXmlVisitor.html" title="Implements the interface to the &quot;Visitor pattern&quot; (see the Accept() method...">TiXmlVisitor</a> class to handle callbacks. For nodes that contain other nodes (Document, Element) you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves are simply called with <a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19" title="Visit a declaration.">Visit()</a>.</p>
+<p>If you return 'true' from a Visit method, recursive parsing will continue. If you return false, <b>no children of this node or its sibilings</b> will be Visited.</p>
+<p>All flavors of Visit methods have a default implementation that returns 'true' (continue visiting). You need to only override methods that are interesting to you.</p>
+<p>Generally Accept() is called on the <a class="el" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>, although all nodes suppert Visiting.</p>
+<p>You should never change the document from a callback.</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">TiXmlNode::Accept()</a> </dd></dl>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/classTiXmlVisitor-members.html vdr-2.0.1.reel/tinyxml/docs/classTiXmlVisitor-members.html
--- vdr-2.0.1/tinyxml/docs/classTiXmlVisitor-members.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/classTiXmlVisitor-members.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,43 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlVisitor Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">Visit</a>(const TiXmlDeclaration &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">Visit</a>(const TiXmlText &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">Visit</a>(const TiXmlComment &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28">Visit</a>(const TiXmlUnknown &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a>(const TiXmlDocument &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">VisitEnter</a>(const TiXmlElement &amp;, const TiXmlAttribute *)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">VisitExit</a>(const TiXmlDocument &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">VisitExit</a>(const TiXmlElement &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/deprecated.html vdr-2.0.1.reel/tinyxml/docs/deprecated.html
--- vdr-2.0.1/tinyxml/docs/deprecated.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/deprecated.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,49 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Deprecated List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+
+
+<h1><a class="anchor" id="deprecated">Deprecated List </a></h1><p><a class="anchor" id="_deprecated000002"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">TiXmlHandle::Element</a> () const  </dt>
+<dd>use ToElement. Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>. This may return null. </dd>
+</dl>
+<p><a class="anchor" id="_deprecated000001"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">TiXmlHandle::Node</a> () const  </dt>
+<dd>use ToNode. Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. This may return null. </dd>
+</dl>
+<p><a class="anchor" id="_deprecated000003"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle::Text</a> () const  </dt>
+<dd>use ToText() Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. This may return null. </dd>
+</dl>
+<p><a class="anchor" id="_deprecated000004"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">TiXmlHandle::Unknown</a> () const  </dt>
+<dd>use ToUnknown() Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>. This may return null. </dd>
+</dl>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/doxygen.css vdr-2.0.1.reel/tinyxml/docs/doxygen.css
--- vdr-2.0.1/tinyxml/docs/doxygen.css	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/doxygen.css	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,532 @@
+/* The standard CSS for doxygen */
+
+body, table, div, p, dl {
+	font-family: Lucida Grande, Verdana, Geneva, Arial, sans-serif;
+	font-size: 12px;
+}
+
+/* @group Heading Levels */
+
+h1 {
+	text-align: center;
+	font-size: 150%;
+}
+
+h2 {
+	font-size: 120%;
+}
+
+h3 {
+	font-size: 100%;
+}
+
+dt {
+	font-weight: bold;
+}
+
+div.multicol {
+	-moz-column-gap: 1em;
+	-webkit-column-gap: 1em;
+	-moz-column-count: 3;
+	-webkit-column-count: 3;
+}
+
+p.startli, p.startdd, p.starttd {
+	margin-top: 2px;
+}
+
+p.endli {
+	margin-bottom: 0px;
+}
+
+p.enddd {
+	margin-bottom: 4px;
+}
+
+p.endtd {
+	margin-bottom: 2px;
+}
+
+/* @end */
+
+caption {
+	font-weight: bold;
+}
+
+span.legend {
+        font-size: 70%;
+        text-align: center;
+}
+
+h3.version {
+        font-size: 90%;
+        text-align: center;
+}
+
+div.qindex, div.navtab{
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	padding: 2px;
+}
+
+div.qindex, div.navpath {
+	width: 100%;
+	line-height: 140%;
+}
+
+div.navtab {
+	margin-right: 15px;
+}
+
+/* @group Link Styling */
+
+a {
+	color: #153788;
+	font-weight: normal;
+	text-decoration: none;
+}
+
+.contents a:visited {
+	color: #1b77c5;
+}
+
+a:hover {
+	text-decoration: underline;
+}
+
+a.qindex {
+	font-weight: bold;
+}
+
+a.qindexHL {
+	font-weight: bold;
+	background-color: #6666cc;
+	color: #ffffff;
+	border: 1px double #9295C2;
+}
+
+.contents a.qindexHL:visited {
+        color: #ffffff;
+}
+
+a.el {
+	font-weight: bold;
+}
+
+a.elRef {
+}
+
+a.code {
+	color: #3030f0;
+}
+
+a.codeRef {
+	color: #3030f0;
+}
+
+/* @end */
+
+dl.el {
+	margin-left: -1cm;
+}
+
+.fragment {
+	font-family: monospace, fixed;
+	font-size: 105%;
+}
+
+pre.fragment {
+	border: 1px solid #CCCCCC;
+	background-color: #f5f5f5;
+	padding: 4px 6px;
+	margin: 4px 8px 4px 2px;
+	overflow: auto;
+	word-wrap: break-word;
+	font-size:  9pt;
+	line-height: 125%;
+}
+
+div.ah {
+	background-color: black;
+	font-weight: bold;
+	color: #ffffff;
+	margin-bottom: 3px;
+	margin-top: 3px
+}
+
+div.groupHeader {
+	margin-left: 16px;
+	margin-top: 12px;
+	margin-bottom: 6px;
+	font-weight: bold;
+}
+
+div.groupText {
+	margin-left: 16px;
+	font-style: italic;
+}
+
+body {
+	background: white;
+	color: black;
+	margin-right: 20px;
+	margin-left: 20px;
+}
+
+td.indexkey {
+	background-color: #e8eef2;
+	font-weight: bold;
+	border: 1px solid #CCCCCC;
+	margin: 2px 0px 2px 0;
+	padding: 2px 10px;
+}
+
+td.indexvalue {
+	background-color: #e8eef2;
+	border: 1px solid #CCCCCC;
+	padding: 2px 10px;
+	margin: 2px 0px;
+}
+
+tr.memlist {
+	background-color: #f0f0f0;
+}
+
+p.formulaDsp {
+	text-align: center;
+}
+
+img.formulaDsp {
+	
+}
+
+img.formulaInl {
+	vertical-align: middle;
+}
+
+div.center {
+	text-align: center;
+        margin-top: 0px;
+        margin-bottom: 0px;
+        padding: 0px;
+}
+
+div.center img {
+	border: 0px;
+}
+
+img.footer {
+	border: 0px;
+	vertical-align: middle;
+}
+
+/* @group Code Colorization */
+
+span.keyword {
+	color: #008000
+}
+
+span.keywordtype {
+	color: #604020
+}
+
+span.keywordflow {
+	color: #e08000
+}
+
+span.comment {
+	color: #800000
+}
+
+span.preprocessor {
+	color: #806020
+}
+
+span.stringliteral {
+	color: #002080
+}
+
+span.charliteral {
+	color: #008080
+}
+
+span.vhdldigit { 
+	color: #ff00ff 
+}
+
+span.vhdlchar { 
+	color: #000000 
+}
+
+span.vhdlkeyword { 
+	color: #700070 
+}
+
+span.vhdllogic { 
+	color: #ff0000 
+}
+
+/* @end */
+
+.search {
+	color: #003399;
+	font-weight: bold;
+}
+
+form.search {
+	margin-bottom: 0px;
+	margin-top: 0px;
+}
+
+input.search {
+	font-size: 75%;
+	color: #000080;
+	font-weight: normal;
+	background-color: #e8eef2;
+}
+
+td.tiny {
+	font-size: 75%;
+}
+
+.dirtab {
+	padding: 4px;
+	border-collapse: collapse;
+	border: 1px solid #84b0c7;
+}
+
+th.dirtab {
+	background: #e8eef2;
+	font-weight: bold;
+}
+
+hr {
+	height: 0;
+	border: none;
+	border-top: 1px solid #666;
+}
+
+/* @group Member Descriptions */
+
+.mdescLeft, .mdescRight,
+.memItemLeft, .memItemRight,
+.memTemplItemLeft, .memTemplItemRight, .memTemplParams {
+	background-color: #FAFAFA;
+	border: none;
+	margin: 4px;
+	padding: 1px 0 0 8px;
+}
+
+.mdescLeft, .mdescRight {
+	padding: 0px 8px 4px 8px;
+	color: #555;
+}
+
+.memItemLeft, .memItemRight, .memTemplParams {
+	border-top: 1px solid #ccc;
+}
+
+.memItemLeft, .memTemplItemLeft {
+        white-space: nowrap;
+}
+
+.memTemplParams {
+	color: #606060;
+        white-space: nowrap;
+}
+
+/* @end */
+
+/* @group Member Details */
+
+/* Styles for detailed member documentation */
+
+.memtemplate {
+	font-size: 80%;
+	color: #606060;
+	font-weight: normal;
+	margin-left: 3px;
+}
+
+.memnav {
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	margin-right: 15px;
+	padding: 2px;
+}
+
+.memitem {
+	padding: 0;
+	margin-bottom: 10px;
+}
+
+.memname {
+	white-space: nowrap;
+	font-weight: bold;
+}
+
+.memproto, .memdoc {
+	border: 1px solid #84b0c7;	
+}
+
+.memproto {
+	padding: 0;
+	background-color: #d5e1e8;
+	font-weight: bold;
+	-webkit-border-top-left-radius: 8px;
+	-webkit-border-top-right-radius: 8px;
+        -webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.15);
+	-moz-border-radius-topleft: 8px;
+	-moz-border-radius-topright: 8px;
+        -moz-box-shadow: rgba(0, 0, 0, 0.15) 5px 5px 5px;
+
+}
+
+.memdoc {
+	padding: 2px 5px;
+	background-color: #eef3f5;
+	border-top-width: 0;
+	-webkit-border-bottom-left-radius: 8px;
+	-webkit-border-bottom-right-radius: 8px;
+        -webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.15);
+	-moz-border-radius-bottomleft: 8px;
+	-moz-border-radius-bottomright: 8px;
+        -moz-box-shadow: rgba(0, 0, 0, 0.15) 5px 5px 5px;
+}
+
+.paramkey {
+	text-align: right;
+}
+
+.paramtype {
+	white-space: nowrap;
+}
+
+.paramname {
+	color: #602020;
+	white-space: nowrap;
+}
+.paramname em {
+	font-style: normal;
+}
+
+/* @end */
+
+/* @group Directory (tree) */
+
+/* for the tree view */
+
+.ftvtree {
+	font-family: sans-serif;
+	margin: 0.5em;
+}
+
+/* these are for tree view when used as main index */
+
+.directory {
+	font-size: 9pt;
+	font-weight: bold;
+}
+
+.directory h3 {
+	margin: 0px;
+	margin-top: 1em;
+	font-size: 11pt;
+}
+
+/*
+The following two styles can be used to replace the root node title
+with an image of your choice.  Simply uncomment the next two styles,
+specify the name of your image and be sure to set 'height' to the
+proper pixel height of your image.
+*/
+
+/*
+.directory h3.swap {
+	height: 61px;
+	background-repeat: no-repeat;
+	background-image: url("yourimage.gif");
+}
+.directory h3.swap span {
+	display: none;
+}
+*/
+
+.directory > h3 {
+	margin-top: 0;
+}
+
+.directory p {
+	margin: 0px;
+	white-space: nowrap;
+}
+
+.directory div {
+	display: none;
+	margin: 0px;
+}
+
+.directory img {
+	vertical-align: -30%;
+}
+
+/* these are for tree view when not used as main index */
+
+.directory-alt {
+	font-size: 100%;
+	font-weight: bold;
+}
+
+.directory-alt h3 {
+	margin: 0px;
+	margin-top: 1em;
+	font-size: 11pt;
+}
+
+.directory-alt > h3 {
+	margin-top: 0;
+}
+
+.directory-alt p {
+	margin: 0px;
+	white-space: nowrap;
+}
+
+.directory-alt div {
+	display: none;
+	margin: 0px;
+}
+
+.directory-alt img {
+	vertical-align: -30%;
+}
+
+/* @end */
+
+address {
+	font-style: normal;
+	color: #333;
+}
+
+table.doxtable {
+	border-collapse:collapse;
+}
+
+table.doxtable td, table.doxtable th {
+	border: 1px solid #153788;
+	padding: 3px 7px 2px;
+}
+
+table.doxtable th {
+	background-color: #254798;
+	color: #FFFFFF;
+	font-size: 110%;
+	padding-bottom: 4px;
+	padding-top: 5px;
+	text-align:left;
+}
+
diff -urN vdr-2.0.1/tinyxml/docs/files.html vdr-2.0.1.reel/tinyxml/docs/files.html
--- vdr-2.0.1/tinyxml/docs/files.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/files.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,36 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: File Index</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li class="current"><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="files.html"><span>File&nbsp;List</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>File List</h1>Here is a list of all documented files with brief descriptions:<table>
+  <tr><td class="indexkey"><b>tinystr.h</b> <a href="tinystr_8h_source.html">[code]</a></td><td class="indexvalue"></td></tr>
+  <tr><td class="indexkey"><b>tinyxml.h</b> <a href="tinyxml_8h_source.html">[code]</a></td><td class="indexvalue"></td></tr>
+</table>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x63.html vdr-2.0.1.reel/tinyxml/docs/functions_0x63.html
--- vdr-2.0.1/tinyxml/docs/functions_0x63.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x63.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,98 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li class="current"><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_c">- c -</a></h3><ul>
+<li>CDATA()
+: <a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">TiXmlText</a>
+</li>
+<li>Child()
+: <a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">TiXmlHandle</a>
+</li>
+<li>ChildElement()
+: <a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">TiXmlHandle</a>
+</li>
+<li>Clear()
+: <a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">TiXmlNode</a>
+</li>
+<li>ClearError()
+: <a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">TiXmlDocument</a>
+</li>
+<li>Clone()
+: <a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>
+, <a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>
+, <a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>
+, <a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">TiXmlText</a>
+</li>
+<li>Column()
+: <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase</a>
+</li>
+<li>CStr()
+: <a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x64.html vdr-2.0.1.reel/tinyxml/docs/functions_0x64.html
--- vdr-2.0.1/tinyxml/docs/functions_0x64.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x64.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,71 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li class="current"><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_d">- d -</a></h3><ul>
+<li>DoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">TiXmlAttribute</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x65.html vdr-2.0.1.reel/tinyxml/docs/functions_0x65.html
--- vdr-2.0.1/tinyxml/docs/functions_0x65.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x65.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,92 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li class="current"><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_e">- e -</a></h3><ul>
+<li>Element()
+: <a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">TiXmlHandle</a>
+</li>
+<li>EncodeString()
+: <a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">TiXmlBase</a>
+</li>
+<li>Encoding()
+: <a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">TiXmlDeclaration</a>
+</li>
+<li>Error()
+: <a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">TiXmlDocument</a>
+</li>
+<li>ErrorCol()
+: <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">TiXmlDocument</a>
+</li>
+<li>ErrorDesc()
+: <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">TiXmlDocument</a>
+</li>
+<li>ErrorId()
+: <a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">TiXmlDocument</a>
+</li>
+<li>ErrorRow()
+: <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x66.html vdr-2.0.1.reel/tinyxml/docs/functions_0x66.html
--- vdr-2.0.1/tinyxml/docs/functions_0x66.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x66.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li class="current"><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_f">- f -</a></h3><ul>
+<li>FirstAttribute()
+: <a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">TiXmlElement</a>
+</li>
+<li>FirstChild()
+: <a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">TiXmlHandle</a>
+</li>
+<li>FirstChildElement()
+: <a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x67.html vdr-2.0.1.reel/tinyxml/docs/functions_0x67.html
--- vdr-2.0.1/tinyxml/docs/functions_0x67.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x67.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,77 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li class="current"><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_g">- g -</a></h3><ul>
+<li>GetDocument()
+: <a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">TiXmlNode</a>
+</li>
+<li>GetText()
+: <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">TiXmlElement</a>
+</li>
+<li>GetUserData()
+: <a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x69.html vdr-2.0.1.reel/tinyxml/docs/functions_0x69.html
--- vdr-2.0.1/tinyxml/docs/functions_0x69.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x69.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li class="current"><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_i">- i -</a></h3><ul>
+<li>Indent()
+: <a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">TiXmlPrinter</a>
+</li>
+<li>InsertAfterChild()
+: <a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">TiXmlNode</a>
+</li>
+<li>InsertBeforeChild()
+: <a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">TiXmlNode</a>
+</li>
+<li>InsertEndChild()
+: <a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">TiXmlNode</a>
+</li>
+<li>IntValue()
+: <a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">TiXmlAttribute</a>
+</li>
+<li>IsWhiteSpaceCondensed()
+: <a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">TiXmlBase</a>
+</li>
+<li>IterateChildren()
+: <a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x6c.html vdr-2.0.1.reel/tinyxml/docs/functions_0x6c.html
--- vdr-2.0.1/tinyxml/docs/functions_0x6c.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x6c.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,83 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li class="current"><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_l">- l -</a></h3><ul>
+<li>LastAttribute()
+: <a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">TiXmlElement</a>
+</li>
+<li>LastChild()
+: <a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">TiXmlNode</a>
+</li>
+<li>LineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">TiXmlPrinter</a>
+</li>
+<li>LinkEndChild()
+: <a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">TiXmlNode</a>
+</li>
+<li>LoadFile()
+: <a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x6e.html vdr-2.0.1.reel/tinyxml/docs/functions_0x6e.html
--- vdr-2.0.1/tinyxml/docs/functions_0x6e.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x6e.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li class="current"><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_n">- n -</a></h3><ul>
+<li>Name()
+: <a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">TiXmlAttribute</a>
+</li>
+<li>Next()
+: <a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">TiXmlAttribute</a>
+</li>
+<li>NextSibling()
+: <a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">TiXmlNode</a>
+</li>
+<li>NextSiblingElement()
+: <a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">TiXmlNode</a>
+</li>
+<li>NoChildren()
+: <a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">TiXmlNode</a>
+</li>
+<li>Node()
+: <a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">TiXmlHandle</a>
+</li>
+<li>NodeType
+: <a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x6f.html vdr-2.0.1.reel/tinyxml/docs/functions_0x6f.html
--- vdr-2.0.1/tinyxml/docs/functions_0x6f.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x6f.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,74 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li class="current"><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_o">- o -</a></h3><ul>
+<li>operator&lt;&lt;
+: <a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">TiXmlNode</a>
+</li>
+<li>operator&gt;&gt;
+: <a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x70.html vdr-2.0.1.reel/tinyxml/docs/functions_0x70.html
--- vdr-2.0.1/tinyxml/docs/functions_0x70.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x70.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,91 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li class="current"><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_p">- p -</a></h3><ul>
+<li>Parent()
+: <a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">TiXmlNode</a>
+</li>
+<li>Parse()
+: <a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">TiXmlDocument</a>
+</li>
+<li>Previous()
+: <a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">TiXmlAttribute</a>
+</li>
+<li>PreviousSibling()
+: <a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">TiXmlNode</a>
+</li>
+<li>Print()
+: <a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>
+, <a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>
+, <a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>
+, <a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>
+, <a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>
+, <a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x71.html vdr-2.0.1.reel/tinyxml/docs/functions_0x71.html
--- vdr-2.0.1/tinyxml/docs/functions_0x71.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x71.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li class="current"><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_q">- q -</a></h3><ul>
+<li>QueryDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">TiXmlElement</a>
+</li>
+<li>QueryDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">TiXmlAttribute</a>
+</li>
+<li>QueryFloatAttribute()
+: <a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">TiXmlElement</a>
+</li>
+<li>QueryIntAttribute()
+: <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">TiXmlElement</a>
+</li>
+<li>QueryIntValue()
+: <a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">TiXmlAttribute</a>
+</li>
+<li>QueryStringAttribute()
+: <a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">TiXmlElement</a>
+</li>
+<li>QueryValueAttribute()
+: <a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x72.html vdr-2.0.1.reel/tinyxml/docs/functions_0x72.html
--- vdr-2.0.1/tinyxml/docs/functions_0x72.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x72.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,83 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li class="current"><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_r">- r -</a></h3><ul>
+<li>RemoveAttribute()
+: <a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">TiXmlElement</a>
+</li>
+<li>RemoveChild()
+: <a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">TiXmlNode</a>
+</li>
+<li>ReplaceChild()
+: <a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">TiXmlNode</a>
+</li>
+<li>RootElement()
+: <a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">TiXmlDocument</a>
+</li>
+<li>Row()
+: <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x73.html vdr-2.0.1.reel/tinyxml/docs/functions_0x73.html
--- vdr-2.0.1/tinyxml/docs/functions_0x73.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x73.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,121 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li class="current"><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_s">- s -</a></h3><ul>
+<li>SaveFile()
+: <a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">TiXmlDocument</a>
+</li>
+<li>SetAttribute()
+: <a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">TiXmlElement</a>
+</li>
+<li>SetCDATA()
+: <a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">TiXmlText</a>
+</li>
+<li>SetCondenseWhiteSpace()
+: <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">TiXmlBase</a>
+</li>
+<li>SetDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">TiXmlElement</a>
+</li>
+<li>SetDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">TiXmlAttribute</a>
+</li>
+<li>SetIndent()
+: <a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">TiXmlPrinter</a>
+</li>
+<li>SetIntValue()
+: <a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">TiXmlAttribute</a>
+</li>
+<li>SetLineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">TiXmlPrinter</a>
+</li>
+<li>SetName()
+: <a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">TiXmlAttribute</a>
+</li>
+<li>SetStreamPrinting()
+: <a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">TiXmlPrinter</a>
+</li>
+<li>SetTabSize()
+: <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument</a>
+</li>
+<li>SetUserData()
+: <a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">TiXmlBase</a>
+</li>
+<li>SetValue()
+: <a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">TiXmlAttribute</a>
+</li>
+<li>Size()
+: <a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">TiXmlPrinter</a>
+</li>
+<li>Standalone()
+: <a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">TiXmlDeclaration</a>
+</li>
+<li>Str()
+: <a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x74.html vdr-2.0.1.reel/tinyxml/docs/functions_0x74.html
--- vdr-2.0.1/tinyxml/docs/functions_0x74.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x74.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,127 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li class="current"><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_t">- t -</a></h3><ul>
+<li>Text()
+: <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle</a>
+</li>
+<li>TiXmlAttribute()
+: <a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>
+</li>
+<li>TiXmlComment()
+: <a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>
+</li>
+<li>TiXmlDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>
+</li>
+<li>TiXmlDocument()
+: <a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>
+</li>
+<li>TiXmlElement()
+: <a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>
+</li>
+<li>TiXmlHandle()
+: <a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>
+</li>
+<li>TiXmlText()
+: <a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a>
+</li>
+<li>ToComment()
+: <a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">TiXmlNode</a>
+, <a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">TiXmlComment</a>
+</li>
+<li>ToDeclaration()
+: <a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">TiXmlDeclaration</a>
+</li>
+<li>ToDocument()
+: <a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">TiXmlNode</a>
+, <a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">TiXmlDocument</a>
+</li>
+<li>ToElement()
+: <a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">TiXmlElement</a>
+, <a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">TiXmlHandle</a>
+</li>
+<li>ToNode()
+: <a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">TiXmlHandle</a>
+</li>
+<li>ToText()
+: <a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">TiXmlText</a>
+, <a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode</a>
+, <a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">TiXmlText</a>
+</li>
+<li>ToUnknown()
+: <a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">TiXmlNode</a>
+, <a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">TiXmlHandle</a>
+</li>
+<li>Type()
+: <a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x75.html vdr-2.0.1.reel/tinyxml/docs/functions_0x75.html
--- vdr-2.0.1/tinyxml/docs/functions_0x75.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x75.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,74 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li class="current"><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_u">- u -</a></h3><ul>
+<li>Unknown()
+: <a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">TiXmlHandle</a>
+</li>
+<li>userData
+: <a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_0x76.html vdr-2.0.1.reel/tinyxml/docs/functions_0x76.html
--- vdr-2.0.1/tinyxml/docs/functions_0x76.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_0x76.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,97 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li class="current"><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_v">- v -</a></h3><ul>
+<li>Value()
+: <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">TiXmlAttribute</a>
+</li>
+<li>ValueStr()
+: <a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">TiXmlNode</a>
+</li>
+<li>Version()
+: <a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">TiXmlDeclaration</a>
+</li>
+<li>Visit()
+: <a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">TiXmlVisitor</a>
+</li>
+<li>VisitEnter()
+: <a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">TiXmlVisitor</a>
+</li>
+<li>VisitExit()
+: <a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">TiXmlVisitor</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_enum.html vdr-2.0.1.reel/tinyxml/docs/functions_enum.html
--- vdr-2.0.1/tinyxml/docs/functions_enum.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_enum.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,48 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Enumerations</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li class="current"><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;<ul>
+<li>NodeType
+: <a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x63.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x63.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x63.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x63.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,97 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li class="current"><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_c">- c -</a></h3><ul>
+<li>CDATA()
+: <a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">TiXmlText</a>
+</li>
+<li>Child()
+: <a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">TiXmlHandle</a>
+</li>
+<li>ChildElement()
+: <a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">TiXmlHandle</a>
+</li>
+<li>Clear()
+: <a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">TiXmlNode</a>
+</li>
+<li>ClearError()
+: <a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">TiXmlDocument</a>
+</li>
+<li>Clone()
+: <a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>
+, <a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>
+, <a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>
+, <a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">TiXmlText</a>
+</li>
+<li>Column()
+: <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase</a>
+</li>
+<li>CStr()
+: <a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x64.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x64.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x64.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x64.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,70 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li class="current"><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_d">- d -</a></h3><ul>
+<li>DoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">TiXmlAttribute</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x65.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x65.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x65.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x65.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,91 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li class="current"><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_e">- e -</a></h3><ul>
+<li>Element()
+: <a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">TiXmlHandle</a>
+</li>
+<li>EncodeString()
+: <a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">TiXmlBase</a>
+</li>
+<li>Encoding()
+: <a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">TiXmlDeclaration</a>
+</li>
+<li>Error()
+: <a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">TiXmlDocument</a>
+</li>
+<li>ErrorCol()
+: <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">TiXmlDocument</a>
+</li>
+<li>ErrorDesc()
+: <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">TiXmlDocument</a>
+</li>
+<li>ErrorId()
+: <a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">TiXmlDocument</a>
+</li>
+<li>ErrorRow()
+: <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x66.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x66.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x66.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x66.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,81 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li class="current"><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_f">- f -</a></h3><ul>
+<li>FirstAttribute()
+: <a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">TiXmlElement</a>
+</li>
+<li>FirstChild()
+: <a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">TiXmlHandle</a>
+</li>
+<li>FirstChildElement()
+: <a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x67.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x67.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x67.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x67.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,76 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li class="current"><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_g">- g -</a></h3><ul>
+<li>GetDocument()
+: <a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">TiXmlNode</a>
+</li>
+<li>GetText()
+: <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">TiXmlElement</a>
+</li>
+<li>GetUserData()
+: <a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x69.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x69.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x69.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x69.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,88 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li class="current"><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_i">- i -</a></h3><ul>
+<li>Indent()
+: <a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">TiXmlPrinter</a>
+</li>
+<li>InsertAfterChild()
+: <a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">TiXmlNode</a>
+</li>
+<li>InsertBeforeChild()
+: <a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">TiXmlNode</a>
+</li>
+<li>InsertEndChild()
+: <a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">TiXmlNode</a>
+</li>
+<li>IntValue()
+: <a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">TiXmlAttribute</a>
+</li>
+<li>IsWhiteSpaceCondensed()
+: <a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">TiXmlBase</a>
+</li>
+<li>IterateChildren()
+: <a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x6c.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x6c.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x6c.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x6c.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li class="current"><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_l">- l -</a></h3><ul>
+<li>LastAttribute()
+: <a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">TiXmlElement</a>
+</li>
+<li>LastChild()
+: <a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">TiXmlNode</a>
+</li>
+<li>LineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">TiXmlPrinter</a>
+</li>
+<li>LinkEndChild()
+: <a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">TiXmlNode</a>
+</li>
+<li>LoadFile()
+: <a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x6e.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x6e.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x6e.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x6e.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,85 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li class="current"><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_n">- n -</a></h3><ul>
+<li>Name()
+: <a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">TiXmlAttribute</a>
+</li>
+<li>Next()
+: <a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">TiXmlAttribute</a>
+</li>
+<li>NextSibling()
+: <a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">TiXmlNode</a>
+</li>
+<li>NextSiblingElement()
+: <a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">TiXmlNode</a>
+</li>
+<li>NoChildren()
+: <a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">TiXmlNode</a>
+</li>
+<li>Node()
+: <a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">TiXmlHandle</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x70.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x70.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x70.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x70.html	2013-05-09 18:10:01.619874320 +0200
@@ -0,0 +1,90 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li class="current"><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_p">- p -</a></h3><ul>
+<li>Parent()
+: <a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">TiXmlNode</a>
+</li>
+<li>Parse()
+: <a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">TiXmlDocument</a>
+</li>
+<li>Previous()
+: <a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">TiXmlAttribute</a>
+</li>
+<li>PreviousSibling()
+: <a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">TiXmlNode</a>
+</li>
+<li>Print()
+: <a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>
+, <a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>
+, <a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>
+, <a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>
+, <a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>
+, <a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x71.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x71.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x71.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x71.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,88 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li class="current"><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_q">- q -</a></h3><ul>
+<li>QueryDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">TiXmlElement</a>
+</li>
+<li>QueryDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">TiXmlAttribute</a>
+</li>
+<li>QueryFloatAttribute()
+: <a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">TiXmlElement</a>
+</li>
+<li>QueryIntAttribute()
+: <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">TiXmlElement</a>
+</li>
+<li>QueryIntValue()
+: <a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">TiXmlAttribute</a>
+</li>
+<li>QueryStringAttribute()
+: <a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">TiXmlElement</a>
+</li>
+<li>QueryValueAttribute()
+: <a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x72.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x72.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x72.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x72.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li class="current"><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_r">- r -</a></h3><ul>
+<li>RemoveAttribute()
+: <a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">TiXmlElement</a>
+</li>
+<li>RemoveChild()
+: <a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">TiXmlNode</a>
+</li>
+<li>ReplaceChild()
+: <a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">TiXmlNode</a>
+</li>
+<li>RootElement()
+: <a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">TiXmlDocument</a>
+</li>
+<li>Row()
+: <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x73.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x73.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x73.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x73.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,120 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li class="current"><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_s">- s -</a></h3><ul>
+<li>SaveFile()
+: <a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">TiXmlDocument</a>
+</li>
+<li>SetAttribute()
+: <a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">TiXmlElement</a>
+</li>
+<li>SetCDATA()
+: <a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">TiXmlText</a>
+</li>
+<li>SetCondenseWhiteSpace()
+: <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">TiXmlBase</a>
+</li>
+<li>SetDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">TiXmlElement</a>
+</li>
+<li>SetDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">TiXmlAttribute</a>
+</li>
+<li>SetIndent()
+: <a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">TiXmlPrinter</a>
+</li>
+<li>SetIntValue()
+: <a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">TiXmlAttribute</a>
+</li>
+<li>SetLineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">TiXmlPrinter</a>
+</li>
+<li>SetName()
+: <a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">TiXmlAttribute</a>
+</li>
+<li>SetStreamPrinting()
+: <a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">TiXmlPrinter</a>
+</li>
+<li>SetTabSize()
+: <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument</a>
+</li>
+<li>SetUserData()
+: <a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">TiXmlBase</a>
+</li>
+<li>SetValue()
+: <a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">TiXmlAttribute</a>
+</li>
+<li>Size()
+: <a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">TiXmlPrinter</a>
+</li>
+<li>Standalone()
+: <a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">TiXmlDeclaration</a>
+</li>
+<li>Str()
+: <a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x74.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x74.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x74.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x74.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,126 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li class="current"><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_t">- t -</a></h3><ul>
+<li>Text()
+: <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle</a>
+</li>
+<li>TiXmlAttribute()
+: <a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>
+</li>
+<li>TiXmlComment()
+: <a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>
+</li>
+<li>TiXmlDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>
+</li>
+<li>TiXmlDocument()
+: <a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>
+</li>
+<li>TiXmlElement()
+: <a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>
+</li>
+<li>TiXmlHandle()
+: <a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>
+</li>
+<li>TiXmlText()
+: <a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a>
+</li>
+<li>ToComment()
+: <a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">TiXmlNode</a>
+, <a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">TiXmlComment</a>
+</li>
+<li>ToDeclaration()
+: <a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">TiXmlDeclaration</a>
+</li>
+<li>ToDocument()
+: <a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">TiXmlNode</a>
+, <a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">TiXmlDocument</a>
+</li>
+<li>ToElement()
+: <a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">TiXmlElement</a>
+, <a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">TiXmlHandle</a>
+</li>
+<li>ToNode()
+: <a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">TiXmlHandle</a>
+</li>
+<li>ToText()
+: <a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">TiXmlText</a>
+, <a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode</a>
+, <a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">TiXmlText</a>
+</li>
+<li>ToUnknown()
+: <a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">TiXmlNode</a>
+, <a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">TiXmlHandle</a>
+</li>
+<li>Type()
+: <a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x75.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x75.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x75.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x75.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,70 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li class="current"><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_u">- u -</a></h3><ul>
+<li>Unknown()
+: <a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">TiXmlHandle</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func_0x76.html vdr-2.0.1.reel/tinyxml/docs/functions_func_0x76.html
--- vdr-2.0.1/tinyxml/docs/functions_func_0x76.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func_0x76.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,96 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li class="current"><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_v">- v -</a></h3><ul>
+<li>Value()
+: <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">TiXmlAttribute</a>
+</li>
+<li>ValueStr()
+: <a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">TiXmlNode</a>
+</li>
+<li>Version()
+: <a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">TiXmlDeclaration</a>
+</li>
+<li>Visit()
+: <a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">TiXmlVisitor</a>
+</li>
+<li>VisitEnter()
+: <a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">TiXmlVisitor</a>
+</li>
+<li>VisitExit()
+: <a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">TiXmlVisitor</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_func.html vdr-2.0.1.reel/tinyxml/docs/functions_func.html
--- vdr-2.0.1/tinyxml/docs/functions_func.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_func.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,79 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_a">- a -</a></h3><ul>
+<li>Accept()
+: <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>
+, <a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>
+, <a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>
+</li>
+<li>Attribute()
+: <a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions.html vdr-2.0.1.reel/tinyxml/docs/functions.html
--- vdr-2.0.1/tinyxml/docs/functions.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,80 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_a">- a -</a></h3><ul>
+<li>Accept()
+: <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>
+, <a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>
+, <a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>
+</li>
+<li>Attribute()
+: <a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_rela.html vdr-2.0.1.reel/tinyxml/docs/functions_rela.html
--- vdr-2.0.1/tinyxml/docs/functions_rela.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_rela.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,51 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Related Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li class="current"><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;<ul>
+<li>operator&lt;&lt;
+: <a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">TiXmlNode</a>
+</li>
+<li>operator&gt;&gt;
+: <a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/functions_vars.html vdr-2.0.1.reel/tinyxml/docs/functions_vars.html
--- vdr-2.0.1/tinyxml/docs/functions_vars.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/functions_vars.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,48 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Variables</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li class="current"><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;<ul>
+<li>userData
+: <a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/hierarchy.html vdr-2.0.1.reel/tinyxml/docs/hierarchy.html
--- vdr-2.0.1/tinyxml/docs/hierarchy.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/hierarchy.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,54 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Hierarchical Index</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li class="current"><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Class Hierarchy</h1>This inheritance list is sorted roughly, but not completely, alphabetically:<ul>
+<li><a class="el" href="classTiXmlBase.html">TiXmlBase</a><ul>
+<li><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></li>
+<li><a class="el" href="classTiXmlNode.html">TiXmlNode</a><ul>
+<li><a class="el" href="classTiXmlComment.html">TiXmlComment</a></li>
+<li><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></li>
+<li><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></li>
+<li><a class="el" href="classTiXmlElement.html">TiXmlElement</a></li>
+<li><a class="el" href="classTiXmlText.html">TiXmlText</a></li>
+<li><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></li>
+</ul>
+</li>
+</ul>
+</li>
+<li><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></li>
+<li><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a><ul>
+<li><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></li>
+</ul>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/index.html vdr-2.0.1.reel/tinyxml/docs/index.html
--- vdr-2.0.1/tinyxml/docs/index.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/index.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,275 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Main Page</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TinyXml Documentation</h1><h3 class="version">2.6.1 </h3><h1>TinyXML </h1>
+<p>TinyXML is a simple, small, C++ XML parser that can be easily integrated into other programs.</p>
+<h2>What it does. </h2>
+<p>In brief, TinyXML parses an XML document, and builds from that a Document Object Model (DOM) that can be read, modified, and saved.</p>
+<p>XML stands for "eXtensible Markup Language." It allows you to create your own document markups. Where HTML does a very good job of marking documents for browsers, XML allows you to define any kind of document markup, for example a document that describes a "to do" list for an organizer application. XML is a very structured and convenient format. All those random file formats created to store application data can all be replaced with XML. One parser for everything.</p>
+<p>The best place for the complete, correct, and quite frankly hard to read spec is at <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a>. An intro to XML (that I really like) can be found at <a href="http://skew.org/xml/tutorial/">http://skew.org/xml/tutorial</a>.</p>
+<p>There are different ways to access and interact with XML data. TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed into a C++ objects that can be browsed and manipulated, and then written to disk or another output stream. You can also construct an XML document from scratch with C++ objects and write this to disk or another output stream.</p>
+<p>TinyXML is designed to be easy and fast to learn. It is two headers and four cpp files. Simply add these to your project and off you go. There is an example file - xmltest.cpp - to get you started.</p>
+<p>TinyXML is released under the ZLib license, so you can use it in open source or commercial code. The details of the license are at the top of every source file.</p>
+<p>TinyXML attempts to be a flexible parser, but with truly correct and compliant XML output. TinyXML should compile on any reasonably C++ compliant system. It does not rely on exceptions or RTTI. It can be compiled with or without STL support. TinyXML fully supports the UTF-8 encoding, and the first 64k character entities.</p>
+<h2>What it doesn't do. </h2>
+<p>TinyXML doesn't parse or use DTDs (Document Type Definitions) or XSLs (eXtensible Stylesheet Language.) There are other parsers out there (check out www.sourceforge.org, search for XML) that are much more fully featured. But they are also much bigger, take longer to set up in your project, have a higher learning curve, and often have a more restrictive license. If you are working with browsers or have more complete XML needs, TinyXML is not the parser for you.</p>
+<p>The following DTD syntax will not parse at this time in TinyXML:</p>
+<div class="fragment"><pre class="fragment">
+	&lt;!DOCTYPE Archiv [
+	 &lt;!ELEMENT Comment (#PCDATA)&gt;
+	]&gt;
+</pre></div><p>because TinyXML sees this as a !DOCTYPE node with an illegally embedded !ELEMENT node. This may be addressed in the future.</p>
+<h2>Tutorials. </h2>
+<p>For the impatient, here is a tutorial to get you going. A great way to get started, but it is worth your time to read this (very short) manual completely.</p>
+<ul>
+<li><a class="el" href="tutorial0.html">TinyXML Tutorial</a></li>
+</ul>
+<h2>Code Status. </h2>
+<p>TinyXML is mature, tested code. It is very stable. If you find bugs, please file a bug report on the sourceforge web site (www.sourceforge.net/projects/tinyxml). We'll get them straightened out as soon as possible.</p>
+<p>There are some areas of improvement; please check sourceforge if you are interested in working on TinyXML.</p>
+<h2>Related Projects </h2>
+<p>TinyXML projects you may find useful! (Descriptions provided by the projects.)</p>
+<ul>
+<li>
+<b>TinyXPath</b> (<a href="http://tinyxpath.sourceforge.net">http://tinyxpath.sourceforge.net</a>). TinyXPath is a small footprint XPath syntax decoder, written in C++. </li>
+<li>
+<b>TinyXML++</b> (<a href="http://code.google.com/p/ticpp/">http://code.google.com/p/ticpp/</a>). TinyXML++ is a completely new interface to TinyXML that uses MANY of the C++ strengths. Templates, exceptions, and much better error handling. </li>
+</ul>
+<h2>Features </h2>
+<h3>Using STL </h3>
+<p>TinyXML can be compiled to use or not use STL. When using STL, TinyXML uses the std::string class, and fully supports std::istream, std::ostream, operator&lt;&lt;, and operator&gt;&gt;. Many API methods have both 'const char*' and 'const std::string&amp;' forms.</p>
+<p>When STL support is compiled out, no STL files are included whatsoever. All the string classes are implemented by TinyXML itself. API methods all use the 'const char*' form for input.</p>
+<p>Use the compile time define:</p>
+<p>TIXML_USE_STL</p>
+<p>to compile one version or the other. This can be passed by the compiler, or set as the first line of "tinyxml.h".</p>
+<p>Note: If compiling the test code in Linux, setting the environment variable TINYXML_USE_STL=YES/NO will control STL compilation. In the Windows project file, STL and non STL targets are provided. In your project, It's probably easiest to add the line "#define TIXML_USE_STL" as the first line of <a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>.</p>
+<h3>UTF-8 </h3>
+<p>TinyXML supports UTF-8 allowing to manipulate XML files in any language. TinyXML also supports "legacy mode" - the encoding used before UTF-8 support and probably best described as "extended ascii".</p>
+<p>Normally, TinyXML will try to detect the correct encoding and use it. However, by setting the value of TIXML_DEFAULT_ENCODING in the header file, TinyXML can be forced to always use one encoding.</p>
+<p>TinyXML will assume Legacy Mode until one of the following occurs: </p>
+<ol>
+<li>
+If the non-standard but common "UTF-8 lead bytes" (0xef 0xbb 0xbf) begin the file or data stream, TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has an encoding="UTF-8", then TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has no encoding specified, then TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has an encoding="something else", then TinyXML will read it as Legacy Mode. In legacy mode, TinyXML will work as it did before. It's not clear what that mode does exactly, but old content should keep working. </li>
+<li>
+Until one of the above criteria is met, TinyXML runs in Legacy Mode. </li>
+</ol>
+<p>What happens if the encoding is incorrectly set or detected? TinyXML will try to read and pass through text seen as improperly encoded. You may get some strange results or mangled characters. You may want to force TinyXML to the correct mode.</p>
+<p>You may force TinyXML to Legacy Mode by using LoadFile( TIXML_ENCODING_LEGACY ) or LoadFile( filename, TIXML_ENCODING_LEGACY ). You may force it to use legacy mode all the time by setting TIXML_DEFAULT_ENCODING = TIXML_ENCODING_LEGACY. Likewise, you may force it to TIXML_ENCODING_UTF8 with the same technique.</p>
+<p>For English users, using English XML, UTF-8 is the same as low-ASCII. You don't need to be aware of UTF-8 or change your code in any way. You can think of UTF-8 as a "superset" of ASCII.</p>
+<p>UTF-8 is not a double byte format - but it is a standard encoding of Unicode! TinyXML does not use or directly support wchar, TCHAR, or Microsoft's _UNICODE at this time. It is common to see the term "Unicode" improperly refer to UTF-16, a wide byte encoding of unicode. This is a source of confusion.</p>
+<p>For "high-ascii" languages - everything not English, pretty much - TinyXML can handle all languages, at the same time, as long as the XML is encoded in UTF-8. That can be a little tricky, older programs and operating systems tend to use the "default" or "traditional" code page. Many apps (and almost all modern ones) can output UTF-8, but older or stubborn (or just broken) ones still output text in the default code page.</p>
+<p>For example, Japanese systems traditionally use SHIFT-JIS encoding. Text encoded as SHIFT-JIS can not be read by TinyXML. A good text editor can import SHIFT-JIS and then save as UTF-8.</p>
+<p>The <a href="http://skew.org/xml/tutorial/">Skew.org link</a> does a great job covering the encoding issue.</p>
+<p>The test file "utf8test.xml" is an XML containing English, Spanish, Russian, and Simplified Chinese. (Hopefully they are translated correctly). The file "utf8test.gif" is a screen capture of the XML file, rendered in IE. Note that if you don't have the correct fonts (Simplified Chinese or Russian) on your system, you won't see output that matches the GIF file even if you can parse it correctly. Also note that (at least on my Windows machine) console output is in a Western code page, so that Print() or printf() cannot correctly display the file. This is not a bug in TinyXML - just an OS issue. No data is lost or destroyed by TinyXML. The console just doesn't render UTF-8.</p>
+<h3>Entities </h3>
+<p>TinyXML recognizes the pre-defined "character entities", meaning special characters. Namely:</p>
+<div class="fragment"><pre class="fragment">
+	&amp;amp;	&amp;
+	&amp;lt;	&lt;
+	&amp;gt;	&gt;
+	&amp;quot;	"
+	&amp;apos;	'
+</pre></div><p>These are recognized when the XML document is read, and translated to there UTF-8 equivalents. For instance, text with the XML of:</p>
+<div class="fragment"><pre class="fragment">
+	Far &amp;amp; Away
+</pre></div><p>will have the Value() of "Far &amp; Away" when queried from the <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a> object, and will be written back to the XML stream/file as an ampersand. Older versions of TinyXML "preserved" character entities, but the newer versions will translate them into characters.</p>
+<p>Additionally, any character can be specified by its Unicode code point: The syntax "&amp;#xA0;" or "&amp;#160;" are both to the non-breaking space characher.</p>
+<h3>Printing </h3>
+<p>TinyXML can print output in several different ways that all have strengths and limitations.</p>
+<ul>
+<li>Print( FILE* ). Output to a std-C stream, which includes all C files as well as stdout.<ul>
+<li>"Pretty prints", but you don't have control over printing options.</li>
+<li>The output is streamed directly to the FILE object, so there is no memory overhead in the TinyXML code.</li>
+<li>used by Print() and SaveFile()</li>
+</ul>
+</li>
+</ul>
+<ul>
+<li>operator&lt;&lt;. Output to a c++ stream.<ul>
+<li>Integrates with standart C++ iostreams.</li>
+<li>Outputs in "network printing" mode without line breaks. Good for network transmission and moving XML between C++ objects, but hard for a human to read.</li>
+</ul>
+</li>
+</ul>
+<ul>
+<li><a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a>. Output to a std::string or memory buffer.<ul>
+<li>API is less concise</li>
+<li>Future printing options will be put here.</li>
+<li>Printing may change slightly in future versions as it is refined and expanded.</li>
+</ul>
+</li>
+</ul>
+<h3>Streams </h3>
+<p>With TIXML_USE_STL on TinyXML supports C++ streams (operator &lt;&lt;,&gt;&gt;) streams as well as C (FILE*) streams. There are some differences that you may need to be aware of.</p>
+<p>C style output:</p>
+<ul>
+<li>based on FILE*</li>
+<li>the Print() and SaveFile() methods</li>
+</ul>
+<p>Generates formatted output, with plenty of white space, intended to be as human-readable as possible. They are very fast, and tolerant of ill formed XML documents. For example, an XML document that contains 2 root elements and 2 declarations, will still print.</p>
+<p>C style input:</p>
+<ul>
+<li>based on FILE*</li>
+<li>the Parse() and LoadFile() methods</li>
+</ul>
+<p>A fast, tolerant read. Use whenever you don't need the C++ streams.</p>
+<p>C++ style output:</p>
+<ul>
+<li>based on std::ostream</li>
+<li>operator&lt;&lt;</li>
+</ul>
+<p>Generates condensed output, intended for network transmission rather than readability. Depending on your system's implementation of the ostream class, these may be somewhat slower. (Or may not.) Not tolerant of ill formed XML: a document should contain the correct one root element. Additional root level elements will not be streamed out.</p>
+<p>C++ style input:</p>
+<ul>
+<li>based on std::istream</li>
+<li>operator&gt;&gt;</li>
+</ul>
+<p>Reads XML from a stream, making it useful for network transmission. The tricky part is knowing when the XML document is complete, since there will almost certainly be other data in the stream. TinyXML will assume the XML data is complete after it reads the root element. Put another way, documents that are ill-constructed with more than one root element will not read correctly. Also note that operator&gt;&gt; is somewhat slower than Parse, due to both implementation of the STL and limitations of TinyXML.</p>
+<h3>White space </h3>
+<p>The world simply does not agree on whether white space should be kept, or condensed. For example, pretend the '_' is a space, and look at "Hello____world". HTML, and at least some XML parsers, will interpret this as "Hello_world". They condense white space. Some XML parsers do not, and will leave it as "Hello____world". (Remember to keep pretending the _ is a space.) Others suggest that __Hello___world__ should become Hello___world.</p>
+<p>It's an issue that hasn't been resolved to my satisfaction. TinyXML supports the first 2 approaches. Call <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1" title="The world does not agree on whether white space should be kept or not.">TiXmlBase::SetCondenseWhiteSpace( bool )</a> to set the desired behavior. The default is to condense white space.</p>
+<p>If you change the default, you should call <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1" title="The world does not agree on whether white space should be kept or not.">TiXmlBase::SetCondenseWhiteSpace( bool )</a> before making any calls to Parse XML data, and I don't recommend changing it after it has been set.</p>
+<h3>Handles </h3>
+<p>Where browsing an XML document in a robust way, it is important to check for null returns from method calls. An error safe implementation can generate a lot of code like:</p>
+<div class="fragment"><pre class="fragment">
+TiXmlElement* root = document.FirstChildElement( "Document" );
+if ( root )
+{
+	TiXmlElement* element = root-&gt;FirstChildElement( "Element" );
+	if ( element )
+	{
+		TiXmlElement* child = element-&gt;FirstChildElement( "Child" );
+		if ( child )
+		{
+			TiXmlElement* child2 = child-&gt;NextSiblingElement( "Child" );
+			if ( child2 )
+			{
+				// Finally do something useful.
+</pre></div><p>Handles have been introduced to clean this up. Using the <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> class, the previous code reduces to:</p>
+<div class="fragment"><pre class="fragment">
+TiXmlHandle docHandle( &amp;document );
+TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+if ( child2 )
+{
+	// do something useful
+</pre></div><p>Which is much easier to deal with. See <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> for more information.</p>
+<h3>Row and Column tracking </h3>
+<p>Being able to track nodes and attributes back to their origin location in source files can be very important for some applications. Additionally, knowing where parsing errors occured in the original source can be very time saving.</p>
+<p>TinyXML can tracks the row and column origin of all nodes and attributes in a text file. The <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">TiXmlBase::Row()</a> and <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">TiXmlBase::Column()</a> methods return the origin of the node in the source text. The correct tabs can be configured in <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">TiXmlDocument::SetTabSize()</a>.</p>
+<h2>Using and Installing </h2>
+<p>To Compile and Run xmltest:</p>
+<p>A Linux Makefile and a Windows Visual C++ .dsw file is provided. Simply compile and run. It will write the file demotest.xml to your disk and generate output on the screen. It also tests walking the DOM by printing out the number of nodes found using different techniques.</p>
+<p>The Linux makefile is very generic and runs on many systems - it is currently tested on mingw and MacOSX. You do not need to run 'make depend'. The dependecies have been hard coded.</p>
+<h3>Windows project file for VC6</h3>
+<ul>
+<li>
+tinyxml: tinyxml library, non-STL  </li>
+<li>
+tinyxmlSTL: tinyxml library, STL  </li>
+<li>
+tinyXmlTest: test app, non-STL  </li>
+<li>
+tinyXmlTestSTL: test app, STL  </li>
+</ul>
+<h3>Makefile</h3>
+<p>At the top of the makefile you can set:</p>
+<p>PROFILE, DEBUG, and TINYXML_USE_STL. Details (such that they are) are in the makefile.</p>
+<p>In the tinyxml directory, type "make clean" then "make". The executable file 'xmltest' will be created.</p>
+<h3>To Use in an Application:</h3>
+<p>Add tinyxml.cpp, <a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>, tinyxmlerror.cpp, tinyxmlparser.cpp, tinystr.cpp, and <a class="el" href="tinystr_8h_source.html">tinystr.h</a> to your project or make file. That's it! It should compile on any reasonably compliant C++ system. You do not need to enable exceptions or RTTI for TinyXML.</p>
+<h2>How TinyXML works. </h2>
+<p>An example is probably the best way to go. Take: </p>
+<div class="fragment"><pre class="fragment">
+	&lt;?xml version="1.0" standalone=no&gt;
+	&lt;!-- Our to do list data --&gt;
+	&lt;ToDo&gt;
+		&lt;Item priority="1"&gt; Go to the &lt;bold&gt;Toy store!&lt;/bold&gt;&lt;/Item&gt;
+		&lt;Item priority="2"&gt; Do bills&lt;/Item&gt;
+	&lt;/ToDo&gt;
+</pre></div><p>Its not much of a To Do list, but it will do. To read this file (say "demo.xml") you would create a document, and parse it in: </p>
+<div class="fragment"><pre class="fragment">
+	TiXmlDocument doc( "demo.xml" );
+	doc.LoadFile();
+</pre></div><p>And its ready to go. Now lets look at some lines and how they relate to the DOM.</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" standalone=no&gt;
+</pre></div><p>The first line is a declaration, and gets turned into the <a class="el" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a> class. It will be the first child of the document node.</p>
+<p>This is the only directive/special tag parsed by TinyXML. Generally directive tags are stored in <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a> so the commands wont be lost when it is saved back to disk.</p>
+<div class="fragment"><pre class="fragment">
+&lt;!-- Our to do list data --&gt;
+</pre></div><p>A comment. Will become a <a class="el" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a> object.</p>
+<div class="fragment"><pre class="fragment">
+&lt;ToDo&gt;
+</pre></div><p>The "ToDo" tag defines a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> object. This one does not have any attributes, but does contain 2 other elements.</p>
+<div class="fragment"><pre class="fragment">
+&lt;Item priority="1"&gt; 
+</pre></div><p>Creates another <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> which is a child of the "ToDo" element. This element has 1 attribute, with the name "priority" and the value "1".</p>
+<div class="fragment"><pre class="fragment">
+Go to the
+</pre></div><p>A <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. This is a leaf node and cannot contain other nodes. It is a child of the "Item" <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>.</p>
+<div class="fragment"><pre class="fragment">
+&lt;bold&gt;
+</pre></div><p>Another <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>, this one a child of the "Item" element.</p>
+<p>Etc.</p>
+<p>Looking at the entire object tree, you end up with: </p>
+<div class="fragment"><pre class="fragment">
+TiXmlDocument					"demo.xml"
+	TiXmlDeclaration			"version='1.0'" "standalone=no"
+	TiXmlComment				" Our to do list data"
+	TiXmlElement				"ToDo"
+		TiXmlElement			"Item" Attribtutes: priority = 1
+			TiXmlText			"Go to the "
+			TiXmlElement		"bold"
+				TiXmlText		"Toy store!"
+		TiXmlElement			"Item" Attributes: priority=2
+			TiXmlText			"Do bills"
+</pre></div><h2>Documentation </h2>
+<p>The documentation is build with Doxygen, using the 'dox' configuration file.</p>
+<h2>License </h2>
+<p>TinyXML is released under the zlib license:</p>
+<p>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.</p>
+<p>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:</p>
+<p>1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</p>
+<p>2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</p>
+<p>3. This notice may not be removed or altered from any source distribution.</p>
+<h2>References </h2>
+<p>The World Wide Web Consortium is the definitive standard body for XML, and their web pages contain huge amounts of information.</p>
+<p>The definitive spec: <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a></p>
+<p>I also recommend "XML Pocket Reference" by Robert Eckstein and published by OReilly...the book that got the whole thing started.</p>
+<h2>Contributors, Contacts, and a Brief History </h2>
+<p>Thanks very much to everyone who sends suggestions, bugs, ideas, and encouragement. It all helps, and makes this project fun. A special thanks to the contributors on the web pages that keep it lively.</p>
+<p>So many people have sent in bugs and ideas, that rather than list here we try to give credit due in the "changes.txt" file.</p>
+<p>TinyXML was originally written by Lee Thomason. (Often the "I" still in the documentation.) Lee reviews changes and releases new versions, with the help of Yves Berquin, Andrew Ellerton, and the tinyXml community.</p>
+<p>We appreciate your suggestions, and would love to know if you use TinyXML. Hopefully you will enjoy it and find it useful. Please post questions, comments, file bugs, or contact us at:</p>
+<p>www.sourceforge.net/projects/tinyxml</p>
+<p>Lee Thomason, Yves Berquin, Andrew Ellerton </p>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/pages.html vdr-2.0.1.reel/tinyxml/docs/pages.html
--- vdr-2.0.1/tinyxml/docs/pages.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/pages.html	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,31 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Page Index</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Related Pages</h1>Here is a list of all related documentation pages:<ul>
+<li><a class="el" href="deprecated.html">Deprecated List</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/entries vdr-2.0.1.reel/tinyxml/docs/.svn/entries
--- vdr-2.0.1/tinyxml/docs/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/entries	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,2986 @@
+10
+
+dir
+19489
+svn://reelbox.org/testing/src/vdr-1.7/tinyxml/docs
+svn://reelbox.org
+
+
+
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+12be777f-adf9-0310-842f-e37ecc4c7426
+
+classTiXmlNode.png
+file
+
+
+
+
+2013-05-03T17:03:38.854701Z
+900c36fcc5deebdade281a1a0eabdb49
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1303
+
+functions_func_0x69.html
+file
+
+
+
+
+2013-05-03T17:03:38.854701Z
+e6d7bba2e64f1439390471be0c580a80
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4003
+
+functions_0x6e.html
+file
+
+
+
+
+2013-05-03T17:03:38.858701Z
+3634f95b6c9d536a39f9a1623c7f9add
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4046
+
+classTiXmlDeclaration-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.858701Z
+1cf21ad8535912969bf34d2e8a73850c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+20501
+
+functions_func.html
+file
+
+
+
+
+2013-05-03T17:03:38.858701Z
+518b6bc6760d273abc93f89855e52160
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3977
+
+functions_0x71.html
+file
+
+
+
+
+2013-05-03T17:03:38.862701Z
+71d972c61be2c99d175fdc52a6b455b3
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4139
+
+classTiXmlPrinter.html
+file
+
+
+
+
+2013-05-03T17:03:38.862701Z
+a8f953dd5e99c67d5ba5b628a83faeeb
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+14684
+
+functions_0x63.html
+file
+
+
+
+
+2013-05-03T17:03:38.862701Z
+5a4f85a5a59a7010b9d6d25da799a61c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4729
+
+classTiXmlText.html
+file
+
+
+
+
+2013-05-03T17:03:38.866701Z
+50c8ceba03b86f74672f34ab967e57cd
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+10566
+
+functions_0x75.html
+file
+
+
+
+
+2013-05-03T17:03:38.866701Z
+d8c0ba7383ce62b61c261ba947dd3459
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3462
+
+functions_0x67.html
+file
+
+
+
+
+2013-05-03T17:03:38.866701Z
+ec9a332138e47743a72ef411668f07af
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3584
+
+classes.html
+file
+
+
+
+
+2013-05-03T17:03:38.866701Z
+14abd2ff0c2e899d58eca22acedacf5f
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2809
+
+classTiXmlAttribute-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.870701Z
+b6c5e9bb5ac5390c15916f66adb75673
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8304
+
+classTiXmlHandle.html
+file
+
+
+
+
+2013-05-03T17:03:38.870701Z
+36a9fd67136a1650f9c747e595dd6d76
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+25214
+
+doxygen.css
+file
+
+
+
+
+2013-05-03T17:03:38.874701Z
+7732da2a47781c1551549545f118d9a3
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7131
+
+functions_func_0x70.html
+file
+
+
+
+
+2013-05-03T17:03:38.874701Z
+889c69f6b738c1c42c33d457fb613d55
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4525
+
+files.html
+file
+
+
+
+
+2013-05-03T17:03:38.874701Z
+5d5e36fbb413ae55aae1df53c23d674d
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1548
+
+functions_vars.html
+file
+
+
+
+
+2013-05-03T17:03:38.874701Z
+66bdfcf12b4e5ce29830414c4bb54969
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1929
+
+functions_func_0x74.html
+file
+
+
+
+
+2013-05-03T17:03:38.874701Z
+f3524bf08c088606f58f21d7f47ab071
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+6092
+
+functions_func_0x66.html
+file
+
+
+
+
+2013-05-03T17:03:38.878701Z
+7bfa6b154e136f55ce4860f7405be86a
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3988
+
+index.html
+file
+
+
+
+
+2013-05-03T17:03:38.878701Z
+dc81969d8d169caba1c44b3957fb1025
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+24431
+
+classTiXmlDeclaration.png
+file
+
+
+
+
+2013-05-03T17:03:38.878701Z
+485241e13520a6aa03590c380e4d9751
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+557
+
+functions_0x6f.html
+file
+
+
+
+
+2013-05-03T17:03:38.882701Z
+bc05f2477bef4dc9e87df521b7a546ca
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3473
+
+tabs.css
+file
+
+
+
+
+2013-05-03T17:03:38.742701Z
+c1ee53b84ad062b911957f90dc631dd2
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1844
+
+hierarchy.html
+file
+
+
+
+
+2013-05-03T17:03:38.742701Z
+51d08f1d84e9fcac34eff53d11d4ae2b
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2343
+
+classTiXmlPrinter-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.746701Z
+e40d4cbf9a4fe523131b6d3f297600aa
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5515
+
+classTiXmlText-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.746701Z
+5339d1530cf1635e29971c53213402bb
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+19711
+
+classTiXmlDocument.html
+file
+
+
+
+
+2013-05-03T17:03:38.750701Z
+9a958c840c51bf067149cf95ed2b72db
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+30742
+
+tutorial0.html
+file
+
+
+
+
+2013-05-03T17:03:38.750701Z
+52c42be50d370e8f869b5eee75547680
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+23226
+
+functions_func_0x6e.html
+file
+
+
+
+
+2013-05-03T17:03:38.754701Z
+f910278a28c877df74bd409312baf089
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3861
+
+classTiXmlHandle-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.754701Z
+063720475ed4d42bd97019cef87adafc
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5695
+
+functions_0x72.html
+file
+
+
+
+
+2013-05-03T17:03:38.754701Z
+5feaa7b209d0798c12ba2cb610a850b4
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3823
+
+functions_0x64.html
+file
+
+
+
+
+2013-05-03T17:03:38.754701Z
+3dc40ec0fa3a63e26ea943b6877f6a64
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3362
+
+functions_0x76.html
+file
+
+
+
+
+2013-05-03T17:03:38.758701Z
+165130b96d969c1f64911131086cbfd0
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5012
+
+doxygen.png
+file
+
+
+
+
+2013-05-03T17:03:38.758701Z
+33f874b8cd0ceafd80ccad649e6e7846
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1281
+
+classTiXmlElement.html
+file
+
+
+
+
+2013-05-03T17:03:38.758701Z
+46338043e5dd07f10c30dc2616bf369e
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+30888
+
+classTiXmlDocument.png
+file
+
+
+
+
+2013-05-03T17:03:38.762701Z
+e18bf75aa5b14a25ce04d422cb5e5aab
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+535
+
+functions_func_0x71.html
+file
+
+
+
+
+2013-05-03T17:03:38.762701Z
+09694c837f4fd854bde50f35849122c5
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4064
+
+functions_func_0x63.html
+file
+
+
+
+
+2013-05-03T17:03:38.766701Z
+aa14b624a62f0e19f26f36486c2f2121
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4654
+
+classTiXmlComment.html
+file
+
+
+
+
+2013-05-03T17:03:38.766701Z
+d0c755858da6a685b6e2b5da75dc9a1b
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7737
+
+functions_func_0x75.html
+file
+
+
+
+
+2013-05-03T17:03:38.770701Z
+ce5dc477e8d6321496e977e2a39b1203
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3277
+
+functions_func_0x67.html
+file
+
+
+
+
+2013-05-03T17:03:38.770701Z
+955e38d1e5a037f38134483dbdd87919
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3509
+
+functions_0x6c.html
+file
+
+
+
+
+2013-05-03T17:03:38.770701Z
+c6da2e21c170efa406c5fd79b55a5ac3
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3828
+
+functions.html
+file
+
+
+
+
+2013-05-03T17:03:38.774701Z
+f1de503ace5a408ace1b28fe6923feae
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4052
+
+classTiXmlDocument-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.774701Z
+4019f6ecfff393a88d3b7c3b0dd01ffa
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+24057
+
+functions_rela.html
+file
+
+
+
+
+2013-05-03T17:03:38.778701Z
+4932d13af13da4b7275f91cb069d5cbf
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2063
+
+annotated.html
+file
+
+
+
+
+2013-05-03T17:03:38.782701Z
+41ec6ca519d44e5d190e20cf68e5c756
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3796
+
+classTiXmlBase.html
+file
+
+
+
+
+2013-05-03T17:03:38.782701Z
+20be0bf40c86c9590e73cbba7b611f2a
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+16033
+
+classTiXmlVisitor.png
+file
+
+
+
+
+2013-05-03T17:03:38.786701Z
+261e6aa6afedb753b18b9a789927defb
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+386
+
+classTiXmlUnknown.png
+file
+
+
+
+
+2013-05-03T17:03:38.790701Z
+d892df11e4a1147802f3427813ee6aac
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+521
+
+tinyxml_8h_source.html
+file
+
+
+
+
+2013-05-03T17:03:38.794701Z
+4fac922d84434b436b964add85466aa3
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+203302
+
+classTiXmlElement-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.794701Z
+f24012ef2139ddcf310e0d9412fa7fb8
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+23787
+
+classTiXmlComment.png
+file
+
+
+
+
+2013-05-03T17:03:38.798701Z
+55cca6d4afac8c6d6496a9e4ecbfdd5e
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+518
+
+classTiXmlNode.html
+file
+
+
+
+
+2013-05-03T17:03:38.802701Z
+8d7c977f5760078e04247747348b535d
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+60709
+
+functions_0x73.html
+file
+
+
+
+
+2013-05-03T17:03:38.802701Z
+a282fb608ad9eaafa2e854d98e41efdc
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5492
+
+functions_0x65.html
+file
+
+
+
+
+2013-05-03T17:03:38.806701Z
+46fdea2d6bc0b39e442313784b1ea18c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4191
+
+functions_0x69.html
+file
+
+
+
+
+2013-05-03T17:03:38.810701Z
+165c9b7b0b7e37c6743de37c4c69ac31
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4078
+
+classTiXmlComment-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.810701Z
+31b904562efc531bf1ccbf5566f8bd64
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+19288
+
+classTiXmlBase.png
+file
+
+
+
+
+2013-05-03T17:03:38.806701Z
+5c0d99e4ef6c1a41c6ab95ca0e51a0b7
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1470
+
+classTiXmlVisitor.html
+file
+
+
+
+
+2013-05-03T17:03:38.814701Z
+c7815637d5252dae53ca243a2743ec9b
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8524
+
+classTiXmlUnknown.html
+file
+
+
+
+
+2013-05-03T17:03:38.814701Z
+a4d7a3a2e746b5500eead4ab3ac99236
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7013
+
+functions_func_0x72.html
+file
+
+
+
+
+2013-05-03T17:03:38.810701Z
+365168cb780fd5ee9aff5004ce17759f
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3748
+
+functions_func_0x64.html
+file
+
+
+
+
+2013-05-03T17:03:38.814701Z
+2dcd1bf621178702df523523964a39e7
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3287
+
+classTiXmlBase-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.814701Z
+a4094c26db2860c96169a87771a1782c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3890
+
+functions_func_0x76.html
+file
+
+
+
+
+2013-05-03T17:03:38.818701Z
+a9752eae8654c36c30ce70e34218365c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4937
+
+classTiXmlText.png
+file
+
+
+
+
+2013-05-03T17:03:38.818701Z
+a4b89477a86a4d5aa0b03562edc77a4f
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+485
+
+tab_b.gif
+file
+
+
+
+
+2013-05-03T17:03:38.818701Z
+a22ef28753006f7a725a9099ade93548
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+35
+
+classTiXmlElement.png
+file
+
+
+
+
+2013-05-03T17:03:38.822701Z
+ef98a2cfd0c332fe1af98c63c36850ab
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+514
+
+classTiXmlNode-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.822701Z
+868d0afbf41832269a1a612c934917f1
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+18771
+
+tab_l.gif
+file
+
+
+
+
+2013-05-03T17:03:38.826701Z
+749f90bcfb2030b4f2c0d274ac3b60ff
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+706
+
+functions_func_0x6c.html
+file
+
+
+
+
+2013-05-03T17:03:38.826701Z
+a3fcbc4e798bc805ce3d4cab8bf21ae5
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3753
+
+functions_0x70.html
+file
+
+
+
+
+2013-05-03T17:03:38.830701Z
+30b2c1a1cb72b45f02aa5d2226eba4b5
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4600
+
+classTiXmlAttribute.png
+file
+
+
+
+
+2013-05-03T17:03:38.830701Z
+5bb68ec6c5885115c01bac0fc2598412
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+401
+
+tab_r.gif
+file
+
+
+
+
+2013-05-03T17:03:38.830701Z
+9802233fa0b185ac2242b8dce096cb90
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2585
+
+classTiXmlDeclaration.html
+file
+
+
+
+
+2013-05-03T17:03:38.834701Z
+ee1384ec5d2e2e12e1cabc5252e58b29
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+10823
+
+functions_0x74.html
+file
+
+
+
+
+2013-05-03T17:03:38.834701Z
+0ed08e71309218cd06e1a788b7e7717c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+6167
+
+functions_0x66.html
+file
+
+
+
+
+2013-05-03T17:03:38.842701Z
+25a6394eea408033523872a41ec9b7cd
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4063
+
+classTiXmlVisitor-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.842701Z
+a72daa89f8aae763bb4d76c5950ab649
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3643
+
+classTiXmlUnknown-members.html
+file
+
+
+
+
+2013-05-03T17:03:38.838701Z
+dd4aa82ebb05af973a3fd438f56eaf20
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+18804
+
+tinystr_8h_source.html
+file
+
+
+
+
+2013-05-03T17:03:38.838701Z
+652a6dc57c6971fd1c8937615057a240
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+28921
+
+functions_enum.html
+file
+
+
+
+
+2013-05-03T17:03:38.842701Z
+30266f8a13493e09b67af1b548d810bb
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1932
+
+pages.html
+file
+
+
+
+
+2013-05-03T17:03:38.842701Z
+e7b33065614c9ee28e1fcd61929a62d1
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1215
+
+deprecated.html
+file
+
+
+
+
+2013-05-03T17:03:38.846701Z
+19bb94d69cf61c10d312297dbb1cf320
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2622
+
+functions_func_0x73.html
+file
+
+
+
+
+2013-05-03T17:03:38.846701Z
+a02e551282b1105b08e754bd4b602444
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5417
+
+functions_func_0x65.html
+file
+
+
+
+
+2013-05-03T17:03:38.846701Z
+9a9d4e1348518871d4405ded1b162e73
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4116
+
+classTiXmlPrinter.png
+file
+
+
+
+
+2013-05-03T17:03:38.850701Z
+20e01695809ee286a495cd55b87b1c71
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+380
+
+classTiXmlAttribute.html
+file
+
+
+
+
+2013-05-03T17:03:38.850701Z
+738cc3b14f3ba6f688ad38a8fa22fc3d
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+15523
+
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlAttribute.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlAttribute.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlAttribute.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlAttribute.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlBase.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlBase.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlBase.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlBase.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlComment.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlComment.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlComment.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlComment.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlDeclaration.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlDeclaration.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlDeclaration.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlDeclaration.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlDocument.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlDocument.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlDocument.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlDocument.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlElement.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlElement.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlElement.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlElement.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlNode.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlNode.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlNode.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlNode.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlPrinter.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlPrinter.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlPrinter.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlPrinter.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlText.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlText.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlText.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlText.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlUnknown.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlUnknown.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlUnknown.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlUnknown.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlVisitor.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlVisitor.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/classTiXmlVisitor.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/classTiXmlVisitor.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/doxygen.png.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/doxygen.png.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/doxygen.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/doxygen.png.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/tab_b.gif.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/tab_b.gif.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/tab_b.gif.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/tab_b.gif.svn-base	2013-05-09 18:10:01.623874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/tab_l.gif.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/tab_l.gif.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/tab_l.gif.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/tab_l.gif.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/prop-base/tab_r.gif.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/tab_r.gif.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/prop-base/tab_r.gif.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/prop-base/tab_r.gif.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/annotated.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/annotated.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/annotated.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/annotated.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,48 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td class="indexvalue">An attribute is a name-value pair </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td class="indexvalue"><a class="el" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a> is a base class for every class in TinyXml </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td class="indexvalue">An XML comment </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td class="indexvalue">In correct XML the declaration is the first entry in the file </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td class="indexvalue">Always the top level node </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td class="indexvalue">The element is a container class </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td class="indexvalue">A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td class="indexvalue">The parent class for everything in the Document Object Model </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td class="indexvalue">Print to memory functionality </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td class="indexvalue">XML text </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td class="indexvalue">Any tag that tinyXml doesn't recognize is saved as an unknown </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td class="indexvalue">Implements the interface to the "Visitor pattern" (see the Accept() method </td></tr>
+</table>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classes.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classes.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classes.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classes.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,38 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Alphabetical List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Class Index</h1><div class="qindex"><a class="qindex" href="#letter_T">T</a></div>
+<table align="center" width="95%" border="0" cellspacing="0" cellpadding="0">
+<tr><td><a name="letter_T"></a><table border="0" cellspacing="0" cellpadding="0"><tr><td><div class="ah">&nbsp;&nbsp;T&nbsp;&nbsp;</div></td></tr></table>
+</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>&nbsp;&nbsp;&nbsp;</td></tr><tr><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a>&nbsp;&nbsp;&nbsp;</td></tr><tr><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>&nbsp;&nbsp;&nbsp;</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a>&nbsp;&nbsp;&nbsp;</td></tr></table><div class="qindex"><a class="qindex" href="#letter_T">T</a></div>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlAttribute.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlAttribute.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlAttribute.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlAttribute.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,173 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlAttribute Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlAttribute Class Reference</h1><!-- doxytag: class="TiXmlAttribute" --><!-- doxytag: inherits="TiXmlBase" -->
+<p>An attribute is a name-value pair.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlAttribute:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlAttribute.png" usemap="#TiXmlAttribute_map" alt=""/>
+  <map id="TiXmlAttribute_map" name="TiXmlAttribute_map">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,90,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlAttribute-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cfa3c8179873fd485d83003b114f8e1"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="a9cfa3c8179873fd485d83003b114f8e1" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a052213522caac3979960e0714063861d"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="a052213522caac3979960e0714063861d" args="(const std::string &amp;_name, const std::string &amp;_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a052213522caac3979960e0714063861d">TiXmlAttribute</a> (const std::string &amp;_name, const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::string constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a759d0b76fb8fcf765ecab243bc14f05e"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="a759d0b76fb8fcf765ecab243bc14f05e" args="(const char *_name, const char *_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a> (const char *_name, const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an attribute with a name and value. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a298a57287d305904ba6bd96ae6f78d3d"></a><!-- doxytag: member="TiXmlAttribute::Name" ref="a298a57287d305904ba6bd96ae6f78d3d" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">Name</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f874490eac8ca00ee0070765d0e97e3"></a><!-- doxytag: member="TiXmlAttribute::Value" ref="a0f874490eac8ca00ee0070765d0e97e3" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">Value</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87705c3ccf9ee9417beb4f7cbacd4d33"></a><!-- doxytag: member="TiXmlAttribute::ValueStr" ref="a87705c3ccf9ee9417beb4f7cbacd4d33" args="() const " -->
+const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a20ad59dc7e89a0ab265396360d50f"></a><!-- doxytag: member="TiXmlAttribute::IntValue" ref="aa1a20ad59dc7e89a0ab265396360d50f" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">IntValue</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute, converted to an integer. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2880ddef53fc7522c99535273954d230"></a><!-- doxytag: member="TiXmlAttribute::DoubleValue" ref="a2880ddef53fc7522c99535273954d230" args="() const " -->
+double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">DoubleValue</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute, converted to a double. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">QueryIntValue</a> (int *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryIntValue examines the value string.  <a href="#ad6c93088ee21af41a107931223339344"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac87b2a8489906a5d7aa2875f20be3513"></a><!-- doxytag: member="TiXmlAttribute::QueryDoubleValue" ref="ac87b2a8489906a5d7aa2875f20be3513" args="(double *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a> (double *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryDoubleValue examines the value string. See <a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344" title="QueryIntValue examines the value string.">QueryIntValue()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7fa3d21ff8d7c5764cf9af15b667a99"></a><!-- doxytag: member="TiXmlAttribute::SetName" ref="ab7fa3d21ff8d7c5764cf9af15b667a99" args="(const char *_name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">SetName</a> (const char *_name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of this attribute. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dae44178f668b3cb48101be4f2236a0"></a><!-- doxytag: member="TiXmlAttribute::SetValue" ref="a2dae44178f668b3cb48101be4f2236a0" args="(const char *_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">SetValue</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e065df640116a62ea4f4b7da5449cc8"></a><!-- doxytag: member="TiXmlAttribute::SetIntValue" ref="a7e065df640116a62ea4f4b7da5449cc8" args="(int _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a> (int _value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value from an integer. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0316da31373496c4368ad549bf711394"></a><!-- doxytag: member="TiXmlAttribute::SetDoubleValue" ref="a0316da31373496c4368ad549bf711394" args="(double _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">SetDoubleValue</a> (double _value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value from a double. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab296ff0c9a8c701055cd257a8a976e57"></a><!-- doxytag: member="TiXmlAttribute::SetName" ref="ab296ff0c9a8c701055cd257a8a976e57" args="(const std::string &amp;_name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ab296ff0c9a8c701055cd257a8a976e57">SetName</a> (const std::string &amp;_name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab43f67a0cc3ec1d80e62606500f0925f"></a><!-- doxytag: member="TiXmlAttribute::SetValue" ref="ab43f67a0cc3ec1d80e62606500f0925f" args="(const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">SetValue</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c78e92e223a40843f644ba48ef69f67"></a><!-- doxytag: member="TiXmlAttribute::Next" ref="a1c78e92e223a40843f644ba48ef69f67" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">Next</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next sibling attribute in the DOM. Returns null at end. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ebbfe333fe76cd834bd6cbcca3130cf"></a><!-- doxytag: member="TiXmlAttribute::Previous" ref="a6ebbfe333fe76cd834bd6cbcca3130cf" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the previous sibling attribute in the DOM. Returns null at beginning. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#acc04956c1d5c4c31fe74f7a7528d109a"></a><br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>An attribute is a name-value pair. </p>
+<p>Elements have an arbitrary number of attributes, each with a unique name.</p>
+<dl class="note"><dt><b>Note:</b></dt><dd>The attributes are not TiXmlNodes, since they are not part of the tinyXML document object model. There are other suggested ways to look at this problem. </dd></dl>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="acc04956c1d5c4c31fe74f7a7528d109a"></a><!-- doxytag: member="TiXmlAttribute::Print" ref="acc04956c1d5c4c31fe74f7a7528d109a" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlAttribute::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ad6c93088ee21af41a107931223339344"></a><!-- doxytag: member="TiXmlAttribute::QueryIntValue" ref="ad6c93088ee21af41a107931223339344" args="(int *_value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlAttribute::QueryIntValue </td>
+          <td>(</td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>QueryIntValue examines the value string. </p>
+<p>It is an alternative to the <a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f" title="Return the value of this attribute, converted to an integer.">IntValue()</a> method with richer error checking. If the value is an integer, it is stored in 'value' and the call returns TIXML_SUCCESS. If it is not an integer, it returns TIXML_WRONG_TYPE.</p>
+<p>A specialized but useful call. Note that for success it returns 0, which is the opposite of almost all other TinyXml calls. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlAttribute-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlAttribute-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlAttribute-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlAttribute-members.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,63 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlAttribute Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">DoubleValue</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">IntValue</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">Name</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">Next</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a>(double *_value) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">QueryIntValue</a>(int *_value) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">SetDoubleValue</a>(double _value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a>(int _value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">SetName</a>(const char *_name)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ab296ff0c9a8c701055cd257a8a976e57">SetName</a>(const std::string &amp;_name)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>()</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a052213522caac3979960e0714063861d">TiXmlAttribute</a>(const std::string &amp;_name, const std::string &amp;_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a>(const char *_name, const char *_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">Value</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlBase.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlBase.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlBase.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlBase.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,226 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlBase Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlBase Class Reference</h1><!-- doxytag: class="TiXmlBase" -->
+<p><a class="el" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a> is a base class for every class in TinyXml.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlBase:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlBase.png" usemap="#TiXmlBase_map" alt=""/>
+  <map id="TiXmlBase_map" name="TiXmlBase_map">
+<area href="classTiXmlAttribute.html" alt="TiXmlAttribute" shape="rect" coords="0,56,108,80"/>
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="295,56,403,80"/>
+<area href="classTiXmlComment.html" alt="TiXmlComment" shape="rect" coords="0,112,108,136"/>
+<area href="classTiXmlDeclaration.html" alt="TiXmlDeclaration" shape="rect" coords="118,112,226,136"/>
+<area href="classTiXmlDocument.html" alt="TiXmlDocument" shape="rect" coords="236,112,344,136"/>
+<area href="classTiXmlElement.html" alt="TiXmlElement" shape="rect" coords="354,112,462,136"/>
+<area href="classTiXmlText.html" alt="TiXmlText" shape="rect" coords="472,112,580,136"/>
+<area href="classTiXmlUnknown.html" alt="TiXmlUnknown" shape="rect" coords="590,112,698,136"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlBase-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">Print</a> (FILE *cfile, int depth) const =0</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a0de56b3f2ef14c65091a3b916437b512"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the position, in the original source file, of this node or attribute.  <a href="#a024bceb070188df92c2a8d8852dd0853"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54bfb9b70fe6dd276e7b279cab7f003"></a><!-- doxytag: member="TiXmlBase::Column" ref="ab54bfb9b70fe6dd276e7b279cab7f003" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6b3e0f790930d4970ec30764e937b5d"></a><!-- doxytag: member="TiXmlBase::SetUserData" ref="ac6b3e0f790930d4970ec30764e937b5d" args="(void *user)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a> (void *user)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a pointer to arbitrary user data. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6559a530ca6763fc301a14d77ed28c17"></a><!-- doxytag: member="TiXmlBase::GetUserData" ref="a6559a530ca6763fc301a14d77ed28c17" args="()" -->
+void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to arbitrary user data. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0120210e4680ef2088601753ce0ede4"></a><!-- doxytag: member="TiXmlBase::GetUserData" ref="ad0120210e4680ef2088601753ce0ede4" args="() const " -->
+const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to arbitrary user data. <br/></td></tr>
+<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a> (bool condense)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The world does not agree on whether white space should be kept or not.  <a href="#a0f799ec645bfb8d8a969e83478f379c1"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4b1472531c647a25b1840a87ae42438"></a><!-- doxytag: member="TiXmlBase::IsWhiteSpaceCondensed" ref="ad4b1472531c647a25b1840a87ae42438" args="()" -->
+static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current white space setting. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a> (const TIXML_STRING &amp;str, TIXML_STRING *out)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands entities in a string.  <a href="#a6bd8c315c1acb09e34107b8736505948"></a><br/></td></tr>
+<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab242c01590191f644569fa89a080d97c"></a><!-- doxytag: member="TiXmlBase::userData" ref="ab242c01590191f644569fa89a080d97c" args="" -->
+void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Field containing a generic user pointer. <br/></td></tr>
+<tr><td colspan="2"><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a218872a0d985ae30e78c55adc4bdb196"></a><!-- doxytag: member="TiXmlBase::TiXmlNode" ref="a218872a0d985ae30e78c55adc4bdb196" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a218872a0d985ae30e78c55adc4bdb196">TiXmlNode</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlBase::TiXmlElement" ref="ab6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#ab6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173617f6dfe902cf484ce5552b950475"></a><!-- doxytag: member="TiXmlBase::TiXmlDocument" ref="a173617f6dfe902cf484ce5552b950475" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#a173617f6dfe902cf484ce5552b950475">TiXmlDocument</a></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p><a class="el" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a> is a base class for every class in TinyXml. </p>
+<p>It does little except to establish that TinyXml classes can be printed and provide some utility functions.</p>
+<p>In XML, the document and elements can contain other elements and other types of nodes.</p>
+<div class="fragment"><pre class="fragment">
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	</pre></div> <hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a6bd8c315c1acb09e34107b8736505948"></a><!-- doxytag: member="TiXmlBase::EncodeString" ref="a6bd8c315c1acb09e34107b8736505948" args="(const TIXML_STRING &amp;str, TIXML_STRING *out)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">static void TiXmlBase::EncodeString </td>
+          <td>(</td>
+          <td class="paramtype">const TIXML_STRING &amp;&nbsp;</td>
+          <td class="paramname"> <em>str</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TIXML_STRING *&nbsp;</td>
+          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [static]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Expands entities in a string. </p>
+<p>Note this should not contian the tag's '&lt;', '&gt;', etc, or they will be transformed into entities! </p>
+
+</div>
+</div>
+<a class="anchor" id="a0de56b3f2ef14c65091a3b916437b512"></a><!-- doxytag: member="TiXmlBase::Print" ref="a0de56b3f2ef14c65091a3b916437b512" args="(FILE *cfile, int depth) const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlBase::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implemented in <a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>, <a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a024bceb070188df92c2a8d8852dd0853"></a><!-- doxytag: member="TiXmlBase::Row" ref="a024bceb070188df92c2a8d8852dd0853" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlBase::Row </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the position, in the original source file, of this node or attribute. </p>
+<p>The row and column are 1-based. (That is the first row and first column is 1,1). If the returns values are 0 or less, then the parser does not have a row and column value.</p>
+<p>Generally, the row and column value will be set when the TiXmlDocument::Load(), <a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">TiXmlDocument::LoadFile()</a>, or any TiXmlNode::Parse() is called. It will NOT be set when the DOM was created from operator&gt;&gt;.</p>
+<p>The values reflect the initial load. Once the DOM is modified programmatically (by adding or changing nodes and attributes) the new values will NOT update to reflect changes in the document.</p>
+<p>There is a minor performance cost to computing the row and column. Computation can be disabled if <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">TiXmlDocument::SetTabSize()</a> is called with 0 as the value.</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">TiXmlDocument::SetTabSize()</a> </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="a0f799ec645bfb8d8a969e83478f379c1"></a><!-- doxytag: member="TiXmlBase::SetCondenseWhiteSpace" ref="a0f799ec645bfb8d8a969e83478f379c1" args="(bool condense)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">static void TiXmlBase::SetCondenseWhiteSpace </td>
+          <td>(</td>
+          <td class="paramtype">bool&nbsp;</td>
+          <td class="paramname"> <em>condense</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline, static]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The world does not agree on whether white space should be kept or not. </p>
+<p>In order to make everyone happy, these global, static functions are provided to set whether or not TinyXml will condense all white space into a single space or not. The default is to condense. Note changing this value is not thread safe. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlBase-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlBase-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlBase-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlBase-members.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,45 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlBase Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlBase.html">TiXmlBase</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">Print</a>(FILE *cfile, int depth) const =0</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlComment.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlComment.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlComment.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlComment.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,115 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlComment Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlComment Class Reference</h1><!-- doxytag: class="TiXmlComment" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>An XML comment.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlComment:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlComment.png" usemap="#TiXmlComment_map" alt=""/>
+  <map id="TiXmlComment_map" name="TiXmlComment_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,94,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,94,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlComment-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa3252031d3e8bd3a2bf51a1c61201b7"></a><!-- doxytag: member="TiXmlComment::TiXmlComment" ref="aaa3252031d3e8bd3a2bf51a1c61201b7" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty comment. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37e7802ef17bc03ebe5ae79bf0713d47"></a><!-- doxytag: member="TiXmlComment::TiXmlComment" ref="a37e7802ef17bc03ebe5ae79bf0713d47" args="(const char *_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a comment from text. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d6662bdc52488b9e12b3c7a0453d028"></a><!-- doxytag: member="TiXmlComment::Clone" ref="a0d6662bdc52488b9e12b3c7a0453d028" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of this Comment. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a6b316527aaa8da0370cd68c22a5a0f5f"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00fb4215c20a2399ea05ac9b9e7e68a0"></a><!-- doxytag: member="TiXmlComment::ToComment" ref="a00fb4215c20a2399ea05ac9b9e7e68a0" args="() const " -->
+virtual const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc7c7e07e13c23f17797d642981511df"></a><!-- doxytag: member="TiXmlComment::ToComment" ref="acc7c7e07e13c23f17797d642981511df" args="()" -->
+virtual <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df">ToComment</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3ac1b99fbbe9ea4fb6e14146156e43e"></a><!-- doxytag: member="TiXmlComment::Accept" ref="af3ac1b99fbbe9ea4fb6e14146156e43e" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>An XML comment. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a6b316527aaa8da0370cd68c22a5a0f5f"></a><!-- doxytag: member="TiXmlComment::Print" ref="a6b316527aaa8da0370cd68c22a5a0f5f" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlComment::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlComment-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlComment-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlComment-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlComment-members.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,109 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlComment Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlComment.html">TiXmlComment</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">Clone</a>() const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>()</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a>(const char *_value)</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a>() const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df">ToComment</a>()</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDeclaration.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDeclaration.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDeclaration.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDeclaration.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,131 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlDeclaration Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDeclaration Class Reference</h1><!-- doxytag: class="TiXmlDeclaration" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>In correct XML the declaration is the first entry in the file.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlDeclaration:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlDeclaration.png" usemap="#TiXmlDeclaration_map" alt=""/>
+  <map id="TiXmlDeclaration_map" name="TiXmlDeclaration_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,108,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,108,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlDeclaration-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0484d059bea0ea1acb47c9094382d79"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="aa0484d059bea0ea1acb47c9094382d79" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty declaration. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5556007c3c72209465081de39d9836"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="acd5556007c3c72209465081de39d9836" args="(const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a> (const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b618d1c30c25e4b7a71f31a595ee298"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="a3b618d1c30c25e4b7a71f31a595ee298" args="(const char *_version, const char *_encoding, const char *_standalone)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a> (const char *_version, const char *_encoding, const char *_standalone)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02ee557b1a4545c3219ed377c103ec76"></a><!-- doxytag: member="TiXmlDeclaration::Version" ref="a02ee557b1a4545c3219ed377c103ec76" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">Version</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version. Will return an empty string if none was found. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d974231f9e9a2f0542f15f3a46cdb76"></a><!-- doxytag: member="TiXmlDeclaration::Encoding" ref="a5d974231f9e9a2f0542f15f3a46cdb76" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encoding. Will return an empty string if none was found. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff06afc033d7ef730ec7c6825b97ad9"></a><!-- doxytag: member="TiXmlDeclaration::Standalone" ref="a9ff06afc033d7ef730ec7c6825b97ad9" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a standalone document? <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf459186040141cda7a180a6585ce2e"></a><!-- doxytag: member="TiXmlDeclaration::Clone" ref="a7cf459186040141cda7a180a6585ce2e" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this Declaration and returns it. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#abf6303db4bd05b5be554036817ff1cb4"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e085d3fefd1dbf5ccdbff729931a967"></a><!-- doxytag: member="TiXmlDeclaration::ToDeclaration" ref="a1e085d3fefd1dbf5ccdbff729931a967" args="() const " -->
+virtual const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd3d1daddcaeb9543c24bfd090969ce"></a><!-- doxytag: member="TiXmlDeclaration::ToDeclaration" ref="a6bd3d1daddcaeb9543c24bfd090969ce" args="()" -->
+virtual <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce">ToDeclaration</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22315a535983b86535cdba3458669e3e"></a><!-- doxytag: member="TiXmlDeclaration::Accept" ref="a22315a535983b86535cdba3458669e3e" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>In correct XML the declaration is the first entry in the file. </p>
+<div class="fragment"><pre class="fragment">
+		&lt;?xml version="1.0" standalone="yes"?&gt;
+	</pre></div><p>TinyXml will happily read or write files without a declaration, however. There are 3 possible attributes to the declaration: version, encoding, and standalone.</p>
+<p>Note: In this version of the code, the attributes are handled as special cases, not generic attributes, simply because there can only be at most 3 and they are always the same. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="abf6303db4bd05b5be554036817ff1cb4"></a><!-- doxytag: member="TiXmlDeclaration::Print" ref="abf6303db4bd05b5be554036817ff1cb4" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlDeclaration::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDeclaration-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDeclaration-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDeclaration-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDeclaration-members.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,113 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDeclaration Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">Clone</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a>()</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>(const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a>(const char *_version, const char *_encoding, const char *_standalone)</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">Version</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDocument.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDocument.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDocument.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDocument.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,437 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlDocument Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDocument Class Reference</h1><!-- doxytag: class="TiXmlDocument" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>Always the top level node.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlDocument:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlDocument.png" usemap="#TiXmlDocument_map" alt=""/>
+  <map id="TiXmlDocument_map" name="TiXmlDocument_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,99,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,99,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlDocument-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f5e84335708fde98400230f9f12659c"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="a9f5e84335708fde98400230f9f12659c" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty document, that has no name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4508b452d0c3061db085f3db27b8396"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="ae4508b452d0c3061db085f3db27b8396" args="(const char *documentName)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ae4508b452d0c3061db085f3db27b8396">TiXmlDocument</a> (const char *documentName)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a document with a name. The name of the document is also the filename of the xml. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6e58fb99bfa76cc613f16840022225"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="a2c6e58fb99bfa76cc613f16840022225" args="(const std::string &amp;documentName)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a> (const std::string &amp;documentName)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f">LoadFile</a> (TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the current document value.  <a href="#a4c852a889c02cf251117fd1d9fe1845f"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21c0aeb0d0a720169ad4ac89523ebe93"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="a21c0aeb0d0a720169ad4ac89523ebe93" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the current document value. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a879cdf5e981b8b2d2ef82f2546dd28fb"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a879cdf5e981b8b2d2ef82f2546dd28fb" args="(const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a879cdf5e981b8b2d2ef82f2546dd28fb">LoadFile</a> (const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the given filename. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae869f5ebf7fc54c4a1d737fb4689fd44"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="ae869f5ebf7fc54c4a1d737fb4689fd44" args="(const char *filename) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ae869f5ebf7fc54c4a1d737fb4689fd44">SaveFile</a> (const char *filename) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the given filename. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">LoadFile</a> (FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the given FILE*.  <a href="#a41f6fe7200864d1dca663d230caf8db6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf1672b4538c6d1d441f9f108aea2bf4"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="acf1672b4538c6d1d441f9f108aea2bf4" args="(FILE *) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#acf1672b4538c6d1d441f9f108aea2bf4">SaveFile</a> (FILE *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the given FILE*. Returns true if successful. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a18ae6ed34fed7991ebc220862dfac884">LoadFile</a> (const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d4fae0463f3f03679ba0b7cf6f2df52"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="a3d4fae0463f3f03679ba0b7cf6f2df52" args="(const std::string &amp;filename) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a3d4fae0463f3f03679ba0b7cf6f2df52">SaveFile</a> (const std::string &amp;filename) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; STL std::string version. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">Parse</a> (const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the given null terminated block of xml data.  <a href="#a17ebabe36926ef398e78dec0d0ad0378"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">RootElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the root element -- the only top level element -- of the document.  <a href="#ad09d17927f908f40efb406af2fb873be"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If an error occurs, Error will be set to true.  <a href="#a6dfc01a6e5d58e56acd537dfd3bdeb29"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0f689f6e09ea494ea547be8d79c25e"></a><!-- doxytag: member="TiXmlDocument::ErrorDesc" ref="a9d0f689f6e09ea494ea547be8d79c25e" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains a textual (english) description of the error if one occurs. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generally, you probably want the error string ( <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc()</a> ).  <a href="#af96fc2f3f9ec6422782bfe916c9e778f"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the location (if known) of the error.  <a href="#af30efc75e804aa2e92fb8be3a8cb676e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa90bc630ee5203c6109ca5fad3323649"></a><!-- doxytag: member="TiXmlDocument::ErrorCol" ref="aa90bc630ee5203c6109ca5fad3323649" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">ErrorCol</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The column where the error occured. See <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a> (int _tabsize)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize()</a> allows the error reporting functions (<a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol()</a>) to report the correct values for row and column.  <a href="#a51dac56316f89b35bdb7d0d433ba988e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">ClearError</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you have handled the error, it can be reset with this call.  <a href="#ac66b8c28db86363315712a3574e87c35"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">Print</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the document to standard out using formatted printing ("pretty print").  <a href="#af08389ec70ee9b2de7f800e206a18510"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8701fda1fa31b25abbc9c0df42da10e8"></a><!-- doxytag: member="TiXmlDocument::Print" ref="a8701fda1fa31b25abbc9c0df42da10e8" args="(FILE *cfile, int depth=0) const " -->
+virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">Print</a> (FILE *cfile, int depth=0) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print this Document to a FILE stream. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc977bde3e4fe85a8eb9d88a35ef5a4"></a><!-- doxytag: member="TiXmlDocument::ToDocument" ref="a1dc977bde3e4fe85a8eb9d88a35ef5a4" args="() const " -->
+virtual const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1025d942a1f328fd742d545e37efdd42"></a><!-- doxytag: member="TiXmlDocument::ToDocument" ref="a1025d942a1f328fd742d545e37efdd42" args="()" -->
+virtual <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42">ToDocument</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa545aae325d9752ad64120bc4ecf939a"></a><!-- doxytag: member="TiXmlDocument::Accept" ref="aa545aae325d9752ad64120bc4ecf939a" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exact duplicate of this node and return it.  <a href="#a4968661cab4a1f44a23329c6f8db1907"></a><br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Always the top level node. </p>
+<p>A document binds together all the XML pieces. It can be saved, loaded, and printed to the screen. The 'value' of a document node is the xml file name. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="ac66b8c28db86363315712a3574e87c35"></a><!-- doxytag: member="TiXmlDocument::ClearError" ref="ac66b8c28db86363315712a3574e87c35" args="()" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::ClearError </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>If you have handled the error, it can be reset with this call. </p>
+<p>The error state is automatically cleared if you Parse a new XML block. </p>
+
+</div>
+</div>
+<a class="anchor" id="a4968661cab4a1f44a23329c6f8db1907"></a><!-- doxytag: member="TiXmlDocument::Clone" ref="a4968661cab4a1f44a23329c6f8db1907" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlDocument::Clone </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [protected, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Create an exact duplicate of this node and return it. </p>
+<p>The memory must be deleted by the caller. </p>
+
+<p>Implements <a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a6dfc01a6e5d58e56acd537dfd3bdeb29"></a><!-- doxytag: member="TiXmlDocument::Error" ref="a6dfc01a6e5d58e56acd537dfd3bdeb29" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::Error </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>If an error occurs, Error will be set to true. </p>
+<p>Also,</p>
+<ul>
+<li>The <a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f" title="Generally, you probably want the error string ( ErrorDesc() ).">ErrorId()</a> will contain the integer identifier of the error (not generally useful)</li>
+<li>The <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc()</a> method will return the name of the error. (very useful)</li>
+<li>The <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol()</a> will return the location of the error (if known) </li>
+</ul>
+
+</div>
+</div>
+<a class="anchor" id="af96fc2f3f9ec6422782bfe916c9e778f"></a><!-- doxytag: member="TiXmlDocument::ErrorId" ref="af96fc2f3f9ec6422782bfe916c9e778f" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlDocument::ErrorId </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Generally, you probably want the error string ( <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc()</a> ). </p>
+<p>But if you prefer the ErrorId, this function will fetch it. </p>
+
+</div>
+</div>
+<a class="anchor" id="af30efc75e804aa2e92fb8be3a8cb676e"></a><!-- doxytag: member="TiXmlDocument::ErrorRow" ref="af30efc75e804aa2e92fb8be3a8cb676e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlDocument::ErrorRow </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Returns the location (if known) of the error. </p>
+<p>The first column is column 1, and the first row is row 1. A value of 0 means the row and column wasn't applicable (memory errors, for example, have no row/column) or the parser lost the error. (An error in the error reporting, in that case.)</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize</a>, <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row</a>, <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">Column</a> </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="a18ae6ed34fed7991ebc220862dfac884"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a18ae6ed34fed7991ebc220862dfac884" args="(const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>filename</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl><dt><b>Parameters:</b></dt><dd>
+  <table border="0" cellspacing="2" cellpadding="0">
+    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>STL std::string version. </td></tr>
+  </table>
+  </dd>
+</dl>
+
+<p>References <a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f">LoadFile()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a41f6fe7200864d1dca663d230caf8db6"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a41f6fe7200864d1dca663d230caf8db6" args="(FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname">, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Load a file using the given FILE*. </p>
+<p>Returns true if successful. Note that this method doesn't stream - the entire object pointed at by the FILE* will be interpreted as an XML file. TinyXML doesn't stream in XML from the current file location. Streaming may be added in the future. </p>
+
+</div>
+</div>
+<a class="anchor" id="a4c852a889c02cf251117fd1d9fe1845f"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="a4c852a889c02cf251117fd1d9fe1845f" args="(TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile </td>
+          <td>(</td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Load a file using the current document value. </p>
+<p>Returns true if successful. Will delete any existing document data before loading. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01425">LoadFile()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a17ebabe36926ef398e78dec0d0ad0378"></a><!-- doxytag: member="TiXmlDocument::Parse" ref="a17ebabe36926ef398e78dec0d0ad0378" args="(const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual const char* TiXmlDocument::Parse </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>p</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlParsingData *&nbsp;</td>
+          <td class="paramname"> <em>data</em> = <code>0</code>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Parse the given null terminated block of xml data. </p>
+<p>Passing in an encoding to this method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml to use that encoding, regardless of what TinyXml might otherwise try to detect. </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="af08389ec70ee9b2de7f800e206a18510"></a><!-- doxytag: member="TiXmlDocument::Print" ref="af08389ec70ee9b2de7f800e206a18510" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::Print </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Write the document to standard out using formatted printing ("pretty print"). </p>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01512">Print()</a>.</p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01512">Print()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ad09d17927f908f40efb406af2fb873be"></a><!-- doxytag: member="TiXmlDocument::RootElement" ref="ad09d17927f908f40efb406af2fb873be" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlDocument::RootElement </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Get the root element -- the only top level element -- of the document. </p>
+<p>In well formed XML, there should only be one. TinyXml is tolerant of multiple elements at the document level. </p>
+
+<p>References <a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">TiXmlNode::FirstChildElement()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a51dac56316f89b35bdb7d0d433ba988e"></a><!-- doxytag: member="TiXmlDocument::SetTabSize" ref="a51dac56316f89b35bdb7d0d433ba988e" args="(int _tabsize)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::SetTabSize </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>_tabsize</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize()</a> allows the error reporting functions (<a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol()</a>) to report the correct values for row and column. </p>
+<p>It does not change the output or input in any way.</p>
+<p>By calling this method, with a tab size greater than 0, the row and column of each node and attribute is stored when the file is loaded. Very useful for tracking the DOM back in to the source file.</p>
+<p>The tab size is required for calculating the location of nodes. If not set, the default of 4 is used. The tabsize is set per document. Setting the tabsize to 0 disables row/column tracking.</p>
+<p>Note that row and column tracking is not supported when using operator&gt;&gt;.</p>
+<p>The tab size needs to be enabled before the parse or load. Correct usage: </p>
+<div class="fragment"><pre class="fragment">
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row</a>, <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">Column</a> </dd></dl>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDocument-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDocument-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlDocument-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlDocument-members.html.svn-base	2013-05-09 18:10:01.627874321 +0200
@@ -0,0 +1,128 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlDocument Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">ClearError</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">Clone</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [protected, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">ErrorCol</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>(TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a879cdf5e981b8b2d2ef82f2546dd28fb">LoadFile</a>(const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">LoadFile</a>(FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a18ae6ed34fed7991ebc220862dfac884">LoadFile</a>(const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">Parse</a>(const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">Print</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">Print</a>(FILE *cfile, int depth=0) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">RootElement</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ae869f5ebf7fc54c4a1d737fb4689fd44">SaveFile</a>(const char *filename) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#acf1672b4538c6d1d441f9f108aea2bf4">SaveFile</a>(FILE *) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a3d4fae0463f3f03679ba0b7cf6f2df52">SaveFile</a>(const std::string &amp;filename) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a>(int _tabsize)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#ae4508b452d0c3061db085f3db27b8396">TiXmlDocument</a>(const char *documentName)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a>(const std::string &amp;documentName)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42">ToDocument</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlElement.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlElement.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlElement.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlElement.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,439 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlElement Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlElement Class Reference</h1><!-- doxytag: class="TiXmlElement" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>The element is a container class.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlElement:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlElement.png" usemap="#TiXmlElement_map" alt=""/>
+  <map id="TiXmlElement_map" name="TiXmlElement_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,87,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,87,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlElement-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01bc3ab372d35da08efcbbe65ad90c60"></a><!-- doxytag: member="TiXmlElement::TiXmlElement" ref="a01bc3ab372d35da08efcbbe65ad90c60" args="(const char *in_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a> (const char *in_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fc2e3c1a955e2f78e1a32350d180e7"></a><!-- doxytag: member="TiXmlElement::TiXmlElement" ref="a40fc2e3c1a955e2f78e1a32350d180e7" args="(const std::string &amp;_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::string constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae419a442a9701a62b0c3d8fd1cbdd12d"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="ae419a442a9701a62b0c3d8fd1cbdd12d" args="(const char *name) const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a> (const char *name) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a0ed8348fdc56b72a6b4900ce5bac1849">Attribute</a> (const char *name, int *i) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists.  <a href="#a0ed8348fdc56b72a6b4900ce5bac1849"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">Attribute</a> (const char *name, double *d) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists.  <a href="#aeaff99d4f0ea5b34f7aee202aad457ba"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a> (const char *name, int *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryIntAttribute examines the attribute - it is an alternative to the <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> method with richer error checking.  <a href="#aea0bfe471380f281c5945770ddbf52b9"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a898d7730ecc341f0bffc7a9dadbf1ce7"></a><!-- doxytag: member="TiXmlElement::QueryDoubleAttribute" ref="a898d7730ecc341f0bffc7a9dadbf1ce7" args="(const char *name, double *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a> (const char *name, double *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryDoubleAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04d3af11601ef5a5f88295203a843be"></a><!-- doxytag: member="TiXmlElement::QueryFloatAttribute" ref="aa04d3af11601ef5a5f88295203a843be" args="(const char *name, float *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a> (const char *name, float *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryFloatAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute()</a>. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14321ac360efe906ed449d9db3fd9961"></a><!-- doxytag: member="TiXmlElement::QueryStringAttribute" ref="a14321ac360efe906ed449d9db3fd9961" args="(const char *name, std::string *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">QueryStringAttribute</a> (const char *name, std::string *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryStringAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute()</a>. <br/></td></tr>
+<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
+<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a> (const std::string &amp;name, T *outValue) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template form of the attribute query which will try to read the attribute into the specified type.  <a href="#ae3b9a03b0a56663a40801c7256683576"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#abf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a> (const char *name, const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#abf0b3bd7f0e4c746a89ec6e7f101fc32"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a80ed65b1d194c71c6c9986ae42337d7d">SetAttribute</a> (const std::string &amp;name, const std::string &amp;_value)</td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f18d54fbe25bbc527936ee65363b3c5"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="a6f18d54fbe25bbc527936ee65363b3c5" args="(const std::string &amp;name, int _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a6f18d54fbe25bbc527936ee65363b3c5">SetAttribute</a> (const std::string &amp;name, int _value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">SetAttribute</a> (const char *name, int value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#ace6f4be75e373726d4774073d666d1a7"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a> (const char *name, double value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#a0d1dd975d75496778177e35abfe0ec0b"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56979767deca794376b1dfa69a525b2a"></a><!-- doxytag: member="TiXmlElement::RemoveAttribute" ref="a56979767deca794376b1dfa69a525b2a" args="(const char *name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">RemoveAttribute</a> (const char *name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an attribute with the given name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1afa6aea716511326a608e4c05df4f3a"></a><!-- doxytag: member="TiXmlElement::RemoveAttribute" ref="a1afa6aea716511326a608e4c05df4f3a" args="(const std::string &amp;name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a">RemoveAttribute</a> (const std::string &amp;name)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a516054c9073647d6cb29b6abe9fa0592"></a><!-- doxytag: member="TiXmlElement::FirstAttribute" ref="a516054c9073647d6cb29b6abe9fa0592" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first attribute in this element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86191b49f9177be132b85b14655f1381"></a><!-- doxytag: member="TiXmlElement::LastAttribute" ref="a86191b49f9177be132b85b14655f1381" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">LastAttribute</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last attribute in this element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">GetText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function for easy access to the text inside an element.  <a href="#af3282294986cdb216646ea1f67af2c87"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa464535ea1994db337cb6a8ce4b588b5"></a><!-- doxytag: member="TiXmlElement::Clone" ref="aa464535ea1994db337cb6a8ce4b588b5" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new Element and returns it - the returned element is a copy. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#afbf52736e70fc91ec9d760721d6f4fd2"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5b8d0e25fa23fd9acbb6d146082901c"></a><!-- doxytag: member="TiXmlElement::ToElement" ref="ac5b8d0e25fa23fd9acbb6d146082901c" args="() const " -->
+virtual const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">ToElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9def86337ea7a755eb41cac980f60c7a"></a><!-- doxytag: member="TiXmlElement::ToElement" ref="a9def86337ea7a755eb41cac980f60c7a" args="()" -->
+virtual <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a">ToElement</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a81b2afb0d42be1543d1c404dee6f5"></a><!-- doxytag: member="TiXmlElement::Accept" ref="a71a81b2afb0d42be1543d1c404dee6f5" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>The element is a container class. </p>
+<p>It has a value, the element name, and can contain other elements, text, comments, and unknowns. Elements also contain an arbitrary number of attributes. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="aeaff99d4f0ea5b34f7aee202aad457ba"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="aeaff99d4f0ea5b34f7aee202aad457ba" args="(const char *name, double *d) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::Attribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">double *&nbsp;</td>
+          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists. </p>
+<p>If the attribute exists and can be converted to an double, the double value will be put in the return 'd', if 'd' is non-null. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0ed8348fdc56b72a6b4900ce5bac1849"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="a0ed8348fdc56b72a6b4900ce5bac1849" args="(const char *name, int *i) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::Attribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Given an attribute name, <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> returns the value for the attribute of that name, or null if none exists. </p>
+<p>If the attribute exists and can be converted to an integer, the integer value will be put in the return 'i', if 'i' is non-null. </p>
+
+</div>
+</div>
+<a class="anchor" id="af3282294986cdb216646ea1f67af2c87"></a><!-- doxytag: member="TiXmlElement::GetText" ref="af3282294986cdb216646ea1f67af2c87" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::GetText </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Convenience function for easy access to the text inside an element. </p>
+<p>Although easy and concise, <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> is limited compared to getting the <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a> child and accessing it directly.</p>
+<p>If the first child of 'this' is a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>, the <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> returns the character string of the Text node, else null is returned.</p>
+<p>This is a convenient method for getting the text of simple contained text: </p>
+<div class="fragment"><pre class="fragment">
+		&lt;foo&gt;This is text&lt;/foo&gt;
+		const char* str = fooElement-&gt;GetText();
+		</pre></div><p>'str' will be a pointer to "This is text".</p>
+<p>Note that this function can be misleading. If the element foo was created from this XML: </p>
+<div class="fragment"><pre class="fragment">
+		&lt;foo&gt;&lt;b&gt;This is text&lt;/b&gt;&lt;/foo&gt; 
+		</pre></div><p>then the value of str would be null. The first child node isn't a text node, it is another element. From this XML: </p>
+<div class="fragment"><pre class="fragment">
+		&lt;foo&gt;This is &lt;b&gt;text&lt;/b&gt;&lt;/foo&gt; 
+		</pre></div><p> <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> will return "This is ".</p>
+<p>WARNING: <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87" title="Convenience function for easy access to the text inside an element.">GetText()</a> accesses a child node - don't become confused with the similarly named <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle::Text()</a> and <a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03" title="Cast to a more defined type. Will return null if not of the requested type.">TiXmlNode::ToText()</a> which are safe type casts on the referenced node. </p>
+
+</div>
+</div>
+<a class="anchor" id="afbf52736e70fc91ec9d760721d6f4fd2"></a><!-- doxytag: member="TiXmlElement::Print" ref="afbf52736e70fc91ec9d760721d6f4fd2" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlElement::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="aea0bfe471380f281c5945770ddbf52b9"></a><!-- doxytag: member="TiXmlElement::QueryIntAttribute" ref="aea0bfe471380f281c5945770ddbf52b9" args="(const char *name, int *_value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlElement::QueryIntAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>QueryIntAttribute examines the attribute - it is an alternative to the <a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute()</a> method with richer error checking. </p>
+<p>If the attribute is an integer, it is stored in 'value' and the call returns TIXML_SUCCESS. If it is not an integer, it returns TIXML_WRONG_TYPE. If the attribute does not exist, then TIXML_NO_ATTRIBUTE is returned. </p>
+
+</div>
+</div>
+<a class="anchor" id="ae3b9a03b0a56663a40801c7256683576"></a><!-- doxytag: member="TiXmlElement::QueryValueAttribute" ref="ae3b9a03b0a56663a40801c7256683576" args="(const std::string &amp;name, T *outValue) const " -->
+<div class="memitem">
+<div class="memproto">
+<div class="memtemplate">
+template&lt;typename T &gt; </div>
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlElement::QueryValueAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">T *&nbsp;</td>
+          <td class="paramname"> <em>outValue</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Template form of the attribute query which will try to read the attribute into the specified type. </p>
+<p>Very easy, very powerful, but be careful to make sure to call this with the correct type.</p>
+<p>NOTE: This method doesn't work correctly for 'string' types that contain spaces.</p>
+<dl class="return"><dt><b>Returns:</b></dt><dd>TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l00814">TiXmlAttribute::ValueStr()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ace6f4be75e373726d4774073d666d1a7"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="ace6f4be75e373726d4774073d666d1a7" args="(const char *name, int value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Sets an attribute of name to a given value. </p>
+<p>The attribute will be created if it does not exist, or changed if it does. </p>
+
+</div>
+</div>
+<a class="anchor" id="a80ed65b1d194c71c6c9986ae42337d7d"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="a80ed65b1d194c71c6c9986ae42337d7d" args="(const std::string &amp;name, const std::string &amp;_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<p>STL std::string form. </p>
+
+</div>
+</div>
+<a class="anchor" id="abf0b3bd7f0e4c746a89ec6e7f101fc32"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="abf0b3bd7f0e4c746a89ec6e7f101fc32" args="(const char *name, const char *_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Sets an attribute of name to a given value. </p>
+<p>The attribute will be created if it does not exist, or changed if it does. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0d1dd975d75496778177e35abfe0ec0b"></a><!-- doxytag: member="TiXmlElement::SetDoubleAttribute" ref="a0d1dd975d75496778177e35abfe0ec0b" args="(const char *name, double value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetDoubleAttribute </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">double&nbsp;</td>
+          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Sets an attribute of name to a given value. </p>
+<p>The attribute will be created if it does not exist, or changed if it does. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlElement-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlElement-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlElement-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlElement-members.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,127 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlElement Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlElement.html">TiXmlElement</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>(const char *name) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a0ed8348fdc56b72a6b4900ce5bac1849">Attribute</a>(const char *name, int *i) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">Attribute</a>(const char *name, double *d) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">Clone</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">GetText</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">LastAttribute</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a>(const char *name, double *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a>(const char *name, float *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a>(const char *name, int *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">QueryStringAttribute</a>(const char *name, std::string *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a>(const std::string &amp;name, T *outValue) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">RemoveAttribute</a>(const char *name)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a">RemoveAttribute</a>(const std::string &amp;name)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#abf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>(const char *name, const char *_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a80ed65b1d194c71c6c9986ae42337d7d">SetAttribute</a>(const std::string &amp;name, const std::string &amp;_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a6f18d54fbe25bbc527936ee65363b3c5">SetAttribute</a>(const std::string &amp;name, int _value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">SetAttribute</a>(const char *name, int value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a>(const char *name, double value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>(const char *in_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">ToElement</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a">ToElement</a>()</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlHandle.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlHandle.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlHandle.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlHandle.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,412 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlHandle Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlHandle Class Reference</h1><!-- doxytag: class="TiXmlHandle" -->
+<p>A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+
+<p><a href="classTiXmlHandle-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba18fd7bdefb942ecdea4bf4b8e29ec8"></a><!-- doxytag: member="TiXmlHandle::TiXmlHandle" ref="aba18fd7bdefb942ecdea4bf4b8e29ec8" args="(TiXmlNode *_node)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *_node)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a handle from any node (at any depth of the tree.) This can be a null pointer. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a236d7855e1e56ccc7b980630c48c7fd7"></a><!-- doxytag: member="TiXmlHandle::TiXmlHandle" ref="a236d7855e1e56ccc7b980630c48c7fd7" args="(const TiXmlHandle &amp;ref)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a> (const <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> &amp;ref)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb1faaf88a700b40ca2c8d9aee21139"></a><!-- doxytag: member="TiXmlHandle::FirstChild" ref="acdb1faaf88a700b40ca2c8d9aee21139" args="() const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c61f64ae9365d89c264f289085541f8"></a><!-- doxytag: member="TiXmlHandle::FirstChild" ref="a8c61f64ae9365d89c264f289085541f8" args="(const char *value) const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">FirstChild</a> (const char *value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child node with the given name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d1112e995e937e4dddb202d4113d4a"></a><!-- doxytag: member="TiXmlHandle::FirstChildElement" ref="a24d1112e995e937e4dddb202d4113d4a" args="() const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0aea751320f5e430fac6f8fff3b8dd4"></a><!-- doxytag: member="TiXmlHandle::FirstChildElement" ref="af0aea751320f5e430fac6f8fff3b8dd4" args="(const char *value) const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#af0aea751320f5e430fac6f8fff3b8dd4">FirstChildElement</a> (const char *value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child element with the given name. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">Child</a> (const char *value, int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child with the given name.  <a href="#a072492b4be1acdb0db2d03cd8f71ccc4"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#af9cf6a7d08a5da94a8924425ad0cd5ac">Child</a> (int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child.  <a href="#af9cf6a7d08a5da94a8924425ad0cd5ac"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">ChildElement</a> (const char *value, int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child element with the given name.  <a href="#a979a3f850984a176ee884e394c7eed2d"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a8786475b9d1f1518492e3a46704c7ef0">ChildElement</a> (int index) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child element.  <a href="#a8786475b9d1f1518492e3a46704c7ef0"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">ToNode</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>.  <a href="#af678e5088e83be67baf76f699756f2c3"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>.  <a href="#abc6e7ed383a5fe1e52b0c0004b457b9e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">ToText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>.  <a href="#a4ac53a652296203a5b5e13854d923586"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">ToUnknown</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>.  <a href="#a1381c17507a130767b1e23afc93b3674"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">Node</a> () const </td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">Element</a> () const </td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">Text</a> () const </td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">Unknown</a> () const </td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing. </p>
+<p>Note that <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> is not part of the TinyXml DOM structure. It is a separate utility class.</p>
+<p>Take an example: </p>
+<div class="fragment"><pre class="fragment">
+	&lt;Document&gt;
+		&lt;Element attributeA = "valueA"&gt;
+			&lt;Child attributeB = "value1" /&gt;
+			&lt;Child attributeB = "value2" /&gt;
+		&lt;/Element&gt;
+	&lt;Document&gt;
+	</pre></div><p>Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very easy to write a *lot* of code that looks like:</p>
+<div class="fragment"><pre class="fragment">
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root-&gt;FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element-&gt;FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child-&gt;NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	</pre></div><p>And that doesn't even cover "else" cases. <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> addresses the verbosity of such code. A <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> checks for null pointers so it is perfectly safe and correct to use:</p>
+<div class="fragment"><pre class="fragment">
+	TiXmlHandle docHandle( &amp;document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	</pre></div><p>Which is MUCH more concise and useful.</p>
+<p>It is also safe to copy handles - internally they are nothing more than node pointers. </p>
+<div class="fragment"><pre class="fragment">
+	TiXmlHandle handleCopy = handle;
+	</pre></div><p>What they should not be used for is iteration:</p>
+<div class="fragment"><pre class="fragment">
+	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	</pre></div><p>It seems reasonable, but it is in fact two embedded while loops. The Child method is a linear walk to find the element, so this code would iterate much more than it needs to. Instead, prefer:</p>
+<div class="fragment"><pre class="fragment">
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child-&gt;NextSiblingElement() )
+	{
+		// do something
+	}
+	</pre></div> <hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="af9cf6a7d08a5da94a8924425ad0cd5ac"></a><!-- doxytag: member="TiXmlHandle::Child" ref="af9cf6a7d08a5da94a8924425ad0cd5ac" args="(int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::Child </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child. </p>
+<p>The first child is 0, the second 1, etc. </p>
+
+</div>
+</div>
+<a class="anchor" id="a072492b4be1acdb0db2d03cd8f71ccc4"></a><!-- doxytag: member="TiXmlHandle::Child" ref="a072492b4be1acdb0db2d03cd8f71ccc4" args="(const char *value, int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::Child </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child with the given name. </p>
+<p>The first child is 0, the second 1, etc. </p>
+
+</div>
+</div>
+<a class="anchor" id="a8786475b9d1f1518492e3a46704c7ef0"></a><!-- doxytag: member="TiXmlHandle::ChildElement" ref="a8786475b9d1f1518492e3a46704c7ef0" args="(int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::ChildElement </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child element. </p>
+<p>The first child element is 0, the second 1, etc. Note that only TiXmlElements are indexed: other types are not counted. </p>
+
+</div>
+</div>
+<a class="anchor" id="a979a3f850984a176ee884e394c7eed2d"></a><!-- doxytag: member="TiXmlHandle::ChildElement" ref="a979a3f850984a176ee884e394c7eed2d" args="(const char *value, int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::ChildElement </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a handle to the "index" child element with the given name. </p>
+<p>The first child element is 0, the second 1, etc. Note that only TiXmlElements are indexed: other types are not counted. </p>
+
+</div>
+</div>
+<a class="anchor" id="acb5fe8388a526289ea65e817a51e05e7"></a><!-- doxytag: member="TiXmlHandle::Element" ref="acb5fe8388a526289ea65e817a51e05e7" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlHandle::Element </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>use ToElement. Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01681">ToElement()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="ab44b723a8dc9af72838a303c079d0376"></a><!-- doxytag: member="TiXmlHandle::Node" ref="ab44b723a8dc9af72838a303c079d0376" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlHandle::Node </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use ToNode. Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01678">ToNode()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a9fc739c8a18d160006f82572fc143d13"></a><!-- doxytag: member="TiXmlHandle::Text" ref="a9fc739c8a18d160006f82572fc143d13" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlText.html">TiXmlText</a>* TiXmlHandle::Text </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586" title="Return the handle as a TiXmlText.">ToText()</a> Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01684">ToText()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="abc6e7ed383a5fe1e52b0c0004b457b9e"></a><!-- doxytag: member="TiXmlHandle::ToElement" ref="abc6e7ed383a5fe1e52b0c0004b457b9e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlHandle::ToElement </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01696">Element()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="af678e5088e83be67baf76f699756f2c3"></a><!-- doxytag: member="TiXmlHandle::ToNode" ref="af678e5088e83be67baf76f699756f2c3" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlHandle::ToNode </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01692">Node()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a4ac53a652296203a5b5e13854d923586"></a><!-- doxytag: member="TiXmlHandle::ToText" ref="a4ac53a652296203a5b5e13854d923586" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlText.html">TiXmlText</a>* TiXmlHandle::ToText </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01700">Text()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a1381c17507a130767b1e23afc93b3674"></a><!-- doxytag: member="TiXmlHandle::ToUnknown" ref="a1381c17507a130767b1e23afc93b3674" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>* TiXmlHandle::ToUnknown </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>. </p>
+<p>This may return null. </p>
+
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01704">Unknown()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a49675b74357ba2aae124657a9a1ef465"></a><!-- doxytag: member="TiXmlHandle::Unknown" ref="a49675b74357ba2aae124657a9a1ef465" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>* TiXmlHandle::Unknown </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>use <a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674" title="Return the handle as a TiXmlUnknown.">ToUnknown()</a> Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>. This may return null. </dd></dl>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l01687">ToUnknown()</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlHandle-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlHandle-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlHandle-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlHandle-members.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,53 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlHandle Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">Child</a>(const char *value, int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#af9cf6a7d08a5da94a8924425ad0cd5ac">Child</a>(int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">ChildElement</a>(const char *value, int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a8786475b9d1f1518492e3a46704c7ef0">ChildElement</a>(int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">Element</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#af0aea751320f5e430fac6f8fff3b8dd4">FirstChildElement</a>(const char *value) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">Node</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">Text</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a>(TiXmlNode *_node)</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>(const TiXmlHandle &amp;ref)</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">ToNode</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">ToText</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">Unknown</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlNode.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlNode.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlNode.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlNode.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,718 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlNode Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlNode Class Reference</h1><!-- doxytag: class="TiXmlNode" --><!-- doxytag: inherits="TiXmlBase" -->
+<p>The parent class for everything in the Document Object Model.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlNode:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlNode.png" usemap="#TiXmlNode_map" alt=""/>
+  <map id="TiXmlNode_map" name="TiXmlNode_map">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="295,0,403,24"/>
+<area href="classTiXmlComment.html" alt="TiXmlComment" shape="rect" coords="0,112,108,136"/>
+<area href="classTiXmlDeclaration.html" alt="TiXmlDeclaration" shape="rect" coords="118,112,226,136"/>
+<area href="classTiXmlDocument.html" alt="TiXmlDocument" shape="rect" coords="236,112,344,136"/>
+<area href="classTiXmlElement.html" alt="TiXmlElement" shape="rect" coords="354,112,462,136"/>
+<area href="classTiXmlText.html" alt="TiXmlText" shape="rect" coords="472,112,580,136"/>
+<area href="classTiXmlUnknown.html" alt="TiXmlUnknown" shape="rect" coords="590,112,698,136"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlNode-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Types</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The types of XML nodes supported by TinyXml. </p>
+ <a href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">More...</a><br/></td></tr>
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The meaning of 'value' changes for the specific type of <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>.  <a href="#a77943eb90d12c2892b1337a9f5918b41"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &#39;value&#39; changes for the specific type of TiXmlNode.">Value()</a> as a std::string.  <a href="#a6d9e505619d39bf50bfd9609c9169ea5"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the value of the node.  <a href="#a2a38329ca5d3f28f98ce932b8299ae90"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2598d5f448042c1abbeae4503dd45ff2"></a><!-- doxytag: member="TiXmlNode::SetValue" ref="a2598d5f448042c1abbeae4503dd45ff2" args="(const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a708e7f953df61d4d2d12f73171550a4b"></a><!-- doxytag: member="TiXmlNode::Clear" ref="a708e7f953df61d4d2d12f73171550a4b" args="()" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all the children of this node. Does not affect 'this'. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab643043132ffd794f8602685d34a982e"></a><!-- doxytag: member="TiXmlNode::Parent" ref="ab643043132ffd794f8602685d34a982e" args="()" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One step up the DOM. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44c8eee26bbe2d1b2762038df9dde2f0"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a44c8eee26bbe2d1b2762038df9dde2f0" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node. Will be null if there are no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a> (const char *value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node with the matching 'value'.  <a href="#a1f05828d023150706eeb16d6fb3f6355"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc8bf32be6419ec453a731868de19554"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="abc8bf32be6419ec453a731868de19554" args="(const char *_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node with the matching 'value'. Will be null if none found. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6432d2b2495f6caf9cb4278df706a031"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="a6432d2b2495f6caf9cb4278df706a031" args="()" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last child of this node. Will be null if there are no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abad5bf1059c48127b958711ef89e8e5d"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="abad5bf1059c48127b958711ef89e8e5d" args="(const char *_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a> (const char *_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last child of this node matching 'value'. Will be null if there are no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07f6200a5956c723c5b52d70f29c46f6"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a07f6200a5956c723c5b52d70f29c46f6" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10d2669ccb5e29e02fcb0e4408685ef6"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a10d2669ccb5e29e02fcb0e4408685ef6" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a256d0cdbfcfeccae83f3a1c9747a8b63"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="a256d0cdbfcfeccae83f3a1c9747a8b63" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69772c9202f70553f940b15c06b07be3"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="a69772c9202f70553f940b15c06b07be3" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a> (const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alternate way to walk the children of a node.  <a href="#a8621196ba3705fa226bef4a761cc51b6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfaef35a076b9343adc1420757376c39"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="adfaef35a076b9343adc1420757376c39" args="(const char *value, const TiXmlNode *previous) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a> (const char *value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This flavor of IterateChildren searches for children with a particular 'value'. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cbaaf8e82c09ad763d52616d75724df"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="a1cbaaf8e82c09ad763d52616d75724df" args="(const std::string &amp;_value, const TiXmlNode *previous) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a> (const std::string &amp;_value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e9ad53e2f5445b14bf325c90aa862c"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="a16e9ad53e2f5445b14bf325c90aa862c" args="(const std::string &amp;_value, const TiXmlNode *previous)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a> (const std::string &amp;_value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a> (const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#ad7d4630e1a2a916edda16be22448a8ba"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#a5d29442ae46de6d0168429156197bfc6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *beforeThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#a0c146fa2fff0157b681594102f48cbc7"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *afterThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#ad9b75e54ec19301c8b4d5ff583d0b3d5"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *replaceThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;withThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a child of this node.  <a href="#a0c49e739a17b9938050c22cd89617fbd"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19d8510efc90596552f4feeac9a8fbf"></a><!-- doxytag: member="TiXmlNode::RemoveChild" ref="ae19d8510efc90596552f4feeac9a8fbf" args="(TiXmlNode *removeThis)" -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *removeThis)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a child of this node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2cd892768726270e511b2ab32de4d10"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="ac2cd892768726270e511b2ab32de4d10" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bdd49327eec1e609b7d22af706b8316"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="a5bdd49327eec1e609b7d22af706b8316" args="(const char *) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a> (const char *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a658276f57d35d5d4256d1dc1a2c398ab"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="a658276f57d35d5d4256d1dc1a2c398ab" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8a0434c7f401d4a3b6dee77c1a5912"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="acc8a0434c7f401d4a3b6dee77c1a5912" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b94d2f7fa7ab25a5a8e8d4340c449c9"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="a1b94d2f7fa7ab25a5a8e8d4340c449c9" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1757c1f4d01e8c9596ffdbd561c76aea"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="a1757c1f4d01e8c9596ffdbd561c76aea" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af854baeba384f5fe9859f5aee03b548e"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="af854baeba384f5fe9859f5aee03b548e" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e61c0b89a77e36a0e8c60490003cb46"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="a2e61c0b89a77e36a0e8c60490003cb46" args="(const char *) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a> (const char *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node with the given 'value'. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements.  <a href="#a73acf929d49d10bd0e5fb3d31b0372d1"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a> (const char *) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements.  <a href="#a071ba77fd7ab79402fa84b7e9b8607b3"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7572d0af9d1e696ee3f05d8bb5ebb463"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a7572d0af9d1e696ee3f05d8bb5ebb463" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a506958e34406729a4e4c5326ea39d081"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a506958e34406729a4e4c5326ea39d081" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4fb652f6bd79ae0d5ce7d0f7d3c0fba"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="af4fb652f6bd79ae0d5ce7d0f7d3c0fba" args="() const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accda2c6b45c25bb5a6f9c3407a644e61"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="accda2c6b45c25bb5a6f9c3407a644e61" args="(const char *_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a> (const char *_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327ad4bbd90073c5dfc931b07314f5f7"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="a327ad4bbd90073c5dfc931b07314f5f7" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a> (const std::string &amp;_value) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f1d7291880534c1e5cdeb392d8c1f45"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="a7f1d7291880534c1e5cdeb392d8c1f45" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a> (const std::string &amp;_value)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the type (as an enumerated value, above) of this node.  <a href="#a57b99d5c97d67a42b9752f5210a1ba5e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the Document this node lives in.  <a href="#a80e397fa973cf5323e33b07154b024f3"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed21ad30630ef6e7faf096127edc9f3"></a><!-- doxytag: member="TiXmlNode::NoChildren" ref="aeed21ad30630ef6e7faf096127edc9f3" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node has no children. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a4cda4b15c29f64cff419309aebed08"></a><!-- doxytag: member="TiXmlNode::ToDocument" ref="a8a4cda4b15c29f64cff419309aebed08" args="() const " -->
+virtual const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72abed96dc9667ab9e0a2a275301bb1c"></a><!-- doxytag: member="TiXmlNode::ToElement" ref="a72abed96dc9667ab9e0a2a275301bb1c" args="() const " -->
+virtual const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a5086f9eaee910bbfdc7f975e26574"></a><!-- doxytag: member="TiXmlNode::ToComment" ref="aa0a5086f9eaee910bbfdc7f975e26574" args="() const " -->
+virtual const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd7205cf31d7a376929f8a36930627a2"></a><!-- doxytag: member="TiXmlNode::ToUnknown" ref="afd7205cf31d7a376929f8a36930627a2" args="() const " -->
+virtual const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a46a52c525992d6b4ee08beb14cd69"></a><!-- doxytag: member="TiXmlNode::ToText" ref="a95a46a52c525992d6b4ee08beb14cd69" args="() const " -->
+virtual const <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f43e6984fc7d4afd6eb32714c6b7b72"></a><!-- doxytag: member="TiXmlNode::ToDeclaration" ref="a9f43e6984fc7d4afd6eb32714c6b7b72" args="() const " -->
+virtual const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a4c8ac28ee7a745d059db6691e03bae"></a><!-- doxytag: member="TiXmlNode::ToDocument" ref="a6a4c8ac28ee7a745d059db6691e03bae" args="()" -->
+virtual <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa65d000223187d22a4dcebd7479e9ebc"></a><!-- doxytag: member="TiXmlNode::ToElement" ref="aa65d000223187d22a4dcebd7479e9ebc" args="()" -->
+virtual <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a383e06a0787f7063953934867990f849"></a><!-- doxytag: member="TiXmlNode::ToComment" ref="a383e06a0787f7063953934867990f849" args="()" -->
+virtual <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06de5af852668c7e4af0d09c205f0b0d"></a><!-- doxytag: member="TiXmlNode::ToUnknown" ref="a06de5af852668c7e4af0d09c205f0b0d" args="()" -->
+virtual <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ddfbcac78fbea041fad57e5c6d60a03"></a><!-- doxytag: member="TiXmlNode::ToText" ref="a3ddfbcac78fbea041fad57e5c6d60a03" args="()" -->
+virtual <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4027136ca820ff4a636b607231b6a6df"></a><!-- doxytag: member="TiXmlNode::ToDeclaration" ref="a4027136ca820ff4a636b607231b6a6df" args="()" -->
+virtual <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a> () const =0</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exact duplicate of this node and return it.  <a href="#a4508cc3a2d7a98e96a54cc09c37a78a4"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const =0</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a hierchical visit the nodes in the TinyXML DOM.  <a href="#acc0f88b7462c6cb73809d410a4f5bb86"></a><br/></td></tr>
+<tr><td colspan="2"><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173617f6dfe902cf484ce5552b950475"></a><!-- doxytag: member="TiXmlNode::TiXmlDocument" ref="a173617f6dfe902cf484ce5552b950475" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a173617f6dfe902cf484ce5552b950475">TiXmlDocument</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlNode::TiXmlElement" ref="ab6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ab6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An input stream operator, for every class.  <a href="#ab57bd426563c926844f65a78412e18b9"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An output stream operator, for every class.  <a href="#a86cd49cfb17a844c0010b3136ac966c7"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ef17e7080df2490cf87bde380685ab"></a><!-- doxytag: member="TiXmlNode::operator&lt;&lt;" ref="a52ef17e7080df2490cf87bde380685ab" args="(std::string &amp;out, const TiXmlNode &amp;base)" -->
+std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a> (std::string &amp;out, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the XML node or attribute to a std::string. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>The parent class for everything in the Document Object Model. </p>
+<p>(Except for attributes). Nodes have siblings, a parent, and children. A node can be in a document, or stand on its own. The type of a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a> can be queried, and it can be cast to its more defined type. </p>
+<hr/><h2>Member Enumeration Documentation</h2>
+<a class="anchor" id="a836eded4920ab9e9ef28496f48cd95a2"></a><!-- doxytag: member="TiXmlNode::NodeType" ref="a836eded4920ab9e9ef28496f48cd95a2" args="" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">enum <a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">TiXmlNode::NodeType</a></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The types of XML nodes supported by TinyXml. </p>
+<p>(All the unsupported types are picked up by UNKNOWN.) </p>
+
+</div>
+</div>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="acc0f88b7462c6cb73809d410a4f5bb86"></a><!-- doxytag: member="TiXmlNode::Accept" ref="acc0f88b7462c6cb73809d410a4f5bb86" args="(TiXmlVisitor *visitor) const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual bool TiXmlNode::Accept </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *&nbsp;</td>
+          <td class="paramname"> <em>visitor</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Accept a hierchical visit the nodes in the TinyXML DOM. </p>
+<p>Every node in the XML tree will be conditionally visited and the host will be called back via the <a class="el" href="classTiXmlVisitor.html" title="Implements the interface to the &quot;Visitor pattern&quot; (see the Accept() method...">TiXmlVisitor</a> interface.</p>
+<p>This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML is unchanged by using this interface versus any other.)</p>
+<p>The interface has been based on ideas from:</p>
+<ul>
+<li><a href="http://www.saxproject.org/">http://www.saxproject.org/</a></li>
+<li><a href="http://c2.com/cgi/wiki?HierarchicalVisitorPattern">http://c2.com/cgi/wiki?HierarchicalVisitorPattern</a></li>
+</ul>
+<p>Which are both good references for "visiting".</p>
+<p>An example of using <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">Accept()</a>: </p>
+<div class="fragment"><pre class="fragment">
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &amp;printer );
+		const char* xmlcstr = printer.CStr();
+		</pre></div> 
+<p>Implemented in <a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a4508cc3a2d7a98e96a54cc09c37a78a4"></a><!-- doxytag: member="TiXmlNode::Clone" ref="a4508cc3a2d7a98e96a54cc09c37a78a4" args="() const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::Clone </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Create an exact duplicate of this node and return it. </p>
+<p>The memory must be deleted by the caller. </p>
+
+<p>Implemented in <a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a1f05828d023150706eeb16d6fb3f6355"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="a1f05828d023150706eeb16d6fb3f6355" args="(const char *value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::FirstChild </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The first child of this node with the matching 'value'. </p>
+<p>Will be null if none found. </p>
+
+</div>
+</div>
+<a class="anchor" id="a80e397fa973cf5323e33b07154b024f3"></a><!-- doxytag: member="TiXmlNode::GetDocument" ref="a80e397fa973cf5323e33b07154b024f3" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>* TiXmlNode::GetDocument </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return a pointer to the Document this node lives in. </p>
+<p>Returns null if not in a document. </p>
+
+</div>
+</div>
+<a class="anchor" id="ad9b75e54ec19301c8b4d5ff583d0b3d5"></a><!-- doxytag: member="TiXmlNode::InsertAfterChild" ref="ad9b75e54ec19301c8b4d5ff583d0b3d5" args="(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertAfterChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>afterThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child after the specified child. Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0c146fa2fff0157b681594102f48cbc7"></a><!-- doxytag: member="TiXmlNode::InsertBeforeChild" ref="a0c146fa2fff0157b681594102f48cbc7" args="(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertBeforeChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>beforeThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child before the specified child. Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="ad7d4630e1a2a916edda16be22448a8ba"></a><!-- doxytag: member="TiXmlNode::InsertEndChild" ref="ad7d4630e1a2a916edda16be22448a8ba" args="(const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertEndChild </td>
+          <td>(</td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child past the LastChild. Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="a8621196ba3705fa226bef4a761cc51b6"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="a8621196ba3705fa226bef4a761cc51b6" args="(const TiXmlNode *previous) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::IterateChildren </td>
+          <td>(</td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>previous</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>An alternate way to walk the children of a node. </p>
+<p>One way to iterate over nodes is: </p>
+<div class="fragment"><pre class="fragment">
+			for( child = parent-&gt;FirstChild(); child; child = child-&gt;NextSibling() )
+		</pre></div><p>IterateChildren does the same thing with the syntax: </p>
+<div class="fragment"><pre class="fragment">
+			child = 0;
+			while( child = parent-&gt;IterateChildren( child ) )
+		</pre></div><p>IterateChildren takes the previous child as input and finds the next one. If the previous child is null, it returns the first. IterateChildren will return null when done. </p>
+
+</div>
+</div>
+<a class="anchor" id="a5d29442ae46de6d0168429156197bfc6"></a><!-- doxytag: member="TiXmlNode::LinkEndChild" ref="a5d29442ae46de6d0168429156197bfc6" args="(TiXmlNode *addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::LinkEndChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Add a new node related to this. </p>
+<p>Adds a child past the LastChild.</p>
+<p>NOTE: the node to be added is passed by pointer, and will be henceforth owned (and deleted) by tinyXml. This method is efficient and avoids an extra copy, but should be used with care as it uses a different memory model than the other insert functions.</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba" title="Add a new node related to this.">InsertEndChild</a> </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="a071ba77fd7ab79402fa84b7e9b8607b3"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a071ba77fd7ab79402fa84b7e9b8607b3" args="(const char *) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlNode::NextSiblingElement </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Convenience function to get through elements. </p>
+<p>Calls NextSibling and ToElement. Will skip all non-Element nodes. Returns 0 if there is not another element. </p>
+
+</div>
+</div>
+<a class="anchor" id="a73acf929d49d10bd0e5fb3d31b0372d1"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="a73acf929d49d10bd0e5fb3d31b0372d1" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlNode::NextSiblingElement </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Convenience function to get through elements. </p>
+<p>Calls NextSibling and ToElement. Will skip all non-Element nodes. Returns 0 if there is not another element. </p>
+
+</div>
+</div>
+<a class="anchor" id="a0c49e739a17b9938050c22cd89617fbd"></a><!-- doxytag: member="TiXmlNode::ReplaceChild" ref="a0c49e739a17b9938050c22cd89617fbd" args="(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::ReplaceChild </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>replaceThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>withThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Replace a child of this node. </p>
+<p>Returns a pointer to the new object or NULL if an error occured. </p>
+
+</div>
+</div>
+<a class="anchor" id="a2a38329ca5d3f28f98ce932b8299ae90"></a><!-- doxytag: member="TiXmlNode::SetValue" ref="a2a38329ca5d3f28f98ce932b8299ae90" args="(const char *_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlNode::SetValue </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Changes the value of the node. </p>
+<p>Defined as: </p>
+<div class="fragment"><pre class="fragment">
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		</pre></div> 
+<p>Referenced by <a class="el" href="tinyxml_8h_source.html#l01161">TiXmlComment::TiXmlComment()</a>, and <a class="el" href="tinyxml_8h_source.html#l01213">TiXmlText::TiXmlText()</a>.</p>
+
+</div>
+</div>
+<a class="anchor" id="a57b99d5c97d67a42b9752f5210a1ba5e"></a><!-- doxytag: member="TiXmlNode::Type" ref="a57b99d5c97d67a42b9752f5210a1ba5e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlNode::Type </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Query the type (as an enumerated value, above) of this node. </p>
+<p>The possible types are: DOCUMENT, ELEMENT, COMMENT, UNKNOWN, TEXT, and DECLARATION. </p>
+
+</div>
+</div>
+<a class="anchor" id="a77943eb90d12c2892b1337a9f5918b41"></a><!-- doxytag: member="TiXmlNode::Value" ref="a77943eb90d12c2892b1337a9f5918b41" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlNode::Value </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>The meaning of 'value' changes for the specific type of <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. </p>
+<div class="fragment"><pre class="fragment">
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		</pre></div><p>The subclasses will wrap this function. </p>
+
+</div>
+</div>
+<a class="anchor" id="a6d9e505619d39bf50bfd9609c9169ea5"></a><!-- doxytag: member="TiXmlNode::ValueStr" ref="a6d9e505619d39bf50bfd9609c9169ea5" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const std::string&amp; TiXmlNode::ValueStr </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Return <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &#39;value&#39; changes for the specific type of TiXmlNode.">Value()</a> as a std::string. </p>
+<p>If you only use STL, this is more efficient than calling <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &#39;value&#39; changes for the specific type of TiXmlNode.">Value()</a>. Only available in STL mode. </p>
+
+</div>
+</div>
+<hr/><h2>Friends And Related Function Documentation</h2>
+<a class="anchor" id="a86cd49cfb17a844c0010b3136ac966c7"></a><!-- doxytag: member="TiXmlNode::operator&lt;&lt;" ref="a86cd49cfb17a844c0010b3136ac966c7" args="(std::ostream &amp;out, const TiXmlNode &amp;base)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
+          <td>(</td>
+          <td class="paramtype">std::ostream &amp;&nbsp;</td>
+          <td class="paramname"> <em>out</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [friend]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>An output stream operator, for every class. </p>
+<p>Note that this outputs without any newlines or formatting, as opposed to <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print()</a>, which includes tabs and new lines.</p>
+<p>The operator&lt;&lt; and operator&gt;&gt; are not completely symmetric. Writing a node to a stream is very well defined. You'll get a nice stream of output, without any extra whitespace or newlines.</p>
+<p>But reading is not as well defined. (As it always is.) If you create a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> (for example) and read that from an input stream, the text needs to define an element or junk will result. This is true of all input streams, but it's worth keeping in mind.</p>
+<p>A <a class="el" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> will read nodes until it reads a root element, and all the children of that root element. </p>
+
+</div>
+</div>
+<a class="anchor" id="ab57bd426563c926844f65a78412e18b9"></a><!-- doxytag: member="TiXmlNode::operator&gt;&gt;" ref="ab57bd426563c926844f65a78412e18b9" args="(std::istream &amp;in, TiXmlNode &amp;base)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
+          <td>(</td>
+          <td class="paramtype">std::istream &amp;&nbsp;</td>
+          <td class="paramname"> <em>in</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td><code> [friend]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>An input stream operator, for every class. </p>
+<p>Tolerant of newlines and formatting, but doesn't expect them. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlNode-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlNode-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlNode-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlNode-members.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,107 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlNode Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlNode.html">TiXmlNode</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">Accept</a>(TiXmlVisitor *visitor) const =0</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a>() const =0</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">Print</a>(FILE *cfile, int depth) const =0</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlPrinter.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlPrinter.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlPrinter.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlPrinter.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,181 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlPrinter Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlPrinter Class Reference</h1><!-- doxytag: class="TiXmlPrinter" --><!-- doxytag: inherits="TiXmlVisitor" -->
+<p>Print to memory functionality.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlPrinter:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlPrinter.png" usemap="#TiXmlPrinter_map" alt=""/>
+  <map id="TiXmlPrinter_map" name="TiXmlPrinter_map">
+<area href="classTiXmlVisitor.html" alt="TiXmlVisitor" shape="rect" coords="0,0,81,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlPrinter-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a799f4f0388570cbb54c0d3c345fef7c1"></a><!-- doxytag: member="TiXmlPrinter::VisitEnter" ref="a799f4f0388570cbb54c0d3c345fef7c1" args="(const TiXmlDocument &amp;doc)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;doc)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66b33edd76c538b462f789b797a4fdf2"></a><!-- doxytag: member="TiXmlPrinter::VisitExit" ref="a66b33edd76c538b462f789b797a4fdf2" args="(const TiXmlDocument &amp;doc)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">VisitExit</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;doc)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c5e7bf8622838417a0d0bfb8f433854"></a><!-- doxytag: member="TiXmlPrinter::VisitEnter" ref="a0c5e7bf8622838417a0d0bfb8f433854" args="(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">VisitEnter</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;element, const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *firstAttribute)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1853cf2f6e63ad4b4232b4835e0acaf0"></a><!-- doxytag: member="TiXmlPrinter::VisitExit" ref="a1853cf2f6e63ad4b4232b4835e0acaf0" args="(const TiXmlElement &amp;element)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">VisitExit</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;element)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1b14d33eede2575c0743e2350f6a38"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="ace1b14d33eede2575c0743e2350f6a38" args="(const TiXmlDeclaration &amp;declaration)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">Visit</a> (const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> &amp;declaration)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a declaration. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a711e7d65d4af9ec70977568d2451fb1c"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="a711e7d65d4af9ec70977568d2451fb1c" args="(const TiXmlText &amp;text)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a711e7d65d4af9ec70977568d2451fb1c">Visit</a> (const <a class="el" href="classTiXmlText.html">TiXmlText</a> &amp;text)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a text node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83c13d6b980064b30f989f9a35498979"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="a83c13d6b980064b30f989f9a35498979" args="(const TiXmlComment &amp;comment)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">Visit</a> (const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> &amp;comment)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a comment node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2dca6dd106e8982fd3c7db1f3330970"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="ad2dca6dd106e8982fd3c7db1f3330970" args="(const TiXmlUnknown &amp;unknown)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ad2dca6dd106e8982fd3c7db1f3330970">Visit</a> (const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> &amp;unknown)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an unknow node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">SetIndent</a> (const char *_indent)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the indent characters for printing.  <a href="#a213377a4070c7e625bae59716b089e5e"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb33ec7d4bad6aaeb57f4304394b133d"></a><!-- doxytag: member="TiXmlPrinter::Indent" ref="abb33ec7d4bad6aaeb57f4304394b133d" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">Indent</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the indention string. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a> (const char *_lineBreak)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the line breaking string.  <a href="#a4be1e37e69e3858c59635aa947174fe6"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f1b4804a460b175ec244eb5724d96d"></a><!-- doxytag: member="TiXmlPrinter::LineBreak" ref="a11f1b4804a460b175ec244eb5724d96d" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">LineBreak</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the current line breaking string. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch over to "stream printing" which is the most dense formatting without linebreaks.  <a href="#ab23a90629e374cb1cadca090468bbd19"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859eede9597d3e0355b77757be48735e"></a><!-- doxytag: member="TiXmlPrinter::CStr" ref="a859eede9597d3e0355b77757be48735e" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">CStr</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad01375ae9199bd2f48252eaddce3039d"></a><!-- doxytag: member="TiXmlPrinter::Size" ref="ad01375ae9199bd2f48252eaddce3039d" args="()" -->
+size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">Size</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length of the result string. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bd4daf44309b41f5813a833caa0d1c9"></a><!-- doxytag: member="TiXmlPrinter::Str" ref="a3bd4daf44309b41f5813a833caa0d1c9" args="()" -->
+const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">Str</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Print to memory functionality. </p>
+<p>The <a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> is useful when you need to:</p>
+<ol type="1">
+<li>Print to memory (especially in non-STL mode)</li>
+<li>Control formatting (line endings, etc.)</li>
+</ol>
+<p>When constructed, the <a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> is in its default "pretty printing" mode. Before calling Accept() you can call methods to control the printing of the XML document. After <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">TiXmlNode::Accept()</a> is called, the printed document can be accessed via the <a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e" title="Return the result.">CStr()</a>, <a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9" title="Return the result.">Str()</a>, and <a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d" title="Return the length of the result string.">Size()</a> methods.</p>
+<p><a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> uses the Visitor API. </p>
+<div class="fragment"><pre class="fragment">
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &amp;printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	</pre></div> <hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a213377a4070c7e625bae59716b089e5e"></a><!-- doxytag: member="TiXmlPrinter::SetIndent" ref="a213377a4070c7e625bae59716b089e5e" args="(const char *_indent)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetIndent </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_indent</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Set the indent characters for printing. </p>
+<p>By default 4 spaces but tab () is also useful, or null/empty string for no indentation. </p>
+
+</div>
+</div>
+<a class="anchor" id="a4be1e37e69e3858c59635aa947174fe6"></a><!-- doxytag: member="TiXmlPrinter::SetLineBreak" ref="a4be1e37e69e3858c59635aa947174fe6" args="(const char *_lineBreak)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetLineBreak </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_lineBreak</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Set the line breaking string. </p>
+<p>By default set to newline (<br/>
+). Some operating systems prefer other characters, or can be set to the null/empty string for no indenation. </p>
+
+</div>
+</div>
+<a class="anchor" id="ab23a90629e374cb1cadca090468bbd19"></a><!-- doxytag: member="TiXmlPrinter::SetStreamPrinting" ref="ab23a90629e374cb1cadca090468bbd19" args="()" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetStreamPrinting </td>
+          <td>(</td>
+          <td class="paramname"></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Switch over to "stream printing" which is the most dense formatting without linebreaks. </p>
+<p>Common when the XML is needed for network transmission. </p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlPrinter-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlPrinter-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlPrinter-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlPrinter-members.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,51 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlPrinter Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">CStr</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">Indent</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">LineBreak</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">SetIndent</a>(const char *_indent)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a>(const char *_lineBreak)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">Size</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">Str</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">Visit</a>(const TiXmlDeclaration &amp;declaration)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a711e7d65d4af9ec70977568d2451fb1c">Visit</a>(const TiXmlText &amp;text)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">Visit</a>(const TiXmlComment &amp;comment)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ad2dca6dd106e8982fd3c7db1f3330970">Visit</a>(const TiXmlUnknown &amp;unknown)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a>(const TiXmlDocument &amp;doc)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">VisitEnter</a>(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">VisitExit</a>(const TiXmlDocument &amp;doc)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">VisitExit</a>(const TiXmlElement &amp;element)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlText.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlText.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlText.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlText.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,149 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlText Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlText Class Reference</h1><!-- doxytag: class="TiXmlText" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>XML text.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlText:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlText.png" usemap="#TiXmlText_map" alt=""/>
+  <map id="TiXmlText_map" name="TiXmlText_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,73,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,73,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlText-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a> (const char *initValue)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for text element.  <a href="#af659e77c6b87d684827f35a8f4895960"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a439792f6183a3d3fb6f2bc2b16fa5691"></a><!-- doxytag: member="TiXmlText::TiXmlText" ref="a439792f6183a3d3fb6f2bc2b16fa5691" args="(const std::string &amp;initValue)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a> (const std::string &amp;initValue)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a0cafbf6f236c7f02d12b2bffc2b7976b"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a6a6b83fa2271022dd97c072a2b586"></a><!-- doxytag: member="TiXmlText::CDATA" ref="ad1a6a6b83fa2271022dd97c072a2b586" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">CDATA</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether this represents text using a CDATA section. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb17ff7c5d09b2c839393445a3de5ea9"></a><!-- doxytag: member="TiXmlText::SetCDATA" ref="acb17ff7c5d09b2c839393445a3de5ea9" args="(bool _cdata)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a> (bool _cdata)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on or off a CDATA representation of text. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a895bf34ffad17f7439ab2a52b9651648"></a><!-- doxytag: member="TiXmlText::ToText" ref="a895bf34ffad17f7439ab2a52b9651648" args="() const " -->
+virtual const <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">ToText</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c3a8fd3e4dbf6c0c4363a943d72f5b"></a><!-- doxytag: member="TiXmlText::ToText" ref="ae7c3a8fd3e4dbf6c0c4363a943d72f5b" args="()" -->
+virtual <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">ToText</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8483d4415ce9de6c4fa8f63d067d5de6"></a><!-- doxytag: member="TiXmlText::Accept" ref="a8483d4415ce9de6c4fa8f63d067d5de6" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c411e93a27537369479d034cc82da3b"></a><!-- doxytag: member="TiXmlText::Clone" ref="a0c411e93a27537369479d034cc82da3b" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[internal use] Creates a new Element and returns it. <br/></td></tr>
+<tr><td colspan="2"><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlText::TiXmlElement" ref="ab6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#ab6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>XML text. </p>
+<p>A text node can have 2 ways to output the next. "normal" output and CDATA. It will default to the mode it was parsed from the XML file and you generally want to leave it alone, but you can change the output mode with <a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9" title="Turns on or off a CDATA representation of text.">SetCDATA()</a> and query it with <a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586" title="Queries whether this represents text using a CDATA section.">CDATA()</a>. </p>
+<hr/><h2>Constructor &amp; Destructor Documentation</h2>
+<a class="anchor" id="af659e77c6b87d684827f35a8f4895960"></a><!-- doxytag: member="TiXmlText::TiXmlText" ref="af659e77c6b87d684827f35a8f4895960" args="(const char *initValue)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">TiXmlText::TiXmlText </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>initValue</em></td>
+          <td>&nbsp;)&nbsp;</td>
+          <td><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>Constructor for text element. </p>
+<p>By default, it is treated as normal, encoded text. If you want it be output as a CDATA text element, set the parameter _cdata to 'true' </p>
+
+<p>References <a class="el" href="tinyxml_8h_source.html#l00508">TiXmlNode::SetValue()</a>.</p>
+
+</div>
+</div>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a0cafbf6f236c7f02d12b2bffc2b7976b"></a><!-- doxytag: member="TiXmlText::Print" ref="a0cafbf6f236c7f02d12b2bffc2b7976b" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlText::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlText-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlText-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlText-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlText-members.html.svn-base	2013-05-09 18:10:01.631874319 +0200
@@ -0,0 +1,111 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlText Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlText.html">TiXmlText</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">CDATA</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">Clone</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [protected, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a>(bool _cdata)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a>(const char *initValue)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a>(const std::string &amp;initValue)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">ToText</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">ToText</a>()</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlUnknown.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlUnknown.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlUnknown.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlUnknown.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,111 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlUnknown Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlUnknown Class Reference</h1><!-- doxytag: class="TiXmlUnknown" --><!-- doxytag: inherits="TiXmlNode" -->
+<p>Any tag that tinyXml doesn't recognize is saved as an unknown.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlUnknown:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlUnknown.png" usemap="#TiXmlUnknown_map" alt=""/>
+  <map id="TiXmlUnknown_map" name="TiXmlUnknown_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,94,80"/>
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,94,24"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlUnknown-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0960bb7428b3f341da46244229604d73"></a><!-- doxytag: member="TiXmlUnknown::Clone" ref="a0960bb7428b3f341da46244229604d73" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">Clone</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this Unknown and returns it. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">Print</a> (FILE *cfile, int depth) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#a31ba089a40fb5a1869750fce09b0bacb"></a><br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0313e5fe77987d746ac1a97a254419d"></a><!-- doxytag: member="TiXmlUnknown::ToUnknown" ref="ab0313e5fe77987d746ac1a97a254419d" args="() const " -->
+virtual const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">ToUnknown</a> () const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67c9fd22940e8c47f706a72cdd2e332c"></a><!-- doxytag: member="TiXmlUnknown::ToUnknown" ref="a67c9fd22940e8c47f706a72cdd2e332c" args="()" -->
+virtual <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c">ToUnknown</a> ()</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7122e5135581b3c832a1a3217760a93"></a><!-- doxytag: member="TiXmlUnknown::Accept" ref="ad7122e5135581b3c832a1a3217760a93" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Any tag that tinyXml doesn't recognize is saved as an unknown. </p>
+<p>It is a tag of text, but should not be modified. It will be written back to the XML, unchanged, when the file is saved.</p>
+<p>DTD tags get thrown into TiXmlUnknowns. </p>
+<hr/><h2>Member Function Documentation</h2>
+<a class="anchor" id="a31ba089a40fb5a1869750fce09b0bacb"></a><!-- doxytag: member="TiXmlUnknown::Print" ref="a31ba089a40fb5a1869750fce09b0bacb" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlUnknown::Print </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. </p>
+<p>) Either or both cfile and str can be null.</p>
+<p>This is a formatted print, and will insert tabs and newlines.</p>
+<p>(For an unformatted stream, use the &lt;&lt; operator.) </p>
+
+<p>Implements <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.</p>
+
+</div>
+</div>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlUnknown-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlUnknown-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlUnknown-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlUnknown-members.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,107 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlUnknown Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">Clone</a>() const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#accda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c">ToUnknown</a>()</td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlVisitor.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlVisitor.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlVisitor.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlVisitor.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TiXmlVisitor Class Reference</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlVisitor Class Reference</h1><!-- doxytag: class="TiXmlVisitor" -->
+<p>Implements the interface to the "Visitor pattern" (see the Accept() method.  
+<a href="#_details">More...</a></p>
+
+<p><code>#include &lt;<a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>&gt;</code></p>
+<div class="dynheader">
+Inheritance diagram for TiXmlVisitor:</div>
+<div class="dynsection">
+ <div class="center">
+  <img src="classTiXmlVisitor.png" usemap="#TiXmlVisitor_map" alt=""/>
+  <map id="TiXmlVisitor_map" name="TiXmlVisitor_map">
+<area href="classTiXmlPrinter.html" alt="TiXmlPrinter" shape="rect" coords="0,56,81,80"/>
+</map>
+ </div>
+</div>
+
+<p><a href="classTiXmlVisitor-members.html">List of all members.</a></p>
+<table border="0" cellpadding="0" cellspacing="0">
+<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07baecb52dd7d8716ae2a48ad0956ee0"></a><!-- doxytag: member="TiXmlVisitor::VisitEnter" ref="a07baecb52dd7d8716ae2a48ad0956ee0" args="(const TiXmlDocument &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ade4f27087447e93974e975c3246ad"></a><!-- doxytag: member="TiXmlVisitor::VisitExit" ref="aa0ade4f27087447e93974e975c3246ad" args="(const TiXmlDocument &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">VisitExit</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6c6178ffa517bbdba95d70490875fff"></a><!-- doxytag: member="TiXmlVisitor::VisitEnter" ref="af6c6178ffa517bbdba95d70490875fff" args="(const TiXmlElement &amp;, const TiXmlAttribute *)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">VisitEnter</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;, const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec2b1f8116226d52f3a1b95dafd3a32c"></a><!-- doxytag: member="TiXmlVisitor::VisitExit" ref="aec2b1f8116226d52f3a1b95dafd3a32c" args="(const TiXmlElement &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">VisitExit</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad71c71ce6473fb9b4b64cd92de4a19"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="afad71c71ce6473fb9b4b64cd92de4a19" args="(const TiXmlDeclaration &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">Visit</a> (const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a declaration. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a399b8ebca5cd14664974a32d2ce029e5"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="a399b8ebca5cd14664974a32d2ce029e5" args="(const TiXmlText &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">Visit</a> (const <a class="el" href="classTiXmlText.html">TiXmlText</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a text node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a60e7a528627b31af3161972cc7fa2"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="a53a60e7a528627b31af3161972cc7fa2" args="(const TiXmlComment &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">Visit</a> (const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a comment node. <br/></td></tr>
+<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e284d607d275c51dac1adb58159ce28"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="a7e284d607d275c51dac1adb58159ce28" args="(const TiXmlUnknown &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28">Visit</a> (const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> &amp;)</td></tr>
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an unknow node. <br/></td></tr>
+</table>
+<hr/><a name="_details"></a><h2>Detailed Description</h2>
+<p>Implements the interface to the "Visitor pattern" (see the Accept() method. </p>
+<p>) If you call the Accept() method, it requires being passed a <a class="el" href="classTiXmlVisitor.html" title="Implements the interface to the &quot;Visitor pattern&quot; (see the Accept() method...">TiXmlVisitor</a> class to handle callbacks. For nodes that contain other nodes (Document, Element) you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves are simply called with <a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19" title="Visit a declaration.">Visit()</a>.</p>
+<p>If you return 'true' from a Visit method, recursive parsing will continue. If you return false, <b>no children of this node or its sibilings</b> will be Visited.</p>
+<p>All flavors of Visit methods have a default implementation that returns 'true' (continue visiting). You need to only override methods that are interesting to you.</p>
+<p>Generally Accept() is called on the <a class="el" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>, although all nodes suppert Visiting.</p>
+<p>You should never change the document from a callback.</p>
+<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">TiXmlNode::Accept()</a> </dd></dl>
+<hr/>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h_source.html">tinyxml.h</a></li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlVisitor-members.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlVisitor-members.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/classTiXmlVisitor-members.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/classTiXmlVisitor-members.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,43 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Member List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TiXmlVisitor Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a>, including all inherited members.<table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">Visit</a>(const TiXmlDeclaration &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">Visit</a>(const TiXmlText &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">Visit</a>(const TiXmlComment &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28">Visit</a>(const TiXmlUnknown &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a>(const TiXmlDocument &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">VisitEnter</a>(const TiXmlElement &amp;, const TiXmlAttribute *)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">VisitExit</a>(const TiXmlDocument &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">VisitExit</a>(const TiXmlElement &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+</table></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/deprecated.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/deprecated.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/deprecated.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/deprecated.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,49 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Deprecated List</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+
+
+<h1><a class="anchor" id="deprecated">Deprecated List </a></h1><p><a class="anchor" id="_deprecated000002"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">TiXmlHandle::Element</a> () const  </dt>
+<dd>use ToElement. Return the handle as a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>. This may return null. </dd>
+</dl>
+<p><a class="anchor" id="_deprecated000001"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">TiXmlHandle::Node</a> () const  </dt>
+<dd>use ToNode. Return the handle as a <a class="el" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>. This may return null. </dd>
+</dl>
+<p><a class="anchor" id="_deprecated000003"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle::Text</a> () const  </dt>
+<dd>use ToText() Return the handle as a <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. This may return null. </dd>
+</dl>
+<p><a class="anchor" id="_deprecated000004"></a> </p>
+<dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">TiXmlHandle::Unknown</a> () const  </dt>
+<dd>use ToUnknown() Return the handle as a <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a>. This may return null. </dd>
+</dl>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/doxygen.css.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/doxygen.css.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/doxygen.css.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/doxygen.css.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,532 @@
+/* The standard CSS for doxygen */
+
+body, table, div, p, dl {
+	font-family: Lucida Grande, Verdana, Geneva, Arial, sans-serif;
+	font-size: 12px;
+}
+
+/* @group Heading Levels */
+
+h1 {
+	text-align: center;
+	font-size: 150%;
+}
+
+h2 {
+	font-size: 120%;
+}
+
+h3 {
+	font-size: 100%;
+}
+
+dt {
+	font-weight: bold;
+}
+
+div.multicol {
+	-moz-column-gap: 1em;
+	-webkit-column-gap: 1em;
+	-moz-column-count: 3;
+	-webkit-column-count: 3;
+}
+
+p.startli, p.startdd, p.starttd {
+	margin-top: 2px;
+}
+
+p.endli {
+	margin-bottom: 0px;
+}
+
+p.enddd {
+	margin-bottom: 4px;
+}
+
+p.endtd {
+	margin-bottom: 2px;
+}
+
+/* @end */
+
+caption {
+	font-weight: bold;
+}
+
+span.legend {
+        font-size: 70%;
+        text-align: center;
+}
+
+h3.version {
+        font-size: 90%;
+        text-align: center;
+}
+
+div.qindex, div.navtab{
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	padding: 2px;
+}
+
+div.qindex, div.navpath {
+	width: 100%;
+	line-height: 140%;
+}
+
+div.navtab {
+	margin-right: 15px;
+}
+
+/* @group Link Styling */
+
+a {
+	color: #153788;
+	font-weight: normal;
+	text-decoration: none;
+}
+
+.contents a:visited {
+	color: #1b77c5;
+}
+
+a:hover {
+	text-decoration: underline;
+}
+
+a.qindex {
+	font-weight: bold;
+}
+
+a.qindexHL {
+	font-weight: bold;
+	background-color: #6666cc;
+	color: #ffffff;
+	border: 1px double #9295C2;
+}
+
+.contents a.qindexHL:visited {
+        color: #ffffff;
+}
+
+a.el {
+	font-weight: bold;
+}
+
+a.elRef {
+}
+
+a.code {
+	color: #3030f0;
+}
+
+a.codeRef {
+	color: #3030f0;
+}
+
+/* @end */
+
+dl.el {
+	margin-left: -1cm;
+}
+
+.fragment {
+	font-family: monospace, fixed;
+	font-size: 105%;
+}
+
+pre.fragment {
+	border: 1px solid #CCCCCC;
+	background-color: #f5f5f5;
+	padding: 4px 6px;
+	margin: 4px 8px 4px 2px;
+	overflow: auto;
+	word-wrap: break-word;
+	font-size:  9pt;
+	line-height: 125%;
+}
+
+div.ah {
+	background-color: black;
+	font-weight: bold;
+	color: #ffffff;
+	margin-bottom: 3px;
+	margin-top: 3px
+}
+
+div.groupHeader {
+	margin-left: 16px;
+	margin-top: 12px;
+	margin-bottom: 6px;
+	font-weight: bold;
+}
+
+div.groupText {
+	margin-left: 16px;
+	font-style: italic;
+}
+
+body {
+	background: white;
+	color: black;
+	margin-right: 20px;
+	margin-left: 20px;
+}
+
+td.indexkey {
+	background-color: #e8eef2;
+	font-weight: bold;
+	border: 1px solid #CCCCCC;
+	margin: 2px 0px 2px 0;
+	padding: 2px 10px;
+}
+
+td.indexvalue {
+	background-color: #e8eef2;
+	border: 1px solid #CCCCCC;
+	padding: 2px 10px;
+	margin: 2px 0px;
+}
+
+tr.memlist {
+	background-color: #f0f0f0;
+}
+
+p.formulaDsp {
+	text-align: center;
+}
+
+img.formulaDsp {
+	
+}
+
+img.formulaInl {
+	vertical-align: middle;
+}
+
+div.center {
+	text-align: center;
+        margin-top: 0px;
+        margin-bottom: 0px;
+        padding: 0px;
+}
+
+div.center img {
+	border: 0px;
+}
+
+img.footer {
+	border: 0px;
+	vertical-align: middle;
+}
+
+/* @group Code Colorization */
+
+span.keyword {
+	color: #008000
+}
+
+span.keywordtype {
+	color: #604020
+}
+
+span.keywordflow {
+	color: #e08000
+}
+
+span.comment {
+	color: #800000
+}
+
+span.preprocessor {
+	color: #806020
+}
+
+span.stringliteral {
+	color: #002080
+}
+
+span.charliteral {
+	color: #008080
+}
+
+span.vhdldigit { 
+	color: #ff00ff 
+}
+
+span.vhdlchar { 
+	color: #000000 
+}
+
+span.vhdlkeyword { 
+	color: #700070 
+}
+
+span.vhdllogic { 
+	color: #ff0000 
+}
+
+/* @end */
+
+.search {
+	color: #003399;
+	font-weight: bold;
+}
+
+form.search {
+	margin-bottom: 0px;
+	margin-top: 0px;
+}
+
+input.search {
+	font-size: 75%;
+	color: #000080;
+	font-weight: normal;
+	background-color: #e8eef2;
+}
+
+td.tiny {
+	font-size: 75%;
+}
+
+.dirtab {
+	padding: 4px;
+	border-collapse: collapse;
+	border: 1px solid #84b0c7;
+}
+
+th.dirtab {
+	background: #e8eef2;
+	font-weight: bold;
+}
+
+hr {
+	height: 0;
+	border: none;
+	border-top: 1px solid #666;
+}
+
+/* @group Member Descriptions */
+
+.mdescLeft, .mdescRight,
+.memItemLeft, .memItemRight,
+.memTemplItemLeft, .memTemplItemRight, .memTemplParams {
+	background-color: #FAFAFA;
+	border: none;
+	margin: 4px;
+	padding: 1px 0 0 8px;
+}
+
+.mdescLeft, .mdescRight {
+	padding: 0px 8px 4px 8px;
+	color: #555;
+}
+
+.memItemLeft, .memItemRight, .memTemplParams {
+	border-top: 1px solid #ccc;
+}
+
+.memItemLeft, .memTemplItemLeft {
+        white-space: nowrap;
+}
+
+.memTemplParams {
+	color: #606060;
+        white-space: nowrap;
+}
+
+/* @end */
+
+/* @group Member Details */
+
+/* Styles for detailed member documentation */
+
+.memtemplate {
+	font-size: 80%;
+	color: #606060;
+	font-weight: normal;
+	margin-left: 3px;
+}
+
+.memnav {
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	margin-right: 15px;
+	padding: 2px;
+}
+
+.memitem {
+	padding: 0;
+	margin-bottom: 10px;
+}
+
+.memname {
+	white-space: nowrap;
+	font-weight: bold;
+}
+
+.memproto, .memdoc {
+	border: 1px solid #84b0c7;	
+}
+
+.memproto {
+	padding: 0;
+	background-color: #d5e1e8;
+	font-weight: bold;
+	-webkit-border-top-left-radius: 8px;
+	-webkit-border-top-right-radius: 8px;
+        -webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.15);
+	-moz-border-radius-topleft: 8px;
+	-moz-border-radius-topright: 8px;
+        -moz-box-shadow: rgba(0, 0, 0, 0.15) 5px 5px 5px;
+
+}
+
+.memdoc {
+	padding: 2px 5px;
+	background-color: #eef3f5;
+	border-top-width: 0;
+	-webkit-border-bottom-left-radius: 8px;
+	-webkit-border-bottom-right-radius: 8px;
+        -webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.15);
+	-moz-border-radius-bottomleft: 8px;
+	-moz-border-radius-bottomright: 8px;
+        -moz-box-shadow: rgba(0, 0, 0, 0.15) 5px 5px 5px;
+}
+
+.paramkey {
+	text-align: right;
+}
+
+.paramtype {
+	white-space: nowrap;
+}
+
+.paramname {
+	color: #602020;
+	white-space: nowrap;
+}
+.paramname em {
+	font-style: normal;
+}
+
+/* @end */
+
+/* @group Directory (tree) */
+
+/* for the tree view */
+
+.ftvtree {
+	font-family: sans-serif;
+	margin: 0.5em;
+}
+
+/* these are for tree view when used as main index */
+
+.directory {
+	font-size: 9pt;
+	font-weight: bold;
+}
+
+.directory h3 {
+	margin: 0px;
+	margin-top: 1em;
+	font-size: 11pt;
+}
+
+/*
+The following two styles can be used to replace the root node title
+with an image of your choice.  Simply uncomment the next two styles,
+specify the name of your image and be sure to set 'height' to the
+proper pixel height of your image.
+*/
+
+/*
+.directory h3.swap {
+	height: 61px;
+	background-repeat: no-repeat;
+	background-image: url("yourimage.gif");
+}
+.directory h3.swap span {
+	display: none;
+}
+*/
+
+.directory > h3 {
+	margin-top: 0;
+}
+
+.directory p {
+	margin: 0px;
+	white-space: nowrap;
+}
+
+.directory div {
+	display: none;
+	margin: 0px;
+}
+
+.directory img {
+	vertical-align: -30%;
+}
+
+/* these are for tree view when not used as main index */
+
+.directory-alt {
+	font-size: 100%;
+	font-weight: bold;
+}
+
+.directory-alt h3 {
+	margin: 0px;
+	margin-top: 1em;
+	font-size: 11pt;
+}
+
+.directory-alt > h3 {
+	margin-top: 0;
+}
+
+.directory-alt p {
+	margin: 0px;
+	white-space: nowrap;
+}
+
+.directory-alt div {
+	display: none;
+	margin: 0px;
+}
+
+.directory-alt img {
+	vertical-align: -30%;
+}
+
+/* @end */
+
+address {
+	font-style: normal;
+	color: #333;
+}
+
+table.doxtable {
+	border-collapse:collapse;
+}
+
+table.doxtable td, table.doxtable th {
+	border: 1px solid #153788;
+	padding: 3px 7px 2px;
+}
+
+table.doxtable th {
+	background-color: #254798;
+	color: #FFFFFF;
+	font-size: 110%;
+	padding-bottom: 4px;
+	padding-top: 5px;
+	text-align:left;
+}
+
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/files.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/files.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/files.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/files.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,36 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: File Index</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li class="current"><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="files.html"><span>File&nbsp;List</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>File List</h1>Here is a list of all documented files with brief descriptions:<table>
+  <tr><td class="indexkey"><b>tinystr.h</b> <a href="tinystr_8h_source.html">[code]</a></td><td class="indexvalue"></td></tr>
+  <tr><td class="indexkey"><b>tinyxml.h</b> <a href="tinyxml_8h_source.html">[code]</a></td><td class="indexvalue"></td></tr>
+</table>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x63.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x63.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x63.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x63.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,98 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li class="current"><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_c">- c -</a></h3><ul>
+<li>CDATA()
+: <a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">TiXmlText</a>
+</li>
+<li>Child()
+: <a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">TiXmlHandle</a>
+</li>
+<li>ChildElement()
+: <a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">TiXmlHandle</a>
+</li>
+<li>Clear()
+: <a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">TiXmlNode</a>
+</li>
+<li>ClearError()
+: <a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">TiXmlDocument</a>
+</li>
+<li>Clone()
+: <a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>
+, <a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>
+, <a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>
+, <a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">TiXmlText</a>
+</li>
+<li>Column()
+: <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase</a>
+</li>
+<li>CStr()
+: <a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x64.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x64.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x64.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x64.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,71 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li class="current"><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_d">- d -</a></h3><ul>
+<li>DoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">TiXmlAttribute</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x65.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x65.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x65.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x65.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,92 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li class="current"><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_e">- e -</a></h3><ul>
+<li>Element()
+: <a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">TiXmlHandle</a>
+</li>
+<li>EncodeString()
+: <a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">TiXmlBase</a>
+</li>
+<li>Encoding()
+: <a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">TiXmlDeclaration</a>
+</li>
+<li>Error()
+: <a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">TiXmlDocument</a>
+</li>
+<li>ErrorCol()
+: <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">TiXmlDocument</a>
+</li>
+<li>ErrorDesc()
+: <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">TiXmlDocument</a>
+</li>
+<li>ErrorId()
+: <a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">TiXmlDocument</a>
+</li>
+<li>ErrorRow()
+: <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x66.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x66.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x66.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x66.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li class="current"><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_f">- f -</a></h3><ul>
+<li>FirstAttribute()
+: <a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">TiXmlElement</a>
+</li>
+<li>FirstChild()
+: <a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">TiXmlHandle</a>
+</li>
+<li>FirstChildElement()
+: <a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x67.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x67.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x67.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x67.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,77 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li class="current"><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_g">- g -</a></h3><ul>
+<li>GetDocument()
+: <a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">TiXmlNode</a>
+</li>
+<li>GetText()
+: <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">TiXmlElement</a>
+</li>
+<li>GetUserData()
+: <a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x69.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x69.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x69.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x69.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li class="current"><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_i">- i -</a></h3><ul>
+<li>Indent()
+: <a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">TiXmlPrinter</a>
+</li>
+<li>InsertAfterChild()
+: <a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">TiXmlNode</a>
+</li>
+<li>InsertBeforeChild()
+: <a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">TiXmlNode</a>
+</li>
+<li>InsertEndChild()
+: <a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">TiXmlNode</a>
+</li>
+<li>IntValue()
+: <a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">TiXmlAttribute</a>
+</li>
+<li>IsWhiteSpaceCondensed()
+: <a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">TiXmlBase</a>
+</li>
+<li>IterateChildren()
+: <a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x6c.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x6c.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x6c.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x6c.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,83 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li class="current"><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_l">- l -</a></h3><ul>
+<li>LastAttribute()
+: <a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">TiXmlElement</a>
+</li>
+<li>LastChild()
+: <a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">TiXmlNode</a>
+</li>
+<li>LineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">TiXmlPrinter</a>
+</li>
+<li>LinkEndChild()
+: <a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">TiXmlNode</a>
+</li>
+<li>LoadFile()
+: <a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x6e.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x6e.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x6e.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x6e.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li class="current"><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_n">- n -</a></h3><ul>
+<li>Name()
+: <a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">TiXmlAttribute</a>
+</li>
+<li>Next()
+: <a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">TiXmlAttribute</a>
+</li>
+<li>NextSibling()
+: <a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">TiXmlNode</a>
+</li>
+<li>NextSiblingElement()
+: <a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">TiXmlNode</a>
+</li>
+<li>NoChildren()
+: <a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">TiXmlNode</a>
+</li>
+<li>Node()
+: <a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">TiXmlHandle</a>
+</li>
+<li>NodeType
+: <a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x6f.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x6f.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x6f.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x6f.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,74 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li class="current"><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_o">- o -</a></h3><ul>
+<li>operator&lt;&lt;
+: <a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">TiXmlNode</a>
+</li>
+<li>operator&gt;&gt;
+: <a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x70.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x70.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x70.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x70.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,91 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li class="current"><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_p">- p -</a></h3><ul>
+<li>Parent()
+: <a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">TiXmlNode</a>
+</li>
+<li>Parse()
+: <a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">TiXmlDocument</a>
+</li>
+<li>Previous()
+: <a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">TiXmlAttribute</a>
+</li>
+<li>PreviousSibling()
+: <a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">TiXmlNode</a>
+</li>
+<li>Print()
+: <a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>
+, <a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>
+, <a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>
+, <a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>
+, <a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>
+, <a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x71.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x71.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x71.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x71.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,89 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li class="current"><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_q">- q -</a></h3><ul>
+<li>QueryDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">TiXmlElement</a>
+</li>
+<li>QueryDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">TiXmlAttribute</a>
+</li>
+<li>QueryFloatAttribute()
+: <a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">TiXmlElement</a>
+</li>
+<li>QueryIntAttribute()
+: <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">TiXmlElement</a>
+</li>
+<li>QueryIntValue()
+: <a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">TiXmlAttribute</a>
+</li>
+<li>QueryStringAttribute()
+: <a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">TiXmlElement</a>
+</li>
+<li>QueryValueAttribute()
+: <a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x72.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x72.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x72.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x72.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,83 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li class="current"><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_r">- r -</a></h3><ul>
+<li>RemoveAttribute()
+: <a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">TiXmlElement</a>
+</li>
+<li>RemoveChild()
+: <a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">TiXmlNode</a>
+</li>
+<li>ReplaceChild()
+: <a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">TiXmlNode</a>
+</li>
+<li>RootElement()
+: <a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">TiXmlDocument</a>
+</li>
+<li>Row()
+: <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x73.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x73.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x73.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x73.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,121 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li class="current"><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_s">- s -</a></h3><ul>
+<li>SaveFile()
+: <a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">TiXmlDocument</a>
+</li>
+<li>SetAttribute()
+: <a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">TiXmlElement</a>
+</li>
+<li>SetCDATA()
+: <a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">TiXmlText</a>
+</li>
+<li>SetCondenseWhiteSpace()
+: <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">TiXmlBase</a>
+</li>
+<li>SetDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">TiXmlElement</a>
+</li>
+<li>SetDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">TiXmlAttribute</a>
+</li>
+<li>SetIndent()
+: <a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">TiXmlPrinter</a>
+</li>
+<li>SetIntValue()
+: <a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">TiXmlAttribute</a>
+</li>
+<li>SetLineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">TiXmlPrinter</a>
+</li>
+<li>SetName()
+: <a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">TiXmlAttribute</a>
+</li>
+<li>SetStreamPrinting()
+: <a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">TiXmlPrinter</a>
+</li>
+<li>SetTabSize()
+: <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument</a>
+</li>
+<li>SetUserData()
+: <a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">TiXmlBase</a>
+</li>
+<li>SetValue()
+: <a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">TiXmlAttribute</a>
+</li>
+<li>Size()
+: <a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">TiXmlPrinter</a>
+</li>
+<li>Standalone()
+: <a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">TiXmlDeclaration</a>
+</li>
+<li>Str()
+: <a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x74.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x74.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x74.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x74.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,127 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li class="current"><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_t">- t -</a></h3><ul>
+<li>Text()
+: <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle</a>
+</li>
+<li>TiXmlAttribute()
+: <a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>
+</li>
+<li>TiXmlComment()
+: <a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>
+</li>
+<li>TiXmlDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>
+</li>
+<li>TiXmlDocument()
+: <a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>
+</li>
+<li>TiXmlElement()
+: <a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>
+</li>
+<li>TiXmlHandle()
+: <a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>
+</li>
+<li>TiXmlText()
+: <a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a>
+</li>
+<li>ToComment()
+: <a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">TiXmlNode</a>
+, <a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">TiXmlComment</a>
+</li>
+<li>ToDeclaration()
+: <a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">TiXmlDeclaration</a>
+</li>
+<li>ToDocument()
+: <a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">TiXmlNode</a>
+, <a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">TiXmlDocument</a>
+</li>
+<li>ToElement()
+: <a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">TiXmlElement</a>
+, <a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">TiXmlHandle</a>
+</li>
+<li>ToNode()
+: <a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">TiXmlHandle</a>
+</li>
+<li>ToText()
+: <a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">TiXmlText</a>
+, <a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode</a>
+, <a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">TiXmlText</a>
+</li>
+<li>ToUnknown()
+: <a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">TiXmlNode</a>
+, <a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">TiXmlHandle</a>
+</li>
+<li>Type()
+: <a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x75.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x75.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x75.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x75.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,74 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li class="current"><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_u">- u -</a></h3><ul>
+<li>Unknown()
+: <a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">TiXmlHandle</a>
+</li>
+<li>userData
+: <a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x76.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x76.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_0x76.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_0x76.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,97 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li class="current"><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_v">- v -</a></h3><ul>
+<li>Value()
+: <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">TiXmlAttribute</a>
+</li>
+<li>ValueStr()
+: <a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">TiXmlNode</a>
+</li>
+<li>Version()
+: <a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">TiXmlDeclaration</a>
+</li>
+<li>Visit()
+: <a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">TiXmlVisitor</a>
+</li>
+<li>VisitEnter()
+: <a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">TiXmlVisitor</a>
+</li>
+<li>VisitExit()
+: <a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">TiXmlVisitor</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_enum.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_enum.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_enum.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_enum.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,48 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Enumerations</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li class="current"><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;<ul>
+<li>NodeType
+: <a class="el" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x63.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x63.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x63.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x63.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,97 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li class="current"><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_c">- c -</a></h3><ul>
+<li>CDATA()
+: <a class="el" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">TiXmlText</a>
+</li>
+<li>Child()
+: <a class="el" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4">TiXmlHandle</a>
+</li>
+<li>ChildElement()
+: <a class="el" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d">TiXmlHandle</a>
+</li>
+<li>Clear()
+: <a class="el" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b">TiXmlNode</a>
+</li>
+<li>ClearError()
+: <a class="el" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">TiXmlDocument</a>
+</li>
+<li>Clone()
+: <a class="el" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>
+, <a class="el" href="classTiXmlElement.html#aa464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>
+, <a class="el" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>
+, <a class="el" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b">TiXmlText</a>
+</li>
+<li>Column()
+: <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase</a>
+</li>
+<li>CStr()
+: <a class="el" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x64.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x64.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x64.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x64.html.svn-base	2013-05-09 18:10:01.635874318 +0200
@@ -0,0 +1,70 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li class="current"><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_d">- d -</a></h3><ul>
+<li>DoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230">TiXmlAttribute</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x65.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x65.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x65.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x65.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,91 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li class="current"><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_e">- e -</a></h3><ul>
+<li>Element()
+: <a class="el" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">TiXmlHandle</a>
+</li>
+<li>EncodeString()
+: <a class="el" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948">TiXmlBase</a>
+</li>
+<li>Encoding()
+: <a class="el" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">TiXmlDeclaration</a>
+</li>
+<li>Error()
+: <a class="el" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">TiXmlDocument</a>
+</li>
+<li>ErrorCol()
+: <a class="el" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">TiXmlDocument</a>
+</li>
+<li>ErrorDesc()
+: <a class="el" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">TiXmlDocument</a>
+</li>
+<li>ErrorId()
+: <a class="el" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">TiXmlDocument</a>
+</li>
+<li>ErrorRow()
+: <a class="el" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x66.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x66.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x66.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x66.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,81 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li class="current"><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_f">- f -</a></h3><ul>
+<li>FirstAttribute()
+: <a class="el" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">TiXmlElement</a>
+</li>
+<li>FirstChild()
+: <a class="el" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a8c61f64ae9365d89c264f289085541f8">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139">TiXmlHandle</a>
+</li>
+<li>FirstChildElement()
+: <a class="el" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x67.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x67.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x67.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x67.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,76 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li class="current"><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_g">- g -</a></h3><ul>
+<li>GetDocument()
+: <a class="el" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3">TiXmlNode</a>
+</li>
+<li>GetText()
+: <a class="el" href="classTiXmlElement.html#af3282294986cdb216646ea1f67af2c87">TiXmlElement</a>
+</li>
+<li>GetUserData()
+: <a class="el" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x69.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x69.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x69.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x69.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,88 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li class="current"><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_i">- i -</a></h3><ul>
+<li>Indent()
+: <a class="el" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">TiXmlPrinter</a>
+</li>
+<li>InsertAfterChild()
+: <a class="el" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5">TiXmlNode</a>
+</li>
+<li>InsertBeforeChild()
+: <a class="el" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7">TiXmlNode</a>
+</li>
+<li>InsertEndChild()
+: <a class="el" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba">TiXmlNode</a>
+</li>
+<li>IntValue()
+: <a class="el" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f">TiXmlAttribute</a>
+</li>
+<li>IsWhiteSpaceCondensed()
+: <a class="el" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">TiXmlBase</a>
+</li>
+<li>IterateChildren()
+: <a class="el" href="classTiXmlNode.html#adfaef35a076b9343adc1420757376c39">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x6c.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x6c.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x6c.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x6c.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li class="current"><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_l">- l -</a></h3><ul>
+<li>LastAttribute()
+: <a class="el" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">TiXmlElement</a>
+</li>
+<li>LastChild()
+: <a class="el" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">TiXmlNode</a>
+</li>
+<li>LineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">TiXmlPrinter</a>
+</li>
+<li>LinkEndChild()
+: <a class="el" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6">TiXmlNode</a>
+</li>
+<li>LoadFile()
+: <a class="el" href="classTiXmlDocument.html#a41f6fe7200864d1dca663d230caf8db6">TiXmlDocument</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x6e.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x6e.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x6e.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x6e.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,85 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li class="current"><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_n">- n -</a></h3><ul>
+<li>Name()
+: <a class="el" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">TiXmlAttribute</a>
+</li>
+<li>Next()
+: <a class="el" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67">TiXmlAttribute</a>
+</li>
+<li>NextSibling()
+: <a class="el" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">TiXmlNode</a>
+</li>
+<li>NextSiblingElement()
+: <a class="el" href="classTiXmlNode.html#a071ba77fd7ab79402fa84b7e9b8607b3">TiXmlNode</a>
+</li>
+<li>NoChildren()
+: <a class="el" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">TiXmlNode</a>
+</li>
+<li>Node()
+: <a class="el" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">TiXmlHandle</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x70.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x70.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x70.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x70.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,90 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li class="current"><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_p">- p -</a></h3><ul>
+<li>Parent()
+: <a class="el" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">TiXmlNode</a>
+</li>
+<li>Parse()
+: <a class="el" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378">TiXmlDocument</a>
+</li>
+<li>Previous()
+: <a class="el" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf">TiXmlAttribute</a>
+</li>
+<li>PreviousSibling()
+: <a class="el" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">TiXmlNode</a>
+</li>
+<li>Print()
+: <a class="el" href="classTiXmlElement.html#afbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>
+, <a class="el" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>
+, <a class="el" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>
+, <a class="el" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlDocument.html#a8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>
+, <a class="el" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>
+, <a class="el" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x71.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x71.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x71.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x71.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,88 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li class="current"><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_q">- q -</a></h3><ul>
+<li>QueryDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7">TiXmlElement</a>
+</li>
+<li>QueryDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513">TiXmlAttribute</a>
+</li>
+<li>QueryFloatAttribute()
+: <a class="el" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">TiXmlElement</a>
+</li>
+<li>QueryIntAttribute()
+: <a class="el" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9">TiXmlElement</a>
+</li>
+<li>QueryIntValue()
+: <a class="el" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344">TiXmlAttribute</a>
+</li>
+<li>QueryStringAttribute()
+: <a class="el" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">TiXmlElement</a>
+</li>
+<li>QueryValueAttribute()
+: <a class="el" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x72.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x72.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x72.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x72.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li class="current"><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_r">- r -</a></h3><ul>
+<li>RemoveAttribute()
+: <a class="el" href="classTiXmlElement.html#a56979767deca794376b1dfa69a525b2a">TiXmlElement</a>
+</li>
+<li>RemoveChild()
+: <a class="el" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf">TiXmlNode</a>
+</li>
+<li>ReplaceChild()
+: <a class="el" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd">TiXmlNode</a>
+</li>
+<li>RootElement()
+: <a class="el" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">TiXmlDocument</a>
+</li>
+<li>Row()
+: <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x73.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x73.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x73.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x73.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,120 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li class="current"><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_s">- s -</a></h3><ul>
+<li>SaveFile()
+: <a class="el" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93">TiXmlDocument</a>
+</li>
+<li>SetAttribute()
+: <a class="el" href="classTiXmlElement.html#ace6f4be75e373726d4774073d666d1a7">TiXmlElement</a>
+</li>
+<li>SetCDATA()
+: <a class="el" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">TiXmlText</a>
+</li>
+<li>SetCondenseWhiteSpace()
+: <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">TiXmlBase</a>
+</li>
+<li>SetDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#a0d1dd975d75496778177e35abfe0ec0b">TiXmlElement</a>
+</li>
+<li>SetDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394">TiXmlAttribute</a>
+</li>
+<li>SetIndent()
+: <a class="el" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">TiXmlPrinter</a>
+</li>
+<li>SetIntValue()
+: <a class="el" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8">TiXmlAttribute</a>
+</li>
+<li>SetLineBreak()
+: <a class="el" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">TiXmlPrinter</a>
+</li>
+<li>SetName()
+: <a class="el" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">TiXmlAttribute</a>
+</li>
+<li>SetStreamPrinting()
+: <a class="el" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">TiXmlPrinter</a>
+</li>
+<li>SetTabSize()
+: <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument</a>
+</li>
+<li>SetUserData()
+: <a class="el" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">TiXmlBase</a>
+</li>
+<li>SetValue()
+: <a class="el" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">TiXmlAttribute</a>
+</li>
+<li>Size()
+: <a class="el" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">TiXmlPrinter</a>
+</li>
+<li>Standalone()
+: <a class="el" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">TiXmlDeclaration</a>
+</li>
+<li>Str()
+: <a class="el" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">TiXmlPrinter</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x74.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x74.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x74.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x74.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,126 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li class="current"><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_t">- t -</a></h3><ul>
+<li>Text()
+: <a class="el" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">TiXmlHandle</a>
+</li>
+<li>TiXmlAttribute()
+: <a class="el" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>
+</li>
+<li>TiXmlComment()
+: <a class="el" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>
+</li>
+<li>TiXmlDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#acd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>
+</li>
+<li>TiXmlDocument()
+: <a class="el" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>
+</li>
+<li>TiXmlElement()
+: <a class="el" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>
+</li>
+<li>TiXmlHandle()
+: <a class="el" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>
+</li>
+<li>TiXmlText()
+: <a class="el" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">TiXmlText</a>
+</li>
+<li>ToComment()
+: <a class="el" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">TiXmlNode</a>
+, <a class="el" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">TiXmlComment</a>
+</li>
+<li>ToDeclaration()
+: <a class="el" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">TiXmlNode</a>
+, <a class="el" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">TiXmlDeclaration</a>
+</li>
+<li>ToDocument()
+: <a class="el" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">TiXmlNode</a>
+, <a class="el" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">TiXmlDocument</a>
+</li>
+<li>ToElement()
+: <a class="el" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">TiXmlElement</a>
+, <a class="el" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">TiXmlHandle</a>
+</li>
+<li>ToNode()
+: <a class="el" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">TiXmlHandle</a>
+</li>
+<li>ToText()
+: <a class="el" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">TiXmlText</a>
+, <a class="el" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">TiXmlHandle</a>
+, <a class="el" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode</a>
+, <a class="el" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">TiXmlText</a>
+</li>
+<li>ToUnknown()
+: <a class="el" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">TiXmlNode</a>
+, <a class="el" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">TiXmlNode</a>
+, <a class="el" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">TiXmlHandle</a>
+</li>
+<li>Type()
+: <a class="el" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x75.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x75.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x75.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x75.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,70 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li class="current"><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_u">- u -</a></h3><ul>
+<li>Unknown()
+: <a class="el" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">TiXmlHandle</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x76.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x76.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func_0x76.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func_0x76.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,96 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li class="current"><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_v">- v -</a></h3><ul>
+<li>Value()
+: <a class="el" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">TiXmlNode</a>
+, <a class="el" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">TiXmlAttribute</a>
+</li>
+<li>ValueStr()
+: <a class="el" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">TiXmlAttribute</a>
+, <a class="el" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">TiXmlNode</a>
+</li>
+<li>Version()
+: <a class="el" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">TiXmlDeclaration</a>
+</li>
+<li>Visit()
+: <a class="el" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a83c13d6b980064b30f989f9a35498979">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">TiXmlVisitor</a>
+</li>
+<li>VisitEnter()
+: <a class="el" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a0c5e7bf8622838417a0d0bfb8f433854">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">TiXmlVisitor</a>
+</li>
+<li>VisitExit()
+: <a class="el" href="classTiXmlPrinter.html#a1853cf2f6e63ad4b4232b4835e0acaf0">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">TiXmlVisitor</a>
+, <a class="el" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2">TiXmlPrinter</a>
+, <a class="el" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">TiXmlVisitor</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_func.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_func.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,79 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li class="current"><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions_func.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_func_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_func_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_func_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_func_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_func_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_func_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_func_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_func_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_func_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_func_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_func_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_func_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_func_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_func_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_func_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;
+
+<h3><a class="anchor" id="index_a">- a -</a></h3><ul>
+<li>Accept()
+: <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>
+, <a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>
+, <a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>
+</li>
+<li>Attribute()
+: <a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,80 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="functions.html#index_a"><span>a</span></a></li>
+      <li><a href="functions_0x63.html#index_c"><span>c</span></a></li>
+      <li><a href="functions_0x64.html#index_d"><span>d</span></a></li>
+      <li><a href="functions_0x65.html#index_e"><span>e</span></a></li>
+      <li><a href="functions_0x66.html#index_f"><span>f</span></a></li>
+      <li><a href="functions_0x67.html#index_g"><span>g</span></a></li>
+      <li><a href="functions_0x69.html#index_i"><span>i</span></a></li>
+      <li><a href="functions_0x6c.html#index_l"><span>l</span></a></li>
+      <li><a href="functions_0x6e.html#index_n"><span>n</span></a></li>
+      <li><a href="functions_0x6f.html#index_o"><span>o</span></a></li>
+      <li><a href="functions_0x70.html#index_p"><span>p</span></a></li>
+      <li><a href="functions_0x71.html#index_q"><span>q</span></a></li>
+      <li><a href="functions_0x72.html#index_r"><span>r</span></a></li>
+      <li><a href="functions_0x73.html#index_s"><span>s</span></a></li>
+      <li><a href="functions_0x74.html#index_t"><span>t</span></a></li>
+      <li><a href="functions_0x75.html#index_u"><span>u</span></a></li>
+      <li><a href="functions_0x76.html#index_v"><span>v</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+Here is a list of all documented class members with links to the class documentation for each member:
+
+<h3><a class="anchor" id="index_a">- a -</a></h3><ul>
+<li>Accept()
+: <a class="el" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode</a>
+, <a class="el" href="classTiXmlElement.html#a71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>
+, <a class="el" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>
+, <a class="el" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>
+, <a class="el" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>
+, <a class="el" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>
+, <a class="el" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>
+</li>
+<li>Attribute()
+: <a class="el" href="classTiXmlElement.html#aeaff99d4f0ea5b34f7aee202aad457ba">TiXmlElement</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_rela.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_rela.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_rela.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_rela.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,51 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Related Functions</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li class="current"><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;<ul>
+<li>operator&lt;&lt;
+: <a class="el" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7">TiXmlNode</a>
+</li>
+<li>operator&gt;&gt;
+: <a class="el" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9">TiXmlNode</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_vars.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_vars.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/functions_vars.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/functions_vars.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,48 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Class Members - Variables</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li class="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="functions.html"><span>All</span></a></li>
+      <li><a href="functions_func.html"><span>Functions</span></a></li>
+      <li class="current"><a href="functions_vars.html"><span>Variables</span></a></li>
+      <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+      <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+&nbsp;<ul>
+<li>userData
+: <a class="el" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">TiXmlBase</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/hierarchy.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/hierarchy.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/hierarchy.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/hierarchy.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,54 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Hierarchical Index</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+      <li class="current"><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Class Hierarchy</h1>This inheritance list is sorted roughly, but not completely, alphabetically:<ul>
+<li><a class="el" href="classTiXmlBase.html">TiXmlBase</a><ul>
+<li><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></li>
+<li><a class="el" href="classTiXmlNode.html">TiXmlNode</a><ul>
+<li><a class="el" href="classTiXmlComment.html">TiXmlComment</a></li>
+<li><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></li>
+<li><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></li>
+<li><a class="el" href="classTiXmlElement.html">TiXmlElement</a></li>
+<li><a class="el" href="classTiXmlText.html">TiXmlText</a></li>
+<li><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></li>
+</ul>
+</li>
+</ul>
+</li>
+<li><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></li>
+<li><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a><ul>
+<li><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></li>
+</ul>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/index.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/index.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/index.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/index.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,275 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Main Page</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>TinyXml Documentation</h1><h3 class="version">2.6.1 </h3><h1>TinyXML </h1>
+<p>TinyXML is a simple, small, C++ XML parser that can be easily integrated into other programs.</p>
+<h2>What it does. </h2>
+<p>In brief, TinyXML parses an XML document, and builds from that a Document Object Model (DOM) that can be read, modified, and saved.</p>
+<p>XML stands for "eXtensible Markup Language." It allows you to create your own document markups. Where HTML does a very good job of marking documents for browsers, XML allows you to define any kind of document markup, for example a document that describes a "to do" list for an organizer application. XML is a very structured and convenient format. All those random file formats created to store application data can all be replaced with XML. One parser for everything.</p>
+<p>The best place for the complete, correct, and quite frankly hard to read spec is at <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a>. An intro to XML (that I really like) can be found at <a href="http://skew.org/xml/tutorial/">http://skew.org/xml/tutorial</a>.</p>
+<p>There are different ways to access and interact with XML data. TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed into a C++ objects that can be browsed and manipulated, and then written to disk or another output stream. You can also construct an XML document from scratch with C++ objects and write this to disk or another output stream.</p>
+<p>TinyXML is designed to be easy and fast to learn. It is two headers and four cpp files. Simply add these to your project and off you go. There is an example file - xmltest.cpp - to get you started.</p>
+<p>TinyXML is released under the ZLib license, so you can use it in open source or commercial code. The details of the license are at the top of every source file.</p>
+<p>TinyXML attempts to be a flexible parser, but with truly correct and compliant XML output. TinyXML should compile on any reasonably C++ compliant system. It does not rely on exceptions or RTTI. It can be compiled with or without STL support. TinyXML fully supports the UTF-8 encoding, and the first 64k character entities.</p>
+<h2>What it doesn't do. </h2>
+<p>TinyXML doesn't parse or use DTDs (Document Type Definitions) or XSLs (eXtensible Stylesheet Language.) There are other parsers out there (check out www.sourceforge.org, search for XML) that are much more fully featured. But they are also much bigger, take longer to set up in your project, have a higher learning curve, and often have a more restrictive license. If you are working with browsers or have more complete XML needs, TinyXML is not the parser for you.</p>
+<p>The following DTD syntax will not parse at this time in TinyXML:</p>
+<div class="fragment"><pre class="fragment">
+	&lt;!DOCTYPE Archiv [
+	 &lt;!ELEMENT Comment (#PCDATA)&gt;
+	]&gt;
+</pre></div><p>because TinyXML sees this as a !DOCTYPE node with an illegally embedded !ELEMENT node. This may be addressed in the future.</p>
+<h2>Tutorials. </h2>
+<p>For the impatient, here is a tutorial to get you going. A great way to get started, but it is worth your time to read this (very short) manual completely.</p>
+<ul>
+<li><a class="el" href="tutorial0.html">TinyXML Tutorial</a></li>
+</ul>
+<h2>Code Status. </h2>
+<p>TinyXML is mature, tested code. It is very stable. If you find bugs, please file a bug report on the sourceforge web site (www.sourceforge.net/projects/tinyxml). We'll get them straightened out as soon as possible.</p>
+<p>There are some areas of improvement; please check sourceforge if you are interested in working on TinyXML.</p>
+<h2>Related Projects </h2>
+<p>TinyXML projects you may find useful! (Descriptions provided by the projects.)</p>
+<ul>
+<li>
+<b>TinyXPath</b> (<a href="http://tinyxpath.sourceforge.net">http://tinyxpath.sourceforge.net</a>). TinyXPath is a small footprint XPath syntax decoder, written in C++. </li>
+<li>
+<b>TinyXML++</b> (<a href="http://code.google.com/p/ticpp/">http://code.google.com/p/ticpp/</a>). TinyXML++ is a completely new interface to TinyXML that uses MANY of the C++ strengths. Templates, exceptions, and much better error handling. </li>
+</ul>
+<h2>Features </h2>
+<h3>Using STL </h3>
+<p>TinyXML can be compiled to use or not use STL. When using STL, TinyXML uses the std::string class, and fully supports std::istream, std::ostream, operator&lt;&lt;, and operator&gt;&gt;. Many API methods have both 'const char*' and 'const std::string&amp;' forms.</p>
+<p>When STL support is compiled out, no STL files are included whatsoever. All the string classes are implemented by TinyXML itself. API methods all use the 'const char*' form for input.</p>
+<p>Use the compile time define:</p>
+<p>TIXML_USE_STL</p>
+<p>to compile one version or the other. This can be passed by the compiler, or set as the first line of "tinyxml.h".</p>
+<p>Note: If compiling the test code in Linux, setting the environment variable TINYXML_USE_STL=YES/NO will control STL compilation. In the Windows project file, STL and non STL targets are provided. In your project, It's probably easiest to add the line "#define TIXML_USE_STL" as the first line of <a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>.</p>
+<h3>UTF-8 </h3>
+<p>TinyXML supports UTF-8 allowing to manipulate XML files in any language. TinyXML also supports "legacy mode" - the encoding used before UTF-8 support and probably best described as "extended ascii".</p>
+<p>Normally, TinyXML will try to detect the correct encoding and use it. However, by setting the value of TIXML_DEFAULT_ENCODING in the header file, TinyXML can be forced to always use one encoding.</p>
+<p>TinyXML will assume Legacy Mode until one of the following occurs: </p>
+<ol>
+<li>
+If the non-standard but common "UTF-8 lead bytes" (0xef 0xbb 0xbf) begin the file or data stream, TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has an encoding="UTF-8", then TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has no encoding specified, then TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has an encoding="something else", then TinyXML will read it as Legacy Mode. In legacy mode, TinyXML will work as it did before. It's not clear what that mode does exactly, but old content should keep working. </li>
+<li>
+Until one of the above criteria is met, TinyXML runs in Legacy Mode. </li>
+</ol>
+<p>What happens if the encoding is incorrectly set or detected? TinyXML will try to read and pass through text seen as improperly encoded. You may get some strange results or mangled characters. You may want to force TinyXML to the correct mode.</p>
+<p>You may force TinyXML to Legacy Mode by using LoadFile( TIXML_ENCODING_LEGACY ) or LoadFile( filename, TIXML_ENCODING_LEGACY ). You may force it to use legacy mode all the time by setting TIXML_DEFAULT_ENCODING = TIXML_ENCODING_LEGACY. Likewise, you may force it to TIXML_ENCODING_UTF8 with the same technique.</p>
+<p>For English users, using English XML, UTF-8 is the same as low-ASCII. You don't need to be aware of UTF-8 or change your code in any way. You can think of UTF-8 as a "superset" of ASCII.</p>
+<p>UTF-8 is not a double byte format - but it is a standard encoding of Unicode! TinyXML does not use or directly support wchar, TCHAR, or Microsoft's _UNICODE at this time. It is common to see the term "Unicode" improperly refer to UTF-16, a wide byte encoding of unicode. This is a source of confusion.</p>
+<p>For "high-ascii" languages - everything not English, pretty much - TinyXML can handle all languages, at the same time, as long as the XML is encoded in UTF-8. That can be a little tricky, older programs and operating systems tend to use the "default" or "traditional" code page. Many apps (and almost all modern ones) can output UTF-8, but older or stubborn (or just broken) ones still output text in the default code page.</p>
+<p>For example, Japanese systems traditionally use SHIFT-JIS encoding. Text encoded as SHIFT-JIS can not be read by TinyXML. A good text editor can import SHIFT-JIS and then save as UTF-8.</p>
+<p>The <a href="http://skew.org/xml/tutorial/">Skew.org link</a> does a great job covering the encoding issue.</p>
+<p>The test file "utf8test.xml" is an XML containing English, Spanish, Russian, and Simplified Chinese. (Hopefully they are translated correctly). The file "utf8test.gif" is a screen capture of the XML file, rendered in IE. Note that if you don't have the correct fonts (Simplified Chinese or Russian) on your system, you won't see output that matches the GIF file even if you can parse it correctly. Also note that (at least on my Windows machine) console output is in a Western code page, so that Print() or printf() cannot correctly display the file. This is not a bug in TinyXML - just an OS issue. No data is lost or destroyed by TinyXML. The console just doesn't render UTF-8.</p>
+<h3>Entities </h3>
+<p>TinyXML recognizes the pre-defined "character entities", meaning special characters. Namely:</p>
+<div class="fragment"><pre class="fragment">
+	&amp;amp;	&amp;
+	&amp;lt;	&lt;
+	&amp;gt;	&gt;
+	&amp;quot;	"
+	&amp;apos;	'
+</pre></div><p>These are recognized when the XML document is read, and translated to there UTF-8 equivalents. For instance, text with the XML of:</p>
+<div class="fragment"><pre class="fragment">
+	Far &amp;amp; Away
+</pre></div><p>will have the Value() of "Far &amp; Away" when queried from the <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a> object, and will be written back to the XML stream/file as an ampersand. Older versions of TinyXML "preserved" character entities, but the newer versions will translate them into characters.</p>
+<p>Additionally, any character can be specified by its Unicode code point: The syntax "&amp;#xA0;" or "&amp;#160;" are both to the non-breaking space characher.</p>
+<h3>Printing </h3>
+<p>TinyXML can print output in several different ways that all have strengths and limitations.</p>
+<ul>
+<li>Print( FILE* ). Output to a std-C stream, which includes all C files as well as stdout.<ul>
+<li>"Pretty prints", but you don't have control over printing options.</li>
+<li>The output is streamed directly to the FILE object, so there is no memory overhead in the TinyXML code.</li>
+<li>used by Print() and SaveFile()</li>
+</ul>
+</li>
+</ul>
+<ul>
+<li>operator&lt;&lt;. Output to a c++ stream.<ul>
+<li>Integrates with standart C++ iostreams.</li>
+<li>Outputs in "network printing" mode without line breaks. Good for network transmission and moving XML between C++ objects, but hard for a human to read.</li>
+</ul>
+</li>
+</ul>
+<ul>
+<li><a class="el" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a>. Output to a std::string or memory buffer.<ul>
+<li>API is less concise</li>
+<li>Future printing options will be put here.</li>
+<li>Printing may change slightly in future versions as it is refined and expanded.</li>
+</ul>
+</li>
+</ul>
+<h3>Streams </h3>
+<p>With TIXML_USE_STL on TinyXML supports C++ streams (operator &lt;&lt;,&gt;&gt;) streams as well as C (FILE*) streams. There are some differences that you may need to be aware of.</p>
+<p>C style output:</p>
+<ul>
+<li>based on FILE*</li>
+<li>the Print() and SaveFile() methods</li>
+</ul>
+<p>Generates formatted output, with plenty of white space, intended to be as human-readable as possible. They are very fast, and tolerant of ill formed XML documents. For example, an XML document that contains 2 root elements and 2 declarations, will still print.</p>
+<p>C style input:</p>
+<ul>
+<li>based on FILE*</li>
+<li>the Parse() and LoadFile() methods</li>
+</ul>
+<p>A fast, tolerant read. Use whenever you don't need the C++ streams.</p>
+<p>C++ style output:</p>
+<ul>
+<li>based on std::ostream</li>
+<li>operator&lt;&lt;</li>
+</ul>
+<p>Generates condensed output, intended for network transmission rather than readability. Depending on your system's implementation of the ostream class, these may be somewhat slower. (Or may not.) Not tolerant of ill formed XML: a document should contain the correct one root element. Additional root level elements will not be streamed out.</p>
+<p>C++ style input:</p>
+<ul>
+<li>based on std::istream</li>
+<li>operator&gt;&gt;</li>
+</ul>
+<p>Reads XML from a stream, making it useful for network transmission. The tricky part is knowing when the XML document is complete, since there will almost certainly be other data in the stream. TinyXML will assume the XML data is complete after it reads the root element. Put another way, documents that are ill-constructed with more than one root element will not read correctly. Also note that operator&gt;&gt; is somewhat slower than Parse, due to both implementation of the STL and limitations of TinyXML.</p>
+<h3>White space </h3>
+<p>The world simply does not agree on whether white space should be kept, or condensed. For example, pretend the '_' is a space, and look at "Hello____world". HTML, and at least some XML parsers, will interpret this as "Hello_world". They condense white space. Some XML parsers do not, and will leave it as "Hello____world". (Remember to keep pretending the _ is a space.) Others suggest that __Hello___world__ should become Hello___world.</p>
+<p>It's an issue that hasn't been resolved to my satisfaction. TinyXML supports the first 2 approaches. Call <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1" title="The world does not agree on whether white space should be kept or not.">TiXmlBase::SetCondenseWhiteSpace( bool )</a> to set the desired behavior. The default is to condense white space.</p>
+<p>If you change the default, you should call <a class="el" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1" title="The world does not agree on whether white space should be kept or not.">TiXmlBase::SetCondenseWhiteSpace( bool )</a> before making any calls to Parse XML data, and I don't recommend changing it after it has been set.</p>
+<h3>Handles </h3>
+<p>Where browsing an XML document in a robust way, it is important to check for null returns from method calls. An error safe implementation can generate a lot of code like:</p>
+<div class="fragment"><pre class="fragment">
+TiXmlElement* root = document.FirstChildElement( "Document" );
+if ( root )
+{
+	TiXmlElement* element = root-&gt;FirstChildElement( "Element" );
+	if ( element )
+	{
+		TiXmlElement* child = element-&gt;FirstChildElement( "Child" );
+		if ( child )
+		{
+			TiXmlElement* child2 = child-&gt;NextSiblingElement( "Child" );
+			if ( child2 )
+			{
+				// Finally do something useful.
+</pre></div><p>Handles have been introduced to clean this up. Using the <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> class, the previous code reduces to:</p>
+<div class="fragment"><pre class="fragment">
+TiXmlHandle docHandle( &amp;document );
+TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+if ( child2 )
+{
+	// do something useful
+</pre></div><p>Which is much easier to deal with. See <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> for more information.</p>
+<h3>Row and Column tracking </h3>
+<p>Being able to track nodes and attributes back to their origin location in source files can be very important for some applications. Additionally, knowing where parsing errors occured in the original source can be very time saving.</p>
+<p>TinyXML can tracks the row and column origin of all nodes and attributes in a text file. The <a class="el" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">TiXmlBase::Row()</a> and <a class="el" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">TiXmlBase::Column()</a> methods return the origin of the node in the source text. The correct tabs can be configured in <a class="el" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">TiXmlDocument::SetTabSize()</a>.</p>
+<h2>Using and Installing </h2>
+<p>To Compile and Run xmltest:</p>
+<p>A Linux Makefile and a Windows Visual C++ .dsw file is provided. Simply compile and run. It will write the file demotest.xml to your disk and generate output on the screen. It also tests walking the DOM by printing out the number of nodes found using different techniques.</p>
+<p>The Linux makefile is very generic and runs on many systems - it is currently tested on mingw and MacOSX. You do not need to run 'make depend'. The dependecies have been hard coded.</p>
+<h3>Windows project file for VC6</h3>
+<ul>
+<li>
+tinyxml: tinyxml library, non-STL  </li>
+<li>
+tinyxmlSTL: tinyxml library, STL  </li>
+<li>
+tinyXmlTest: test app, non-STL  </li>
+<li>
+tinyXmlTestSTL: test app, STL  </li>
+</ul>
+<h3>Makefile</h3>
+<p>At the top of the makefile you can set:</p>
+<p>PROFILE, DEBUG, and TINYXML_USE_STL. Details (such that they are) are in the makefile.</p>
+<p>In the tinyxml directory, type "make clean" then "make". The executable file 'xmltest' will be created.</p>
+<h3>To Use in an Application:</h3>
+<p>Add tinyxml.cpp, <a class="el" href="tinyxml_8h_source.html">tinyxml.h</a>, tinyxmlerror.cpp, tinyxmlparser.cpp, tinystr.cpp, and <a class="el" href="tinystr_8h_source.html">tinystr.h</a> to your project or make file. That's it! It should compile on any reasonably compliant C++ system. You do not need to enable exceptions or RTTI for TinyXML.</p>
+<h2>How TinyXML works. </h2>
+<p>An example is probably the best way to go. Take: </p>
+<div class="fragment"><pre class="fragment">
+	&lt;?xml version="1.0" standalone=no&gt;
+	&lt;!-- Our to do list data --&gt;
+	&lt;ToDo&gt;
+		&lt;Item priority="1"&gt; Go to the &lt;bold&gt;Toy store!&lt;/bold&gt;&lt;/Item&gt;
+		&lt;Item priority="2"&gt; Do bills&lt;/Item&gt;
+	&lt;/ToDo&gt;
+</pre></div><p>Its not much of a To Do list, but it will do. To read this file (say "demo.xml") you would create a document, and parse it in: </p>
+<div class="fragment"><pre class="fragment">
+	TiXmlDocument doc( "demo.xml" );
+	doc.LoadFile();
+</pre></div><p>And its ready to go. Now lets look at some lines and how they relate to the DOM.</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" standalone=no&gt;
+</pre></div><p>The first line is a declaration, and gets turned into the <a class="el" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a> class. It will be the first child of the document node.</p>
+<p>This is the only directive/special tag parsed by TinyXML. Generally directive tags are stored in <a class="el" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&#39;t recognize is saved as an unknown.">TiXmlUnknown</a> so the commands wont be lost when it is saved back to disk.</p>
+<div class="fragment"><pre class="fragment">
+&lt;!-- Our to do list data --&gt;
+</pre></div><p>A comment. Will become a <a class="el" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a> object.</p>
+<div class="fragment"><pre class="fragment">
+&lt;ToDo&gt;
+</pre></div><p>The "ToDo" tag defines a <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> object. This one does not have any attributes, but does contain 2 other elements.</p>
+<div class="fragment"><pre class="fragment">
+&lt;Item priority="1"&gt; 
+</pre></div><p>Creates another <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> which is a child of the "ToDo" element. This element has 1 attribute, with the name "priority" and the value "1".</p>
+<div class="fragment"><pre class="fragment">
+Go to the
+</pre></div><p>A <a class="el" href="classTiXmlText.html" title="XML text.">TiXmlText</a>. This is a leaf node and cannot contain other nodes. It is a child of the "Item" <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>.</p>
+<div class="fragment"><pre class="fragment">
+&lt;bold&gt;
+</pre></div><p>Another <a class="el" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>, this one a child of the "Item" element.</p>
+<p>Etc.</p>
+<p>Looking at the entire object tree, you end up with: </p>
+<div class="fragment"><pre class="fragment">
+TiXmlDocument					"demo.xml"
+	TiXmlDeclaration			"version='1.0'" "standalone=no"
+	TiXmlComment				" Our to do list data"
+	TiXmlElement				"ToDo"
+		TiXmlElement			"Item" Attribtutes: priority = 1
+			TiXmlText			"Go to the "
+			TiXmlElement		"bold"
+				TiXmlText		"Toy store!"
+		TiXmlElement			"Item" Attributes: priority=2
+			TiXmlText			"Do bills"
+</pre></div><h2>Documentation </h2>
+<p>The documentation is build with Doxygen, using the 'dox' configuration file.</p>
+<h2>License </h2>
+<p>TinyXML is released under the zlib license:</p>
+<p>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.</p>
+<p>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:</p>
+<p>1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</p>
+<p>2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</p>
+<p>3. This notice may not be removed or altered from any source distribution.</p>
+<h2>References </h2>
+<p>The World Wide Web Consortium is the definitive standard body for XML, and their web pages contain huge amounts of information.</p>
+<p>The definitive spec: <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a></p>
+<p>I also recommend "XML Pocket Reference" by Robert Eckstein and published by OReilly...the book that got the whole thing started.</p>
+<h2>Contributors, Contacts, and a Brief History </h2>
+<p>Thanks very much to everyone who sends suggestions, bugs, ideas, and encouragement. It all helps, and makes this project fun. A special thanks to the contributors on the web pages that keep it lively.</p>
+<p>So many people have sent in bugs and ideas, that rather than list here we try to give credit due in the "changes.txt" file.</p>
+<p>TinyXML was originally written by Lee Thomason. (Often the "I" still in the documentation.) Lee reviews changes and releases new versions, with the help of Yves Berquin, Andrew Ellerton, and the tinyXml community.</p>
+<p>We appreciate your suggestions, and would love to know if you use TinyXML. Hopefully you will enjoy it and find it useful. Please post questions, comments, file bugs, or contact us at:</p>
+<p>www.sourceforge.net/projects/tinyxml</p>
+<p>Lee Thomason, Yves Berquin, Andrew Ellerton </p>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/pages.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/pages.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/pages.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/pages.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,31 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: Page Index</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+</div>
+<div class="contents">
+<h1>Related Pages</h1>Here is a list of all related documentation pages:<ul>
+<li><a class="el" href="deprecated.html">Deprecated List</a>
+</li>
+</ul>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/tabs.css.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tabs.css.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/tabs.css.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tabs.css.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,105 @@
+/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */
+
+DIV.tabs
+{
+   float            : left;
+   width            : 100%;
+   background       : url("tab_b.gif") repeat-x bottom;
+   margin-bottom    : 4px;
+}
+
+DIV.tabs UL
+{
+   margin           : 0px;
+   padding-left     : 10px;
+   list-style       : none;
+}
+
+DIV.tabs LI, DIV.tabs FORM
+{
+   display          : inline;
+   margin           : 0px;
+   padding          : 0px;
+}
+
+DIV.tabs FORM
+{
+   float            : right;
+}
+
+DIV.tabs A
+{
+   float            : left;
+   background       : url("tab_r.gif") no-repeat right top;
+   border-bottom    : 1px solid #84B0C7;
+   font-size        : 80%;
+   font-weight      : bold;
+   text-decoration  : none;
+}
+
+DIV.tabs A:hover
+{
+   background-position: 100% -150px;
+}
+
+DIV.tabs A:link, DIV.tabs A:visited,
+DIV.tabs A:active, DIV.tabs A:hover
+{
+       color: #1A419D;
+}
+
+DIV.tabs SPAN
+{
+   float            : left;
+   display          : block;
+   background       : url("tab_l.gif") no-repeat left top;
+   padding          : 5px 9px;
+   white-space      : nowrap;
+}
+
+DIV.tabs #MSearchBox
+{
+   float            : right;
+   display          : inline;
+   font-size        : 1em;
+}
+
+DIV.tabs TD
+{
+   font-size        : 80%;
+   font-weight      : bold;
+   text-decoration  : none;
+}
+
+
+
+/* Commented Backslash Hack hides rule from IE5-Mac \*/
+DIV.tabs SPAN {float : none;}
+/* End IE5-Mac hack */
+
+DIV.tabs A:hover SPAN
+{
+   background-position: 0% -150px;
+}
+
+DIV.tabs LI.current A
+{
+   background-position: 100% -150px;
+   border-width     : 0px;
+}
+
+DIV.tabs LI.current SPAN
+{
+   background-position: 0% -150px;
+   padding-bottom   : 6px;
+}
+
+DIV.navpath
+{
+   background       : none;
+   border           : none;
+   border-bottom    : 1px solid #84B0C7;
+   text-align       : center;
+   margin           : 2px;
+   padding          : 2px;
+}
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/tinystr_8h_source.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tinystr_8h_source.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/tinystr_8h_source.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tinystr_8h_source.html.svn-base	2013-05-09 18:10:01.639874319 +0200
@@ -0,0 +1,349 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: tinystr.h Source File</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li class="current"><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
+    </ul>
+  </div>
+<h1>tinystr.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
+<a name="l00002"></a>00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
+<a name="l00003"></a>00003 <span class="comment">Original file by Yves Berquin.</span>
+<a name="l00004"></a>00004 <span class="comment"></span>
+<a name="l00005"></a>00005 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied</span>
+<a name="l00006"></a>00006 <span class="comment">warranty. In no event will the authors be held liable for any</span>
+<a name="l00007"></a>00007 <span class="comment">damages arising from the use of this software.</span>
+<a name="l00008"></a>00008 <span class="comment"></span>
+<a name="l00009"></a>00009 <span class="comment">Permission is granted to anyone to use this software for any</span>
+<a name="l00010"></a>00010 <span class="comment">purpose, including commercial applications, and to alter it and</span>
+<a name="l00011"></a>00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
+<a name="l00012"></a>00012 <span class="comment"></span>
+<a name="l00013"></a>00013 <span class="comment">1. The origin of this software must not be misrepresented; you must</span>
+<a name="l00014"></a>00014 <span class="comment">not claim that you wrote the original software. If you use this</span>
+<a name="l00015"></a>00015 <span class="comment">software in a product, an acknowledgment in the product documentation</span>
+<a name="l00016"></a>00016 <span class="comment">would be appreciated but is not required.</span>
+<a name="l00017"></a>00017 <span class="comment"></span>
+<a name="l00018"></a>00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
+<a name="l00019"></a>00019 <span class="comment">must not be misrepresented as being the original software.</span>
+<a name="l00020"></a>00020 <span class="comment"></span>
+<a name="l00021"></a>00021 <span class="comment">3. This notice may not be removed or altered from any source</span>
+<a name="l00022"></a>00022 <span class="comment">distribution.</span>
+<a name="l00023"></a>00023 <span class="comment">*/</span>
+<a name="l00024"></a>00024 
+<a name="l00025"></a>00025 <span class="comment">/*</span>
+<a name="l00026"></a>00026 <span class="comment"> * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.</span>
+<a name="l00027"></a>00027 <span class="comment"> *</span>
+<a name="l00028"></a>00028 <span class="comment"> * - completely rewritten. compact, clean, and fast implementation.</span>
+<a name="l00029"></a>00029 <span class="comment"> * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)</span>
+<a name="l00030"></a>00030 <span class="comment"> * - fixed reserve() to work as per specification.</span>
+<a name="l00031"></a>00031 <span class="comment"> * - fixed buggy compares operator==(), operator&lt;(), and operator&gt;()</span>
+<a name="l00032"></a>00032 <span class="comment"> * - fixed operator+=() to take a const ref argument, following spec.</span>
+<a name="l00033"></a>00033 <span class="comment"> * - added &quot;copy&quot; constructor with length, and most compare operators.</span>
+<a name="l00034"></a>00034 <span class="comment"> * - added swap(), clear(), size(), capacity(), operator+().</span>
+<a name="l00035"></a>00035 <span class="comment"> */</span>
+<a name="l00036"></a>00036 
+<a name="l00037"></a>00037 <span class="preprocessor">#ifndef TIXML_USE_STL</span>
+<a name="l00038"></a>00038 <span class="preprocessor"></span>
+<a name="l00039"></a>00039 <span class="preprocessor">#ifndef TIXML_STRING_INCLUDED</span>
+<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define TIXML_STRING_INCLUDED</span>
+<a name="l00041"></a>00041 <span class="preprocessor"></span>
+<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;assert.h&gt;</span>
+<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
+<a name="l00044"></a>00044 
+<a name="l00045"></a>00045 <span class="comment">/*  The support for explicit isn&#39;t that universal, and it isn&#39;t really</span>
+<a name="l00046"></a>00046 <span class="comment">    required - it is used to check that the TiXmlString class isn&#39;t incorrectly</span>
+<a name="l00047"></a>00047 <span class="comment">    used. Be nice to old compilers and macro it here:</span>
+<a name="l00048"></a>00048 <span class="comment">*/</span>
+<a name="l00049"></a>00049 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200 )</span>
+<a name="l00050"></a>00050 <span class="preprocessor"></span>    <span class="comment">// Microsoft visual studio, version 6 and higher.</span>
+<a name="l00051"></a>00051 <span class="preprocessor">    #define TIXML_EXPLICIT explicit</span>
+<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3 )</span>
+<a name="l00053"></a>00053 <span class="preprocessor"></span>    <span class="comment">// GCC version 3 and higher.s</span>
+<a name="l00054"></a>00054 <span class="preprocessor">    #define TIXML_EXPLICIT explicit</span>
+<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#else</span>
+<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">    #define TIXML_EXPLICIT</span>
+<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00058"></a>00058 <span class="preprocessor"></span>
+<a name="l00059"></a>00059 
+<a name="l00060"></a>00060 <span class="comment">/*</span>
+<a name="l00061"></a>00061 <span class="comment">   TiXmlString is an emulation of a subset of the std::string template.</span>
+<a name="l00062"></a>00062 <span class="comment">   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.</span>
+<a name="l00063"></a>00063 <span class="comment">   Only the member functions relevant to the TinyXML project have been implemented.</span>
+<a name="l00064"></a>00064 <span class="comment">   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase</span>
+<a name="l00065"></a>00065 <span class="comment">   a string and there&#39;s no more room, we allocate a buffer twice as big as we need.</span>
+<a name="l00066"></a>00066 <span class="comment">*/</span>
+<a name="l00067"></a>00067 <span class="keyword">class </span>TiXmlString
+<a name="l00068"></a>00068 {
+<a name="l00069"></a>00069   <span class="keyword">public</span> :
+<a name="l00070"></a>00070     <span class="comment">// The size type used</span>
+<a name="l00071"></a>00071     <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> size_type;
+<a name="l00072"></a>00072 
+<a name="l00073"></a>00073     <span class="comment">// Error value for find primitive</span>
+<a name="l00074"></a>00074     <span class="keyword">static</span> <span class="keyword">const</span> size_type npos; <span class="comment">// = -1;</span>
+<a name="l00075"></a>00075 
+<a name="l00076"></a>00076 
+<a name="l00077"></a>00077     <span class="comment">// TiXmlString empty constructor</span>
+<a name="l00078"></a>00078     TiXmlString () : rep_(&amp;nullrep_)
+<a name="l00079"></a>00079     {
+<a name="l00080"></a>00080     }
+<a name="l00081"></a>00081 
+<a name="l00082"></a>00082     <span class="comment">// TiXmlString copy constructor</span>
+<a name="l00083"></a>00083     TiXmlString ( <span class="keyword">const</span> TiXmlString &amp; copy) : rep_(0)
+<a name="l00084"></a>00084     {
+<a name="l00085"></a>00085         init(copy.length());
+<a name="l00086"></a>00086         memcpy(start(), copy.data(), length());
+<a name="l00087"></a>00087     }
+<a name="l00088"></a>00088 
+<a name="l00089"></a>00089     <span class="comment">// TiXmlString constructor, based on a string</span>
+<a name="l00090"></a>00090     TIXML_EXPLICIT TiXmlString ( <span class="keyword">const</span> <span class="keywordtype">char</span> * copy) : rep_(0)
+<a name="l00091"></a>00091     {
+<a name="l00092"></a>00092         init( static_cast&lt;size_type&gt;( strlen(copy) ));
+<a name="l00093"></a>00093         memcpy(start(), copy, length());
+<a name="l00094"></a>00094     }
+<a name="l00095"></a>00095 
+<a name="l00096"></a>00096     <span class="comment">// TiXmlString constructor, based on a string</span>
+<a name="l00097"></a>00097     TIXML_EXPLICIT TiXmlString ( <span class="keyword">const</span> <span class="keywordtype">char</span> * str, size_type len) : rep_(0)
+<a name="l00098"></a>00098     {
+<a name="l00099"></a>00099         init(len);
+<a name="l00100"></a>00100         memcpy(start(), str, len);
+<a name="l00101"></a>00101     }
+<a name="l00102"></a>00102 
+<a name="l00103"></a>00103     <span class="comment">// TiXmlString destructor</span>
+<a name="l00104"></a>00104     ~TiXmlString ()
+<a name="l00105"></a>00105     {
+<a name="l00106"></a>00106         quit();
+<a name="l00107"></a>00107     }
+<a name="l00108"></a>00108 
+<a name="l00109"></a>00109     <span class="comment">// = operator</span>
+<a name="l00110"></a>00110     TiXmlString&amp; operator = (<span class="keyword">const</span> <span class="keywordtype">char</span> * copy)
+<a name="l00111"></a>00111     {
+<a name="l00112"></a>00112         <span class="keywordflow">return</span> assign( copy, (size_type)strlen(copy));
+<a name="l00113"></a>00113     }
+<a name="l00114"></a>00114 
+<a name="l00115"></a>00115     <span class="comment">// = operator</span>
+<a name="l00116"></a>00116     TiXmlString&amp; operator = (<span class="keyword">const</span> TiXmlString &amp; copy)
+<a name="l00117"></a>00117     {
+<a name="l00118"></a>00118         <span class="keywordflow">return</span> assign(copy.start(), copy.length());
+<a name="l00119"></a>00119     }
+<a name="l00120"></a>00120 
+<a name="l00121"></a>00121 
+<a name="l00122"></a>00122     <span class="comment">// += operator. Maps to append</span>
+<a name="l00123"></a>00123     TiXmlString&amp; operator += (<span class="keyword">const</span> <span class="keywordtype">char</span> * suffix)
+<a name="l00124"></a>00124     {
+<a name="l00125"></a>00125         <span class="keywordflow">return</span> append(suffix, static_cast&lt;size_type&gt;( strlen(suffix) ));
+<a name="l00126"></a>00126     }
+<a name="l00127"></a>00127 
+<a name="l00128"></a>00128     <span class="comment">// += operator. Maps to append</span>
+<a name="l00129"></a>00129     TiXmlString&amp; operator += (<span class="keywordtype">char</span> single)
+<a name="l00130"></a>00130     {
+<a name="l00131"></a>00131         <span class="keywordflow">return</span> append(&amp;single, 1);
+<a name="l00132"></a>00132     }
+<a name="l00133"></a>00133 
+<a name="l00134"></a>00134     <span class="comment">// += operator. Maps to append</span>
+<a name="l00135"></a>00135     TiXmlString&amp; operator += (<span class="keyword">const</span> TiXmlString &amp; suffix)
+<a name="l00136"></a>00136     {
+<a name="l00137"></a>00137         <span class="keywordflow">return</span> append(suffix.data(), suffix.length());
+<a name="l00138"></a>00138     }
+<a name="l00139"></a>00139 
+<a name="l00140"></a>00140 
+<a name="l00141"></a>00141     <span class="comment">// Convert a TiXmlString into a null-terminated char *</span>
+<a name="l00142"></a>00142     <span class="keyword">const</span> <span class="keywordtype">char</span> * c_str ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00143"></a>00143 
+<a name="l00144"></a>00144     <span class="comment">// Convert a TiXmlString into a char * (need not be null terminated).</span>
+<a name="l00145"></a>00145     <span class="keyword">const</span> <span class="keywordtype">char</span> * data ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00146"></a>00146 
+<a name="l00147"></a>00147     <span class="comment">// Return the length of a TiXmlString</span>
+<a name="l00148"></a>00148     size_type length ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size; }
+<a name="l00149"></a>00149 
+<a name="l00150"></a>00150     <span class="comment">// Alias for length()</span>
+<a name="l00151"></a>00151     size_type size ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size; }
+<a name="l00152"></a>00152 
+<a name="l00153"></a>00153     <span class="comment">// Checks if a TiXmlString is empty</span>
+<a name="l00154"></a>00154     <span class="keywordtype">bool</span> empty ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size == 0; }
+<a name="l00155"></a>00155 
+<a name="l00156"></a>00156     <span class="comment">// Return capacity of string</span>
+<a name="l00157"></a>00157     size_type capacity ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;capacity; }
+<a name="l00158"></a>00158 
+<a name="l00159"></a>00159 
+<a name="l00160"></a>00160     <span class="comment">// single char extraction</span>
+<a name="l00161"></a>00161     <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; at (size_type index)<span class="keyword"> const</span>
+<a name="l00162"></a>00162 <span class="keyword">    </span>{
+<a name="l00163"></a>00163         assert( index &lt; length() );
+<a name="l00164"></a>00164         <span class="keywordflow">return</span> rep_-&gt;str[ index ];
+<a name="l00165"></a>00165     }
+<a name="l00166"></a>00166 
+<a name="l00167"></a>00167     <span class="comment">// [] operator</span>
+<a name="l00168"></a>00168     <span class="keywordtype">char</span>&amp; operator [] (size_type index)<span class="keyword"> const</span>
+<a name="l00169"></a>00169 <span class="keyword">    </span>{
+<a name="l00170"></a>00170         assert( index &lt; length() );
+<a name="l00171"></a>00171         <span class="keywordflow">return</span> rep_-&gt;str[ index ];
+<a name="l00172"></a>00172     }
+<a name="l00173"></a>00173 
+<a name="l00174"></a>00174     <span class="comment">// find a char in a string. Return TiXmlString::npos if not found</span>
+<a name="l00175"></a>00175     size_type find (<span class="keywordtype">char</span> lookup)<span class="keyword"> const</span>
+<a name="l00176"></a>00176 <span class="keyword">    </span>{
+<a name="l00177"></a>00177         <span class="keywordflow">return</span> find(lookup, 0);
+<a name="l00178"></a>00178     }
+<a name="l00179"></a>00179 
+<a name="l00180"></a>00180     <span class="comment">// find a char in a string from an offset. Return TiXmlString::npos if not found</span>
+<a name="l00181"></a>00181     size_type find (<span class="keywordtype">char</span> tofind, size_type offset)<span class="keyword"> const</span>
+<a name="l00182"></a>00182 <span class="keyword">    </span>{
+<a name="l00183"></a>00183         <span class="keywordflow">if</span> (offset &gt;= length()) <span class="keywordflow">return</span> npos;
+<a name="l00184"></a>00184 
+<a name="l00185"></a>00185         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>* p = c_str() + offset; *p != <span class="charliteral">&#39;\0&#39;</span>; ++p)
+<a name="l00186"></a>00186         {
+<a name="l00187"></a>00187            <span class="keywordflow">if</span> (*p == tofind) <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> size_type <span class="keyword">&gt;</span>( p - c_str() );
+<a name="l00188"></a>00188         }
+<a name="l00189"></a>00189         <span class="keywordflow">return</span> npos;
+<a name="l00190"></a>00190     }
+<a name="l00191"></a>00191 
+<a name="l00192"></a>00192     <span class="keywordtype">void</span> clear ()
+<a name="l00193"></a>00193     {
+<a name="l00194"></a>00194         <span class="comment">//Lee:</span>
+<a name="l00195"></a>00195         <span class="comment">//The original was just too strange, though correct:</span>
+<a name="l00196"></a>00196         <span class="comment">//  TiXmlString().swap(*this);</span>
+<a name="l00197"></a>00197         <span class="comment">//Instead use the quit &amp; re-init:</span>
+<a name="l00198"></a>00198         quit();
+<a name="l00199"></a>00199         init(0,0);
+<a name="l00200"></a>00200     }
+<a name="l00201"></a>00201 
+<a name="l00202"></a>00202     <span class="comment">/*  Function to reserve a big amount of data when we know we&#39;ll need it. Be aware that this</span>
+<a name="l00203"></a>00203 <span class="comment">        function DOES NOT clear the content of the TiXmlString if any exists.</span>
+<a name="l00204"></a>00204 <span class="comment">    */</span>
+<a name="l00205"></a>00205     <span class="keywordtype">void</span> reserve (size_type cap);
+<a name="l00206"></a>00206 
+<a name="l00207"></a>00207     TiXmlString&amp; assign (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, size_type len);
+<a name="l00208"></a>00208 
+<a name="l00209"></a>00209     TiXmlString&amp; append (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, size_type len);
+<a name="l00210"></a>00210 
+<a name="l00211"></a>00211     <span class="keywordtype">void</span> swap (TiXmlString&amp; other)
+<a name="l00212"></a>00212     {
+<a name="l00213"></a>00213         Rep* r = rep_;
+<a name="l00214"></a>00214         rep_ = other.rep_;
+<a name="l00215"></a>00215         other.rep_ = r;
+<a name="l00216"></a>00216     }
+<a name="l00217"></a>00217 
+<a name="l00218"></a>00218   <span class="keyword">private</span>:
+<a name="l00219"></a>00219 
+<a name="l00220"></a>00220     <span class="keywordtype">void</span> init(size_type sz) { init(sz, sz); }
+<a name="l00221"></a>00221     <span class="keywordtype">void</span> set_size(size_type sz) { rep_-&gt;str[ rep_-&gt;size = sz ] = <span class="charliteral">&#39;\0&#39;</span>; }
+<a name="l00222"></a>00222     <span class="keywordtype">char</span>* start()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00223"></a>00223     <span class="keywordtype">char</span>* finish()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str + rep_-&gt;size; }
+<a name="l00224"></a>00224 
+<a name="l00225"></a>00225     <span class="keyword">struct </span>Rep
+<a name="l00226"></a>00226     {
+<a name="l00227"></a>00227         size_type size, capacity;
+<a name="l00228"></a>00228         <span class="keywordtype">char</span> str[1];
+<a name="l00229"></a>00229     };
+<a name="l00230"></a>00230 
+<a name="l00231"></a>00231     <span class="keywordtype">void</span> init(size_type sz, size_type cap)
+<a name="l00232"></a>00232     {
+<a name="l00233"></a>00233         <span class="keywordflow">if</span> (cap)
+<a name="l00234"></a>00234         {
+<a name="l00235"></a>00235             <span class="comment">// Lee: the original form:</span>
+<a name="l00236"></a>00236             <span class="comment">//  rep_ = static_cast&lt;Rep*&gt;(operator new(sizeof(Rep) + cap));</span>
+<a name="l00237"></a>00237             <span class="comment">// doesn&#39;t work in some cases of new being overloaded. Switching</span>
+<a name="l00238"></a>00238             <span class="comment">// to the normal allocation, although use an &#39;int&#39; for systems</span>
+<a name="l00239"></a>00239             <span class="comment">// that are overly picky about structure alignment.</span>
+<a name="l00240"></a>00240             <span class="keyword">const</span> size_type bytesNeeded = <span class="keyword">sizeof</span>(Rep) + cap;
+<a name="l00241"></a>00241             <span class="keyword">const</span> size_type intsNeeded = ( bytesNeeded + <span class="keyword">sizeof</span>(int) - 1 ) / <span class="keyword">sizeof</span>( int ); 
+<a name="l00242"></a>00242             rep_ = <span class="keyword">reinterpret_cast&lt;</span>Rep*<span class="keyword">&gt;</span>( <span class="keyword">new</span> <span class="keywordtype">int</span>[ intsNeeded ] );
+<a name="l00243"></a>00243 
+<a name="l00244"></a>00244             rep_-&gt;str[ rep_-&gt;size = sz ] = <span class="charliteral">&#39;\0&#39;</span>;
+<a name="l00245"></a>00245             rep_-&gt;capacity = cap;
+<a name="l00246"></a>00246         }
+<a name="l00247"></a>00247         <span class="keywordflow">else</span>
+<a name="l00248"></a>00248         {
+<a name="l00249"></a>00249             rep_ = &amp;nullrep_;
+<a name="l00250"></a>00250         }
+<a name="l00251"></a>00251     }
+<a name="l00252"></a>00252 
+<a name="l00253"></a>00253     <span class="keywordtype">void</span> quit()
+<a name="l00254"></a>00254     {
+<a name="l00255"></a>00255         <span class="keywordflow">if</span> (rep_ != &amp;nullrep_)
+<a name="l00256"></a>00256         {
+<a name="l00257"></a>00257             <span class="comment">// The rep_ is really an array of ints. (see the allocator, above).</span>
+<a name="l00258"></a>00258             <span class="comment">// Cast it back before delete, so the compiler won&#39;t incorrectly call destructors.</span>
+<a name="l00259"></a>00259             <span class="keyword">delete</span> [] ( <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>( rep_ ) );
+<a name="l00260"></a>00260         }
+<a name="l00261"></a>00261     }
+<a name="l00262"></a>00262 
+<a name="l00263"></a>00263     Rep * rep_;
+<a name="l00264"></a>00264     <span class="keyword">static</span> Rep nullrep_;
+<a name="l00265"></a>00265 
+<a name="l00266"></a>00266 } ;
+<a name="l00267"></a>00267 
+<a name="l00268"></a>00268 
+<a name="l00269"></a>00269 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b)
+<a name="l00270"></a>00270 {
+<a name="l00271"></a>00271     <span class="keywordflow">return</span>    ( a.length() == b.length() )              <span class="comment">// optimization on some platforms</span>
+<a name="l00272"></a>00272            &amp;&amp; ( strcmp(a.c_str(), b.c_str()) == 0 );    <span class="comment">// actual compare</span>
+<a name="l00273"></a>00273 }
+<a name="l00274"></a>00274 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b)
+<a name="l00275"></a>00275 {
+<a name="l00276"></a>00276     <span class="keywordflow">return</span> strcmp(a.c_str(), b.c_str()) &lt; 0;
+<a name="l00277"></a>00277 }
+<a name="l00278"></a>00278 
+<a name="l00279"></a>00279 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(a == b); }
+<a name="l00280"></a>00280 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;  (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> b &lt; a; }
+<a name="l00281"></a>00281 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(b &lt; a); }
+<a name="l00282"></a>00282 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(a &lt; b); }
+<a name="l00283"></a>00283 
+<a name="l00284"></a>00284 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b) { <span class="keywordflow">return</span> strcmp(a.c_str(), b) == 0; }
+<a name="l00285"></a>00285 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> b == a; }
+<a name="l00286"></a>00286 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b) { <span class="keywordflow">return</span> !(a == b); }
+<a name="l00287"></a>00287 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(b == a); }
+<a name="l00288"></a>00288 
+<a name="l00289"></a>00289 TiXmlString operator + (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b);
+<a name="l00290"></a>00290 TiXmlString operator + (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b);
+<a name="l00291"></a>00291 TiXmlString operator + (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b);
+<a name="l00292"></a>00292 
+<a name="l00293"></a>00293 
+<a name="l00294"></a>00294 <span class="comment">/*</span>
+<a name="l00295"></a>00295 <span class="comment">   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.</span>
+<a name="l00296"></a>00296 <span class="comment">   Only the operators that we need for TinyXML have been developped.</span>
+<a name="l00297"></a>00297 <span class="comment">*/</span>
+<a name="l00298"></a>00298 <span class="keyword">class </span>TiXmlOutStream : <span class="keyword">public</span> TiXmlString
+<a name="l00299"></a>00299 {
+<a name="l00300"></a>00300 <span class="keyword">public</span> :
+<a name="l00301"></a>00301 
+<a name="l00302"></a>00302     <span class="comment">// TiXmlOutStream &lt;&lt; operator.</span>
+<a name="l00303"></a>00303     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> TiXmlString &amp; in)
+<a name="l00304"></a>00304     {
+<a name="l00305"></a>00305         *<span class="keyword">this</span> += in;
+<a name="l00306"></a>00306         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
+<a name="l00307"></a>00307     }
+<a name="l00308"></a>00308 
+<a name="l00309"></a>00309     <span class="comment">// TiXmlOutStream &lt;&lt; operator.</span>
+<a name="l00310"></a>00310     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> <span class="keywordtype">char</span> * in)
+<a name="l00311"></a>00311     {
+<a name="l00312"></a>00312         *<span class="keyword">this</span> += in;
+<a name="l00313"></a>00313         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
+<a name="l00314"></a>00314     }
+<a name="l00315"></a>00315 
+<a name="l00316"></a>00316 } ;
+<a name="l00317"></a>00317 
+<a name="l00318"></a>00318 <span class="preprocessor">#endif  // TIXML_STRING_INCLUDED</span>
+<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#endif  // TIXML_USE_STL</span>
+</pre></div></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/tinyxml_8h_source.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tinyxml_8h_source.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/tinyxml_8h_source.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tinyxml_8h_source.html.svn-base	2013-05-09 18:10:01.643874321 +0200
@@ -0,0 +1,1205 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: tinyxml.h Source File</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li class="current"><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
+    </ul>
+  </div>
+<h1>tinyxml.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
+<a name="l00002"></a>00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
+<a name="l00003"></a>00003 <span class="comment">Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)</span>
+<a name="l00004"></a>00004 <span class="comment"></span>
+<a name="l00005"></a>00005 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied</span>
+<a name="l00006"></a>00006 <span class="comment">warranty. In no event will the authors be held liable for any</span>
+<a name="l00007"></a>00007 <span class="comment">damages arising from the use of this software.</span>
+<a name="l00008"></a>00008 <span class="comment"></span>
+<a name="l00009"></a>00009 <span class="comment">Permission is granted to anyone to use this software for any</span>
+<a name="l00010"></a>00010 <span class="comment">purpose, including commercial applications, and to alter it and</span>
+<a name="l00011"></a>00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
+<a name="l00012"></a>00012 <span class="comment"></span>
+<a name="l00013"></a>00013 <span class="comment">1. The origin of this software must not be misrepresented; you must</span>
+<a name="l00014"></a>00014 <span class="comment">not claim that you wrote the original software. If you use this</span>
+<a name="l00015"></a>00015 <span class="comment">software in a product, an acknowledgment in the product documentation</span>
+<a name="l00016"></a>00016 <span class="comment">would be appreciated but is not required.</span>
+<a name="l00017"></a>00017 <span class="comment"></span>
+<a name="l00018"></a>00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
+<a name="l00019"></a>00019 <span class="comment">must not be misrepresented as being the original software.</span>
+<a name="l00020"></a>00020 <span class="comment"></span>
+<a name="l00021"></a>00021 <span class="comment">3. This notice may not be removed or altered from any source</span>
+<a name="l00022"></a>00022 <span class="comment">distribution.</span>
+<a name="l00023"></a>00023 <span class="comment">*/</span>
+<a name="l00024"></a>00024 
+<a name="l00025"></a>00025 
+<a name="l00026"></a>00026 <span class="preprocessor">#ifndef TINYXML_INCLUDED</span>
+<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define TINYXML_INCLUDED</span>
+<a name="l00028"></a>00028 <span class="preprocessor"></span>
+<a name="l00029"></a>00029 <span class="preprocessor">#ifdef _MSC_VER</span>
+<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( push )</span>
+<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4530 )</span>
+<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4786 )</span>
+<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00034"></a>00034 <span class="preprocessor"></span>
+<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
+<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
+<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
+<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;string.h&gt;</span>
+<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;assert.h&gt;</span>
+<a name="l00040"></a>00040 
+<a name="l00041"></a>00041 <span class="comment">// Help out windows:</span>
+<a name="l00042"></a>00042 <span class="preprocessor">#if defined( _DEBUG ) &amp;&amp; !defined( DEBUG )</span>
+<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG</span>
+<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00045"></a>00045 <span class="preprocessor"></span>
+<a name="l00046"></a>00046 <span class="preprocessor">#ifdef TIXML_USE_STL</span>
+<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;string&gt;</span>
+<a name="l00048"></a>00048 <span class="preprocessor">    #include &lt;iostream&gt;</span>
+<a name="l00049"></a>00049 <span class="preprocessor">    #include &lt;sstream&gt;</span>
+<a name="l00050"></a>00050 <span class="preprocessor">    #define TIXML_STRING        std::string</span>
+<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#else</span>
+<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">    #include &quot;tinystr.h&quot;</span>
+<a name="l00053"></a>00053 <span class="preprocessor">    #define TIXML_STRING        TiXmlString</span>
+<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00055"></a>00055 <span class="preprocessor"></span>
+<a name="l00056"></a>00056 <span class="comment">// Deprecated library function hell. Compilers want to use the</span>
+<a name="l00057"></a>00057 <span class="comment">// new safe versions. This probably doesn&#39;t fully address the problem,</span>
+<a name="l00058"></a>00058 <span class="comment">// but it gets closer. There are too many compilers for me to fully</span>
+<a name="l00059"></a>00059 <span class="comment">// test. If you get compilation troubles, undefine TIXML_SAFE</span>
+<a name="l00060"></a>00060 <span class="preprocessor">#define TIXML_SAFE</span>
+<a name="l00061"></a>00061 <span class="preprocessor"></span>
+<a name="l00062"></a>00062 <span class="preprocessor">#ifdef TIXML_SAFE</span>
+<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">    #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400 )</span>
+<a name="l00064"></a>00064 <span class="preprocessor"></span>        <span class="comment">// Microsoft visual studio, version 2005 and higher.</span>
+<a name="l00065"></a>00065 <span class="preprocessor">        #define TIXML_SNPRINTF _snprintf_s</span>
+<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf_s</span>
+<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200 )</span>
+<a name="l00068"></a>00068 <span class="preprocessor"></span>        <span class="comment">// Microsoft visual studio, version 6 and higher.</span>
+<a name="l00069"></a>00069         <span class="comment">//#pragma message( &quot;Using _sn* functions.&quot; )</span>
+<a name="l00070"></a>00070 <span class="preprocessor">        #define TIXML_SNPRINTF _snprintf</span>
+<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3 )</span>
+<a name="l00073"></a>00073 <span class="preprocessor"></span>        <span class="comment">// GCC version 3 and higher.s</span>
+<a name="l00074"></a>00074         <span class="comment">//#warning( &quot;Using sn* functions.&quot; )</span>
+<a name="l00075"></a>00075 <span class="preprocessor">        #define TIXML_SNPRINTF snprintf</span>
+<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
+<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SNPRINTF snprintf</span>
+<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#endif  </span>
+<a name="l00082"></a>00082 <span class="preprocessor"></span>
+<a name="l00083"></a>00083 <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>;
+<a name="l00084"></a>00084 <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l00085"></a>00085 <span class="keyword">class </span><a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>;
+<a name="l00086"></a>00086 <span class="keyword">class </span><a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>;
+<a name="l00087"></a>00087 <span class="keyword">class </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>;
+<a name="l00088"></a>00088 <span class="keyword">class </span><a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>;
+<a name="l00089"></a>00089 <span class="keyword">class </span><a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>;
+<a name="l00090"></a>00090 <span class="keyword">class </span>TiXmlParsingData;
+<a name="l00091"></a>00091 
+<a name="l00092"></a>00092 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_MAJOR_VERSION = 2;
+<a name="l00093"></a>00093 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_MINOR_VERSION = 6;
+<a name="l00094"></a>00094 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_PATCH_VERSION = 1;
+<a name="l00095"></a>00095 
+<a name="l00096"></a>00096 <span class="comment">/*  Internal structure for tracking location of items </span>
+<a name="l00097"></a>00097 <span class="comment">    in the XML file.</span>
+<a name="l00098"></a>00098 <span class="comment">*/</span>
+<a name="l00099"></a>00099 <span class="keyword">struct </span>TiXmlCursor
+<a name="l00100"></a>00100 {
+<a name="l00101"></a>00101     TiXmlCursor()       { Clear(); }
+<a name="l00102"></a>00102     <span class="keywordtype">void</span> Clear()        { row = col = -1; }
+<a name="l00103"></a>00103 
+<a name="l00104"></a>00104     <span class="keywordtype">int</span> row;    <span class="comment">// 0 based.</span>
+<a name="l00105"></a>00105     <span class="keywordtype">int</span> col;    <span class="comment">// 0 based.</span>
+<a name="l00106"></a>00106 };
+<a name="l00107"></a>00107 
+<a name="l00108"></a>00108 
+<a name="l00128"></a><a class="code" href="classTiXmlVisitor.html">00128</a> <span class="keyword">class </span><a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>
+<a name="l00129"></a>00129 {
+<a name="l00130"></a>00130 <span class="keyword">public</span>:
+<a name="l00131"></a>00131     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>() {}
+<a name="l00132"></a>00132 
+<a name="l00134"></a><a class="code" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">00134</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0" title="Visit a document.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; <span class="comment">/*doc*/</span> )         { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00136"></a><a class="code" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">00136</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad" title="Visit a document.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; <span class="comment">/*doc*/</span> )          { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00137"></a>00137 
+<a name="l00139"></a><a class="code" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">00139</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff" title="Visit an element.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; <span class="comment">/*element*/</span>, <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="comment">/*firstAttribute*/</span> )    { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00141"></a><a class="code" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">00141</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c" title="Visit an element.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; <span class="comment">/*element*/</span> )       { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00142"></a>00142 
+<a name="l00144"></a><a class="code" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">00144</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; <span class="comment">/*declaration*/</span> )   { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00146"></a><a class="code" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">00146</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5" title="Visit a text node.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; <span class="comment">/*text*/</span> )                 { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00148"></a><a class="code" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">00148</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2" title="Visit a comment node.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; <span class="comment">/*comment*/</span> )           { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00150"></a><a class="code" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28">00150</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28" title="Visit an unknow node.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; <span class="comment">/*unknown*/</span> )           { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00151"></a>00151 };
+<a name="l00152"></a>00152 
+<a name="l00153"></a>00153 <span class="comment">// Only used by Attribute::Query functions</span>
+<a name="l00154"></a>00154 <span class="keyword">enum</span> 
+<a name="l00155"></a>00155 { 
+<a name="l00156"></a>00156     TIXML_SUCCESS,
+<a name="l00157"></a>00157     TIXML_NO_ATTRIBUTE,
+<a name="l00158"></a>00158     TIXML_WRONG_TYPE
+<a name="l00159"></a>00159 };
+<a name="l00160"></a>00160 
+<a name="l00161"></a>00161 
+<a name="l00162"></a>00162 <span class="comment">// Used by the parsing routines.</span>
+<a name="l00163"></a>00163 <span class="keyword">enum</span> TiXmlEncoding
+<a name="l00164"></a>00164 {
+<a name="l00165"></a>00165     TIXML_ENCODING_UNKNOWN,
+<a name="l00166"></a>00166     TIXML_ENCODING_UTF8,
+<a name="l00167"></a>00167     TIXML_ENCODING_LEGACY
+<a name="l00168"></a>00168 };
+<a name="l00169"></a>00169 
+<a name="l00170"></a>00170 <span class="keyword">const</span> TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+<a name="l00171"></a>00171 
+<a name="l00194"></a><a class="code" href="classTiXmlBase.html">00194</a> <span class="keyword">class </span><a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>
+<a name="l00195"></a>00195 {
+<a name="l00196"></a>00196     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>;
+<a name="l00197"></a>00197     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l00198"></a>00198     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>;
+<a name="l00199"></a>00199 
+<a name="l00200"></a>00200 <span class="keyword">public</span>:
+<a name="l00201"></a>00201     <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>() :   <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>(0)     {}
+<a name="l00202"></a>00202     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>()            {}
+<a name="l00203"></a>00203 
+<a name="l00213"></a>00213     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span> = 0;
+<a name="l00214"></a>00214 
+<a name="l00221"></a><a class="code" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">00221</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1" title="The world does not agree on whether white space should be kept or not.">SetCondenseWhiteSpace</a>( <span class="keywordtype">bool</span> condense )      { condenseWhiteSpace = condense; }
+<a name="l00222"></a>00222 
+<a name="l00224"></a><a class="code" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">00224</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438" title="Return the current white space setting.">IsWhiteSpaceCondensed</a>()                     { <span class="keywordflow">return</span> condenseWhiteSpace; }
+<a name="l00225"></a>00225 
+<a name="l00244"></a><a class="code" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">00244</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> location.row + 1; }
+<a name="l00245"></a><a class="code" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">00245</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">Column</a>()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> location.col + 1; }    
+<a name="l00246"></a>00246 
+<a name="l00247"></a><a class="code" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">00247</a>     <span class="keywordtype">void</span>  <a class="code" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d" title="Set a pointer to arbitrary user data.">SetUserData</a>( <span class="keywordtype">void</span>* user )         { <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a> = user; }    
+<a name="l00248"></a><a class="code" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">00248</a>     <span class="keywordtype">void</span>* <a class="code" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17" title="Get a pointer to arbitrary user data.">GetUserData</a>()                     { <span class="keywordflow">return</span> <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>; }    
+<a name="l00249"></a><a class="code" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">00249</a>     <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4" title="Get a pointer to arbitrary user data.">GetUserData</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>; }    
+<a name="l00250"></a>00250 
+<a name="l00251"></a>00251     <span class="comment">// Table that returs, for a given lead byte, the total number of bytes</span>
+<a name="l00252"></a>00252     <span class="comment">// in the UTF-8 sequence.</span>
+<a name="l00253"></a>00253     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> utf8ByteTable[256];
+<a name="l00254"></a>00254 
+<a name="l00255"></a>00255     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378" title="Parse the given null terminated block of xml data.">Parse</a>(  <span class="keyword">const</span> <span class="keywordtype">char</span>* p, 
+<a name="l00256"></a>00256                                 TiXmlParsingData* data, 
+<a name="l00257"></a>00257                                 TiXmlEncoding encoding <span class="comment">/*= TIXML_ENCODING_UNKNOWN */</span> ) = 0;
+<a name="l00258"></a>00258 
+<a name="l00262"></a>00262     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948" title="Expands entities in a string.">EncodeString</a>( <span class="keyword">const</span> TIXML_STRING&amp; str, TIXML_STRING* out );
+<a name="l00263"></a>00263 
+<a name="l00264"></a>00264     <span class="keyword">enum</span>
+<a name="l00265"></a>00265     {
+<a name="l00266"></a>00266         TIXML_NO_ERROR = 0,
+<a name="l00267"></a>00267         TIXML_ERROR,
+<a name="l00268"></a>00268         TIXML_ERROR_OPENING_FILE,
+<a name="l00269"></a>00269         TIXML_ERROR_PARSING_ELEMENT,
+<a name="l00270"></a>00270         TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+<a name="l00271"></a>00271         TIXML_ERROR_READING_ELEMENT_VALUE,
+<a name="l00272"></a>00272         TIXML_ERROR_READING_ATTRIBUTES,
+<a name="l00273"></a>00273         TIXML_ERROR_PARSING_EMPTY,
+<a name="l00274"></a>00274         TIXML_ERROR_READING_END_TAG,
+<a name="l00275"></a>00275         TIXML_ERROR_PARSING_UNKNOWN,
+<a name="l00276"></a>00276         TIXML_ERROR_PARSING_COMMENT,
+<a name="l00277"></a>00277         TIXML_ERROR_PARSING_DECLARATION,
+<a name="l00278"></a>00278         TIXML_ERROR_DOCUMENT_EMPTY,
+<a name="l00279"></a>00279         TIXML_ERROR_EMBEDDED_NULL,
+<a name="l00280"></a>00280         TIXML_ERROR_PARSING_CDATA,
+<a name="l00281"></a>00281         TIXML_ERROR_DOCUMENT_TOP_ONLY,
+<a name="l00282"></a>00282 
+<a name="l00283"></a>00283         TIXML_ERROR_STRING_COUNT
+<a name="l00284"></a>00284     };
+<a name="l00285"></a>00285 
+<a name="l00286"></a>00286 <span class="keyword">protected</span>:
+<a name="l00287"></a>00287 
+<a name="l00288"></a>00288     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* SkipWhiteSpace( <span class="keyword">const</span> <span class="keywordtype">char</span>*, TiXmlEncoding encoding );
+<a name="l00289"></a>00289 
+<a name="l00290"></a>00290     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsWhiteSpace( <span class="keywordtype">char</span> c )       
+<a name="l00291"></a>00291     { 
+<a name="l00292"></a>00292         <span class="keywordflow">return</span> ( isspace( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) c ) || c == <span class="charliteral">&#39;\n&#39;</span> || c == <span class="charliteral">&#39;\r&#39;</span> ); 
+<a name="l00293"></a>00293     }
+<a name="l00294"></a>00294     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsWhiteSpace( <span class="keywordtype">int</span> c )
+<a name="l00295"></a>00295     {
+<a name="l00296"></a>00296         <span class="keywordflow">if</span> ( c &lt; 256 )
+<a name="l00297"></a>00297             <span class="keywordflow">return</span> IsWhiteSpace( (<span class="keywordtype">char</span>) c );
+<a name="l00298"></a>00298         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// Again, only truly correct for English/Latin...but usually works.</span>
+<a name="l00299"></a>00299     }
+<a name="l00300"></a>00300 
+<a name="l00301"></a>00301 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00302"></a>00302 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">bool</span> StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+<a name="l00303"></a>00303     <span class="keyword">static</span> <span class="keywordtype">bool</span> StreamTo( std::istream * in, <span class="keywordtype">int</span> character, TIXML_STRING * tag );
+<a name="l00304"></a>00304 <span class="preprocessor">    #endif</span>
+<a name="l00305"></a>00305 <span class="preprocessor"></span>
+<a name="l00306"></a>00306     <span class="comment">/*  Reads an XML name into the string provided. Returns</span>
+<a name="l00307"></a>00307 <span class="comment">        a pointer just past the last character of the name,</span>
+<a name="l00308"></a>00308 <span class="comment">        or 0 if the function has an error.</span>
+<a name="l00309"></a>00309 <span class="comment">    */</span>
+<a name="l00310"></a>00310     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadName( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TIXML_STRING* name, TiXmlEncoding encoding );
+<a name="l00311"></a>00311 
+<a name="l00312"></a>00312     <span class="comment">/*  Reads text. Returns a pointer past the given end tag.</span>
+<a name="l00313"></a>00313 <span class="comment">        Wickedly complex options, but it keeps the (sensitive) code in one place.</span>
+<a name="l00314"></a>00314 <span class="comment">    */</span>
+<a name="l00315"></a>00315     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadText(    <span class="keyword">const</span> <span class="keywordtype">char</span>* in,             <span class="comment">// where to start</span>
+<a name="l00316"></a>00316                                     TIXML_STRING* text,         <span class="comment">// the string read</span>
+<a name="l00317"></a>00317                                     <span class="keywordtype">bool</span> ignoreWhiteSpace,      <span class="comment">// whether to keep the white space</span>
+<a name="l00318"></a>00318                                     <span class="keyword">const</span> <span class="keywordtype">char</span>* endTag,         <span class="comment">// what ends this text</span>
+<a name="l00319"></a>00319                                     <span class="keywordtype">bool</span> ignoreCase,            <span class="comment">// whether to ignore case in the end tag</span>
+<a name="l00320"></a>00320                                     TiXmlEncoding encoding );   <span class="comment">// the current encoding</span>
+<a name="l00321"></a>00321 
+<a name="l00322"></a>00322     <span class="comment">// If an entity has been found, transform it into a character.</span>
+<a name="l00323"></a>00323     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* GetEntity( <span class="keyword">const</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span>* length, TiXmlEncoding encoding );
+<a name="l00324"></a>00324 
+<a name="l00325"></a>00325     <span class="comment">// Get a character, while interpreting entities.</span>
+<a name="l00326"></a>00326     <span class="comment">// The length can be from 0 to 4 bytes.</span>
+<a name="l00327"></a>00327     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* GetChar( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, <span class="keywordtype">char</span>* _value, <span class="keywordtype">int</span>* length, TiXmlEncoding encoding )
+<a name="l00328"></a>00328     {
+<a name="l00329"></a>00329         assert( p );
+<a name="l00330"></a>00330         <span class="keywordflow">if</span> ( encoding == TIXML_ENCODING_UTF8 )
+<a name="l00331"></a>00331         {
+<a name="l00332"></a>00332             *length = utf8ByteTable[ *((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)p) ];
+<a name="l00333"></a>00333             assert( *length &gt;= 0 &amp;&amp; *length &lt; 5 );
+<a name="l00334"></a>00334         }
+<a name="l00335"></a>00335         <span class="keywordflow">else</span>
+<a name="l00336"></a>00336         {
+<a name="l00337"></a>00337             *length = 1;
+<a name="l00338"></a>00338         }
+<a name="l00339"></a>00339 
+<a name="l00340"></a>00340         <span class="keywordflow">if</span> ( *length == 1 )
+<a name="l00341"></a>00341         {
+<a name="l00342"></a>00342             <span class="keywordflow">if</span> ( *p == <span class="charliteral">&#39;&amp;&#39;</span> )
+<a name="l00343"></a>00343                 <span class="keywordflow">return</span> GetEntity( p, _value, length, encoding );
+<a name="l00344"></a>00344             *_value = *p;
+<a name="l00345"></a>00345             <span class="keywordflow">return</span> p+1;
+<a name="l00346"></a>00346         }
+<a name="l00347"></a>00347         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( *length )
+<a name="l00348"></a>00348         {
+<a name="l00349"></a>00349             <span class="comment">//strncpy( _value, p, *length );    // lots of compilers don&#39;t like this function (unsafe),</span>
+<a name="l00350"></a>00350                                                 <span class="comment">// and the null terminator isn&#39;t needed</span>
+<a name="l00351"></a>00351             <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; p[i] &amp;&amp; i&lt;*length; ++i ) {
+<a name="l00352"></a>00352                 _value[i] = p[i];
+<a name="l00353"></a>00353             }
+<a name="l00354"></a>00354             <span class="keywordflow">return</span> p + (*length);
+<a name="l00355"></a>00355         }
+<a name="l00356"></a>00356         <span class="keywordflow">else</span>
+<a name="l00357"></a>00357         {
+<a name="l00358"></a>00358             <span class="comment">// Not valid text.</span>
+<a name="l00359"></a>00359             <span class="keywordflow">return</span> 0;
+<a name="l00360"></a>00360         }
+<a name="l00361"></a>00361     }
+<a name="l00362"></a>00362 
+<a name="l00363"></a>00363     <span class="comment">// Return true if the next characters in the stream are any of the endTag sequences.</span>
+<a name="l00364"></a>00364     <span class="comment">// Ignore case only works for english, and should only be relied on when comparing</span>
+<a name="l00365"></a>00365     <span class="comment">// to English words: StringEqual( p, &quot;version&quot;, true ) is fine.</span>
+<a name="l00366"></a>00366     <span class="keyword">static</span> <span class="keywordtype">bool</span> StringEqual(    <span class="keyword">const</span> <span class="keywordtype">char</span>* p,
+<a name="l00367"></a>00367                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* endTag,
+<a name="l00368"></a>00368                                 <span class="keywordtype">bool</span> ignoreCase,
+<a name="l00369"></a>00369                                 TiXmlEncoding encoding );
+<a name="l00370"></a>00370 
+<a name="l00371"></a>00371     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* errorString[ TIXML_ERROR_STRING_COUNT ];
+<a name="l00372"></a>00372 
+<a name="l00373"></a>00373     TiXmlCursor location;
+<a name="l00374"></a>00374 
+<a name="l00376"></a><a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">00376</a>     <span class="keywordtype">void</span>*           <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>;
+<a name="l00377"></a>00377     
+<a name="l00378"></a>00378     <span class="comment">// None of these methods are reliable for any language except English.</span>
+<a name="l00379"></a>00379     <span class="comment">// Good for approximation, not great for accuracy.</span>
+<a name="l00380"></a>00380     <span class="keyword">static</span> <span class="keywordtype">int</span> IsAlpha( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> anyByte, TiXmlEncoding encoding );
+<a name="l00381"></a>00381     <span class="keyword">static</span> <span class="keywordtype">int</span> IsAlphaNum( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> anyByte, TiXmlEncoding encoding );
+<a name="l00382"></a>00382     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> ToLower( <span class="keywordtype">int</span> v, TiXmlEncoding encoding )
+<a name="l00383"></a>00383     {
+<a name="l00384"></a>00384         <span class="keywordflow">if</span> ( encoding == TIXML_ENCODING_UTF8 )
+<a name="l00385"></a>00385         {
+<a name="l00386"></a>00386             <span class="keywordflow">if</span> ( v &lt; 128 ) <span class="keywordflow">return</span> tolower( v );
+<a name="l00387"></a>00387             <span class="keywordflow">return</span> v;
+<a name="l00388"></a>00388         }
+<a name="l00389"></a>00389         <span class="keywordflow">else</span>
+<a name="l00390"></a>00390         {
+<a name="l00391"></a>00391             <span class="keywordflow">return</span> tolower( v );
+<a name="l00392"></a>00392         }
+<a name="l00393"></a>00393     }
+<a name="l00394"></a>00394     <span class="keyword">static</span> <span class="keywordtype">void</span> ConvertUTF32ToUTF8( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> input, <span class="keywordtype">char</span>* output, <span class="keywordtype">int</span>* length );
+<a name="l00395"></a>00395 
+<a name="l00396"></a>00396 <span class="keyword">private</span>:
+<a name="l00397"></a>00397     <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>&amp; );              <span class="comment">// not implemented.</span>
+<a name="l00398"></a>00398     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>&amp; base );    <span class="comment">// not allowed.</span>
+<a name="l00399"></a>00399 
+<a name="l00400"></a>00400     <span class="keyword">struct </span>Entity
+<a name="l00401"></a>00401     {
+<a name="l00402"></a>00402         <span class="keyword">const</span> <span class="keywordtype">char</span>*     str;
+<a name="l00403"></a>00403         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    strLength;
+<a name="l00404"></a>00404         <span class="keywordtype">char</span>            chr;
+<a name="l00405"></a>00405     };
+<a name="l00406"></a>00406     <span class="keyword">enum</span>
+<a name="l00407"></a>00407     {
+<a name="l00408"></a>00408         NUM_ENTITY = 5,
+<a name="l00409"></a>00409         MAX_ENTITY_LENGTH = 6
+<a name="l00410"></a>00410 
+<a name="l00411"></a>00411     };
+<a name="l00412"></a>00412     <span class="keyword">static</span> Entity entity[ NUM_ENTITY ];
+<a name="l00413"></a>00413     <span class="keyword">static</span> <span class="keywordtype">bool</span> condenseWhiteSpace;
+<a name="l00414"></a>00414 };
+<a name="l00415"></a>00415 
+<a name="l00416"></a>00416 
+<a name="l00423"></a><a class="code" href="classTiXmlNode.html">00423</a> <span class="keyword">class </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>
+<a name="l00424"></a>00424 {
+<a name="l00425"></a>00425     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>;
+<a name="l00426"></a>00426     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l00427"></a>00427 
+<a name="l00428"></a>00428 <span class="keyword">public</span>:
+<a name="l00429"></a>00429 <span class="preprocessor">    #ifdef TIXML_USE_STL    </span>
+<a name="l00430"></a>00430 <span class="preprocessor"></span>
+<a name="l00434"></a>00434         <span class="keyword">friend</span> std::istream&amp; <a class="code" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9" title="An input stream operator, for every class.">operator &gt;&gt; </a>(std::istream&amp; in, <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base);
+<a name="l00435"></a>00435 
+<a name="l00452"></a>00452         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7" title="An output stream operator, for every class.">operator&lt;&lt; </a>(std::ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base);
+<a name="l00453"></a>00453 
+<a name="l00455"></a>00455         <span class="keyword">friend</span> std::string&amp; <a class="code" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7" title="An output stream operator, for every class.">operator&lt;&lt; </a>(std::string&amp; out, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base );
+<a name="l00456"></a>00456 
+<a name="l00457"></a>00457 <span class="preprocessor">    #endif</span>
+<a name="l00458"></a>00458 <span class="preprocessor"></span>
+<a name="l00462"></a><a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">00462</a>     <span class="keyword">enum</span> <a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2" title="The types of XML nodes supported by TinyXml.">NodeType</a>
+<a name="l00463"></a>00463     {
+<a name="l00464"></a>00464         TINYXML_DOCUMENT,
+<a name="l00465"></a>00465         TINYXML_ELEMENT,
+<a name="l00466"></a>00466         TINYXML_COMMENT,
+<a name="l00467"></a>00467         TINYXML_UNKNOWN,
+<a name="l00468"></a>00468         TINYXML_TEXT,
+<a name="l00469"></a>00469         TINYXML_DECLARATION,
+<a name="l00470"></a>00470         TINYXML_TYPECOUNT
+<a name="l00471"></a>00471     };
+<a name="l00472"></a>00472 
+<a name="l00473"></a>00473     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>();
+<a name="l00474"></a>00474 
+<a name="l00487"></a><a class="code" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">00487</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &amp;#39;value&amp;#39; changes for the specific type of TiXmlNode.">Value</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value.c_str (); }
+<a name="l00488"></a>00488 
+<a name="l00489"></a>00489 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00490"></a>00490 <span class="preprocessor"></span>
+<a name="l00494"></a><a class="code" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">00494</a>     <span class="keyword">const</span> std::string&amp; <a class="code" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5" title="Return Value() as a std::string.">ValueStr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }
+<a name="l00495"></a>00495 <span class="preprocessor">    #endif</span>
+<a name="l00496"></a>00496 <span class="preprocessor"></span>
+<a name="l00497"></a>00497     <span class="keyword">const</span> TIXML_STRING&amp; ValueTStr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }
+<a name="l00498"></a>00498 
+<a name="l00508"></a><a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">00508</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * _value) { value = _value;}
+<a name="l00509"></a>00509 
+<a name="l00510"></a>00510 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00512"></a><a class="code" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">00512</a> <span class="preprocessor">    void SetValue( const std::string&amp; _value )  { value = _value; }</span>
+<a name="l00513"></a>00513 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00514"></a>00514 <span class="preprocessor"></span>
+<a name="l00516"></a>00516     <span class="keywordtype">void</span> <a class="code" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b" title="Delete all the children of this node. Does not affect &amp;#39;this&amp;#39;.">Clear</a>();
+<a name="l00517"></a>00517 
+<a name="l00519"></a><a class="code" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">00519</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e" title="One step up the DOM.">Parent</a>()                         { <span class="keywordflow">return</span> parent; }
+<a name="l00520"></a>00520     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e" title="One step up the DOM.">Parent</a>()<span class="keyword"> const             </span>{ <span class="keywordflow">return</span> parent; }
+<a name="l00521"></a>00521 
+<a name="l00522"></a><a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">00522</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0" title="The first child of this node. Will be null if there are no children.">FirstChild</a>()<span class="keyword">   const       </span>{ <span class="keywordflow">return</span> firstChild; }  
+<a name="l00523"></a>00523     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0" title="The first child of this node. Will be null if there are no children.">FirstChild</a>()                     { <span class="keywordflow">return</span> firstChild; }
+<a name="l00524"></a>00524     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0" title="The first child of this node. Will be null if there are no children.">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;            
+<a name="l00525"></a>00525 
+<a name="l00526"></a><a class="code" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">00526</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554" title="The first child of this node with the matching &amp;#39;value&amp;#39;. Will be null if none...">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00527"></a>00527         <span class="comment">// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)</span>
+<a name="l00528"></a>00528         <span class="comment">// call the method, cast the return back to non-const.</span>
+<a name="l00529"></a>00529         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span> ((<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;FirstChild( _value ));
+<a name="l00530"></a>00530     }
+<a name="l00531"></a>00531     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* LastChild()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> lastChild; }       
+<a name="l00532"></a><a class="code" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">00532</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031" title="The last child of this node. Will be null if there are no children.">LastChild</a>()  { <span class="keywordflow">return</span> lastChild; }
+<a name="l00533"></a>00533     
+<a name="l00534"></a>00534     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* LastChild( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;         
+<a name="l00535"></a><a class="code" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">00535</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d" title="The last child of this node matching &amp;#39;value&amp;#39;. Will be null if there are no...">LastChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00536"></a>00536         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span> ((<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;LastChild( _value ));
+<a name="l00537"></a>00537     }
+<a name="l00538"></a>00538 
+<a name="l00539"></a>00539 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00540"></a><a class="code" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">00540</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6" title="STL std::string form.">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const  </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6" title="STL std::string form.">FirstChild</a> (_value.c_str ());    }   
+<a name="l00541"></a><a class="code" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">00541</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6" title="STL std::string form.">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )              {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6" title="STL std::string form.">FirstChild</a> (_value.c_str ());    }   
+<a name="l00542"></a><a class="code" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">00542</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63" title="STL std::string form.">LastChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const   </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63" title="STL std::string form.">LastChild</a> (_value.c_str ()); }   
+<a name="l00543"></a><a class="code" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">00543</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3" title="STL std::string form.">LastChild</a>( <span class="keyword">const</span> std::string&amp; _value )               {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3" title="STL std::string form.">LastChild</a> (_value.c_str ()); }   
+<a name="l00544"></a>00544 <span class="preprocessor">    #endif</span>
+<a name="l00545"></a>00545 <span class="preprocessor"></span>
+<a name="l00562"></a>00562     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) <span class="keyword">const</span>;
+<a name="l00563"></a>00563     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) {
+<a name="l00564"></a>00564         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;IterateChildren( previous ) );
+<a name="l00565"></a>00565     }
+<a name="l00566"></a>00566 
+<a name="l00568"></a>00568     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) <span class="keyword">const</span>;
+<a name="l00569"></a>00569     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) {
+<a name="l00570"></a>00570         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;IterateChildren( _value, previous ) );
+<a name="l00571"></a>00571     }
+<a name="l00572"></a>00572 
+<a name="l00573"></a>00573 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00574"></a><a class="code" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">00574</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df" title="STL std::string form.">IterateChildren</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous )<span class="keyword"> const  </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df" title="STL std::string form.">IterateChildren</a> (_value.c_str (), previous); }   
+<a name="l00575"></a><a class="code" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">00575</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c" title="STL std::string form.">IterateChildren</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) {    <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c" title="STL std::string form.">IterateChildren</a> (_value.c_str (), previous); }   
+<a name="l00576"></a>00576 <span class="preprocessor">    #endif</span>
+<a name="l00577"></a>00577 <span class="preprocessor"></span>
+<a name="l00581"></a>00581     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba" title="Add a new node related to this.">InsertEndChild</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; addThis );
+<a name="l00582"></a>00582 
+<a name="l00583"></a>00583 
+<a name="l00593"></a>00593     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6" title="Add a new node related to this.">LinkEndChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* addThis );
+<a name="l00594"></a>00594 
+<a name="l00598"></a>00598     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7" title="Add a new node related to this.">InsertBeforeChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* beforeThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; addThis );
+<a name="l00599"></a>00599 
+<a name="l00603"></a>00603     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5" title="Add a new node related to this.">InsertAfterChild</a>(  <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* afterThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; addThis );
+<a name="l00604"></a>00604 
+<a name="l00608"></a>00608     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd" title="Replace a child of this node.">ReplaceChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* replaceThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; withThis );
+<a name="l00609"></a>00609 
+<a name="l00611"></a>00611     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf" title="Delete a child of this node.">RemoveChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* removeThis );
+<a name="l00612"></a>00612 
+<a name="l00614"></a><a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">00614</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>()<span class="keyword"> const            </span>{ <span class="keywordflow">return</span> prev; }
+<a name="l00615"></a>00615     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>()                        { <span class="keywordflow">return</span> prev; }
+<a name="l00616"></a>00616 
+<a name="l00618"></a>00618     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00619"></a>00619     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *_prev ) {
+<a name="l00620"></a>00620         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;PreviousSibling( _prev ) );
+<a name="l00621"></a>00621     }
+<a name="l00622"></a>00622 
+<a name="l00623"></a>00623 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00624"></a><a class="code" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">00624</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab" title="STL std::string form.">PreviousSibling</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab" title="STL std::string form.">PreviousSibling</a> (_value.c_str ());   }   
+<a name="l00625"></a><a class="code" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">00625</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912" title="STL std::string form.">PreviousSibling</a>( <span class="keyword">const</span> std::string&amp; _value )             {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912" title="STL std::string form.">PreviousSibling</a> (_value.c_str ());   }   
+<a name="l00626"></a><a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">00626</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>( <span class="keyword">const</span> std::string&amp; _value)<span class="keyword"> const      </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a> (_value.c_str ());   }   
+<a name="l00627"></a><a class="code" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">00627</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea" title="STL std::string form.">NextSibling</a>( <span class="keyword">const</span> std::string&amp; _value)                  {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea" title="STL std::string form.">NextSibling</a> (_value.c_str ());   }   
+<a name="l00628"></a>00628 <span class="preprocessor">    #endif</span>
+<a name="l00629"></a>00629 <span class="preprocessor"></span>
+<a name="l00631"></a><a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">00631</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>()<span class="keyword"> const                </span>{ <span class="keywordflow">return</span> next; }
+<a name="l00632"></a>00632     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>()                            { <span class="keywordflow">return</span> next; }
+<a name="l00633"></a>00633 
+<a name="l00635"></a>00635     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00636"></a>00636     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _next ) {
+<a name="l00637"></a>00637         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;NextSibling( _next ) );
+<a name="l00638"></a>00638     }
+<a name="l00639"></a>00639 
+<a name="l00644"></a>00644     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>() <span class="keyword">const</span>;
+<a name="l00645"></a>00645     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>() {
+<a name="l00646"></a>00646         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;NextSiblingElement() );
+<a name="l00647"></a>00647     }
+<a name="l00648"></a>00648 
+<a name="l00653"></a>00653     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00654"></a>00654     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *_next ) {
+<a name="l00655"></a>00655         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;NextSiblingElement( _next ) );
+<a name="l00656"></a>00656     }
+<a name="l00657"></a>00657 
+<a name="l00658"></a>00658 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00659"></a><a class="code" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">00659</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463" title="STL std::string form.">NextSiblingElement</a>( <span class="keyword">const</span> std::string&amp; _value)<span class="keyword"> const    </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463" title="STL std::string form.">NextSiblingElement</a> (_value.c_str ());    }   
+<a name="l00660"></a><a class="code" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">00660</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081" title="STL std::string form.">NextSiblingElement</a>( <span class="keyword">const</span> std::string&amp; _value)                {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081" title="STL std::string form.">NextSiblingElement</a> (_value.c_str ());    }   
+<a name="l00661"></a>00661 <span class="preprocessor">    #endif</span>
+<a name="l00662"></a>00662 <span class="preprocessor"></span>
+<a name="l00664"></a>00664     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>() <span class="keyword">const</span>;
+<a name="l00665"></a>00665     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>() {
+<a name="l00666"></a>00666         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;FirstChildElement() );
+<a name="l00667"></a>00667     }
+<a name="l00668"></a>00668 
+<a name="l00670"></a>00670     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) <span class="keyword">const</span>;
+<a name="l00671"></a>00671     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00672"></a>00672         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;FirstChildElement( _value ) );
+<a name="l00673"></a>00673     }
+<a name="l00674"></a>00674 
+<a name="l00675"></a>00675 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00676"></a><a class="code" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">00676</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7" title="STL std::string form.">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const    </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7" title="STL std::string form.">FirstChildElement</a> (_value.c_str ()); }   
+<a name="l00677"></a><a class="code" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">00677</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45" title="STL std::string form.">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )                {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45" title="STL std::string form.">FirstChildElement</a> (_value.c_str ()); }   
+<a name="l00678"></a>00678 <span class="preprocessor">    #endif</span>
+<a name="l00679"></a>00679 <span class="preprocessor"></span>
+<a name="l00684"></a><a class="code" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">00684</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e" title="Query the type (as an enumerated value, above) of this node.">Type</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> type; }
+<a name="l00685"></a>00685 
+<a name="l00689"></a>00689     <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* <a class="code" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3" title="Return a pointer to the Document this node lives in.">GetDocument</a>() <span class="keyword">const</span>;
+<a name="l00690"></a>00690     <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* <a class="code" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3" title="Return a pointer to the Document this node lives in.">GetDocument</a>() {
+<a name="l00691"></a>00691         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;GetDocument() );
+<a name="l00692"></a>00692     }
+<a name="l00693"></a>00693 
+<a name="l00695"></a><a class="code" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">00695</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3" title="Returns true if this node has no children.">NoChildren</a>()<span class="keyword"> const                     </span>{ <span class="keywordflow">return</span> !firstChild; }
+<a name="l00696"></a>00696 
+<a name="l00697"></a><a class="code" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">00697</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*    <a class="code" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08" title="Cast to a more defined type. Will return null if not of the requested type.">ToDocument</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00698"></a><a class="code" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">00698</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*     <a class="code" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c" title="Cast to a more defined type. Will return null if not of the requested type.">ToElement</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00699"></a><a class="code" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">00699</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*     <a class="code" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574" title="Cast to a more defined type. Will return null if not of the requested type.">ToComment</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00700"></a><a class="code" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">00700</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*     <a class="code" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2" title="Cast to a more defined type. Will return null if not of the requested type.">ToUnknown</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00701"></a><a class="code" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">00701</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>*        <a class="code" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69" title="Cast to a more defined type. Will return null if not of the requested type.">ToText</a>()<span class="keyword">        const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00702"></a><a class="code" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">00702</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>* <a class="code" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72" title="Cast to a more defined type. Will return null if not of the requested type.">ToDeclaration</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00703"></a>00703 
+<a name="l00704"></a><a class="code" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">00704</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*          <a class="code" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae" title="Cast to a more defined type. Will return null if not of the requested type.">ToDocument</a>()    { <span class="keywordflow">return</span> 0; } 
+<a name="l00705"></a><a class="code" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">00705</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*           <a class="code" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc" title="Cast to a more defined type. Will return null if not of the requested type.">ToElement</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00706"></a><a class="code" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">00706</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*           <a class="code" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849" title="Cast to a more defined type. Will return null if not of the requested type.">ToComment</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00707"></a><a class="code" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">00707</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*           <a class="code" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d" title="Cast to a more defined type. Will return null if not of the requested type.">ToUnknown</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00708"></a><a class="code" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">00708</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>*              <a class="code" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03" title="Cast to a more defined type. Will return null if not of the requested type.">ToText</a>()        { <span class="keywordflow">return</span> 0; } 
+<a name="l00709"></a><a class="code" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">00709</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>*       <a class="code" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df" title="Cast to a more defined type. Will return null if not of the requested type.">ToDeclaration</a>() { <span class="keywordflow">return</span> 0; } 
+<a name="l00710"></a>00710 
+<a name="l00714"></a>00714     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4" title="Create an exact duplicate of this node and return it.">Clone</a>() <span class="keyword">const</span> = 0;
+<a name="l00715"></a>00715 
+<a name="l00738"></a>00738     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span> = 0;
+<a name="l00739"></a>00739 
+<a name="l00740"></a>00740 <span class="keyword">protected</span>:
+<a name="l00741"></a>00741     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2" title="The types of XML nodes supported by TinyXml.">NodeType</a> _type );
+<a name="l00742"></a>00742 
+<a name="l00743"></a>00743     <span class="comment">// Copy to the allocated object. Shared functionality between Clone, Copy constructor,</span>
+<a name="l00744"></a>00744     <span class="comment">// and the assignment operator.</span>
+<a name="l00745"></a>00745     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* target ) <span class="keyword">const</span>;
+<a name="l00746"></a>00746 
+<a name="l00747"></a>00747 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00748"></a>00748 <span class="preprocessor"></span>        <span class="comment">// The real work of the input operator.</span>
+<a name="l00749"></a>00749     <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+<a name="l00750"></a>00750 <span class="preprocessor">    #endif</span>
+<a name="l00751"></a>00751 <span class="preprocessor"></span>
+<a name="l00752"></a>00752     <span class="comment">// Figure out what is at *p, and parse it. Returns null if it is not an xml node.</span>
+<a name="l00753"></a>00753     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* Identify( <span class="keyword">const</span> <span class="keywordtype">char</span>* start, TiXmlEncoding encoding );
+<a name="l00754"></a>00754 
+<a name="l00755"></a>00755     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      parent;
+<a name="l00756"></a>00756     <a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2" title="The types of XML nodes supported by TinyXml.">NodeType</a>        type;
+<a name="l00757"></a>00757 
+<a name="l00758"></a>00758     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      firstChild;
+<a name="l00759"></a>00759     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      lastChild;
+<a name="l00760"></a>00760 
+<a name="l00761"></a>00761     TIXML_STRING    value;
+<a name="l00762"></a>00762 
+<a name="l00763"></a>00763     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      prev;
+<a name="l00764"></a>00764     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      next;
+<a name="l00765"></a>00765 
+<a name="l00766"></a>00766 <span class="keyword">private</span>:
+<a name="l00767"></a>00767     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; );              <span class="comment">// not implemented.</span>
+<a name="l00768"></a>00768     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base );    <span class="comment">// not allowed.</span>
+<a name="l00769"></a>00769 };
+<a name="l00770"></a>00770 
+<a name="l00771"></a>00771 
+<a name="l00779"></a><a class="code" href="classTiXmlAttribute.html">00779</a> <span class="keyword">class </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>
+<a name="l00780"></a>00780 {
+<a name="l00781"></a>00781     <span class="keyword">friend</span> <span class="keyword">class </span>TiXmlAttributeSet;
+<a name="l00782"></a>00782 
+<a name="l00783"></a>00783 <span class="keyword">public</span>:
+<a name="l00785"></a><a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">00785</a>     <a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1" title="Construct an empty attribute.">TiXmlAttribute</a>() : <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>()
+<a name="l00786"></a>00786     {
+<a name="l00787"></a>00787         document = 0;
+<a name="l00788"></a>00788         prev = next = 0;
+<a name="l00789"></a>00789     }
+<a name="l00790"></a>00790 
+<a name="l00791"></a>00791 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00793"></a><a class="code" href="classTiXmlAttribute.html#a052213522caac3979960e0714063861d">00793</a> <span class="preprocessor">    TiXmlAttribute( const std::string&amp; _name, const std::string&amp; _value )</span>
+<a name="l00794"></a>00794 <span class="preprocessor"></span>    {
+<a name="l00795"></a>00795         name = _name;
+<a name="l00796"></a>00796         value = _value;
+<a name="l00797"></a>00797         document = 0;
+<a name="l00798"></a>00798         prev = next = 0;
+<a name="l00799"></a>00799     }
+<a name="l00800"></a>00800 <span class="preprocessor">    #endif</span>
+<a name="l00801"></a>00801 <span class="preprocessor"></span>
+<a name="l00803"></a><a class="code" href="classTiXmlAttribute.html#a759d0b76fb8fcf765ecab243bc14f05e">00803</a>     <a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1" title="Construct an empty attribute.">TiXmlAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _name, <span class="keyword">const</span> <span class="keywordtype">char</span> * _value )
+<a name="l00804"></a>00804     {
+<a name="l00805"></a>00805         name = _name;
+<a name="l00806"></a>00806         value = _value;
+<a name="l00807"></a>00807         document = 0;
+<a name="l00808"></a>00808         prev = next = 0;
+<a name="l00809"></a>00809     }
+<a name="l00810"></a>00810 
+<a name="l00811"></a><a class="code" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">00811</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d" title="Return the name of this attribute.">Name</a>()<span class="keyword">  const       </span>{ <span class="keywordflow">return</span> name.c_str(); }        
+<a name="l00812"></a><a class="code" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">00812</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3" title="Return the value of this attribute.">Value</a>()<span class="keyword"> const       </span>{ <span class="keywordflow">return</span> value.c_str(); }       
+<a name="l00813"></a>00813 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00814"></a><a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">00814</a> <span class="preprocessor"></span>    <span class="keyword">const</span> std::string&amp; <a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33" title="Return the value of this attribute.">ValueStr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }               
+<a name="l00815"></a>00815 <span class="preprocessor">    #endif</span>
+<a name="l00816"></a>00816 <span class="preprocessor"></span>    <span class="keywordtype">int</span>             <a class="code" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f" title="Return the value of this attribute, converted to an integer.">IntValue</a>() <span class="keyword">const</span>;                                   
+<a name="l00817"></a>00817     <span class="keywordtype">double</span>          <a class="code" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230" title="Return the value of this attribute, converted to a double.">DoubleValue</a>() <span class="keyword">const</span>;                                
+<a name="l00818"></a>00818 
+<a name="l00819"></a>00819     <span class="comment">// Get the tinyxml string representation</span>
+<a name="l00820"></a>00820     <span class="keyword">const</span> TIXML_STRING&amp; NameTStr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name; }
+<a name="l00821"></a>00821 
+<a name="l00831"></a>00831     <span class="keywordtype">int</span> <a class="code" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344" title="QueryIntValue examines the value string.">QueryIntValue</a>( <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l00833"></a>00833     <span class="keywordtype">int</span> <a class="code" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513" title="QueryDoubleValue examines the value string. See QueryIntValue().">QueryDoubleValue</a>( <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l00834"></a>00834 
+<a name="l00835"></a><a class="code" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">00835</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99" title="Set the name of this attribute.">SetName</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name )   { name = _name; }               
+<a name="l00836"></a><a class="code" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">00836</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0" title="Set the value.">SetValue</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _value ) { value = _value; }             
+<a name="l00837"></a>00837 
+<a name="l00838"></a>00838     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8" title="Set the value from an integer.">SetIntValue</a>( <span class="keywordtype">int</span> _value );                                     
+<a name="l00839"></a>00839     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394" title="Set the value from a double.">SetDoubleValue</a>( <span class="keywordtype">double</span> _value );                               
+<a name="l00840"></a>00840 
+<a name="l00841"></a>00841 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00843"></a><a class="code" href="classTiXmlAttribute.html#ab296ff0c9a8c701055cd257a8a976e57">00843</a> <span class="preprocessor">    void SetName( const std::string&amp; _name )    { name = _name; }   </span>
+<a name="l00845"></a><a class="code" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">00845</a> <span class="preprocessor">    void SetValue( const std::string&amp; _value )  { value = _value; }</span>
+<a name="l00846"></a>00846 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00847"></a>00847 <span class="preprocessor"></span>
+<a name="l00849"></a>00849     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67" title="Get the next sibling attribute in the DOM. Returns null at end.">Next</a>() <span class="keyword">const</span>;
+<a name="l00850"></a>00850     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67" title="Get the next sibling attribute in the DOM. Returns null at end.">Next</a>() {
+<a name="l00851"></a>00851         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;Next() ); 
+<a name="l00852"></a>00852     }
+<a name="l00853"></a>00853 
+<a name="l00855"></a>00855     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf" title="Get the previous sibling attribute in the DOM. Returns null at beginning.">Previous</a>() <span class="keyword">const</span>;
+<a name="l00856"></a>00856     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf" title="Get the previous sibling attribute in the DOM. Returns null at beginning.">Previous</a>() {
+<a name="l00857"></a>00857         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;Previous() ); 
+<a name="l00858"></a>00858     }
+<a name="l00859"></a>00859 
+<a name="l00860"></a>00860     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; rhs )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rhs.name == name; }
+<a name="l00861"></a>00861     <span class="keywordtype">bool</span> operator&lt;( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; rhs )<span class="keyword">  const </span>{ <span class="keywordflow">return</span> name &lt; rhs.name; }
+<a name="l00862"></a>00862     <span class="keywordtype">bool</span> operator&gt;( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; rhs )<span class="keyword">  const </span>{ <span class="keywordflow">return</span> name &gt; rhs.name; }
+<a name="l00863"></a>00863 
+<a name="l00864"></a>00864     <span class="comment">/*  Attribute parsing starts: first letter of the name</span>
+<a name="l00865"></a>00865 <span class="comment">                         returns: the next char after the value end quote</span>
+<a name="l00866"></a>00866 <span class="comment">    */</span>
+<a name="l00867"></a>00867     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l00868"></a>00868 
+<a name="l00869"></a>00869     <span class="comment">// Prints this Attribute to a FILE stream.</span>
+<a name="l00870"></a><a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">00870</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth )<span class="keyword"> const </span>{
+<a name="l00871"></a>00871         <a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( cfile, depth, 0 );
+<a name="l00872"></a>00872     }
+<a name="l00873"></a>00873     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth, TIXML_STRING* str ) <span class="keyword">const</span>;
+<a name="l00874"></a>00874 
+<a name="l00875"></a>00875     <span class="comment">// [internal use]</span>
+<a name="l00876"></a>00876     <span class="comment">// Set the document pointer so the attribute can report errors.</span>
+<a name="l00877"></a>00877     <span class="keywordtype">void</span> SetDocument( <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* doc )  { document = doc; }
+<a name="l00878"></a>00878 
+<a name="l00879"></a>00879 <span class="keyword">private</span>:
+<a name="l00880"></a>00880     <a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1" title="Construct an empty attribute.">TiXmlAttribute</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; );                <span class="comment">// not implemented.</span>
+<a name="l00881"></a>00881     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; base );   <span class="comment">// not allowed.</span>
+<a name="l00882"></a>00882 
+<a name="l00883"></a>00883     <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*  document;   <span class="comment">// A pointer back to a document, for error reporting.</span>
+<a name="l00884"></a>00884     TIXML_STRING name;
+<a name="l00885"></a>00885     TIXML_STRING value;
+<a name="l00886"></a>00886     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* prev;
+<a name="l00887"></a>00887     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* next;
+<a name="l00888"></a>00888 };
+<a name="l00889"></a>00889 
+<a name="l00890"></a>00890 
+<a name="l00891"></a>00891 <span class="comment">/*  A class used to manage a group of attributes.</span>
+<a name="l00892"></a>00892 <span class="comment">    It is only used internally, both by the ELEMENT and the DECLARATION.</span>
+<a name="l00893"></a>00893 <span class="comment">    </span>
+<a name="l00894"></a>00894 <span class="comment">    The set can be changed transparent to the Element and Declaration</span>
+<a name="l00895"></a>00895 <span class="comment">    classes that use it, but NOT transparent to the Attribute</span>
+<a name="l00896"></a>00896 <span class="comment">    which has to implement a next() and previous() method. Which makes</span>
+<a name="l00897"></a>00897 <span class="comment">    it a bit problematic and prevents the use of STL.</span>
+<a name="l00898"></a>00898 <span class="comment"></span>
+<a name="l00899"></a>00899 <span class="comment">    This version is implemented with circular lists because:</span>
+<a name="l00900"></a>00900 <span class="comment">        - I like circular lists</span>
+<a name="l00901"></a>00901 <span class="comment">        - it demonstrates some independence from the (typical) doubly linked list.</span>
+<a name="l00902"></a>00902 <span class="comment">*/</span>
+<a name="l00903"></a>00903 <span class="keyword">class </span>TiXmlAttributeSet
+<a name="l00904"></a>00904 {
+<a name="l00905"></a>00905 <span class="keyword">public</span>:
+<a name="l00906"></a>00906     TiXmlAttributeSet();
+<a name="l00907"></a>00907     ~TiXmlAttributeSet();
+<a name="l00908"></a>00908 
+<a name="l00909"></a>00909     <span class="keywordtype">void</span> Add( <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* attribute );
+<a name="l00910"></a>00910     <span class="keywordtype">void</span> Remove( <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* attribute );
+<a name="l00911"></a>00911 
+<a name="l00912"></a>00912     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* First()<span class="keyword">   const   </span>{ <span class="keywordflow">return</span> ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
+<a name="l00913"></a>00913     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* First()                 { <span class="keywordflow">return</span> ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
+<a name="l00914"></a>00914     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Last()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
+<a name="l00915"></a>00915     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Last()                  { <span class="keywordflow">return</span> ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
+<a name="l00916"></a>00916 
+<a name="l00917"></a>00917     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Find( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name ) <span class="keyword">const</span>;
+<a name="l00918"></a>00918     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* FindOrCreate( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name );
+<a name="l00919"></a>00919 
+<a name="l00920"></a>00920 <span class="preprocessor">#   ifdef TIXML_USE_STL</span>
+<a name="l00921"></a>00921 <span class="preprocessor"></span>    <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Find( <span class="keyword">const</span> std::string&amp; _name ) <span class="keyword">const</span>;
+<a name="l00922"></a>00922     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* FindOrCreate( <span class="keyword">const</span> std::string&amp; _name );
+<a name="l00923"></a>00923 <span class="preprocessor">#   endif</span>
+<a name="l00924"></a>00924 <span class="preprocessor"></span>
+<a name="l00925"></a>00925 
+<a name="l00926"></a>00926 <span class="keyword">private</span>:
+<a name="l00927"></a>00927     <span class="comment">//*ME:  Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),</span>
+<a name="l00928"></a>00928     <span class="comment">//*ME:  this class must be also use a hidden/disabled copy-constructor !!!</span>
+<a name="l00929"></a>00929     TiXmlAttributeSet( <span class="keyword">const</span> TiXmlAttributeSet&amp; );  <span class="comment">// not allowed</span>
+<a name="l00930"></a>00930     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> TiXmlAttributeSet&amp; ); <span class="comment">// not allowed (as TiXmlAttribute)</span>
+<a name="l00931"></a>00931 
+<a name="l00932"></a>00932     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a> sentinel;
+<a name="l00933"></a>00933 };
+<a name="l00934"></a>00934 
+<a name="l00935"></a>00935 
+<a name="l00940"></a><a class="code" href="classTiXmlElement.html">00940</a> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l00941"></a>00941 {
+<a name="l00942"></a>00942 <span class="keyword">public</span>:
+<a name="l00944"></a>00944     <a class="code" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60" title="Construct an element.">TiXmlElement</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> * in_value);
+<a name="l00945"></a>00945 
+<a name="l00946"></a>00946 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00948"></a>00948 <span class="preprocessor">    TiXmlElement( const std::string&amp; _value );</span>
+<a name="l00949"></a>00949 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00950"></a>00950 <span class="preprocessor"></span>
+<a name="l00951"></a>00951     <a class="code" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60" title="Construct an element.">TiXmlElement</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; );
+<a name="l00952"></a>00952 
+<a name="l00953"></a>00953     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; base );
+<a name="l00954"></a>00954 
+<a name="l00955"></a>00955     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>();
+<a name="l00956"></a>00956 
+<a name="l00960"></a>00960     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name ) <span class="keyword">const</span>;
+<a name="l00961"></a>00961 
+<a name="l00968"></a>00968     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span>* i ) <span class="keyword">const</span>;
+<a name="l00969"></a>00969 
+<a name="l00976"></a>00976     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">double</span>* d ) <span class="keyword">const</span>;
+<a name="l00977"></a>00977 
+<a name="l00985"></a>00985     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l00987"></a>00987     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7" title="QueryDoubleAttribute examines the attribute - see QueryIntAttribute().">QueryDoubleAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l00989"></a><a class="code" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">00989</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be" title="QueryFloatAttribute examines the attribute - see QueryIntAttribute().">QueryFloatAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">float</span>* _value )<span class="keyword"> const </span>{
+<a name="l00990"></a>00990         <span class="keywordtype">double</span> d;
+<a name="l00991"></a>00991         <span class="keywordtype">int</span> result = <a class="code" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7" title="QueryDoubleAttribute examines the attribute - see QueryIntAttribute().">QueryDoubleAttribute</a>( name, &amp;d );
+<a name="l00992"></a>00992         <span class="keywordflow">if</span> ( result == TIXML_SUCCESS ) {
+<a name="l00993"></a>00993             *_value = (float)d;
+<a name="l00994"></a>00994         }
+<a name="l00995"></a>00995         <span class="keywordflow">return</span> result;
+<a name="l00996"></a>00996     }
+<a name="l00997"></a>00997 
+<a name="l00998"></a>00998 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01000"></a><a class="code" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">01000</a> <span class="preprocessor">    int QueryStringAttribute( const char* name, std::string* _value ) const {</span>
+<a name="l01001"></a>01001 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">char</span>* cstr = <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( name );
+<a name="l01002"></a>01002         <span class="keywordflow">if</span> ( cstr ) {
+<a name="l01003"></a>01003             *_value = std::string( cstr );
+<a name="l01004"></a>01004             <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01005"></a>01005         }
+<a name="l01006"></a>01006         <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01007"></a>01007     }
+<a name="l01008"></a>01008 
+<a name="l01017"></a><a class="code" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">01017</a>     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt; <span class="keywordtype">int</span> QueryValueAttribute( <span class="keyword">const</span> std::string&amp; name, T* outValue )<span class="keyword"> const</span>
+<a name="l01018"></a>01018 <span class="keyword">    </span>{
+<a name="l01019"></a>01019         <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* node = attributeSet.Find( name );
+<a name="l01020"></a>01020         <span class="keywordflow">if</span> ( !node )
+<a name="l01021"></a>01021             <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01022"></a>01022 
+<a name="l01023"></a>01023         std::stringstream sstream( node-&gt;<a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33" title="Return the value of this attribute.">ValueStr</a>() );
+<a name="l01024"></a>01024         sstream &gt;&gt; *outValue;
+<a name="l01025"></a>01025         <span class="keywordflow">if</span> ( !sstream.fail() )
+<a name="l01026"></a>01026             <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01027"></a>01027         <span class="keywordflow">return</span> TIXML_WRONG_TYPE;
+<a name="l01028"></a>01028     }
+<a name="l01029"></a>01029 
+<a name="l01030"></a>01030     <span class="keywordtype">int</span> QueryValueAttribute( <span class="keyword">const</span> std::string&amp; name, std::string* outValue )<span class="keyword"> const</span>
+<a name="l01031"></a>01031 <span class="keyword">    </span>{
+<a name="l01032"></a>01032         <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* node = attributeSet.Find( name );
+<a name="l01033"></a>01033         <span class="keywordflow">if</span> ( !node )
+<a name="l01034"></a>01034             <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01035"></a>01035         *outValue = node-&gt;<a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33" title="Return the value of this attribute.">ValueStr</a>();
+<a name="l01036"></a>01036         <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01037"></a>01037     }
+<a name="l01038"></a>01038 <span class="preprocessor">    #endif</span>
+<a name="l01039"></a>01039 <span class="preprocessor"></span>
+<a name="l01043"></a>01043     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> <span class="keywordtype">char</span> * _value );
+<a name="l01044"></a>01044 
+<a name="l01045"></a>01045 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01046"></a>01046 <span class="preprocessor"></span>    <span class="keyword">const</span> std::string* Attribute( <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>;
+<a name="l01047"></a>01047     <span class="keyword">const</span> std::string* Attribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span>* i ) <span class="keyword">const</span>;
+<a name="l01048"></a>01048     <span class="keyword">const</span> std::string* Attribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span>* d ) <span class="keyword">const</span>;
+<a name="l01049"></a>01049     <span class="keywordtype">int</span> QueryIntAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l01050"></a>01050     <span class="keywordtype">int</span> QueryDoubleAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l01051"></a>01051 
+<a name="l01053"></a>01053     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; _value );
+<a name="l01055"></a>01055     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span> _value );
+<a name="l01057"></a>01057     <span class="keywordtype">void</span> SetDoubleAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span> value );
+<a name="l01058"></a>01058 <span class="preprocessor">    #endif</span>
+<a name="l01059"></a>01059 <span class="preprocessor"></span>
+<a name="l01063"></a>01063     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">int</span> value );
+<a name="l01064"></a>01064 
+<a name="l01068"></a>01068     <span class="keywordtype">void</span> SetDoubleAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">double</span> value );
+<a name="l01069"></a>01069 
+<a name="l01072"></a>01072     <span class="keywordtype">void</span> RemoveAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span> * name );
+<a name="l01073"></a>01073 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01074"></a><a class="code" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a">01074</a> <span class="preprocessor"></span>    <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a" title="STL std::string form.">RemoveAttribute</a>( <span class="keyword">const</span> std::string&amp; name ) {   <a class="code" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a" title="STL std::string form.">RemoveAttribute</a> (name.c_str ());    }   
+<a name="l01075"></a>01075 <span class="preprocessor">    #endif</span>
+<a name="l01076"></a>01076 <span class="preprocessor"></span>
+<a name="l01077"></a><a class="code" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">01077</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592" title="Access the first attribute in this element.">FirstAttribute</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> attributeSet.First(); }        
+<a name="l01078"></a>01078     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* FirstAttribute()                { <span class="keywordflow">return</span> attributeSet.First(); }
+<a name="l01079"></a><a class="code" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">01079</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381" title="Access the last attribute in this element.">LastAttribute</a>()<span class="keyword">   const   </span>{ <span class="keywordflow">return</span> attributeSet.Last(); }     
+<a name="l01080"></a>01080     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* LastAttribute()                 { <span class="keywordflow">return</span> attributeSet.Last(); }
+<a name="l01081"></a>01081 
+<a name="l01114"></a>01114     <span class="keyword">const</span> <span class="keywordtype">char</span>* GetText() <span class="keyword">const</span>;
+<a name="l01115"></a>01115 
+<a name="l01117"></a>01117     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* Clone() <span class="keyword">const</span>;
+<a name="l01118"></a>01118     <span class="comment">// Print the Element to a FILE stream.</span>
+<a name="l01119"></a>01119     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Print( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01120"></a>01120 
+<a name="l01121"></a>01121     <span class="comment">/*  Attribtue parsing starts: next char past &#39;&lt;&#39;</span>
+<a name="l01122"></a>01122 <span class="comment">                         returns: next char past &#39;&gt;&#39;</span>
+<a name="l01123"></a>01123 <span class="comment">    */</span>
+<a name="l01124"></a>01124     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01125"></a>01125 
+<a name="l01126"></a><a class="code" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">01126</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*     <a class="code" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c" title="Cast to a more defined type. Will return null not of the requested type.">ToElement</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01127"></a><a class="code" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a">01127</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*           <a class="code" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a" title="Cast to a more defined type. Will return null not of the requested type.">ToElement</a>()           { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01128"></a>01128 
+<a name="l01131"></a>01131     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Accept( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01132"></a>01132 
+<a name="l01133"></a>01133 <span class="keyword">protected</span>:
+<a name="l01134"></a>01134 
+<a name="l01135"></a>01135     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* target ) <span class="keyword">const</span>;
+<a name="l01136"></a>01136     <span class="keywordtype">void</span> ClearThis();   <span class="comment">// like clear, but initializes &#39;this&#39; object as well</span>
+<a name="l01137"></a>01137 
+<a name="l01138"></a>01138     <span class="comment">// Used to be public [internal use]</span>
+<a name="l01139"></a>01139 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01140"></a>01140 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01141"></a>01141 <span class="preprocessor">    #endif</span>
+<a name="l01142"></a>01142 <span class="preprocessor"></span>    <span class="comment">/*  [internal use]</span>
+<a name="l01143"></a>01143 <span class="comment">        Reads the &quot;value&quot; of the element -- another element, or text.</span>
+<a name="l01144"></a>01144 <span class="comment">        This should terminate with the current end tag.</span>
+<a name="l01145"></a>01145 <span class="comment">    */</span>
+<a name="l01146"></a>01146     <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadValue( <span class="keyword">const</span> <span class="keywordtype">char</span>* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+<a name="l01147"></a>01147 
+<a name="l01148"></a>01148 <span class="keyword">private</span>:
+<a name="l01149"></a>01149     TiXmlAttributeSet attributeSet;
+<a name="l01150"></a>01150 };
+<a name="l01151"></a>01151 
+<a name="l01152"></a>01152 
+<a name="l01155"></a><a class="code" href="classTiXmlComment.html">01155</a> <span class="keyword">class </span><a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01156"></a>01156 {
+<a name="l01157"></a>01157 <span class="keyword">public</span>:
+<a name="l01159"></a><a class="code" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">01159</a>     <a class="code" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7" title="Constructs an empty comment.">TiXmlComment</a>() : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_COMMENT ) {}
+<a name="l01161"></a><a class="code" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47">01161</a>     <a class="code" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47" title="Construct a comment from text.">TiXmlComment</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _value ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_COMMENT ) {
+<a name="l01162"></a>01162         <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>( _value );
+<a name="l01163"></a>01163     }
+<a name="l01164"></a>01164     <a class="code" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7" title="Constructs an empty comment.">TiXmlComment</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; );
+<a name="l01165"></a>01165     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; base );
+<a name="l01166"></a>01166 
+<a name="l01167"></a>01167     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>() {}
+<a name="l01168"></a>01168 
+<a name="l01170"></a>01170     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028" title="Returns a copy of this Comment.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01171"></a>01171     <span class="comment">// Write this Comment to a FILE stream.</span>
+<a name="l01172"></a>01172     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01173"></a>01173 
+<a name="l01174"></a>01174     <span class="comment">/*  Attribtue parsing starts: at the ! of the !--</span>
+<a name="l01175"></a>01175 <span class="comment">                         returns: next char past &#39;&gt;&#39;</span>
+<a name="l01176"></a>01176 <span class="comment">    */</span>
+<a name="l01177"></a>01177     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01178"></a>01178 
+<a name="l01179"></a><a class="code" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">01179</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*  <a class="code" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0" title="Cast to a more defined type. Will return null not of the requested type.">ToComment</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01180"></a><a class="code" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df">01180</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*  <a class="code" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df" title="Cast to a more defined type. Will return null not of the requested type.">ToComment</a>() { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01181"></a>01181 
+<a name="l01184"></a>01184     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01185"></a>01185 
+<a name="l01186"></a>01186 <span class="keyword">protected</span>:
+<a name="l01187"></a>01187     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>* target ) <span class="keyword">const</span>;
+<a name="l01188"></a>01188 
+<a name="l01189"></a>01189     <span class="comment">// used to be public</span>
+<a name="l01190"></a>01190 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01191"></a>01191 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01192"></a>01192 <span class="preprocessor">    #endif</span>
+<a name="l01193"></a>01193 <span class="preprocessor"></span><span class="comment">//  virtual void StreamOut( TIXML_OSTREAM * out ) const;</span>
+<a name="l01194"></a>01194 
+<a name="l01195"></a>01195 <span class="keyword">private</span>:
+<a name="l01196"></a>01196 
+<a name="l01197"></a>01197 };
+<a name="l01198"></a>01198 
+<a name="l01199"></a>01199 
+<a name="l01205"></a><a class="code" href="classTiXmlText.html">01205</a> <span class="keyword">class </span><a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01206"></a>01206 {
+<a name="l01207"></a>01207     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l01208"></a>01208 <span class="keyword">public</span>:
+<a name="l01213"></a><a class="code" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">01213</a>     <a class="code" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960" title="Constructor for text element.">TiXmlText</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> * initValue ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a> (<a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_TEXT)
+<a name="l01214"></a>01214     {
+<a name="l01215"></a>01215         <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>( initValue );
+<a name="l01216"></a>01216         cdata = <span class="keyword">false</span>;
+<a name="l01217"></a>01217     }
+<a name="l01218"></a>01218     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>() {}
+<a name="l01219"></a>01219 
+<a name="l01220"></a>01220 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01222"></a><a class="code" href="classTiXmlText.html#a439792f6183a3d3fb6f2bc2b16fa5691">01222</a> <span class="preprocessor">    TiXmlText( const std::string&amp; initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)</span>
+<a name="l01223"></a>01223 <span class="preprocessor"></span>    {
+<a name="l01224"></a>01224         <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>( initValue );
+<a name="l01225"></a>01225         cdata = <span class="keyword">false</span>;
+<a name="l01226"></a>01226     }
+<a name="l01227"></a>01227 <span class="preprocessor">    #endif</span>
+<a name="l01228"></a>01228 <span class="preprocessor"></span>
+<a name="l01229"></a>01229     <a class="code" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960" title="Constructor for text element.">TiXmlText</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; copy ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_TEXT )   { copy.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01230"></a>01230     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; base )                             { base.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01231"></a>01231 
+<a name="l01232"></a>01232     <span class="comment">// Write this text object to a FILE stream.</span>
+<a name="l01233"></a>01233     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01234"></a>01234 
+<a name="l01236"></a><a class="code" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">01236</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586" title="Queries whether this represents text using a CDATA section.">CDATA</a>()<span class="keyword"> const              </span>{ <span class="keywordflow">return</span> cdata; }
+<a name="l01238"></a><a class="code" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">01238</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9" title="Turns on or off a CDATA representation of text.">SetCDATA</a>( <span class="keywordtype">bool</span> _cdata )    { cdata = _cdata; }
+<a name="l01239"></a>01239 
+<a name="l01240"></a>01240     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01241"></a>01241 
+<a name="l01242"></a><a class="code" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">01242</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* <a class="code" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648" title="Cast to a more defined type. Will return null not of the requested type.">ToText</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01243"></a><a class="code" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">01243</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>*       <a class="code" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b" title="Cast to a more defined type. Will return null not of the requested type.">ToText</a>()       { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01244"></a>01244 
+<a name="l01247"></a>01247     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01248"></a>01248 
+<a name="l01249"></a>01249 <span class="keyword">protected</span> :
+<a name="l01251"></a>01251     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b" title="[internal use] Creates a new Element and returns it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01252"></a>01252     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* target ) <span class="keyword">const</span>;
+<a name="l01253"></a>01253 
+<a name="l01254"></a>01254     <span class="keywordtype">bool</span> Blank() <span class="keyword">const</span>; <span class="comment">// returns true if all white space and new lines</span>
+<a name="l01255"></a>01255     <span class="comment">// [internal use]</span>
+<a name="l01256"></a>01256 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01257"></a>01257 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01258"></a>01258 <span class="preprocessor">    #endif</span>
+<a name="l01259"></a>01259 <span class="preprocessor"></span>
+<a name="l01260"></a>01260 <span class="keyword">private</span>:
+<a name="l01261"></a>01261     <span class="keywordtype">bool</span> cdata;         <span class="comment">// true if this should be input and output as a CDATA style text element</span>
+<a name="l01262"></a>01262 };
+<a name="l01263"></a>01263 
+<a name="l01264"></a>01264 
+<a name="l01278"></a><a class="code" href="classTiXmlDeclaration.html">01278</a> <span class="keyword">class </span><a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01279"></a>01279 {
+<a name="l01280"></a>01280 <span class="keyword">public</span>:
+<a name="l01282"></a><a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79">01282</a>     <a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79" title="Construct an empty declaration.">TiXmlDeclaration</a>()   : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_DECLARATION ) {}
+<a name="l01283"></a>01283 
+<a name="l01284"></a>01284 <span class="preprocessor">#ifdef TIXML_USE_STL</span>
+<a name="l01286"></a>01286 <span class="preprocessor">    TiXmlDeclaration(   const std::string&amp; _version,</span>
+<a name="l01287"></a>01287 <span class="preprocessor"></span>                        <span class="keyword">const</span> std::string&amp; _encoding,
+<a name="l01288"></a>01288                         <span class="keyword">const</span> std::string&amp; _standalone );
+<a name="l01289"></a>01289 <span class="preprocessor">#endif</span>
+<a name="l01290"></a>01290 <span class="preprocessor"></span>
+<a name="l01292"></a>01292     <a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79" title="Construct an empty declaration.">TiXmlDeclaration</a>(   <span class="keyword">const</span> <span class="keywordtype">char</span>* _version,
+<a name="l01293"></a>01293                         <span class="keyword">const</span> <span class="keywordtype">char</span>* _encoding,
+<a name="l01294"></a>01294                         <span class="keyword">const</span> <span class="keywordtype">char</span>* _standalone );
+<a name="l01295"></a>01295 
+<a name="l01296"></a>01296     <a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79" title="Construct an empty declaration.">TiXmlDeclaration</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; copy );
+<a name="l01297"></a>01297     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; copy );
+<a name="l01298"></a>01298 
+<a name="l01299"></a>01299     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>() {}
+<a name="l01300"></a>01300 
+<a name="l01302"></a><a class="code" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">01302</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76" title="Version. Will return an empty string if none was found.">Version</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> version.c_str (); }
+<a name="l01304"></a><a class="code" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">01304</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76" title="Encoding. Will return an empty string if none was found.">Encoding</a>()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> encoding.c_str (); }
+<a name="l01306"></a><a class="code" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">01306</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9" title="Is this a standalone document?">Standalone</a>()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> standalone.c_str (); }
+<a name="l01307"></a>01307 
+<a name="l01309"></a>01309     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e" title="Creates a copy of this Declaration and returns it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01310"></a>01310     <span class="comment">// Print this declaration to a FILE stream.</span>
+<a name="l01311"></a>01311     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Print( FILE* cfile, <span class="keywordtype">int</span> depth, TIXML_STRING* str ) <span class="keyword">const</span>;
+<a name="l01312"></a><a class="code" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">01312</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth )<span class="keyword"> const </span>{
+<a name="l01313"></a>01313         Print( cfile, depth, 0 );
+<a name="l01314"></a>01314     }
+<a name="l01315"></a>01315 
+<a name="l01316"></a>01316     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01317"></a>01317 
+<a name="l01318"></a><a class="code" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">01318</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>* <a class="code" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967" title="Cast to a more defined type. Will return null not of the requested type.">ToDeclaration</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01319"></a><a class="code" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce">01319</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>*       <a class="code" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce" title="Cast to a more defined type. Will return null not of the requested type.">ToDeclaration</a>()       { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01320"></a>01320 
+<a name="l01323"></a>01323     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01324"></a>01324 
+<a name="l01325"></a>01325 <span class="keyword">protected</span>:
+<a name="l01326"></a>01326     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>* target ) <span class="keyword">const</span>;
+<a name="l01327"></a>01327     <span class="comment">// used to be public</span>
+<a name="l01328"></a>01328 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01329"></a>01329 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01330"></a>01330 <span class="preprocessor">    #endif</span>
+<a name="l01331"></a>01331 <span class="preprocessor"></span>
+<a name="l01332"></a>01332 <span class="keyword">private</span>:
+<a name="l01333"></a>01333 
+<a name="l01334"></a>01334     TIXML_STRING version;
+<a name="l01335"></a>01335     TIXML_STRING encoding;
+<a name="l01336"></a>01336     TIXML_STRING standalone;
+<a name="l01337"></a>01337 };
+<a name="l01338"></a>01338 
+<a name="l01339"></a>01339 
+<a name="l01347"></a><a class="code" href="classTiXmlUnknown.html">01347</a> <span class="keyword">class </span><a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01348"></a>01348 {
+<a name="l01349"></a>01349 <span class="keyword">public</span>:
+<a name="l01350"></a>01350     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>() : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( TiXmlNode::TINYXML_UNKNOWN )    {}
+<a name="l01351"></a>01351     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>() {}
+<a name="l01352"></a>01352 
+<a name="l01353"></a>01353     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; copy ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( TiXmlNode::TINYXML_UNKNOWN )      { copy.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01354"></a>01354     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; copy )                                      { copy.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01355"></a>01355 
+<a name="l01357"></a>01357     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73" title="Creates a copy of this Unknown and returns it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01358"></a>01358     <span class="comment">// Print this Unknown to a FILE stream.</span>
+<a name="l01359"></a>01359     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01360"></a>01360 
+<a name="l01361"></a>01361     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01362"></a>01362 
+<a name="l01363"></a><a class="code" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">01363</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*     <a class="code" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d" title="Cast to a more defined type. Will return null not of the requested type.">ToUnknown</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01364"></a><a class="code" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c">01364</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*           <a class="code" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c" title="Cast to a more defined type. Will return null not of the requested type.">ToUnknown</a>()     { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01365"></a>01365 
+<a name="l01368"></a>01368     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01369"></a>01369 
+<a name="l01370"></a>01370 <span class="keyword">protected</span>:
+<a name="l01371"></a>01371     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>* target ) <span class="keyword">const</span>;
+<a name="l01372"></a>01372 
+<a name="l01373"></a>01373 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01374"></a>01374 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01375"></a>01375 <span class="preprocessor">    #endif</span>
+<a name="l01376"></a>01376 <span class="preprocessor"></span>
+<a name="l01377"></a>01377 <span class="keyword">private</span>:
+<a name="l01378"></a>01378 
+<a name="l01379"></a>01379 };
+<a name="l01380"></a>01380 
+<a name="l01381"></a>01381 
+<a name="l01386"></a><a class="code" href="classTiXmlDocument.html">01386</a> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01387"></a>01387 {
+<a name="l01388"></a>01388 <span class="keyword">public</span>:
+<a name="l01390"></a>01390     <a class="code" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c" title="Create an empty document, that has no name.">TiXmlDocument</a>();
+<a name="l01392"></a>01392     <a class="code" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c" title="Create an empty document, that has no name.">TiXmlDocument</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * documentName );
+<a name="l01393"></a>01393 
+<a name="l01394"></a>01394 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01396"></a>01396 <span class="preprocessor">    TiXmlDocument( const std::string&amp; documentName );</span>
+<a name="l01397"></a>01397 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l01398"></a>01398 <span class="preprocessor"></span>
+<a name="l01399"></a>01399     <a class="code" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c" title="Create an empty document, that has no name.">TiXmlDocument</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; copy );
+<a name="l01400"></a>01400     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; copy );
+<a name="l01401"></a>01401 
+<a name="l01402"></a>01402     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>() {}
+<a name="l01403"></a>01403 
+<a name="l01408"></a>01408     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01410"></a>01410     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>() <span class="keyword">const</span>;
+<a name="l01412"></a>01412     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01414"></a>01414     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * filename ) <span class="keyword">const</span>;
+<a name="l01420"></a>01420     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01422"></a>01422     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( FILE* ) <span class="keyword">const</span>;
+<a name="l01423"></a>01423 
+<a name="l01424"></a>01424 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01425"></a><a class="code" href="classTiXmlDocument.html#a18ae6ed34fed7991ebc220862dfac884">01425</a> <span class="preprocessor"></span>    <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( <span class="keyword">const</span> std::string&amp; filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )           
+<a name="l01426"></a>01426     {
+<a name="l01427"></a>01427         <span class="keywordflow">return</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( filename.c_str(), encoding );
+<a name="l01428"></a>01428     }
+<a name="l01429"></a><a class="code" href="classTiXmlDocument.html#a3d4fae0463f3f03679ba0b7cf6f2df52">01429</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( <span class="keyword">const</span> std::string&amp; filename ) <span class="keyword">const</span>      
+<a name="l01430"></a>01430     {
+<a name="l01431"></a>01431         <span class="keywordflow">return</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( filename.c_str() );
+<a name="l01432"></a>01432     }
+<a name="l01433"></a>01433 <span class="preprocessor">    #endif</span>
+<a name="l01434"></a>01434 <span class="preprocessor"></span>
+<a name="l01439"></a>01439     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378" title="Parse the given null terminated block of xml data.">Parse</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01440"></a>01440 
+<a name="l01445"></a><a class="code" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">01445</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be" title="Get the root element -- the only top level element -- of the document.">RootElement</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>(); }
+<a name="l01446"></a>01446     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be" title="Get the root element -- the only top level element -- of the document.">RootElement</a>()                 { <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>(); }
+<a name="l01447"></a>01447 
+<a name="l01453"></a><a class="code" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">01453</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29" title="If an error occurs, Error will be set to true.">Error</a>()<span class="keyword"> const                      </span>{ <span class="keywordflow">return</span> error; }
+<a name="l01454"></a>01454 
+<a name="l01456"></a><a class="code" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">01456</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc</a>()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> errorDesc.c_str (); }
+<a name="l01457"></a>01457 
+<a name="l01461"></a><a class="code" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">01461</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f" title="Generally, you probably want the error string ( ErrorDesc() ).">ErrorId</a>()<span class="keyword">   const               </span>{ <span class="keywordflow">return</span> errorId; }
+<a name="l01462"></a>01462 
+<a name="l01470"></a><a class="code" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">01470</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> errorLocation.row+1; }
+<a name="l01471"></a><a class="code" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">01471</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> errorLocation.col+1; } 
+<a name="l01472"></a>01472 
+<a name="l01497"></a><a class="code" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">01497</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize</a>( <span class="keywordtype">int</span> _tabsize )     { tabsize = _tabsize; }
+<a name="l01498"></a>01498 
+<a name="l01499"></a>01499     <span class="keywordtype">int</span> TabSize()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tabsize; }
+<a name="l01500"></a>01500 
+<a name="l01504"></a><a class="code" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">01504</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35" title="If you have handled the error, it can be reset with this call.">ClearError</a>()                       {   error = <span class="keyword">false</span>; 
+<a name="l01505"></a>01505                                                 errorId = 0; 
+<a name="l01506"></a>01506                                                 errorDesc = <span class="stringliteral">&quot;&quot;</span>; 
+<a name="l01507"></a>01507                                                 errorLocation.row = errorLocation.col = 0; 
+<a name="l01508"></a>01508                                                 <span class="comment">//errorLocation.last = 0; </span>
+<a name="l01509"></a>01509                                             }
+<a name="l01510"></a>01510 
+<a name="l01512"></a><a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">01512</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510" title="Write the document to standard out using formatted printing (&amp;quot;pretty print&amp;quot;)...">Print</a>()<span class="keyword"> const                      </span>{ <a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510" title="Write the document to standard out using formatted printing (&amp;quot;pretty print&amp;quot;)...">Print</a>( stdout, 0 ); }
+<a name="l01513"></a>01513 
+<a name="l01514"></a>01514     <span class="comment">/* Write the document to a string using formatted printing (&quot;pretty print&quot;). This</span>
+<a name="l01515"></a>01515 <span class="comment">        will allocate a character array (new char[]) and return it as a pointer. The</span>
+<a name="l01516"></a>01516 <span class="comment">        calling code pust call delete[] on the return char* to avoid a memory leak.</span>
+<a name="l01517"></a>01517 <span class="comment">    */</span>
+<a name="l01518"></a>01518     <span class="comment">//char* PrintToMemory() const; </span>
+<a name="l01519"></a>01519 
+<a name="l01521"></a>01521     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510" title="Write the document to standard out using formatted printing (&amp;quot;pretty print&amp;quot;)...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth = 0 ) <span class="keyword">const</span>;
+<a name="l01522"></a>01522     <span class="comment">// [internal use]</span>
+<a name="l01523"></a>01523     <span class="keywordtype">void</span> SetError( <span class="keywordtype">int</span> err, <span class="keyword">const</span> <span class="keywordtype">char</span>* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+<a name="l01524"></a>01524 
+<a name="l01525"></a><a class="code" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">01525</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*    <a class="code" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4" title="Cast to a more defined type. Will return null not of the requested type.">ToDocument</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01526"></a><a class="code" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42">01526</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*          <a class="code" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42" title="Cast to a more defined type. Will return null not of the requested type.">ToDocument</a>()          { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01527"></a>01527 
+<a name="l01530"></a>01530     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01531"></a>01531 
+<a name="l01532"></a>01532 <span class="keyword">protected</span> :
+<a name="l01533"></a>01533     <span class="comment">// [internal use]</span>
+<a name="l01534"></a>01534     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907" title="Create an exact duplicate of this node and return it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01535"></a>01535 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01536"></a>01536 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01537"></a>01537 <span class="preprocessor">    #endif</span>
+<a name="l01538"></a>01538 <span class="preprocessor"></span>
+<a name="l01539"></a>01539 <span class="keyword">private</span>:
+<a name="l01540"></a>01540     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* target ) <span class="keyword">const</span>;
+<a name="l01541"></a>01541 
+<a name="l01542"></a>01542     <span class="keywordtype">bool</span> error;
+<a name="l01543"></a>01543     <span class="keywordtype">int</span>  errorId;
+<a name="l01544"></a>01544     TIXML_STRING errorDesc;
+<a name="l01545"></a>01545     <span class="keywordtype">int</span> tabsize;
+<a name="l01546"></a>01546     TiXmlCursor errorLocation;
+<a name="l01547"></a>01547     <span class="keywordtype">bool</span> useMicrosoftBOM;       <span class="comment">// the UTF-8 BOM were found when read. Note this, and try to write.</span>
+<a name="l01548"></a>01548 };
+<a name="l01549"></a>01549 
+<a name="l01550"></a>01550 
+<a name="l01631"></a><a class="code" href="classTiXmlHandle.html">01631</a> <span class="keyword">class </span><a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>
+<a name="l01632"></a>01632 {
+<a name="l01633"></a>01633 <span class="keyword">public</span>:
+<a name="l01635"></a><a class="code" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8">01635</a>     <a class="code" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8" title="Create a handle from any node (at any depth of the tree.) This can be a null pointer...">TiXmlHandle</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* _node )                 { this-&gt;node = _node; }
+<a name="l01637"></a><a class="code" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">01637</a>     <a class="code" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7" title="Copy constructor.">TiXmlHandle</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>&amp; ref )           { this-&gt;node = ref.node; }
+<a name="l01638"></a>01638     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>&amp; ref ) { this-&gt;node = ref.node; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
+<a name="l01639"></a>01639 
+<a name="l01641"></a>01641     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>() <span class="keyword">const</span>;
+<a name="l01643"></a>01643     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;
+<a name="l01645"></a>01645     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>() <span class="keyword">const</span>;
+<a name="l01647"></a>01647     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;
+<a name="l01648"></a>01648 
+<a name="l01652"></a>01652     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01656"></a>01656     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01661"></a>01661     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01666"></a>01666     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01667"></a>01667 
+<a name="l01668"></a>01668 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01669"></a>01669 <span class="preprocessor"></span>    <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const               </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>( _value.c_str() ); }
+<a name="l01670"></a>01670     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>( _value.c_str() ); }
+<a name="l01671"></a>01671 
+<a name="l01672"></a>01672     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keywordtype">int</span> index )<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( _value.c_str(), index ); }
+<a name="l01673"></a>01673     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keywordtype">int</span> index )<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( _value.c_str(), index ); }
+<a name="l01674"></a>01674 <span class="preprocessor">    #endif</span>
+<a name="l01675"></a>01675 <span class="preprocessor"></span>
+<a name="l01678"></a><a class="code" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">01678</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3" title="Return the handle as a TiXmlNode.">ToNode</a>()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> node; } 
+<a name="l01681"></a><a class="code" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">01681</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e" title="Return the handle as a TiXmlElement.">ToElement</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;ToElement() ) ? node-&gt;ToElement() : 0 ); }
+<a name="l01684"></a><a class="code" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">01684</a>     <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* <a class="code" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586" title="Return the handle as a TiXmlText.">ToText</a>()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;ToText() ) ? node-&gt;ToText() : 0 ); }
+<a name="l01687"></a><a class="code" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">01687</a>     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>* <a class="code" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674" title="Return the handle as a TiXmlUnknown.">ToUnknown</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;ToUnknown() ) ? node-&gt;ToUnknown() : 0 ); }
+<a name="l01688"></a>01688 
+<a name="l01692"></a><a class="code" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">01692</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">Node</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3" title="Return the handle as a TiXmlNode.">ToNode</a>(); } 
+<a name="l01696"></a><a class="code" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">01696</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">Element</a>()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e" title="Return the handle as a TiXmlElement.">ToElement</a>(); }
+<a name="l01700"></a><a class="code" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">01700</a>     <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* <a class="code" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">Text</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586" title="Return the handle as a TiXmlText.">ToText</a>(); }
+<a name="l01704"></a><a class="code" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">01704</a>     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>* <a class="code" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">Unknown</a>()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674" title="Return the handle as a TiXmlUnknown.">ToUnknown</a>(); }
+<a name="l01705"></a>01705 
+<a name="l01706"></a>01706 <span class="keyword">private</span>:
+<a name="l01707"></a>01707     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* node;
+<a name="l01708"></a>01708 };
+<a name="l01709"></a>01709 
+<a name="l01710"></a>01710 
+<a name="l01730"></a><a class="code" href="classTiXmlPrinter.html">01730</a> <span class="keyword">class </span><a class="code" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>
+<a name="l01731"></a>01731 {
+<a name="l01732"></a>01732 <span class="keyword">public</span>:
+<a name="l01733"></a>01733     <a class="code" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a>() : depth( 0 ), simpleTextPrint( <span class="keyword">false</span> ),
+<a name="l01734"></a>01734                      buffer(), indent( <span class="stringliteral">&quot;    &quot;</span> ), lineBreak( <span class="stringliteral">&quot;\n&quot;</span> ) {}
+<a name="l01735"></a>01735 
+<a name="l01736"></a>01736     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1" title="Visit a document.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; doc );
+<a name="l01737"></a>01737     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2" title="Visit a document.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; doc );
+<a name="l01738"></a>01738 
+<a name="l01739"></a>01739     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1" title="Visit a document.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; element, <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* firstAttribute );
+<a name="l01740"></a>01740     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2" title="Visit a document.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; element );
+<a name="l01741"></a>01741 
+<a name="l01742"></a>01742     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; declaration );
+<a name="l01743"></a>01743     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; text );
+<a name="l01744"></a>01744     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; comment );
+<a name="l01745"></a>01745     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; unknown );
+<a name="l01746"></a>01746 
+<a name="l01750"></a><a class="code" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">01750</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e" title="Set the indent characters for printing.">SetIndent</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _indent )           { indent = _indent ? _indent : <span class="stringliteral">&quot;&quot;</span> ; }
+<a name="l01752"></a><a class="code" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">01752</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d" title="Query the indention string.">Indent</a>()                            { <span class="keywordflow">return</span> indent.c_str(); }
+<a name="l01757"></a><a class="code" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">01757</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6" title="Set the line breaking string.">SetLineBreak</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _lineBreak )     { lineBreak = _lineBreak ? _lineBreak : <span class="stringliteral">&quot;&quot;</span>; }
+<a name="l01759"></a><a class="code" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">01759</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d" title="Query the current line breaking string.">LineBreak</a>()                         { <span class="keywordflow">return</span> lineBreak.c_str(); }
+<a name="l01760"></a>01760 
+<a name="l01764"></a><a class="code" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">01764</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19" title="Switch over to &amp;quot;stream printing&amp;quot; which is the most dense formatting without...">SetStreamPrinting</a>()                        { indent = <span class="stringliteral">&quot;&quot;</span>;
+<a name="l01765"></a>01765                                                       lineBreak = <span class="stringliteral">&quot;&quot;</span>;
+<a name="l01766"></a>01766                                                     }   
+<a name="l01768"></a><a class="code" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">01768</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e" title="Return the result.">CStr</a>()                              { <span class="keywordflow">return</span> buffer.c_str(); }
+<a name="l01770"></a><a class="code" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">01770</a>     <span class="keywordtype">size_t</span> <a class="code" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d" title="Return the length of the result string.">Size</a>()                                   { <span class="keywordflow">return</span> buffer.size(); }
+<a name="l01771"></a>01771 
+<a name="l01772"></a>01772 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01774"></a><a class="code" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">01774</a> <span class="preprocessor">    const std::string&amp; Str()                        { return buffer; }</span>
+<a name="l01775"></a>01775 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l01776"></a>01776 <span class="preprocessor"></span>
+<a name="l01777"></a>01777 <span class="keyword">private</span>:
+<a name="l01778"></a>01778     <span class="keywordtype">void</span> DoIndent() {
+<a name="l01779"></a>01779         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;depth; ++i )
+<a name="l01780"></a>01780             buffer += indent;
+<a name="l01781"></a>01781     }
+<a name="l01782"></a>01782     <span class="keywordtype">void</span> DoLineBreak() {
+<a name="l01783"></a>01783         buffer += lineBreak;
+<a name="l01784"></a>01784     }
+<a name="l01785"></a>01785 
+<a name="l01786"></a>01786     <span class="keywordtype">int</span> depth;
+<a name="l01787"></a>01787     <span class="keywordtype">bool</span> simpleTextPrint;
+<a name="l01788"></a>01788     TIXML_STRING buffer;
+<a name="l01789"></a>01789     TIXML_STRING indent;
+<a name="l01790"></a>01790     TIXML_STRING lineBreak;
+<a name="l01791"></a>01791 };
+<a name="l01792"></a>01792 
+<a name="l01793"></a>01793 
+<a name="l01794"></a>01794 <span class="preprocessor">#ifdef _MSC_VER</span>
+<a name="l01795"></a>01795 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( pop )</span>
+<a name="l01796"></a>01796 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l01797"></a>01797 <span class="preprocessor"></span>
+<a name="l01798"></a>01798 <span class="preprocessor">#endif</span>
+<a name="l01799"></a>01799 <span class="preprocessor"></span>
+</pre></div></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/.svn/text-base/tutorial0.html.svn-base vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tutorial0.html.svn-base
--- vdr-2.0.1/tinyxml/docs/.svn/text-base/tutorial0.html.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/.svn/text-base/tutorial0.html.svn-base	2013-05-09 18:10:01.643874321 +0200
@@ -0,0 +1,720 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TinyXML Tutorial</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="navpath"><a class="el" href="index.html">index</a>
+  </div>
+</div>
+<div class="contents">
+
+
+<h1><a class="anchor" id="tutorial0">TinyXML Tutorial </a></h1><h1>What is this? </h1>
+<p>This tutorial has a few tips and suggestions on how to use TinyXML effectively.</p>
+<p>I've also tried to include some C++ tips like how to convert strings to integers and vice versa. This isn't anything to do with TinyXML itself, but it may helpful for your project so I've put it in anyway.</p>
+<p>If you don't know basic C++ concepts this tutorial won't be useful. Likewise if you don't know what a DOM is, look elsewhere first.</p>
+<h1>Before we start </h1>
+<p>Some example XML datasets/files will be used.</p>
+<p>example1.xml:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>example2.xml:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;poetry&gt;
+	&lt;verse&gt;
+		Alas
+		  Great World
+			Alas (again)
+	&lt;/verse&gt;
+&lt;/poetry&gt;
+</pre></div><p>example3.xml:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;shapes&gt;
+	&lt;circle name="int-based" x="20" y="30" r="50" /&gt;
+	&lt;point name="float-based" x="3.5" y="52.1" /&gt;
+&lt;/shapes&gt;
+</pre></div><p>example4.xml</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;MyApp&gt;
+    &lt;!-- Settings for MyApp --&gt;
+    &lt;Messages&gt;
+        &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;
+        &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt;
+&lt;/MyApp&gt;
+</pre></div><h1>Getting Started </h1>
+<h2>Load XML from a file </h2>
+<p>The simplest way to load a file into a TinyXML DOM is:</p>
+<div class="fragment"><pre class="fragment">
+TiXmlDocument doc( "demo.xml" );
+doc.LoadFile();
+</pre></div><p>A more real-world usage is shown below. This will load the file and display the contents to STDOUT:</p>
+<div class="fragment"><pre class="fragment">
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &amp;doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+</pre></div><p>A simple demonstration of this function is to use a main like this:</p>
+<div class="fragment"><pre class="fragment">
+int main(void)
+{
+	dump_to_stdout("example1.xml");
+	return 0;
+}
+</pre></div><p>Recall that Example 1 XML is:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>Running the program with this XML will display this in the console/DOS window:</p>
+<div class="fragment"><pre class="fragment">
+DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+</pre></div><p>The ``dump_to_stdout`` function is defined later in this tutorial and is useful if you want to understand recursive traversal of a DOM.</p>
+<h2>Building Documents Programatically </h2>
+<p>This is how to build Example 1 pragmatically:</p>
+<div class="fragment"><pre class="fragment">
+void build_simple_doc( )
+{
+	// Make xml: &lt;?xml ..&gt;&lt;Hello&gt;World&lt;/Hello&gt;
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	TiXmlText * text = new TiXmlText( "World" );
+	element-&gt;LinkEndChild( text );
+	doc.LinkEndChild( decl );
+	doc.LinkEndChild( element );
+	doc.SaveFile( "madeByHand.xml" );
+}
+</pre></div><p>This can be loaded and displayed on the console with:</p>
+<div class="fragment"><pre class="fragment">
+dump_to_stdout("madeByHand.xml"); // this func defined later in the tutorial
+</pre></div><p>and you'll see it is identical to Example 1:</p>
+<div class="fragment"><pre class="fragment">
+madeByHand.xml:
+Document
++ Declaration
++ Element [Hello]
+  + Text: [World]
+</pre></div><p>This code produces exactly the same XML DOM but it shows a different ordering to node creation and linking:</p>
+<div class="fragment"><pre class="fragment">
+void write_simple_doc2( )
+{
+	// same as write_simple_doc1 but add each node
+	// as early as possible into the tree.
+
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	doc.LinkEndChild( decl );
+	
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	doc.LinkEndChild( element );
+	
+	TiXmlText * text = new TiXmlText( "World" );
+	element-&gt;LinkEndChild( text );
+	
+	doc.SaveFile( "madeByHand2.xml" );
+}
+</pre></div><p>Both of these produce the same XML, namely:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>Or in structure form:</p>
+<div class="fragment"><pre class="fragment">
+DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+</pre></div><h2>Attributes </h2>
+<p>Given an existing node, settings attributes is easy:</p>
+<div class="fragment"><pre class="fragment">
+window = new TiXmlElement( "Demo" );  
+window-&gt;SetAttribute("name", "Circle");
+window-&gt;SetAttribute("x", 5);
+window-&gt;SetAttribute("y", 15);
+window-&gt;SetDoubleAttribute("radius", 3.14159);
+</pre></div><p>You can it also work with the <a class="el" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a> objects if you want.</p>
+<p>The following code shows one way (not the only way) to get all attributes of an element, print the name and string value, and if the value can be converted to an integer or double, print that value too:</p>
+<div class="fragment"><pre class="fragment">
+// print all attributes of pElement.
+// returns the number of attributes printed
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement-&gt;FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib-&gt;Name(), pAttrib-&gt;Value());
+
+		if (pAttrib-&gt;QueryIntValue(&amp;ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib-&gt;QueryDoubleValue(&amp;dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib-&gt;Next();
+	}
+	return i;
+}
+</pre></div><h2>Writing a document to a file </h2>
+<p>Writing a pre-built DOM to a file is trivial:</p>
+<div class="fragment"><pre class="fragment">
+doc.SaveFile( saveFilename );  
+</pre></div><p>Recall, for example, example 4:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;MyApp&gt;
+    &lt;!-- Settings for MyApp --&gt;
+    &lt;Messages&gt;
+        &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;
+        &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt;
+&lt;/MyApp&gt;
+</pre></div><p>The following function builds this DOM and writes the file "appsettings.xml":</p>
+<div class="fragment"><pre class="fragment">
+void write_app_settings_doc( )  
+{  
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl );  
+ 
+	TiXmlElement * root = new TiXmlElement( "MyApp" );  
+	doc.LinkEndChild( root );  
+
+	TiXmlComment * comment = new TiXmlComment();
+	comment-&gt;SetValue(" Settings for MyApp " );  
+	root-&gt;LinkEndChild( comment );  
+ 
+	TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+	root-&gt;LinkEndChild( msgs );  
+ 
+	msg = new TiXmlElement( "Welcome" );  
+	msg-&gt;LinkEndChild( new TiXmlText( "Welcome to MyApp" ));  
+	msgs-&gt;LinkEndChild( msg );  
+ 
+	msg = new TiXmlElement( "Farewell" );  
+	msg-&gt;LinkEndChild( new TiXmlText( "Thank you for using MyApp" ));  
+	msgs-&gt;LinkEndChild( msg );  
+ 
+	TiXmlElement * windows = new TiXmlElement( "Windows" );  
+	root-&gt;LinkEndChild( windows );  
+
+	TiXmlElement * window;
+	window = new TiXmlElement( "Window" );  
+	windows-&gt;LinkEndChild( window );  
+	window-&gt;SetAttribute("name", "MainFrame");
+	window-&gt;SetAttribute("x", 5);
+	window-&gt;SetAttribute("y", 15);
+	window-&gt;SetAttribute("w", 400);
+	window-&gt;SetAttribute("h", 250);
+
+	TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+	root-&gt;LinkEndChild( cxn );  
+	cxn-&gt;SetAttribute("ip", "192.168.0.1");
+	cxn-&gt;SetDoubleAttribute("timeout", 123.456); // floating point attrib
+	
+	dump_to_stdout( &amp;doc );
+	doc.SaveFile( "appsettings.xml" );  
+} 
+</pre></div><p>The dump_to_stdout function will show this structure:</p>
+<div class="fragment"><pre class="fragment">
+Document
++ Declaration
++ Element [MyApp]
+ (No attributes)
+  + Comment: [ Settings for MyApp ]
+  + Element [Messages]
+ (No attributes)
+    + Element [Welcome]
+ (No attributes)
+      + Text: [Welcome to MyApp]
+    + Element [Farewell]
+ (No attributes)
+      + Text: [Thank you for using MyApp]
+  + Element [Windows]
+ (No attributes)
+    + Element [Window]
+      + name: value=[MainFrame]
+      + x: value=[5] int=5 d=5.0
+      + y: value=[15] int=15 d=15.0
+      + w: value=[400] int=400 d=400.0
+      + h: value=[250] int=250 d=250.0
+      5 attributes
+  + Element [Connection]
+    + ip: value=[192.168.0.1] int=192 d=192.2
+    + timeout: value=[123.456000] int=123 d=123.5
+    2 attributes
+</pre></div><p>I was surprised that TinyXml, by default, writes the XML in what other APIs call a "pretty" format - it modifies the whitespace of text of elements that contain other nodes so that writing the tree includes an indication of nesting level.</p>
+<p>I haven't looked yet to see if there is a way to turn off indenting when writing a file - its bound to be easy.</p>
+<p>[Lee: It's easy in STL mode, just use cout &lt;&lt; myDoc. Non-STL mode is always in "pretty" format. Adding a switch would be a nice feature and has been requested.]</p>
+<h1>XML to/from C++ objects </h1>
+<h2>Intro </h2>
+<p>This example assumes you're loading and saving your app settings in an XML file, e.g. something like example4.xml.</p>
+<p>There are a number of ways to do this. For example, look into the TinyBind project at <a href="http://sourceforge.net/projects/tinybind">http://sourceforge.net/projects/tinybind</a></p>
+<p>This section shows a plain-old approach to loading and saving a basic object structure using XML.</p>
+<h2>Set up your object classes </h2>
+<p>Start off with some basic classes like these:</p>
+<div class="fragment"><pre class="fragment">
+#include &lt;string&gt;
+#include &lt;map&gt;
+using namespace std;
+
+typedef std::map&lt;std::string,std::string&gt; MessageMap;
+
+// a basic window abstraction - demo purposes only
+class WindowSettings
+{
+public:
+	int x,y,w,h;
+	string name;
+
+	WindowSettings()
+		: x(0), y(0), w(100), h(100), name("Untitled")
+	{
+	}
+
+	WindowSettings(int x, int y, int w, int h, const string&amp; name)
+	{
+		this-&gt;x=x;
+		this-&gt;y=y;
+		this-&gt;w=w;
+		this-&gt;h=h;
+		this-&gt;name=name;
+	}
+};
+
+class ConnectionSettings
+{
+public:
+	string ip;
+	double timeout;
+};
+
+class AppSettings
+{
+public:
+	string m_name;
+	MessageMap m_messages;
+	list&lt;WindowSettings&gt; m_windows;
+	ConnectionSettings m_connection;
+
+	AppSettings() {}
+
+	void save(const char* pFilename);
+	void load(const char* pFilename);
+	
+	// just to show how to do it
+	void setDemoValues()
+	{
+		m_name="MyApp";
+		m_messages.clear();
+		m_messages["Welcome"]="Welcome to "+m_name;
+		m_messages["Farewell"]="Thank you for using "+m_name;
+		m_windows.clear();
+		m_windows.push_back(WindowSettings(15,15,400,250,"Main"));
+		m_connection.ip="Unknown";
+		m_connection.timeout=123.456;
+	}
+};
+</pre></div><p>This is a basic main() that shows how to create a default settings object tree, save it and load it again:</p>
+<div class="fragment"><pre class="fragment">
+int main(void)
+{
+	AppSettings settings;
+	
+	settings.save("appsettings2.xml");
+	settings.load("appsettings2.xml");
+	return 0;
+}
+</pre></div><p>The following main() shows creation, modification, saving and then loading of a settings structure:</p>
+<div class="fragment"><pre class="fragment">
+int main(void)
+{
+	// block: customise and save settings
+	{
+		AppSettings settings;
+		settings.m_name="HitchHikerApp";
+		settings.m_messages["Welcome"]="Don't Panic";
+		settings.m_messages["Farewell"]="Thanks for all the fish";
+		settings.m_windows.push_back(WindowSettings(15,25,300,250,"BookFrame"));
+		settings.m_connection.ip="192.168.0.77";
+		settings.m_connection.timeout=42.0;
+
+		settings.save("appsettings2.xml");
+	}
+	
+	// block: load settings
+	{
+		AppSettings settings;
+		settings.load("appsettings2.xml");
+		printf("%s: %s\n", settings.m_name.c_str(), 
+			settings.m_messages["Welcome"].c_str());
+		WindowSettings &amp; w=settings.m_windows.front();
+		printf("%s: Show window '%s' at %d,%d (%d x %d)\n", 
+			settings.m_name.c_str(), w.name.c_str(), w.x, w.y, w.w, w.h);
+		printf("%s: %s\n", settings.m_name.c_str(), settings.m_messages["Farewell"].c_str());
+	}
+	return 0;
+}
+</pre></div><p>When the save() and load() are completed (see below), running this main() displays on the console:</p>
+<div class="fragment"><pre class="fragment">
+HitchHikerApp: Don't Panic
+HitchHikerApp: Show window 'BookFrame' at 15,25 (300 x 100)
+HitchHikerApp: Thanks for all the fish
+</pre></div><h2>Encode C++ state as XML </h2>
+<p>There are lots of different ways to approach saving this to a file. Here's one:</p>
+<div class="fragment"><pre class="fragment">
+void AppSettings::save(const char* pFilename)
+{
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+	TiXmlComment * comment;
+	string s;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl ); 
+ 
+	TiXmlElement * root = new TiXmlElement(m_name.c_str());  
+	doc.LinkEndChild( root );  
+
+	comment = new TiXmlComment();
+	s=" Settings for "+m_name+" ";
+	comment-&gt;SetValue(s.c_str());  
+	root-&gt;LinkEndChild( comment );  
+
+	// block: messages
+	{
+		MessageMap::iterator iter;
+
+		TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+		root-&gt;LinkEndChild( msgs );  
+ 
+		for (iter=m_messages.begin(); iter != m_messages.end(); iter++)
+		{
+			const string &amp; key=(*iter).first;
+			const string &amp; value=(*iter).second;
+			msg = new TiXmlElement(key.c_str());  
+			msg-&gt;LinkEndChild( new TiXmlText(value.c_str()));  
+			msgs-&gt;LinkEndChild( msg );  
+		}
+	}
+
+	// block: windows
+	{
+		TiXmlElement * windowsNode = new TiXmlElement( "Windows" );  
+		root-&gt;LinkEndChild( windowsNode );  
+
+		list&lt;WindowSettings&gt;::iterator iter;
+
+		for (iter=m_windows.begin(); iter != m_windows.end(); iter++)
+		{
+			const WindowSettings&amp; w=*iter;
+
+			TiXmlElement * window;
+			window = new TiXmlElement( "Window" );  
+			windowsNode-&gt;LinkEndChild( window );  
+			window-&gt;SetAttribute("name", w.name.c_str());
+			window-&gt;SetAttribute("x", w.x);
+			window-&gt;SetAttribute("y", w.y);
+			window-&gt;SetAttribute("w", w.w);
+			window-&gt;SetAttribute("h", w.h);
+		}
+	}
+
+	// block: connection
+	{
+		TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+		root-&gt;LinkEndChild( cxn );  
+		cxn-&gt;SetAttribute("ip", m_connection.ip.c_str());
+		cxn-&gt;SetDoubleAttribute("timeout", m_connection.timeout); 
+	}
+
+	doc.SaveFile(pFilename);  
+}
+</pre></div><p>Running this with the modified main produces this file:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;HitchHikerApp&gt;
+    &lt;!-- Settings for HitchHikerApp --&gt;
+    &lt;Messages&gt;
+        &lt;Farewell&gt;Thanks for all the fish&lt;/Farewell&gt;
+        &lt;Welcome&gt;Don&amp;apos;t Panic&lt;/Welcome&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="BookFrame" x="15" y="25" w="300" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.77" timeout="42.000000" /&gt;
+&lt;/HitchHikerApp&gt;
+</pre></div><h2>Decoding state from XML </h2>
+<p>As with encoding objects, there are a number of approaches to decoding XML into your own C++ object structure. The following approach uses TiXmlHandles.</p>
+<div class="fragment"><pre class="fragment">
+void AppSettings::load(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	if (!doc.LoadFile()) return;
+
+	TiXmlHandle hDoc(&amp;doc);
+	TiXmlElement* pElem;
+	TiXmlHandle hRoot(0);
+
+	// block: name
+	{
+		pElem=hDoc.FirstChildElement().Element();
+		// should always have a valid root but handle gracefully if it does
+		if (!pElem) return;
+		m_name=pElem-&gt;Value();
+
+		// save this for later
+		hRoot=TiXmlHandle(pElem);
+	}
+
+	// block: string table
+	{
+		m_messages.clear(); // trash existing table
+
+		pElem=hRoot.FirstChild( "Messages" ).FirstChild().Element();
+		for( pElem; pElem; pElem=pElem-&gt;NextSiblingElement())
+		{
+			const char *pKey=pElem-&gt;Value();
+			const char *pText=pElem-&gt;GetText();
+			if (pKey &amp;&amp; pText) 
+			{
+				m_messages[pKey]=pText;
+			}
+		}
+	}
+
+	// block: windows
+	{
+		m_windows.clear(); // trash existing list
+
+		TiXmlElement* pWindowNode=hRoot.FirstChild( "Windows" ).FirstChild().Element();
+		for( pWindowNode; pWindowNode; pWindowNode=pWindowNode-&gt;NextSiblingElement())
+		{
+			WindowSettings w;
+			const char *pName=pWindowNode-&gt;Attribute("name");
+			if (pName) w.name=pName;
+			
+			pWindowNode-&gt;QueryIntAttribute("x", &amp;w.x); // If this fails, original value is left as-is
+			pWindowNode-&gt;QueryIntAttribute("y", &amp;w.y);
+			pWindowNode-&gt;QueryIntAttribute("w", &amp;w.w);
+			pWindowNode-&gt;QueryIntAttribute("hh", &amp;w.h);
+
+			m_windows.push_back(w);
+		}
+	}
+
+	// block: connection
+	{
+		pElem=hRoot.FirstChild("Connection").Element();
+		if (pElem)
+		{
+			m_connection.ip=pElem-&gt;Attribute("ip");
+			pElem-&gt;QueryDoubleAttribute("timeout",&amp;m_connection.timeout);
+		}
+	}
+}
+</pre></div><h1>Full listing for dump_to_stdout </h1>
+<p>Below is a copy-and-paste demo program for loading arbitrary XML files and dumping the structure to STDOUT using the recursive traversal listed above.</p>
+<div class="fragment"><pre class="fragment">
+// tutorial demo program
+#include "stdafx.h"
+#include "tinyxml.h"
+
+// ----------------------------------------------------------------------
+// STDOUT dump and indenting utility functions
+// ----------------------------------------------------------------------
+const unsigned int NUM_INDENTS_PER_SPACE=2;
+
+const char * getIndent( unsigned int numIndents )
+{
+	static const char * pINDENT="                                      + ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n &gt; LENGTH ) n = LENGTH;
+
+	return &amp;pINDENT[ LENGTH-n ];
+}
+
+// same as getIndent but no "+" at the end
+const char * getIndentAlt( unsigned int numIndents )
+{
+	static const char * pINDENT="                                        ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n &gt; LENGTH ) n = LENGTH;
+
+	return &amp;pINDENT[ LENGTH-n ];
+}
+
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement-&gt;FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib-&gt;Name(), pAttrib-&gt;Value());
+
+		if (pAttrib-&gt;QueryIntValue(&amp;ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib-&gt;QueryDoubleValue(&amp;dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib-&gt;Next();
+	}
+	return i;	
+}
+
+void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0 )
+{
+	if ( !pParent ) return;
+
+	TiXmlNode* pChild;
+	TiXmlText* pText;
+	int t = pParent-&gt;Type();
+	printf( "%s", getIndent(indent));
+	int num;
+
+	switch ( t )
+	{
+	case TiXmlNode::TINYXML_DOCUMENT:
+		printf( "Document" );
+		break;
+
+	case TiXmlNode::TINYXML_ELEMENT:
+		printf( "Element [%s]", pParent-&gt;Value() );
+		num=dump_attribs_to_stdout(pParent-&gt;ToElement(), indent+1);
+		switch(num)
+		{
+			case 0:  printf( " (No attributes)"); break;
+			case 1:  printf( "%s1 attribute", getIndentAlt(indent)); break;
+			default: printf( "%s%d attributes", getIndentAlt(indent), num); break;
+		}
+		break;
+
+	case TiXmlNode::TINYXML_COMMENT:
+		printf( "Comment: [%s]", pParent-&gt;Value());
+		break;
+
+	case TiXmlNode::TINYXML_UNKNOWN:
+		printf( "Unknown" );
+		break;
+
+	case TiXmlNode::TINYXML_TEXT:
+		pText = pParent-&gt;ToText();
+		printf( "Text: [%s]", pText-&gt;Value() );
+		break;
+
+	case TiXmlNode::TINYXML_DECLARATION:
+		printf( "Declaration" );
+		break;
+	default:
+		break;
+	}
+	printf( "\n" );
+	for ( pChild = pParent-&gt;FirstChild(); pChild != 0; pChild = pChild-&gt;NextSibling()) 
+	{
+		dump_to_stdout( pChild, indent+1 );
+	}
+}
+
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &amp;doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+
+// ----------------------------------------------------------------------
+// main() for printing files named on the command line
+// ----------------------------------------------------------------------
+int main(int argc, char* argv[])
+{
+	for (int i=1; i&lt;argc; i++)
+	{
+		dump_to_stdout(argv[i]);
+	}
+	return 0;
+}
+</pre></div><p>Run this from the command line or a DOS window, e.g.:</p>
+<div class="fragment"><pre class="fragment">
+C:\dev\tinyxml&gt; Debug\tinyxml_1.exe example1.xml
+
+example1.xml:
+Document
++ Declaration
++ Element [Hello]
+ (No attributes)
+  + Text: [World]
+</pre></div><p><em> Authors and Changes </p>
+<ul>
+<li>
+Written by Ellers, April, May, June 2005  </li>
+<li>
+Minor edits and integration into doc system, Lee Thomason September 2005  </li>
+<li>
+Updated by Ellers, October 2005  </li>
+</ul>
+<p></em> </p>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/tabs.css vdr-2.0.1.reel/tinyxml/docs/tabs.css
--- vdr-2.0.1/tinyxml/docs/tabs.css	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/tabs.css	2013-05-09 18:10:01.643874321 +0200
@@ -0,0 +1,105 @@
+/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */
+
+DIV.tabs
+{
+   float            : left;
+   width            : 100%;
+   background       : url("tab_b.gif") repeat-x bottom;
+   margin-bottom    : 4px;
+}
+
+DIV.tabs UL
+{
+   margin           : 0px;
+   padding-left     : 10px;
+   list-style       : none;
+}
+
+DIV.tabs LI, DIV.tabs FORM
+{
+   display          : inline;
+   margin           : 0px;
+   padding          : 0px;
+}
+
+DIV.tabs FORM
+{
+   float            : right;
+}
+
+DIV.tabs A
+{
+   float            : left;
+   background       : url("tab_r.gif") no-repeat right top;
+   border-bottom    : 1px solid #84B0C7;
+   font-size        : 80%;
+   font-weight      : bold;
+   text-decoration  : none;
+}
+
+DIV.tabs A:hover
+{
+   background-position: 100% -150px;
+}
+
+DIV.tabs A:link, DIV.tabs A:visited,
+DIV.tabs A:active, DIV.tabs A:hover
+{
+       color: #1A419D;
+}
+
+DIV.tabs SPAN
+{
+   float            : left;
+   display          : block;
+   background       : url("tab_l.gif") no-repeat left top;
+   padding          : 5px 9px;
+   white-space      : nowrap;
+}
+
+DIV.tabs #MSearchBox
+{
+   float            : right;
+   display          : inline;
+   font-size        : 1em;
+}
+
+DIV.tabs TD
+{
+   font-size        : 80%;
+   font-weight      : bold;
+   text-decoration  : none;
+}
+
+
+
+/* Commented Backslash Hack hides rule from IE5-Mac \*/
+DIV.tabs SPAN {float : none;}
+/* End IE5-Mac hack */
+
+DIV.tabs A:hover SPAN
+{
+   background-position: 0% -150px;
+}
+
+DIV.tabs LI.current A
+{
+   background-position: 100% -150px;
+   border-width     : 0px;
+}
+
+DIV.tabs LI.current SPAN
+{
+   background-position: 0% -150px;
+   padding-bottom   : 6px;
+}
+
+DIV.navpath
+{
+   background       : none;
+   border           : none;
+   border-bottom    : 1px solid #84B0C7;
+   text-align       : center;
+   margin           : 2px;
+   padding          : 2px;
+}
diff -urN vdr-2.0.1/tinyxml/docs/tinystr_8h_source.html vdr-2.0.1.reel/tinyxml/docs/tinystr_8h_source.html
--- vdr-2.0.1/tinyxml/docs/tinystr_8h_source.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/tinystr_8h_source.html	2013-05-09 18:10:01.643874321 +0200
@@ -0,0 +1,349 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: tinystr.h Source File</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li class="current"><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
+    </ul>
+  </div>
+<h1>tinystr.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
+<a name="l00002"></a>00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
+<a name="l00003"></a>00003 <span class="comment">Original file by Yves Berquin.</span>
+<a name="l00004"></a>00004 <span class="comment"></span>
+<a name="l00005"></a>00005 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied</span>
+<a name="l00006"></a>00006 <span class="comment">warranty. In no event will the authors be held liable for any</span>
+<a name="l00007"></a>00007 <span class="comment">damages arising from the use of this software.</span>
+<a name="l00008"></a>00008 <span class="comment"></span>
+<a name="l00009"></a>00009 <span class="comment">Permission is granted to anyone to use this software for any</span>
+<a name="l00010"></a>00010 <span class="comment">purpose, including commercial applications, and to alter it and</span>
+<a name="l00011"></a>00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
+<a name="l00012"></a>00012 <span class="comment"></span>
+<a name="l00013"></a>00013 <span class="comment">1. The origin of this software must not be misrepresented; you must</span>
+<a name="l00014"></a>00014 <span class="comment">not claim that you wrote the original software. If you use this</span>
+<a name="l00015"></a>00015 <span class="comment">software in a product, an acknowledgment in the product documentation</span>
+<a name="l00016"></a>00016 <span class="comment">would be appreciated but is not required.</span>
+<a name="l00017"></a>00017 <span class="comment"></span>
+<a name="l00018"></a>00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
+<a name="l00019"></a>00019 <span class="comment">must not be misrepresented as being the original software.</span>
+<a name="l00020"></a>00020 <span class="comment"></span>
+<a name="l00021"></a>00021 <span class="comment">3. This notice may not be removed or altered from any source</span>
+<a name="l00022"></a>00022 <span class="comment">distribution.</span>
+<a name="l00023"></a>00023 <span class="comment">*/</span>
+<a name="l00024"></a>00024 
+<a name="l00025"></a>00025 <span class="comment">/*</span>
+<a name="l00026"></a>00026 <span class="comment"> * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.</span>
+<a name="l00027"></a>00027 <span class="comment"> *</span>
+<a name="l00028"></a>00028 <span class="comment"> * - completely rewritten. compact, clean, and fast implementation.</span>
+<a name="l00029"></a>00029 <span class="comment"> * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)</span>
+<a name="l00030"></a>00030 <span class="comment"> * - fixed reserve() to work as per specification.</span>
+<a name="l00031"></a>00031 <span class="comment"> * - fixed buggy compares operator==(), operator&lt;(), and operator&gt;()</span>
+<a name="l00032"></a>00032 <span class="comment"> * - fixed operator+=() to take a const ref argument, following spec.</span>
+<a name="l00033"></a>00033 <span class="comment"> * - added &quot;copy&quot; constructor with length, and most compare operators.</span>
+<a name="l00034"></a>00034 <span class="comment"> * - added swap(), clear(), size(), capacity(), operator+().</span>
+<a name="l00035"></a>00035 <span class="comment"> */</span>
+<a name="l00036"></a>00036 
+<a name="l00037"></a>00037 <span class="preprocessor">#ifndef TIXML_USE_STL</span>
+<a name="l00038"></a>00038 <span class="preprocessor"></span>
+<a name="l00039"></a>00039 <span class="preprocessor">#ifndef TIXML_STRING_INCLUDED</span>
+<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define TIXML_STRING_INCLUDED</span>
+<a name="l00041"></a>00041 <span class="preprocessor"></span>
+<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;assert.h&gt;</span>
+<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
+<a name="l00044"></a>00044 
+<a name="l00045"></a>00045 <span class="comment">/*  The support for explicit isn&#39;t that universal, and it isn&#39;t really</span>
+<a name="l00046"></a>00046 <span class="comment">    required - it is used to check that the TiXmlString class isn&#39;t incorrectly</span>
+<a name="l00047"></a>00047 <span class="comment">    used. Be nice to old compilers and macro it here:</span>
+<a name="l00048"></a>00048 <span class="comment">*/</span>
+<a name="l00049"></a>00049 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200 )</span>
+<a name="l00050"></a>00050 <span class="preprocessor"></span>    <span class="comment">// Microsoft visual studio, version 6 and higher.</span>
+<a name="l00051"></a>00051 <span class="preprocessor">    #define TIXML_EXPLICIT explicit</span>
+<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3 )</span>
+<a name="l00053"></a>00053 <span class="preprocessor"></span>    <span class="comment">// GCC version 3 and higher.s</span>
+<a name="l00054"></a>00054 <span class="preprocessor">    #define TIXML_EXPLICIT explicit</span>
+<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#else</span>
+<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">    #define TIXML_EXPLICIT</span>
+<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00058"></a>00058 <span class="preprocessor"></span>
+<a name="l00059"></a>00059 
+<a name="l00060"></a>00060 <span class="comment">/*</span>
+<a name="l00061"></a>00061 <span class="comment">   TiXmlString is an emulation of a subset of the std::string template.</span>
+<a name="l00062"></a>00062 <span class="comment">   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.</span>
+<a name="l00063"></a>00063 <span class="comment">   Only the member functions relevant to the TinyXML project have been implemented.</span>
+<a name="l00064"></a>00064 <span class="comment">   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase</span>
+<a name="l00065"></a>00065 <span class="comment">   a string and there&#39;s no more room, we allocate a buffer twice as big as we need.</span>
+<a name="l00066"></a>00066 <span class="comment">*/</span>
+<a name="l00067"></a>00067 <span class="keyword">class </span>TiXmlString
+<a name="l00068"></a>00068 {
+<a name="l00069"></a>00069   <span class="keyword">public</span> :
+<a name="l00070"></a>00070     <span class="comment">// The size type used</span>
+<a name="l00071"></a>00071     <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> size_type;
+<a name="l00072"></a>00072 
+<a name="l00073"></a>00073     <span class="comment">// Error value for find primitive</span>
+<a name="l00074"></a>00074     <span class="keyword">static</span> <span class="keyword">const</span> size_type npos; <span class="comment">// = -1;</span>
+<a name="l00075"></a>00075 
+<a name="l00076"></a>00076 
+<a name="l00077"></a>00077     <span class="comment">// TiXmlString empty constructor</span>
+<a name="l00078"></a>00078     TiXmlString () : rep_(&amp;nullrep_)
+<a name="l00079"></a>00079     {
+<a name="l00080"></a>00080     }
+<a name="l00081"></a>00081 
+<a name="l00082"></a>00082     <span class="comment">// TiXmlString copy constructor</span>
+<a name="l00083"></a>00083     TiXmlString ( <span class="keyword">const</span> TiXmlString &amp; copy) : rep_(0)
+<a name="l00084"></a>00084     {
+<a name="l00085"></a>00085         init(copy.length());
+<a name="l00086"></a>00086         memcpy(start(), copy.data(), length());
+<a name="l00087"></a>00087     }
+<a name="l00088"></a>00088 
+<a name="l00089"></a>00089     <span class="comment">// TiXmlString constructor, based on a string</span>
+<a name="l00090"></a>00090     TIXML_EXPLICIT TiXmlString ( <span class="keyword">const</span> <span class="keywordtype">char</span> * copy) : rep_(0)
+<a name="l00091"></a>00091     {
+<a name="l00092"></a>00092         init( static_cast&lt;size_type&gt;( strlen(copy) ));
+<a name="l00093"></a>00093         memcpy(start(), copy, length());
+<a name="l00094"></a>00094     }
+<a name="l00095"></a>00095 
+<a name="l00096"></a>00096     <span class="comment">// TiXmlString constructor, based on a string</span>
+<a name="l00097"></a>00097     TIXML_EXPLICIT TiXmlString ( <span class="keyword">const</span> <span class="keywordtype">char</span> * str, size_type len) : rep_(0)
+<a name="l00098"></a>00098     {
+<a name="l00099"></a>00099         init(len);
+<a name="l00100"></a>00100         memcpy(start(), str, len);
+<a name="l00101"></a>00101     }
+<a name="l00102"></a>00102 
+<a name="l00103"></a>00103     <span class="comment">// TiXmlString destructor</span>
+<a name="l00104"></a>00104     ~TiXmlString ()
+<a name="l00105"></a>00105     {
+<a name="l00106"></a>00106         quit();
+<a name="l00107"></a>00107     }
+<a name="l00108"></a>00108 
+<a name="l00109"></a>00109     <span class="comment">// = operator</span>
+<a name="l00110"></a>00110     TiXmlString&amp; operator = (<span class="keyword">const</span> <span class="keywordtype">char</span> * copy)
+<a name="l00111"></a>00111     {
+<a name="l00112"></a>00112         <span class="keywordflow">return</span> assign( copy, (size_type)strlen(copy));
+<a name="l00113"></a>00113     }
+<a name="l00114"></a>00114 
+<a name="l00115"></a>00115     <span class="comment">// = operator</span>
+<a name="l00116"></a>00116     TiXmlString&amp; operator = (<span class="keyword">const</span> TiXmlString &amp; copy)
+<a name="l00117"></a>00117     {
+<a name="l00118"></a>00118         <span class="keywordflow">return</span> assign(copy.start(), copy.length());
+<a name="l00119"></a>00119     }
+<a name="l00120"></a>00120 
+<a name="l00121"></a>00121 
+<a name="l00122"></a>00122     <span class="comment">// += operator. Maps to append</span>
+<a name="l00123"></a>00123     TiXmlString&amp; operator += (<span class="keyword">const</span> <span class="keywordtype">char</span> * suffix)
+<a name="l00124"></a>00124     {
+<a name="l00125"></a>00125         <span class="keywordflow">return</span> append(suffix, static_cast&lt;size_type&gt;( strlen(suffix) ));
+<a name="l00126"></a>00126     }
+<a name="l00127"></a>00127 
+<a name="l00128"></a>00128     <span class="comment">// += operator. Maps to append</span>
+<a name="l00129"></a>00129     TiXmlString&amp; operator += (<span class="keywordtype">char</span> single)
+<a name="l00130"></a>00130     {
+<a name="l00131"></a>00131         <span class="keywordflow">return</span> append(&amp;single, 1);
+<a name="l00132"></a>00132     }
+<a name="l00133"></a>00133 
+<a name="l00134"></a>00134     <span class="comment">// += operator. Maps to append</span>
+<a name="l00135"></a>00135     TiXmlString&amp; operator += (<span class="keyword">const</span> TiXmlString &amp; suffix)
+<a name="l00136"></a>00136     {
+<a name="l00137"></a>00137         <span class="keywordflow">return</span> append(suffix.data(), suffix.length());
+<a name="l00138"></a>00138     }
+<a name="l00139"></a>00139 
+<a name="l00140"></a>00140 
+<a name="l00141"></a>00141     <span class="comment">// Convert a TiXmlString into a null-terminated char *</span>
+<a name="l00142"></a>00142     <span class="keyword">const</span> <span class="keywordtype">char</span> * c_str ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00143"></a>00143 
+<a name="l00144"></a>00144     <span class="comment">// Convert a TiXmlString into a char * (need not be null terminated).</span>
+<a name="l00145"></a>00145     <span class="keyword">const</span> <span class="keywordtype">char</span> * data ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00146"></a>00146 
+<a name="l00147"></a>00147     <span class="comment">// Return the length of a TiXmlString</span>
+<a name="l00148"></a>00148     size_type length ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size; }
+<a name="l00149"></a>00149 
+<a name="l00150"></a>00150     <span class="comment">// Alias for length()</span>
+<a name="l00151"></a>00151     size_type size ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size; }
+<a name="l00152"></a>00152 
+<a name="l00153"></a>00153     <span class="comment">// Checks if a TiXmlString is empty</span>
+<a name="l00154"></a>00154     <span class="keywordtype">bool</span> empty ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size == 0; }
+<a name="l00155"></a>00155 
+<a name="l00156"></a>00156     <span class="comment">// Return capacity of string</span>
+<a name="l00157"></a>00157     size_type capacity ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;capacity; }
+<a name="l00158"></a>00158 
+<a name="l00159"></a>00159 
+<a name="l00160"></a>00160     <span class="comment">// single char extraction</span>
+<a name="l00161"></a>00161     <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; at (size_type index)<span class="keyword"> const</span>
+<a name="l00162"></a>00162 <span class="keyword">    </span>{
+<a name="l00163"></a>00163         assert( index &lt; length() );
+<a name="l00164"></a>00164         <span class="keywordflow">return</span> rep_-&gt;str[ index ];
+<a name="l00165"></a>00165     }
+<a name="l00166"></a>00166 
+<a name="l00167"></a>00167     <span class="comment">// [] operator</span>
+<a name="l00168"></a>00168     <span class="keywordtype">char</span>&amp; operator [] (size_type index)<span class="keyword"> const</span>
+<a name="l00169"></a>00169 <span class="keyword">    </span>{
+<a name="l00170"></a>00170         assert( index &lt; length() );
+<a name="l00171"></a>00171         <span class="keywordflow">return</span> rep_-&gt;str[ index ];
+<a name="l00172"></a>00172     }
+<a name="l00173"></a>00173 
+<a name="l00174"></a>00174     <span class="comment">// find a char in a string. Return TiXmlString::npos if not found</span>
+<a name="l00175"></a>00175     size_type find (<span class="keywordtype">char</span> lookup)<span class="keyword"> const</span>
+<a name="l00176"></a>00176 <span class="keyword">    </span>{
+<a name="l00177"></a>00177         <span class="keywordflow">return</span> find(lookup, 0);
+<a name="l00178"></a>00178     }
+<a name="l00179"></a>00179 
+<a name="l00180"></a>00180     <span class="comment">// find a char in a string from an offset. Return TiXmlString::npos if not found</span>
+<a name="l00181"></a>00181     size_type find (<span class="keywordtype">char</span> tofind, size_type offset)<span class="keyword"> const</span>
+<a name="l00182"></a>00182 <span class="keyword">    </span>{
+<a name="l00183"></a>00183         <span class="keywordflow">if</span> (offset &gt;= length()) <span class="keywordflow">return</span> npos;
+<a name="l00184"></a>00184 
+<a name="l00185"></a>00185         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>* p = c_str() + offset; *p != <span class="charliteral">&#39;\0&#39;</span>; ++p)
+<a name="l00186"></a>00186         {
+<a name="l00187"></a>00187            <span class="keywordflow">if</span> (*p == tofind) <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> size_type <span class="keyword">&gt;</span>( p - c_str() );
+<a name="l00188"></a>00188         }
+<a name="l00189"></a>00189         <span class="keywordflow">return</span> npos;
+<a name="l00190"></a>00190     }
+<a name="l00191"></a>00191 
+<a name="l00192"></a>00192     <span class="keywordtype">void</span> clear ()
+<a name="l00193"></a>00193     {
+<a name="l00194"></a>00194         <span class="comment">//Lee:</span>
+<a name="l00195"></a>00195         <span class="comment">//The original was just too strange, though correct:</span>
+<a name="l00196"></a>00196         <span class="comment">//  TiXmlString().swap(*this);</span>
+<a name="l00197"></a>00197         <span class="comment">//Instead use the quit &amp; re-init:</span>
+<a name="l00198"></a>00198         quit();
+<a name="l00199"></a>00199         init(0,0);
+<a name="l00200"></a>00200     }
+<a name="l00201"></a>00201 
+<a name="l00202"></a>00202     <span class="comment">/*  Function to reserve a big amount of data when we know we&#39;ll need it. Be aware that this</span>
+<a name="l00203"></a>00203 <span class="comment">        function DOES NOT clear the content of the TiXmlString if any exists.</span>
+<a name="l00204"></a>00204 <span class="comment">    */</span>
+<a name="l00205"></a>00205     <span class="keywordtype">void</span> reserve (size_type cap);
+<a name="l00206"></a>00206 
+<a name="l00207"></a>00207     TiXmlString&amp; assign (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, size_type len);
+<a name="l00208"></a>00208 
+<a name="l00209"></a>00209     TiXmlString&amp; append (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, size_type len);
+<a name="l00210"></a>00210 
+<a name="l00211"></a>00211     <span class="keywordtype">void</span> swap (TiXmlString&amp; other)
+<a name="l00212"></a>00212     {
+<a name="l00213"></a>00213         Rep* r = rep_;
+<a name="l00214"></a>00214         rep_ = other.rep_;
+<a name="l00215"></a>00215         other.rep_ = r;
+<a name="l00216"></a>00216     }
+<a name="l00217"></a>00217 
+<a name="l00218"></a>00218   <span class="keyword">private</span>:
+<a name="l00219"></a>00219 
+<a name="l00220"></a>00220     <span class="keywordtype">void</span> init(size_type sz) { init(sz, sz); }
+<a name="l00221"></a>00221     <span class="keywordtype">void</span> set_size(size_type sz) { rep_-&gt;str[ rep_-&gt;size = sz ] = <span class="charliteral">&#39;\0&#39;</span>; }
+<a name="l00222"></a>00222     <span class="keywordtype">char</span>* start()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00223"></a>00223     <span class="keywordtype">char</span>* finish()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str + rep_-&gt;size; }
+<a name="l00224"></a>00224 
+<a name="l00225"></a>00225     <span class="keyword">struct </span>Rep
+<a name="l00226"></a>00226     {
+<a name="l00227"></a>00227         size_type size, capacity;
+<a name="l00228"></a>00228         <span class="keywordtype">char</span> str[1];
+<a name="l00229"></a>00229     };
+<a name="l00230"></a>00230 
+<a name="l00231"></a>00231     <span class="keywordtype">void</span> init(size_type sz, size_type cap)
+<a name="l00232"></a>00232     {
+<a name="l00233"></a>00233         <span class="keywordflow">if</span> (cap)
+<a name="l00234"></a>00234         {
+<a name="l00235"></a>00235             <span class="comment">// Lee: the original form:</span>
+<a name="l00236"></a>00236             <span class="comment">//  rep_ = static_cast&lt;Rep*&gt;(operator new(sizeof(Rep) + cap));</span>
+<a name="l00237"></a>00237             <span class="comment">// doesn&#39;t work in some cases of new being overloaded. Switching</span>
+<a name="l00238"></a>00238             <span class="comment">// to the normal allocation, although use an &#39;int&#39; for systems</span>
+<a name="l00239"></a>00239             <span class="comment">// that are overly picky about structure alignment.</span>
+<a name="l00240"></a>00240             <span class="keyword">const</span> size_type bytesNeeded = <span class="keyword">sizeof</span>(Rep) + cap;
+<a name="l00241"></a>00241             <span class="keyword">const</span> size_type intsNeeded = ( bytesNeeded + <span class="keyword">sizeof</span>(int) - 1 ) / <span class="keyword">sizeof</span>( int ); 
+<a name="l00242"></a>00242             rep_ = <span class="keyword">reinterpret_cast&lt;</span>Rep*<span class="keyword">&gt;</span>( <span class="keyword">new</span> <span class="keywordtype">int</span>[ intsNeeded ] );
+<a name="l00243"></a>00243 
+<a name="l00244"></a>00244             rep_-&gt;str[ rep_-&gt;size = sz ] = <span class="charliteral">&#39;\0&#39;</span>;
+<a name="l00245"></a>00245             rep_-&gt;capacity = cap;
+<a name="l00246"></a>00246         }
+<a name="l00247"></a>00247         <span class="keywordflow">else</span>
+<a name="l00248"></a>00248         {
+<a name="l00249"></a>00249             rep_ = &amp;nullrep_;
+<a name="l00250"></a>00250         }
+<a name="l00251"></a>00251     }
+<a name="l00252"></a>00252 
+<a name="l00253"></a>00253     <span class="keywordtype">void</span> quit()
+<a name="l00254"></a>00254     {
+<a name="l00255"></a>00255         <span class="keywordflow">if</span> (rep_ != &amp;nullrep_)
+<a name="l00256"></a>00256         {
+<a name="l00257"></a>00257             <span class="comment">// The rep_ is really an array of ints. (see the allocator, above).</span>
+<a name="l00258"></a>00258             <span class="comment">// Cast it back before delete, so the compiler won&#39;t incorrectly call destructors.</span>
+<a name="l00259"></a>00259             <span class="keyword">delete</span> [] ( <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>( rep_ ) );
+<a name="l00260"></a>00260         }
+<a name="l00261"></a>00261     }
+<a name="l00262"></a>00262 
+<a name="l00263"></a>00263     Rep * rep_;
+<a name="l00264"></a>00264     <span class="keyword">static</span> Rep nullrep_;
+<a name="l00265"></a>00265 
+<a name="l00266"></a>00266 } ;
+<a name="l00267"></a>00267 
+<a name="l00268"></a>00268 
+<a name="l00269"></a>00269 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b)
+<a name="l00270"></a>00270 {
+<a name="l00271"></a>00271     <span class="keywordflow">return</span>    ( a.length() == b.length() )              <span class="comment">// optimization on some platforms</span>
+<a name="l00272"></a>00272            &amp;&amp; ( strcmp(a.c_str(), b.c_str()) == 0 );    <span class="comment">// actual compare</span>
+<a name="l00273"></a>00273 }
+<a name="l00274"></a>00274 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b)
+<a name="l00275"></a>00275 {
+<a name="l00276"></a>00276     <span class="keywordflow">return</span> strcmp(a.c_str(), b.c_str()) &lt; 0;
+<a name="l00277"></a>00277 }
+<a name="l00278"></a>00278 
+<a name="l00279"></a>00279 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(a == b); }
+<a name="l00280"></a>00280 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;  (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> b &lt; a; }
+<a name="l00281"></a>00281 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(b &lt; a); }
+<a name="l00282"></a>00282 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(a &lt; b); }
+<a name="l00283"></a>00283 
+<a name="l00284"></a>00284 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b) { <span class="keywordflow">return</span> strcmp(a.c_str(), b) == 0; }
+<a name="l00285"></a>00285 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> b == a; }
+<a name="l00286"></a>00286 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b) { <span class="keywordflow">return</span> !(a == b); }
+<a name="l00287"></a>00287 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(b == a); }
+<a name="l00288"></a>00288 
+<a name="l00289"></a>00289 TiXmlString operator + (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b);
+<a name="l00290"></a>00290 TiXmlString operator + (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b);
+<a name="l00291"></a>00291 TiXmlString operator + (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b);
+<a name="l00292"></a>00292 
+<a name="l00293"></a>00293 
+<a name="l00294"></a>00294 <span class="comment">/*</span>
+<a name="l00295"></a>00295 <span class="comment">   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.</span>
+<a name="l00296"></a>00296 <span class="comment">   Only the operators that we need for TinyXML have been developped.</span>
+<a name="l00297"></a>00297 <span class="comment">*/</span>
+<a name="l00298"></a>00298 <span class="keyword">class </span>TiXmlOutStream : <span class="keyword">public</span> TiXmlString
+<a name="l00299"></a>00299 {
+<a name="l00300"></a>00300 <span class="keyword">public</span> :
+<a name="l00301"></a>00301 
+<a name="l00302"></a>00302     <span class="comment">// TiXmlOutStream &lt;&lt; operator.</span>
+<a name="l00303"></a>00303     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> TiXmlString &amp; in)
+<a name="l00304"></a>00304     {
+<a name="l00305"></a>00305         *<span class="keyword">this</span> += in;
+<a name="l00306"></a>00306         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
+<a name="l00307"></a>00307     }
+<a name="l00308"></a>00308 
+<a name="l00309"></a>00309     <span class="comment">// TiXmlOutStream &lt;&lt; operator.</span>
+<a name="l00310"></a>00310     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> <span class="keywordtype">char</span> * in)
+<a name="l00311"></a>00311     {
+<a name="l00312"></a>00312         *<span class="keyword">this</span> += in;
+<a name="l00313"></a>00313         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
+<a name="l00314"></a>00314     }
+<a name="l00315"></a>00315 
+<a name="l00316"></a>00316 } ;
+<a name="l00317"></a>00317 
+<a name="l00318"></a>00318 <span class="preprocessor">#endif  // TIXML_STRING_INCLUDED</span>
+<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#endif  // TIXML_USE_STL</span>
+</pre></div></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/tinyxml_8h_source.html vdr-2.0.1.reel/tinyxml/docs/tinyxml_8h_source.html
--- vdr-2.0.1/tinyxml/docs/tinyxml_8h_source.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/tinyxml_8h_source.html	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,1205 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: tinyxml.h Source File</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li class="current"><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="tabs">
+    <ul>
+      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
+    </ul>
+  </div>
+<h1>tinyxml.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
+<a name="l00002"></a>00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
+<a name="l00003"></a>00003 <span class="comment">Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)</span>
+<a name="l00004"></a>00004 <span class="comment"></span>
+<a name="l00005"></a>00005 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied</span>
+<a name="l00006"></a>00006 <span class="comment">warranty. In no event will the authors be held liable for any</span>
+<a name="l00007"></a>00007 <span class="comment">damages arising from the use of this software.</span>
+<a name="l00008"></a>00008 <span class="comment"></span>
+<a name="l00009"></a>00009 <span class="comment">Permission is granted to anyone to use this software for any</span>
+<a name="l00010"></a>00010 <span class="comment">purpose, including commercial applications, and to alter it and</span>
+<a name="l00011"></a>00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
+<a name="l00012"></a>00012 <span class="comment"></span>
+<a name="l00013"></a>00013 <span class="comment">1. The origin of this software must not be misrepresented; you must</span>
+<a name="l00014"></a>00014 <span class="comment">not claim that you wrote the original software. If you use this</span>
+<a name="l00015"></a>00015 <span class="comment">software in a product, an acknowledgment in the product documentation</span>
+<a name="l00016"></a>00016 <span class="comment">would be appreciated but is not required.</span>
+<a name="l00017"></a>00017 <span class="comment"></span>
+<a name="l00018"></a>00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
+<a name="l00019"></a>00019 <span class="comment">must not be misrepresented as being the original software.</span>
+<a name="l00020"></a>00020 <span class="comment"></span>
+<a name="l00021"></a>00021 <span class="comment">3. This notice may not be removed or altered from any source</span>
+<a name="l00022"></a>00022 <span class="comment">distribution.</span>
+<a name="l00023"></a>00023 <span class="comment">*/</span>
+<a name="l00024"></a>00024 
+<a name="l00025"></a>00025 
+<a name="l00026"></a>00026 <span class="preprocessor">#ifndef TINYXML_INCLUDED</span>
+<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define TINYXML_INCLUDED</span>
+<a name="l00028"></a>00028 <span class="preprocessor"></span>
+<a name="l00029"></a>00029 <span class="preprocessor">#ifdef _MSC_VER</span>
+<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( push )</span>
+<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4530 )</span>
+<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4786 )</span>
+<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00034"></a>00034 <span class="preprocessor"></span>
+<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
+<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
+<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
+<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;string.h&gt;</span>
+<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;assert.h&gt;</span>
+<a name="l00040"></a>00040 
+<a name="l00041"></a>00041 <span class="comment">// Help out windows:</span>
+<a name="l00042"></a>00042 <span class="preprocessor">#if defined( _DEBUG ) &amp;&amp; !defined( DEBUG )</span>
+<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG</span>
+<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00045"></a>00045 <span class="preprocessor"></span>
+<a name="l00046"></a>00046 <span class="preprocessor">#ifdef TIXML_USE_STL</span>
+<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;string&gt;</span>
+<a name="l00048"></a>00048 <span class="preprocessor">    #include &lt;iostream&gt;</span>
+<a name="l00049"></a>00049 <span class="preprocessor">    #include &lt;sstream&gt;</span>
+<a name="l00050"></a>00050 <span class="preprocessor">    #define TIXML_STRING        std::string</span>
+<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#else</span>
+<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">    #include &quot;tinystr.h&quot;</span>
+<a name="l00053"></a>00053 <span class="preprocessor">    #define TIXML_STRING        TiXmlString</span>
+<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00055"></a>00055 <span class="preprocessor"></span>
+<a name="l00056"></a>00056 <span class="comment">// Deprecated library function hell. Compilers want to use the</span>
+<a name="l00057"></a>00057 <span class="comment">// new safe versions. This probably doesn&#39;t fully address the problem,</span>
+<a name="l00058"></a>00058 <span class="comment">// but it gets closer. There are too many compilers for me to fully</span>
+<a name="l00059"></a>00059 <span class="comment">// test. If you get compilation troubles, undefine TIXML_SAFE</span>
+<a name="l00060"></a>00060 <span class="preprocessor">#define TIXML_SAFE</span>
+<a name="l00061"></a>00061 <span class="preprocessor"></span>
+<a name="l00062"></a>00062 <span class="preprocessor">#ifdef TIXML_SAFE</span>
+<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">    #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400 )</span>
+<a name="l00064"></a>00064 <span class="preprocessor"></span>        <span class="comment">// Microsoft visual studio, version 2005 and higher.</span>
+<a name="l00065"></a>00065 <span class="preprocessor">        #define TIXML_SNPRINTF _snprintf_s</span>
+<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf_s</span>
+<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200 )</span>
+<a name="l00068"></a>00068 <span class="preprocessor"></span>        <span class="comment">// Microsoft visual studio, version 6 and higher.</span>
+<a name="l00069"></a>00069         <span class="comment">//#pragma message( &quot;Using _sn* functions.&quot; )</span>
+<a name="l00070"></a>00070 <span class="preprocessor">        #define TIXML_SNPRINTF _snprintf</span>
+<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3 )</span>
+<a name="l00073"></a>00073 <span class="preprocessor"></span>        <span class="comment">// GCC version 3 and higher.s</span>
+<a name="l00074"></a>00074         <span class="comment">//#warning( &quot;Using sn* functions.&quot; )</span>
+<a name="l00075"></a>00075 <span class="preprocessor">        #define TIXML_SNPRINTF snprintf</span>
+<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
+<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SNPRINTF snprintf</span>
+<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#endif  </span>
+<a name="l00082"></a>00082 <span class="preprocessor"></span>
+<a name="l00083"></a>00083 <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>;
+<a name="l00084"></a>00084 <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l00085"></a>00085 <span class="keyword">class </span><a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>;
+<a name="l00086"></a>00086 <span class="keyword">class </span><a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>;
+<a name="l00087"></a>00087 <span class="keyword">class </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>;
+<a name="l00088"></a>00088 <span class="keyword">class </span><a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>;
+<a name="l00089"></a>00089 <span class="keyword">class </span><a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>;
+<a name="l00090"></a>00090 <span class="keyword">class </span>TiXmlParsingData;
+<a name="l00091"></a>00091 
+<a name="l00092"></a>00092 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_MAJOR_VERSION = 2;
+<a name="l00093"></a>00093 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_MINOR_VERSION = 6;
+<a name="l00094"></a>00094 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_PATCH_VERSION = 1;
+<a name="l00095"></a>00095 
+<a name="l00096"></a>00096 <span class="comment">/*  Internal structure for tracking location of items </span>
+<a name="l00097"></a>00097 <span class="comment">    in the XML file.</span>
+<a name="l00098"></a>00098 <span class="comment">*/</span>
+<a name="l00099"></a>00099 <span class="keyword">struct </span>TiXmlCursor
+<a name="l00100"></a>00100 {
+<a name="l00101"></a>00101     TiXmlCursor()       { Clear(); }
+<a name="l00102"></a>00102     <span class="keywordtype">void</span> Clear()        { row = col = -1; }
+<a name="l00103"></a>00103 
+<a name="l00104"></a>00104     <span class="keywordtype">int</span> row;    <span class="comment">// 0 based.</span>
+<a name="l00105"></a>00105     <span class="keywordtype">int</span> col;    <span class="comment">// 0 based.</span>
+<a name="l00106"></a>00106 };
+<a name="l00107"></a>00107 
+<a name="l00108"></a>00108 
+<a name="l00128"></a><a class="code" href="classTiXmlVisitor.html">00128</a> <span class="keyword">class </span><a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>
+<a name="l00129"></a>00129 {
+<a name="l00130"></a>00130 <span class="keyword">public</span>:
+<a name="l00131"></a>00131     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>() {}
+<a name="l00132"></a>00132 
+<a name="l00134"></a><a class="code" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0">00134</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a07baecb52dd7d8716ae2a48ad0956ee0" title="Visit a document.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; <span class="comment">/*doc*/</span> )         { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00136"></a><a class="code" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad">00136</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#aa0ade4f27087447e93974e975c3246ad" title="Visit a document.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; <span class="comment">/*doc*/</span> )          { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00137"></a>00137 
+<a name="l00139"></a><a class="code" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff">00139</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#af6c6178ffa517bbdba95d70490875fff" title="Visit an element.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; <span class="comment">/*element*/</span>, <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="comment">/*firstAttribute*/</span> )    { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00141"></a><a class="code" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c">00141</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#aec2b1f8116226d52f3a1b95dafd3a32c" title="Visit an element.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; <span class="comment">/*element*/</span> )       { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00142"></a>00142 
+<a name="l00144"></a><a class="code" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19">00144</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#afad71c71ce6473fb9b4b64cd92de4a19" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; <span class="comment">/*declaration*/</span> )   { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00146"></a><a class="code" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5">00146</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a399b8ebca5cd14664974a32d2ce029e5" title="Visit a text node.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; <span class="comment">/*text*/</span> )                 { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00148"></a><a class="code" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2">00148</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a53a60e7a528627b31af3161972cc7fa2" title="Visit a comment node.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; <span class="comment">/*comment*/</span> )           { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00150"></a><a class="code" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28">00150</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a7e284d607d275c51dac1adb58159ce28" title="Visit an unknow node.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; <span class="comment">/*unknown*/</span> )           { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00151"></a>00151 };
+<a name="l00152"></a>00152 
+<a name="l00153"></a>00153 <span class="comment">// Only used by Attribute::Query functions</span>
+<a name="l00154"></a>00154 <span class="keyword">enum</span> 
+<a name="l00155"></a>00155 { 
+<a name="l00156"></a>00156     TIXML_SUCCESS,
+<a name="l00157"></a>00157     TIXML_NO_ATTRIBUTE,
+<a name="l00158"></a>00158     TIXML_WRONG_TYPE
+<a name="l00159"></a>00159 };
+<a name="l00160"></a>00160 
+<a name="l00161"></a>00161 
+<a name="l00162"></a>00162 <span class="comment">// Used by the parsing routines.</span>
+<a name="l00163"></a>00163 <span class="keyword">enum</span> TiXmlEncoding
+<a name="l00164"></a>00164 {
+<a name="l00165"></a>00165     TIXML_ENCODING_UNKNOWN,
+<a name="l00166"></a>00166     TIXML_ENCODING_UTF8,
+<a name="l00167"></a>00167     TIXML_ENCODING_LEGACY
+<a name="l00168"></a>00168 };
+<a name="l00169"></a>00169 
+<a name="l00170"></a>00170 <span class="keyword">const</span> TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+<a name="l00171"></a>00171 
+<a name="l00194"></a><a class="code" href="classTiXmlBase.html">00194</a> <span class="keyword">class </span><a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>
+<a name="l00195"></a>00195 {
+<a name="l00196"></a>00196     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>;
+<a name="l00197"></a>00197     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l00198"></a>00198     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>;
+<a name="l00199"></a>00199 
+<a name="l00200"></a>00200 <span class="keyword">public</span>:
+<a name="l00201"></a>00201     <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>() :   <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>(0)     {}
+<a name="l00202"></a>00202     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>()            {}
+<a name="l00203"></a>00203 
+<a name="l00213"></a>00213     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#a0de56b3f2ef14c65091a3b916437b512" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span> = 0;
+<a name="l00214"></a>00214 
+<a name="l00221"></a><a class="code" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1">00221</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#a0f799ec645bfb8d8a969e83478f379c1" title="The world does not agree on whether white space should be kept or not.">SetCondenseWhiteSpace</a>( <span class="keywordtype">bool</span> condense )      { condenseWhiteSpace = condense; }
+<a name="l00222"></a>00222 
+<a name="l00224"></a><a class="code" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438">00224</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlBase.html#ad4b1472531c647a25b1840a87ae42438" title="Return the current white space setting.">IsWhiteSpaceCondensed</a>()                     { <span class="keywordflow">return</span> condenseWhiteSpace; }
+<a name="l00225"></a>00225 
+<a name="l00244"></a><a class="code" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853">00244</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlBase.html#a024bceb070188df92c2a8d8852dd0853" title="Return the position, in the original source file, of this node or attribute.">Row</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> location.row + 1; }
+<a name="l00245"></a><a class="code" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003">00245</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlBase.html#ab54bfb9b70fe6dd276e7b279cab7f003" title="See Row().">Column</a>()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> location.col + 1; }    
+<a name="l00246"></a>00246 
+<a name="l00247"></a><a class="code" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d">00247</a>     <span class="keywordtype">void</span>  <a class="code" href="classTiXmlBase.html#ac6b3e0f790930d4970ec30764e937b5d" title="Set a pointer to arbitrary user data.">SetUserData</a>( <span class="keywordtype">void</span>* user )         { <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a> = user; }    
+<a name="l00248"></a><a class="code" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17">00248</a>     <span class="keywordtype">void</span>* <a class="code" href="classTiXmlBase.html#a6559a530ca6763fc301a14d77ed28c17" title="Get a pointer to arbitrary user data.">GetUserData</a>()                     { <span class="keywordflow">return</span> <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>; }    
+<a name="l00249"></a><a class="code" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4">00249</a>     <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="classTiXmlBase.html#ad0120210e4680ef2088601753ce0ede4" title="Get a pointer to arbitrary user data.">GetUserData</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>; }    
+<a name="l00250"></a>00250 
+<a name="l00251"></a>00251     <span class="comment">// Table that returs, for a given lead byte, the total number of bytes</span>
+<a name="l00252"></a>00252     <span class="comment">// in the UTF-8 sequence.</span>
+<a name="l00253"></a>00253     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> utf8ByteTable[256];
+<a name="l00254"></a>00254 
+<a name="l00255"></a>00255     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378" title="Parse the given null terminated block of xml data.">Parse</a>(  <span class="keyword">const</span> <span class="keywordtype">char</span>* p, 
+<a name="l00256"></a>00256                                 TiXmlParsingData* data, 
+<a name="l00257"></a>00257                                 TiXmlEncoding encoding <span class="comment">/*= TIXML_ENCODING_UNKNOWN */</span> ) = 0;
+<a name="l00258"></a>00258 
+<a name="l00262"></a>00262     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#a6bd8c315c1acb09e34107b8736505948" title="Expands entities in a string.">EncodeString</a>( <span class="keyword">const</span> TIXML_STRING&amp; str, TIXML_STRING* out );
+<a name="l00263"></a>00263 
+<a name="l00264"></a>00264     <span class="keyword">enum</span>
+<a name="l00265"></a>00265     {
+<a name="l00266"></a>00266         TIXML_NO_ERROR = 0,
+<a name="l00267"></a>00267         TIXML_ERROR,
+<a name="l00268"></a>00268         TIXML_ERROR_OPENING_FILE,
+<a name="l00269"></a>00269         TIXML_ERROR_PARSING_ELEMENT,
+<a name="l00270"></a>00270         TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+<a name="l00271"></a>00271         TIXML_ERROR_READING_ELEMENT_VALUE,
+<a name="l00272"></a>00272         TIXML_ERROR_READING_ATTRIBUTES,
+<a name="l00273"></a>00273         TIXML_ERROR_PARSING_EMPTY,
+<a name="l00274"></a>00274         TIXML_ERROR_READING_END_TAG,
+<a name="l00275"></a>00275         TIXML_ERROR_PARSING_UNKNOWN,
+<a name="l00276"></a>00276         TIXML_ERROR_PARSING_COMMENT,
+<a name="l00277"></a>00277         TIXML_ERROR_PARSING_DECLARATION,
+<a name="l00278"></a>00278         TIXML_ERROR_DOCUMENT_EMPTY,
+<a name="l00279"></a>00279         TIXML_ERROR_EMBEDDED_NULL,
+<a name="l00280"></a>00280         TIXML_ERROR_PARSING_CDATA,
+<a name="l00281"></a>00281         TIXML_ERROR_DOCUMENT_TOP_ONLY,
+<a name="l00282"></a>00282 
+<a name="l00283"></a>00283         TIXML_ERROR_STRING_COUNT
+<a name="l00284"></a>00284     };
+<a name="l00285"></a>00285 
+<a name="l00286"></a>00286 <span class="keyword">protected</span>:
+<a name="l00287"></a>00287 
+<a name="l00288"></a>00288     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* SkipWhiteSpace( <span class="keyword">const</span> <span class="keywordtype">char</span>*, TiXmlEncoding encoding );
+<a name="l00289"></a>00289 
+<a name="l00290"></a>00290     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsWhiteSpace( <span class="keywordtype">char</span> c )       
+<a name="l00291"></a>00291     { 
+<a name="l00292"></a>00292         <span class="keywordflow">return</span> ( isspace( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) c ) || c == <span class="charliteral">&#39;\n&#39;</span> || c == <span class="charliteral">&#39;\r&#39;</span> ); 
+<a name="l00293"></a>00293     }
+<a name="l00294"></a>00294     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsWhiteSpace( <span class="keywordtype">int</span> c )
+<a name="l00295"></a>00295     {
+<a name="l00296"></a>00296         <span class="keywordflow">if</span> ( c &lt; 256 )
+<a name="l00297"></a>00297             <span class="keywordflow">return</span> IsWhiteSpace( (<span class="keywordtype">char</span>) c );
+<a name="l00298"></a>00298         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// Again, only truly correct for English/Latin...but usually works.</span>
+<a name="l00299"></a>00299     }
+<a name="l00300"></a>00300 
+<a name="l00301"></a>00301 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00302"></a>00302 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">bool</span> StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+<a name="l00303"></a>00303     <span class="keyword">static</span> <span class="keywordtype">bool</span> StreamTo( std::istream * in, <span class="keywordtype">int</span> character, TIXML_STRING * tag );
+<a name="l00304"></a>00304 <span class="preprocessor">    #endif</span>
+<a name="l00305"></a>00305 <span class="preprocessor"></span>
+<a name="l00306"></a>00306     <span class="comment">/*  Reads an XML name into the string provided. Returns</span>
+<a name="l00307"></a>00307 <span class="comment">        a pointer just past the last character of the name,</span>
+<a name="l00308"></a>00308 <span class="comment">        or 0 if the function has an error.</span>
+<a name="l00309"></a>00309 <span class="comment">    */</span>
+<a name="l00310"></a>00310     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadName( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TIXML_STRING* name, TiXmlEncoding encoding );
+<a name="l00311"></a>00311 
+<a name="l00312"></a>00312     <span class="comment">/*  Reads text. Returns a pointer past the given end tag.</span>
+<a name="l00313"></a>00313 <span class="comment">        Wickedly complex options, but it keeps the (sensitive) code in one place.</span>
+<a name="l00314"></a>00314 <span class="comment">    */</span>
+<a name="l00315"></a>00315     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadText(    <span class="keyword">const</span> <span class="keywordtype">char</span>* in,             <span class="comment">// where to start</span>
+<a name="l00316"></a>00316                                     TIXML_STRING* text,         <span class="comment">// the string read</span>
+<a name="l00317"></a>00317                                     <span class="keywordtype">bool</span> ignoreWhiteSpace,      <span class="comment">// whether to keep the white space</span>
+<a name="l00318"></a>00318                                     <span class="keyword">const</span> <span class="keywordtype">char</span>* endTag,         <span class="comment">// what ends this text</span>
+<a name="l00319"></a>00319                                     <span class="keywordtype">bool</span> ignoreCase,            <span class="comment">// whether to ignore case in the end tag</span>
+<a name="l00320"></a>00320                                     TiXmlEncoding encoding );   <span class="comment">// the current encoding</span>
+<a name="l00321"></a>00321 
+<a name="l00322"></a>00322     <span class="comment">// If an entity has been found, transform it into a character.</span>
+<a name="l00323"></a>00323     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* GetEntity( <span class="keyword">const</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span>* length, TiXmlEncoding encoding );
+<a name="l00324"></a>00324 
+<a name="l00325"></a>00325     <span class="comment">// Get a character, while interpreting entities.</span>
+<a name="l00326"></a>00326     <span class="comment">// The length can be from 0 to 4 bytes.</span>
+<a name="l00327"></a>00327     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* GetChar( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, <span class="keywordtype">char</span>* _value, <span class="keywordtype">int</span>* length, TiXmlEncoding encoding )
+<a name="l00328"></a>00328     {
+<a name="l00329"></a>00329         assert( p );
+<a name="l00330"></a>00330         <span class="keywordflow">if</span> ( encoding == TIXML_ENCODING_UTF8 )
+<a name="l00331"></a>00331         {
+<a name="l00332"></a>00332             *length = utf8ByteTable[ *((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)p) ];
+<a name="l00333"></a>00333             assert( *length &gt;= 0 &amp;&amp; *length &lt; 5 );
+<a name="l00334"></a>00334         }
+<a name="l00335"></a>00335         <span class="keywordflow">else</span>
+<a name="l00336"></a>00336         {
+<a name="l00337"></a>00337             *length = 1;
+<a name="l00338"></a>00338         }
+<a name="l00339"></a>00339 
+<a name="l00340"></a>00340         <span class="keywordflow">if</span> ( *length == 1 )
+<a name="l00341"></a>00341         {
+<a name="l00342"></a>00342             <span class="keywordflow">if</span> ( *p == <span class="charliteral">&#39;&amp;&#39;</span> )
+<a name="l00343"></a>00343                 <span class="keywordflow">return</span> GetEntity( p, _value, length, encoding );
+<a name="l00344"></a>00344             *_value = *p;
+<a name="l00345"></a>00345             <span class="keywordflow">return</span> p+1;
+<a name="l00346"></a>00346         }
+<a name="l00347"></a>00347         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( *length )
+<a name="l00348"></a>00348         {
+<a name="l00349"></a>00349             <span class="comment">//strncpy( _value, p, *length );    // lots of compilers don&#39;t like this function (unsafe),</span>
+<a name="l00350"></a>00350                                                 <span class="comment">// and the null terminator isn&#39;t needed</span>
+<a name="l00351"></a>00351             <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; p[i] &amp;&amp; i&lt;*length; ++i ) {
+<a name="l00352"></a>00352                 _value[i] = p[i];
+<a name="l00353"></a>00353             }
+<a name="l00354"></a>00354             <span class="keywordflow">return</span> p + (*length);
+<a name="l00355"></a>00355         }
+<a name="l00356"></a>00356         <span class="keywordflow">else</span>
+<a name="l00357"></a>00357         {
+<a name="l00358"></a>00358             <span class="comment">// Not valid text.</span>
+<a name="l00359"></a>00359             <span class="keywordflow">return</span> 0;
+<a name="l00360"></a>00360         }
+<a name="l00361"></a>00361     }
+<a name="l00362"></a>00362 
+<a name="l00363"></a>00363     <span class="comment">// Return true if the next characters in the stream are any of the endTag sequences.</span>
+<a name="l00364"></a>00364     <span class="comment">// Ignore case only works for english, and should only be relied on when comparing</span>
+<a name="l00365"></a>00365     <span class="comment">// to English words: StringEqual( p, &quot;version&quot;, true ) is fine.</span>
+<a name="l00366"></a>00366     <span class="keyword">static</span> <span class="keywordtype">bool</span> StringEqual(    <span class="keyword">const</span> <span class="keywordtype">char</span>* p,
+<a name="l00367"></a>00367                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* endTag,
+<a name="l00368"></a>00368                                 <span class="keywordtype">bool</span> ignoreCase,
+<a name="l00369"></a>00369                                 TiXmlEncoding encoding );
+<a name="l00370"></a>00370 
+<a name="l00371"></a>00371     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* errorString[ TIXML_ERROR_STRING_COUNT ];
+<a name="l00372"></a>00372 
+<a name="l00373"></a>00373     TiXmlCursor location;
+<a name="l00374"></a>00374 
+<a name="l00376"></a><a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c">00376</a>     <span class="keywordtype">void</span>*           <a class="code" href="classTiXmlBase.html#ab242c01590191f644569fa89a080d97c" title="Field containing a generic user pointer.">userData</a>;
+<a name="l00377"></a>00377     
+<a name="l00378"></a>00378     <span class="comment">// None of these methods are reliable for any language except English.</span>
+<a name="l00379"></a>00379     <span class="comment">// Good for approximation, not great for accuracy.</span>
+<a name="l00380"></a>00380     <span class="keyword">static</span> <span class="keywordtype">int</span> IsAlpha( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> anyByte, TiXmlEncoding encoding );
+<a name="l00381"></a>00381     <span class="keyword">static</span> <span class="keywordtype">int</span> IsAlphaNum( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> anyByte, TiXmlEncoding encoding );
+<a name="l00382"></a>00382     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> ToLower( <span class="keywordtype">int</span> v, TiXmlEncoding encoding )
+<a name="l00383"></a>00383     {
+<a name="l00384"></a>00384         <span class="keywordflow">if</span> ( encoding == TIXML_ENCODING_UTF8 )
+<a name="l00385"></a>00385         {
+<a name="l00386"></a>00386             <span class="keywordflow">if</span> ( v &lt; 128 ) <span class="keywordflow">return</span> tolower( v );
+<a name="l00387"></a>00387             <span class="keywordflow">return</span> v;
+<a name="l00388"></a>00388         }
+<a name="l00389"></a>00389         <span class="keywordflow">else</span>
+<a name="l00390"></a>00390         {
+<a name="l00391"></a>00391             <span class="keywordflow">return</span> tolower( v );
+<a name="l00392"></a>00392         }
+<a name="l00393"></a>00393     }
+<a name="l00394"></a>00394     <span class="keyword">static</span> <span class="keywordtype">void</span> ConvertUTF32ToUTF8( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> input, <span class="keywordtype">char</span>* output, <span class="keywordtype">int</span>* length );
+<a name="l00395"></a>00395 
+<a name="l00396"></a>00396 <span class="keyword">private</span>:
+<a name="l00397"></a>00397     <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>&amp; );              <span class="comment">// not implemented.</span>
+<a name="l00398"></a>00398     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>&amp; base );    <span class="comment">// not allowed.</span>
+<a name="l00399"></a>00399 
+<a name="l00400"></a>00400     <span class="keyword">struct </span>Entity
+<a name="l00401"></a>00401     {
+<a name="l00402"></a>00402         <span class="keyword">const</span> <span class="keywordtype">char</span>*     str;
+<a name="l00403"></a>00403         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    strLength;
+<a name="l00404"></a>00404         <span class="keywordtype">char</span>            chr;
+<a name="l00405"></a>00405     };
+<a name="l00406"></a>00406     <span class="keyword">enum</span>
+<a name="l00407"></a>00407     {
+<a name="l00408"></a>00408         NUM_ENTITY = 5,
+<a name="l00409"></a>00409         MAX_ENTITY_LENGTH = 6
+<a name="l00410"></a>00410 
+<a name="l00411"></a>00411     };
+<a name="l00412"></a>00412     <span class="keyword">static</span> Entity entity[ NUM_ENTITY ];
+<a name="l00413"></a>00413     <span class="keyword">static</span> <span class="keywordtype">bool</span> condenseWhiteSpace;
+<a name="l00414"></a>00414 };
+<a name="l00415"></a>00415 
+<a name="l00416"></a>00416 
+<a name="l00423"></a><a class="code" href="classTiXmlNode.html">00423</a> <span class="keyword">class </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>
+<a name="l00424"></a>00424 {
+<a name="l00425"></a>00425     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>;
+<a name="l00426"></a>00426     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l00427"></a>00427 
+<a name="l00428"></a>00428 <span class="keyword">public</span>:
+<a name="l00429"></a>00429 <span class="preprocessor">    #ifdef TIXML_USE_STL    </span>
+<a name="l00430"></a>00430 <span class="preprocessor"></span>
+<a name="l00434"></a>00434         <span class="keyword">friend</span> std::istream&amp; <a class="code" href="classTiXmlNode.html#ab57bd426563c926844f65a78412e18b9" title="An input stream operator, for every class.">operator &gt;&gt; </a>(std::istream&amp; in, <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base);
+<a name="l00435"></a>00435 
+<a name="l00452"></a>00452         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7" title="An output stream operator, for every class.">operator&lt;&lt; </a>(std::ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base);
+<a name="l00453"></a>00453 
+<a name="l00455"></a>00455         <span class="keyword">friend</span> std::string&amp; <a class="code" href="classTiXmlNode.html#a86cd49cfb17a844c0010b3136ac966c7" title="An output stream operator, for every class.">operator&lt;&lt; </a>(std::string&amp; out, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base );
+<a name="l00456"></a>00456 
+<a name="l00457"></a>00457 <span class="preprocessor">    #endif</span>
+<a name="l00458"></a>00458 <span class="preprocessor"></span>
+<a name="l00462"></a><a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2">00462</a>     <span class="keyword">enum</span> <a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2" title="The types of XML nodes supported by TinyXml.">NodeType</a>
+<a name="l00463"></a>00463     {
+<a name="l00464"></a>00464         TINYXML_DOCUMENT,
+<a name="l00465"></a>00465         TINYXML_ELEMENT,
+<a name="l00466"></a>00466         TINYXML_COMMENT,
+<a name="l00467"></a>00467         TINYXML_UNKNOWN,
+<a name="l00468"></a>00468         TINYXML_TEXT,
+<a name="l00469"></a>00469         TINYXML_DECLARATION,
+<a name="l00470"></a>00470         TINYXML_TYPECOUNT
+<a name="l00471"></a>00471     };
+<a name="l00472"></a>00472 
+<a name="l00473"></a>00473     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>();
+<a name="l00474"></a>00474 
+<a name="l00487"></a><a class="code" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41">00487</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlNode.html#a77943eb90d12c2892b1337a9f5918b41" title="The meaning of &amp;#39;value&amp;#39; changes for the specific type of TiXmlNode.">Value</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value.c_str (); }
+<a name="l00488"></a>00488 
+<a name="l00489"></a>00489 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00490"></a>00490 <span class="preprocessor"></span>
+<a name="l00494"></a><a class="code" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5">00494</a>     <span class="keyword">const</span> std::string&amp; <a class="code" href="classTiXmlNode.html#a6d9e505619d39bf50bfd9609c9169ea5" title="Return Value() as a std::string.">ValueStr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }
+<a name="l00495"></a>00495 <span class="preprocessor">    #endif</span>
+<a name="l00496"></a>00496 <span class="preprocessor"></span>
+<a name="l00497"></a>00497     <span class="keyword">const</span> TIXML_STRING&amp; ValueTStr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }
+<a name="l00498"></a>00498 
+<a name="l00508"></a><a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90">00508</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * _value) { value = _value;}
+<a name="l00509"></a>00509 
+<a name="l00510"></a>00510 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00512"></a><a class="code" href="classTiXmlNode.html#a2598d5f448042c1abbeae4503dd45ff2">00512</a> <span class="preprocessor">    void SetValue( const std::string&amp; _value )  { value = _value; }</span>
+<a name="l00513"></a>00513 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00514"></a>00514 <span class="preprocessor"></span>
+<a name="l00516"></a>00516     <span class="keywordtype">void</span> <a class="code" href="classTiXmlNode.html#a708e7f953df61d4d2d12f73171550a4b" title="Delete all the children of this node. Does not affect &amp;#39;this&amp;#39;.">Clear</a>();
+<a name="l00517"></a>00517 
+<a name="l00519"></a><a class="code" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e">00519</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e" title="One step up the DOM.">Parent</a>()                         { <span class="keywordflow">return</span> parent; }
+<a name="l00520"></a>00520     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ab643043132ffd794f8602685d34a982e" title="One step up the DOM.">Parent</a>()<span class="keyword"> const             </span>{ <span class="keywordflow">return</span> parent; }
+<a name="l00521"></a>00521 
+<a name="l00522"></a><a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0">00522</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0" title="The first child of this node. Will be null if there are no children.">FirstChild</a>()<span class="keyword">   const       </span>{ <span class="keywordflow">return</span> firstChild; }  
+<a name="l00523"></a>00523     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0" title="The first child of this node. Will be null if there are no children.">FirstChild</a>()                     { <span class="keywordflow">return</span> firstChild; }
+<a name="l00524"></a>00524     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a44c8eee26bbe2d1b2762038df9dde2f0" title="The first child of this node. Will be null if there are no children.">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;            
+<a name="l00525"></a>00525 
+<a name="l00526"></a><a class="code" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554">00526</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#abc8bf32be6419ec453a731868de19554" title="The first child of this node with the matching &amp;#39;value&amp;#39;. Will be null if none...">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00527"></a>00527         <span class="comment">// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)</span>
+<a name="l00528"></a>00528         <span class="comment">// call the method, cast the return back to non-const.</span>
+<a name="l00529"></a>00529         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span> ((<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;FirstChild( _value ));
+<a name="l00530"></a>00530     }
+<a name="l00531"></a>00531     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* LastChild()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> lastChild; }       
+<a name="l00532"></a><a class="code" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031">00532</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a6432d2b2495f6caf9cb4278df706a031" title="The last child of this node. Will be null if there are no children.">LastChild</a>()  { <span class="keywordflow">return</span> lastChild; }
+<a name="l00533"></a>00533     
+<a name="l00534"></a>00534     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* LastChild( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;         
+<a name="l00535"></a><a class="code" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d">00535</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#abad5bf1059c48127b958711ef89e8e5d" title="The last child of this node matching &amp;#39;value&amp;#39;. Will be null if there are no...">LastChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00536"></a>00536         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span> ((<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;LastChild( _value ));
+<a name="l00537"></a>00537     }
+<a name="l00538"></a>00538 
+<a name="l00539"></a>00539 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00540"></a><a class="code" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6">00540</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6" title="STL std::string form.">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const  </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a07f6200a5956c723c5b52d70f29c46f6" title="STL std::string form.">FirstChild</a> (_value.c_str ());    }   
+<a name="l00541"></a><a class="code" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6">00541</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6" title="STL std::string form.">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )              {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a10d2669ccb5e29e02fcb0e4408685ef6" title="STL std::string form.">FirstChild</a> (_value.c_str ());    }   
+<a name="l00542"></a><a class="code" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63">00542</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63" title="STL std::string form.">LastChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const   </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a256d0cdbfcfeccae83f3a1c9747a8b63" title="STL std::string form.">LastChild</a> (_value.c_str ()); }   
+<a name="l00543"></a><a class="code" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3">00543</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3" title="STL std::string form.">LastChild</a>( <span class="keyword">const</span> std::string&amp; _value )               {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a69772c9202f70553f940b15c06b07be3" title="STL std::string form.">LastChild</a> (_value.c_str ()); }   
+<a name="l00544"></a>00544 <span class="preprocessor">    #endif</span>
+<a name="l00545"></a>00545 <span class="preprocessor"></span>
+<a name="l00562"></a>00562     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) <span class="keyword">const</span>;
+<a name="l00563"></a>00563     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) {
+<a name="l00564"></a>00564         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;IterateChildren( previous ) );
+<a name="l00565"></a>00565     }
+<a name="l00566"></a>00566 
+<a name="l00568"></a>00568     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) <span class="keyword">const</span>;
+<a name="l00569"></a>00569     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a8621196ba3705fa226bef4a761cc51b6" title="An alternate way to walk the children of a node.">IterateChildren</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) {
+<a name="l00570"></a>00570         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;IterateChildren( _value, previous ) );
+<a name="l00571"></a>00571     }
+<a name="l00572"></a>00572 
+<a name="l00573"></a>00573 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00574"></a><a class="code" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df">00574</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df" title="STL std::string form.">IterateChildren</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous )<span class="keyword"> const  </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a1cbaaf8e82c09ad763d52616d75724df" title="STL std::string form.">IterateChildren</a> (_value.c_str (), previous); }   
+<a name="l00575"></a><a class="code" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c">00575</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c" title="STL std::string form.">IterateChildren</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* previous ) {    <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a16e9ad53e2f5445b14bf325c90aa862c" title="STL std::string form.">IterateChildren</a> (_value.c_str (), previous); }   
+<a name="l00576"></a>00576 <span class="preprocessor">    #endif</span>
+<a name="l00577"></a>00577 <span class="preprocessor"></span>
+<a name="l00581"></a>00581     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ad7d4630e1a2a916edda16be22448a8ba" title="Add a new node related to this.">InsertEndChild</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; addThis );
+<a name="l00582"></a>00582 
+<a name="l00583"></a>00583 
+<a name="l00593"></a>00593     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a5d29442ae46de6d0168429156197bfc6" title="Add a new node related to this.">LinkEndChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* addThis );
+<a name="l00594"></a>00594 
+<a name="l00598"></a>00598     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a0c146fa2fff0157b681594102f48cbc7" title="Add a new node related to this.">InsertBeforeChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* beforeThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; addThis );
+<a name="l00599"></a>00599 
+<a name="l00603"></a>00603     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ad9b75e54ec19301c8b4d5ff583d0b3d5" title="Add a new node related to this.">InsertAfterChild</a>(  <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* afterThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; addThis );
+<a name="l00604"></a>00604 
+<a name="l00608"></a>00608     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a0c49e739a17b9938050c22cd89617fbd" title="Replace a child of this node.">ReplaceChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* replaceThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; withThis );
+<a name="l00609"></a>00609 
+<a name="l00611"></a>00611     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#ae19d8510efc90596552f4feeac9a8fbf" title="Delete a child of this node.">RemoveChild</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* removeThis );
+<a name="l00612"></a>00612 
+<a name="l00614"></a><a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10">00614</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>()<span class="keyword"> const            </span>{ <span class="keywordflow">return</span> prev; }
+<a name="l00615"></a>00615     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>()                        { <span class="keywordflow">return</span> prev; }
+<a name="l00616"></a>00616 
+<a name="l00618"></a>00618     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00619"></a>00619     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#ac2cd892768726270e511b2ab32de4d10" title="Navigate to a sibling node.">PreviousSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *_prev ) {
+<a name="l00620"></a>00620         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;PreviousSibling( _prev ) );
+<a name="l00621"></a>00621     }
+<a name="l00622"></a>00622 
+<a name="l00623"></a>00623 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00624"></a><a class="code" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab">00624</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab" title="STL std::string form.">PreviousSibling</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a658276f57d35d5d4256d1dc1a2c398ab" title="STL std::string form.">PreviousSibling</a> (_value.c_str ());   }   
+<a name="l00625"></a><a class="code" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912">00625</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912" title="STL std::string form.">PreviousSibling</a>( <span class="keyword">const</span> std::string&amp; _value )             {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#acc8a0434c7f401d4a3b6dee77c1a5912" title="STL std::string form.">PreviousSibling</a> (_value.c_str ());   }   
+<a name="l00626"></a><a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9">00626</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>( <span class="keyword">const</span> std::string&amp; _value)<span class="keyword"> const      </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a> (_value.c_str ());   }   
+<a name="l00627"></a><a class="code" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea">00627</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea" title="STL std::string form.">NextSibling</a>( <span class="keyword">const</span> std::string&amp; _value)                  {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a1757c1f4d01e8c9596ffdbd561c76aea" title="STL std::string form.">NextSibling</a> (_value.c_str ());   }   
+<a name="l00628"></a>00628 <span class="preprocessor">    #endif</span>
+<a name="l00629"></a>00629 <span class="preprocessor"></span>
+<a name="l00631"></a><a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e">00631</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>()<span class="keyword"> const                </span>{ <span class="keywordflow">return</span> next; }
+<a name="l00632"></a>00632     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>()                            { <span class="keywordflow">return</span> next; }
+<a name="l00633"></a>00633 
+<a name="l00635"></a>00635     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00636"></a>00636     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#af854baeba384f5fe9859f5aee03b548e" title="Navigate to a sibling node.">NextSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _next ) {
+<a name="l00637"></a>00637         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;NextSibling( _next ) );
+<a name="l00638"></a>00638     }
+<a name="l00639"></a>00639 
+<a name="l00644"></a>00644     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>() <span class="keyword">const</span>;
+<a name="l00645"></a>00645     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>() {
+<a name="l00646"></a>00646         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;NextSiblingElement() );
+<a name="l00647"></a>00647     }
+<a name="l00648"></a>00648 
+<a name="l00653"></a>00653     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00654"></a>00654     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a73acf929d49d10bd0e5fb3d31b0372d1" title="Convenience function to get through elements.">NextSiblingElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *_next ) {
+<a name="l00655"></a>00655         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;NextSiblingElement( _next ) );
+<a name="l00656"></a>00656     }
+<a name="l00657"></a>00657 
+<a name="l00658"></a>00658 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00659"></a><a class="code" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463">00659</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463" title="STL std::string form.">NextSiblingElement</a>( <span class="keyword">const</span> std::string&amp; _value)<span class="keyword"> const    </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a7572d0af9d1e696ee3f05d8bb5ebb463" title="STL std::string form.">NextSiblingElement</a> (_value.c_str ());    }   
+<a name="l00660"></a><a class="code" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081">00660</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081" title="STL std::string form.">NextSiblingElement</a>( <span class="keyword">const</span> std::string&amp; _value)                {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a506958e34406729a4e4c5326ea39d081" title="STL std::string form.">NextSiblingElement</a> (_value.c_str ());    }   
+<a name="l00661"></a>00661 <span class="preprocessor">    #endif</span>
+<a name="l00662"></a>00662 <span class="preprocessor"></span>
+<a name="l00664"></a>00664     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>() <span class="keyword">const</span>;
+<a name="l00665"></a>00665     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>() {
+<a name="l00666"></a>00666         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;FirstChildElement() );
+<a name="l00667"></a>00667     }
+<a name="l00668"></a>00668 
+<a name="l00670"></a>00670     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) <span class="keyword">const</span>;
+<a name="l00671"></a>00671     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00672"></a>00672         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;FirstChildElement( _value ) );
+<a name="l00673"></a>00673     }
+<a name="l00674"></a>00674 
+<a name="l00675"></a>00675 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00676"></a><a class="code" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7">00676</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7" title="STL std::string form.">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const    </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a327ad4bbd90073c5dfc931b07314f5f7" title="STL std::string form.">FirstChildElement</a> (_value.c_str ()); }   
+<a name="l00677"></a><a class="code" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45">00677</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45" title="STL std::string form.">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )                {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#a7f1d7291880534c1e5cdeb392d8c1f45" title="STL std::string form.">FirstChildElement</a> (_value.c_str ()); }   
+<a name="l00678"></a>00678 <span class="preprocessor">    #endif</span>
+<a name="l00679"></a>00679 <span class="preprocessor"></span>
+<a name="l00684"></a><a class="code" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e">00684</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlNode.html#a57b99d5c97d67a42b9752f5210a1ba5e" title="Query the type (as an enumerated value, above) of this node.">Type</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> type; }
+<a name="l00685"></a>00685 
+<a name="l00689"></a>00689     <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* <a class="code" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3" title="Return a pointer to the Document this node lives in.">GetDocument</a>() <span class="keyword">const</span>;
+<a name="l00690"></a>00690     <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* <a class="code" href="classTiXmlNode.html#a80e397fa973cf5323e33b07154b024f3" title="Return a pointer to the Document this node lives in.">GetDocument</a>() {
+<a name="l00691"></a>00691         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;GetDocument() );
+<a name="l00692"></a>00692     }
+<a name="l00693"></a>00693 
+<a name="l00695"></a><a class="code" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3">00695</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#aeed21ad30630ef6e7faf096127edc9f3" title="Returns true if this node has no children.">NoChildren</a>()<span class="keyword"> const                     </span>{ <span class="keywordflow">return</span> !firstChild; }
+<a name="l00696"></a>00696 
+<a name="l00697"></a><a class="code" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08">00697</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*    <a class="code" href="classTiXmlNode.html#a8a4cda4b15c29f64cff419309aebed08" title="Cast to a more defined type. Will return null if not of the requested type.">ToDocument</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00698"></a><a class="code" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c">00698</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*     <a class="code" href="classTiXmlNode.html#a72abed96dc9667ab9e0a2a275301bb1c" title="Cast to a more defined type. Will return null if not of the requested type.">ToElement</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00699"></a><a class="code" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574">00699</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*     <a class="code" href="classTiXmlNode.html#aa0a5086f9eaee910bbfdc7f975e26574" title="Cast to a more defined type. Will return null if not of the requested type.">ToComment</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00700"></a><a class="code" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2">00700</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*     <a class="code" href="classTiXmlNode.html#afd7205cf31d7a376929f8a36930627a2" title="Cast to a more defined type. Will return null if not of the requested type.">ToUnknown</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00701"></a><a class="code" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69">00701</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>*        <a class="code" href="classTiXmlNode.html#a95a46a52c525992d6b4ee08beb14cd69" title="Cast to a more defined type. Will return null if not of the requested type.">ToText</a>()<span class="keyword">        const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00702"></a><a class="code" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72">00702</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>* <a class="code" href="classTiXmlNode.html#a9f43e6984fc7d4afd6eb32714c6b7b72" title="Cast to a more defined type. Will return null if not of the requested type.">ToDeclaration</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00703"></a>00703 
+<a name="l00704"></a><a class="code" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae">00704</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*          <a class="code" href="classTiXmlNode.html#a6a4c8ac28ee7a745d059db6691e03bae" title="Cast to a more defined type. Will return null if not of the requested type.">ToDocument</a>()    { <span class="keywordflow">return</span> 0; } 
+<a name="l00705"></a><a class="code" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc">00705</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*           <a class="code" href="classTiXmlNode.html#aa65d000223187d22a4dcebd7479e9ebc" title="Cast to a more defined type. Will return null if not of the requested type.">ToElement</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00706"></a><a class="code" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849">00706</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*           <a class="code" href="classTiXmlNode.html#a383e06a0787f7063953934867990f849" title="Cast to a more defined type. Will return null if not of the requested type.">ToComment</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00707"></a><a class="code" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d">00707</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*           <a class="code" href="classTiXmlNode.html#a06de5af852668c7e4af0d09c205f0b0d" title="Cast to a more defined type. Will return null if not of the requested type.">ToUnknown</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00708"></a><a class="code" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03">00708</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>*              <a class="code" href="classTiXmlNode.html#a3ddfbcac78fbea041fad57e5c6d60a03" title="Cast to a more defined type. Will return null if not of the requested type.">ToText</a>()        { <span class="keywordflow">return</span> 0; } 
+<a name="l00709"></a><a class="code" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df">00709</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>*       <a class="code" href="classTiXmlNode.html#a4027136ca820ff4a636b607231b6a6df" title="Cast to a more defined type. Will return null if not of the requested type.">ToDeclaration</a>() { <span class="keywordflow">return</span> 0; } 
+<a name="l00710"></a>00710 
+<a name="l00714"></a>00714     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#a4508cc3a2d7a98e96a54cc09c37a78a4" title="Create an exact duplicate of this node and return it.">Clone</a>() <span class="keyword">const</span> = 0;
+<a name="l00715"></a>00715 
+<a name="l00738"></a>00738     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#acc0f88b7462c6cb73809d410a4f5bb86" title="Accept a hierchical visit the nodes in the TinyXML DOM.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span> = 0;
+<a name="l00739"></a>00739 
+<a name="l00740"></a>00740 <span class="keyword">protected</span>:
+<a name="l00741"></a>00741     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2" title="The types of XML nodes supported by TinyXml.">NodeType</a> _type );
+<a name="l00742"></a>00742 
+<a name="l00743"></a>00743     <span class="comment">// Copy to the allocated object. Shared functionality between Clone, Copy constructor,</span>
+<a name="l00744"></a>00744     <span class="comment">// and the assignment operator.</span>
+<a name="l00745"></a>00745     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* target ) <span class="keyword">const</span>;
+<a name="l00746"></a>00746 
+<a name="l00747"></a>00747 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00748"></a>00748 <span class="preprocessor"></span>        <span class="comment">// The real work of the input operator.</span>
+<a name="l00749"></a>00749     <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+<a name="l00750"></a>00750 <span class="preprocessor">    #endif</span>
+<a name="l00751"></a>00751 <span class="preprocessor"></span>
+<a name="l00752"></a>00752     <span class="comment">// Figure out what is at *p, and parse it. Returns null if it is not an xml node.</span>
+<a name="l00753"></a>00753     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* Identify( <span class="keyword">const</span> <span class="keywordtype">char</span>* start, TiXmlEncoding encoding );
+<a name="l00754"></a>00754 
+<a name="l00755"></a>00755     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      parent;
+<a name="l00756"></a>00756     <a class="code" href="classTiXmlNode.html#a836eded4920ab9e9ef28496f48cd95a2" title="The types of XML nodes supported by TinyXml.">NodeType</a>        type;
+<a name="l00757"></a>00757 
+<a name="l00758"></a>00758     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      firstChild;
+<a name="l00759"></a>00759     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      lastChild;
+<a name="l00760"></a>00760 
+<a name="l00761"></a>00761     TIXML_STRING    value;
+<a name="l00762"></a>00762 
+<a name="l00763"></a>00763     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      prev;
+<a name="l00764"></a>00764     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>*      next;
+<a name="l00765"></a>00765 
+<a name="l00766"></a>00766 <span class="keyword">private</span>:
+<a name="l00767"></a>00767     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; );              <span class="comment">// not implemented.</span>
+<a name="l00768"></a>00768     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>&amp; base );    <span class="comment">// not allowed.</span>
+<a name="l00769"></a>00769 };
+<a name="l00770"></a>00770 
+<a name="l00771"></a>00771 
+<a name="l00779"></a><a class="code" href="classTiXmlAttribute.html">00779</a> <span class="keyword">class </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>
+<a name="l00780"></a>00780 {
+<a name="l00781"></a>00781     <span class="keyword">friend</span> <span class="keyword">class </span>TiXmlAttributeSet;
+<a name="l00782"></a>00782 
+<a name="l00783"></a>00783 <span class="keyword">public</span>:
+<a name="l00785"></a><a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1">00785</a>     <a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1" title="Construct an empty attribute.">TiXmlAttribute</a>() : <a class="code" href="classTiXmlBase.html" title="TiXmlBase is a base class for every class in TinyXml.">TiXmlBase</a>()
+<a name="l00786"></a>00786     {
+<a name="l00787"></a>00787         document = 0;
+<a name="l00788"></a>00788         prev = next = 0;
+<a name="l00789"></a>00789     }
+<a name="l00790"></a>00790 
+<a name="l00791"></a>00791 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00793"></a><a class="code" href="classTiXmlAttribute.html#a052213522caac3979960e0714063861d">00793</a> <span class="preprocessor">    TiXmlAttribute( const std::string&amp; _name, const std::string&amp; _value )</span>
+<a name="l00794"></a>00794 <span class="preprocessor"></span>    {
+<a name="l00795"></a>00795         name = _name;
+<a name="l00796"></a>00796         value = _value;
+<a name="l00797"></a>00797         document = 0;
+<a name="l00798"></a>00798         prev = next = 0;
+<a name="l00799"></a>00799     }
+<a name="l00800"></a>00800 <span class="preprocessor">    #endif</span>
+<a name="l00801"></a>00801 <span class="preprocessor"></span>
+<a name="l00803"></a><a class="code" href="classTiXmlAttribute.html#a759d0b76fb8fcf765ecab243bc14f05e">00803</a>     <a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1" title="Construct an empty attribute.">TiXmlAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _name, <span class="keyword">const</span> <span class="keywordtype">char</span> * _value )
+<a name="l00804"></a>00804     {
+<a name="l00805"></a>00805         name = _name;
+<a name="l00806"></a>00806         value = _value;
+<a name="l00807"></a>00807         document = 0;
+<a name="l00808"></a>00808         prev = next = 0;
+<a name="l00809"></a>00809     }
+<a name="l00810"></a>00810 
+<a name="l00811"></a><a class="code" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d">00811</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classTiXmlAttribute.html#a298a57287d305904ba6bd96ae6f78d3d" title="Return the name of this attribute.">Name</a>()<span class="keyword">  const       </span>{ <span class="keywordflow">return</span> name.c_str(); }        
+<a name="l00812"></a><a class="code" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3">00812</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classTiXmlAttribute.html#a0f874490eac8ca00ee0070765d0e97e3" title="Return the value of this attribute.">Value</a>()<span class="keyword"> const       </span>{ <span class="keywordflow">return</span> value.c_str(); }       
+<a name="l00813"></a>00813 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00814"></a><a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33">00814</a> <span class="preprocessor"></span>    <span class="keyword">const</span> std::string&amp; <a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33" title="Return the value of this attribute.">ValueStr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }               
+<a name="l00815"></a>00815 <span class="preprocessor">    #endif</span>
+<a name="l00816"></a>00816 <span class="preprocessor"></span>    <span class="keywordtype">int</span>             <a class="code" href="classTiXmlAttribute.html#aa1a20ad59dc7e89a0ab265396360d50f" title="Return the value of this attribute, converted to an integer.">IntValue</a>() <span class="keyword">const</span>;                                   
+<a name="l00817"></a>00817     <span class="keywordtype">double</span>          <a class="code" href="classTiXmlAttribute.html#a2880ddef53fc7522c99535273954d230" title="Return the value of this attribute, converted to a double.">DoubleValue</a>() <span class="keyword">const</span>;                                
+<a name="l00818"></a>00818 
+<a name="l00819"></a>00819     <span class="comment">// Get the tinyxml string representation</span>
+<a name="l00820"></a>00820     <span class="keyword">const</span> TIXML_STRING&amp; NameTStr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name; }
+<a name="l00821"></a>00821 
+<a name="l00831"></a>00831     <span class="keywordtype">int</span> <a class="code" href="classTiXmlAttribute.html#ad6c93088ee21af41a107931223339344" title="QueryIntValue examines the value string.">QueryIntValue</a>( <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l00833"></a>00833     <span class="keywordtype">int</span> <a class="code" href="classTiXmlAttribute.html#ac87b2a8489906a5d7aa2875f20be3513" title="QueryDoubleValue examines the value string. See QueryIntValue().">QueryDoubleValue</a>( <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l00834"></a>00834 
+<a name="l00835"></a><a class="code" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99">00835</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#ab7fa3d21ff8d7c5764cf9af15b667a99" title="Set the name of this attribute.">SetName</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name )   { name = _name; }               
+<a name="l00836"></a><a class="code" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0">00836</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#a2dae44178f668b3cb48101be4f2236a0" title="Set the value.">SetValue</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _value ) { value = _value; }             
+<a name="l00837"></a>00837 
+<a name="l00838"></a>00838     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#a7e065df640116a62ea4f4b7da5449cc8" title="Set the value from an integer.">SetIntValue</a>( <span class="keywordtype">int</span> _value );                                     
+<a name="l00839"></a>00839     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#a0316da31373496c4368ad549bf711394" title="Set the value from a double.">SetDoubleValue</a>( <span class="keywordtype">double</span> _value );                               
+<a name="l00840"></a>00840 
+<a name="l00841"></a>00841 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00843"></a><a class="code" href="classTiXmlAttribute.html#ab296ff0c9a8c701055cd257a8a976e57">00843</a> <span class="preprocessor">    void SetName( const std::string&amp; _name )    { name = _name; }   </span>
+<a name="l00845"></a><a class="code" href="classTiXmlAttribute.html#ab43f67a0cc3ec1d80e62606500f0925f">00845</a> <span class="preprocessor">    void SetValue( const std::string&amp; _value )  { value = _value; }</span>
+<a name="l00846"></a>00846 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00847"></a>00847 <span class="preprocessor"></span>
+<a name="l00849"></a>00849     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67" title="Get the next sibling attribute in the DOM. Returns null at end.">Next</a>() <span class="keyword">const</span>;
+<a name="l00850"></a>00850     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a1c78e92e223a40843f644ba48ef69f67" title="Get the next sibling attribute in the DOM. Returns null at end.">Next</a>() {
+<a name="l00851"></a>00851         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;Next() ); 
+<a name="l00852"></a>00852     }
+<a name="l00853"></a>00853 
+<a name="l00855"></a>00855     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf" title="Get the previous sibling attribute in the DOM. Returns null at beginning.">Previous</a>() <span class="keyword">const</span>;
+<a name="l00856"></a>00856     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#a6ebbfe333fe76cd834bd6cbcca3130cf" title="Get the previous sibling attribute in the DOM. Returns null at beginning.">Previous</a>() {
+<a name="l00857"></a>00857         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>( (<span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;Previous() ); 
+<a name="l00858"></a>00858     }
+<a name="l00859"></a>00859 
+<a name="l00860"></a>00860     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; rhs )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rhs.name == name; }
+<a name="l00861"></a>00861     <span class="keywordtype">bool</span> operator&lt;( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; rhs )<span class="keyword">  const </span>{ <span class="keywordflow">return</span> name &lt; rhs.name; }
+<a name="l00862"></a>00862     <span class="keywordtype">bool</span> operator&gt;( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; rhs )<span class="keyword">  const </span>{ <span class="keywordflow">return</span> name &gt; rhs.name; }
+<a name="l00863"></a>00863 
+<a name="l00864"></a>00864     <span class="comment">/*  Attribute parsing starts: first letter of the name</span>
+<a name="l00865"></a>00865 <span class="comment">                         returns: the next char after the value end quote</span>
+<a name="l00866"></a>00866 <span class="comment">    */</span>
+<a name="l00867"></a>00867     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l00868"></a>00868 
+<a name="l00869"></a>00869     <span class="comment">// Prints this Attribute to a FILE stream.</span>
+<a name="l00870"></a><a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a">00870</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth )<span class="keyword"> const </span>{
+<a name="l00871"></a>00871         <a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( cfile, depth, 0 );
+<a name="l00872"></a>00872     }
+<a name="l00873"></a>00873     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#acc04956c1d5c4c31fe74f7a7528d109a" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth, TIXML_STRING* str ) <span class="keyword">const</span>;
+<a name="l00874"></a>00874 
+<a name="l00875"></a>00875     <span class="comment">// [internal use]</span>
+<a name="l00876"></a>00876     <span class="comment">// Set the document pointer so the attribute can report errors.</span>
+<a name="l00877"></a>00877     <span class="keywordtype">void</span> SetDocument( <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* doc )  { document = doc; }
+<a name="l00878"></a>00878 
+<a name="l00879"></a>00879 <span class="keyword">private</span>:
+<a name="l00880"></a>00880     <a class="code" href="classTiXmlAttribute.html#a9cfa3c8179873fd485d83003b114f8e1" title="Construct an empty attribute.">TiXmlAttribute</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; );                <span class="comment">// not implemented.</span>
+<a name="l00881"></a>00881     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>&amp; base );   <span class="comment">// not allowed.</span>
+<a name="l00882"></a>00882 
+<a name="l00883"></a>00883     <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*  document;   <span class="comment">// A pointer back to a document, for error reporting.</span>
+<a name="l00884"></a>00884     TIXML_STRING name;
+<a name="l00885"></a>00885     TIXML_STRING value;
+<a name="l00886"></a>00886     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* prev;
+<a name="l00887"></a>00887     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* next;
+<a name="l00888"></a>00888 };
+<a name="l00889"></a>00889 
+<a name="l00890"></a>00890 
+<a name="l00891"></a>00891 <span class="comment">/*  A class used to manage a group of attributes.</span>
+<a name="l00892"></a>00892 <span class="comment">    It is only used internally, both by the ELEMENT and the DECLARATION.</span>
+<a name="l00893"></a>00893 <span class="comment">    </span>
+<a name="l00894"></a>00894 <span class="comment">    The set can be changed transparent to the Element and Declaration</span>
+<a name="l00895"></a>00895 <span class="comment">    classes that use it, but NOT transparent to the Attribute</span>
+<a name="l00896"></a>00896 <span class="comment">    which has to implement a next() and previous() method. Which makes</span>
+<a name="l00897"></a>00897 <span class="comment">    it a bit problematic and prevents the use of STL.</span>
+<a name="l00898"></a>00898 <span class="comment"></span>
+<a name="l00899"></a>00899 <span class="comment">    This version is implemented with circular lists because:</span>
+<a name="l00900"></a>00900 <span class="comment">        - I like circular lists</span>
+<a name="l00901"></a>00901 <span class="comment">        - it demonstrates some independence from the (typical) doubly linked list.</span>
+<a name="l00902"></a>00902 <span class="comment">*/</span>
+<a name="l00903"></a>00903 <span class="keyword">class </span>TiXmlAttributeSet
+<a name="l00904"></a>00904 {
+<a name="l00905"></a>00905 <span class="keyword">public</span>:
+<a name="l00906"></a>00906     TiXmlAttributeSet();
+<a name="l00907"></a>00907     ~TiXmlAttributeSet();
+<a name="l00908"></a>00908 
+<a name="l00909"></a>00909     <span class="keywordtype">void</span> Add( <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* attribute );
+<a name="l00910"></a>00910     <span class="keywordtype">void</span> Remove( <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* attribute );
+<a name="l00911"></a>00911 
+<a name="l00912"></a>00912     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* First()<span class="keyword">   const   </span>{ <span class="keywordflow">return</span> ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
+<a name="l00913"></a>00913     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* First()                 { <span class="keywordflow">return</span> ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
+<a name="l00914"></a>00914     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Last()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
+<a name="l00915"></a>00915     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Last()                  { <span class="keywordflow">return</span> ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
+<a name="l00916"></a>00916 
+<a name="l00917"></a>00917     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Find( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name ) <span class="keyword">const</span>;
+<a name="l00918"></a>00918     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* FindOrCreate( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name );
+<a name="l00919"></a>00919 
+<a name="l00920"></a>00920 <span class="preprocessor">#   ifdef TIXML_USE_STL</span>
+<a name="l00921"></a>00921 <span class="preprocessor"></span>    <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* Find( <span class="keyword">const</span> std::string&amp; _name ) <span class="keyword">const</span>;
+<a name="l00922"></a>00922     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* FindOrCreate( <span class="keyword">const</span> std::string&amp; _name );
+<a name="l00923"></a>00923 <span class="preprocessor">#   endif</span>
+<a name="l00924"></a>00924 <span class="preprocessor"></span>
+<a name="l00925"></a>00925 
+<a name="l00926"></a>00926 <span class="keyword">private</span>:
+<a name="l00927"></a>00927     <span class="comment">//*ME:  Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),</span>
+<a name="l00928"></a>00928     <span class="comment">//*ME:  this class must be also use a hidden/disabled copy-constructor !!!</span>
+<a name="l00929"></a>00929     TiXmlAttributeSet( <span class="keyword">const</span> TiXmlAttributeSet&amp; );  <span class="comment">// not allowed</span>
+<a name="l00930"></a>00930     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> TiXmlAttributeSet&amp; ); <span class="comment">// not allowed (as TiXmlAttribute)</span>
+<a name="l00931"></a>00931 
+<a name="l00932"></a>00932     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a> sentinel;
+<a name="l00933"></a>00933 };
+<a name="l00934"></a>00934 
+<a name="l00935"></a>00935 
+<a name="l00940"></a><a class="code" href="classTiXmlElement.html">00940</a> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l00941"></a>00941 {
+<a name="l00942"></a>00942 <span class="keyword">public</span>:
+<a name="l00944"></a>00944     <a class="code" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60" title="Construct an element.">TiXmlElement</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> * in_value);
+<a name="l00945"></a>00945 
+<a name="l00946"></a>00946 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00948"></a>00948 <span class="preprocessor">    TiXmlElement( const std::string&amp; _value );</span>
+<a name="l00949"></a>00949 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00950"></a>00950 <span class="preprocessor"></span>
+<a name="l00951"></a>00951     <a class="code" href="classTiXmlElement.html#a01bc3ab372d35da08efcbbe65ad90c60" title="Construct an element.">TiXmlElement</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; );
+<a name="l00952"></a>00952 
+<a name="l00953"></a>00953     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; base );
+<a name="l00954"></a>00954 
+<a name="l00955"></a>00955     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>();
+<a name="l00956"></a>00956 
+<a name="l00960"></a>00960     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name ) <span class="keyword">const</span>;
+<a name="l00961"></a>00961 
+<a name="l00968"></a>00968     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span>* i ) <span class="keyword">const</span>;
+<a name="l00969"></a>00969 
+<a name="l00976"></a>00976     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">double</span>* d ) <span class="keyword">const</span>;
+<a name="l00977"></a>00977 
+<a name="l00985"></a>00985     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#aea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l00987"></a>00987     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7" title="QueryDoubleAttribute examines the attribute - see QueryIntAttribute().">QueryDoubleAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l00989"></a><a class="code" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be">00989</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#aa04d3af11601ef5a5f88295203a843be" title="QueryFloatAttribute examines the attribute - see QueryIntAttribute().">QueryFloatAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">float</span>* _value )<span class="keyword"> const </span>{
+<a name="l00990"></a>00990         <span class="keywordtype">double</span> d;
+<a name="l00991"></a>00991         <span class="keywordtype">int</span> result = <a class="code" href="classTiXmlElement.html#a898d7730ecc341f0bffc7a9dadbf1ce7" title="QueryDoubleAttribute examines the attribute - see QueryIntAttribute().">QueryDoubleAttribute</a>( name, &amp;d );
+<a name="l00992"></a>00992         <span class="keywordflow">if</span> ( result == TIXML_SUCCESS ) {
+<a name="l00993"></a>00993             *_value = (float)d;
+<a name="l00994"></a>00994         }
+<a name="l00995"></a>00995         <span class="keywordflow">return</span> result;
+<a name="l00996"></a>00996     }
+<a name="l00997"></a>00997 
+<a name="l00998"></a>00998 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01000"></a><a class="code" href="classTiXmlElement.html#a14321ac360efe906ed449d9db3fd9961">01000</a> <span class="preprocessor">    int QueryStringAttribute( const char* name, std::string* _value ) const {</span>
+<a name="l01001"></a>01001 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">char</span>* cstr = <a class="code" href="classTiXmlElement.html#ae419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( name );
+<a name="l01002"></a>01002         <span class="keywordflow">if</span> ( cstr ) {
+<a name="l01003"></a>01003             *_value = std::string( cstr );
+<a name="l01004"></a>01004             <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01005"></a>01005         }
+<a name="l01006"></a>01006         <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01007"></a>01007     }
+<a name="l01008"></a>01008 
+<a name="l01017"></a><a class="code" href="classTiXmlElement.html#ae3b9a03b0a56663a40801c7256683576">01017</a>     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt; <span class="keywordtype">int</span> QueryValueAttribute( <span class="keyword">const</span> std::string&amp; name, T* outValue )<span class="keyword"> const</span>
+<a name="l01018"></a>01018 <span class="keyword">    </span>{
+<a name="l01019"></a>01019         <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* node = attributeSet.Find( name );
+<a name="l01020"></a>01020         <span class="keywordflow">if</span> ( !node )
+<a name="l01021"></a>01021             <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01022"></a>01022 
+<a name="l01023"></a>01023         std::stringstream sstream( node-&gt;<a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33" title="Return the value of this attribute.">ValueStr</a>() );
+<a name="l01024"></a>01024         sstream &gt;&gt; *outValue;
+<a name="l01025"></a>01025         <span class="keywordflow">if</span> ( !sstream.fail() )
+<a name="l01026"></a>01026             <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01027"></a>01027         <span class="keywordflow">return</span> TIXML_WRONG_TYPE;
+<a name="l01028"></a>01028     }
+<a name="l01029"></a>01029 
+<a name="l01030"></a>01030     <span class="keywordtype">int</span> QueryValueAttribute( <span class="keyword">const</span> std::string&amp; name, std::string* outValue )<span class="keyword"> const</span>
+<a name="l01031"></a>01031 <span class="keyword">    </span>{
+<a name="l01032"></a>01032         <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* node = attributeSet.Find( name );
+<a name="l01033"></a>01033         <span class="keywordflow">if</span> ( !node )
+<a name="l01034"></a>01034             <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01035"></a>01035         *outValue = node-&gt;<a class="code" href="classTiXmlAttribute.html#a87705c3ccf9ee9417beb4f7cbacd4d33" title="Return the value of this attribute.">ValueStr</a>();
+<a name="l01036"></a>01036         <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01037"></a>01037     }
+<a name="l01038"></a>01038 <span class="preprocessor">    #endif</span>
+<a name="l01039"></a>01039 <span class="preprocessor"></span>
+<a name="l01043"></a>01043     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> <span class="keywordtype">char</span> * _value );
+<a name="l01044"></a>01044 
+<a name="l01045"></a>01045 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01046"></a>01046 <span class="preprocessor"></span>    <span class="keyword">const</span> std::string* Attribute( <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>;
+<a name="l01047"></a>01047     <span class="keyword">const</span> std::string* Attribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span>* i ) <span class="keyword">const</span>;
+<a name="l01048"></a>01048     <span class="keyword">const</span> std::string* Attribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span>* d ) <span class="keyword">const</span>;
+<a name="l01049"></a>01049     <span class="keywordtype">int</span> QueryIntAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l01050"></a>01050     <span class="keywordtype">int</span> QueryDoubleAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l01051"></a>01051 
+<a name="l01053"></a>01053     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; _value );
+<a name="l01055"></a>01055     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span> _value );
+<a name="l01057"></a>01057     <span class="keywordtype">void</span> SetDoubleAttribute( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span> value );
+<a name="l01058"></a>01058 <span class="preprocessor">    #endif</span>
+<a name="l01059"></a>01059 <span class="preprocessor"></span>
+<a name="l01063"></a>01063     <span class="keywordtype">void</span> SetAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">int</span> value );
+<a name="l01064"></a>01064 
+<a name="l01068"></a>01068     <span class="keywordtype">void</span> SetDoubleAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">double</span> value );
+<a name="l01069"></a>01069 
+<a name="l01072"></a>01072     <span class="keywordtype">void</span> RemoveAttribute( <span class="keyword">const</span> <span class="keywordtype">char</span> * name );
+<a name="l01073"></a>01073 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01074"></a><a class="code" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a">01074</a> <span class="preprocessor"></span>    <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a" title="STL std::string form.">RemoveAttribute</a>( <span class="keyword">const</span> std::string&amp; name ) {   <a class="code" href="classTiXmlElement.html#a1afa6aea716511326a608e4c05df4f3a" title="STL std::string form.">RemoveAttribute</a> (name.c_str ());    }   
+<a name="l01075"></a>01075 <span class="preprocessor">    #endif</span>
+<a name="l01076"></a>01076 <span class="preprocessor"></span>
+<a name="l01077"></a><a class="code" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592">01077</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#a516054c9073647d6cb29b6abe9fa0592" title="Access the first attribute in this element.">FirstAttribute</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> attributeSet.First(); }        
+<a name="l01078"></a>01078     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* FirstAttribute()                { <span class="keywordflow">return</span> attributeSet.First(); }
+<a name="l01079"></a><a class="code" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381">01079</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#a86191b49f9177be132b85b14655f1381" title="Access the last attribute in this element.">LastAttribute</a>()<span class="keyword">   const   </span>{ <span class="keywordflow">return</span> attributeSet.Last(); }     
+<a name="l01080"></a>01080     <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* LastAttribute()                 { <span class="keywordflow">return</span> attributeSet.Last(); }
+<a name="l01081"></a>01081 
+<a name="l01114"></a>01114     <span class="keyword">const</span> <span class="keywordtype">char</span>* GetText() <span class="keyword">const</span>;
+<a name="l01115"></a>01115 
+<a name="l01117"></a>01117     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* Clone() <span class="keyword">const</span>;
+<a name="l01118"></a>01118     <span class="comment">// Print the Element to a FILE stream.</span>
+<a name="l01119"></a>01119     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Print( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01120"></a>01120 
+<a name="l01121"></a>01121     <span class="comment">/*  Attribtue parsing starts: next char past &#39;&lt;&#39;</span>
+<a name="l01122"></a>01122 <span class="comment">                         returns: next char past &#39;&gt;&#39;</span>
+<a name="l01123"></a>01123 <span class="comment">    */</span>
+<a name="l01124"></a>01124     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01125"></a>01125 
+<a name="l01126"></a><a class="code" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c">01126</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*     <a class="code" href="classTiXmlElement.html#ac5b8d0e25fa23fd9acbb6d146082901c" title="Cast to a more defined type. Will return null not of the requested type.">ToElement</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01127"></a><a class="code" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a">01127</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>*           <a class="code" href="classTiXmlElement.html#a9def86337ea7a755eb41cac980f60c7a" title="Cast to a more defined type. Will return null not of the requested type.">ToElement</a>()           { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01128"></a>01128 
+<a name="l01131"></a>01131     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Accept( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01132"></a>01132 
+<a name="l01133"></a>01133 <span class="keyword">protected</span>:
+<a name="l01134"></a>01134 
+<a name="l01135"></a>01135     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* target ) <span class="keyword">const</span>;
+<a name="l01136"></a>01136     <span class="keywordtype">void</span> ClearThis();   <span class="comment">// like clear, but initializes &#39;this&#39; object as well</span>
+<a name="l01137"></a>01137 
+<a name="l01138"></a>01138     <span class="comment">// Used to be public [internal use]</span>
+<a name="l01139"></a>01139 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01140"></a>01140 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01141"></a>01141 <span class="preprocessor">    #endif</span>
+<a name="l01142"></a>01142 <span class="preprocessor"></span>    <span class="comment">/*  [internal use]</span>
+<a name="l01143"></a>01143 <span class="comment">        Reads the &quot;value&quot; of the element -- another element, or text.</span>
+<a name="l01144"></a>01144 <span class="comment">        This should terminate with the current end tag.</span>
+<a name="l01145"></a>01145 <span class="comment">    */</span>
+<a name="l01146"></a>01146     <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadValue( <span class="keyword">const</span> <span class="keywordtype">char</span>* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+<a name="l01147"></a>01147 
+<a name="l01148"></a>01148 <span class="keyword">private</span>:
+<a name="l01149"></a>01149     TiXmlAttributeSet attributeSet;
+<a name="l01150"></a>01150 };
+<a name="l01151"></a>01151 
+<a name="l01152"></a>01152 
+<a name="l01155"></a><a class="code" href="classTiXmlComment.html">01155</a> <span class="keyword">class </span><a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01156"></a>01156 {
+<a name="l01157"></a>01157 <span class="keyword">public</span>:
+<a name="l01159"></a><a class="code" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7">01159</a>     <a class="code" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7" title="Constructs an empty comment.">TiXmlComment</a>() : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_COMMENT ) {}
+<a name="l01161"></a><a class="code" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47">01161</a>     <a class="code" href="classTiXmlComment.html#a37e7802ef17bc03ebe5ae79bf0713d47" title="Construct a comment from text.">TiXmlComment</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _value ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_COMMENT ) {
+<a name="l01162"></a>01162         <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>( _value );
+<a name="l01163"></a>01163     }
+<a name="l01164"></a>01164     <a class="code" href="classTiXmlComment.html#aaa3252031d3e8bd3a2bf51a1c61201b7" title="Constructs an empty comment.">TiXmlComment</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; );
+<a name="l01165"></a>01165     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; base );
+<a name="l01166"></a>01166 
+<a name="l01167"></a>01167     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>() {}
+<a name="l01168"></a>01168 
+<a name="l01170"></a>01170     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlComment.html#a0d6662bdc52488b9e12b3c7a0453d028" title="Returns a copy of this Comment.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01171"></a>01171     <span class="comment">// Write this Comment to a FILE stream.</span>
+<a name="l01172"></a>01172     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlComment.html#a6b316527aaa8da0370cd68c22a5a0f5f" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01173"></a>01173 
+<a name="l01174"></a>01174     <span class="comment">/*  Attribtue parsing starts: at the ! of the !--</span>
+<a name="l01175"></a>01175 <span class="comment">                         returns: next char past &#39;&gt;&#39;</span>
+<a name="l01176"></a>01176 <span class="comment">    */</span>
+<a name="l01177"></a>01177     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01178"></a>01178 
+<a name="l01179"></a><a class="code" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0">01179</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*  <a class="code" href="classTiXmlComment.html#a00fb4215c20a2399ea05ac9b9e7e68a0" title="Cast to a more defined type. Will return null not of the requested type.">ToComment</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01180"></a><a class="code" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df">01180</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>*  <a class="code" href="classTiXmlComment.html#acc7c7e07e13c23f17797d642981511df" title="Cast to a more defined type. Will return null not of the requested type.">ToComment</a>() { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01181"></a>01181 
+<a name="l01184"></a>01184     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlComment.html#af3ac1b99fbbe9ea4fb6e14146156e43e" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01185"></a>01185 
+<a name="l01186"></a>01186 <span class="keyword">protected</span>:
+<a name="l01187"></a>01187     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>* target ) <span class="keyword">const</span>;
+<a name="l01188"></a>01188 
+<a name="l01189"></a>01189     <span class="comment">// used to be public</span>
+<a name="l01190"></a>01190 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01191"></a>01191 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01192"></a>01192 <span class="preprocessor">    #endif</span>
+<a name="l01193"></a>01193 <span class="preprocessor"></span><span class="comment">//  virtual void StreamOut( TIXML_OSTREAM * out ) const;</span>
+<a name="l01194"></a>01194 
+<a name="l01195"></a>01195 <span class="keyword">private</span>:
+<a name="l01196"></a>01196 
+<a name="l01197"></a>01197 };
+<a name="l01198"></a>01198 
+<a name="l01199"></a>01199 
+<a name="l01205"></a><a class="code" href="classTiXmlText.html">01205</a> <span class="keyword">class </span><a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01206"></a>01206 {
+<a name="l01207"></a>01207     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>;
+<a name="l01208"></a>01208 <span class="keyword">public</span>:
+<a name="l01213"></a><a class="code" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960">01213</a>     <a class="code" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960" title="Constructor for text element.">TiXmlText</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> * initValue ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a> (<a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_TEXT)
+<a name="l01214"></a>01214     {
+<a name="l01215"></a>01215         <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>( initValue );
+<a name="l01216"></a>01216         cdata = <span class="keyword">false</span>;
+<a name="l01217"></a>01217     }
+<a name="l01218"></a>01218     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>() {}
+<a name="l01219"></a>01219 
+<a name="l01220"></a>01220 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01222"></a><a class="code" href="classTiXmlText.html#a439792f6183a3d3fb6f2bc2b16fa5691">01222</a> <span class="preprocessor">    TiXmlText( const std::string&amp; initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)</span>
+<a name="l01223"></a>01223 <span class="preprocessor"></span>    {
+<a name="l01224"></a>01224         <a class="code" href="classTiXmlNode.html#a2a38329ca5d3f28f98ce932b8299ae90" title="Changes the value of the node.">SetValue</a>( initValue );
+<a name="l01225"></a>01225         cdata = <span class="keyword">false</span>;
+<a name="l01226"></a>01226     }
+<a name="l01227"></a>01227 <span class="preprocessor">    #endif</span>
+<a name="l01228"></a>01228 <span class="preprocessor"></span>
+<a name="l01229"></a>01229     <a class="code" href="classTiXmlText.html#af659e77c6b87d684827f35a8f4895960" title="Constructor for text element.">TiXmlText</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; copy ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_TEXT )   { copy.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01230"></a>01230     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; base )                             { base.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01231"></a>01231 
+<a name="l01232"></a>01232     <span class="comment">// Write this text object to a FILE stream.</span>
+<a name="l01233"></a>01233     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlText.html#a0cafbf6f236c7f02d12b2bffc2b7976b" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01234"></a>01234 
+<a name="l01236"></a><a class="code" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586">01236</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlText.html#ad1a6a6b83fa2271022dd97c072a2b586" title="Queries whether this represents text using a CDATA section.">CDATA</a>()<span class="keyword"> const              </span>{ <span class="keywordflow">return</span> cdata; }
+<a name="l01238"></a><a class="code" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9">01238</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlText.html#acb17ff7c5d09b2c839393445a3de5ea9" title="Turns on or off a CDATA representation of text.">SetCDATA</a>( <span class="keywordtype">bool</span> _cdata )    { cdata = _cdata; }
+<a name="l01239"></a>01239 
+<a name="l01240"></a>01240     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01241"></a>01241 
+<a name="l01242"></a><a class="code" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648">01242</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* <a class="code" href="classTiXmlText.html#a895bf34ffad17f7439ab2a52b9651648" title="Cast to a more defined type. Will return null not of the requested type.">ToText</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01243"></a><a class="code" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b">01243</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>*       <a class="code" href="classTiXmlText.html#ae7c3a8fd3e4dbf6c0c4363a943d72f5b" title="Cast to a more defined type. Will return null not of the requested type.">ToText</a>()       { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01244"></a>01244 
+<a name="l01247"></a>01247     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlText.html#a8483d4415ce9de6c4fa8f63d067d5de6" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01248"></a>01248 
+<a name="l01249"></a>01249 <span class="keyword">protected</span> :
+<a name="l01251"></a>01251     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlText.html#a0c411e93a27537369479d034cc82da3b" title="[internal use] Creates a new Element and returns it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01252"></a>01252     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* target ) <span class="keyword">const</span>;
+<a name="l01253"></a>01253 
+<a name="l01254"></a>01254     <span class="keywordtype">bool</span> Blank() <span class="keyword">const</span>; <span class="comment">// returns true if all white space and new lines</span>
+<a name="l01255"></a>01255     <span class="comment">// [internal use]</span>
+<a name="l01256"></a>01256 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01257"></a>01257 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01258"></a>01258 <span class="preprocessor">    #endif</span>
+<a name="l01259"></a>01259 <span class="preprocessor"></span>
+<a name="l01260"></a>01260 <span class="keyword">private</span>:
+<a name="l01261"></a>01261     <span class="keywordtype">bool</span> cdata;         <span class="comment">// true if this should be input and output as a CDATA style text element</span>
+<a name="l01262"></a>01262 };
+<a name="l01263"></a>01263 
+<a name="l01264"></a>01264 
+<a name="l01278"></a><a class="code" href="classTiXmlDeclaration.html">01278</a> <span class="keyword">class </span><a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01279"></a>01279 {
+<a name="l01280"></a>01280 <span class="keyword">public</span>:
+<a name="l01282"></a><a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79">01282</a>     <a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79" title="Construct an empty declaration.">TiXmlDeclaration</a>()   : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>::TINYXML_DECLARATION ) {}
+<a name="l01283"></a>01283 
+<a name="l01284"></a>01284 <span class="preprocessor">#ifdef TIXML_USE_STL</span>
+<a name="l01286"></a>01286 <span class="preprocessor">    TiXmlDeclaration(   const std::string&amp; _version,</span>
+<a name="l01287"></a>01287 <span class="preprocessor"></span>                        <span class="keyword">const</span> std::string&amp; _encoding,
+<a name="l01288"></a>01288                         <span class="keyword">const</span> std::string&amp; _standalone );
+<a name="l01289"></a>01289 <span class="preprocessor">#endif</span>
+<a name="l01290"></a>01290 <span class="preprocessor"></span>
+<a name="l01292"></a>01292     <a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79" title="Construct an empty declaration.">TiXmlDeclaration</a>(   <span class="keyword">const</span> <span class="keywordtype">char</span>* _version,
+<a name="l01293"></a>01293                         <span class="keyword">const</span> <span class="keywordtype">char</span>* _encoding,
+<a name="l01294"></a>01294                         <span class="keyword">const</span> <span class="keywordtype">char</span>* _standalone );
+<a name="l01295"></a>01295 
+<a name="l01296"></a>01296     <a class="code" href="classTiXmlDeclaration.html#aa0484d059bea0ea1acb47c9094382d79" title="Construct an empty declaration.">TiXmlDeclaration</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; copy );
+<a name="l01297"></a>01297     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; copy );
+<a name="l01298"></a>01298 
+<a name="l01299"></a>01299     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>() {}
+<a name="l01300"></a>01300 
+<a name="l01302"></a><a class="code" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76">01302</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#a02ee557b1a4545c3219ed377c103ec76" title="Version. Will return an empty string if none was found.">Version</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> version.c_str (); }
+<a name="l01304"></a><a class="code" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76">01304</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#a5d974231f9e9a2f0542f15f3a46cdb76" title="Encoding. Will return an empty string if none was found.">Encoding</a>()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> encoding.c_str (); }
+<a name="l01306"></a><a class="code" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9">01306</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#a9ff06afc033d7ef730ec7c6825b97ad9" title="Is this a standalone document?">Standalone</a>()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> standalone.c_str (); }
+<a name="l01307"></a>01307 
+<a name="l01309"></a>01309     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlDeclaration.html#a7cf459186040141cda7a180a6585ce2e" title="Creates a copy of this Declaration and returns it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01310"></a>01310     <span class="comment">// Print this declaration to a FILE stream.</span>
+<a name="l01311"></a>01311     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Print( FILE* cfile, <span class="keywordtype">int</span> depth, TIXML_STRING* str ) <span class="keyword">const</span>;
+<a name="l01312"></a><a class="code" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4">01312</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlDeclaration.html#abf6303db4bd05b5be554036817ff1cb4" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth )<span class="keyword"> const </span>{
+<a name="l01313"></a>01313         Print( cfile, depth, 0 );
+<a name="l01314"></a>01314     }
+<a name="l01315"></a>01315 
+<a name="l01316"></a>01316     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01317"></a>01317 
+<a name="l01318"></a><a class="code" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967">01318</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>* <a class="code" href="classTiXmlDeclaration.html#a1e085d3fefd1dbf5ccdbff729931a967" title="Cast to a more defined type. Will return null not of the requested type.">ToDeclaration</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01319"></a><a class="code" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce">01319</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>*       <a class="code" href="classTiXmlDeclaration.html#a6bd3d1daddcaeb9543c24bfd090969ce" title="Cast to a more defined type. Will return null not of the requested type.">ToDeclaration</a>()       { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01320"></a>01320 
+<a name="l01323"></a>01323     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDeclaration.html#a22315a535983b86535cdba3458669e3e" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01324"></a>01324 
+<a name="l01325"></a>01325 <span class="keyword">protected</span>:
+<a name="l01326"></a>01326     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>* target ) <span class="keyword">const</span>;
+<a name="l01327"></a>01327     <span class="comment">// used to be public</span>
+<a name="l01328"></a>01328 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01329"></a>01329 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01330"></a>01330 <span class="preprocessor">    #endif</span>
+<a name="l01331"></a>01331 <span class="preprocessor"></span>
+<a name="l01332"></a>01332 <span class="keyword">private</span>:
+<a name="l01333"></a>01333 
+<a name="l01334"></a>01334     TIXML_STRING version;
+<a name="l01335"></a>01335     TIXML_STRING encoding;
+<a name="l01336"></a>01336     TIXML_STRING standalone;
+<a name="l01337"></a>01337 };
+<a name="l01338"></a>01338 
+<a name="l01339"></a>01339 
+<a name="l01347"></a><a class="code" href="classTiXmlUnknown.html">01347</a> <span class="keyword">class </span><a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01348"></a>01348 {
+<a name="l01349"></a>01349 <span class="keyword">public</span>:
+<a name="l01350"></a>01350     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>() : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( TiXmlNode::TINYXML_UNKNOWN )    {}
+<a name="l01351"></a>01351     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>() {}
+<a name="l01352"></a>01352 
+<a name="l01353"></a>01353     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; copy ) : <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>( TiXmlNode::TINYXML_UNKNOWN )      { copy.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01354"></a>01354     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; copy )                                      { copy.CopyTo( <span class="keyword">this</span> ); }
+<a name="l01355"></a>01355 
+<a name="l01357"></a>01357     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlUnknown.html#a0960bb7428b3f341da46244229604d73" title="Creates a copy of this Unknown and returns it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01358"></a>01358     <span class="comment">// Print this Unknown to a FILE stream.</span>
+<a name="l01359"></a>01359     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlUnknown.html#a31ba089a40fb5a1869750fce09b0bacb" title="All TinyXml classes can print themselves to a filestream or the string class (TiXmlString...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01360"></a>01360 
+<a name="l01361"></a>01361     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01362"></a>01362 
+<a name="l01363"></a><a class="code" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d">01363</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*     <a class="code" href="classTiXmlUnknown.html#ab0313e5fe77987d746ac1a97a254419d" title="Cast to a more defined type. Will return null not of the requested type.">ToUnknown</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01364"></a><a class="code" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c">01364</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>*           <a class="code" href="classTiXmlUnknown.html#a67c9fd22940e8c47f706a72cdd2e332c" title="Cast to a more defined type. Will return null not of the requested type.">ToUnknown</a>()     { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01365"></a>01365 
+<a name="l01368"></a>01368     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlUnknown.html#ad7122e5135581b3c832a1a3217760a93" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01369"></a>01369 
+<a name="l01370"></a>01370 <span class="keyword">protected</span>:
+<a name="l01371"></a>01371     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>* target ) <span class="keyword">const</span>;
+<a name="l01372"></a>01372 
+<a name="l01373"></a>01373 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01374"></a>01374 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01375"></a>01375 <span class="preprocessor">    #endif</span>
+<a name="l01376"></a>01376 <span class="preprocessor"></span>
+<a name="l01377"></a>01377 <span class="keyword">private</span>:
+<a name="l01378"></a>01378 
+<a name="l01379"></a>01379 };
+<a name="l01380"></a>01380 
+<a name="l01381"></a>01381 
+<a name="l01386"></a><a class="code" href="classTiXmlDocument.html">01386</a> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>
+<a name="l01387"></a>01387 {
+<a name="l01388"></a>01388 <span class="keyword">public</span>:
+<a name="l01390"></a>01390     <a class="code" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c" title="Create an empty document, that has no name.">TiXmlDocument</a>();
+<a name="l01392"></a>01392     <a class="code" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c" title="Create an empty document, that has no name.">TiXmlDocument</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * documentName );
+<a name="l01393"></a>01393 
+<a name="l01394"></a>01394 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01396"></a>01396 <span class="preprocessor">    TiXmlDocument( const std::string&amp; documentName );</span>
+<a name="l01397"></a>01397 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l01398"></a>01398 <span class="preprocessor"></span>
+<a name="l01399"></a>01399     <a class="code" href="classTiXmlDocument.html#a9f5e84335708fde98400230f9f12659c" title="Create an empty document, that has no name.">TiXmlDocument</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; copy );
+<a name="l01400"></a>01400     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; copy );
+<a name="l01401"></a>01401 
+<a name="l01402"></a>01402     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>() {}
+<a name="l01403"></a>01403 
+<a name="l01408"></a>01408     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01410"></a>01410     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>() <span class="keyword">const</span>;
+<a name="l01412"></a>01412     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01414"></a>01414     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * filename ) <span class="keyword">const</span>;
+<a name="l01420"></a>01420     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01422"></a>01422     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( FILE* ) <span class="keyword">const</span>;
+<a name="l01423"></a>01423 
+<a name="l01424"></a>01424 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01425"></a><a class="code" href="classTiXmlDocument.html#a18ae6ed34fed7991ebc220862dfac884">01425</a> <span class="preprocessor"></span>    <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( <span class="keyword">const</span> std::string&amp; filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )           
+<a name="l01426"></a>01426     {
+<a name="l01427"></a>01427         <span class="keywordflow">return</span> <a class="code" href="classTiXmlDocument.html#a4c852a889c02cf251117fd1d9fe1845f" title="Load a file using the current document value.">LoadFile</a>( filename.c_str(), encoding );
+<a name="l01428"></a>01428     }
+<a name="l01429"></a><a class="code" href="classTiXmlDocument.html#a3d4fae0463f3f03679ba0b7cf6f2df52">01429</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( <span class="keyword">const</span> std::string&amp; filename ) <span class="keyword">const</span>      
+<a name="l01430"></a>01430     {
+<a name="l01431"></a>01431         <span class="keywordflow">return</span> <a class="code" href="classTiXmlDocument.html#a21c0aeb0d0a720169ad4ac89523ebe93" title="Save a file using the current document value. Returns true if successful.">SaveFile</a>( filename.c_str() );
+<a name="l01432"></a>01432     }
+<a name="l01433"></a>01433 <span class="preprocessor">    #endif</span>
+<a name="l01434"></a>01434 <span class="preprocessor"></span>
+<a name="l01439"></a>01439     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlDocument.html#a17ebabe36926ef398e78dec0d0ad0378" title="Parse the given null terminated block of xml data.">Parse</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01440"></a>01440 
+<a name="l01445"></a><a class="code" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be">01445</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be" title="Get the root element -- the only top level element -- of the document.">RootElement</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>(); }
+<a name="l01446"></a>01446     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlDocument.html#ad09d17927f908f40efb406af2fb873be" title="Get the root element -- the only top level element -- of the document.">RootElement</a>()                 { <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>(); }
+<a name="l01447"></a>01447 
+<a name="l01453"></a><a class="code" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29">01453</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a6dfc01a6e5d58e56acd537dfd3bdeb29" title="If an error occurs, Error will be set to true.">Error</a>()<span class="keyword"> const                      </span>{ <span class="keywordflow">return</span> error; }
+<a name="l01454"></a>01454 
+<a name="l01456"></a><a class="code" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e">01456</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="classTiXmlDocument.html#a9d0f689f6e09ea494ea547be8d79c25e" title="Contains a textual (english) description of the error if one occurs.">ErrorDesc</a>()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> errorDesc.c_str (); }
+<a name="l01457"></a>01457 
+<a name="l01461"></a><a class="code" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f">01461</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#af96fc2f3f9ec6422782bfe916c9e778f" title="Generally, you probably want the error string ( ErrorDesc() ).">ErrorId</a>()<span class="keyword">   const               </span>{ <span class="keywordflow">return</span> errorId; }
+<a name="l01462"></a>01462 
+<a name="l01470"></a><a class="code" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e">01470</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#af30efc75e804aa2e92fb8be3a8cb676e" title="Returns the location (if known) of the error.">ErrorRow</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> errorLocation.row+1; }
+<a name="l01471"></a><a class="code" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649">01471</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#aa90bc630ee5203c6109ca5fad3323649" title="The column where the error occured. See ErrorRow().">ErrorCol</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> errorLocation.col+1; } 
+<a name="l01472"></a>01472 
+<a name="l01497"></a><a class="code" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e">01497</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#a51dac56316f89b35bdb7d0d433ba988e" title="SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol()) to...">SetTabSize</a>( <span class="keywordtype">int</span> _tabsize )     { tabsize = _tabsize; }
+<a name="l01498"></a>01498 
+<a name="l01499"></a>01499     <span class="keywordtype">int</span> TabSize()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tabsize; }
+<a name="l01500"></a>01500 
+<a name="l01504"></a><a class="code" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35">01504</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#ac66b8c28db86363315712a3574e87c35" title="If you have handled the error, it can be reset with this call.">ClearError</a>()                       {   error = <span class="keyword">false</span>; 
+<a name="l01505"></a>01505                                                 errorId = 0; 
+<a name="l01506"></a>01506                                                 errorDesc = <span class="stringliteral">&quot;&quot;</span>; 
+<a name="l01507"></a>01507                                                 errorLocation.row = errorLocation.col = 0; 
+<a name="l01508"></a>01508                                                 <span class="comment">//errorLocation.last = 0; </span>
+<a name="l01509"></a>01509                                             }
+<a name="l01510"></a>01510 
+<a name="l01512"></a><a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510">01512</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510" title="Write the document to standard out using formatted printing (&amp;quot;pretty print&amp;quot;)...">Print</a>()<span class="keyword"> const                      </span>{ <a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510" title="Write the document to standard out using formatted printing (&amp;quot;pretty print&amp;quot;)...">Print</a>( stdout, 0 ); }
+<a name="l01513"></a>01513 
+<a name="l01514"></a>01514     <span class="comment">/* Write the document to a string using formatted printing (&quot;pretty print&quot;). This</span>
+<a name="l01515"></a>01515 <span class="comment">        will allocate a character array (new char[]) and return it as a pointer. The</span>
+<a name="l01516"></a>01516 <span class="comment">        calling code pust call delete[] on the return char* to avoid a memory leak.</span>
+<a name="l01517"></a>01517 <span class="comment">    */</span>
+<a name="l01518"></a>01518     <span class="comment">//char* PrintToMemory() const; </span>
+<a name="l01519"></a>01519 
+<a name="l01521"></a>01521     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#af08389ec70ee9b2de7f800e206a18510" title="Write the document to standard out using formatted printing (&amp;quot;pretty print&amp;quot;)...">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth = 0 ) <span class="keyword">const</span>;
+<a name="l01522"></a>01522     <span class="comment">// [internal use]</span>
+<a name="l01523"></a>01523     <span class="keywordtype">void</span> SetError( <span class="keywordtype">int</span> err, <span class="keyword">const</span> <span class="keywordtype">char</span>* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+<a name="l01524"></a>01524 
+<a name="l01525"></a><a class="code" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4">01525</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*    <a class="code" href="classTiXmlDocument.html#a1dc977bde3e4fe85a8eb9d88a35ef5a4" title="Cast to a more defined type. Will return null not of the requested type.">ToDocument</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01526"></a><a class="code" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42">01526</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>*          <a class="code" href="classTiXmlDocument.html#a1025d942a1f328fd742d545e37efdd42" title="Cast to a more defined type. Will return null not of the requested type.">ToDocument</a>()          { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01527"></a>01527 
+<a name="l01530"></a>01530     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#aa545aae325d9752ad64120bc4ecf939a" title="Walk the XML tree visiting this node and all of its children.">Accept</a>( <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01531"></a>01531 
+<a name="l01532"></a>01532 <span class="keyword">protected</span> :
+<a name="l01533"></a>01533     <span class="comment">// [internal use]</span>
+<a name="l01534"></a>01534     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlDocument.html#a4968661cab4a1f44a23329c6f8db1907" title="Create an exact duplicate of this node and return it.">Clone</a>() <span class="keyword">const</span>;
+<a name="l01535"></a>01535 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01536"></a>01536 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01537"></a>01537 <span class="preprocessor">    #endif</span>
+<a name="l01538"></a>01538 <span class="preprocessor"></span>
+<a name="l01539"></a>01539 <span class="keyword">private</span>:
+<a name="l01540"></a>01540     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>* target ) <span class="keyword">const</span>;
+<a name="l01541"></a>01541 
+<a name="l01542"></a>01542     <span class="keywordtype">bool</span> error;
+<a name="l01543"></a>01543     <span class="keywordtype">int</span>  errorId;
+<a name="l01544"></a>01544     TIXML_STRING errorDesc;
+<a name="l01545"></a>01545     <span class="keywordtype">int</span> tabsize;
+<a name="l01546"></a>01546     TiXmlCursor errorLocation;
+<a name="l01547"></a>01547     <span class="keywordtype">bool</span> useMicrosoftBOM;       <span class="comment">// the UTF-8 BOM were found when read. Note this, and try to write.</span>
+<a name="l01548"></a>01548 };
+<a name="l01549"></a>01549 
+<a name="l01550"></a>01550 
+<a name="l01631"></a><a class="code" href="classTiXmlHandle.html">01631</a> <span class="keyword">class </span><a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>
+<a name="l01632"></a>01632 {
+<a name="l01633"></a>01633 <span class="keyword">public</span>:
+<a name="l01635"></a><a class="code" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8">01635</a>     <a class="code" href="classTiXmlHandle.html#aba18fd7bdefb942ecdea4bf4b8e29ec8" title="Create a handle from any node (at any depth of the tree.) This can be a null pointer...">TiXmlHandle</a>( <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* _node )                 { this-&gt;node = _node; }
+<a name="l01637"></a><a class="code" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7">01637</a>     <a class="code" href="classTiXmlHandle.html#a236d7855e1e56ccc7b980630c48c7fd7" title="Copy constructor.">TiXmlHandle</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>&amp; ref )           { this-&gt;node = ref.node; }
+<a name="l01638"></a>01638     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>&amp; ref ) { this-&gt;node = ref.node; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
+<a name="l01639"></a>01639 
+<a name="l01641"></a>01641     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>() <span class="keyword">const</span>;
+<a name="l01643"></a>01643     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;
+<a name="l01645"></a>01645     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>() <span class="keyword">const</span>;
+<a name="l01647"></a>01647     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;
+<a name="l01648"></a>01648 
+<a name="l01652"></a>01652     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01656"></a>01656     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01661"></a>01661     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01666"></a>01666     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01667"></a>01667 
+<a name="l01668"></a>01668 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01669"></a>01669 <span class="preprocessor"></span>    <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const               </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#acdb1faaf88a700b40ca2c8d9aee21139" title="Return a handle to the first child node.">FirstChild</a>( _value.c_str() ); }
+<a name="l01670"></a>01670     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a24d1112e995e937e4dddb202d4113d4a" title="Return a handle to the first child element.">FirstChildElement</a>( _value.c_str() ); }
+<a name="l01671"></a>01671 
+<a name="l01672"></a>01672     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keywordtype">int</span> index )<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a072492b4be1acdb0db2d03cd8f71ccc4" title="Return a handle to the &amp;quot;index&amp;quot; child with the given name.">Child</a>( _value.c_str(), index ); }
+<a name="l01673"></a>01673     <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keywordtype">int</span> index )<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a979a3f850984a176ee884e394c7eed2d" title="Return a handle to the &amp;quot;index&amp;quot; child element with the given name.">ChildElement</a>( _value.c_str(), index ); }
+<a name="l01674"></a>01674 <span class="preprocessor">    #endif</span>
+<a name="l01675"></a>01675 <span class="preprocessor"></span>
+<a name="l01678"></a><a class="code" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3">01678</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3" title="Return the handle as a TiXmlNode.">ToNode</a>()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> node; } 
+<a name="l01681"></a><a class="code" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e">01681</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e" title="Return the handle as a TiXmlElement.">ToElement</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;ToElement() ) ? node-&gt;ToElement() : 0 ); }
+<a name="l01684"></a><a class="code" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586">01684</a>     <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* <a class="code" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586" title="Return the handle as a TiXmlText.">ToText</a>()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;ToText() ) ? node-&gt;ToText() : 0 ); }
+<a name="l01687"></a><a class="code" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674">01687</a>     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>* <a class="code" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674" title="Return the handle as a TiXmlUnknown.">ToUnknown</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;ToUnknown() ) ? node-&gt;ToUnknown() : 0 ); }
+<a name="l01688"></a>01688 
+<a name="l01692"></a><a class="code" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">01692</a>     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* <a class="code" href="classTiXmlHandle.html#ab44b723a8dc9af72838a303c079d0376">Node</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#af678e5088e83be67baf76f699756f2c3" title="Return the handle as a TiXmlNode.">ToNode</a>(); } 
+<a name="l01696"></a><a class="code" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">01696</a>     <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* <a class="code" href="classTiXmlHandle.html#acb5fe8388a526289ea65e817a51e05e7">Element</a>()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#abc6e7ed383a5fe1e52b0c0004b457b9e" title="Return the handle as a TiXmlElement.">ToElement</a>(); }
+<a name="l01700"></a><a class="code" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">01700</a>     <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>* <a class="code" href="classTiXmlHandle.html#a9fc739c8a18d160006f82572fc143d13">Text</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a4ac53a652296203a5b5e13854d923586" title="Return the handle as a TiXmlText.">ToText</a>(); }
+<a name="l01704"></a><a class="code" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">01704</a>     <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>* <a class="code" href="classTiXmlHandle.html#a49675b74357ba2aae124657a9a1ef465">Unknown</a>()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#a1381c17507a130767b1e23afc93b3674" title="Return the handle as a TiXmlUnknown.">ToUnknown</a>(); }
+<a name="l01705"></a>01705 
+<a name="l01706"></a>01706 <span class="keyword">private</span>:
+<a name="l01707"></a>01707     <a class="code" href="classTiXmlNode.html" title="The parent class for everything in the Document Object Model.">TiXmlNode</a>* node;
+<a name="l01708"></a>01708 };
+<a name="l01709"></a>01709 
+<a name="l01710"></a>01710 
+<a name="l01730"></a><a class="code" href="classTiXmlPrinter.html">01730</a> <span class="keyword">class </span><a class="code" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlVisitor.html" title="Implements the interface to the &amp;quot;Visitor pattern&amp;quot; (see the Accept() method...">TiXmlVisitor</a>
+<a name="l01731"></a>01731 {
+<a name="l01732"></a>01732 <span class="keyword">public</span>:
+<a name="l01733"></a>01733     <a class="code" href="classTiXmlPrinter.html" title="Print to memory functionality.">TiXmlPrinter</a>() : depth( 0 ), simpleTextPrint( <span class="keyword">false</span> ),
+<a name="l01734"></a>01734                      buffer(), indent( <span class="stringliteral">&quot;    &quot;</span> ), lineBreak( <span class="stringliteral">&quot;\n&quot;</span> ) {}
+<a name="l01735"></a>01735 
+<a name="l01736"></a>01736     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1" title="Visit a document.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; doc );
+<a name="l01737"></a>01737     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2" title="Visit a document.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a>&amp; doc );
+<a name="l01738"></a>01738 
+<a name="l01739"></a>01739     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a799f4f0388570cbb54c0d3c345fef7c1" title="Visit a document.">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; element, <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a>* firstAttribute );
+<a name="l01740"></a>01740     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#a66b33edd76c538b462f789b797a4fdf2" title="Visit a document.">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>&amp; element );
+<a name="l01741"></a>01741 
+<a name="l01742"></a>01742     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html" title="In correct XML the declaration is the first entry in the file.">TiXmlDeclaration</a>&amp; declaration );
+<a name="l01743"></a>01743     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html" title="XML text.">TiXmlText</a>&amp; text );
+<a name="l01744"></a>01744     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html" title="An XML comment.">TiXmlComment</a>&amp; comment );
+<a name="l01745"></a>01745     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ace1b14d33eede2575c0743e2350f6a38" title="Visit a declaration.">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html" title="Any tag that tinyXml doesn&amp;#39;t recognize is saved as an unknown.">TiXmlUnknown</a>&amp; unknown );
+<a name="l01746"></a>01746 
+<a name="l01750"></a><a class="code" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e">01750</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#a213377a4070c7e625bae59716b089e5e" title="Set the indent characters for printing.">SetIndent</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _indent )           { indent = _indent ? _indent : <span class="stringliteral">&quot;&quot;</span> ; }
+<a name="l01752"></a><a class="code" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d">01752</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#abb33ec7d4bad6aaeb57f4304394b133d" title="Query the indention string.">Indent</a>()                            { <span class="keywordflow">return</span> indent.c_str(); }
+<a name="l01757"></a><a class="code" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6">01757</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#a4be1e37e69e3858c59635aa947174fe6" title="Set the line breaking string.">SetLineBreak</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _lineBreak )     { lineBreak = _lineBreak ? _lineBreak : <span class="stringliteral">&quot;&quot;</span>; }
+<a name="l01759"></a><a class="code" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d">01759</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#a11f1b4804a460b175ec244eb5724d96d" title="Query the current line breaking string.">LineBreak</a>()                         { <span class="keywordflow">return</span> lineBreak.c_str(); }
+<a name="l01760"></a>01760 
+<a name="l01764"></a><a class="code" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19">01764</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#ab23a90629e374cb1cadca090468bbd19" title="Switch over to &amp;quot;stream printing&amp;quot; which is the most dense formatting without...">SetStreamPrinting</a>()                        { indent = <span class="stringliteral">&quot;&quot;</span>;
+<a name="l01765"></a>01765                                                       lineBreak = <span class="stringliteral">&quot;&quot;</span>;
+<a name="l01766"></a>01766                                                     }   
+<a name="l01768"></a><a class="code" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e">01768</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#a859eede9597d3e0355b77757be48735e" title="Return the result.">CStr</a>()                              { <span class="keywordflow">return</span> buffer.c_str(); }
+<a name="l01770"></a><a class="code" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d">01770</a>     <span class="keywordtype">size_t</span> <a class="code" href="classTiXmlPrinter.html#ad01375ae9199bd2f48252eaddce3039d" title="Return the length of the result string.">Size</a>()                                   { <span class="keywordflow">return</span> buffer.size(); }
+<a name="l01771"></a>01771 
+<a name="l01772"></a>01772 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01774"></a><a class="code" href="classTiXmlPrinter.html#a3bd4daf44309b41f5813a833caa0d1c9">01774</a> <span class="preprocessor">    const std::string&amp; Str()                        { return buffer; }</span>
+<a name="l01775"></a>01775 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l01776"></a>01776 <span class="preprocessor"></span>
+<a name="l01777"></a>01777 <span class="keyword">private</span>:
+<a name="l01778"></a>01778     <span class="keywordtype">void</span> DoIndent() {
+<a name="l01779"></a>01779         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;depth; ++i )
+<a name="l01780"></a>01780             buffer += indent;
+<a name="l01781"></a>01781     }
+<a name="l01782"></a>01782     <span class="keywordtype">void</span> DoLineBreak() {
+<a name="l01783"></a>01783         buffer += lineBreak;
+<a name="l01784"></a>01784     }
+<a name="l01785"></a>01785 
+<a name="l01786"></a>01786     <span class="keywordtype">int</span> depth;
+<a name="l01787"></a>01787     <span class="keywordtype">bool</span> simpleTextPrint;
+<a name="l01788"></a>01788     TIXML_STRING buffer;
+<a name="l01789"></a>01789     TIXML_STRING indent;
+<a name="l01790"></a>01790     TIXML_STRING lineBreak;
+<a name="l01791"></a>01791 };
+<a name="l01792"></a>01792 
+<a name="l01793"></a>01793 
+<a name="l01794"></a>01794 <span class="preprocessor">#ifdef _MSC_VER</span>
+<a name="l01795"></a>01795 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( pop )</span>
+<a name="l01796"></a>01796 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l01797"></a>01797 <span class="preprocessor"></span>
+<a name="l01798"></a>01798 <span class="preprocessor">#endif</span>
+<a name="l01799"></a>01799 <span class="preprocessor"></span>
+</pre></div></div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/docs/tutorial0.html vdr-2.0.1.reel/tinyxml/docs/tutorial0.html
--- vdr-2.0.1/tinyxml/docs/tutorial0.html	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/docs/tutorial0.html	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,720 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
+<title>TinyXml: TinyXML Tutorial</title>
+<link href="tabs.css" rel="stylesheet" type="text/css"/>
+<link href="doxygen.css" rel="stylesheet" type="text/css"/>
+</head>
+<body>
+<!-- Generated by Doxygen 1.6.2 -->
+<div class="navigation" id="top">
+  <div class="tabs">
+    <ul>
+      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+      <li><a href="annotated.html"><span>Classes</span></a></li>
+      <li><a href="files.html"><span>Files</span></a></li>
+    </ul>
+  </div>
+  <div class="navpath"><a class="el" href="index.html">index</a>
+  </div>
+</div>
+<div class="contents">
+
+
+<h1><a class="anchor" id="tutorial0">TinyXML Tutorial </a></h1><h1>What is this? </h1>
+<p>This tutorial has a few tips and suggestions on how to use TinyXML effectively.</p>
+<p>I've also tried to include some C++ tips like how to convert strings to integers and vice versa. This isn't anything to do with TinyXML itself, but it may helpful for your project so I've put it in anyway.</p>
+<p>If you don't know basic C++ concepts this tutorial won't be useful. Likewise if you don't know what a DOM is, look elsewhere first.</p>
+<h1>Before we start </h1>
+<p>Some example XML datasets/files will be used.</p>
+<p>example1.xml:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>example2.xml:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;poetry&gt;
+	&lt;verse&gt;
+		Alas
+		  Great World
+			Alas (again)
+	&lt;/verse&gt;
+&lt;/poetry&gt;
+</pre></div><p>example3.xml:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;shapes&gt;
+	&lt;circle name="int-based" x="20" y="30" r="50" /&gt;
+	&lt;point name="float-based" x="3.5" y="52.1" /&gt;
+&lt;/shapes&gt;
+</pre></div><p>example4.xml</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;MyApp&gt;
+    &lt;!-- Settings for MyApp --&gt;
+    &lt;Messages&gt;
+        &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;
+        &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt;
+&lt;/MyApp&gt;
+</pre></div><h1>Getting Started </h1>
+<h2>Load XML from a file </h2>
+<p>The simplest way to load a file into a TinyXML DOM is:</p>
+<div class="fragment"><pre class="fragment">
+TiXmlDocument doc( "demo.xml" );
+doc.LoadFile();
+</pre></div><p>A more real-world usage is shown below. This will load the file and display the contents to STDOUT:</p>
+<div class="fragment"><pre class="fragment">
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &amp;doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+</pre></div><p>A simple demonstration of this function is to use a main like this:</p>
+<div class="fragment"><pre class="fragment">
+int main(void)
+{
+	dump_to_stdout("example1.xml");
+	return 0;
+}
+</pre></div><p>Recall that Example 1 XML is:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>Running the program with this XML will display this in the console/DOS window:</p>
+<div class="fragment"><pre class="fragment">
+DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+</pre></div><p>The ``dump_to_stdout`` function is defined later in this tutorial and is useful if you want to understand recursive traversal of a DOM.</p>
+<h2>Building Documents Programatically </h2>
+<p>This is how to build Example 1 pragmatically:</p>
+<div class="fragment"><pre class="fragment">
+void build_simple_doc( )
+{
+	// Make xml: &lt;?xml ..&gt;&lt;Hello&gt;World&lt;/Hello&gt;
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	TiXmlText * text = new TiXmlText( "World" );
+	element-&gt;LinkEndChild( text );
+	doc.LinkEndChild( decl );
+	doc.LinkEndChild( element );
+	doc.SaveFile( "madeByHand.xml" );
+}
+</pre></div><p>This can be loaded and displayed on the console with:</p>
+<div class="fragment"><pre class="fragment">
+dump_to_stdout("madeByHand.xml"); // this func defined later in the tutorial
+</pre></div><p>and you'll see it is identical to Example 1:</p>
+<div class="fragment"><pre class="fragment">
+madeByHand.xml:
+Document
++ Declaration
++ Element [Hello]
+  + Text: [World]
+</pre></div><p>This code produces exactly the same XML DOM but it shows a different ordering to node creation and linking:</p>
+<div class="fragment"><pre class="fragment">
+void write_simple_doc2( )
+{
+	// same as write_simple_doc1 but add each node
+	// as early as possible into the tree.
+
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	doc.LinkEndChild( decl );
+	
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	doc.LinkEndChild( element );
+	
+	TiXmlText * text = new TiXmlText( "World" );
+	element-&gt;LinkEndChild( text );
+	
+	doc.SaveFile( "madeByHand2.xml" );
+}
+</pre></div><p>Both of these produce the same XML, namely:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>Or in structure form:</p>
+<div class="fragment"><pre class="fragment">
+DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+</pre></div><h2>Attributes </h2>
+<p>Given an existing node, settings attributes is easy:</p>
+<div class="fragment"><pre class="fragment">
+window = new TiXmlElement( "Demo" );  
+window-&gt;SetAttribute("name", "Circle");
+window-&gt;SetAttribute("x", 5);
+window-&gt;SetAttribute("y", 15);
+window-&gt;SetDoubleAttribute("radius", 3.14159);
+</pre></div><p>You can it also work with the <a class="el" href="classTiXmlAttribute.html" title="An attribute is a name-value pair.">TiXmlAttribute</a> objects if you want.</p>
+<p>The following code shows one way (not the only way) to get all attributes of an element, print the name and string value, and if the value can be converted to an integer or double, print that value too:</p>
+<div class="fragment"><pre class="fragment">
+// print all attributes of pElement.
+// returns the number of attributes printed
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement-&gt;FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib-&gt;Name(), pAttrib-&gt;Value());
+
+		if (pAttrib-&gt;QueryIntValue(&amp;ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib-&gt;QueryDoubleValue(&amp;dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib-&gt;Next();
+	}
+	return i;
+}
+</pre></div><h2>Writing a document to a file </h2>
+<p>Writing a pre-built DOM to a file is trivial:</p>
+<div class="fragment"><pre class="fragment">
+doc.SaveFile( saveFilename );  
+</pre></div><p>Recall, for example, example 4:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;MyApp&gt;
+    &lt;!-- Settings for MyApp --&gt;
+    &lt;Messages&gt;
+        &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;
+        &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt;
+&lt;/MyApp&gt;
+</pre></div><p>The following function builds this DOM and writes the file "appsettings.xml":</p>
+<div class="fragment"><pre class="fragment">
+void write_app_settings_doc( )  
+{  
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl );  
+ 
+	TiXmlElement * root = new TiXmlElement( "MyApp" );  
+	doc.LinkEndChild( root );  
+
+	TiXmlComment * comment = new TiXmlComment();
+	comment-&gt;SetValue(" Settings for MyApp " );  
+	root-&gt;LinkEndChild( comment );  
+ 
+	TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+	root-&gt;LinkEndChild( msgs );  
+ 
+	msg = new TiXmlElement( "Welcome" );  
+	msg-&gt;LinkEndChild( new TiXmlText( "Welcome to MyApp" ));  
+	msgs-&gt;LinkEndChild( msg );  
+ 
+	msg = new TiXmlElement( "Farewell" );  
+	msg-&gt;LinkEndChild( new TiXmlText( "Thank you for using MyApp" ));  
+	msgs-&gt;LinkEndChild( msg );  
+ 
+	TiXmlElement * windows = new TiXmlElement( "Windows" );  
+	root-&gt;LinkEndChild( windows );  
+
+	TiXmlElement * window;
+	window = new TiXmlElement( "Window" );  
+	windows-&gt;LinkEndChild( window );  
+	window-&gt;SetAttribute("name", "MainFrame");
+	window-&gt;SetAttribute("x", 5);
+	window-&gt;SetAttribute("y", 15);
+	window-&gt;SetAttribute("w", 400);
+	window-&gt;SetAttribute("h", 250);
+
+	TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+	root-&gt;LinkEndChild( cxn );  
+	cxn-&gt;SetAttribute("ip", "192.168.0.1");
+	cxn-&gt;SetDoubleAttribute("timeout", 123.456); // floating point attrib
+	
+	dump_to_stdout( &amp;doc );
+	doc.SaveFile( "appsettings.xml" );  
+} 
+</pre></div><p>The dump_to_stdout function will show this structure:</p>
+<div class="fragment"><pre class="fragment">
+Document
++ Declaration
++ Element [MyApp]
+ (No attributes)
+  + Comment: [ Settings for MyApp ]
+  + Element [Messages]
+ (No attributes)
+    + Element [Welcome]
+ (No attributes)
+      + Text: [Welcome to MyApp]
+    + Element [Farewell]
+ (No attributes)
+      + Text: [Thank you for using MyApp]
+  + Element [Windows]
+ (No attributes)
+    + Element [Window]
+      + name: value=[MainFrame]
+      + x: value=[5] int=5 d=5.0
+      + y: value=[15] int=15 d=15.0
+      + w: value=[400] int=400 d=400.0
+      + h: value=[250] int=250 d=250.0
+      5 attributes
+  + Element [Connection]
+    + ip: value=[192.168.0.1] int=192 d=192.2
+    + timeout: value=[123.456000] int=123 d=123.5
+    2 attributes
+</pre></div><p>I was surprised that TinyXml, by default, writes the XML in what other APIs call a "pretty" format - it modifies the whitespace of text of elements that contain other nodes so that writing the tree includes an indication of nesting level.</p>
+<p>I haven't looked yet to see if there is a way to turn off indenting when writing a file - its bound to be easy.</p>
+<p>[Lee: It's easy in STL mode, just use cout &lt;&lt; myDoc. Non-STL mode is always in "pretty" format. Adding a switch would be a nice feature and has been requested.]</p>
+<h1>XML to/from C++ objects </h1>
+<h2>Intro </h2>
+<p>This example assumes you're loading and saving your app settings in an XML file, e.g. something like example4.xml.</p>
+<p>There are a number of ways to do this. For example, look into the TinyBind project at <a href="http://sourceforge.net/projects/tinybind">http://sourceforge.net/projects/tinybind</a></p>
+<p>This section shows a plain-old approach to loading and saving a basic object structure using XML.</p>
+<h2>Set up your object classes </h2>
+<p>Start off with some basic classes like these:</p>
+<div class="fragment"><pre class="fragment">
+#include &lt;string&gt;
+#include &lt;map&gt;
+using namespace std;
+
+typedef std::map&lt;std::string,std::string&gt; MessageMap;
+
+// a basic window abstraction - demo purposes only
+class WindowSettings
+{
+public:
+	int x,y,w,h;
+	string name;
+
+	WindowSettings()
+		: x(0), y(0), w(100), h(100), name("Untitled")
+	{
+	}
+
+	WindowSettings(int x, int y, int w, int h, const string&amp; name)
+	{
+		this-&gt;x=x;
+		this-&gt;y=y;
+		this-&gt;w=w;
+		this-&gt;h=h;
+		this-&gt;name=name;
+	}
+};
+
+class ConnectionSettings
+{
+public:
+	string ip;
+	double timeout;
+};
+
+class AppSettings
+{
+public:
+	string m_name;
+	MessageMap m_messages;
+	list&lt;WindowSettings&gt; m_windows;
+	ConnectionSettings m_connection;
+
+	AppSettings() {}
+
+	void save(const char* pFilename);
+	void load(const char* pFilename);
+	
+	// just to show how to do it
+	void setDemoValues()
+	{
+		m_name="MyApp";
+		m_messages.clear();
+		m_messages["Welcome"]="Welcome to "+m_name;
+		m_messages["Farewell"]="Thank you for using "+m_name;
+		m_windows.clear();
+		m_windows.push_back(WindowSettings(15,15,400,250,"Main"));
+		m_connection.ip="Unknown";
+		m_connection.timeout=123.456;
+	}
+};
+</pre></div><p>This is a basic main() that shows how to create a default settings object tree, save it and load it again:</p>
+<div class="fragment"><pre class="fragment">
+int main(void)
+{
+	AppSettings settings;
+	
+	settings.save("appsettings2.xml");
+	settings.load("appsettings2.xml");
+	return 0;
+}
+</pre></div><p>The following main() shows creation, modification, saving and then loading of a settings structure:</p>
+<div class="fragment"><pre class="fragment">
+int main(void)
+{
+	// block: customise and save settings
+	{
+		AppSettings settings;
+		settings.m_name="HitchHikerApp";
+		settings.m_messages["Welcome"]="Don't Panic";
+		settings.m_messages["Farewell"]="Thanks for all the fish";
+		settings.m_windows.push_back(WindowSettings(15,25,300,250,"BookFrame"));
+		settings.m_connection.ip="192.168.0.77";
+		settings.m_connection.timeout=42.0;
+
+		settings.save("appsettings2.xml");
+	}
+	
+	// block: load settings
+	{
+		AppSettings settings;
+		settings.load("appsettings2.xml");
+		printf("%s: %s\n", settings.m_name.c_str(), 
+			settings.m_messages["Welcome"].c_str());
+		WindowSettings &amp; w=settings.m_windows.front();
+		printf("%s: Show window '%s' at %d,%d (%d x %d)\n", 
+			settings.m_name.c_str(), w.name.c_str(), w.x, w.y, w.w, w.h);
+		printf("%s: %s\n", settings.m_name.c_str(), settings.m_messages["Farewell"].c_str());
+	}
+	return 0;
+}
+</pre></div><p>When the save() and load() are completed (see below), running this main() displays on the console:</p>
+<div class="fragment"><pre class="fragment">
+HitchHikerApp: Don't Panic
+HitchHikerApp: Show window 'BookFrame' at 15,25 (300 x 100)
+HitchHikerApp: Thanks for all the fish
+</pre></div><h2>Encode C++ state as XML </h2>
+<p>There are lots of different ways to approach saving this to a file. Here's one:</p>
+<div class="fragment"><pre class="fragment">
+void AppSettings::save(const char* pFilename)
+{
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+	TiXmlComment * comment;
+	string s;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl ); 
+ 
+	TiXmlElement * root = new TiXmlElement(m_name.c_str());  
+	doc.LinkEndChild( root );  
+
+	comment = new TiXmlComment();
+	s=" Settings for "+m_name+" ";
+	comment-&gt;SetValue(s.c_str());  
+	root-&gt;LinkEndChild( comment );  
+
+	// block: messages
+	{
+		MessageMap::iterator iter;
+
+		TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+		root-&gt;LinkEndChild( msgs );  
+ 
+		for (iter=m_messages.begin(); iter != m_messages.end(); iter++)
+		{
+			const string &amp; key=(*iter).first;
+			const string &amp; value=(*iter).second;
+			msg = new TiXmlElement(key.c_str());  
+			msg-&gt;LinkEndChild( new TiXmlText(value.c_str()));  
+			msgs-&gt;LinkEndChild( msg );  
+		}
+	}
+
+	// block: windows
+	{
+		TiXmlElement * windowsNode = new TiXmlElement( "Windows" );  
+		root-&gt;LinkEndChild( windowsNode );  
+
+		list&lt;WindowSettings&gt;::iterator iter;
+
+		for (iter=m_windows.begin(); iter != m_windows.end(); iter++)
+		{
+			const WindowSettings&amp; w=*iter;
+
+			TiXmlElement * window;
+			window = new TiXmlElement( "Window" );  
+			windowsNode-&gt;LinkEndChild( window );  
+			window-&gt;SetAttribute("name", w.name.c_str());
+			window-&gt;SetAttribute("x", w.x);
+			window-&gt;SetAttribute("y", w.y);
+			window-&gt;SetAttribute("w", w.w);
+			window-&gt;SetAttribute("h", w.h);
+		}
+	}
+
+	// block: connection
+	{
+		TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+		root-&gt;LinkEndChild( cxn );  
+		cxn-&gt;SetAttribute("ip", m_connection.ip.c_str());
+		cxn-&gt;SetDoubleAttribute("timeout", m_connection.timeout); 
+	}
+
+	doc.SaveFile(pFilename);  
+}
+</pre></div><p>Running this with the modified main produces this file:</p>
+<div class="fragment"><pre class="fragment">
+&lt;?xml version="1.0" ?&gt;
+&lt;HitchHikerApp&gt;
+    &lt;!-- Settings for HitchHikerApp --&gt;
+    &lt;Messages&gt;
+        &lt;Farewell&gt;Thanks for all the fish&lt;/Farewell&gt;
+        &lt;Welcome&gt;Don&amp;apos;t Panic&lt;/Welcome&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="BookFrame" x="15" y="25" w="300" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.77" timeout="42.000000" /&gt;
+&lt;/HitchHikerApp&gt;
+</pre></div><h2>Decoding state from XML </h2>
+<p>As with encoding objects, there are a number of approaches to decoding XML into your own C++ object structure. The following approach uses TiXmlHandles.</p>
+<div class="fragment"><pre class="fragment">
+void AppSettings::load(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	if (!doc.LoadFile()) return;
+
+	TiXmlHandle hDoc(&amp;doc);
+	TiXmlElement* pElem;
+	TiXmlHandle hRoot(0);
+
+	// block: name
+	{
+		pElem=hDoc.FirstChildElement().Element();
+		// should always have a valid root but handle gracefully if it does
+		if (!pElem) return;
+		m_name=pElem-&gt;Value();
+
+		// save this for later
+		hRoot=TiXmlHandle(pElem);
+	}
+
+	// block: string table
+	{
+		m_messages.clear(); // trash existing table
+
+		pElem=hRoot.FirstChild( "Messages" ).FirstChild().Element();
+		for( pElem; pElem; pElem=pElem-&gt;NextSiblingElement())
+		{
+			const char *pKey=pElem-&gt;Value();
+			const char *pText=pElem-&gt;GetText();
+			if (pKey &amp;&amp; pText) 
+			{
+				m_messages[pKey]=pText;
+			}
+		}
+	}
+
+	// block: windows
+	{
+		m_windows.clear(); // trash existing list
+
+		TiXmlElement* pWindowNode=hRoot.FirstChild( "Windows" ).FirstChild().Element();
+		for( pWindowNode; pWindowNode; pWindowNode=pWindowNode-&gt;NextSiblingElement())
+		{
+			WindowSettings w;
+			const char *pName=pWindowNode-&gt;Attribute("name");
+			if (pName) w.name=pName;
+			
+			pWindowNode-&gt;QueryIntAttribute("x", &amp;w.x); // If this fails, original value is left as-is
+			pWindowNode-&gt;QueryIntAttribute("y", &amp;w.y);
+			pWindowNode-&gt;QueryIntAttribute("w", &amp;w.w);
+			pWindowNode-&gt;QueryIntAttribute("hh", &amp;w.h);
+
+			m_windows.push_back(w);
+		}
+	}
+
+	// block: connection
+	{
+		pElem=hRoot.FirstChild("Connection").Element();
+		if (pElem)
+		{
+			m_connection.ip=pElem-&gt;Attribute("ip");
+			pElem-&gt;QueryDoubleAttribute("timeout",&amp;m_connection.timeout);
+		}
+	}
+}
+</pre></div><h1>Full listing for dump_to_stdout </h1>
+<p>Below is a copy-and-paste demo program for loading arbitrary XML files and dumping the structure to STDOUT using the recursive traversal listed above.</p>
+<div class="fragment"><pre class="fragment">
+// tutorial demo program
+#include "stdafx.h"
+#include "tinyxml.h"
+
+// ----------------------------------------------------------------------
+// STDOUT dump and indenting utility functions
+// ----------------------------------------------------------------------
+const unsigned int NUM_INDENTS_PER_SPACE=2;
+
+const char * getIndent( unsigned int numIndents )
+{
+	static const char * pINDENT="                                      + ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n &gt; LENGTH ) n = LENGTH;
+
+	return &amp;pINDENT[ LENGTH-n ];
+}
+
+// same as getIndent but no "+" at the end
+const char * getIndentAlt( unsigned int numIndents )
+{
+	static const char * pINDENT="                                        ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n &gt; LENGTH ) n = LENGTH;
+
+	return &amp;pINDENT[ LENGTH-n ];
+}
+
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement-&gt;FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib-&gt;Name(), pAttrib-&gt;Value());
+
+		if (pAttrib-&gt;QueryIntValue(&amp;ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib-&gt;QueryDoubleValue(&amp;dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib-&gt;Next();
+	}
+	return i;	
+}
+
+void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0 )
+{
+	if ( !pParent ) return;
+
+	TiXmlNode* pChild;
+	TiXmlText* pText;
+	int t = pParent-&gt;Type();
+	printf( "%s", getIndent(indent));
+	int num;
+
+	switch ( t )
+	{
+	case TiXmlNode::TINYXML_DOCUMENT:
+		printf( "Document" );
+		break;
+
+	case TiXmlNode::TINYXML_ELEMENT:
+		printf( "Element [%s]", pParent-&gt;Value() );
+		num=dump_attribs_to_stdout(pParent-&gt;ToElement(), indent+1);
+		switch(num)
+		{
+			case 0:  printf( " (No attributes)"); break;
+			case 1:  printf( "%s1 attribute", getIndentAlt(indent)); break;
+			default: printf( "%s%d attributes", getIndentAlt(indent), num); break;
+		}
+		break;
+
+	case TiXmlNode::TINYXML_COMMENT:
+		printf( "Comment: [%s]", pParent-&gt;Value());
+		break;
+
+	case TiXmlNode::TINYXML_UNKNOWN:
+		printf( "Unknown" );
+		break;
+
+	case TiXmlNode::TINYXML_TEXT:
+		pText = pParent-&gt;ToText();
+		printf( "Text: [%s]", pText-&gt;Value() );
+		break;
+
+	case TiXmlNode::TINYXML_DECLARATION:
+		printf( "Declaration" );
+		break;
+	default:
+		break;
+	}
+	printf( "\n" );
+	for ( pChild = pParent-&gt;FirstChild(); pChild != 0; pChild = pChild-&gt;NextSibling()) 
+	{
+		dump_to_stdout( pChild, indent+1 );
+	}
+}
+
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &amp;doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+
+// ----------------------------------------------------------------------
+// main() for printing files named on the command line
+// ----------------------------------------------------------------------
+int main(int argc, char* argv[])
+{
+	for (int i=1; i&lt;argc; i++)
+	{
+		dump_to_stdout(argv[i]);
+	}
+	return 0;
+}
+</pre></div><p>Run this from the command line or a DOS window, e.g.:</p>
+<div class="fragment"><pre class="fragment">
+C:\dev\tinyxml&gt; Debug\tinyxml_1.exe example1.xml
+
+example1.xml:
+Document
++ Declaration
++ Element [Hello]
+ (No attributes)
+  + Text: [World]
+</pre></div><p><em> Authors and Changes </p>
+<ul>
+<li>
+Written by Ellers, April, May, June 2005  </li>
+<li>
+Minor edits and integration into doc system, Lee Thomason September 2005  </li>
+<li>
+Updated by Ellers, October 2005  </li>
+</ul>
+<p></em> </p>
+</div>
+<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
+</body>
+</html>
diff -urN vdr-2.0.1/tinyxml/echo.dsp vdr-2.0.1.reel/tinyxml/echo.dsp
--- vdr-2.0.1/tinyxml/echo.dsp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/echo.dsp	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,113 @@
+# Microsoft Developer Studio Project File - Name="echo" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=echo - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "echo.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "echo.mak" CFG="echo - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "echo - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "echo - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "echo - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "echoRelease"
+# PROP Intermediate_Dir "echoRelease"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /YX /FD /c
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "echo - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "echo___Win32_Debug"
+# PROP BASE Intermediate_Dir "echo___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "echoDebug"
+# PROP Intermediate_Dir "echoDebug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "echo - Win32 Release"
+# Name "echo - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltester\bugtest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/Makefile vdr-2.0.1.reel/tinyxml/Makefile
--- vdr-2.0.1/tinyxml/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/Makefile	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,133 @@
+#****************************************************************************
+#
+# Makefile for TinyXml test.
+# Lee Thomason
+# www.grinninglizard.com
+#
+# This is a GNU make (gmake) makefile
+#****************************************************************************
+
+# DEBUG can be set to YES to include debugging info, or NO otherwise
+DEBUG          := NO
+
+# PROFILE can be set to YES to include profiling info, or NO otherwise
+PROFILE        := NO
+
+# TINYXML_USE_STL can be used to turn on STL support. NO, then STL
+# will not be used. YES will include the STL files.
+TINYXML_USE_STL := NO
+
+#****************************************************************************
+
+CC     ?= gcc
+CXX    ?= g++
+LD     ?= g++
+AR     := ar rc
+RANLIB ?= ranlib
+
+DEBUG_CFLAGS     := -Wall -Wno-format -g -DDEBUG
+RELEASE_CFLAGS   := -Wall -Wno-unknown-pragmas -Wno-format -O3
+
+LIBS		 :=
+
+DEBUG_CXXFLAGS   := ${DEBUG_CFLAGS} 
+RELEASE_CXXFLAGS := ${RELEASE_CFLAGS}
+
+DEBUG_LDFLAGS    := -g
+RELEASE_LDFLAGS  :=
+
+ifeq (YES, ${DEBUG})
+   CFLAGS       := ${DEBUG_CFLAGS}
+   CXXFLAGS     := ${DEBUG_CXXFLAGS}
+   LDFLAGS      := ${DEBUG_LDFLAGS}
+else
+   CFLAGS       := ${RELEASE_CFLAGS}
+   CXXFLAGS     := ${RELEASE_CXXFLAGS}
+   LDFLAGS      := ${RELEASE_LDFLAGS}
+endif
+
+ifeq (YES, ${PROFILE})
+   CFLAGS   := ${CFLAGS} -pg -O3
+   CXXFLAGS := ${CXXFLAGS} -pg -O3
+   LDFLAGS  := ${LDFLAGS} -pg
+endif
+
+#****************************************************************************
+# Preprocessor directives
+#****************************************************************************
+
+ifeq (YES, ${TINYXML_USE_STL})
+  DEFS := -DTIXML_USE_STL
+else
+  DEFS :=
+endif
+
+#****************************************************************************
+# Include paths
+#****************************************************************************
+
+#INCS := -I/usr/include/g++-2 -I/usr/local/include
+INCS :=
+
+
+#****************************************************************************
+# Makefile code common to all platforms
+#****************************************************************************
+
+CFLAGS   := ${CFLAGS}   ${DEFS}
+CXXFLAGS := ${CXXFLAGS} ${DEFS}
+
+#****************************************************************************
+# Targets of the build
+#****************************************************************************
+
+#OUTPUT := xmltest
+OUTPUT := libtinyxml.a
+
+all: ${OUTPUT}
+
+
+#****************************************************************************
+# Source files
+#****************************************************************************
+
+#SRCS := tinyxml.cpp tinyxmlparser.cpp xmltest.cpp tinyxmlerror.cpp tinystr.cpp
+SRCS := tinyxml.cpp tinyxmlparser.cpp tinyxmlerror.cpp tinystr.cpp
+
+# Add on the sources for libraries
+SRCS := ${SRCS}
+
+OBJS := $(addsuffix .o,$(basename ${SRCS}))
+
+#****************************************************************************
+# Output
+#****************************************************************************
+
+${OUTPUT}: ${OBJS}
+#	${LD} -o $@ ${LDFLAGS} ${OBJS} ${LIBS} ${EXTRA_LIBS}
+	${AR} $@ ${OBJS}
+
+#****************************************************************************
+# common rules
+#****************************************************************************
+
+# Rules for compiling source files to object files
+%.o : %.cpp
+	${CXX} -c ${CXXFLAGS} ${INCS} $< -o $@
+
+%.o : %.c
+	${CC} -c ${CFLAGS} ${INCS} $< -o $@
+
+dist:
+	bash makedistlinux
+
+clean:
+	-rm -f core ${OBJS} ${OUTPUT}
+
+depend:
+	#makedepend ${INCS} ${SRCS}
+
+tinyxml.o: tinyxml.h tinystr.h
+tinyxmlparser.o: tinyxml.h tinystr.h
+xmltest.o: tinyxml.h tinystr.h
+tinyxmlerror.o: tinyxml.h tinystr.h
diff -urN vdr-2.0.1/tinyxml/readme.txt vdr-2.0.1.reel/tinyxml/readme.txt
--- vdr-2.0.1/tinyxml/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/readme.txt	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,530 @@
+/** @mainpage
+
+<h1> TinyXML </h1>
+
+TinyXML is a simple, small, C++ XML parser that can be easily 
+integrated into other programs.
+
+<h2> What it does. </h2>
+	
+In brief, TinyXML parses an XML document, and builds from that a 
+Document Object Model (DOM) that can be read, modified, and saved.
+
+XML stands for "eXtensible Markup Language." It allows you to create 
+your own document markups. Where HTML does a very good job of marking 
+documents for browsers, XML allows you to define any kind of document 
+markup, for example a document that describes a "to do" list for an 
+organizer application. XML is a very structured and convenient format.
+All those random file formats created to store application data can 
+all be replaced with XML. One parser for everything.
+
+The best place for the complete, correct, and quite frankly hard to
+read spec is at <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">
+http://www.w3.org/TR/2004/REC-xml-20040204/</a>. An intro to XML
+(that I really like) can be found at 
+<a href="http://skew.org/xml/tutorial/">http://skew.org/xml/tutorial</a>.
+
+There are different ways to access and interact with XML data.
+TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed
+into a C++ objects that can be browsed and manipulated, and then 
+written to disk or another output stream. You can also construct an XML document 
+from scratch with C++ objects and write this to disk or another output
+stream.
+
+TinyXML is designed to be easy and fast to learn. It is two headers 
+and four cpp files. Simply add these to your project and off you go. 
+There is an example file - xmltest.cpp - to get you started. 
+
+TinyXML is released under the ZLib license, 
+so you can use it in open source or commercial code. The details
+of the license are at the top of every source file.
+
+TinyXML attempts to be a flexible parser, but with truly correct and
+compliant XML output. TinyXML should compile on any reasonably C++
+compliant system. It does not rely on exceptions or RTTI. It can be 
+compiled with or without STL support. TinyXML fully supports
+the UTF-8 encoding, and the first 64k character entities.
+
+
+<h2> What it doesn't do. </h2>
+
+TinyXML doesn't parse or use DTDs (Document Type Definitions) or XSLs
+(eXtensible Stylesheet Language.) There are other parsers out there 
+(check out www.sourceforge.org, search for XML) that are much more fully
+featured. But they are also much bigger, take longer to set up in
+your project, have a higher learning curve, and often have a more
+restrictive license. If you are working with browsers or have more
+complete XML needs, TinyXML is not the parser for you.
+
+The following DTD syntax will not parse at this time in TinyXML:
+
+@verbatim
+	<!DOCTYPE Archiv [
+	 <!ELEMENT Comment (#PCDATA)>
+	]>
+@endverbatim
+
+because TinyXML sees this as a !DOCTYPE node with an illegally 
+embedded !ELEMENT node. This may be addressed in the future.
+
+<h2> Tutorials. </h2>
+
+For the impatient, here is a tutorial to get you going. A great way to get started, 
+but it is worth your time to read this (very short) manual completely.
+
+- @subpage tutorial0
+
+<h2> Code Status.  </h2>
+
+TinyXML is mature, tested code. It is very stable. If you find
+bugs, please file a bug report on the sourceforge web site
+(www.sourceforge.net/projects/tinyxml). We'll get them straightened 
+out as soon as possible.
+
+There are some areas of improvement; please check sourceforge if you are
+interested in working on TinyXML.
+
+<h2> Related Projects </h2>
+
+TinyXML projects you may find useful! (Descriptions provided by the projects.)
+
+<ul>
+<li> <b>TinyXPath</b> (http://tinyxpath.sourceforge.net). TinyXPath is a small footprint 
+     XPath syntax decoder, written in C++.</li>
+<li> <b>TinyXML++</b> (http://code.google.com/p/ticpp/). TinyXML++ is a completely new 
+     interface to TinyXML that uses MANY of the C++ strengths. Templates, 
+	 exceptions, and much better error handling.</li>
+</ul>
+
+<h2> Features </h2>
+
+<h3> Using STL </h3>
+
+TinyXML can be compiled to use or not use STL. When using STL, TinyXML
+uses the std::string class, and fully supports std::istream, std::ostream,
+operator<<, and operator>>. Many API methods have both 'const char*' and
+'const std::string&' forms.
+
+When STL support is compiled out, no STL files are included whatsoever. All
+the string classes are implemented by TinyXML itself. API methods
+all use the 'const char*' form for input.
+
+Use the compile time #define:
+
+	TIXML_USE_STL
+
+to compile one version or the other. This can be passed by the compiler,
+or set as the first line of "tinyxml.h".
+
+Note: If compiling the test code in Linux, setting the environment
+variable TINYXML_USE_STL=YES/NO will control STL compilation. In the
+Windows project file, STL and non STL targets are provided. In your project,
+It's probably easiest to add the line "#define TIXML_USE_STL" as the first
+line of tinyxml.h.
+
+<h3> UTF-8 </h3>
+
+TinyXML supports UTF-8 allowing to manipulate XML files in any language. TinyXML
+also supports "legacy mode" - the encoding used before UTF-8 support and
+probably best described as "extended ascii".
+
+Normally, TinyXML will try to detect the correct encoding and use it. However,
+by setting the value of TIXML_DEFAULT_ENCODING in the header file, TinyXML
+can be forced to always use one encoding.
+
+TinyXML will assume Legacy Mode until one of the following occurs:
+<ol>
+	<li> If the non-standard but common "UTF-8 lead bytes" (0xef 0xbb 0xbf)
+		 begin the file or data stream, TinyXML will read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has an encoding="UTF-8", then
+		 TinyXML will read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has no encoding specified, then TinyXML will 
+		 read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has an encoding="something else", then TinyXML 
+		 will read it as Legacy Mode. In legacy mode, TinyXML will work as it did before. It's 
+		 not clear what that mode does exactly, but old content should keep working.</li>
+	<li> Until one of the above criteria is met, TinyXML runs in Legacy Mode.</li>
+</ol>
+
+What happens if the encoding is incorrectly set or detected? TinyXML will try
+to read and pass through text seen as improperly encoded. You may get some strange results or 
+mangled characters. You may want to force TinyXML to the correct mode.
+
+You may force TinyXML to Legacy Mode by using LoadFile( TIXML_ENCODING_LEGACY ) or
+LoadFile( filename, TIXML_ENCODING_LEGACY ). You may force it to use legacy mode all
+the time by setting TIXML_DEFAULT_ENCODING = TIXML_ENCODING_LEGACY. Likewise, you may 
+force it to TIXML_ENCODING_UTF8 with the same technique.
+
+For English users, using English XML, UTF-8 is the same as low-ASCII. You
+don't need to be aware of UTF-8 or change your code in any way. You can think
+of UTF-8 as a "superset" of ASCII.
+
+UTF-8 is not a double byte format - but it is a standard encoding of Unicode!
+TinyXML does not use or directly support wchar, TCHAR, or Microsoft's _UNICODE at this time. 
+It is common to see the term "Unicode" improperly refer to UTF-16, a wide byte encoding
+of unicode. This is a source of confusion.
+
+For "high-ascii" languages - everything not English, pretty much - TinyXML can
+handle all languages, at the same time, as long as the XML is encoded
+in UTF-8. That can be a little tricky, older programs and operating systems
+tend to use the "default" or "traditional" code page. Many apps (and almost all
+modern ones) can output UTF-8, but older or stubborn (or just broken) ones
+still output text in the default code page. 
+
+For example, Japanese systems traditionally use SHIFT-JIS encoding. 
+Text encoded as SHIFT-JIS can not be read by TinyXML. 
+A good text editor can import SHIFT-JIS and then save as UTF-8.
+
+The <a href="http://skew.org/xml/tutorial/">Skew.org link</a> does a great
+job covering the encoding issue.
+
+The test file "utf8test.xml" is an XML containing English, Spanish, Russian,
+and Simplified Chinese. (Hopefully they are translated correctly). The file
+"utf8test.gif" is a screen capture of the XML file, rendered in IE. Note that
+if you don't have the correct fonts (Simplified Chinese or Russian) on your
+system, you won't see output that matches the GIF file even if you can parse
+it correctly. Also note that (at least on my Windows machine) console output
+is in a Western code page, so that Print() or printf() cannot correctly display
+the file. This is not a bug in TinyXML - just an OS issue. No data is lost or 
+destroyed by TinyXML. The console just doesn't render UTF-8.
+
+
+<h3> Entities </h3>
+TinyXML recognizes the pre-defined "character entities", meaning special
+characters. Namely:
+
+@verbatim
+	&amp;	&
+	&lt;	<
+	&gt;	>
+	&quot;	"
+	&apos;	'
+@endverbatim
+
+These are recognized when the XML document is read, and translated to there
+UTF-8 equivalents. For instance, text with the XML of:
+
+@verbatim
+	Far &amp; Away
+@endverbatim
+
+will have the Value() of "Far & Away" when queried from the TiXmlText object,
+and will be written back to the XML stream/file as an ampersand. Older versions
+of TinyXML "preserved" character entities, but the newer versions will translate
+them into characters.
+
+Additionally, any character can be specified by its Unicode code point:
+The syntax "&#xA0;" or "&#160;" are both to the non-breaking space characher.
+
+<h3> Printing </h3>
+TinyXML can print output in several different ways that all have strengths and limitations.
+
+- Print( FILE* ). Output to a std-C stream, which includes all C files as well as stdout.
+	- "Pretty prints", but you don't have control over printing options.
+	- The output is streamed directly to the FILE object, so there is no memory overhead
+	  in the TinyXML code.
+	- used by Print() and SaveFile()
+
+- operator<<. Output to a c++ stream.
+	- Integrates with standart C++ iostreams.
+	- Outputs in "network printing" mode without line breaks. Good for network transmission
+	  and moving XML between C++ objects, but hard for a human to read.
+
+- TiXmlPrinter. Output to a std::string or memory buffer.
+	- API is less concise
+	- Future printing options will be put here.
+	- Printing may change slightly in future versions as it is refined and expanded.
+
+<h3> Streams </h3>
+With TIXML_USE_STL on TinyXML supports C++ streams (operator <<,>>) streams as well
+as C (FILE*) streams. There are some differences that you may need to be aware of.
+
+C style output:
+	- based on FILE*
+	- the Print() and SaveFile() methods
+
+	Generates formatted output, with plenty of white space, intended to be as 
+	human-readable as possible. They are very fast, and tolerant of ill formed 
+	XML documents. For example, an XML document that contains 2 root elements 
+	and 2 declarations, will still print.
+
+C style input:
+	- based on FILE*
+	- the Parse() and LoadFile() methods
+
+	A fast, tolerant read. Use whenever you don't need the C++ streams.
+
+C++ style output:
+	- based on std::ostream
+	- operator<<
+
+	Generates condensed output, intended for network transmission rather than
+	readability. Depending on your system's implementation of the ostream class,
+	these may be somewhat slower. (Or may not.) Not tolerant of ill formed XML:
+	a document should contain the correct one root element. Additional root level
+	elements will not be streamed out.
+
+C++ style input:
+	- based on std::istream
+	- operator>>
+
+	Reads XML from a stream, making it useful for network transmission. The tricky
+	part is knowing when the XML document is complete, since there will almost
+	certainly be other data in the stream. TinyXML will assume the XML data is
+	complete after it reads the root element. Put another way, documents that
+	are ill-constructed with more than one root element will not read correctly.
+	Also note that operator>> is somewhat slower than Parse, due to both 
+	implementation of the STL and limitations of TinyXML.
+
+<h3> White space </h3>
+The world simply does not agree on whether white space should be kept, or condensed.
+For example, pretend the '_' is a space, and look at "Hello____world". HTML, and 
+at least some XML parsers, will interpret this as "Hello_world". They condense white
+space. Some XML parsers do not, and will leave it as "Hello____world". (Remember
+to keep pretending the _ is a space.) Others suggest that __Hello___world__ should become
+Hello___world.
+
+It's an issue that hasn't been resolved to my satisfaction. TinyXML supports the
+first 2 approaches. Call TiXmlBase::SetCondenseWhiteSpace( bool ) to set the desired behavior.
+The default is to condense white space.
+
+If you change the default, you should call TiXmlBase::SetCondenseWhiteSpace( bool )
+before making any calls to Parse XML data, and I don't recommend changing it after
+it has been set.
+
+
+<h3> Handles </h3>
+
+Where browsing an XML document in a robust way, it is important to check
+for null returns from method calls. An error safe implementation can
+generate a lot of code like:
+
+@verbatim
+TiXmlElement* root = document.FirstChildElement( "Document" );
+if ( root )
+{
+	TiXmlElement* element = root->FirstChildElement( "Element" );
+	if ( element )
+	{
+		TiXmlElement* child = element->FirstChildElement( "Child" );
+		if ( child )
+		{
+			TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+			if ( child2 )
+			{
+				// Finally do something useful.
+@endverbatim
+
+Handles have been introduced to clean this up. Using the TiXmlHandle class,
+the previous code reduces to:
+
+@verbatim
+TiXmlHandle docHandle( &document );
+TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+if ( child2 )
+{
+	// do something useful
+@endverbatim
+
+Which is much easier to deal with. See TiXmlHandle for more information.
+
+
+<h3> Row and Column tracking </h3>
+Being able to track nodes and attributes back to their origin location
+in source files can be very important for some applications. Additionally,
+knowing where parsing errors occured in the original source can be very
+time saving.
+
+TinyXML can tracks the row and column origin of all nodes and attributes
+in a text file. The TiXmlBase::Row() and TiXmlBase::Column() methods return
+the origin of the node in the source text. The correct tabs can be 
+configured in TiXmlDocument::SetTabSize().
+
+
+<h2> Using and Installing </h2>
+
+To Compile and Run xmltest:
+
+A Linux Makefile and a Windows Visual C++ .dsw file is provided. 
+Simply compile and run. It will write the file demotest.xml to your 
+disk and generate output on the screen. It also tests walking the
+DOM by printing out the number of nodes found using different 
+techniques.
+
+The Linux makefile is very generic and runs on many systems - it 
+is currently tested on mingw and
+MacOSX. You do not need to run 'make depend'. The dependecies have been
+hard coded.
+
+<h3>Windows project file for VC6</h3>
+<ul>
+<li>tinyxml:		tinyxml library, non-STL </li>
+<li>tinyxmlSTL:		tinyxml library, STL </li>
+<li>tinyXmlTest:	test app, non-STL </li>
+<li>tinyXmlTestSTL: test app, STL </li>
+</ul>
+
+<h3>Makefile</h3>
+At the top of the makefile you can set:
+
+PROFILE, DEBUG, and TINYXML_USE_STL. Details (such that they are) are in
+the makefile.
+
+In the tinyxml directory, type "make clean" then "make". The executable
+file 'xmltest' will be created.
+
+
+
+<h3>To Use in an Application:</h3>
+
+Add tinyxml.cpp, tinyxml.h, tinyxmlerror.cpp, tinyxmlparser.cpp, tinystr.cpp, and tinystr.h to your
+project or make file. That's it! It should compile on any reasonably
+compliant C++ system. You do not need to enable exceptions or
+RTTI for TinyXML.
+
+
+<h2> How TinyXML works.  </h2>
+
+An example is probably the best way to go. Take:
+@verbatim
+	<?xml version="1.0" standalone=no>
+	<!-- Our to do list data -->
+	<ToDo>
+		<Item priority="1"> Go to the <bold>Toy store!</bold></Item>
+		<Item priority="2"> Do bills</Item>
+	</ToDo>
+@endverbatim
+
+Its not much of a To Do list, but it will do. To read this file 
+(say "demo.xml") you would create a document, and parse it in:
+@verbatim
+	TiXmlDocument doc( "demo.xml" );
+	doc.LoadFile();
+@endverbatim
+
+And its ready to go. Now lets look at some lines and how they 
+relate to the DOM.
+
+@verbatim
+<?xml version="1.0" standalone=no>
+@endverbatim
+
+	The first line is a declaration, and gets turned into the
+	TiXmlDeclaration class. It will be the first child of the
+	document node.
+	
+	This is the only directive/special tag parsed by TinyXML.
+	Generally directive tags are stored in TiXmlUnknown so the 
+	commands wont be lost when it is saved back to disk.
+
+@verbatim
+<!-- Our to do list data -->
+@endverbatim
+
+	A comment. Will become a TiXmlComment object.
+
+@verbatim
+<ToDo>
+@endverbatim
+
+	The "ToDo" tag defines a TiXmlElement object. This one does not have 
+	any attributes, but does contain 2 other elements.
+
+@verbatim
+<Item priority="1"> 
+@endverbatim
+
+	Creates another TiXmlElement which is a child of the "ToDo" element. 
+	This element has 1 attribute, with the name "priority" and the value 
+	"1".
+
+@verbatim
+Go to the
+@endverbatim 
+
+	A TiXmlText. This is a leaf node and cannot contain other nodes. 
+	It is a child of the "Item" TiXmlElement.
+
+@verbatim
+<bold>
+@endverbatim
+
+	
+	Another TiXmlElement, this one a child of the "Item" element.
+
+Etc.
+
+Looking at the entire object tree, you end up with:
+@verbatim
+TiXmlDocument					"demo.xml"
+	TiXmlDeclaration			"version='1.0'" "standalone=no"
+	TiXmlComment				" Our to do list data"
+	TiXmlElement				"ToDo"
+		TiXmlElement			"Item" Attribtutes: priority = 1
+			TiXmlText			"Go to the "
+			TiXmlElement		"bold"
+				TiXmlText		"Toy store!"
+		TiXmlElement			"Item" Attributes: priority=2
+			TiXmlText			"Do bills"
+@endverbatim
+
+<h2> Documentation </h2>
+
+The documentation is build with Doxygen, using the 'dox' 
+configuration file.
+
+<h2> License </h2>
+
+TinyXML is released under the zlib license:
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this 
+software in a product, an acknowledgment in the product documentation 
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+
+<h2> References  </h2>
+
+The World Wide Web Consortium is the definitive standard body for 
+XML, and their web pages contain huge amounts of information. 
+
+The definitive spec: <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">
+http://www.w3.org/TR/2004/REC-xml-20040204/</a>
+
+I also recommend "XML Pocket Reference" by Robert Eckstein and published by 
+OReilly...the book that got the whole thing started.
+
+<h2> Contributors, Contacts, and a Brief History </h2>
+
+Thanks very much to everyone who sends suggestions, bugs, ideas, and 
+encouragement. It all helps, and makes this project fun. A special thanks
+to the contributors on the web pages that keep it lively.
+
+So many people have sent in bugs and ideas, that rather than list here 
+we try to give credit due in the "changes.txt" file.
+
+TinyXML was originally written by Lee Thomason. (Often the "I" still
+in the documentation.) Lee reviews changes and releases new versions,
+with the help of Yves Berquin, Andrew Ellerton, and the tinyXml community.
+
+We appreciate your suggestions, and would love to know if you 
+use TinyXML. Hopefully you will enjoy it and find it useful. 
+Please post questions, comments, file bugs, or contact us at:
+
+www.sourceforge.net/projects/tinyxml
+
+Lee Thomason, Yves Berquin, Andrew Ellerton
+*/
diff -urN vdr-2.0.1/tinyxml/.svn/entries vdr-2.0.1.reel/tinyxml/.svn/entries
--- vdr-2.0.1/tinyxml/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/entries	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,881 @@
+10
+
+dir
+19489
+svn://reelbox.org/testing/src/vdr-1.7/tinyxml
+svn://reelbox.org
+
+
+
+2011-01-12T11:11:52.208433Z
+15853
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+12be777f-adf9-0310-842f-e37ecc4c7426
+
+tinyXmlTestSTL.vcproj
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+5343f028224a65ace7fc717625243cff
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5447
+
+tinyXmlTest.dsp
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+81d83fe82afa5985ac4ef8bf45c301ed
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4189
+
+tinyxmlSTL.vcproj
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+ba995952b2abff5e96e7e77e63bb929d
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5656
+
+tinyxml.h
+file
+
+
+
+
+2013-05-03T17:03:38.970701Z
+cb6c9b45173e414fdbdea20176fb1a99
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+64316
+
+._Makefile
+file
+
+
+
+
+2013-05-03T17:03:38.970701Z
+6f90edd257246324e51cc5053dd6ae67
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+171
+
+utf8test.gif
+file
+
+
+
+
+2013-05-03T17:03:38.970701Z
+49a7cc1a718591de3a1d789927bf76f1
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+14812
+
+tinyxml_lib.vcproj
+file
+
+
+
+
+2013-05-03T17:03:38.970701Z
+9e4005a821d30bad5b7977c6f1cdea06
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5676
+
+tinystr.cpp
+file
+
+
+
+
+2013-05-03T17:03:38.974701Z
+375cdcb664469af25e6ebda03177ab3d
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2602
+
+tinyxmlerror.cpp
+file
+
+
+
+
+2013-05-03T17:03:38.974701Z
+1678986e638707a592e6aa8b4146567b
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1780
+
+tinyxml.sln
+file
+
+
+
+
+2013-05-03T17:03:38.974701Z
+901058d0c8476f4514ad320cfe85fd62
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2535
+
+tinyxml.dsw
+file
+
+
+
+
+2013-05-03T17:03:38.974701Z
+47c99500f7d6c84b7caebb47df5ff31c
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1315
+
+tinystr.h
+file
+
+
+
+
+2013-05-03T17:03:38.974701Z
+cf367876ee833646804f79b5dd331d83
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8783
+
+tinyxmlparser.cpp
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+c0d02eacfe4ae72f6de8e62708c41098
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+37193
+
+echo.dsp
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+5a0ec15d02a34ed833642290497ca975
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4457
+
+tinyXmlTest.vcproj
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+9b8c61148a979d5befe6cb4ac5d1c904
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5336
+
+utf8testverify.xml
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+f4198a04eb8a0b02bdf27aff64556cc5
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+692
+
+readme.txt
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+f8f366f3370dda889f60faa7db162cf4
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+19831
+
+tinyXmlTestSTL.dsp
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+e0e9bbaccfd0d00767b32c5f6d779bc3
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4453
+
+tinyxmlSTL.dsp
+file
+
+
+
+
+2013-05-03T17:03:38.978701Z
+5da335b41b619518f3c33d578cafbb9b
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3518
+
+Makefile
+file
+
+
+
+
+2013-05-03T17:03:38.982701Z
+d0ab2b3924e3f6dcc0da4650f726ff10
+2011-01-12T11:11:52.208433Z
+15853
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3613
+
+tinyxml_lib.dsp
+file
+
+
+
+
+2013-05-03T17:03:38.962701Z
+6153b6c42eea02428d47633efc2fcb11
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3475
+
+xmltest.cpp
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+72dc3b41fdd2f582909f2ac76729fca1
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+41492
+
+tinyxml.cpp
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+9f8429b8e9b6316a778ff49557e23f4b
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+36435
+
+utf8test.xml
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+60125088e7992e07e224685e1c9fca6f
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+690
+
+changes.txt
+file
+
+
+
+
+2013-05-03T17:03:38.966701Z
+4e4d5c9310273fe6a54016f751d45583
+2010-11-12T09:13:20.936395Z
+15371
+dirk
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+14898
+
+docs
+dir
+
diff -urN vdr-2.0.1/tinyxml/.svn/prop-base/._Makefile.svn-base vdr-2.0.1.reel/tinyxml/.svn/prop-base/._Makefile.svn-base
--- vdr-2.0.1/tinyxml/.svn/prop-base/._Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/prop-base/._Makefile.svn-base	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/.svn/prop-base/utf8test.gif.svn-base vdr-2.0.1.reel/tinyxml/.svn/prop-base/utf8test.gif.svn-base
--- vdr-2.0.1/tinyxml/.svn/prop-base/utf8test.gif.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/prop-base/utf8test.gif.svn-base	2013-05-09 18:10:01.647874322 +0200
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/changes.txt.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/changes.txt.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/changes.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/changes.txt.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,290 @@
+Changes in version 1.0.1:
+- Fixed comment tags which were outputing as '<?--' instead of 
+  the correct '<!--'.
+- Implemented the Next and Prev methods of the TiXmlAttribute class.
+- Renamed 'LastAttribtute' to 'LastAttribute'
+- Fixed bad pointer to 'isspace' that could occur while parsing text.
+- Errors finding beginning and end of tags no longer throw it into an
+  infinite loop. (Hopefully.)
+
+Changes in version 1.0.2
+- Minor documentation fixes.
+
+Changes in version 1.0.3
+- After nodes are added to a document, they return a pointer
+  to the new node instead of a bool for success.
+- Elements can be constructed with a value, which is the
+  element name. Every element must have a value or it will be
+  invalid, but the code changes to enforce this are not fully
+  in place.
+
+Changes in version 1.1.0
+- Added the	TiXmlAttributeSet class to pull the attributes into
+  a seperate container.
+- Moved the doubly liked list out of XmlBase. Now XmlBase only
+  requires the Print() function and defines some utility functions.
+- Moved errors into a seperate file. (With the idea of internationalization
+  to the other latin-1 languages.)
+- Added the "NodeType"
+- Fixed white space parsing in text to conform with the standard. 
+  Basically, all white space becomes just one space.
+- Added the TiXmlDeclaration class to read xml declarations.
+
+Changes in version 1.2.0
+- Removed the factory. The factory was not really in the spirit 
+  of small and simple, confused the code, and was of limited value.
+- Added FirstChildElement and NextSiblingElement, because they
+  are such common functions.
+- Re-wrote the example to test and demonstrate more functionality.
+
+Changes in version 1.2.1
+- Fixed a bug where comments couldn't be inside elements.
+- Loading now clears out existing XML rather than appending.
+- Added the "Clear" method on a node to delete all its children.
+
+Changes in version 1.2.2
+- Fixed TiXmlAttribute::Previous actually returning "next." Thanks
+  to Rickard Troedsson for the bug fix.
+
+Changes in version 1.2.3
+- Added the TIXML prefix to the error strings to resolve conflicts
+  with #defines in OS headers. Thanks to Steve Lhomme.
+- Fixed a delete buf that should be a delete [] buf. 
+  Thanks to Ephi Sinowitz.
+
+Changes in version 1.2.4
+- ReplaceChild() was almost guarenteed to fail. Should be fixed,
+  thanks to Joe Smith. Joe also pointed out that the Print() functions
+  should take stream references: I agree, and would like to overload
+  the Print() method to take either format, but I don't want to do 
+  this in a dot release.
+- Some compilers seem to need an extra <ctype.h> include. Thanks
+  to Steve Lhomme for that.
+
+Changes in version 2.0.0 BETA
+- Made the ToXXX() casts safe if 'this' is null. 
+  When "LoadFile" is called with a filename, the value will correctly get set.
+  Thanks to Brian Yoder.
+- Fixed bug where isalpha() and isalnum() would get called with a negative value for 
+  high ascii numbers. Thanks to Alesky Aksenov.
+- Fixed some errors codes that were not getting set.
+- Made methods "const" that were not.
+- Added a switch to enable or disable the ignoring of white space. ( TiXmlDocument::SetIgnoreWhiteSpace() )
+- Greater standardization and code re-use in the parser.
+- Added a stream out operator.
+- Added a stream in operator.
+- Entity support, of predefined entites. &#x entities are untouched by input or output.
+- Improved text out formatting.
+- Fixed ReplaceChild bug, thanks to Tao Chen.
+
+Changes in version 2.0.1
+- Fixed hanging on loading a 0 length file. Thanks to Jeff Scozzafava.
+- Fixed crashing on InsertBeforeChild and InsertAfterChild. Also possibility of bad links being
+  created by same function. Thanks to Frank De prins.
+- Added missing licence text. Thanks to Lars Willemsens.
+- Added <ctype.h> include, at the suggestion of Steve Walters.
+
+Changes in version 2.1.0
+- Yves Berquin brings us the STL switch. The forum on SourceForge, and various emails to
+  me, have long debated all out STL vs. no STL at all. And now you can have it both ways.
+  TinyXml will compile either way.
+
+Changes in version 2.1.1
+- Compilation warnings.
+
+Changes in version 2.1.2
+- Uneeded code is not compiled in the STL case.
+- Changed headers so that STL can be turned on or off in tinyxml.h
+
+Changes in version 2.1.3
+- Fixed non-const reference in API; now uses a pointer.
+- Copy constructor of TiXmlString not checking for assignment to self.
+- Nimrod Cohen found a truly evil bug in the STL implementation that occurs
+  when a string is converted to a c_str and then assigned to self. Search for
+  STL_STRING_BUG for a full description. I'm asserting this is a Microsoft STL
+  bug, since &string and string.c_str() should never be the same. Nevertheless,
+  the code works around it.
+- Urivan Saaib pointed out a compiler conflict, where the C headers define
+  the isblank macro, which was wiping out the TiXmlString::isblank() method.
+  The method was unused and has been removed.
+
+Changes in version 2.1.4
+- Reworked the entity code. Entities were not correctly surving round trip input and output.
+  Will now automatically create entities for high ascii in output.
+
+Changes in version 2.1.5
+- Bug fix by kylotan : infinite loop on some input (tinyxmlparser.cpp rev 1.27)
+- Contributed by Ivica Aracic (bytelord) : 1 new VC++ project to compile versions as static libraries (tinyxml_lib.dsp), 
+  and an example usage in xmltest.dsp
+  (Patch request ID 678605)
+- A suggestion by Ronald Fenner Jr (dormlock) to add #include <istream> and <ostream> for Apple's Project Builder 
+  (Patch request ID 697642)
+- A patch from ohommes that allows to parse correctly dots in element names and attribute names
+  (Patch request 602600 and kylotan 701728)
+- A patch from  hermitgeek ( James ) and wasteland for improper error reporting
+- Reviewed by Lee, with the following changes:
+	- Got sick of fighting the STL/non-STL thing in the windows build. Broke
+	  them out as seperate projects.
+	- I have too long not included the dsw. Added.
+	- TinyXmlText had a protected Print. Odd.
+	- Made LinkEndChild public, with docs and appropriate warnings.
+	- Updated the docs.
+
+2.2.0
+- Fixed an uninitialized pointer in the TiXmlAttributes
+- Fixed STL compilation problem in MinGW (and gcc 3?) - thanks Brian Yoder for finding this one
+- Fixed a syntax error in TiXmlDeclaration - thanks Brian Yoder
+- Fletcher Dunn proposed and submitted new error handling that tracked the row and column. Lee
+  modified it to not have performance impact.
+- General cleanup suggestions from Fletcher Dunn.
+- In error handling, general errors will no longer clear the error state of specific ones.
+- Fix error in documentation : comments starting with "<?--" instead of "<!--" (thanks ion_pulse)
+- Added the TiXmlHandle. An easy, safe way to browse XML DOMs with less code.
+- Added QueryAttribute calls which have better error messaging. (Proposed by Fletcher Dunn)
+- Nodes and attributes can now print themselves to strings. (Yves suggestion)
+- Fixed bug where entities with one character would confuse parser. (Thanks Roman)
+
+2.2.1
+- Additional testing (no more bugs found to be fixed in this release)
+- Significant performance improvement to the cursor code.
+
+2.3.0
+- User Data are now defined in TiXmlBase instead of TiXmlNode
+- Character Entities are now UCS-2
+- Character Entities can be decimal or hexadecimal
+- UTF-8 conversion.
+- Fixed many, many bugs.
+
+2.3.1
+- Fixed bug in handling nulls embedded in the input.
+- Make UTF-8 parser tolerant of bad text encoding.
+- Added encoding detection. 
+- Many fixes and input from John-Philip Leonard Johansson (JP) and Ellers, 
+  including UTF-8 feedback, bug reports, and patches. Thanks!
+- Added version # constants - a suggestion from JP and Ellers.
+- [ 979180 ] Missing ; in entity reference, fix from Rob Laveaux.
+- Copy constructors and assignment have been a long time coming. Thanks to
+  Fokke and JP.
+
+2.3.2
+- Made the IsAlpha and IsAlphaNum much more tolerant of non-UTF-8 encodings. Thanks
+  Volker Boerchers for finding the issue.
+- Ran the program though the magnificent Valgrind - http://valgrind.kde.org - to check
+  for memory errors. Fixed some minor issues.
+
+2.3.3
+- Fixed crash when test program was run from incorrect directory.
+- Fixed bug 1070717 - empty document not returned correctly - thanks Katsuhisa Yuasa.
+- Bug 1079301 resolved - deprecated stdlib calls. Thanks Adrian Boeing.
+- Bug 1035218 fixed - documentation errors. Xunji Luo
+- Other bug fixes have accumulated and been fixed on the way as well; my apologies to
+  authors not credited!
+- Big fix / addition is to correctly return const values. TinyXml could basically
+  remove const in a method like this: TiXmlElement* Foo() const, where the returned element
+  was a pointer to internal data. That is now: const TiXmlElement* Foo() const and
+  TiXmlElement* Foo().
+
+2.3.4
+- Fixed additional const errors, thanks Kent Gibson.
+- Correctly re-enable warnings after tinyxml header. Thanks Cory Nelson.
+- Variety of type cleanup and warning fixes. Thanks Warren Stevens.
+- Cleaned up unneeded constructor calls in TinyString - thanks to Geoff Carlton and
+  the discussion group on sourceforge.
+
+2.4.0
+- Improved string class, thanks Tyge Lovset (whose name gets mangled in English - sorry)
+- Type cast compiler warning, thanks Rob van den Bogaard
+- Added GetText() convenience function. Thanks Ilya Parniuk & Andrew Ellers for input.
+- Many thanks to marlonism for finding an infinite loop in bad xml.
+- A patch to cleanup warnings from Robert Gebis.
+- Added ValueStr() to get the value of a node as a string.
+- TiXmlText can now parse and output as CDATA
+- Additional string improvement from James (z2895)
+- Removed extraneous 'const', thanks David Aldrich
+- First pass at switching to the "safe" stdlib functions. Many people have suggested and
+  pushed on this, but Warren Stevens put together the first proposal.
+- TinyXml now will do EOL normalization before parsing, consistent with the W3C XML spec.
+- Documents loaded with the UTF-8 BOM will now save with the UTF-8 BOM. Good suggestion 
+  from 'instructor_'
+- Ellers submitted his very popular tutorials, which have been added to the distribution.
+
+2.4.1
+- Fixed CDATA output formatting
+- Fixed memory allocators in TinyString to work with overloaded new/delete
+
+2.4.2
+- solosnake pointed out that TIXML_LOG causes problems on an XBOX. The definition in the header
+  was superflous and was moved inside of DEBUG_PARSING
+
+2.4.3
+- Fixed a test bug that caused a crash in 'xmltest'. TinyXML was fine, but it isn't good
+  to ship with a broken test suite.
+- Started converting some functions to not cast between std::string and const char* 
+  quite as often.
+- Added FILE* versions of the document loads - good suggestion from Wade Brainerd
+- Empty documents might not always return the errors they should. [1398915] Thanks to igor v.
+- Added some asserts for multiply adding a node, regardng bug [1391937] suggested by Paco Arjonilla.
+
+2.4.4
+- Bug find thanks to andre-gross found a memory leak that occured when a document failed to load.
+- Bug find (and good analysis) by VirtualJim who found a case where attribute parsing 
+  should be throwing an error and wasn't.
+- Steve Hyatt suggested the QueryValueAttribute method, which is now implemented.
+- DavidA identified a chunk of dead code.
+- Andrew Baxter sent in some compiler warnings that were good clean up points.
+
+2.5
+- Added the Visit() API. Many thanks to both Andrew Ellerton and John-Philip for all their
+  work, code, suggestion, and just general pushing that it should be done.
+- Removed existing streaming code and use TiXmlPrinter instead.
+- [ tinyxml-Bugs-1527079 ] Compile error in tinystr.cpp fixed, thanks to Paul Suggs
+- [ tinyxml-Bugs-1522890 ] SaveFile has no error checks fixed, thanks to Ivan Dobrokotov
+- Ivan Dobrokotov also reported redundant memory allocation in the Attribute() method, which
+  upon investigation was a mess. The attribute should now be fixed for both const char* and 
+  std::string, and the return types match the input parameters.
+- Feature [ 1511105 ] Make TiXmlComment constructor accept a string / char*, implemented.
+  Thanks to Karl Itschen for the feedback.
+- [ 1480108 ] Stream parsing fails when CDATA contains tags was found by Tobias Grimm, who also
+  submitted a test case and patch. A significant bug in CDATA streaming (operator>>) has now
+  been fixed.
+
+2.5.2
+- Lieven, and others, pointed out a missing const-cast that upset the Open Watcom compiler.
+  Should now be fixed.
+- ErrorRow and ErrorCol should have been const, and weren't. Fixed thanks to Dmitry Polutov.
+
+2.5.3
+- zloe_zlo identified a missing string specialization for QueryValueAttribute() [ 1695429 ]. Worked
+  on this bug, but not sure how to fix it in a safe, cross-compiler way.
+- increased warning level to 4 and turned on detect 64 bit portability issues for VC2005.
+  May address [ 1677737 ] VS2005: /Wp64 warnings
+- grosheck identified several problems with the Document copy. Many thanks for [ 1660367 ]
+- Nice catch, and suggested fix, be Gilad Novik on the Printer dropping entities.
+  "[ 1600650 ] Bug when printing xml text" is now fixed.
+- A subtle fix from Nicos Gollan in the tinystring initializer: 
+  [ 1581449 ] Fix initialiser of TiXmlString::nullrep_
+- Great catch, although there isn't a submitter for the bug. [ 1475201 ] TinyXML parses entities in comments. 
+  Comments should not, in fact, parse entities. Fixed the code path and added tests.
+- We were not catching all the returns from ftell. Thanks to Bernard for catching that.
+  
+2.5.4
+- A TiXMLDocument can't be a sub-node. Block this from happening in the 'replace'. Thanks Noam.
+- [ 1714831 ] TiXmlBase::location is not copied by copy-ctors, fix reported and suggested by Nicola Civran.
+- Fixed possible memory overrun in the comment reading code - thanks gcarlton77
+
+2.5.5
+- Alex van der Wal spotted incorrect types (lf) being used in print and scan. robertnestor pointed out some problems with the simple solution. Types updated.
+- Johannes Hillert pointed out some bug typos.
+- Christian Mueller identified inconsistent error handling with Attributes.
+- olivier barthelemy also reported a problem with double truncation, also related to the %lf issue.
+- zaelsius came up with a great (and simple) suggestion to fix QueryValueAttribute truncating strings.
+- added some null pointer checks suggested by hansenk
+- Sami Visnen found a (rare) buffer overrun that could occur in parsing.
+- vi tri filed a bug that led to a refactoring of the attribute setting mess (as well as adding a missing SetDoubleAttribute() )
+- removed TIXML_ERROR_OUT_OF_MEMORY. TinyXML does not systematically address OOO, and the notion it does is misleading.
+- vanneto, keithmarshall, others all reported the warning from IsWhiteSpace() usage. Cleaned this up - many thanks to everyone who reported this one.
+- tibur found a bug in end tag parsing
+
+
+
+
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/echo.dsp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/echo.dsp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/echo.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/echo.dsp.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,113 @@
+# Microsoft Developer Studio Project File - Name="echo" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=echo - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "echo.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "echo.mak" CFG="echo - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "echo - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "echo - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "echo - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "echoRelease"
+# PROP Intermediate_Dir "echoRelease"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /YX /FD /c
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "echo - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "echo___Win32_Debug"
+# PROP BASE Intermediate_Dir "echo___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "echoDebug"
+# PROP Intermediate_Dir "echoDebug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "echo - Win32 Release"
+# Name "echo - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltester\bugtest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/Makefile.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/Makefile.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/Makefile.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,133 @@
+#****************************************************************************
+#
+# Makefile for TinyXml test.
+# Lee Thomason
+# www.grinninglizard.com
+#
+# This is a GNU make (gmake) makefile
+#****************************************************************************
+
+# DEBUG can be set to YES to include debugging info, or NO otherwise
+DEBUG          := NO
+
+# PROFILE can be set to YES to include profiling info, or NO otherwise
+PROFILE        := NO
+
+# TINYXML_USE_STL can be used to turn on STL support. NO, then STL
+# will not be used. YES will include the STL files.
+TINYXML_USE_STL := NO
+
+#****************************************************************************
+
+CC     ?= gcc
+CXX    ?= g++
+LD     ?= g++
+AR     := ar rc
+RANLIB ?= ranlib
+
+DEBUG_CFLAGS     := -Wall -Wno-format -g -DDEBUG
+RELEASE_CFLAGS   := -Wall -Wno-unknown-pragmas -Wno-format -O3
+
+LIBS		 :=
+
+DEBUG_CXXFLAGS   := ${DEBUG_CFLAGS} 
+RELEASE_CXXFLAGS := ${RELEASE_CFLAGS}
+
+DEBUG_LDFLAGS    := -g
+RELEASE_LDFLAGS  :=
+
+ifeq (YES, ${DEBUG})
+   CFLAGS       := ${DEBUG_CFLAGS}
+   CXXFLAGS     := ${DEBUG_CXXFLAGS}
+   LDFLAGS      := ${DEBUG_LDFLAGS}
+else
+   CFLAGS       := ${RELEASE_CFLAGS}
+   CXXFLAGS     := ${RELEASE_CXXFLAGS}
+   LDFLAGS      := ${RELEASE_LDFLAGS}
+endif
+
+ifeq (YES, ${PROFILE})
+   CFLAGS   := ${CFLAGS} -pg -O3
+   CXXFLAGS := ${CXXFLAGS} -pg -O3
+   LDFLAGS  := ${LDFLAGS} -pg
+endif
+
+#****************************************************************************
+# Preprocessor directives
+#****************************************************************************
+
+ifeq (YES, ${TINYXML_USE_STL})
+  DEFS := -DTIXML_USE_STL
+else
+  DEFS :=
+endif
+
+#****************************************************************************
+# Include paths
+#****************************************************************************
+
+#INCS := -I/usr/include/g++-2 -I/usr/local/include
+INCS :=
+
+
+#****************************************************************************
+# Makefile code common to all platforms
+#****************************************************************************
+
+CFLAGS   := ${CFLAGS}   ${DEFS}
+CXXFLAGS := ${CXXFLAGS} ${DEFS}
+
+#****************************************************************************
+# Targets of the build
+#****************************************************************************
+
+#OUTPUT := xmltest
+OUTPUT := libtinyxml.a
+
+all: ${OUTPUT}
+
+
+#****************************************************************************
+# Source files
+#****************************************************************************
+
+#SRCS := tinyxml.cpp tinyxmlparser.cpp xmltest.cpp tinyxmlerror.cpp tinystr.cpp
+SRCS := tinyxml.cpp tinyxmlparser.cpp tinyxmlerror.cpp tinystr.cpp
+
+# Add on the sources for libraries
+SRCS := ${SRCS}
+
+OBJS := $(addsuffix .o,$(basename ${SRCS}))
+
+#****************************************************************************
+# Output
+#****************************************************************************
+
+${OUTPUT}: ${OBJS}
+#	${LD} -o $@ ${LDFLAGS} ${OBJS} ${LIBS} ${EXTRA_LIBS}
+	${AR} $@ ${OBJS}
+
+#****************************************************************************
+# common rules
+#****************************************************************************
+
+# Rules for compiling source files to object files
+%.o : %.cpp
+	${CXX} -c ${CXXFLAGS} ${INCS} $< -o $@
+
+%.o : %.c
+	${CC} -c ${CFLAGS} ${INCS} $< -o $@
+
+dist:
+	bash makedistlinux
+
+clean:
+	-rm -f core ${OBJS} ${OUTPUT}
+
+depend:
+	#makedepend ${INCS} ${SRCS}
+
+tinyxml.o: tinyxml.h tinystr.h
+tinyxmlparser.o: tinyxml.h tinystr.h
+xmltest.o: tinyxml.h tinystr.h
+tinyxmlerror.o: tinyxml.h tinystr.h
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/readme.txt.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/readme.txt.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/readme.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/readme.txt.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,530 @@
+/** @mainpage
+
+<h1> TinyXML </h1>
+
+TinyXML is a simple, small, C++ XML parser that can be easily 
+integrated into other programs.
+
+<h2> What it does. </h2>
+	
+In brief, TinyXML parses an XML document, and builds from that a 
+Document Object Model (DOM) that can be read, modified, and saved.
+
+XML stands for "eXtensible Markup Language." It allows you to create 
+your own document markups. Where HTML does a very good job of marking 
+documents for browsers, XML allows you to define any kind of document 
+markup, for example a document that describes a "to do" list for an 
+organizer application. XML is a very structured and convenient format.
+All those random file formats created to store application data can 
+all be replaced with XML. One parser for everything.
+
+The best place for the complete, correct, and quite frankly hard to
+read spec is at <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">
+http://www.w3.org/TR/2004/REC-xml-20040204/</a>. An intro to XML
+(that I really like) can be found at 
+<a href="http://skew.org/xml/tutorial/">http://skew.org/xml/tutorial</a>.
+
+There are different ways to access and interact with XML data.
+TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed
+into a C++ objects that can be browsed and manipulated, and then 
+written to disk or another output stream. You can also construct an XML document 
+from scratch with C++ objects and write this to disk or another output
+stream.
+
+TinyXML is designed to be easy and fast to learn. It is two headers 
+and four cpp files. Simply add these to your project and off you go. 
+There is an example file - xmltest.cpp - to get you started. 
+
+TinyXML is released under the ZLib license, 
+so you can use it in open source or commercial code. The details
+of the license are at the top of every source file.
+
+TinyXML attempts to be a flexible parser, but with truly correct and
+compliant XML output. TinyXML should compile on any reasonably C++
+compliant system. It does not rely on exceptions or RTTI. It can be 
+compiled with or without STL support. TinyXML fully supports
+the UTF-8 encoding, and the first 64k character entities.
+
+
+<h2> What it doesn't do. </h2>
+
+TinyXML doesn't parse or use DTDs (Document Type Definitions) or XSLs
+(eXtensible Stylesheet Language.) There are other parsers out there 
+(check out www.sourceforge.org, search for XML) that are much more fully
+featured. But they are also much bigger, take longer to set up in
+your project, have a higher learning curve, and often have a more
+restrictive license. If you are working with browsers or have more
+complete XML needs, TinyXML is not the parser for you.
+
+The following DTD syntax will not parse at this time in TinyXML:
+
+@verbatim
+	<!DOCTYPE Archiv [
+	 <!ELEMENT Comment (#PCDATA)>
+	]>
+@endverbatim
+
+because TinyXML sees this as a !DOCTYPE node with an illegally 
+embedded !ELEMENT node. This may be addressed in the future.
+
+<h2> Tutorials. </h2>
+
+For the impatient, here is a tutorial to get you going. A great way to get started, 
+but it is worth your time to read this (very short) manual completely.
+
+- @subpage tutorial0
+
+<h2> Code Status.  </h2>
+
+TinyXML is mature, tested code. It is very stable. If you find
+bugs, please file a bug report on the sourceforge web site
+(www.sourceforge.net/projects/tinyxml). We'll get them straightened 
+out as soon as possible.
+
+There are some areas of improvement; please check sourceforge if you are
+interested in working on TinyXML.
+
+<h2> Related Projects </h2>
+
+TinyXML projects you may find useful! (Descriptions provided by the projects.)
+
+<ul>
+<li> <b>TinyXPath</b> (http://tinyxpath.sourceforge.net). TinyXPath is a small footprint 
+     XPath syntax decoder, written in C++.</li>
+<li> <b>TinyXML++</b> (http://code.google.com/p/ticpp/). TinyXML++ is a completely new 
+     interface to TinyXML that uses MANY of the C++ strengths. Templates, 
+	 exceptions, and much better error handling.</li>
+</ul>
+
+<h2> Features </h2>
+
+<h3> Using STL </h3>
+
+TinyXML can be compiled to use or not use STL. When using STL, TinyXML
+uses the std::string class, and fully supports std::istream, std::ostream,
+operator<<, and operator>>. Many API methods have both 'const char*' and
+'const std::string&' forms.
+
+When STL support is compiled out, no STL files are included whatsoever. All
+the string classes are implemented by TinyXML itself. API methods
+all use the 'const char*' form for input.
+
+Use the compile time #define:
+
+	TIXML_USE_STL
+
+to compile one version or the other. This can be passed by the compiler,
+or set as the first line of "tinyxml.h".
+
+Note: If compiling the test code in Linux, setting the environment
+variable TINYXML_USE_STL=YES/NO will control STL compilation. In the
+Windows project file, STL and non STL targets are provided. In your project,
+It's probably easiest to add the line "#define TIXML_USE_STL" as the first
+line of tinyxml.h.
+
+<h3> UTF-8 </h3>
+
+TinyXML supports UTF-8 allowing to manipulate XML files in any language. TinyXML
+also supports "legacy mode" - the encoding used before UTF-8 support and
+probably best described as "extended ascii".
+
+Normally, TinyXML will try to detect the correct encoding and use it. However,
+by setting the value of TIXML_DEFAULT_ENCODING in the header file, TinyXML
+can be forced to always use one encoding.
+
+TinyXML will assume Legacy Mode until one of the following occurs:
+<ol>
+	<li> If the non-standard but common "UTF-8 lead bytes" (0xef 0xbb 0xbf)
+		 begin the file or data stream, TinyXML will read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has an encoding="UTF-8", then
+		 TinyXML will read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has no encoding specified, then TinyXML will 
+		 read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has an encoding="something else", then TinyXML 
+		 will read it as Legacy Mode. In legacy mode, TinyXML will work as it did before. It's 
+		 not clear what that mode does exactly, but old content should keep working.</li>
+	<li> Until one of the above criteria is met, TinyXML runs in Legacy Mode.</li>
+</ol>
+
+What happens if the encoding is incorrectly set or detected? TinyXML will try
+to read and pass through text seen as improperly encoded. You may get some strange results or 
+mangled characters. You may want to force TinyXML to the correct mode.
+
+You may force TinyXML to Legacy Mode by using LoadFile( TIXML_ENCODING_LEGACY ) or
+LoadFile( filename, TIXML_ENCODING_LEGACY ). You may force it to use legacy mode all
+the time by setting TIXML_DEFAULT_ENCODING = TIXML_ENCODING_LEGACY. Likewise, you may 
+force it to TIXML_ENCODING_UTF8 with the same technique.
+
+For English users, using English XML, UTF-8 is the same as low-ASCII. You
+don't need to be aware of UTF-8 or change your code in any way. You can think
+of UTF-8 as a "superset" of ASCII.
+
+UTF-8 is not a double byte format - but it is a standard encoding of Unicode!
+TinyXML does not use or directly support wchar, TCHAR, or Microsoft's _UNICODE at this time. 
+It is common to see the term "Unicode" improperly refer to UTF-16, a wide byte encoding
+of unicode. This is a source of confusion.
+
+For "high-ascii" languages - everything not English, pretty much - TinyXML can
+handle all languages, at the same time, as long as the XML is encoded
+in UTF-8. That can be a little tricky, older programs and operating systems
+tend to use the "default" or "traditional" code page. Many apps (and almost all
+modern ones) can output UTF-8, but older or stubborn (or just broken) ones
+still output text in the default code page. 
+
+For example, Japanese systems traditionally use SHIFT-JIS encoding. 
+Text encoded as SHIFT-JIS can not be read by TinyXML. 
+A good text editor can import SHIFT-JIS and then save as UTF-8.
+
+The <a href="http://skew.org/xml/tutorial/">Skew.org link</a> does a great
+job covering the encoding issue.
+
+The test file "utf8test.xml" is an XML containing English, Spanish, Russian,
+and Simplified Chinese. (Hopefully they are translated correctly). The file
+"utf8test.gif" is a screen capture of the XML file, rendered in IE. Note that
+if you don't have the correct fonts (Simplified Chinese or Russian) on your
+system, you won't see output that matches the GIF file even if you can parse
+it correctly. Also note that (at least on my Windows machine) console output
+is in a Western code page, so that Print() or printf() cannot correctly display
+the file. This is not a bug in TinyXML - just an OS issue. No data is lost or 
+destroyed by TinyXML. The console just doesn't render UTF-8.
+
+
+<h3> Entities </h3>
+TinyXML recognizes the pre-defined "character entities", meaning special
+characters. Namely:
+
+@verbatim
+	&amp;	&
+	&lt;	<
+	&gt;	>
+	&quot;	"
+	&apos;	'
+@endverbatim
+
+These are recognized when the XML document is read, and translated to there
+UTF-8 equivalents. For instance, text with the XML of:
+
+@verbatim
+	Far &amp; Away
+@endverbatim
+
+will have the Value() of "Far & Away" when queried from the TiXmlText object,
+and will be written back to the XML stream/file as an ampersand. Older versions
+of TinyXML "preserved" character entities, but the newer versions will translate
+them into characters.
+
+Additionally, any character can be specified by its Unicode code point:
+The syntax "&#xA0;" or "&#160;" are both to the non-breaking space characher.
+
+<h3> Printing </h3>
+TinyXML can print output in several different ways that all have strengths and limitations.
+
+- Print( FILE* ). Output to a std-C stream, which includes all C files as well as stdout.
+	- "Pretty prints", but you don't have control over printing options.
+	- The output is streamed directly to the FILE object, so there is no memory overhead
+	  in the TinyXML code.
+	- used by Print() and SaveFile()
+
+- operator<<. Output to a c++ stream.
+	- Integrates with standart C++ iostreams.
+	- Outputs in "network printing" mode without line breaks. Good for network transmission
+	  and moving XML between C++ objects, but hard for a human to read.
+
+- TiXmlPrinter. Output to a std::string or memory buffer.
+	- API is less concise
+	- Future printing options will be put here.
+	- Printing may change slightly in future versions as it is refined and expanded.
+
+<h3> Streams </h3>
+With TIXML_USE_STL on TinyXML supports C++ streams (operator <<,>>) streams as well
+as C (FILE*) streams. There are some differences that you may need to be aware of.
+
+C style output:
+	- based on FILE*
+	- the Print() and SaveFile() methods
+
+	Generates formatted output, with plenty of white space, intended to be as 
+	human-readable as possible. They are very fast, and tolerant of ill formed 
+	XML documents. For example, an XML document that contains 2 root elements 
+	and 2 declarations, will still print.
+
+C style input:
+	- based on FILE*
+	- the Parse() and LoadFile() methods
+
+	A fast, tolerant read. Use whenever you don't need the C++ streams.
+
+C++ style output:
+	- based on std::ostream
+	- operator<<
+
+	Generates condensed output, intended for network transmission rather than
+	readability. Depending on your system's implementation of the ostream class,
+	these may be somewhat slower. (Or may not.) Not tolerant of ill formed XML:
+	a document should contain the correct one root element. Additional root level
+	elements will not be streamed out.
+
+C++ style input:
+	- based on std::istream
+	- operator>>
+
+	Reads XML from a stream, making it useful for network transmission. The tricky
+	part is knowing when the XML document is complete, since there will almost
+	certainly be other data in the stream. TinyXML will assume the XML data is
+	complete after it reads the root element. Put another way, documents that
+	are ill-constructed with more than one root element will not read correctly.
+	Also note that operator>> is somewhat slower than Parse, due to both 
+	implementation of the STL and limitations of TinyXML.
+
+<h3> White space </h3>
+The world simply does not agree on whether white space should be kept, or condensed.
+For example, pretend the '_' is a space, and look at "Hello____world". HTML, and 
+at least some XML parsers, will interpret this as "Hello_world". They condense white
+space. Some XML parsers do not, and will leave it as "Hello____world". (Remember
+to keep pretending the _ is a space.) Others suggest that __Hello___world__ should become
+Hello___world.
+
+It's an issue that hasn't been resolved to my satisfaction. TinyXML supports the
+first 2 approaches. Call TiXmlBase::SetCondenseWhiteSpace( bool ) to set the desired behavior.
+The default is to condense white space.
+
+If you change the default, you should call TiXmlBase::SetCondenseWhiteSpace( bool )
+before making any calls to Parse XML data, and I don't recommend changing it after
+it has been set.
+
+
+<h3> Handles </h3>
+
+Where browsing an XML document in a robust way, it is important to check
+for null returns from method calls. An error safe implementation can
+generate a lot of code like:
+
+@verbatim
+TiXmlElement* root = document.FirstChildElement( "Document" );
+if ( root )
+{
+	TiXmlElement* element = root->FirstChildElement( "Element" );
+	if ( element )
+	{
+		TiXmlElement* child = element->FirstChildElement( "Child" );
+		if ( child )
+		{
+			TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+			if ( child2 )
+			{
+				// Finally do something useful.
+@endverbatim
+
+Handles have been introduced to clean this up. Using the TiXmlHandle class,
+the previous code reduces to:
+
+@verbatim
+TiXmlHandle docHandle( &document );
+TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+if ( child2 )
+{
+	// do something useful
+@endverbatim
+
+Which is much easier to deal with. See TiXmlHandle for more information.
+
+
+<h3> Row and Column tracking </h3>
+Being able to track nodes and attributes back to their origin location
+in source files can be very important for some applications. Additionally,
+knowing where parsing errors occured in the original source can be very
+time saving.
+
+TinyXML can tracks the row and column origin of all nodes and attributes
+in a text file. The TiXmlBase::Row() and TiXmlBase::Column() methods return
+the origin of the node in the source text. The correct tabs can be 
+configured in TiXmlDocument::SetTabSize().
+
+
+<h2> Using and Installing </h2>
+
+To Compile and Run xmltest:
+
+A Linux Makefile and a Windows Visual C++ .dsw file is provided. 
+Simply compile and run. It will write the file demotest.xml to your 
+disk and generate output on the screen. It also tests walking the
+DOM by printing out the number of nodes found using different 
+techniques.
+
+The Linux makefile is very generic and runs on many systems - it 
+is currently tested on mingw and
+MacOSX. You do not need to run 'make depend'. The dependecies have been
+hard coded.
+
+<h3>Windows project file for VC6</h3>
+<ul>
+<li>tinyxml:		tinyxml library, non-STL </li>
+<li>tinyxmlSTL:		tinyxml library, STL </li>
+<li>tinyXmlTest:	test app, non-STL </li>
+<li>tinyXmlTestSTL: test app, STL </li>
+</ul>
+
+<h3>Makefile</h3>
+At the top of the makefile you can set:
+
+PROFILE, DEBUG, and TINYXML_USE_STL. Details (such that they are) are in
+the makefile.
+
+In the tinyxml directory, type "make clean" then "make". The executable
+file 'xmltest' will be created.
+
+
+
+<h3>To Use in an Application:</h3>
+
+Add tinyxml.cpp, tinyxml.h, tinyxmlerror.cpp, tinyxmlparser.cpp, tinystr.cpp, and tinystr.h to your
+project or make file. That's it! It should compile on any reasonably
+compliant C++ system. You do not need to enable exceptions or
+RTTI for TinyXML.
+
+
+<h2> How TinyXML works.  </h2>
+
+An example is probably the best way to go. Take:
+@verbatim
+	<?xml version="1.0" standalone=no>
+	<!-- Our to do list data -->
+	<ToDo>
+		<Item priority="1"> Go to the <bold>Toy store!</bold></Item>
+		<Item priority="2"> Do bills</Item>
+	</ToDo>
+@endverbatim
+
+Its not much of a To Do list, but it will do. To read this file 
+(say "demo.xml") you would create a document, and parse it in:
+@verbatim
+	TiXmlDocument doc( "demo.xml" );
+	doc.LoadFile();
+@endverbatim
+
+And its ready to go. Now lets look at some lines and how they 
+relate to the DOM.
+
+@verbatim
+<?xml version="1.0" standalone=no>
+@endverbatim
+
+	The first line is a declaration, and gets turned into the
+	TiXmlDeclaration class. It will be the first child of the
+	document node.
+	
+	This is the only directive/special tag parsed by TinyXML.
+	Generally directive tags are stored in TiXmlUnknown so the 
+	commands wont be lost when it is saved back to disk.
+
+@verbatim
+<!-- Our to do list data -->
+@endverbatim
+
+	A comment. Will become a TiXmlComment object.
+
+@verbatim
+<ToDo>
+@endverbatim
+
+	The "ToDo" tag defines a TiXmlElement object. This one does not have 
+	any attributes, but does contain 2 other elements.
+
+@verbatim
+<Item priority="1"> 
+@endverbatim
+
+	Creates another TiXmlElement which is a child of the "ToDo" element. 
+	This element has 1 attribute, with the name "priority" and the value 
+	"1".
+
+@verbatim
+Go to the
+@endverbatim 
+
+	A TiXmlText. This is a leaf node and cannot contain other nodes. 
+	It is a child of the "Item" TiXmlElement.
+
+@verbatim
+<bold>
+@endverbatim
+
+	
+	Another TiXmlElement, this one a child of the "Item" element.
+
+Etc.
+
+Looking at the entire object tree, you end up with:
+@verbatim
+TiXmlDocument					"demo.xml"
+	TiXmlDeclaration			"version='1.0'" "standalone=no"
+	TiXmlComment				" Our to do list data"
+	TiXmlElement				"ToDo"
+		TiXmlElement			"Item" Attribtutes: priority = 1
+			TiXmlText			"Go to the "
+			TiXmlElement		"bold"
+				TiXmlText		"Toy store!"
+		TiXmlElement			"Item" Attributes: priority=2
+			TiXmlText			"Do bills"
+@endverbatim
+
+<h2> Documentation </h2>
+
+The documentation is build with Doxygen, using the 'dox' 
+configuration file.
+
+<h2> License </h2>
+
+TinyXML is released under the zlib license:
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this 
+software in a product, an acknowledgment in the product documentation 
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+
+<h2> References  </h2>
+
+The World Wide Web Consortium is the definitive standard body for 
+XML, and their web pages contain huge amounts of information. 
+
+The definitive spec: <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">
+http://www.w3.org/TR/2004/REC-xml-20040204/</a>
+
+I also recommend "XML Pocket Reference" by Robert Eckstein and published by 
+OReilly...the book that got the whole thing started.
+
+<h2> Contributors, Contacts, and a Brief History </h2>
+
+Thanks very much to everyone who sends suggestions, bugs, ideas, and 
+encouragement. It all helps, and makes this project fun. A special thanks
+to the contributors on the web pages that keep it lively.
+
+So many people have sent in bugs and ideas, that rather than list here 
+we try to give credit due in the "changes.txt" file.
+
+TinyXML was originally written by Lee Thomason. (Often the "I" still
+in the documentation.) Lee reviews changes and releases new versions,
+with the help of Yves Berquin, Andrew Ellerton, and the tinyXml community.
+
+We appreciate your suggestions, and would love to know if you 
+use TinyXML. Hopefully you will enjoy it and find it useful. 
+Please post questions, comments, file bugs, or contact us at:
+
+www.sourceforge.net/projects/tinyxml
+
+Lee Thomason, Yves Berquin, Andrew Ellerton
+*/
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinystr.cpp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinystr.cpp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinystr.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinystr.cpp.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,116 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lvset, 7. April 2005.
+ */
+
+
+#ifndef TIXML_USE_STL
+
+#include "tinystr.h"
+
+// Error value for find primitive
+const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);
+
+
+// Null rep.
+TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\0' } };
+
+
+void TiXmlString::reserve (size_type cap)
+{
+	if (cap > capacity())
+	{
+		TiXmlString tmp;
+		tmp.init(length(), cap);
+		memcpy(tmp.start(), data(), length());
+		swap(tmp);
+	}
+}
+
+
+TiXmlString& TiXmlString::assign(const char* str, size_type len)
+{
+	size_type cap = capacity();
+	if (len > cap || cap > 3*(len + 8))
+	{
+		TiXmlString tmp;
+		tmp.init(len);
+		memcpy(tmp.start(), str, len);
+		swap(tmp);
+	}
+	else
+	{
+		memmove(start(), str, len);
+		set_size(len);
+	}
+	return *this;
+}
+
+
+TiXmlString& TiXmlString::append(const char* str, size_type len)
+{
+	size_type newsize = length() + len;
+	if (newsize > capacity())
+	{
+		reserve (newsize + capacity());
+	}
+	memmove(finish(), str, len);
+	set_size(newsize);
+	return *this;
+}
+
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	tmp.reserve(a.length() + b.length());
+	tmp += a;
+	tmp += b;
+	return tmp;
+}
+
+TiXmlString operator + (const TiXmlString & a, const char* b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
+	tmp.reserve(a.length() + b_len);
+	tmp += a;
+	tmp.append(b, b_len);
+	return tmp;
+}
+
+TiXmlString operator + (const char* a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
+	tmp.reserve(a_len + b.length());
+	tmp.append(a, a_len);
+	tmp += b;
+	return tmp;
+}
+
+
+#endif	// TIXML_USE_STL
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinystr.h.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinystr.h.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinystr.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinystr.h.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,319 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
+ *
+ * - completely rewritten. compact, clean, and fast implementation.
+ * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
+ * - fixed reserve() to work as per specification.
+ * - fixed buggy compares operator==(), operator<(), and operator>()
+ * - fixed operator+=() to take a const ref argument, following spec.
+ * - added "copy" constructor with length, and most compare operators.
+ * - added swap(), clear(), size(), capacity(), operator+().
+ */
+
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#include <assert.h>
+#include <string.h>
+
+/*	The support for explicit isn't that universal, and it isn't really
+	required - it is used to check that the TiXmlString class isn't incorrectly
+	used. Be nice to old compilers and macro it here:
+*/
+#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
+	// Microsoft visual studio, version 6 and higher.
+	#define TIXML_EXPLICIT explicit
+#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+	// GCC version 3 and higher.s
+	#define TIXML_EXPLICIT explicit
+#else
+	#define TIXML_EXPLICIT
+#endif
+
+
+/*
+   TiXmlString is an emulation of a subset of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TiXmlString
+{
+  public :
+	// The size type used
+  	typedef size_t size_type;
+
+	// Error value for find primitive
+	static const size_type npos; // = -1;
+
+
+	// TiXmlString empty constructor
+	TiXmlString () : rep_(&nullrep_)
+	{
+	}
+
+	// TiXmlString copy constructor
+	TiXmlString ( const TiXmlString & copy) : rep_(0)
+	{
+		init(copy.length());
+		memcpy(start(), copy.data(), length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
+	{
+		init( static_cast<size_type>( strlen(copy) ));
+		memcpy(start(), copy, length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
+	{
+		init(len);
+		memcpy(start(), str, len);
+	}
+
+	// TiXmlString destructor
+	~TiXmlString ()
+	{
+		quit();
+	}
+
+	// = operator
+	TiXmlString& operator = (const char * copy)
+	{
+		return assign( copy, (size_type)strlen(copy));
+	}
+
+	// = operator
+	TiXmlString& operator = (const TiXmlString & copy)
+	{
+		return assign(copy.start(), copy.length());
+	}
+
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const char * suffix)
+	{
+		return append(suffix, static_cast<size_type>( strlen(suffix) ));
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (char single)
+	{
+		return append(&single, 1);
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const TiXmlString & suffix)
+	{
+		return append(suffix.data(), suffix.length());
+	}
+
+
+	// Convert a TiXmlString into a null-terminated char *
+	const char * c_str () const { return rep_->str; }
+
+	// Convert a TiXmlString into a char * (need not be null terminated).
+	const char * data () const { return rep_->str; }
+
+	// Return the length of a TiXmlString
+	size_type length () const { return rep_->size; }
+
+	// Alias for length()
+	size_type size () const { return rep_->size; }
+
+	// Checks if a TiXmlString is empty
+	bool empty () const { return rep_->size == 0; }
+
+	// Return capacity of string
+	size_type capacity () const { return rep_->capacity; }
+
+
+	// single char extraction
+	const char& at (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// [] operator
+	char& operator [] (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// find a char in a string. Return TiXmlString::npos if not found
+	size_type find (char lookup) const
+	{
+		return find(lookup, 0);
+	}
+
+	// find a char in a string from an offset. Return TiXmlString::npos if not found
+	size_type find (char tofind, size_type offset) const
+	{
+		if (offset >= length()) return npos;
+
+		for (const char* p = c_str() + offset; *p != '\0'; ++p)
+		{
+		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
+		}
+		return npos;
+	}
+
+	void clear ()
+	{
+		//Lee:
+		//The original was just too strange, though correct:
+		//	TiXmlString().swap(*this);
+		//Instead use the quit & re-init:
+		quit();
+		init(0,0);
+	}
+
+	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function DOES NOT clear the content of the TiXmlString if any exists.
+	*/
+	void reserve (size_type cap);
+
+	TiXmlString& assign (const char* str, size_type len);
+
+	TiXmlString& append (const char* str, size_type len);
+
+	void swap (TiXmlString& other)
+	{
+		Rep* r = rep_;
+		rep_ = other.rep_;
+		other.rep_ = r;
+	}
+
+  private:
+
+	void init(size_type sz) { init(sz, sz); }
+	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
+	char* start() const { return rep_->str; }
+	char* finish() const { return rep_->str + rep_->size; }
+
+	struct Rep
+	{
+		size_type size, capacity;
+		char str[1];
+	};
+
+	void init(size_type sz, size_type cap)
+	{
+		if (cap)
+		{
+			// Lee: the original form:
+			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
+			// doesn't work in some cases of new being overloaded. Switching
+			// to the normal allocation, although use an 'int' for systems
+			// that are overly picky about structure alignment.
+			const size_type bytesNeeded = sizeof(Rep) + cap;
+			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
+			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );
+
+			rep_->str[ rep_->size = sz ] = '\0';
+			rep_->capacity = cap;
+		}
+		else
+		{
+			rep_ = &nullrep_;
+		}
+	}
+
+	void quit()
+	{
+		if (rep_ != &nullrep_)
+		{
+			// The rep_ is really an array of ints. (see the allocator, above).
+			// Cast it back before delete, so the compiler won't incorrectly call destructors.
+			delete [] ( reinterpret_cast<int*>( rep_ ) );
+		}
+	}
+
+	Rep * rep_;
+	static Rep nullrep_;
+
+} ;
+
+
+inline bool operator == (const TiXmlString & a, const TiXmlString & b)
+{
+	return    ( a.length() == b.length() )				// optimization on some platforms
+	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
+}
+inline bool operator < (const TiXmlString & a, const TiXmlString & b)
+{
+	return strcmp(a.c_str(), b.c_str()) < 0;
+}
+
+inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
+inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
+inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
+inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }
+
+inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
+inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
+inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
+inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
+TiXmlString operator + (const TiXmlString & a, const char* b);
+TiXmlString operator + (const char* a, const TiXmlString & b);
+
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TiXmlOutStream : public TiXmlString
+{
+public :
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const TiXmlString & in)
+	{
+		*this += in;
+		return *this;
+	}
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const char * in)
+	{
+		*this += in;
+		return *this;
+	}
+
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.cpp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.cpp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.cpp.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,1839 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include <ctype.h>
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#include <iostream>
+#endif
+
+#include "tinyxml.h"
+
+FILE* TiXmlFOpen( const char* filename, const char* mode );
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+// Microsoft compiler security
+FILE* TiXmlFOpen( const char* filename, const char* mode )
+{
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		FILE* fp = 0;
+		errno_t err = fopen_s( &fp, filename, mode );
+		if ( !err && fp )
+			return fp;
+		return 0;
+	#else
+		return fopen( filename, mode );
+	#endif
+}
+
+void TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&' 
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+			
+			#if defined(TIXML_SNPRINTF)		
+				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#else
+				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#endif		
+
+			//*ME:	warning C4267: convert 'size_t' to 'int'
+			//*ME:	Int-Cast to make compiler happy ...
+			outString->append( buf, (int)strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+
+TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
+{
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData; 
+	target->location = location;
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	assert( node->parent == 0 || node->parent == this );
+	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );
+
+	if ( node->Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		delete node;
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{	
+	if ( !beforeThis || beforeThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( !replaceThis )
+		return 0;
+
+	if ( replaceThis->parent != this )
+		return 0;
+
+	if ( withThis.ToDocument() ) {
+		// A document can never be a child.	Thanks to Noam.
+		TiXmlDocument* document = GetDocument();
+		if ( document ) 
+			document->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( !removeThis ) {
+		return false;
+	}
+
+	if ( removeThis->parent != this )
+	{	
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const 
+{
+	const TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING str( name );
+	TiXmlAttribute* node = attributeSet.Find( str );
+	#else
+	TiXmlAttribute* node = attributeSet.Find( name );
+	#endif
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+const TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value ) 
+	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char* TiXmlElement::Attribute( const char* name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return node->Value();
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( attrib )
+		return &attrib->ValueStr();
+	return 0;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, int* i ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const char* result = 0;
+
+	if ( attrib ) {
+		result = attrib->Value();
+		if ( i ) {
+			attrib->QueryIntValue( i );
+		}
+	}
+	return result;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const std::string* result = 0;
+
+	if ( attrib ) {
+		result = &attrib->ValueStr();
+		if ( i ) {
+			attrib->QueryIntValue( i );
+		}
+	}
+	return result;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, double* d ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const char* result = 0;
+
+	if ( attrib ) {
+		result = attrib->Value();
+		if ( d ) {
+			attrib->QueryDoubleValue( d );
+		}
+	}
+	return result;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const std::string* result = 0;
+
+	if ( attrib ) {
+		result = &attrib->ValueStr();
+		if ( d ) {
+			attrib->QueryDoubleValue( d );
+		}
+	}
+	return result;
+}
+#endif
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryIntValue( ival );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryIntValue( ival );
+}
+#endif
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryDoubleValue( dval );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryDoubleValue( dval );
+}
+#endif
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetIntValue( val );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, int val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetIntValue( val );
+	}
+}
+#endif
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetDoubleValue( val );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetDoubleAttribute( const std::string& name, double val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetDoubleValue( val );
+	}
+}
+#endif 
+
+
+void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
+{
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( cname );
+	if ( attrib ) {
+		attrib->SetValue( cvalue );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& _name, const std::string& _value )
+{
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( _name );
+	if ( attrib ) {
+		attrib->SetValue( _value );
+	}
+}
+#endif
+
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	assert( cfile );
+	for ( i=0; i<depth; i++ ) {
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	const TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class: 
+	// Clone the attributes, then clone the children.
+	const TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this, attributeSet.First() ) ) 
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+const char* TiXmlElement::GetText() const
+{
+	const TiXmlNode* child = this->FirstChild();
+	if ( child ) {
+		const TiXmlText* childText = child->ToText();
+		if ( childText ) {
+			return childText->Value();
+		}
+	}
+	return 0;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	return LoadFile( Value(), encoding );
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	return SaveFile( Value() );
+}
+
+bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
+{
+	TIXML_STRING filename( _filename );
+	value = filename;
+
+	// reading in binary mode so that tinyxml can normalize the EOL
+	FILE* file = TiXmlFOpen( value.c_str (), "rb" );	
+
+	if ( file )
+	{
+		bool result = LoadFile( file, encoding );
+		fclose( file );
+		return result;
+	}
+	else
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+}
+
+bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
+{
+	if ( !file ) 
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+	long length = 0;
+	fseek( file, 0, SEEK_END );
+	length = ftell( file );
+	fseek( file, 0, SEEK_SET );
+
+	// Strange case, but good to handle up front.
+	if ( length <= 0 )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
+	// 2.11 End-of-Line Handling
+	// <snip>
+	// <quote>
+	// ...the XML processor MUST behave as if it normalized all line breaks in external 
+	// parsed entities (including the document entity) on input, before parsing, by translating 
+	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to 
+	// a single #xA character.
+	// </quote>
+	//
+	// It is not clear fgets does that, and certainly isn't clear it works cross platform. 
+	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
+	// convention, and not work generally.
+
+	/*
+	while( fgets( buf, sizeof(buf), file ) )
+	{
+		data += buf;
+	}
+	*/
+
+	char* buf = new char[ length+1 ];
+	buf[0] = 0;
+
+	if ( fread( buf, length, 1, file ) != 1 ) {
+		delete [] buf;
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Process the buffer in place to normalize new lines. (See comment above.)
+	// Copies from the 'p' to 'q' pointer, where p can advance faster if
+	// a newline-carriage return is hit.
+	//
+	// Wikipedia:
+	// Systems based on ASCII or a compatible character set use either LF  (Line feed, '\n', 0x0A, 10 in decimal) or 
+	// CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF (CR+LF, 0x0D 0x0A)...
+	//		* LF:    Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS, Amiga, RISC OS, and others
+    //		* CR+LF: DEC RT-11 and most other early non-Unix, non-IBM OSes, CP/M, MP/M, DOS, OS/2, Microsoft Windows, Symbian OS
+    //		* CR:    Commodore 8-bit machines, Apple II family, Mac OS up to version 9 and OS-9
+
+	const char* p = buf;	// the read head
+	char* q = buf;			// the write head
+	const char CR = 0x0d;
+	const char LF = 0x0a;
+
+	buf[length] = 0;
+	while( *p ) {
+		assert( p < (buf+length) );
+		assert( q <= (buf+length) );
+		assert( q <= p );
+
+		if ( *p == CR ) {
+			*q++ = LF;
+			p++;
+			if ( *p == LF ) {		// check for CR+LF (and skip LF)
+				p++;
+			}
+		}
+		else {
+			*q++ = *p++;
+		}
+	}
+	assert( q <= (buf+length) );
+	*q = 0;
+
+	Parse( buf, 0, encoding );
+
+	delete [] buf;
+	return !Error();
+}
+
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = TiXmlFOpen( filename, "w" );
+	if ( fp )
+	{
+		bool result = SaveFile( fp );
+		fclose( fp );
+		return result;
+	}
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile( FILE* fp ) const
+{
+	if ( useMicrosoftBOM ) 
+	{
+		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+		fputc( TIXML_UTF_LEAD_0, fp );
+		fputc( TIXML_UTF_LEAD_1, fp );
+		fputc( TIXML_UTF_LEAD_2, fp );
+	}
+	Print( fp, 0 );
+	return (ferror(fp) == 0);
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorId = errorId;
+	target->errorDesc = errorDesc;
+	target->tabsize = tabsize;
+	target->errorLocation = errorLocation;
+	target->useMicrosoftBOM = useMicrosoftBOM;
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}	
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+
+bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this ) )
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+const TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Next()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+*/
+
+const TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Previous()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+*/
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	TIXML_STRING n, v;
+
+	EncodeString( name, &n );
+	EncodeString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos) {
+		if ( cfile ) {
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
+		}
+	}
+	else {
+		if ( cfile ) {
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
+		}
+	}
+}
+
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
+	#else
+		sprintf (buf, "%d", _value);
+	#endif
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [256];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%g", _value);
+	#else
+		sprintf (buf, "%g", _value);
+	#endif
+	SetValue (buf);
+}
+
+int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( int i=0; i<depth; i++ )
+	{
+		fprintf( cfile,  "    " );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	if ( cdata )
+	{
+		int i;
+		fprintf( cfile, "\n" );
+		for ( i=0; i<depth; i++ ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
+	}
+	else
+	{
+		TIXML_STRING buffer;
+		EncodeString( value, &buffer );
+		fprintf( cfile, "%s", buffer.c_str() );
+	}
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+	target->cdata = cdata;
+}
+
+
+bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{	
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
+{
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	if ( cfile ) fprintf( cfile, "<?xml " );
+	if ( str )	 (*str) += "<?xml ";
+
+	if ( !version.empty() ) {
+		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
+		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
+	}
+	if ( !encoding.empty() ) {
+		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
+	}
+	if ( !standalone.empty() ) {
+		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
+	}
+	if ( cfile ) fprintf( cfile, "?>" );
+	if ( str )	 (*str) += "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{	
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+    #ifdef TIXML_USE_STL
+	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
+	#else
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+	#endif
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+TiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const std::string& _name )
+{
+	TiXmlAttribute* attrib = Find( _name );
+	if ( !attrib ) {
+		attrib = new TiXmlAttribute();
+		Add( attrib );
+		attrib->SetName( _name );
+	}
+	return attrib;
+}
+#endif
+
+
+TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+TiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const char* _name )
+{
+	TiXmlAttribute* attrib = Find( _name );
+	if ( !attrib ) {
+		attrib = new TiXmlAttribute();
+		Add( attrib );
+		attrib->SetName( _name );
+	}
+	return attrib;
+}
+
+
+#ifdef TIXML_USE_STL	
+std::istream& operator>> (std::istream & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+#ifdef TIXML_USE_STL	
+std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out << printer.Str();
+
+	return out;
+}
+
+
+std::string& operator<< (std::string& out, const TiXmlNode& base )
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out.append( printer.Str() );
+
+	return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += element.Value();
+
+	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
+	{
+		buffer += " ";
+		attrib->Print( 0, 0, &buffer );
+	}
+
+	if ( !element.FirstChild() ) 
+	{
+		buffer += " />";
+		DoLineBreak();
+	}
+	else 
+	{
+		buffer += ">";
+		if (    element.FirstChild()->ToText()
+			  && element.LastChild() == element.FirstChild()
+			  && element.FirstChild()->ToText()->CDATA() == false )
+		{
+			simpleTextPrint = true;
+			// no DoLineBreak()!
+		}
+		else
+		{
+			DoLineBreak();
+		}
+	}
+	++depth;	
+	return true;
+}
+
+
+bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
+{
+	--depth;
+	if ( !element.FirstChild() ) 
+	{
+		// nothing.
+	}
+	else 
+	{
+		if ( simpleTextPrint )
+		{
+			simpleTextPrint = false;
+		}
+		else
+		{
+			DoIndent();
+		}
+		buffer += "</";
+		buffer += element.Value();
+		buffer += ">";
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlText& text )
+{
+	if ( text.CDATA() )
+	{
+		DoIndent();
+		buffer += "<![CDATA[";
+		buffer += text.Value();
+		buffer += "]]>";
+		DoLineBreak();
+	}
+	else if ( simpleTextPrint )
+	{
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+	}
+	else
+	{
+		DoIndent();
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
+{
+	DoIndent();
+	declaration.Print( 0, 0, &buffer );
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlComment& comment )
+{
+	DoIndent();
+	buffer += "<!--";
+	buffer += comment.Value();
+	buffer += "-->";
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += unknown.Value();
+	buffer += ">";
+	DoLineBreak();
+	return true;
+}
+
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.dsw.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.dsw.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.dsw.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,71 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "tinyXmlTest"=.\tinyXmlTest.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name tinyxml
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tinyXmlTestSTL"=.\tinyXmlTestSTL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name tinyxmlSTL
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tinyxml"=.\tinyxml_lib.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "tinyxmlSTL"=.\tinyxmlSTL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlerror.cpp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlerror.cpp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlerror.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlerror.cpp.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,52 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// english error messages, but the could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+	"Error parsing CDATA.",
+	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
+};
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.h.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.h.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.h.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,1799 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#include <sstream>
+	#define TIXML_STRING		std::string
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING		TiXmlString
+#endif
+
+// Deprecated library function hell. Compilers want to use the
+// new safe versions. This probably doesn't fully address the problem,
+// but it gets closer. There are too many compilers for me to fully
+// test. If you get compilation troubles, undefine TIXML_SAFE
+#define TIXML_SAFE
+
+#ifdef TIXML_SAFE
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		// Microsoft visual studio, version 2005 and higher.
+		#define TIXML_SNPRINTF _snprintf_s
+		#define TIXML_SSCANF   sscanf_s
+	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
+		// Microsoft visual studio, version 6 and higher.
+		//#pragma message( "Using _sn* functions." )
+		#define TIXML_SNPRINTF _snprintf
+		#define TIXML_SSCANF   sscanf
+	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+		// GCC version 3 and higher.s
+		//#warning( "Using sn* functions." )
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SSCANF   sscanf
+	#else
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SSCANF   sscanf
+	#endif
+#endif	
+
+class TiXmlDocument;
+class TiXmlElement;
+class TiXmlComment;
+class TiXmlUnknown;
+class TiXmlAttribute;
+class TiXmlText;
+class TiXmlDeclaration;
+class TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 6;
+const int TIXML_PATCH_VERSION = 1;
+
+/*	Internal structure for tracking location of items 
+	in the XML file.
+*/
+struct TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+/**
+	Implements the interface to the "Visitor pattern" (see the Accept() method.)
+	If you call the Accept() method, it requires being passed a TiXmlVisitor
+	class to handle callbacks. For nodes that contain other nodes (Document, Element)
+	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
+	are simply called with Visit().
+
+	If you return 'true' from a Visit method, recursive parsing will continue. If you return
+	false, <b>no children of this node or its sibilings</b> will be Visited.
+
+	All flavors of Visit methods have a default implementation that returns 'true' (continue 
+	visiting). You need to only override methods that are interesting to you.
+
+	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.
+
+	You should never change the document from a callback.
+
+	@sa TiXmlNode::Accept()
+*/
+class TiXmlVisitor
+{
+public:
+	virtual ~TiXmlVisitor() {}
+
+	/// Visit a document.
+	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
+	/// Visit a document.
+	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }
+
+	/// Visit an element.
+	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
+	/// Visit an element.
+	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }
+
+	/// Visit a declaration
+	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
+	/// Visit a text node
+	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
+	/// Visit a comment node
+	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
+	/// Visit an unknow node
+	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
+};
+
+// Only used by Attribute::Query functions
+enum 
+{ 
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+class TiXmlBase
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0)		{}
+	virtual ~TiXmlBase()			{}
+
+	/**	All TinyXml classes can print themselves to a filestream
+		or the string class (TiXmlString in non-STL mode, std::string
+		in STL mode.) Either or both cfile and str can be null.
+		
+		This is a formatted print, and will insert 
+		tabs and newlines.
+		
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		value is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
+	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
+	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p, 
+								TiXmlParsingData* data, 
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
+		or they will be transformed into entities!
+	*/
+	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+		TIXML_ERROR_PARSING_CDATA,
+		TIXML_ERROR_DOCUMENT_TOP_ONLY,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+
+protected:
+
+	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+
+	inline static bool IsWhiteSpace( char c )		
+	{ 
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
+	}
+	inline static bool IsWhiteSpace( int c )
+	{
+		if ( c < 256 )
+			return IsWhiteSpace( (char) c );
+		return false;	// Again, only truly correct for English/Latin...but usually works.
+	}
+
+	#ifdef TIXML_USE_STL
+	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((const unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
+												// and the null terminator isn't needed
+			for( int i=0; p[i] && i<*length; ++i ) {
+				_value[i] = p[i];
+			}
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to English words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+	
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL	
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+		    
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */	
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		TINYXML_DOCUMENT,
+		TINYXML_ELEMENT,
+		TINYXML_COMMENT,
+		TINYXML_UNKNOWN,
+		TINYXML_TEXT,
+		TINYXML_DECLARATION,
+		TINYXML_TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char *Value() const { return value.c_str (); }
+
+    #ifdef TIXML_USE_STL
+	/** Return Value() as a std::string. If you only use STL,
+	    this is more efficient than calling Value().
+		Only available in STL mode.
+	*/
+	const std::string& ValueStr() const { return value; }
+	#endif
+
+	const TIXML_STRING& ValueTStr() const { return value; }
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent()							{ return parent; }
+	const TiXmlNode* Parent() const				{ return parent; }
+
+	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild()						{ return firstChild; }
+	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+	/// The first child of this node with the matching 'value'. Will be null if none found.
+	TiXmlNode* FirstChild( const char * _value ) {
+		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
+		// call the method, cast the return back to non-const.
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
+	}
+	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild()	{ return lastChild; }
+	
+	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * _value ) {
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
+	}
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling() const			{ return prev; }
+	TiXmlNode* PreviousSibling()						{ return prev; }
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling( const char * ) const;
+	TiXmlNode* PreviousSibling( const char *_prev ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* NextSibling() const				{ return next; }
+	TiXmlNode* NextSibling()							{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	const TiXmlNode* NextSibling( const char * ) const;
+	TiXmlNode* NextSibling( const char* _next ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement() const;
+	TiXmlElement* NextSiblingElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement( const char * ) const;
+	TiXmlElement* NextSiblingElement( const char *_next ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement()	const;
+	TiXmlElement* FirstChildElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
+	}
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement( const char * _value ) const;
+	TiXmlElement* FirstChildElement( const char * _value ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	const TiXmlDocument* GetDocument() const;
+	TiXmlDocument* GetDocument() {
+		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
+	}
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller. 
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
+		XML tree will be conditionally visited and the host will be called back
+		via the TiXmlVisitor interface.
+
+		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
+		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
+		interface versus any other.)
+
+		The interface has been based on ideas from:
+
+		- http://www.saxproject.org/
+		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern 
+
+		Which are both good references for "visiting".
+
+		An example of using Accept():
+		@verbatim
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &printer );
+		const char* xmlcstr = printer.CStr();
+		@endverbatim
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
+	#ifdef TIXML_USE_STL
+	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
+	#endif
+	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	// Get the tinyxml string representation
+	const TIXML_STRING& NameTStr() const { return name; }
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* _value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* _value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int _value );										///< Set the value from an integer.
+	void SetDoubleValue( double _value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )	{ name = _name; }	
+	/// STL std::string form.	
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	const TiXmlAttribute* Next() const;
+	TiXmlAttribute* Next() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); 
+	}
+
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	const TiXmlAttribute* Previous() const;
+	TiXmlAttribute* Previous() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); 
+	}
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+	
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+
+	TiXmlAttribute*	Find( const char* _name ) const;
+	TiXmlAttribute* FindOrCreate( const char* _name );
+
+#	ifdef TIXML_USE_STL
+	TiXmlAttribute*	Find( const std::string& _name ) const;
+	TiXmlAttribute* FindOrCreate( const std::string& _name );
+#	endif
+
+
+private:
+	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
+	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
+	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
+	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)
+
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/	
+	int QueryIntAttribute( const char* name, int* _value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* _value ) const;
+	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
+	int QueryFloatAttribute( const char* name, float* _value ) const {
+		double d;
+		int result = QueryDoubleAttribute( name, &d );
+		if ( result == TIXML_SUCCESS ) {
+			*_value = (float)d;
+		}
+		return result;
+	}
+
+    #ifdef TIXML_USE_STL
+	/// QueryStringAttribute examines the attribute - see QueryIntAttribute().
+	int QueryStringAttribute( const char* name, std::string* _value ) const {
+		const char* cstr = Attribute( name );
+		if ( cstr ) {
+			*_value = std::string( cstr );
+			return TIXML_SUCCESS;
+		}
+		return TIXML_NO_ATTRIBUTE;
+	}
+
+	/** Template form of the attribute query which will try to read the
+		attribute into the specified type. Very easy, very powerful, but
+		be careful to make sure to call this with the correct type.
+		
+		NOTE: This method doesn't work correctly for 'string' types that contain spaces.
+
+		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
+	*/
+	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+
+		std::stringstream sstream( node->ValueStr() );
+		sstream >> *outValue;
+		if ( !sstream.fail() )
+			return TIXML_SUCCESS;
+		return TIXML_WRONG_TYPE;
+	}
+
+	int QueryValueAttribute( const std::string& name, std::string* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+		*outValue = node->ValueStr();
+		return TIXML_SUCCESS;
+	}
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * _value );
+
+    #ifdef TIXML_USE_STL
+	const std::string* Attribute( const std::string& name ) const;
+	const std::string* Attribute( const std::string& name, int* i ) const;
+	const std::string* Attribute( const std::string& name, double* d ) const;
+	int QueryIntAttribute( const std::string& name, int* _value ) const;
+	int QueryDoubleAttribute( const std::string& name, double* _value ) const;
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value );
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value );
+	///< STL std::string form.
+	void SetDoubleAttribute( const std::string& name, double value );
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
+	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }
+
+	/** Convenience function for easy access to the text inside an element. Although easy
+		and concise, GetText() is limited compared to getting the TiXmlText child
+		and accessing it directly.
+	
+		If the first child of 'this' is a TiXmlText, the GetText()
+		returns the character string of the Text node, else null is returned.
+
+		This is a convenient method for getting the text of simple contained text:
+		@verbatim
+		<foo>This is text</foo>
+		const char* str = fooElement->GetText();
+		@endverbatim
+
+		'str' will be a pointer to "This is text". 
+		
+		Note that this function can be misleading. If the element foo was created from
+		this XML:
+		@verbatim
+		<foo><b>This is text</b></foo> 
+		@endverbatim
+
+		then the value of str would be null. The first child node isn't a text node, it is
+		another element. From this XML:
+		@verbatim
+		<foo>This is <b>text</b></foo> 
+		@endverbatim
+		GetText() will return "This is ".
+
+		WARNING: GetText() accesses a child node - don't become confused with the 
+				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
+				 safe type casts on the referenced node.
+	*/
+	const char* GetText() const;
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {}
+	/// Construct a comment from text.
+	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {
+		SetValue( _value );
+	}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+//	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. A text node can have 2 ways to output the next. "normal" output 
+	and CDATA. It will default to the mode it was parsed from the XML file and
+	you generally want to leave it alone, but you can change the output mode with 
+	SetCDATA() and query it with CDATA().
+*/
+class TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/** Constructor for text element. By default, it is treated as 
+		normal, encoded text. If you want it be output as a CDATA text
+		element, set the parameter _cdata to 'true'
+	*/
+	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TINYXML_TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/// Queries whether this represents text using a CDATA section.
+	bool CDATA() const				{ return cdata; }
+	/// Turns on or off a CDATA representation of text.
+	void SetCDATA( bool _cdata )	{ cdata = _cdata; }
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	bool cdata;			// true if this should be input and output as a CDATA style text element
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::TINYXML_DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+	/** Load a file using the given FILE*. Returns true if successful. Note that this method
+		doesn't stream - the entire object pointed at by the FILE*
+		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
+		file location. Streaming may be added in the future.
+	*/
+	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given FILE*. Returns true if successful.
+	bool SaveFile( FILE* ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+		return LoadFile( filename.c_str(), encoding );
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+		return SaveFile( filename.c_str() );
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+	TiXmlElement* RootElement()					{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/	
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1, 
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow() const	{ return errorLocation.row+1; }
+	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
+		to report the correct values for row and column. It does not change the output
+		or input in any way.
+		
+		By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false; 
+												errorId = 0; 
+												errorDesc = ""; 
+												errorLocation.row = errorLocation.col = 0; 
+												//errorLocation.last = 0; 
+											}
+
+	/** Write the document to standard out using formatted printing ("pretty print"). */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/* Write the document to a string using formatted printing ("pretty print"). This
+		will allocate a character array (new char[]) and return it as a pointer. The
+		calling code pust call delete[] on the return char* to avoid a memory leak.
+	*/
+	//char* PrintToMemory() const; 
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
+	a linear walk to find the element, so this code would iterate much more than it needs 
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/** Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* ToNode() const			{ return node; } 
+	/** Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/**	Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/** Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+	/** @deprecated use ToNode. 
+		Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* Node() const			{ return ToNode(); } 
+	/** @deprecated use ToElement. 
+		Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* Element() const	{ return ToElement(); }
+	/**	@deprecated use ToText()
+		Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* Text() const			{ return ToText(); }
+	/** @deprecated use ToUnknown()
+		Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+/** Print to memory functionality. The TiXmlPrinter is useful when you need to:
+
+	-# Print to memory (especially in non-STL mode)
+	-# Control formatting (line endings, etc.)
+
+	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
+	Before calling Accept() you can call methods to control the printing
+	of the XML document. After TiXmlNode::Accept() is called, the printed document can
+	be accessed via the CStr(), Str(), and Size() methods.
+
+	TiXmlPrinter uses the Visitor API.
+	@verbatim
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	@endverbatim
+*/
+class TiXmlPrinter : public TiXmlVisitor
+{
+public:
+	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
+					 buffer(), indent( "    " ), lineBreak( "\n" ) {}
+
+	virtual bool VisitEnter( const TiXmlDocument& doc );
+	virtual bool VisitExit( const TiXmlDocument& doc );
+
+	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
+	virtual bool VisitExit( const TiXmlElement& element );
+
+	virtual bool Visit( const TiXmlDeclaration& declaration );
+	virtual bool Visit( const TiXmlText& text );
+	virtual bool Visit( const TiXmlComment& comment );
+	virtual bool Visit( const TiXmlUnknown& unknown );
+
+	/** Set the indent characters for printing. By default 4 spaces
+		but tab (\t) is also useful, or null/empty string for no indentation.
+	*/
+	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
+	/// Query the indention string.
+	const char* Indent()							{ return indent.c_str(); }
+	/** Set the line breaking string. By default set to newline (\n). 
+		Some operating systems prefer other characters, or can be
+		set to the null/empty string for no indenation.
+	*/
+	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
+	/// Query the current line breaking string.
+	const char* LineBreak()							{ return lineBreak.c_str(); }
+
+	/** Switch over to "stream printing" which is the most dense formatting without 
+		linebreaks. Common when the XML is needed for network transmission.
+	*/
+	void SetStreamPrinting()						{ indent = "";
+													  lineBreak = "";
+													}	
+	/// Return the result.
+	const char* CStr()								{ return buffer.c_str(); }
+	/// Return the length of the result string.
+	size_t Size()									{ return buffer.size(); }
+
+	#ifdef TIXML_USE_STL
+	/// Return the result.
+	const std::string& Str()						{ return buffer; }
+	#endif
+
+private:
+	void DoIndent()	{
+		for( int i=0; i<depth; ++i )
+			buffer += indent;
+	}
+	void DoLineBreak() {
+		buffer += lineBreak;
+	}
+
+	int depth;
+	bool simpleTextPrint;
+	TIXML_STRING buffer;
+	TIXML_STRING indent;
+	TIXML_STRING lineBreak;
+};
+
+
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+
+#endif
+
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxml_lib.dsp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml_lib.dsp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxml_lib.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml_lib.dsp.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,130 @@
+# Microsoft Developer Studio Project File - Name="tinyxml" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=tinyxml - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxml_lib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxml_lib.mak" CFG="tinyxml - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyxml - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "tinyxml - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyxml - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "NDEBUG"
+# ADD RSC /l 0x407 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Release\tinyxml.lib"
+
+!ELSEIF  "$(CFG)" == "tinyxml - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x407 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\tinyxmld.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyxml - Win32 Release"
+# Name "tinyxml - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\changes.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\readme.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\tutorial_gettingStarted.txt
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxml_lib.vcproj.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml_lib.vcproj.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxml_lib.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml_lib.vcproj.svn-base	2013-05-09 18:10:01.651874322 +0200
@@ -0,0 +1,284 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyxml"
+	ProjectGUID="{C406DAEC-0886-4771-8DEA-9D7329B46CC1}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/tinyxml_lib.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1031"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Release\tinyxml.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/tinyxml_lib.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/tinyxml_lib.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1031"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug\tinyxmld.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/tinyxml_lib.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="tinystr.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxml.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlerror.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlparser.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="tinystr.h"
+				>
+			</File>
+			<File
+				RelativePath="tinyxml.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="changes.txt"
+			>
+		</File>
+		<File
+			RelativePath="readme.txt"
+			>
+		</File>
+		<File
+			RelativePath="tutorial_gettingStarted.txt"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlparser.cpp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlparser.cpp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlparser.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlparser.cpp.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,1635 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+*/
+
+#include <ctype.h>
+#include <stddef.h>
+
+#include "tinyxml.h"
+
+//#define DEBUG_PARSER
+#if defined( DEBUG_PARSER )
+#	if defined( DEBUG ) && defined( _MSC_VER )
+#		include <windows.h>
+#		define TIXML_LOG OutputDebugString
+#	else
+#		define TIXML_LOG printf
+#	endif
+#endif
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.	
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:	
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf 
+
+const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+const int TiXmlBase::utf8ByteTable[256] = 
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0 
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80) 
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	// Scary scary fall throughs.
+	switch (*length) 
+	{
+		case 4:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 3:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 2:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 1:
+			--output; 
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Treat p as unsigned, so we have a happy compiler.
+		const unsigned char* pU = (const unsigned char*)p;
+
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*pU) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;				
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case TIXML_UTF_LEAD_0:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
+							p += 3;	
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			const unsigned char* pU = (const unsigned char*)p;
+			
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==TIXML_UTF_LEAD_1 
+				 && *(pU+2)==TIXML_UTF_LEAD_2 )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbeU )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbfU )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( *p && IsWhiteSpace( *p ) )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
+// "assign" optimization removes over 10% of the execution time.
+//
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	// Oddly, not supported on some comilers,
+	//name->clear();
+	// So use this:
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p 
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		const char* start = p;
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			//(*name) += *p; // expensive
+			++p;
+		}
+		if ( p-start > 0 ) {
+			name->assign( start, p-start );
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		ptrdiff_t delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else 
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else 
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
+					// Just writes strange XML.
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p, 
+									TIXML_STRING * text, 
+									bool trimWhiteSpace, 
+									const char* endTag, 
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	if ( p && *p ) 
+		p += strlen( endTag );
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) ) 
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of 
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		const unsigned char* pU = (const unsigned char*)p;
+		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
+			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
+			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+			useMicrosoftBOM = true;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else 
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// Was this empty?
+	if ( !firstChild ) {
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
+		return 0;
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{	
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing? 
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+	const char* cdataHeader = { "<![CDATA[" };
+
+	if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, cdataHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing CDATA\n" );
+		#endif
+		TiXmlText* text = new TiXmlText( "" );
+		text->SetCDATA( true );
+		returnNode = text;
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+		
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>' 
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		cdata text (which looks like another node)
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' ) 
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = (int) tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				// Early out if we find the CDATA id.
+				if ( c == '[' && tag->size() >= 9 )
+				{
+					size_t len = tag->size();
+					const char* start = tag->c_str() + len - 9;
+					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
+						assert( !closingTag );
+						break;
+					}
+				}
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p ) {
+				// We were looking for the end tag, but found nothing.
+				// Fix for [ 1663758 ] Failure to report error on bad XML
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+
+			// We should find the end tag now
+			// note that:
+			// </foo > and
+			// </foo> 
+			// are both valid end tags.
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				p = SkipWhiteSpace( p, encoding );
+				if ( p && *p && *p == '>' ) {
+					++p;
+					return p;
+				}
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			#ifdef TIXML_USE_STL
+			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
+			#else
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			#endif
+			if ( node )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	// Read in text and elements in any order.
+	const char* pWithWhiteSpace = p;
+	p = SkipWhiteSpace( p, encoding );
+
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+			    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		} 
+		else 
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag? This could also be
+			// a TiXmlText in the "CDATA" style.
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}				
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		pWithWhiteSpace = p;
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}	
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>' 
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+
+	// [ 1475201 ] TinyXML parses entities in comments
+	// Oops - ReadText doesn't work, because we don't want to parse the entities.
+	// p = ReadText( p, &value, false, endTag, false, encoding );
+	//
+	// from the XML spec:
+	/*
+	 [Definition: Comments may appear anywhere in a document outside other markup; in addition, 
+	              they may appear within the document type declaration at places allowed by the grammar. 
+				  They are not part of the document's character data; an XML processor MAY, but need not, 
+				  make it possible for an application to retrieve the text of comments. For compatibility, 
+				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity 
+				  references MUST NOT be recognized within comments.
+
+				  An example of a comment:
+
+				  <!-- declarations for <head> & <body> -->
+	*/
+
+    value = "";
+	// Keep all the white space.
+	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )
+	{
+		value.append( p, 1 );
+		++p;
+	}
+	if ( p && *p ) 
+		p += strlen( endTag );
+
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+	
+	const char* end;
+	const char SINGLE_QUOTE = '\'';
+	const char DOUBLE_QUOTE = '\"';
+
+	if ( *p == SINGLE_QUOTE )
+	{
+		++p;
+		end = "\'";		// single quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == DOUBLE_QUOTE )
+	{
+		++p;
+		end = "\"";		// double quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p											// existence
+				&& !IsWhiteSpace( *p )								// whitespace
+				&& *p != '/' && *p != '>' )							// tag end
+		{
+			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
+				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
+				// We did not have an opening quote but seem to have a 
+				// closing one. Give up and throw an error.
+				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+				return 0;
+			}
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();	
+		if ( !cdata && (c == '<' ) ) 
+		{
+			return;
+		}
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();	// "commits" the peek made above
+
+		if ( cdata && c == '>' && tag->size() >= 3 ) {
+			size_t len = tag->size();
+			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
+				// terminator of cdata.
+				return;
+			}
+		}    
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+	TiXmlDocument* document = GetDocument();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	const char* const startTag = "<![CDATA[";
+	const char* const endTag   = "]]>";
+
+	if ( cdata || StringEqual( p, startTag, false, encoding ) )
+	{
+		cdata = true;
+
+		if ( !StringEqual( p, startTag, false, encoding ) )
+		{
+			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
+			return 0;
+		}
+		p += strlen( startTag );
+
+		// Keep all the white space, ignore the encoding, etc.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, false, encoding )
+			  )
+		{
+			value += *p;
+			++p;
+		}
+
+		TIXML_STRING dummy; 
+		p = ReadText( p, &dummy, false, endTag, false, encoding );
+		return p;
+	}
+	else
+	{
+		bool ignoreWhite = true;
+
+		const char* end = "<";
+		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+		if ( p )
+			return p-1;	// don't truncate the '<'
+		return 0;
+	}
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
+
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.sln.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.sln.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxml.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxml.sln.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,44 @@
+
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyXmlTest", "tinyXmlTest.vcproj", "{34719950-09E8-457E-BE23-8F1CE3A1F1F6}"
+	ProjectSection(ProjectDependencies) = postProject
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1} = {C406DAEC-0886-4771-8DEA-9D7329B46CC1}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyXmlTestSTL", "tinyXmlTestSTL.vcproj", "{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{A3A84737-5017-4577-B8A2-79429A25B8B6} = {A3A84737-5017-4577-B8A2-79429A25B8B6}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyxml", "tinyxml_lib.vcproj", "{C406DAEC-0886-4771-8DEA-9D7329B46CC1}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyxmlSTL", "tinyxmlSTL.vcproj", "{A3A84737-5017-4577-B8A2-79429A25B8B6}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Debug|Win32.ActiveCfg = Debug|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Debug|Win32.Build.0 = Debug|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Release|Win32.ActiveCfg = Release|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Release|Win32.Build.0 = Release|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Debug|Win32.Build.0 = Debug|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Release|Win32.ActiveCfg = Release|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Release|Win32.Build.0 = Release|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Debug|Win32.ActiveCfg = Debug|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Debug|Win32.Build.0 = Debug|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Release|Win32.ActiveCfg = Release|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Release|Win32.Build.0 = Release|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Debug|Win32.Build.0 = Debug|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Release|Win32.ActiveCfg = Release|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlSTL.dsp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlSTL.dsp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlSTL.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlSTL.dsp.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,126 @@
+# Microsoft Developer Studio Project File - Name="tinyxmlSTL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=tinyxmlSTL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxmlSTL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxmlSTL.mak" CFG="tinyxmlSTL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyxmlSTL - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "tinyxmlSTL - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyxmlSTL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyxmlSTL___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyxmlSTL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release_STL"
+# PROP Intermediate_Dir "Release_STL"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "TIXML_USE_STL" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Release_STL\tinyxml_STL.lib"
+
+!ELSEIF  "$(CFG)" == "tinyxmlSTL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyxmlSTL___Win32_Debug0"
+# PROP BASE Intermediate_Dir "tinyxmlSTL___Win32_Debug0"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug_STL"
+# PROP Intermediate_Dir "Debug_STL"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "TIXML_USE_STL" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug_STL\tinyxmld_STL.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyxmlSTL - Win32 Release"
+# Name "tinyxmlSTL - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\changes.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\readme.txt
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlSTL.vcproj.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlSTL.vcproj.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyxmlSTL.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyxmlSTL.vcproj.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,279 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyxmlSTL"
+	ProjectGUID="{A3A84737-5017-4577-B8A2-79429A25B8B6}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug_STL"
+			IntermediateDirectory=".\Debug_STL"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;TIXML_USE_STL;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug_STL/tinyxmlSTL.pch"
+				AssemblerListingLocation=".\Debug_STL/"
+				ObjectFile=".\Debug_STL/"
+				ProgramDataBaseFileName=".\Debug_STL/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug_STL\tinyxmld_STL.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug_STL/tinyxmlSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release_STL"
+			IntermediateDirectory=".\Release_STL"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;TIXML_USE_STL"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release_STL/tinyxmlSTL.pch"
+				AssemblerListingLocation=".\Release_STL/"
+				ObjectFile=".\Release_STL/"
+				ProgramDataBaseFileName=".\Release_STL/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Release_STL\tinyxml_STL.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release_STL/tinyxmlSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			>
+			<File
+				RelativePath="tinystr.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxml.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlerror.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlparser.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			>
+			<File
+				RelativePath="tinystr.h"
+				>
+			</File>
+			<File
+				RelativePath="tinyxml.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="changes.txt"
+			>
+		</File>
+		<File
+			RelativePath="readme.txt"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTest.dsp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTest.dsp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTest.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTest.dsp.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,92 @@
+# Microsoft Developer Studio Project File - Name="tinyXmlTest" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tinyXmlTest - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTest.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTest.mak" CFG="tinyXmlTest - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyXmlTest - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "tinyXmlTest - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyXmlTest - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyXmlTest___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyXmlTest___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "tinyXmlTest___Win32_Release"
+# PROP Intermediate_Dir "tinyXmlTest___Win32_Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 ./Release/tinyxml.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "tinyXmlTest - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyXmlTest___Win32_Debug"
+# PROP BASE Intermediate_Dir "tinyXmlTest___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "tinyXmlTest___Win32_Debug"
+# PROP Intermediate_Dir "tinyXmlTest___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TUNE" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 ./Debug/tinyxmld.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyXmlTest - Win32 Release"
+# Name "tinyXmlTest - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltest.cpp
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTestSTL.dsp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTestSTL.dsp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTestSTL.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTestSTL.dsp.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,92 @@
+# Microsoft Developer Studio Project File - Name="tinyXmlTestSTL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tinyXmlTestSTL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTestSTL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTestSTL.mak" CFG="tinyXmlTestSTL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyXmlTestSTL - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "tinyXmlTestSTL - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyXmlTestSTL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP Intermediate_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 ./Release_STL/tinyxml_stl.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "tinyXmlTestSTL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP BASE Intermediate_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP Intermediate_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /D "TUNE" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 ./Debug_STL/tinyxmld_stl.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyXmlTestSTL - Win32 Release"
+# Name "tinyXmlTestSTL - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltest.cpp
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTestSTL.vcproj.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTestSTL.vcproj.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTestSTL.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTestSTL.vcproj.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,225 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyXmlTestSTL"
+	ProjectGUID="{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\tinyXmlTestSTL___Win32_Debug"
+			IntermediateDirectory=".\tinyXmlTestSTL___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;TIXML_USE_STL;TUNE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.pch"
+				AssemblerListingLocation=".\tinyXmlTestSTL___Win32_Debug/"
+				ObjectFile=".\tinyXmlTestSTL___Win32_Debug/"
+				ProgramDataBaseFileName=".\tinyXmlTestSTL___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Debug_STL/tinyxmld_stl.lib"
+				OutputFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\tinyXmlTestSTL___Win32_Release"
+			IntermediateDirectory=".\tinyXmlTestSTL___Win32_Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;TIXML_USE_STL;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.pch"
+				AssemblerListingLocation=".\tinyXmlTestSTL___Win32_Release/"
+				ObjectFile=".\tinyXmlTestSTL___Win32_Release/"
+				ProgramDataBaseFileName=".\tinyXmlTestSTL___Win32_Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Release_STL/tinyxml_stl.lib"
+				OutputFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="xmltest.cpp"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTest.vcproj.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTest.vcproj.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/tinyXmlTest.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/tinyXmlTest.vcproj.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,226 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyXmlTest"
+	ProjectGUID="{34719950-09E8-457E-BE23-8F1CE3A1F1F6}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\tinyXmlTest___Win32_Debug"
+			IntermediateDirectory=".\tinyXmlTest___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTest___Win32_Debug/tinyXmlTest.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;TUNE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.pch"
+				AssemblerListingLocation=".\tinyXmlTest___Win32_Debug/"
+				ObjectFile=".\tinyXmlTest___Win32_Debug/"
+				ProgramDataBaseFileName=".\tinyXmlTest___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Debug/tinyxmld.lib"
+				OutputFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\tinyXmlTest___Win32_Release"
+			IntermediateDirectory=".\tinyXmlTest___Win32_Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTest___Win32_Release/tinyXmlTest.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.pch"
+				AssemblerListingLocation=".\tinyXmlTest___Win32_Release/"
+				ObjectFile=".\tinyXmlTest___Win32_Release/"
+				ProgramDataBaseFileName=".\tinyXmlTest___Win32_Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Release/tinyxml.lib"
+				OutputFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="xmltest.cpp"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/utf8testverify.xml.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/utf8testverify.xml.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/utf8testverify.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/utf8testverify.xml.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<document>
+    <English name="name" value="value">The world has many languages</English>
+    <Russian name="()" value="">   </Russian>
+    <Spanish name="el nombre" value="el valor">el mundo tiene muchos idiomas</Spanish>
+    <SimplifiedChinese name="" value=""></SimplifiedChinese>
+    < ="name" ="value">&lt;&gt;</>
+    < ="name" ="value"></>
+    <Heavy>&quot;Mtl!&quot;</Heavy>
+    <>Umlaut Element</>
+</document>
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/utf8test.xml.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/utf8test.xml.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/utf8test.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/utf8test.xml.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+    <English name="name" value="value">The world has many languages</English>
+    <Russian name="()" value="">   </Russian>
+    <Spanish name="el nombre" value="el valor">el mundo tiene muchos idiomas</Spanish>
+    <SimplifiedChinese name="" value=""></SimplifiedChinese>
+    < ="name" ="value">&lt;&gt;</>
+    < ="name" ="value"></>
+    <Heavy>"M&#x0eB;t&#230;l!"</Heavy>
+    <>Umlaut Element</>
+</document>
diff -urN vdr-2.0.1/tinyxml/.svn/text-base/xmltest.cpp.svn-base vdr-2.0.1.reel/tinyxml/.svn/text-base/xmltest.cpp.svn-base
--- vdr-2.0.1/tinyxml/.svn/text-base/xmltest.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/.svn/text-base/xmltest.cpp.svn-base	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,1364 @@
+/*
+   Test program for TinyXML.
+*/
+
+
+#ifdef TIXML_USE_STL
+	#include <iostream>
+	#include <sstream>
+	using namespace std;
+#else
+	#include <stdio.h>
+#endif
+
+#if defined( WIN32 ) && defined( TUNE )
+	#include <crtdbg.h>
+	_CrtMemState startMemState;
+	_CrtMemState endMemState;
+#endif
+
+#include "tinyxml.h"
+
+bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho = false);
+bool XmlTest( const char* testString, int expected, int found, bool noEcho = false );
+
+static int gPass = 0;
+static int gFail = 0;
+
+
+
+bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho )
+{
+	bool pass = !strcmp( expected, found );
+	if ( pass )
+		printf ("[pass]");
+	else
+		printf ("[fail]");
+
+	if ( noEcho )
+		printf (" %s\n", testString);
+	else
+		printf (" %s [%s][%s]\n", testString, expected, found);
+
+	if ( pass )
+		++gPass;
+	else
+		++gFail;
+	return pass;
+}
+
+
+bool XmlTest( const char* testString, int expected, int found, bool noEcho )
+{
+	bool pass = ( expected == found );
+	if ( pass )
+		printf ("[pass]");
+	else
+		printf ("[fail]");
+
+	if ( noEcho )
+		printf (" %s\n", testString);
+	else
+		printf (" %s [%d][%d]\n", testString, expected, found);
+
+	if ( pass )
+		++gPass;
+	else
+		++gFail;
+	return pass;
+}
+
+
+//
+// This file demonstrates some basic functionality of TinyXml.
+// Note that the example is very contrived. It presumes you know
+// what is in the XML file. But it does test the basic operations,
+// and show how to add and remove nodes.
+//
+
+int main()
+{
+
+	//
+	// We start with the 'demoStart' todo list. Process it. And
+	// should hopefully end up with the todo list as illustrated.
+	//
+	const char* demoStart =
+		"<?xml version=\"1.0\"  standalone='no' >\n"
+		"<!-- Our to do list data -->"
+		"<ToDo>\n"
+		"<!-- Do I need a secure PDA? -->\n"
+		"<Item priority=\"1\" distance='close'> Go to the <bold>Toy store!</bold></Item>"
+		"<Item priority=\"2\" distance='none'> Do bills   </Item>"
+		"<Item priority=\"2\" distance='far &amp; back'> Look for Evil Dinosaurs! </Item>"
+		"</ToDo>";
+		
+	{
+
+	#ifdef TIXML_USE_STL
+		//	What the todo list should look like after processing.
+		// In stream (no formatting) representation.
+		const char* demoEnd =
+			"<?xml version=\"1.0\" standalone=\"no\" ?>"
+			"<!-- Our to do list data -->"
+			"<ToDo>"
+			"<!-- Do I need a secure PDA? -->"
+			"<Item priority=\"2\" distance=\"close\">Go to the"
+			"<bold>Toy store!"
+			"</bold>"
+			"</Item>"
+			"<Item priority=\"1\" distance=\"far\">Talk to:"
+			"<Meeting where=\"School\">"
+			"<Attendee name=\"Marple\" position=\"teacher\" />"
+			"<Attendee name=\"Voel\" position=\"counselor\" />"
+			"</Meeting>"
+			"<Meeting where=\"Lunch\" />"
+			"</Item>"
+			"<Item priority=\"2\" distance=\"here\">Do bills"
+			"</Item>"
+			"</ToDo>";
+	#endif
+
+		// The example parses from the character string (above):
+		#if defined( WIN32 ) && defined( TUNE )
+		_CrtMemCheckpoint( &startMemState );
+		#endif	
+
+		{
+			// Write to a file and read it back, to check file I/O.
+
+			TiXmlDocument doc( "demotest.xml" );
+			doc.Parse( demoStart );
+
+			if ( doc.Error() )
+			{
+				printf( "Error in %s: %s\n", doc.Value(), doc.ErrorDesc() );
+				exit( 1 );
+			}
+			doc.SaveFile();
+		}
+
+		TiXmlDocument doc( "demotest.xml" );
+		bool loadOkay = doc.LoadFile();
+
+		if ( !loadOkay )
+		{
+			printf( "Could not load test file 'demotest.xml'. Error='%s'. Exiting.\n", doc.ErrorDesc() );
+			exit( 1 );
+		}
+
+		printf( "** Demo doc read from disk: ** \n\n" );
+		printf( "** Printing via doc.Print **\n" );
+		doc.Print( stdout );
+
+		{
+			printf( "** Printing via TiXmlPrinter **\n" );
+			TiXmlPrinter printer;
+			doc.Accept( &printer );
+			fprintf( stdout, "%s", printer.CStr() );
+		}
+		#ifdef TIXML_USE_STL	
+		{
+			printf( "** Printing via operator<< **\n" );
+			std::cout << doc;
+		}
+		#endif
+		TiXmlNode* node = 0;
+		TiXmlElement* todoElement = 0;
+		TiXmlElement* itemElement = 0;
+
+
+		// --------------------------------------------------------
+		// An example of changing existing attributes, and removing
+		// an element from the document.
+		// --------------------------------------------------------
+
+		// Get the "ToDo" element.
+		// It is a child of the document, and can be selected by name.
+		node = doc.FirstChild( "ToDo" );
+		assert( node );
+		todoElement = node->ToElement();
+		assert( todoElement  );
+
+		// Going to the toy store is now our second priority...
+		// So set the "priority" attribute of the first item in the list.
+		node = todoElement->FirstChildElement();	// This skips the "PDA" comment.
+		assert( node );
+		itemElement = node->ToElement();
+		assert( itemElement  );
+		itemElement->SetAttribute( "priority", 2 );
+
+		// Change the distance to "doing bills" from
+		// "none" to "here". It's the next sibling element.
+		itemElement = itemElement->NextSiblingElement();
+		assert( itemElement );
+		itemElement->SetAttribute( "distance", "here" );
+
+		// Remove the "Look for Evil Dinosaurs!" item.
+		// It is 1 more sibling away. We ask the parent to remove
+		// a particular child.
+		itemElement = itemElement->NextSiblingElement();
+		todoElement->RemoveChild( itemElement );
+
+		itemElement = 0;
+
+		// --------------------------------------------------------
+		// What follows is an example of created elements and text
+		// nodes and adding them to the document.
+		// --------------------------------------------------------
+
+		// Add some meetings.
+		TiXmlElement item( "Item" );
+		item.SetAttribute( "priority", "1" );
+		item.SetAttribute( "distance", "far" );
+
+		TiXmlText text( "Talk to:" );
+
+		TiXmlElement meeting1( "Meeting" );
+		meeting1.SetAttribute( "where", "School" );
+
+		TiXmlElement meeting2( "Meeting" );
+		meeting2.SetAttribute( "where", "Lunch" );
+
+		TiXmlElement attendee1( "Attendee" );
+		attendee1.SetAttribute( "name", "Marple" );
+		attendee1.SetAttribute( "position", "teacher" );
+
+		TiXmlElement attendee2( "Attendee" );
+		attendee2.SetAttribute( "name", "Voel" );
+		attendee2.SetAttribute( "position", "counselor" );
+
+		// Assemble the nodes we've created:
+		meeting1.InsertEndChild( attendee1 );
+		meeting1.InsertEndChild( attendee2 );
+
+		item.InsertEndChild( text );
+		item.InsertEndChild( meeting1 );
+		item.InsertEndChild( meeting2 );
+
+		// And add the node to the existing list after the first child.
+		node = todoElement->FirstChild( "Item" );
+		assert( node );
+		itemElement = node->ToElement();
+		assert( itemElement );
+
+		todoElement->InsertAfterChild( itemElement, item );
+
+		printf( "\n** Demo doc processed: ** \n\n" );
+		doc.Print( stdout );
+
+
+	#ifdef TIXML_USE_STL
+		printf( "** Demo doc processed to stream: ** \n\n" );
+		cout << doc << endl << endl;
+	#endif
+
+		// --------------------------------------------------------
+		// Different tests...do we have what we expect?
+		// --------------------------------------------------------
+
+		int count = 0;
+		TiXmlElement*	element;
+
+		//////////////////////////////////////////////////////
+
+	#ifdef TIXML_USE_STL
+		cout << "** Basic structure. **\n";
+		ostringstream outputStream( ostringstream::out );
+		outputStream << doc;
+		XmlTest( "Output stream correct.",	string( demoEnd ).c_str(),
+											outputStream.str().c_str(), true );
+	#endif
+
+		node = doc.RootElement();
+		assert( node );
+		XmlTest( "Root element exists.", true, ( node != 0 && node->ToElement() ) );
+		XmlTest ( "Root element value is 'ToDo'.", "ToDo",  node->Value());
+
+		node = node->FirstChild();
+		XmlTest( "First child exists & is a comment.", true, ( node != 0 && node->ToComment() ) );
+		node = node->NextSibling();
+		XmlTest( "Sibling element exists & is an element.", true, ( node != 0 && node->ToElement() ) );
+		XmlTest ( "Value is 'Item'.", "Item", node->Value() );
+
+		node = node->FirstChild();
+		XmlTest ( "First child exists.", true, ( node != 0 && node->ToText() ) );
+		XmlTest ( "Value is 'Go to the'.", "Go to the", node->Value() );
+
+
+		//////////////////////////////////////////////////////
+		printf ("\n** Iterators. **\n");
+
+		// Walk all the top level nodes of the document.
+		count = 0;
+		for( node = doc.FirstChild();
+			 node;
+			 node = node->NextSibling() )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using First / Next.", 3, count );
+
+		count = 0;
+		for( node = doc.LastChild();
+			 node;
+			 node = node->PreviousSibling() )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using Last / Previous.", 3, count );
+
+		// Walk all the top level nodes of the document,
+		// using a different syntax.
+		count = 0;
+		for( node = doc.IterateChildren( 0 );
+			 node;
+			 node = doc.IterateChildren( node ) )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using IterateChildren.", 3, count );
+
+		// Walk all the elements in a node.
+		count = 0;
+		for( element = todoElement->FirstChildElement();
+			 element;
+			 element = element->NextSiblingElement() )
+		{
+			count++;
+		}
+		XmlTest( "Children of the 'ToDo' element, using First / Next.",
+			3, count );
+
+		// Walk all the elements in a node by value.
+		count = 0;
+		for( node = todoElement->FirstChild( "Item" );
+			 node;
+			 node = node->NextSibling( "Item" ) )
+		{
+			count++;
+		}
+		XmlTest( "'Item' children of the 'ToDo' element, using First/Next.", 3, count );
+
+		count = 0;
+		for( node = todoElement->LastChild( "Item" );
+			 node;
+			 node = node->PreviousSibling( "Item" ) )
+		{
+			count++;
+		}
+		XmlTest( "'Item' children of the 'ToDo' element, using Last/Previous.", 3, count );
+
+	#ifdef TIXML_USE_STL
+		{
+			cout << "\n** Parsing. **\n";
+			istringstream parse0( "<Element0 attribute0='foo0' attribute1= noquotes attribute2 = '&gt;' />" );
+			TiXmlElement element0( "default" );
+			parse0 >> element0;
+
+			XmlTest ( "Element parsed, value is 'Element0'.", "Element0", element0.Value() );
+			XmlTest ( "Reads attribute 'attribute0=\"foo0\"'.", "foo0", element0.Attribute( "attribute0" ));
+			XmlTest ( "Reads incorrectly formatted 'attribute1=noquotes'.", "noquotes", element0.Attribute( "attribute1" ) );
+			XmlTest ( "Read attribute with entity value '>'.", ">", element0.Attribute( "attribute2" ) );
+		}
+	#endif
+
+		{
+			const char* error =	"<?xml version=\"1.0\" standalone=\"no\" ?>\n"
+								"<passages count=\"006\" formatversion=\"20020620\">\n"
+								"    <wrong error>\n"
+								"</passages>";
+
+			TiXmlDocument docTest;
+			docTest.Parse( error );
+			XmlTest( "Error row", docTest.ErrorRow(), 3 );
+			XmlTest( "Error column", docTest.ErrorCol(), 17 );
+			//printf( "error=%d id='%s' row %d col%d\n", (int) doc.Error(), doc.ErrorDesc(), doc.ErrorRow()+1, doc.ErrorCol() + 1 );
+
+		}
+
+	#ifdef TIXML_USE_STL
+		{
+			//////////////////////////////////////////////////////
+			cout << "\n** Streaming. **\n";
+
+			// Round trip check: stream in, then stream back out to verify. The stream
+			// out has already been checked, above. We use the output
+
+			istringstream inputStringStream( outputStream.str() );
+			TiXmlDocument document0;
+
+			inputStringStream >> document0;
+
+			ostringstream outputStream0( ostringstream::out );
+			outputStream0 << document0;
+
+			XmlTest( "Stream round trip correct.",	string( demoEnd ).c_str(), 
+													outputStream0.str().c_str(), true );
+
+			std::string str;
+			str << document0;
+
+			XmlTest( "String printing correct.", string( demoEnd ).c_str(), 
+												 str.c_str(), true );
+		}
+	#endif
+	}
+
+	{
+		const char* str = "<doc attr0='1' attr1='2.0' attr2='foo' />";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlElement* ele = doc.FirstChildElement();
+
+		int iVal, result;
+		double dVal;
+
+		result = ele->QueryDoubleAttribute( "attr0", &dVal );
+		XmlTest( "Query attribute: int as double", result, TIXML_SUCCESS );
+		XmlTest( "Query attribute: int as double", (int)dVal, 1 );
+		result = ele->QueryDoubleAttribute( "attr1", &dVal );
+		XmlTest( "Query attribute: double as double", (int)dVal, 2 );
+		result = ele->QueryIntAttribute( "attr1", &iVal );
+		XmlTest( "Query attribute: double as int", result, TIXML_SUCCESS );
+		XmlTest( "Query attribute: double as int", iVal, 2 );
+		result = ele->QueryIntAttribute( "attr2", &iVal );
+		XmlTest( "Query attribute: not a number", result, TIXML_WRONG_TYPE );
+		result = ele->QueryIntAttribute( "bar", &iVal );
+		XmlTest( "Query attribute: does not exist", result, TIXML_NO_ATTRIBUTE );
+	}
+
+	{
+		const char* str = "<doc/>";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlElement* ele = doc.FirstChildElement();
+
+		int iVal;
+		double dVal;
+
+		ele->SetAttribute( "str", "strValue" );
+		ele->SetAttribute( "int", 1 );
+		ele->SetDoubleAttribute( "double", -1.0 );
+
+		const char* cStr = ele->Attribute( "str" );
+		ele->QueryIntAttribute( "int", &iVal );
+		ele->QueryDoubleAttribute( "double", &dVal );
+
+		XmlTest( "Attribute round trip. c-string.", "strValue", cStr );
+		XmlTest( "Attribute round trip. int.", 1, iVal );
+		XmlTest( "Attribute round trip. double.", -1, (int)dVal );
+	}
+	
+	{
+		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
+							"</room>";
+
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Parse( str );
+
+		TiXmlHandle docHandle( &doc );
+		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
+
+		assert( docHandle.Node() );
+		assert( roomHandle.Element() );
+
+		TiXmlElement* room = roomHandle.Element();
+		assert( room );
+		TiXmlAttribute* doors = room->FirstAttribute();
+		assert( doors );
+
+		XmlTest( "Location tracking: Tab 8: room row", room->Row(), 1 );
+		XmlTest( "Location tracking: Tab 8: room col", room->Column(), 49 );
+		XmlTest( "Location tracking: Tab 8: doors row", doors->Row(), 1 );
+		XmlTest( "Location tracking: Tab 8: doors col", doors->Column(), 55 );
+	}
+	
+	{
+		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
+							"  <!-- Silly example -->\n"
+							"    <door wall='north'>A great door!</door>\n"
+							"\t<door wall='east'/>"
+							"</room>";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlHandle docHandle( &doc );
+		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
+		TiXmlHandle commentHandle = docHandle.FirstChildElement( "room" ).FirstChild();
+		TiXmlHandle textHandle = docHandle.FirstChildElement( "room" ).ChildElement( "door", 0 ).FirstChild();
+		TiXmlHandle door0Handle = docHandle.FirstChildElement( "room" ).ChildElement( 0 );
+		TiXmlHandle door1Handle = docHandle.FirstChildElement( "room" ).ChildElement( 1 );
+
+		assert( docHandle.Node() );
+		assert( roomHandle.Element() );
+		assert( commentHandle.Node() );
+		assert( textHandle.Text() );
+		assert( door0Handle.Element() );
+		assert( door1Handle.Element() );
+
+		TiXmlDeclaration* declaration = doc.FirstChild()->ToDeclaration();
+		assert( declaration );
+		TiXmlElement* room = roomHandle.Element();
+		assert( room );
+		TiXmlAttribute* doors = room->FirstAttribute();
+		assert( doors );
+		TiXmlText* text = textHandle.Text();
+		TiXmlComment* comment = commentHandle.Node()->ToComment();
+		assert( comment );
+		TiXmlElement* door0 = door0Handle.Element();
+		TiXmlElement* door1 = door1Handle.Element();
+
+		XmlTest( "Location tracking: Declaration row", declaration->Row(), 1 );
+		XmlTest( "Location tracking: Declaration col", declaration->Column(), 5 );
+		XmlTest( "Location tracking: room row", room->Row(), 1 );
+		XmlTest( "Location tracking: room col", room->Column(), 45 );
+		XmlTest( "Location tracking: doors row", doors->Row(), 1 );
+		XmlTest( "Location tracking: doors col", doors->Column(), 51 );
+		XmlTest( "Location tracking: Comment row", comment->Row(), 2 );
+		XmlTest( "Location tracking: Comment col", comment->Column(), 3 );
+		XmlTest( "Location tracking: text row", text->Row(), 3 ); 
+		XmlTest( "Location tracking: text col", text->Column(), 24 );
+		XmlTest( "Location tracking: door0 row", door0->Row(), 3 );
+		XmlTest( "Location tracking: door0 col", door0->Column(), 5 );
+		XmlTest( "Location tracking: door1 row", door1->Row(), 4 );
+		XmlTest( "Location tracking: door1 col", door1->Column(), 5 );
+	}
+
+
+	// --------------------------------------------------------
+	// UTF-8 testing. It is important to test:
+	//	1. Making sure name, value, and text read correctly
+	//	2. Row, Col functionality
+	//	3. Correct output
+	// --------------------------------------------------------
+	printf ("\n** UTF-8 **\n");
+	{
+		TiXmlDocument doc( "utf8test.xml" );
+		doc.LoadFile();
+		if ( doc.Error() && doc.ErrorId() == TiXmlBase::TIXML_ERROR_OPENING_FILE ) {
+			printf( "WARNING: File 'utf8test.xml' not found.\n"
+					"(Are you running the test from the wrong directory?)\n"
+				    "Could not test UTF-8 functionality.\n" );
+		}
+		else
+		{
+			TiXmlHandle docH( &doc );
+			// Get the attribute "value" from the "Russian" element and check it.
+			TiXmlElement* element = docH.FirstChildElement( "document" ).FirstChildElement( "Russian" ).Element();
+			const unsigned char correctValue[] = {	0xd1U, 0x86U, 0xd0U, 0xb5U, 0xd0U, 0xbdU, 0xd0U, 0xbdU, 
+													0xd0U, 0xbeU, 0xd1U, 0x81U, 0xd1U, 0x82U, 0xd1U, 0x8cU, 0 };
+
+			XmlTest( "UTF-8: Russian value.", (const char*)correctValue, element->Attribute( "value" ), true );
+			XmlTest( "UTF-8: Russian value row.", 4, element->Row() );
+			XmlTest( "UTF-8: Russian value column.", 5, element->Column() );
+
+			const unsigned char russianElementName[] = {	0xd0U, 0xa0U, 0xd1U, 0x83U,
+															0xd1U, 0x81U, 0xd1U, 0x81U,
+															0xd0U, 0xbaU, 0xd0U, 0xb8U,
+															0xd0U, 0xb9U, 0 };
+			const char russianText[] = "<\xD0\xB8\xD0\xBC\xD0\xB5\xD0\xB5\xD1\x82>";
+
+			TiXmlText* text = docH.FirstChildElement( "document" ).FirstChildElement( (const char*) russianElementName ).Child( 0 ).Text();
+			XmlTest( "UTF-8: Browsing russian element name.",
+					 russianText,
+					 text->Value(),
+					 true );
+			XmlTest( "UTF-8: Russian element name row.", 7, text->Row() );
+			XmlTest( "UTF-8: Russian element name column.", 47, text->Column() );
+
+			TiXmlDeclaration* dec = docH.Child( 0 ).Node()->ToDeclaration();
+			XmlTest( "UTF-8: Declaration column.", 1, dec->Column() );
+			XmlTest( "UTF-8: Document column.", 1, doc.Column() );
+
+			// Now try for a round trip.
+			doc.SaveFile( "utf8testout.xml" );
+
+			// Check the round trip.
+			char savedBuf[256];
+			char verifyBuf[256];
+			int okay = 1;
+
+			FILE* saved  = fopen( "utf8testout.xml", "r" );
+			FILE* verify = fopen( "utf8testverify.xml", "r" );
+			if ( saved && verify )
+			{
+				while ( fgets( verifyBuf, 256, verify ) )
+				{
+					fgets( savedBuf, 256, saved );
+					if ( strcmp( verifyBuf, savedBuf ) )
+					{
+						okay = 0;
+						break;
+					}
+				}
+				fclose( saved );
+				fclose( verify );
+			}
+			XmlTest( "UTF-8: Verified multi-language round trip.", 1, okay );
+
+			// On most Western machines, this is an element that contains
+			// the word "resume" with the correct accents, in a latin encoding.
+			// It will be something else completely on non-wester machines,
+			// which is why TinyXml is switching to UTF-8.
+			const char latin[] = "<element>r\x82sum\x82</element>";
+
+			TiXmlDocument latinDoc;
+			latinDoc.Parse( latin, 0, TIXML_ENCODING_LEGACY );
+
+			text = latinDoc.FirstChildElement()->FirstChild()->ToText();
+			XmlTest( "Legacy encoding: Verify text element.", "r\x82sum\x82", text->Value() );
+		}
+	}		
+
+	//////////////////////
+	// Copy and assignment
+	//////////////////////
+	printf ("\n** Copy and Assignment **\n");
+	{
+		TiXmlElement element( "foo" );
+		element.Parse( "<element name='value' />", 0, TIXML_ENCODING_UNKNOWN );
+
+		TiXmlElement elementCopy( element );
+		TiXmlElement elementAssign( "foo" );
+		elementAssign.Parse( "<incorrect foo='bar'/>", 0, TIXML_ENCODING_UNKNOWN );
+		elementAssign = element;
+
+		XmlTest( "Copy/Assign: element copy #1.", "element", elementCopy.Value() );
+		XmlTest( "Copy/Assign: element copy #2.", "value", elementCopy.Attribute( "name" ) );
+		XmlTest( "Copy/Assign: element assign #1.", "element", elementAssign.Value() );
+		XmlTest( "Copy/Assign: element assign #2.", "value", elementAssign.Attribute( "name" ) );
+		XmlTest( "Copy/Assign: element assign #3.", true, ( 0 == elementAssign.Attribute( "foo" )) );
+
+		TiXmlComment comment;
+		comment.Parse( "<!--comment-->", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlComment commentCopy( comment );
+		TiXmlComment commentAssign;
+		commentAssign = commentCopy;
+		XmlTest( "Copy/Assign: comment copy.", "comment", commentCopy.Value() );
+		XmlTest( "Copy/Assign: comment assign.", "comment", commentAssign.Value() );
+
+		TiXmlUnknown unknown;
+		unknown.Parse( "<[unknown]>", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlUnknown unknownCopy( unknown );
+		TiXmlUnknown unknownAssign;
+		unknownAssign.Parse( "incorrect", 0, TIXML_ENCODING_UNKNOWN );
+		unknownAssign = unknownCopy;
+		XmlTest( "Copy/Assign: unknown copy.", "[unknown]", unknownCopy.Value() );
+		XmlTest( "Copy/Assign: unknown assign.", "[unknown]", unknownAssign.Value() );
+		
+		TiXmlText text( "TextNode" );
+		TiXmlText textCopy( text );
+		TiXmlText textAssign( "incorrect" );
+		textAssign = text;
+		XmlTest( "Copy/Assign: text copy.", "TextNode", textCopy.Value() );
+		XmlTest( "Copy/Assign: text assign.", "TextNode", textAssign.Value() );
+
+		TiXmlDeclaration dec;
+		dec.Parse( "<?xml version='1.0' encoding='UTF-8'?>", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlDeclaration decCopy( dec );
+		TiXmlDeclaration decAssign;
+		decAssign = dec;
+
+		XmlTest( "Copy/Assign: declaration copy.", "UTF-8", decCopy.Encoding() );
+		XmlTest( "Copy/Assign: text assign.", "UTF-8", decAssign.Encoding() );
+
+		TiXmlDocument doc;
+		elementCopy.InsertEndChild( textCopy );
+		doc.InsertEndChild( decAssign );
+		doc.InsertEndChild( elementCopy );
+		doc.InsertEndChild( unknownAssign );
+
+		TiXmlDocument docCopy( doc );
+		TiXmlDocument docAssign;
+		docAssign = docCopy;
+
+		#ifdef TIXML_USE_STL
+		std::string original, copy, assign;
+		original << doc;
+		copy << docCopy;
+		assign << docAssign;
+		XmlTest( "Copy/Assign: document copy.", original.c_str(), copy.c_str(), true );
+		XmlTest( "Copy/Assign: document assign.", original.c_str(), assign.c_str(), true );
+
+		#endif
+	}	
+
+	//////////////////////////////////////////////////////
+#ifdef TIXML_USE_STL
+	printf ("\n** Parsing, no Condense Whitespace **\n");
+	TiXmlBase::SetCondenseWhiteSpace( false );
+	{
+		istringstream parse1( "<start>This  is    \ntext</start>" );
+		TiXmlElement text1( "text" );
+		parse1 >> text1;
+
+		XmlTest ( "Condense white space OFF.", "This  is    \ntext",
+					text1.FirstChild()->Value(),
+					true );
+	}
+	TiXmlBase::SetCondenseWhiteSpace( true );
+#endif
+
+	//////////////////////////////////////////////////////
+	// GetText();
+	{
+		const char* str = "<foo>This is text</foo>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		const TiXmlElement* element = doc.RootElement();
+
+		XmlTest( "GetText() normal use.", "This is text", element->GetText() );
+
+		str = "<foo><b>This is text</b></foo>";
+		doc.Clear();
+		doc.Parse( str );
+		element = doc.RootElement();
+
+		XmlTest( "GetText() contained element.", element->GetText() == 0, true );
+
+		str = "<foo>This is <b>text</b></foo>";
+		doc.Clear();
+		TiXmlBase::SetCondenseWhiteSpace( false );
+		doc.Parse( str );
+		TiXmlBase::SetCondenseWhiteSpace( true );
+		element = doc.RootElement();
+
+		XmlTest( "GetText() partial.", "This is ", element->GetText() );
+	}
+
+
+	//////////////////////////////////////////////////////
+	// CDATA
+	{
+		const char* str =	"<xmlElement>"
+								"<![CDATA["
+									"I am > the rules!\n"
+									"...since I make symbolic puns"
+								"]]>"
+							"</xmlElement>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		doc.Print();
+
+		XmlTest( "CDATA parse.", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+
+		#ifdef TIXML_USE_STL
+		//cout << doc << '\n';
+
+		doc.Clear();
+
+		istringstream parse0( str );
+		parse0 >> doc;
+		//cout << doc << '\n';
+
+		XmlTest( "CDATA stream.", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+		#endif
+
+		TiXmlDocument doc1 = doc;
+		//doc.Print();
+
+		XmlTest( "CDATA copy.", doc1.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+	}
+	{
+		// [ 1482728 ] Wrong wide char parsing
+		char buf[256];
+		buf[255] = 0;
+		for( int i=0; i<255; ++i ) {
+			buf[i] = (char)((i>=32) ? i : 32);
+		}
+		TIXML_STRING str( "<xmlElement><![CDATA[" );
+		str += buf;
+		str += "]]></xmlElement>";
+
+		TiXmlDocument doc;
+		doc.Parse( str.c_str() );
+
+		TiXmlPrinter printer;
+		printer.SetStreamPrinting();
+		doc.Accept( &printer );
+
+		XmlTest( "CDATA with all bytes #1.", str.c_str(), printer.CStr(), true );
+
+		#ifdef TIXML_USE_STL
+		doc.Clear();
+		istringstream iss( printer.Str() );
+		iss >> doc;
+		std::string out;
+		out << doc;
+		XmlTest( "CDATA with all bytes #2.", out.c_str(), printer.CStr(), true );
+		#endif
+	}
+	{
+		// [ 1480107 ] Bug-fix for STL-streaming of CDATA that contains tags
+		// CDATA streaming had a couple of bugs, that this tests for.
+		const char* str =	"<xmlElement>"
+								"<![CDATA["
+									"<b>I am > the rules!</b>\n"
+									"...since I make symbolic puns"
+								"]]>"
+							"</xmlElement>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		doc.Print();
+
+		XmlTest( "CDATA parse. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+
+		#ifdef TIXML_USE_STL
+
+		doc.Clear();
+
+		istringstream parse0( str );
+		parse0 >> doc;
+
+		XmlTest( "CDATA stream. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+		#endif
+
+		TiXmlDocument doc1 = doc;
+		//doc.Print();
+
+		XmlTest( "CDATA copy. [ 1480107 ]", doc1.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+	}
+	//////////////////////////////////////////////////////
+	// Visit()
+
+
+
+	//////////////////////////////////////////////////////
+	printf( "\n** Fuzzing... **\n" );
+
+	const int FUZZ_ITERATION = 300;
+
+	// The only goal is not to crash on bad input.
+	int len = (int) strlen( demoStart );
+	for( int i=0; i<FUZZ_ITERATION; ++i ) 
+	{
+		char* demoCopy = new char[ len+1 ];
+		strcpy( demoCopy, demoStart );
+
+		demoCopy[ i%len ] = (char)((i+1)*3);
+		demoCopy[ (i*7)%len ] = '>';
+		demoCopy[ (i*11)%len ] = '<';
+
+		TiXmlDocument xml;
+		xml.Parse( demoCopy );
+
+		delete [] demoCopy;
+	}
+	printf( "** Fuzzing Complete. **\n" );
+	
+	//////////////////////////////////////////////////////
+	printf ("\n** Bug regression tests **\n");
+
+	// InsertBeforeChild and InsertAfterChild causes crash.
+	{
+		TiXmlElement parent( "Parent" );
+		TiXmlElement childText0( "childText0" );
+		TiXmlElement childText1( "childText1" );
+		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
+		TiXmlNode* childNode1 = parent.InsertBeforeChild( childNode0, childText1 );
+
+		XmlTest( "Test InsertBeforeChild on empty node.", ( childNode1 == parent.FirstChild() ), true );
+	}
+
+	{
+		// InsertBeforeChild and InsertAfterChild causes crash.
+		TiXmlElement parent( "Parent" );
+		TiXmlElement childText0( "childText0" );
+		TiXmlElement childText1( "childText1" );
+		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
+		TiXmlNode* childNode1 = parent.InsertAfterChild( childNode0, childText1 );
+
+		XmlTest( "Test InsertAfterChild on empty node. ", ( childNode1 == parent.LastChild() ), true );
+	}
+
+	// Reports of missing constructors, irregular string problems.
+	{
+		// Missing constructor implementation. No test -- just compiles.
+		TiXmlText text( "Missing" );
+
+		#ifdef TIXML_USE_STL
+			// Missing implementation:
+			TiXmlDocument doc;
+			string name = "missing";
+			doc.LoadFile( name );
+
+			TiXmlText textSTL( name );
+		#else
+			// verifying some basic string functions:
+			TiXmlString a;
+			TiXmlString b( "Hello" );
+			TiXmlString c( "ooga" );
+
+			c = " World!";
+			a = b;
+			a += c;
+			a = a;
+
+			XmlTest( "Basic TiXmlString test. ", "Hello World!", a.c_str() );
+		#endif
+ 	}
+
+	// Long filenames crashing STL version
+	{
+		TiXmlDocument doc( "midsummerNightsDreamWithAVeryLongFilenameToConfuseTheStringHandlingRoutines.xml" );
+		bool loadOkay = doc.LoadFile();
+		loadOkay = true;	// get rid of compiler warning.
+		// Won't pass on non-dev systems. Just a "no crash" check.
+		//XmlTest( "Long filename. ", true, loadOkay );
+	}
+
+	{
+		// Entities not being written correctly.
+		// From Lynn Allen
+
+		const char* passages =
+			"<?xml version=\"1.0\" standalone=\"no\" ?>"
+			"<passages count=\"006\" formatversion=\"20020620\">"
+				"<psg context=\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
+				" It also has &lt;, &gt;, and &amp;, as well as a fake copyright &#xA9;.\"> </psg>"
+			"</passages>";
+
+		TiXmlDocument doc( "passages.xml" );
+		doc.Parse( passages );
+		TiXmlElement* psg = doc.RootElement()->FirstChildElement();
+		const char* context = psg->Attribute( "context" );
+		const char* expected = "Line 5 has \"quotation marks\" and 'apostrophe marks'. It also has <, >, and &, as well as a fake copyright \xC2\xA9.";
+
+		XmlTest( "Entity transformation: read. ", expected, context, true );
+
+		FILE* textfile = fopen( "textfile.txt", "w" );
+		if ( textfile )
+		{
+			psg->Print( textfile, 0 );
+			fclose( textfile );
+		}
+		textfile = fopen( "textfile.txt", "r" );
+		assert( textfile );
+		if ( textfile )
+		{
+			char buf[ 1024 ];
+			fgets( buf, 1024, textfile );
+			XmlTest( "Entity transformation: write. ",
+					 "<psg context=\'Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
+					 " It also has &lt;, &gt;, and &amp;, as well as a fake copyright \xC2\xA9.' />",
+					 buf,
+					 true );
+		}
+		fclose( textfile );
+	}
+
+    {
+		FILE* textfile = fopen( "test5.xml", "w" );
+		if ( textfile )
+		{
+            fputs("<?xml version='1.0'?><a.elem xmi.version='2.0'/>", textfile);
+            fclose(textfile);
+
+			TiXmlDocument doc;
+            doc.LoadFile( "test5.xml" );
+            XmlTest( "dot in element attributes and names", doc.Error(), 0);
+		}
+    }
+
+	{
+		FILE* textfile = fopen( "test6.xml", "w" );
+		if ( textfile )
+		{
+            fputs("<element><Name>1.1 Start easy ignore fin thickness&#xA;</Name></element>", textfile );
+            fclose(textfile);
+
+            TiXmlDocument doc;
+            bool result = doc.LoadFile( "test6.xml" );
+            XmlTest( "Entity with one digit.", result, true );
+
+			TiXmlText* text = doc.FirstChildElement()->FirstChildElement()->FirstChild()->ToText();
+			XmlTest( "Entity with one digit.",
+						text->Value(), "1.1 Start easy ignore fin thickness\n" );
+		}
+    }
+
+	{
+		// DOCTYPE not preserved (950171)
+		// 
+		const char* doctype =
+			"<?xml version=\"1.0\" ?>"
+			"<!DOCTYPE PLAY SYSTEM 'play.dtd'>"
+			"<!ELEMENT title (#PCDATA)>"
+			"<!ELEMENT books (title,authors)>"
+			"<element />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		doc.SaveFile( "test7.xml" );
+		doc.Clear();
+		doc.LoadFile( "test7.xml" );
+		
+		TiXmlHandle docH( &doc );
+		TiXmlUnknown* unknown = docH.Child( 1 ).Unknown();
+		XmlTest( "Correct value of unknown.", "!DOCTYPE PLAY SYSTEM 'play.dtd'", unknown->Value() );
+		#ifdef TIXML_USE_STL
+		TiXmlNode* node = docH.Child( 2 ).Node();
+		std::string str;
+		str << (*node);
+		XmlTest( "Correct streaming of unknown.", "<!ELEMENT title (#PCDATA)>", str.c_str() );
+		#endif
+	}
+
+	{
+		// [ 791411 ] Formatting bug
+		// Comments do not stream out correctly.
+		const char* doctype = 
+			"<!-- Somewhat<evil> -->";
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+
+		TiXmlHandle docH( &doc );
+		TiXmlComment* comment = docH.Child( 0 ).Node()->ToComment();
+
+		XmlTest( "Comment formatting.", " Somewhat<evil> ", comment->Value() );
+		#ifdef TIXML_USE_STL
+		std::string str;
+		str << (*comment);
+		XmlTest( "Comment streaming.", "<!-- Somewhat<evil> -->", str.c_str() );
+		#endif
+	}
+
+	{
+		// [ 870502 ] White space issues
+		TiXmlDocument doc;
+		TiXmlText* text;
+		TiXmlHandle docH( &doc );
+	
+		const char* doctype0 = "<element> This has leading and trailing space </element>";
+		const char* doctype1 = "<element>This has  internal space</element>";
+		const char* doctype2 = "<element> This has leading, trailing, and  internal space </element>";
+
+		TiXmlBase::SetCondenseWhiteSpace( false );
+		doc.Clear();
+		doc.Parse( doctype0 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", " This has leading and trailing space ", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype1 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", "This has  internal space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype2 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", " This has leading, trailing, and  internal space ", text->Value() );
+
+		TiXmlBase::SetCondenseWhiteSpace( true );
+		doc.Clear();
+		doc.Parse( doctype0 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has leading and trailing space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype1 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has internal space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype2 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has leading, trailing, and internal space", text->Value() );
+	}
+
+	{
+		// Double attributes
+		const char* doctype = "<element attr='red' attr='blue' />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		
+		XmlTest( "Parsing repeated attributes.", true, doc.Error() );	// is an  error to tinyxml (didn't use to be, but caused issues)
+		//XmlTest( "Parsing repeated attributes.", "blue", doc.FirstChildElement( "element" )->Attribute( "attr" ) );
+	}
+
+	{
+		// Embedded null in stream.
+		const char* doctype = "<element att\0r='red' attr='blue' />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		XmlTest( "Embedded null throws error.", true, doc.Error() );
+
+		#ifdef TIXML_USE_STL
+		istringstream strm( doctype );
+		doc.Clear();
+		doc.ClearError();
+		strm >> doc;
+		XmlTest( "Embedded null throws error.", true, doc.Error() );
+		#endif
+	}
+
+    {
+            // Legacy mode test. (This test may only pass on a western system)
+            const char* str =
+                        "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"
+                        "<>"
+                        "Cntnt"
+                        "</>";
+
+            TiXmlDocument doc;
+            doc.Parse( str );
+
+            TiXmlHandle docHandle( &doc );
+            TiXmlHandle aHandle = docHandle.FirstChildElement( "" );
+            TiXmlHandle tHandle = aHandle.Child( 0 );
+            assert( aHandle.Element() );
+            assert( tHandle.Text() );
+            XmlTest( "ISO-8859-1 Parsing.", "Cntnt", tHandle.Text()->Value() );
+    }
+
+	{
+		// Empty documents should return TIXML_ERROR_PARSING_EMPTY, bug 1070717
+		const char* str = "    ";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		XmlTest( "Empty document error TIXML_ERROR_DOCUMENT_EMPTY", TiXmlBase::TIXML_ERROR_DOCUMENT_EMPTY, doc.ErrorId() );
+	}
+	#ifndef TIXML_USE_STL
+	{
+		// String equality. [ 1006409 ] string operator==/!= no worky in all cases
+		TiXmlString temp;
+		XmlTest( "Empty tinyxml string compare equal", ( temp == "" ), true );
+
+		TiXmlString    foo;
+		TiXmlString    bar( "" );
+		XmlTest( "Empty tinyxml string compare equal", ( foo == bar ), true );
+	}
+
+	#endif
+	{
+		// Bug [ 1195696 ] from marlonism
+		TiXmlBase::SetCondenseWhiteSpace(false); 
+		TiXmlDocument xml; 
+		xml.Parse("<text><break/>This hangs</text>"); 
+		XmlTest( "Test safe error return.", xml.Error(), false );
+	}
+
+	{
+		// Bug [ 1243992 ] - another infinite loop
+		TiXmlDocument doc;
+		doc.SetCondenseWhiteSpace(false);
+		doc.Parse("<p><pb></pb>test</p>");
+	} 
+	{
+		// Low entities
+		TiXmlDocument xml;
+		xml.Parse( "<test>&#x0e;</test>" );
+		const char result[] = { 0x0e, 0 };
+		XmlTest( "Low entities.", xml.FirstChildElement()->GetText(), result );
+		xml.Print();
+	}
+	{
+		// Bug [ 1451649 ] Attribute values with trailing quotes not handled correctly
+		TiXmlDocument xml;
+		xml.Parse( "<foo attribute=bar\" />" );
+		XmlTest( "Throw error with bad end quotes.", xml.Error(), true );
+	}
+	#ifdef TIXML_USE_STL
+	{
+		// Bug [ 1449463 ] Consider generic query
+		TiXmlDocument xml;
+		xml.Parse( "<foo bar='3' barStr='a string'/>" );
+
+		TiXmlElement* ele = xml.FirstChildElement();
+		double d;
+		int i;
+		float f;
+		bool b;
+		std::string str;
+
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &d ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &i ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &f ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &b ), TIXML_WRONG_TYPE );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "nobar", &b ), TIXML_NO_ATTRIBUTE );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "barStr", &str ), TIXML_SUCCESS );
+
+		XmlTest( "QueryValueAttribute", (d==3.0), true );
+		XmlTest( "QueryValueAttribute", (i==3), true );
+		XmlTest( "QueryValueAttribute", (f==3.0f), true );
+		XmlTest( "QueryValueAttribute", (str==std::string( "a string" )), true );
+	}
+	#endif
+
+	#ifdef TIXML_USE_STL
+	{
+		// [ 1505267 ] redundant malloc in TiXmlElement::Attribute
+		TiXmlDocument xml;
+		xml.Parse( "<foo bar='3' />" );
+		TiXmlElement* ele = xml.FirstChildElement();
+		double d;
+		int i;
+
+		std::string bar = "bar";
+
+		const std::string* atrrib = ele->Attribute( bar );
+		ele->Attribute( bar, &d );
+		ele->Attribute( bar, &i );
+
+		XmlTest( "Attribute", atrrib->empty(), false );
+		XmlTest( "Attribute", (d==3.0), true );
+		XmlTest( "Attribute", (i==3), true );
+	}
+	#endif
+
+	{
+		// [ 1356059 ] Allow TiXMLDocument to only be at the top level
+		TiXmlDocument xml, xml2;
+		xml.InsertEndChild( xml2 );
+		XmlTest( "Document only at top level.", xml.Error(), true );
+		XmlTest( "Document only at top level.", xml.ErrorId(), TiXmlBase::TIXML_ERROR_DOCUMENT_TOP_ONLY );
+	}
+
+	{
+		// [ 1663758 ] Failure to report error on bad XML
+		TiXmlDocument xml;
+		xml.Parse("<x>");
+		XmlTest("Missing end tag at end of input", xml.Error(), true);
+		xml.Parse("<x> ");
+		XmlTest("Missing end tag with trailing whitespace", xml.Error(), true);
+	} 
+
+	{
+		// [ 1635701 ] fail to parse files with a tag separated into two lines
+		// I'm not sure this is a bug. Marked 'pending' for feedback.
+		TiXmlDocument xml;
+		xml.Parse( "<title><p>text</p\n><title>" );
+		//xml.Print();
+		//XmlTest( "Tag split by newline", xml.Error(), false );
+	}
+
+	#ifdef TIXML_USE_STL
+	{
+		// [ 1475201 ] TinyXML parses entities in comments
+		TiXmlDocument xml;
+		istringstream parse1( "<!-- declarations for <head> & <body> -->"
+						      "<!-- far &amp; away -->" );
+		parse1 >> xml;
+
+		TiXmlNode* e0 = xml.FirstChild();
+		TiXmlNode* e1 = e0->NextSibling();
+		TiXmlComment* c0 = e0->ToComment();
+		TiXmlComment* c1 = e1->ToComment();
+
+		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
+		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
+	}
+	#endif
+
+	{
+		// [ 1475201 ] TinyXML parses entities in comments
+		TiXmlDocument xml;
+		xml.Parse("<!-- declarations for <head> & <body> -->"
+				  "<!-- far &amp; away -->" );
+
+		TiXmlNode* e0 = xml.FirstChild();
+		TiXmlNode* e1 = e0->NextSibling();
+		TiXmlComment* c0 = e0->ToComment();
+		TiXmlComment* c1 = e1->ToComment();
+
+		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
+		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
+	}
+
+	{
+		TiXmlDocument xml;
+		xml.Parse( "<Parent>"
+						"<child1 att=''/>"
+						"<!-- With this comment, child2 will not be parsed! -->"
+						"<child2 att=''/>"
+					"</Parent>" );
+		int count = 0;
+
+		TiXmlNode* ele = 0;
+		while ( (ele = xml.FirstChildElement( "Parent" )->IterateChildren( ele ) ) != 0 ) {
+			++count;
+		}
+		XmlTest( "Comments iterate correctly.", 3, count );
+	}
+
+	{
+		// trying to repro ]1874301]. If it doesn't go into an infinite loop, all is well.
+		unsigned char buf[] = "<?xml version=\"1.0\" encoding=\"utf-8\"?><feed><![CDATA[Test XMLblablablalblbl";
+		buf[60] = 239;
+		buf[61] = 0;
+
+		TiXmlDocument doc;
+		doc.Parse( (const char*)buf);
+	} 
+
+
+	{
+		// bug 1827248 Error while parsing a little bit malformed file
+		// Actually not malformed - should work.
+		TiXmlDocument xml;
+		xml.Parse( "<attributelist> </attributelist >" );
+		XmlTest( "Handle end tag whitespace", false, xml.Error() );
+	}
+
+	{
+		// 1709904 - can not repro the crash
+		{
+			TiXmlDocument xml;
+			xml.Parse( "<tag>/</tag>" );
+			XmlTest( "Odd XML parsing.", xml.FirstChild()->Value(), "tag" );
+		}
+		/* Could not repro. {
+			TiXmlDocument xml;
+			xml.LoadFile( "EQUI_Inventory.xml" );
+			//XmlTest( "Odd XML parsing.", xml.FirstChildElement()->Value(), "XML" );
+			TiXmlPrinter printer;
+			xml.Accept( &printer );
+			fprintf( stdout, "%s", printer.CStr() );
+		}*/
+	}
+
+	/*  1417717 experiment
+	{
+		TiXmlDocument xml;
+		xml.Parse("<text>Dan & Tracie</text>");
+		xml.Print(stdout);
+	}
+	{
+		TiXmlDocument xml;
+		xml.Parse("<text>Dan &foo; Tracie</text>");
+		xml.Print(stdout);
+	}
+	*/
+	#if defined( WIN32 ) && defined( TUNE )
+	_CrtMemCheckpoint( &endMemState );
+	//_CrtMemDumpStatistics( &endMemState );
+
+	_CrtMemState diffMemState;
+	_CrtMemDifference( &diffMemState, &startMemState, &endMemState );
+	_CrtMemDumpStatistics( &diffMemState );
+	#endif
+
+	printf ("\nPass %d, Fail %d\n", gPass, gFail);
+	return gFail;
+}
diff -urN vdr-2.0.1/tinyxml/tinystr.cpp vdr-2.0.1.reel/tinyxml/tinystr.cpp
--- vdr-2.0.1/tinyxml/tinystr.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinystr.cpp	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,116 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lvset, 7. April 2005.
+ */
+
+
+#ifndef TIXML_USE_STL
+
+#include "tinystr.h"
+
+// Error value for find primitive
+const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);
+
+
+// Null rep.
+TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\0' } };
+
+
+void TiXmlString::reserve (size_type cap)
+{
+	if (cap > capacity())
+	{
+		TiXmlString tmp;
+		tmp.init(length(), cap);
+		memcpy(tmp.start(), data(), length());
+		swap(tmp);
+	}
+}
+
+
+TiXmlString& TiXmlString::assign(const char* str, size_type len)
+{
+	size_type cap = capacity();
+	if (len > cap || cap > 3*(len + 8))
+	{
+		TiXmlString tmp;
+		tmp.init(len);
+		memcpy(tmp.start(), str, len);
+		swap(tmp);
+	}
+	else
+	{
+		memmove(start(), str, len);
+		set_size(len);
+	}
+	return *this;
+}
+
+
+TiXmlString& TiXmlString::append(const char* str, size_type len)
+{
+	size_type newsize = length() + len;
+	if (newsize > capacity())
+	{
+		reserve (newsize + capacity());
+	}
+	memmove(finish(), str, len);
+	set_size(newsize);
+	return *this;
+}
+
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	tmp.reserve(a.length() + b.length());
+	tmp += a;
+	tmp += b;
+	return tmp;
+}
+
+TiXmlString operator + (const TiXmlString & a, const char* b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
+	tmp.reserve(a.length() + b_len);
+	tmp += a;
+	tmp.append(b, b_len);
+	return tmp;
+}
+
+TiXmlString operator + (const char* a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
+	tmp.reserve(a_len + b.length());
+	tmp.append(a, a_len);
+	tmp += b;
+	return tmp;
+}
+
+
+#endif	// TIXML_USE_STL
diff -urN vdr-2.0.1/tinyxml/tinystr.h vdr-2.0.1.reel/tinyxml/tinystr.h
--- vdr-2.0.1/tinyxml/tinystr.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinystr.h	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,319 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
+ *
+ * - completely rewritten. compact, clean, and fast implementation.
+ * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
+ * - fixed reserve() to work as per specification.
+ * - fixed buggy compares operator==(), operator<(), and operator>()
+ * - fixed operator+=() to take a const ref argument, following spec.
+ * - added "copy" constructor with length, and most compare operators.
+ * - added swap(), clear(), size(), capacity(), operator+().
+ */
+
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#include <assert.h>
+#include <string.h>
+
+/*	The support for explicit isn't that universal, and it isn't really
+	required - it is used to check that the TiXmlString class isn't incorrectly
+	used. Be nice to old compilers and macro it here:
+*/
+#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
+	// Microsoft visual studio, version 6 and higher.
+	#define TIXML_EXPLICIT explicit
+#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+	// GCC version 3 and higher.s
+	#define TIXML_EXPLICIT explicit
+#else
+	#define TIXML_EXPLICIT
+#endif
+
+
+/*
+   TiXmlString is an emulation of a subset of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TiXmlString
+{
+  public :
+	// The size type used
+  	typedef size_t size_type;
+
+	// Error value for find primitive
+	static const size_type npos; // = -1;
+
+
+	// TiXmlString empty constructor
+	TiXmlString () : rep_(&nullrep_)
+	{
+	}
+
+	// TiXmlString copy constructor
+	TiXmlString ( const TiXmlString & copy) : rep_(0)
+	{
+		init(copy.length());
+		memcpy(start(), copy.data(), length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
+	{
+		init( static_cast<size_type>( strlen(copy) ));
+		memcpy(start(), copy, length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
+	{
+		init(len);
+		memcpy(start(), str, len);
+	}
+
+	// TiXmlString destructor
+	~TiXmlString ()
+	{
+		quit();
+	}
+
+	// = operator
+	TiXmlString& operator = (const char * copy)
+	{
+		return assign( copy, (size_type)strlen(copy));
+	}
+
+	// = operator
+	TiXmlString& operator = (const TiXmlString & copy)
+	{
+		return assign(copy.start(), copy.length());
+	}
+
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const char * suffix)
+	{
+		return append(suffix, static_cast<size_type>( strlen(suffix) ));
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (char single)
+	{
+		return append(&single, 1);
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const TiXmlString & suffix)
+	{
+		return append(suffix.data(), suffix.length());
+	}
+
+
+	// Convert a TiXmlString into a null-terminated char *
+	const char * c_str () const { return rep_->str; }
+
+	// Convert a TiXmlString into a char * (need not be null terminated).
+	const char * data () const { return rep_->str; }
+
+	// Return the length of a TiXmlString
+	size_type length () const { return rep_->size; }
+
+	// Alias for length()
+	size_type size () const { return rep_->size; }
+
+	// Checks if a TiXmlString is empty
+	bool empty () const { return rep_->size == 0; }
+
+	// Return capacity of string
+	size_type capacity () const { return rep_->capacity; }
+
+
+	// single char extraction
+	const char& at (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// [] operator
+	char& operator [] (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// find a char in a string. Return TiXmlString::npos if not found
+	size_type find (char lookup) const
+	{
+		return find(lookup, 0);
+	}
+
+	// find a char in a string from an offset. Return TiXmlString::npos if not found
+	size_type find (char tofind, size_type offset) const
+	{
+		if (offset >= length()) return npos;
+
+		for (const char* p = c_str() + offset; *p != '\0'; ++p)
+		{
+		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
+		}
+		return npos;
+	}
+
+	void clear ()
+	{
+		//Lee:
+		//The original was just too strange, though correct:
+		//	TiXmlString().swap(*this);
+		//Instead use the quit & re-init:
+		quit();
+		init(0,0);
+	}
+
+	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function DOES NOT clear the content of the TiXmlString if any exists.
+	*/
+	void reserve (size_type cap);
+
+	TiXmlString& assign (const char* str, size_type len);
+
+	TiXmlString& append (const char* str, size_type len);
+
+	void swap (TiXmlString& other)
+	{
+		Rep* r = rep_;
+		rep_ = other.rep_;
+		other.rep_ = r;
+	}
+
+  private:
+
+	void init(size_type sz) { init(sz, sz); }
+	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
+	char* start() const { return rep_->str; }
+	char* finish() const { return rep_->str + rep_->size; }
+
+	struct Rep
+	{
+		size_type size, capacity;
+		char str[1];
+	};
+
+	void init(size_type sz, size_type cap)
+	{
+		if (cap)
+		{
+			// Lee: the original form:
+			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
+			// doesn't work in some cases of new being overloaded. Switching
+			// to the normal allocation, although use an 'int' for systems
+			// that are overly picky about structure alignment.
+			const size_type bytesNeeded = sizeof(Rep) + cap;
+			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
+			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );
+
+			rep_->str[ rep_->size = sz ] = '\0';
+			rep_->capacity = cap;
+		}
+		else
+		{
+			rep_ = &nullrep_;
+		}
+	}
+
+	void quit()
+	{
+		if (rep_ != &nullrep_)
+		{
+			// The rep_ is really an array of ints. (see the allocator, above).
+			// Cast it back before delete, so the compiler won't incorrectly call destructors.
+			delete [] ( reinterpret_cast<int*>( rep_ ) );
+		}
+	}
+
+	Rep * rep_;
+	static Rep nullrep_;
+
+} ;
+
+
+inline bool operator == (const TiXmlString & a, const TiXmlString & b)
+{
+	return    ( a.length() == b.length() )				// optimization on some platforms
+	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
+}
+inline bool operator < (const TiXmlString & a, const TiXmlString & b)
+{
+	return strcmp(a.c_str(), b.c_str()) < 0;
+}
+
+inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
+inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
+inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
+inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }
+
+inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
+inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
+inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
+inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
+TiXmlString operator + (const TiXmlString & a, const char* b);
+TiXmlString operator + (const char* a, const TiXmlString & b);
+
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TiXmlOutStream : public TiXmlString
+{
+public :
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const TiXmlString & in)
+	{
+		*this += in;
+		return *this;
+	}
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const char * in)
+	{
+		*this += in;
+		return *this;
+	}
+
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL
diff -urN vdr-2.0.1/tinyxml/tinyxml.cpp vdr-2.0.1.reel/tinyxml/tinyxml.cpp
--- vdr-2.0.1/tinyxml/tinyxml.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxml.cpp	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,1839 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include <ctype.h>
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#include <iostream>
+#endif
+
+#include "tinyxml.h"
+
+FILE* TiXmlFOpen( const char* filename, const char* mode );
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+// Microsoft compiler security
+FILE* TiXmlFOpen( const char* filename, const char* mode )
+{
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		FILE* fp = 0;
+		errno_t err = fopen_s( &fp, filename, mode );
+		if ( !err && fp )
+			return fp;
+		return 0;
+	#else
+		return fopen( filename, mode );
+	#endif
+}
+
+void TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&' 
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+			
+			#if defined(TIXML_SNPRINTF)		
+				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#else
+				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#endif		
+
+			//*ME:	warning C4267: convert 'size_t' to 'int'
+			//*ME:	Int-Cast to make compiler happy ...
+			outString->append( buf, (int)strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+
+TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
+{
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData; 
+	target->location = location;
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	assert( node->parent == 0 || node->parent == this );
+	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );
+
+	if ( node->Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		delete node;
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{	
+	if ( !beforeThis || beforeThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( !replaceThis )
+		return 0;
+
+	if ( replaceThis->parent != this )
+		return 0;
+
+	if ( withThis.ToDocument() ) {
+		// A document can never be a child.	Thanks to Noam.
+		TiXmlDocument* document = GetDocument();
+		if ( document ) 
+			document->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( !removeThis ) {
+		return false;
+	}
+
+	if ( removeThis->parent != this )
+	{	
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const 
+{
+	const TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING str( name );
+	TiXmlAttribute* node = attributeSet.Find( str );
+	#else
+	TiXmlAttribute* node = attributeSet.Find( name );
+	#endif
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+const TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value ) 
+	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char* TiXmlElement::Attribute( const char* name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return node->Value();
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( attrib )
+		return &attrib->ValueStr();
+	return 0;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, int* i ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const char* result = 0;
+
+	if ( attrib ) {
+		result = attrib->Value();
+		if ( i ) {
+			attrib->QueryIntValue( i );
+		}
+	}
+	return result;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const std::string* result = 0;
+
+	if ( attrib ) {
+		result = &attrib->ValueStr();
+		if ( i ) {
+			attrib->QueryIntValue( i );
+		}
+	}
+	return result;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, double* d ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const char* result = 0;
+
+	if ( attrib ) {
+		result = attrib->Value();
+		if ( d ) {
+			attrib->QueryDoubleValue( d );
+		}
+	}
+	return result;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	const std::string* result = 0;
+
+	if ( attrib ) {
+		result = &attrib->ValueStr();
+		if ( d ) {
+			attrib->QueryDoubleValue( d );
+		}
+	}
+	return result;
+}
+#endif
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryIntValue( ival );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryIntValue( ival );
+}
+#endif
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryDoubleValue( dval );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
+{
+	const TiXmlAttribute* attrib = attributeSet.Find( name );
+	if ( !attrib )
+		return TIXML_NO_ATTRIBUTE;
+	return attrib->QueryDoubleValue( dval );
+}
+#endif
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetIntValue( val );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, int val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetIntValue( val );
+	}
+}
+#endif
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetDoubleValue( val );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetDoubleAttribute( const std::string& name, double val )
+{	
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
+	if ( attrib ) {
+		attrib->SetDoubleValue( val );
+	}
+}
+#endif 
+
+
+void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
+{
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( cname );
+	if ( attrib ) {
+		attrib->SetValue( cvalue );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& _name, const std::string& _value )
+{
+	TiXmlAttribute* attrib = attributeSet.FindOrCreate( _name );
+	if ( attrib ) {
+		attrib->SetValue( _value );
+	}
+}
+#endif
+
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	assert( cfile );
+	for ( i=0; i<depth; i++ ) {
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	const TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class: 
+	// Clone the attributes, then clone the children.
+	const TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this, attributeSet.First() ) ) 
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+const char* TiXmlElement::GetText() const
+{
+	const TiXmlNode* child = this->FirstChild();
+	if ( child ) {
+		const TiXmlText* childText = child->ToText();
+		if ( childText ) {
+			return childText->Value();
+		}
+	}
+	return 0;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	return LoadFile( Value(), encoding );
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	return SaveFile( Value() );
+}
+
+bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
+{
+	TIXML_STRING filename( _filename );
+	value = filename;
+
+	// reading in binary mode so that tinyxml can normalize the EOL
+	FILE* file = TiXmlFOpen( value.c_str (), "rb" );	
+
+	if ( file )
+	{
+		bool result = LoadFile( file, encoding );
+		fclose( file );
+		return result;
+	}
+	else
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+}
+
+bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
+{
+	if ( !file ) 
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+	long length = 0;
+	fseek( file, 0, SEEK_END );
+	length = ftell( file );
+	fseek( file, 0, SEEK_SET );
+
+	// Strange case, but good to handle up front.
+	if ( length <= 0 )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
+	// 2.11 End-of-Line Handling
+	// <snip>
+	// <quote>
+	// ...the XML processor MUST behave as if it normalized all line breaks in external 
+	// parsed entities (including the document entity) on input, before parsing, by translating 
+	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to 
+	// a single #xA character.
+	// </quote>
+	//
+	// It is not clear fgets does that, and certainly isn't clear it works cross platform. 
+	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
+	// convention, and not work generally.
+
+	/*
+	while( fgets( buf, sizeof(buf), file ) )
+	{
+		data += buf;
+	}
+	*/
+
+	char* buf = new char[ length+1 ];
+	buf[0] = 0;
+
+	if ( fread( buf, length, 1, file ) != 1 ) {
+		delete [] buf;
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Process the buffer in place to normalize new lines. (See comment above.)
+	// Copies from the 'p' to 'q' pointer, where p can advance faster if
+	// a newline-carriage return is hit.
+	//
+	// Wikipedia:
+	// Systems based on ASCII or a compatible character set use either LF  (Line feed, '\n', 0x0A, 10 in decimal) or 
+	// CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF (CR+LF, 0x0D 0x0A)...
+	//		* LF:    Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS, Amiga, RISC OS, and others
+    //		* CR+LF: DEC RT-11 and most other early non-Unix, non-IBM OSes, CP/M, MP/M, DOS, OS/2, Microsoft Windows, Symbian OS
+    //		* CR:    Commodore 8-bit machines, Apple II family, Mac OS up to version 9 and OS-9
+
+	const char* p = buf;	// the read head
+	char* q = buf;			// the write head
+	const char CR = 0x0d;
+	const char LF = 0x0a;
+
+	buf[length] = 0;
+	while( *p ) {
+		assert( p < (buf+length) );
+		assert( q <= (buf+length) );
+		assert( q <= p );
+
+		if ( *p == CR ) {
+			*q++ = LF;
+			p++;
+			if ( *p == LF ) {		// check for CR+LF (and skip LF)
+				p++;
+			}
+		}
+		else {
+			*q++ = *p++;
+		}
+	}
+	assert( q <= (buf+length) );
+	*q = 0;
+
+	Parse( buf, 0, encoding );
+
+	delete [] buf;
+	return !Error();
+}
+
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = TiXmlFOpen( filename, "w" );
+	if ( fp )
+	{
+		bool result = SaveFile( fp );
+		fclose( fp );
+		return result;
+	}
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile( FILE* fp ) const
+{
+	if ( useMicrosoftBOM ) 
+	{
+		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+		fputc( TIXML_UTF_LEAD_0, fp );
+		fputc( TIXML_UTF_LEAD_1, fp );
+		fputc( TIXML_UTF_LEAD_2, fp );
+	}
+	Print( fp, 0 );
+	return (ferror(fp) == 0);
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorId = errorId;
+	target->errorDesc = errorDesc;
+	target->tabsize = tabsize;
+	target->errorLocation = errorLocation;
+	target->useMicrosoftBOM = useMicrosoftBOM;
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}	
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+
+bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this ) )
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+const TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Next()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+*/
+
+const TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Previous()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+*/
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	TIXML_STRING n, v;
+
+	EncodeString( name, &n );
+	EncodeString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos) {
+		if ( cfile ) {
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
+		}
+	}
+	else {
+		if ( cfile ) {
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
+		}
+	}
+}
+
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
+	#else
+		sprintf (buf, "%d", _value);
+	#endif
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [256];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%g", _value);
+	#else
+		sprintf (buf, "%g", _value);
+	#endif
+	SetValue (buf);
+}
+
+int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( int i=0; i<depth; i++ )
+	{
+		fprintf( cfile,  "    " );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	if ( cdata )
+	{
+		int i;
+		fprintf( cfile, "\n" );
+		for ( i=0; i<depth; i++ ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
+	}
+	else
+	{
+		TIXML_STRING buffer;
+		EncodeString( value, &buffer );
+		fprintf( cfile, "%s", buffer.c_str() );
+	}
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+	target->cdata = cdata;
+}
+
+
+bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{	
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
+{
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	if ( cfile ) fprintf( cfile, "<?xml " );
+	if ( str )	 (*str) += "<?xml ";
+
+	if ( !version.empty() ) {
+		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
+		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
+	}
+	if ( !encoding.empty() ) {
+		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
+	}
+	if ( !standalone.empty() ) {
+		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
+	}
+	if ( cfile ) fprintf( cfile, "?>" );
+	if ( str )	 (*str) += "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{	
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+    #ifdef TIXML_USE_STL
+	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
+	#else
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+	#endif
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+TiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const std::string& _name )
+{
+	TiXmlAttribute* attrib = Find( _name );
+	if ( !attrib ) {
+		attrib = new TiXmlAttribute();
+		Add( attrib );
+		attrib->SetName( _name );
+	}
+	return attrib;
+}
+#endif
+
+
+TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+TiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const char* _name )
+{
+	TiXmlAttribute* attrib = Find( _name );
+	if ( !attrib ) {
+		attrib = new TiXmlAttribute();
+		Add( attrib );
+		attrib->SetName( _name );
+	}
+	return attrib;
+}
+
+
+#ifdef TIXML_USE_STL	
+std::istream& operator>> (std::istream & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+#ifdef TIXML_USE_STL	
+std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out << printer.Str();
+
+	return out;
+}
+
+
+std::string& operator<< (std::string& out, const TiXmlNode& base )
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out.append( printer.Str() );
+
+	return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += element.Value();
+
+	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
+	{
+		buffer += " ";
+		attrib->Print( 0, 0, &buffer );
+	}
+
+	if ( !element.FirstChild() ) 
+	{
+		buffer += " />";
+		DoLineBreak();
+	}
+	else 
+	{
+		buffer += ">";
+		if (    element.FirstChild()->ToText()
+			  && element.LastChild() == element.FirstChild()
+			  && element.FirstChild()->ToText()->CDATA() == false )
+		{
+			simpleTextPrint = true;
+			// no DoLineBreak()!
+		}
+		else
+		{
+			DoLineBreak();
+		}
+	}
+	++depth;	
+	return true;
+}
+
+
+bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
+{
+	--depth;
+	if ( !element.FirstChild() ) 
+	{
+		// nothing.
+	}
+	else 
+	{
+		if ( simpleTextPrint )
+		{
+			simpleTextPrint = false;
+		}
+		else
+		{
+			DoIndent();
+		}
+		buffer += "</";
+		buffer += element.Value();
+		buffer += ">";
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlText& text )
+{
+	if ( text.CDATA() )
+	{
+		DoIndent();
+		buffer += "<![CDATA[";
+		buffer += text.Value();
+		buffer += "]]>";
+		DoLineBreak();
+	}
+	else if ( simpleTextPrint )
+	{
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+	}
+	else
+	{
+		DoIndent();
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
+{
+	DoIndent();
+	declaration.Print( 0, 0, &buffer );
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlComment& comment )
+{
+	DoIndent();
+	buffer += "<!--";
+	buffer += comment.Value();
+	buffer += "-->";
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += unknown.Value();
+	buffer += ">";
+	DoLineBreak();
+	return true;
+}
+
diff -urN vdr-2.0.1/tinyxml/tinyxml.dsw vdr-2.0.1.reel/tinyxml/tinyxml.dsw
--- vdr-2.0.1/tinyxml/tinyxml.dsw	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxml.dsw	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,71 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "tinyXmlTest"=.\tinyXmlTest.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name tinyxml
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tinyXmlTestSTL"=.\tinyXmlTestSTL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name tinyxmlSTL
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tinyxml"=.\tinyxml_lib.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "tinyxmlSTL"=.\tinyxmlSTL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN vdr-2.0.1/tinyxml/tinyxmlerror.cpp vdr-2.0.1.reel/tinyxml/tinyxmlerror.cpp
--- vdr-2.0.1/tinyxml/tinyxmlerror.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxmlerror.cpp	2013-05-09 18:10:01.655874320 +0200
@@ -0,0 +1,52 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// english error messages, but the could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+	"Error parsing CDATA.",
+	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
+};
diff -urN vdr-2.0.1/tinyxml/tinyxml.h vdr-2.0.1.reel/tinyxml/tinyxml.h
--- vdr-2.0.1/tinyxml/tinyxml.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxml.h	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,1799 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#include <sstream>
+	#define TIXML_STRING		std::string
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING		TiXmlString
+#endif
+
+// Deprecated library function hell. Compilers want to use the
+// new safe versions. This probably doesn't fully address the problem,
+// but it gets closer. There are too many compilers for me to fully
+// test. If you get compilation troubles, undefine TIXML_SAFE
+#define TIXML_SAFE
+
+#ifdef TIXML_SAFE
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		// Microsoft visual studio, version 2005 and higher.
+		#define TIXML_SNPRINTF _snprintf_s
+		#define TIXML_SSCANF   sscanf_s
+	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
+		// Microsoft visual studio, version 6 and higher.
+		//#pragma message( "Using _sn* functions." )
+		#define TIXML_SNPRINTF _snprintf
+		#define TIXML_SSCANF   sscanf
+	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+		// GCC version 3 and higher.s
+		//#warning( "Using sn* functions." )
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SSCANF   sscanf
+	#else
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SSCANF   sscanf
+	#endif
+#endif	
+
+class TiXmlDocument;
+class TiXmlElement;
+class TiXmlComment;
+class TiXmlUnknown;
+class TiXmlAttribute;
+class TiXmlText;
+class TiXmlDeclaration;
+class TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 6;
+const int TIXML_PATCH_VERSION = 1;
+
+/*	Internal structure for tracking location of items 
+	in the XML file.
+*/
+struct TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+/**
+	Implements the interface to the "Visitor pattern" (see the Accept() method.)
+	If you call the Accept() method, it requires being passed a TiXmlVisitor
+	class to handle callbacks. For nodes that contain other nodes (Document, Element)
+	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
+	are simply called with Visit().
+
+	If you return 'true' from a Visit method, recursive parsing will continue. If you return
+	false, <b>no children of this node or its sibilings</b> will be Visited.
+
+	All flavors of Visit methods have a default implementation that returns 'true' (continue 
+	visiting). You need to only override methods that are interesting to you.
+
+	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.
+
+	You should never change the document from a callback.
+
+	@sa TiXmlNode::Accept()
+*/
+class TiXmlVisitor
+{
+public:
+	virtual ~TiXmlVisitor() {}
+
+	/// Visit a document.
+	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
+	/// Visit a document.
+	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }
+
+	/// Visit an element.
+	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
+	/// Visit an element.
+	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }
+
+	/// Visit a declaration
+	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
+	/// Visit a text node
+	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
+	/// Visit a comment node
+	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
+	/// Visit an unknow node
+	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
+};
+
+// Only used by Attribute::Query functions
+enum 
+{ 
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+class TiXmlBase
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0)		{}
+	virtual ~TiXmlBase()			{}
+
+	/**	All TinyXml classes can print themselves to a filestream
+		or the string class (TiXmlString in non-STL mode, std::string
+		in STL mode.) Either or both cfile and str can be null.
+		
+		This is a formatted print, and will insert 
+		tabs and newlines.
+		
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		value is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
+	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
+	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p, 
+								TiXmlParsingData* data, 
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
+		or they will be transformed into entities!
+	*/
+	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+		TIXML_ERROR_PARSING_CDATA,
+		TIXML_ERROR_DOCUMENT_TOP_ONLY,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+
+protected:
+
+	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+
+	inline static bool IsWhiteSpace( char c )		
+	{ 
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
+	}
+	inline static bool IsWhiteSpace( int c )
+	{
+		if ( c < 256 )
+			return IsWhiteSpace( (char) c );
+		return false;	// Again, only truly correct for English/Latin...but usually works.
+	}
+
+	#ifdef TIXML_USE_STL
+	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((const unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
+												// and the null terminator isn't needed
+			for( int i=0; p[i] && i<*length; ++i ) {
+				_value[i] = p[i];
+			}
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to English words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+	
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL	
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+		    
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */	
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		TINYXML_DOCUMENT,
+		TINYXML_ELEMENT,
+		TINYXML_COMMENT,
+		TINYXML_UNKNOWN,
+		TINYXML_TEXT,
+		TINYXML_DECLARATION,
+		TINYXML_TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char *Value() const { return value.c_str (); }
+
+    #ifdef TIXML_USE_STL
+	/** Return Value() as a std::string. If you only use STL,
+	    this is more efficient than calling Value().
+		Only available in STL mode.
+	*/
+	const std::string& ValueStr() const { return value; }
+	#endif
+
+	const TIXML_STRING& ValueTStr() const { return value; }
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent()							{ return parent; }
+	const TiXmlNode* Parent() const				{ return parent; }
+
+	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild()						{ return firstChild; }
+	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+	/// The first child of this node with the matching 'value'. Will be null if none found.
+	TiXmlNode* FirstChild( const char * _value ) {
+		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
+		// call the method, cast the return back to non-const.
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
+	}
+	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild()	{ return lastChild; }
+	
+	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * _value ) {
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
+	}
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling() const			{ return prev; }
+	TiXmlNode* PreviousSibling()						{ return prev; }
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling( const char * ) const;
+	TiXmlNode* PreviousSibling( const char *_prev ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* NextSibling() const				{ return next; }
+	TiXmlNode* NextSibling()							{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	const TiXmlNode* NextSibling( const char * ) const;
+	TiXmlNode* NextSibling( const char* _next ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement() const;
+	TiXmlElement* NextSiblingElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement( const char * ) const;
+	TiXmlElement* NextSiblingElement( const char *_next ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement()	const;
+	TiXmlElement* FirstChildElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
+	}
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement( const char * _value ) const;
+	TiXmlElement* FirstChildElement( const char * _value ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	const TiXmlDocument* GetDocument() const;
+	TiXmlDocument* GetDocument() {
+		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
+	}
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller. 
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
+		XML tree will be conditionally visited and the host will be called back
+		via the TiXmlVisitor interface.
+
+		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
+		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
+		interface versus any other.)
+
+		The interface has been based on ideas from:
+
+		- http://www.saxproject.org/
+		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern 
+
+		Which are both good references for "visiting".
+
+		An example of using Accept():
+		@verbatim
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &printer );
+		const char* xmlcstr = printer.CStr();
+		@endverbatim
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
+	#ifdef TIXML_USE_STL
+	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
+	#endif
+	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	// Get the tinyxml string representation
+	const TIXML_STRING& NameTStr() const { return name; }
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* _value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* _value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int _value );										///< Set the value from an integer.
+	void SetDoubleValue( double _value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )	{ name = _name; }	
+	/// STL std::string form.	
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	const TiXmlAttribute* Next() const;
+	TiXmlAttribute* Next() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); 
+	}
+
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	const TiXmlAttribute* Previous() const;
+	TiXmlAttribute* Previous() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); 
+	}
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+	
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+
+	TiXmlAttribute*	Find( const char* _name ) const;
+	TiXmlAttribute* FindOrCreate( const char* _name );
+
+#	ifdef TIXML_USE_STL
+	TiXmlAttribute*	Find( const std::string& _name ) const;
+	TiXmlAttribute* FindOrCreate( const std::string& _name );
+#	endif
+
+
+private:
+	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
+	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
+	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
+	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)
+
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/	
+	int QueryIntAttribute( const char* name, int* _value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* _value ) const;
+	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
+	int QueryFloatAttribute( const char* name, float* _value ) const {
+		double d;
+		int result = QueryDoubleAttribute( name, &d );
+		if ( result == TIXML_SUCCESS ) {
+			*_value = (float)d;
+		}
+		return result;
+	}
+
+    #ifdef TIXML_USE_STL
+	/// QueryStringAttribute examines the attribute - see QueryIntAttribute().
+	int QueryStringAttribute( const char* name, std::string* _value ) const {
+		const char* cstr = Attribute( name );
+		if ( cstr ) {
+			*_value = std::string( cstr );
+			return TIXML_SUCCESS;
+		}
+		return TIXML_NO_ATTRIBUTE;
+	}
+
+	/** Template form of the attribute query which will try to read the
+		attribute into the specified type. Very easy, very powerful, but
+		be careful to make sure to call this with the correct type.
+		
+		NOTE: This method doesn't work correctly for 'string' types that contain spaces.
+
+		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
+	*/
+	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+
+		std::stringstream sstream( node->ValueStr() );
+		sstream >> *outValue;
+		if ( !sstream.fail() )
+			return TIXML_SUCCESS;
+		return TIXML_WRONG_TYPE;
+	}
+
+	int QueryValueAttribute( const std::string& name, std::string* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+		*outValue = node->ValueStr();
+		return TIXML_SUCCESS;
+	}
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * _value );
+
+    #ifdef TIXML_USE_STL
+	const std::string* Attribute( const std::string& name ) const;
+	const std::string* Attribute( const std::string& name, int* i ) const;
+	const std::string* Attribute( const std::string& name, double* d ) const;
+	int QueryIntAttribute( const std::string& name, int* _value ) const;
+	int QueryDoubleAttribute( const std::string& name, double* _value ) const;
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value );
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value );
+	///< STL std::string form.
+	void SetDoubleAttribute( const std::string& name, double value );
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
+	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }
+
+	/** Convenience function for easy access to the text inside an element. Although easy
+		and concise, GetText() is limited compared to getting the TiXmlText child
+		and accessing it directly.
+	
+		If the first child of 'this' is a TiXmlText, the GetText()
+		returns the character string of the Text node, else null is returned.
+
+		This is a convenient method for getting the text of simple contained text:
+		@verbatim
+		<foo>This is text</foo>
+		const char* str = fooElement->GetText();
+		@endverbatim
+
+		'str' will be a pointer to "This is text". 
+		
+		Note that this function can be misleading. If the element foo was created from
+		this XML:
+		@verbatim
+		<foo><b>This is text</b></foo> 
+		@endverbatim
+
+		then the value of str would be null. The first child node isn't a text node, it is
+		another element. From this XML:
+		@verbatim
+		<foo>This is <b>text</b></foo> 
+		@endverbatim
+		GetText() will return "This is ".
+
+		WARNING: GetText() accesses a child node - don't become confused with the 
+				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
+				 safe type casts on the referenced node.
+	*/
+	const char* GetText() const;
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {}
+	/// Construct a comment from text.
+	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {
+		SetValue( _value );
+	}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+//	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. A text node can have 2 ways to output the next. "normal" output 
+	and CDATA. It will default to the mode it was parsed from the XML file and
+	you generally want to leave it alone, but you can change the output mode with 
+	SetCDATA() and query it with CDATA().
+*/
+class TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/** Constructor for text element. By default, it is treated as 
+		normal, encoded text. If you want it be output as a CDATA text
+		element, set the parameter _cdata to 'true'
+	*/
+	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TINYXML_TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/// Queries whether this represents text using a CDATA section.
+	bool CDATA() const				{ return cdata; }
+	/// Turns on or off a CDATA representation of text.
+	void SetCDATA( bool _cdata )	{ cdata = _cdata; }
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	bool cdata;			// true if this should be input and output as a CDATA style text element
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::TINYXML_DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+	/** Load a file using the given FILE*. Returns true if successful. Note that this method
+		doesn't stream - the entire object pointed at by the FILE*
+		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
+		file location. Streaming may be added in the future.
+	*/
+	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given FILE*. Returns true if successful.
+	bool SaveFile( FILE* ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+		return LoadFile( filename.c_str(), encoding );
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+		return SaveFile( filename.c_str() );
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+	TiXmlElement* RootElement()					{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/	
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1, 
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow() const	{ return errorLocation.row+1; }
+	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
+		to report the correct values for row and column. It does not change the output
+		or input in any way.
+		
+		By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false; 
+												errorId = 0; 
+												errorDesc = ""; 
+												errorLocation.row = errorLocation.col = 0; 
+												//errorLocation.last = 0; 
+											}
+
+	/** Write the document to standard out using formatted printing ("pretty print"). */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/* Write the document to a string using formatted printing ("pretty print"). This
+		will allocate a character array (new char[]) and return it as a pointer. The
+		calling code pust call delete[] on the return char* to avoid a memory leak.
+	*/
+	//char* PrintToMemory() const; 
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
+	a linear walk to find the element, so this code would iterate much more than it needs 
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/** Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* ToNode() const			{ return node; } 
+	/** Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/**	Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/** Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+	/** @deprecated use ToNode. 
+		Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* Node() const			{ return ToNode(); } 
+	/** @deprecated use ToElement. 
+		Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* Element() const	{ return ToElement(); }
+	/**	@deprecated use ToText()
+		Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* Text() const			{ return ToText(); }
+	/** @deprecated use ToUnknown()
+		Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+/** Print to memory functionality. The TiXmlPrinter is useful when you need to:
+
+	-# Print to memory (especially in non-STL mode)
+	-# Control formatting (line endings, etc.)
+
+	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
+	Before calling Accept() you can call methods to control the printing
+	of the XML document. After TiXmlNode::Accept() is called, the printed document can
+	be accessed via the CStr(), Str(), and Size() methods.
+
+	TiXmlPrinter uses the Visitor API.
+	@verbatim
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	@endverbatim
+*/
+class TiXmlPrinter : public TiXmlVisitor
+{
+public:
+	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
+					 buffer(), indent( "    " ), lineBreak( "\n" ) {}
+
+	virtual bool VisitEnter( const TiXmlDocument& doc );
+	virtual bool VisitExit( const TiXmlDocument& doc );
+
+	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
+	virtual bool VisitExit( const TiXmlElement& element );
+
+	virtual bool Visit( const TiXmlDeclaration& declaration );
+	virtual bool Visit( const TiXmlText& text );
+	virtual bool Visit( const TiXmlComment& comment );
+	virtual bool Visit( const TiXmlUnknown& unknown );
+
+	/** Set the indent characters for printing. By default 4 spaces
+		but tab (\t) is also useful, or null/empty string for no indentation.
+	*/
+	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
+	/// Query the indention string.
+	const char* Indent()							{ return indent.c_str(); }
+	/** Set the line breaking string. By default set to newline (\n). 
+		Some operating systems prefer other characters, or can be
+		set to the null/empty string for no indenation.
+	*/
+	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
+	/// Query the current line breaking string.
+	const char* LineBreak()							{ return lineBreak.c_str(); }
+
+	/** Switch over to "stream printing" which is the most dense formatting without 
+		linebreaks. Common when the XML is needed for network transmission.
+	*/
+	void SetStreamPrinting()						{ indent = "";
+													  lineBreak = "";
+													}	
+	/// Return the result.
+	const char* CStr()								{ return buffer.c_str(); }
+	/// Return the length of the result string.
+	size_t Size()									{ return buffer.size(); }
+
+	#ifdef TIXML_USE_STL
+	/// Return the result.
+	const std::string& Str()						{ return buffer; }
+	#endif
+
+private:
+	void DoIndent()	{
+		for( int i=0; i<depth; ++i )
+			buffer += indent;
+	}
+	void DoLineBreak() {
+		buffer += lineBreak;
+	}
+
+	int depth;
+	bool simpleTextPrint;
+	TIXML_STRING buffer;
+	TIXML_STRING indent;
+	TIXML_STRING lineBreak;
+};
+
+
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+
+#endif
+
diff -urN vdr-2.0.1/tinyxml/tinyxml_lib.dsp vdr-2.0.1.reel/tinyxml/tinyxml_lib.dsp
--- vdr-2.0.1/tinyxml/tinyxml_lib.dsp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxml_lib.dsp	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,130 @@
+# Microsoft Developer Studio Project File - Name="tinyxml" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=tinyxml - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxml_lib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxml_lib.mak" CFG="tinyxml - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyxml - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "tinyxml - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyxml - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "NDEBUG"
+# ADD RSC /l 0x407 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Release\tinyxml.lib"
+
+!ELSEIF  "$(CFG)" == "tinyxml - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x407 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\tinyxmld.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyxml - Win32 Release"
+# Name "tinyxml - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\changes.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\readme.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\tutorial_gettingStarted.txt
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/tinyxml_lib.vcproj vdr-2.0.1.reel/tinyxml/tinyxml_lib.vcproj
--- vdr-2.0.1/tinyxml/tinyxml_lib.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxml_lib.vcproj	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,284 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyxml"
+	ProjectGUID="{C406DAEC-0886-4771-8DEA-9D7329B46CC1}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/tinyxml_lib.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1031"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Release\tinyxml.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/tinyxml_lib.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/tinyxml_lib.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1031"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug\tinyxmld.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/tinyxml_lib.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="tinystr.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxml.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlerror.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlparser.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="tinystr.h"
+				>
+			</File>
+			<File
+				RelativePath="tinyxml.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="changes.txt"
+			>
+		</File>
+		<File
+			RelativePath="readme.txt"
+			>
+		</File>
+		<File
+			RelativePath="tutorial_gettingStarted.txt"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/tinyxmlparser.cpp vdr-2.0.1.reel/tinyxml/tinyxmlparser.cpp
--- vdr-2.0.1/tinyxml/tinyxmlparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxmlparser.cpp	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,1635 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+*/
+
+#include <ctype.h>
+#include <stddef.h>
+
+#include "tinyxml.h"
+
+//#define DEBUG_PARSER
+#if defined( DEBUG_PARSER )
+#	if defined( DEBUG ) && defined( _MSC_VER )
+#		include <windows.h>
+#		define TIXML_LOG OutputDebugString
+#	else
+#		define TIXML_LOG printf
+#	endif
+#endif
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.	
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:	
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf 
+
+const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+const int TiXmlBase::utf8ByteTable[256] = 
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0 
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80) 
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	// Scary scary fall throughs.
+	switch (*length) 
+	{
+		case 4:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 3:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 2:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 1:
+			--output; 
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Treat p as unsigned, so we have a happy compiler.
+		const unsigned char* pU = (const unsigned char*)p;
+
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*pU) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;				
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case TIXML_UTF_LEAD_0:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
+							p += 3;	
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			const unsigned char* pU = (const unsigned char*)p;
+			
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==TIXML_UTF_LEAD_1 
+				 && *(pU+2)==TIXML_UTF_LEAD_2 )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbeU )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbfU )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( *p && IsWhiteSpace( *p ) )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
+// "assign" optimization removes over 10% of the execution time.
+//
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	// Oddly, not supported on some comilers,
+	//name->clear();
+	// So use this:
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p 
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		const char* start = p;
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			//(*name) += *p; // expensive
+			++p;
+		}
+		if ( p-start > 0 ) {
+			name->assign( start, p-start );
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		ptrdiff_t delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else 
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else 
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
+					// Just writes strange XML.
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p, 
+									TIXML_STRING * text, 
+									bool trimWhiteSpace, 
+									const char* endTag, 
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	if ( p && *p ) 
+		p += strlen( endTag );
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) ) 
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of 
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		const unsigned char* pU = (const unsigned char*)p;
+		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
+			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
+			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+			useMicrosoftBOM = true;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else 
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// Was this empty?
+	if ( !firstChild ) {
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
+		return 0;
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{	
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing? 
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+	const char* cdataHeader = { "<![CDATA[" };
+
+	if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, cdataHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing CDATA\n" );
+		#endif
+		TiXmlText* text = new TiXmlText( "" );
+		text->SetCDATA( true );
+		returnNode = text;
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+		
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>' 
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		cdata text (which looks like another node)
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' ) 
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = (int) tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				// Early out if we find the CDATA id.
+				if ( c == '[' && tag->size() >= 9 )
+				{
+					size_t len = tag->size();
+					const char* start = tag->c_str() + len - 9;
+					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
+						assert( !closingTag );
+						break;
+					}
+				}
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p ) {
+				// We were looking for the end tag, but found nothing.
+				// Fix for [ 1663758 ] Failure to report error on bad XML
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+
+			// We should find the end tag now
+			// note that:
+			// </foo > and
+			// </foo> 
+			// are both valid end tags.
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				p = SkipWhiteSpace( p, encoding );
+				if ( p && *p && *p == '>' ) {
+					++p;
+					return p;
+				}
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			#ifdef TIXML_USE_STL
+			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
+			#else
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			#endif
+			if ( node )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	// Read in text and elements in any order.
+	const char* pWithWhiteSpace = p;
+	p = SkipWhiteSpace( p, encoding );
+
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+			    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		} 
+		else 
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag? This could also be
+			// a TiXmlText in the "CDATA" style.
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}				
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		pWithWhiteSpace = p;
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}	
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>' 
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+
+	// [ 1475201 ] TinyXML parses entities in comments
+	// Oops - ReadText doesn't work, because we don't want to parse the entities.
+	// p = ReadText( p, &value, false, endTag, false, encoding );
+	//
+	// from the XML spec:
+	/*
+	 [Definition: Comments may appear anywhere in a document outside other markup; in addition, 
+	              they may appear within the document type declaration at places allowed by the grammar. 
+				  They are not part of the document's character data; an XML processor MAY, but need not, 
+				  make it possible for an application to retrieve the text of comments. For compatibility, 
+				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity 
+				  references MUST NOT be recognized within comments.
+
+				  An example of a comment:
+
+				  <!-- declarations for <head> & <body> -->
+	*/
+
+    value = "";
+	// Keep all the white space.
+	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )
+	{
+		value.append( p, 1 );
+		++p;
+	}
+	if ( p && *p ) 
+		p += strlen( endTag );
+
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+	
+	const char* end;
+	const char SINGLE_QUOTE = '\'';
+	const char DOUBLE_QUOTE = '\"';
+
+	if ( *p == SINGLE_QUOTE )
+	{
+		++p;
+		end = "\'";		// single quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == DOUBLE_QUOTE )
+	{
+		++p;
+		end = "\"";		// double quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p											// existence
+				&& !IsWhiteSpace( *p )								// whitespace
+				&& *p != '/' && *p != '>' )							// tag end
+		{
+			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
+				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
+				// We did not have an opening quote but seem to have a 
+				// closing one. Give up and throw an error.
+				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+				return 0;
+			}
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();	
+		if ( !cdata && (c == '<' ) ) 
+		{
+			return;
+		}
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();	// "commits" the peek made above
+
+		if ( cdata && c == '>' && tag->size() >= 3 ) {
+			size_t len = tag->size();
+			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
+				// terminator of cdata.
+				return;
+			}
+		}    
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+	TiXmlDocument* document = GetDocument();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	const char* const startTag = "<![CDATA[";
+	const char* const endTag   = "]]>";
+
+	if ( cdata || StringEqual( p, startTag, false, encoding ) )
+	{
+		cdata = true;
+
+		if ( !StringEqual( p, startTag, false, encoding ) )
+		{
+			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
+			return 0;
+		}
+		p += strlen( startTag );
+
+		// Keep all the white space, ignore the encoding, etc.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, false, encoding )
+			  )
+		{
+			value += *p;
+			++p;
+		}
+
+		TIXML_STRING dummy; 
+		p = ReadText( p, &dummy, false, endTag, false, encoding );
+		return p;
+	}
+	else
+	{
+		bool ignoreWhite = true;
+
+		const char* end = "<";
+		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+		if ( p )
+			return p-1;	// don't truncate the '<'
+		return 0;
+	}
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
+
diff -urN vdr-2.0.1/tinyxml/tinyxml.sln vdr-2.0.1.reel/tinyxml/tinyxml.sln
--- vdr-2.0.1/tinyxml/tinyxml.sln	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxml.sln	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,44 @@
+
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyXmlTest", "tinyXmlTest.vcproj", "{34719950-09E8-457E-BE23-8F1CE3A1F1F6}"
+	ProjectSection(ProjectDependencies) = postProject
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1} = {C406DAEC-0886-4771-8DEA-9D7329B46CC1}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyXmlTestSTL", "tinyXmlTestSTL.vcproj", "{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{A3A84737-5017-4577-B8A2-79429A25B8B6} = {A3A84737-5017-4577-B8A2-79429A25B8B6}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyxml", "tinyxml_lib.vcproj", "{C406DAEC-0886-4771-8DEA-9D7329B46CC1}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyxmlSTL", "tinyxmlSTL.vcproj", "{A3A84737-5017-4577-B8A2-79429A25B8B6}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Debug|Win32.ActiveCfg = Debug|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Debug|Win32.Build.0 = Debug|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Release|Win32.ActiveCfg = Release|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Release|Win32.Build.0 = Release|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Debug|Win32.Build.0 = Debug|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Release|Win32.ActiveCfg = Release|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Release|Win32.Build.0 = Release|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Debug|Win32.ActiveCfg = Debug|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Debug|Win32.Build.0 = Debug|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Release|Win32.ActiveCfg = Release|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Release|Win32.Build.0 = Release|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Debug|Win32.Build.0 = Debug|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Release|Win32.ActiveCfg = Release|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN vdr-2.0.1/tinyxml/tinyxmlSTL.dsp vdr-2.0.1.reel/tinyxml/tinyxmlSTL.dsp
--- vdr-2.0.1/tinyxml/tinyxmlSTL.dsp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxmlSTL.dsp	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,126 @@
+# Microsoft Developer Studio Project File - Name="tinyxmlSTL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=tinyxmlSTL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxmlSTL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxmlSTL.mak" CFG="tinyxmlSTL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyxmlSTL - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "tinyxmlSTL - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyxmlSTL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyxmlSTL___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyxmlSTL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release_STL"
+# PROP Intermediate_Dir "Release_STL"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "TIXML_USE_STL" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Release_STL\tinyxml_STL.lib"
+
+!ELSEIF  "$(CFG)" == "tinyxmlSTL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyxmlSTL___Win32_Debug0"
+# PROP BASE Intermediate_Dir "tinyxmlSTL___Win32_Debug0"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug_STL"
+# PROP Intermediate_Dir "Debug_STL"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "TIXML_USE_STL" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug_STL\tinyxmld_STL.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyxmlSTL - Win32 Release"
+# Name "tinyxmlSTL - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\changes.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\readme.txt
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/tinyxmlSTL.vcproj vdr-2.0.1.reel/tinyxml/tinyxmlSTL.vcproj
--- vdr-2.0.1/tinyxml/tinyxmlSTL.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyxmlSTL.vcproj	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,279 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyxmlSTL"
+	ProjectGUID="{A3A84737-5017-4577-B8A2-79429A25B8B6}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug_STL"
+			IntermediateDirectory=".\Debug_STL"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;TIXML_USE_STL;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug_STL/tinyxmlSTL.pch"
+				AssemblerListingLocation=".\Debug_STL/"
+				ObjectFile=".\Debug_STL/"
+				ProgramDataBaseFileName=".\Debug_STL/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug_STL\tinyxmld_STL.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug_STL/tinyxmlSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release_STL"
+			IntermediateDirectory=".\Release_STL"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;TIXML_USE_STL"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release_STL/tinyxmlSTL.pch"
+				AssemblerListingLocation=".\Release_STL/"
+				ObjectFile=".\Release_STL/"
+				ProgramDataBaseFileName=".\Release_STL/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Release_STL\tinyxml_STL.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release_STL/tinyxmlSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			>
+			<File
+				RelativePath="tinystr.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxml.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlerror.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlparser.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			>
+			<File
+				RelativePath="tinystr.h"
+				>
+			</File>
+			<File
+				RelativePath="tinyxml.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="changes.txt"
+			>
+		</File>
+		<File
+			RelativePath="readme.txt"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/tinyXmlTest.dsp vdr-2.0.1.reel/tinyxml/tinyXmlTest.dsp
--- vdr-2.0.1/tinyxml/tinyXmlTest.dsp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyXmlTest.dsp	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,92 @@
+# Microsoft Developer Studio Project File - Name="tinyXmlTest" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tinyXmlTest - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTest.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTest.mak" CFG="tinyXmlTest - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyXmlTest - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "tinyXmlTest - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyXmlTest - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyXmlTest___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyXmlTest___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "tinyXmlTest___Win32_Release"
+# PROP Intermediate_Dir "tinyXmlTest___Win32_Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 ./Release/tinyxml.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "tinyXmlTest - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyXmlTest___Win32_Debug"
+# PROP BASE Intermediate_Dir "tinyXmlTest___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "tinyXmlTest___Win32_Debug"
+# PROP Intermediate_Dir "tinyXmlTest___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TUNE" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 ./Debug/tinyxmld.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyXmlTest - Win32 Release"
+# Name "tinyXmlTest - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltest.cpp
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/tinyXmlTestSTL.dsp vdr-2.0.1.reel/tinyxml/tinyXmlTestSTL.dsp
--- vdr-2.0.1/tinyxml/tinyXmlTestSTL.dsp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyXmlTestSTL.dsp	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,92 @@
+# Microsoft Developer Studio Project File - Name="tinyXmlTestSTL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tinyXmlTestSTL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTestSTL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTestSTL.mak" CFG="tinyXmlTestSTL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyXmlTestSTL - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "tinyXmlTestSTL - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyXmlTestSTL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP Intermediate_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 ./Release_STL/tinyxml_stl.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "tinyXmlTestSTL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP BASE Intermediate_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP Intermediate_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /D "TUNE" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 ./Debug_STL/tinyxmld_stl.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyXmlTestSTL - Win32 Release"
+# Name "tinyXmlTestSTL - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltest.cpp
+# End Source File
+# End Target
+# End Project
diff -urN vdr-2.0.1/tinyxml/tinyXmlTestSTL.vcproj vdr-2.0.1.reel/tinyxml/tinyXmlTestSTL.vcproj
--- vdr-2.0.1/tinyxml/tinyXmlTestSTL.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyXmlTestSTL.vcproj	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,225 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyXmlTestSTL"
+	ProjectGUID="{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\tinyXmlTestSTL___Win32_Debug"
+			IntermediateDirectory=".\tinyXmlTestSTL___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;TIXML_USE_STL;TUNE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.pch"
+				AssemblerListingLocation=".\tinyXmlTestSTL___Win32_Debug/"
+				ObjectFile=".\tinyXmlTestSTL___Win32_Debug/"
+				ProgramDataBaseFileName=".\tinyXmlTestSTL___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Debug_STL/tinyxmld_stl.lib"
+				OutputFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\tinyXmlTestSTL___Win32_Release"
+			IntermediateDirectory=".\tinyXmlTestSTL___Win32_Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;TIXML_USE_STL;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.pch"
+				AssemblerListingLocation=".\tinyXmlTestSTL___Win32_Release/"
+				ObjectFile=".\tinyXmlTestSTL___Win32_Release/"
+				ProgramDataBaseFileName=".\tinyXmlTestSTL___Win32_Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Release_STL/tinyxml_stl.lib"
+				OutputFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="xmltest.cpp"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/tinyXmlTest.vcproj vdr-2.0.1.reel/tinyxml/tinyXmlTest.vcproj
--- vdr-2.0.1/tinyxml/tinyXmlTest.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/tinyXmlTest.vcproj	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,226 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="tinyXmlTest"
+	ProjectGUID="{34719950-09E8-457E-BE23-8F1CE3A1F1F6}"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\tinyXmlTest___Win32_Debug"
+			IntermediateDirectory=".\tinyXmlTest___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTest___Win32_Debug/tinyXmlTest.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;TUNE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.pch"
+				AssemblerListingLocation=".\tinyXmlTest___Win32_Debug/"
+				ObjectFile=".\tinyXmlTest___Win32_Debug/"
+				ProgramDataBaseFileName=".\tinyXmlTest___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Debug/tinyxmld.lib"
+				OutputFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\tinyXmlTest___Win32_Release"
+			IntermediateDirectory=".\tinyXmlTest___Win32_Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTest___Win32_Release/tinyXmlTest.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.pch"
+				AssemblerListingLocation=".\tinyXmlTest___Win32_Release/"
+				ObjectFile=".\tinyXmlTest___Win32_Release/"
+				ProgramDataBaseFileName=".\tinyXmlTest___Win32_Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Release/tinyxml.lib"
+				OutputFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="xmltest.cpp"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN vdr-2.0.1/tinyxml/utf8testverify.xml vdr-2.0.1.reel/tinyxml/utf8testverify.xml
--- vdr-2.0.1/tinyxml/utf8testverify.xml	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/utf8testverify.xml	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<document>
+    <English name="name" value="value">The world has many languages</English>
+    <Russian name="()" value="">   </Russian>
+    <Spanish name="el nombre" value="el valor">el mundo tiene muchos idiomas</Spanish>
+    <SimplifiedChinese name="" value=""></SimplifiedChinese>
+    < ="name" ="value">&lt;&gt;</>
+    < ="name" ="value"></>
+    <Heavy>&quot;Mtl!&quot;</Heavy>
+    <>Umlaut Element</>
+</document>
diff -urN vdr-2.0.1/tinyxml/utf8test.xml vdr-2.0.1.reel/tinyxml/utf8test.xml
--- vdr-2.0.1/tinyxml/utf8test.xml	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/utf8test.xml	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+    <English name="name" value="value">The world has many languages</English>
+    <Russian name="()" value="">   </Russian>
+    <Spanish name="el nombre" value="el valor">el mundo tiene muchos idiomas</Spanish>
+    <SimplifiedChinese name="" value=""></SimplifiedChinese>
+    < ="name" ="value">&lt;&gt;</>
+    < ="name" ="value"></>
+    <Heavy>"M&#x0eB;t&#230;l!"</Heavy>
+    <>Umlaut Element</>
+</document>
diff -urN vdr-2.0.1/tinyxml/xmltest.cpp vdr-2.0.1.reel/tinyxml/xmltest.cpp
--- vdr-2.0.1/tinyxml/xmltest.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml/xmltest.cpp	2013-05-09 18:10:01.659874319 +0200
@@ -0,0 +1,1364 @@
+/*
+   Test program for TinyXML.
+*/
+
+
+#ifdef TIXML_USE_STL
+	#include <iostream>
+	#include <sstream>
+	using namespace std;
+#else
+	#include <stdio.h>
+#endif
+
+#if defined( WIN32 ) && defined( TUNE )
+	#include <crtdbg.h>
+	_CrtMemState startMemState;
+	_CrtMemState endMemState;
+#endif
+
+#include "tinyxml.h"
+
+bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho = false);
+bool XmlTest( const char* testString, int expected, int found, bool noEcho = false );
+
+static int gPass = 0;
+static int gFail = 0;
+
+
+
+bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho )
+{
+	bool pass = !strcmp( expected, found );
+	if ( pass )
+		printf ("[pass]");
+	else
+		printf ("[fail]");
+
+	if ( noEcho )
+		printf (" %s\n", testString);
+	else
+		printf (" %s [%s][%s]\n", testString, expected, found);
+
+	if ( pass )
+		++gPass;
+	else
+		++gFail;
+	return pass;
+}
+
+
+bool XmlTest( const char* testString, int expected, int found, bool noEcho )
+{
+	bool pass = ( expected == found );
+	if ( pass )
+		printf ("[pass]");
+	else
+		printf ("[fail]");
+
+	if ( noEcho )
+		printf (" %s\n", testString);
+	else
+		printf (" %s [%d][%d]\n", testString, expected, found);
+
+	if ( pass )
+		++gPass;
+	else
+		++gFail;
+	return pass;
+}
+
+
+//
+// This file demonstrates some basic functionality of TinyXml.
+// Note that the example is very contrived. It presumes you know
+// what is in the XML file. But it does test the basic operations,
+// and show how to add and remove nodes.
+//
+
+int main()
+{
+
+	//
+	// We start with the 'demoStart' todo list. Process it. And
+	// should hopefully end up with the todo list as illustrated.
+	//
+	const char* demoStart =
+		"<?xml version=\"1.0\"  standalone='no' >\n"
+		"<!-- Our to do list data -->"
+		"<ToDo>\n"
+		"<!-- Do I need a secure PDA? -->\n"
+		"<Item priority=\"1\" distance='close'> Go to the <bold>Toy store!</bold></Item>"
+		"<Item priority=\"2\" distance='none'> Do bills   </Item>"
+		"<Item priority=\"2\" distance='far &amp; back'> Look for Evil Dinosaurs! </Item>"
+		"</ToDo>";
+		
+	{
+
+	#ifdef TIXML_USE_STL
+		//	What the todo list should look like after processing.
+		// In stream (no formatting) representation.
+		const char* demoEnd =
+			"<?xml version=\"1.0\" standalone=\"no\" ?>"
+			"<!-- Our to do list data -->"
+			"<ToDo>"
+			"<!-- Do I need a secure PDA? -->"
+			"<Item priority=\"2\" distance=\"close\">Go to the"
+			"<bold>Toy store!"
+			"</bold>"
+			"</Item>"
+			"<Item priority=\"1\" distance=\"far\">Talk to:"
+			"<Meeting where=\"School\">"
+			"<Attendee name=\"Marple\" position=\"teacher\" />"
+			"<Attendee name=\"Voel\" position=\"counselor\" />"
+			"</Meeting>"
+			"<Meeting where=\"Lunch\" />"
+			"</Item>"
+			"<Item priority=\"2\" distance=\"here\">Do bills"
+			"</Item>"
+			"</ToDo>";
+	#endif
+
+		// The example parses from the character string (above):
+		#if defined( WIN32 ) && defined( TUNE )
+		_CrtMemCheckpoint( &startMemState );
+		#endif	
+
+		{
+			// Write to a file and read it back, to check file I/O.
+
+			TiXmlDocument doc( "demotest.xml" );
+			doc.Parse( demoStart );
+
+			if ( doc.Error() )
+			{
+				printf( "Error in %s: %s\n", doc.Value(), doc.ErrorDesc() );
+				exit( 1 );
+			}
+			doc.SaveFile();
+		}
+
+		TiXmlDocument doc( "demotest.xml" );
+		bool loadOkay = doc.LoadFile();
+
+		if ( !loadOkay )
+		{
+			printf( "Could not load test file 'demotest.xml'. Error='%s'. Exiting.\n", doc.ErrorDesc() );
+			exit( 1 );
+		}
+
+		printf( "** Demo doc read from disk: ** \n\n" );
+		printf( "** Printing via doc.Print **\n" );
+		doc.Print( stdout );
+
+		{
+			printf( "** Printing via TiXmlPrinter **\n" );
+			TiXmlPrinter printer;
+			doc.Accept( &printer );
+			fprintf( stdout, "%s", printer.CStr() );
+		}
+		#ifdef TIXML_USE_STL	
+		{
+			printf( "** Printing via operator<< **\n" );
+			std::cout << doc;
+		}
+		#endif
+		TiXmlNode* node = 0;
+		TiXmlElement* todoElement = 0;
+		TiXmlElement* itemElement = 0;
+
+
+		// --------------------------------------------------------
+		// An example of changing existing attributes, and removing
+		// an element from the document.
+		// --------------------------------------------------------
+
+		// Get the "ToDo" element.
+		// It is a child of the document, and can be selected by name.
+		node = doc.FirstChild( "ToDo" );
+		assert( node );
+		todoElement = node->ToElement();
+		assert( todoElement  );
+
+		// Going to the toy store is now our second priority...
+		// So set the "priority" attribute of the first item in the list.
+		node = todoElement->FirstChildElement();	// This skips the "PDA" comment.
+		assert( node );
+		itemElement = node->ToElement();
+		assert( itemElement  );
+		itemElement->SetAttribute( "priority", 2 );
+
+		// Change the distance to "doing bills" from
+		// "none" to "here". It's the next sibling element.
+		itemElement = itemElement->NextSiblingElement();
+		assert( itemElement );
+		itemElement->SetAttribute( "distance", "here" );
+
+		// Remove the "Look for Evil Dinosaurs!" item.
+		// It is 1 more sibling away. We ask the parent to remove
+		// a particular child.
+		itemElement = itemElement->NextSiblingElement();
+		todoElement->RemoveChild( itemElement );
+
+		itemElement = 0;
+
+		// --------------------------------------------------------
+		// What follows is an example of created elements and text
+		// nodes and adding them to the document.
+		// --------------------------------------------------------
+
+		// Add some meetings.
+		TiXmlElement item( "Item" );
+		item.SetAttribute( "priority", "1" );
+		item.SetAttribute( "distance", "far" );
+
+		TiXmlText text( "Talk to:" );
+
+		TiXmlElement meeting1( "Meeting" );
+		meeting1.SetAttribute( "where", "School" );
+
+		TiXmlElement meeting2( "Meeting" );
+		meeting2.SetAttribute( "where", "Lunch" );
+
+		TiXmlElement attendee1( "Attendee" );
+		attendee1.SetAttribute( "name", "Marple" );
+		attendee1.SetAttribute( "position", "teacher" );
+
+		TiXmlElement attendee2( "Attendee" );
+		attendee2.SetAttribute( "name", "Voel" );
+		attendee2.SetAttribute( "position", "counselor" );
+
+		// Assemble the nodes we've created:
+		meeting1.InsertEndChild( attendee1 );
+		meeting1.InsertEndChild( attendee2 );
+
+		item.InsertEndChild( text );
+		item.InsertEndChild( meeting1 );
+		item.InsertEndChild( meeting2 );
+
+		// And add the node to the existing list after the first child.
+		node = todoElement->FirstChild( "Item" );
+		assert( node );
+		itemElement = node->ToElement();
+		assert( itemElement );
+
+		todoElement->InsertAfterChild( itemElement, item );
+
+		printf( "\n** Demo doc processed: ** \n\n" );
+		doc.Print( stdout );
+
+
+	#ifdef TIXML_USE_STL
+		printf( "** Demo doc processed to stream: ** \n\n" );
+		cout << doc << endl << endl;
+	#endif
+
+		// --------------------------------------------------------
+		// Different tests...do we have what we expect?
+		// --------------------------------------------------------
+
+		int count = 0;
+		TiXmlElement*	element;
+
+		//////////////////////////////////////////////////////
+
+	#ifdef TIXML_USE_STL
+		cout << "** Basic structure. **\n";
+		ostringstream outputStream( ostringstream::out );
+		outputStream << doc;
+		XmlTest( "Output stream correct.",	string( demoEnd ).c_str(),
+											outputStream.str().c_str(), true );
+	#endif
+
+		node = doc.RootElement();
+		assert( node );
+		XmlTest( "Root element exists.", true, ( node != 0 && node->ToElement() ) );
+		XmlTest ( "Root element value is 'ToDo'.", "ToDo",  node->Value());
+
+		node = node->FirstChild();
+		XmlTest( "First child exists & is a comment.", true, ( node != 0 && node->ToComment() ) );
+		node = node->NextSibling();
+		XmlTest( "Sibling element exists & is an element.", true, ( node != 0 && node->ToElement() ) );
+		XmlTest ( "Value is 'Item'.", "Item", node->Value() );
+
+		node = node->FirstChild();
+		XmlTest ( "First child exists.", true, ( node != 0 && node->ToText() ) );
+		XmlTest ( "Value is 'Go to the'.", "Go to the", node->Value() );
+
+
+		//////////////////////////////////////////////////////
+		printf ("\n** Iterators. **\n");
+
+		// Walk all the top level nodes of the document.
+		count = 0;
+		for( node = doc.FirstChild();
+			 node;
+			 node = node->NextSibling() )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using First / Next.", 3, count );
+
+		count = 0;
+		for( node = doc.LastChild();
+			 node;
+			 node = node->PreviousSibling() )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using Last / Previous.", 3, count );
+
+		// Walk all the top level nodes of the document,
+		// using a different syntax.
+		count = 0;
+		for( node = doc.IterateChildren( 0 );
+			 node;
+			 node = doc.IterateChildren( node ) )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using IterateChildren.", 3, count );
+
+		// Walk all the elements in a node.
+		count = 0;
+		for( element = todoElement->FirstChildElement();
+			 element;
+			 element = element->NextSiblingElement() )
+		{
+			count++;
+		}
+		XmlTest( "Children of the 'ToDo' element, using First / Next.",
+			3, count );
+
+		// Walk all the elements in a node by value.
+		count = 0;
+		for( node = todoElement->FirstChild( "Item" );
+			 node;
+			 node = node->NextSibling( "Item" ) )
+		{
+			count++;
+		}
+		XmlTest( "'Item' children of the 'ToDo' element, using First/Next.", 3, count );
+
+		count = 0;
+		for( node = todoElement->LastChild( "Item" );
+			 node;
+			 node = node->PreviousSibling( "Item" ) )
+		{
+			count++;
+		}
+		XmlTest( "'Item' children of the 'ToDo' element, using Last/Previous.", 3, count );
+
+	#ifdef TIXML_USE_STL
+		{
+			cout << "\n** Parsing. **\n";
+			istringstream parse0( "<Element0 attribute0='foo0' attribute1= noquotes attribute2 = '&gt;' />" );
+			TiXmlElement element0( "default" );
+			parse0 >> element0;
+
+			XmlTest ( "Element parsed, value is 'Element0'.", "Element0", element0.Value() );
+			XmlTest ( "Reads attribute 'attribute0=\"foo0\"'.", "foo0", element0.Attribute( "attribute0" ));
+			XmlTest ( "Reads incorrectly formatted 'attribute1=noquotes'.", "noquotes", element0.Attribute( "attribute1" ) );
+			XmlTest ( "Read attribute with entity value '>'.", ">", element0.Attribute( "attribute2" ) );
+		}
+	#endif
+
+		{
+			const char* error =	"<?xml version=\"1.0\" standalone=\"no\" ?>\n"
+								"<passages count=\"006\" formatversion=\"20020620\">\n"
+								"    <wrong error>\n"
+								"</passages>";
+
+			TiXmlDocument docTest;
+			docTest.Parse( error );
+			XmlTest( "Error row", docTest.ErrorRow(), 3 );
+			XmlTest( "Error column", docTest.ErrorCol(), 17 );
+			//printf( "error=%d id='%s' row %d col%d\n", (int) doc.Error(), doc.ErrorDesc(), doc.ErrorRow()+1, doc.ErrorCol() + 1 );
+
+		}
+
+	#ifdef TIXML_USE_STL
+		{
+			//////////////////////////////////////////////////////
+			cout << "\n** Streaming. **\n";
+
+			// Round trip check: stream in, then stream back out to verify. The stream
+			// out has already been checked, above. We use the output
+
+			istringstream inputStringStream( outputStream.str() );
+			TiXmlDocument document0;
+
+			inputStringStream >> document0;
+
+			ostringstream outputStream0( ostringstream::out );
+			outputStream0 << document0;
+
+			XmlTest( "Stream round trip correct.",	string( demoEnd ).c_str(), 
+													outputStream0.str().c_str(), true );
+
+			std::string str;
+			str << document0;
+
+			XmlTest( "String printing correct.", string( demoEnd ).c_str(), 
+												 str.c_str(), true );
+		}
+	#endif
+	}
+
+	{
+		const char* str = "<doc attr0='1' attr1='2.0' attr2='foo' />";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlElement* ele = doc.FirstChildElement();
+
+		int iVal, result;
+		double dVal;
+
+		result = ele->QueryDoubleAttribute( "attr0", &dVal );
+		XmlTest( "Query attribute: int as double", result, TIXML_SUCCESS );
+		XmlTest( "Query attribute: int as double", (int)dVal, 1 );
+		result = ele->QueryDoubleAttribute( "attr1", &dVal );
+		XmlTest( "Query attribute: double as double", (int)dVal, 2 );
+		result = ele->QueryIntAttribute( "attr1", &iVal );
+		XmlTest( "Query attribute: double as int", result, TIXML_SUCCESS );
+		XmlTest( "Query attribute: double as int", iVal, 2 );
+		result = ele->QueryIntAttribute( "attr2", &iVal );
+		XmlTest( "Query attribute: not a number", result, TIXML_WRONG_TYPE );
+		result = ele->QueryIntAttribute( "bar", &iVal );
+		XmlTest( "Query attribute: does not exist", result, TIXML_NO_ATTRIBUTE );
+	}
+
+	{
+		const char* str = "<doc/>";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlElement* ele = doc.FirstChildElement();
+
+		int iVal;
+		double dVal;
+
+		ele->SetAttribute( "str", "strValue" );
+		ele->SetAttribute( "int", 1 );
+		ele->SetDoubleAttribute( "double", -1.0 );
+
+		const char* cStr = ele->Attribute( "str" );
+		ele->QueryIntAttribute( "int", &iVal );
+		ele->QueryDoubleAttribute( "double", &dVal );
+
+		XmlTest( "Attribute round trip. c-string.", "strValue", cStr );
+		XmlTest( "Attribute round trip. int.", 1, iVal );
+		XmlTest( "Attribute round trip. double.", -1, (int)dVal );
+	}
+	
+	{
+		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
+							"</room>";
+
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Parse( str );
+
+		TiXmlHandle docHandle( &doc );
+		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
+
+		assert( docHandle.Node() );
+		assert( roomHandle.Element() );
+
+		TiXmlElement* room = roomHandle.Element();
+		assert( room );
+		TiXmlAttribute* doors = room->FirstAttribute();
+		assert( doors );
+
+		XmlTest( "Location tracking: Tab 8: room row", room->Row(), 1 );
+		XmlTest( "Location tracking: Tab 8: room col", room->Column(), 49 );
+		XmlTest( "Location tracking: Tab 8: doors row", doors->Row(), 1 );
+		XmlTest( "Location tracking: Tab 8: doors col", doors->Column(), 55 );
+	}
+	
+	{
+		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
+							"  <!-- Silly example -->\n"
+							"    <door wall='north'>A great door!</door>\n"
+							"\t<door wall='east'/>"
+							"</room>";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlHandle docHandle( &doc );
+		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
+		TiXmlHandle commentHandle = docHandle.FirstChildElement( "room" ).FirstChild();
+		TiXmlHandle textHandle = docHandle.FirstChildElement( "room" ).ChildElement( "door", 0 ).FirstChild();
+		TiXmlHandle door0Handle = docHandle.FirstChildElement( "room" ).ChildElement( 0 );
+		TiXmlHandle door1Handle = docHandle.FirstChildElement( "room" ).ChildElement( 1 );
+
+		assert( docHandle.Node() );
+		assert( roomHandle.Element() );
+		assert( commentHandle.Node() );
+		assert( textHandle.Text() );
+		assert( door0Handle.Element() );
+		assert( door1Handle.Element() );
+
+		TiXmlDeclaration* declaration = doc.FirstChild()->ToDeclaration();
+		assert( declaration );
+		TiXmlElement* room = roomHandle.Element();
+		assert( room );
+		TiXmlAttribute* doors = room->FirstAttribute();
+		assert( doors );
+		TiXmlText* text = textHandle.Text();
+		TiXmlComment* comment = commentHandle.Node()->ToComment();
+		assert( comment );
+		TiXmlElement* door0 = door0Handle.Element();
+		TiXmlElement* door1 = door1Handle.Element();
+
+		XmlTest( "Location tracking: Declaration row", declaration->Row(), 1 );
+		XmlTest( "Location tracking: Declaration col", declaration->Column(), 5 );
+		XmlTest( "Location tracking: room row", room->Row(), 1 );
+		XmlTest( "Location tracking: room col", room->Column(), 45 );
+		XmlTest( "Location tracking: doors row", doors->Row(), 1 );
+		XmlTest( "Location tracking: doors col", doors->Column(), 51 );
+		XmlTest( "Location tracking: Comment row", comment->Row(), 2 );
+		XmlTest( "Location tracking: Comment col", comment->Column(), 3 );
+		XmlTest( "Location tracking: text row", text->Row(), 3 ); 
+		XmlTest( "Location tracking: text col", text->Column(), 24 );
+		XmlTest( "Location tracking: door0 row", door0->Row(), 3 );
+		XmlTest( "Location tracking: door0 col", door0->Column(), 5 );
+		XmlTest( "Location tracking: door1 row", door1->Row(), 4 );
+		XmlTest( "Location tracking: door1 col", door1->Column(), 5 );
+	}
+
+
+	// --------------------------------------------------------
+	// UTF-8 testing. It is important to test:
+	//	1. Making sure name, value, and text read correctly
+	//	2. Row, Col functionality
+	//	3. Correct output
+	// --------------------------------------------------------
+	printf ("\n** UTF-8 **\n");
+	{
+		TiXmlDocument doc( "utf8test.xml" );
+		doc.LoadFile();
+		if ( doc.Error() && doc.ErrorId() == TiXmlBase::TIXML_ERROR_OPENING_FILE ) {
+			printf( "WARNING: File 'utf8test.xml' not found.\n"
+					"(Are you running the test from the wrong directory?)\n"
+				    "Could not test UTF-8 functionality.\n" );
+		}
+		else
+		{
+			TiXmlHandle docH( &doc );
+			// Get the attribute "value" from the "Russian" element and check it.
+			TiXmlElement* element = docH.FirstChildElement( "document" ).FirstChildElement( "Russian" ).Element();
+			const unsigned char correctValue[] = {	0xd1U, 0x86U, 0xd0U, 0xb5U, 0xd0U, 0xbdU, 0xd0U, 0xbdU, 
+													0xd0U, 0xbeU, 0xd1U, 0x81U, 0xd1U, 0x82U, 0xd1U, 0x8cU, 0 };
+
+			XmlTest( "UTF-8: Russian value.", (const char*)correctValue, element->Attribute( "value" ), true );
+			XmlTest( "UTF-8: Russian value row.", 4, element->Row() );
+			XmlTest( "UTF-8: Russian value column.", 5, element->Column() );
+
+			const unsigned char russianElementName[] = {	0xd0U, 0xa0U, 0xd1U, 0x83U,
+															0xd1U, 0x81U, 0xd1U, 0x81U,
+															0xd0U, 0xbaU, 0xd0U, 0xb8U,
+															0xd0U, 0xb9U, 0 };
+			const char russianText[] = "<\xD0\xB8\xD0\xBC\xD0\xB5\xD0\xB5\xD1\x82>";
+
+			TiXmlText* text = docH.FirstChildElement( "document" ).FirstChildElement( (const char*) russianElementName ).Child( 0 ).Text();
+			XmlTest( "UTF-8: Browsing russian element name.",
+					 russianText,
+					 text->Value(),
+					 true );
+			XmlTest( "UTF-8: Russian element name row.", 7, text->Row() );
+			XmlTest( "UTF-8: Russian element name column.", 47, text->Column() );
+
+			TiXmlDeclaration* dec = docH.Child( 0 ).Node()->ToDeclaration();
+			XmlTest( "UTF-8: Declaration column.", 1, dec->Column() );
+			XmlTest( "UTF-8: Document column.", 1, doc.Column() );
+
+			// Now try for a round trip.
+			doc.SaveFile( "utf8testout.xml" );
+
+			// Check the round trip.
+			char savedBuf[256];
+			char verifyBuf[256];
+			int okay = 1;
+
+			FILE* saved  = fopen( "utf8testout.xml", "r" );
+			FILE* verify = fopen( "utf8testverify.xml", "r" );
+			if ( saved && verify )
+			{
+				while ( fgets( verifyBuf, 256, verify ) )
+				{
+					fgets( savedBuf, 256, saved );
+					if ( strcmp( verifyBuf, savedBuf ) )
+					{
+						okay = 0;
+						break;
+					}
+				}
+				fclose( saved );
+				fclose( verify );
+			}
+			XmlTest( "UTF-8: Verified multi-language round trip.", 1, okay );
+
+			// On most Western machines, this is an element that contains
+			// the word "resume" with the correct accents, in a latin encoding.
+			// It will be something else completely on non-wester machines,
+			// which is why TinyXml is switching to UTF-8.
+			const char latin[] = "<element>r\x82sum\x82</element>";
+
+			TiXmlDocument latinDoc;
+			latinDoc.Parse( latin, 0, TIXML_ENCODING_LEGACY );
+
+			text = latinDoc.FirstChildElement()->FirstChild()->ToText();
+			XmlTest( "Legacy encoding: Verify text element.", "r\x82sum\x82", text->Value() );
+		}
+	}		
+
+	//////////////////////
+	// Copy and assignment
+	//////////////////////
+	printf ("\n** Copy and Assignment **\n");
+	{
+		TiXmlElement element( "foo" );
+		element.Parse( "<element name='value' />", 0, TIXML_ENCODING_UNKNOWN );
+
+		TiXmlElement elementCopy( element );
+		TiXmlElement elementAssign( "foo" );
+		elementAssign.Parse( "<incorrect foo='bar'/>", 0, TIXML_ENCODING_UNKNOWN );
+		elementAssign = element;
+
+		XmlTest( "Copy/Assign: element copy #1.", "element", elementCopy.Value() );
+		XmlTest( "Copy/Assign: element copy #2.", "value", elementCopy.Attribute( "name" ) );
+		XmlTest( "Copy/Assign: element assign #1.", "element", elementAssign.Value() );
+		XmlTest( "Copy/Assign: element assign #2.", "value", elementAssign.Attribute( "name" ) );
+		XmlTest( "Copy/Assign: element assign #3.", true, ( 0 == elementAssign.Attribute( "foo" )) );
+
+		TiXmlComment comment;
+		comment.Parse( "<!--comment-->", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlComment commentCopy( comment );
+		TiXmlComment commentAssign;
+		commentAssign = commentCopy;
+		XmlTest( "Copy/Assign: comment copy.", "comment", commentCopy.Value() );
+		XmlTest( "Copy/Assign: comment assign.", "comment", commentAssign.Value() );
+
+		TiXmlUnknown unknown;
+		unknown.Parse( "<[unknown]>", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlUnknown unknownCopy( unknown );
+		TiXmlUnknown unknownAssign;
+		unknownAssign.Parse( "incorrect", 0, TIXML_ENCODING_UNKNOWN );
+		unknownAssign = unknownCopy;
+		XmlTest( "Copy/Assign: unknown copy.", "[unknown]", unknownCopy.Value() );
+		XmlTest( "Copy/Assign: unknown assign.", "[unknown]", unknownAssign.Value() );
+		
+		TiXmlText text( "TextNode" );
+		TiXmlText textCopy( text );
+		TiXmlText textAssign( "incorrect" );
+		textAssign = text;
+		XmlTest( "Copy/Assign: text copy.", "TextNode", textCopy.Value() );
+		XmlTest( "Copy/Assign: text assign.", "TextNode", textAssign.Value() );
+
+		TiXmlDeclaration dec;
+		dec.Parse( "<?xml version='1.0' encoding='UTF-8'?>", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlDeclaration decCopy( dec );
+		TiXmlDeclaration decAssign;
+		decAssign = dec;
+
+		XmlTest( "Copy/Assign: declaration copy.", "UTF-8", decCopy.Encoding() );
+		XmlTest( "Copy/Assign: text assign.", "UTF-8", decAssign.Encoding() );
+
+		TiXmlDocument doc;
+		elementCopy.InsertEndChild( textCopy );
+		doc.InsertEndChild( decAssign );
+		doc.InsertEndChild( elementCopy );
+		doc.InsertEndChild( unknownAssign );
+
+		TiXmlDocument docCopy( doc );
+		TiXmlDocument docAssign;
+		docAssign = docCopy;
+
+		#ifdef TIXML_USE_STL
+		std::string original, copy, assign;
+		original << doc;
+		copy << docCopy;
+		assign << docAssign;
+		XmlTest( "Copy/Assign: document copy.", original.c_str(), copy.c_str(), true );
+		XmlTest( "Copy/Assign: document assign.", original.c_str(), assign.c_str(), true );
+
+		#endif
+	}	
+
+	//////////////////////////////////////////////////////
+#ifdef TIXML_USE_STL
+	printf ("\n** Parsing, no Condense Whitespace **\n");
+	TiXmlBase::SetCondenseWhiteSpace( false );
+	{
+		istringstream parse1( "<start>This  is    \ntext</start>" );
+		TiXmlElement text1( "text" );
+		parse1 >> text1;
+
+		XmlTest ( "Condense white space OFF.", "This  is    \ntext",
+					text1.FirstChild()->Value(),
+					true );
+	}
+	TiXmlBase::SetCondenseWhiteSpace( true );
+#endif
+
+	//////////////////////////////////////////////////////
+	// GetText();
+	{
+		const char* str = "<foo>This is text</foo>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		const TiXmlElement* element = doc.RootElement();
+
+		XmlTest( "GetText() normal use.", "This is text", element->GetText() );
+
+		str = "<foo><b>This is text</b></foo>";
+		doc.Clear();
+		doc.Parse( str );
+		element = doc.RootElement();
+
+		XmlTest( "GetText() contained element.", element->GetText() == 0, true );
+
+		str = "<foo>This is <b>text</b></foo>";
+		doc.Clear();
+		TiXmlBase::SetCondenseWhiteSpace( false );
+		doc.Parse( str );
+		TiXmlBase::SetCondenseWhiteSpace( true );
+		element = doc.RootElement();
+
+		XmlTest( "GetText() partial.", "This is ", element->GetText() );
+	}
+
+
+	//////////////////////////////////////////////////////
+	// CDATA
+	{
+		const char* str =	"<xmlElement>"
+								"<![CDATA["
+									"I am > the rules!\n"
+									"...since I make symbolic puns"
+								"]]>"
+							"</xmlElement>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		doc.Print();
+
+		XmlTest( "CDATA parse.", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+
+		#ifdef TIXML_USE_STL
+		//cout << doc << '\n';
+
+		doc.Clear();
+
+		istringstream parse0( str );
+		parse0 >> doc;
+		//cout << doc << '\n';
+
+		XmlTest( "CDATA stream.", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+		#endif
+
+		TiXmlDocument doc1 = doc;
+		//doc.Print();
+
+		XmlTest( "CDATA copy.", doc1.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+	}
+	{
+		// [ 1482728 ] Wrong wide char parsing
+		char buf[256];
+		buf[255] = 0;
+		for( int i=0; i<255; ++i ) {
+			buf[i] = (char)((i>=32) ? i : 32);
+		}
+		TIXML_STRING str( "<xmlElement><![CDATA[" );
+		str += buf;
+		str += "]]></xmlElement>";
+
+		TiXmlDocument doc;
+		doc.Parse( str.c_str() );
+
+		TiXmlPrinter printer;
+		printer.SetStreamPrinting();
+		doc.Accept( &printer );
+
+		XmlTest( "CDATA with all bytes #1.", str.c_str(), printer.CStr(), true );
+
+		#ifdef TIXML_USE_STL
+		doc.Clear();
+		istringstream iss( printer.Str() );
+		iss >> doc;
+		std::string out;
+		out << doc;
+		XmlTest( "CDATA with all bytes #2.", out.c_str(), printer.CStr(), true );
+		#endif
+	}
+	{
+		// [ 1480107 ] Bug-fix for STL-streaming of CDATA that contains tags
+		// CDATA streaming had a couple of bugs, that this tests for.
+		const char* str =	"<xmlElement>"
+								"<![CDATA["
+									"<b>I am > the rules!</b>\n"
+									"...since I make symbolic puns"
+								"]]>"
+							"</xmlElement>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		doc.Print();
+
+		XmlTest( "CDATA parse. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+
+		#ifdef TIXML_USE_STL
+
+		doc.Clear();
+
+		istringstream parse0( str );
+		parse0 >> doc;
+
+		XmlTest( "CDATA stream. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+		#endif
+
+		TiXmlDocument doc1 = doc;
+		//doc.Print();
+
+		XmlTest( "CDATA copy. [ 1480107 ]", doc1.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+	}
+	//////////////////////////////////////////////////////
+	// Visit()
+
+
+
+	//////////////////////////////////////////////////////
+	printf( "\n** Fuzzing... **\n" );
+
+	const int FUZZ_ITERATION = 300;
+
+	// The only goal is not to crash on bad input.
+	int len = (int) strlen( demoStart );
+	for( int i=0; i<FUZZ_ITERATION; ++i ) 
+	{
+		char* demoCopy = new char[ len+1 ];
+		strcpy( demoCopy, demoStart );
+
+		demoCopy[ i%len ] = (char)((i+1)*3);
+		demoCopy[ (i*7)%len ] = '>';
+		demoCopy[ (i*11)%len ] = '<';
+
+		TiXmlDocument xml;
+		xml.Parse( demoCopy );
+
+		delete [] demoCopy;
+	}
+	printf( "** Fuzzing Complete. **\n" );
+	
+	//////////////////////////////////////////////////////
+	printf ("\n** Bug regression tests **\n");
+
+	// InsertBeforeChild and InsertAfterChild causes crash.
+	{
+		TiXmlElement parent( "Parent" );
+		TiXmlElement childText0( "childText0" );
+		TiXmlElement childText1( "childText1" );
+		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
+		TiXmlNode* childNode1 = parent.InsertBeforeChild( childNode0, childText1 );
+
+		XmlTest( "Test InsertBeforeChild on empty node.", ( childNode1 == parent.FirstChild() ), true );
+	}
+
+	{
+		// InsertBeforeChild and InsertAfterChild causes crash.
+		TiXmlElement parent( "Parent" );
+		TiXmlElement childText0( "childText0" );
+		TiXmlElement childText1( "childText1" );
+		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
+		TiXmlNode* childNode1 = parent.InsertAfterChild( childNode0, childText1 );
+
+		XmlTest( "Test InsertAfterChild on empty node. ", ( childNode1 == parent.LastChild() ), true );
+	}
+
+	// Reports of missing constructors, irregular string problems.
+	{
+		// Missing constructor implementation. No test -- just compiles.
+		TiXmlText text( "Missing" );
+
+		#ifdef TIXML_USE_STL
+			// Missing implementation:
+			TiXmlDocument doc;
+			string name = "missing";
+			doc.LoadFile( name );
+
+			TiXmlText textSTL( name );
+		#else
+			// verifying some basic string functions:
+			TiXmlString a;
+			TiXmlString b( "Hello" );
+			TiXmlString c( "ooga" );
+
+			c = " World!";
+			a = b;
+			a += c;
+			a = a;
+
+			XmlTest( "Basic TiXmlString test. ", "Hello World!", a.c_str() );
+		#endif
+ 	}
+
+	// Long filenames crashing STL version
+	{
+		TiXmlDocument doc( "midsummerNightsDreamWithAVeryLongFilenameToConfuseTheStringHandlingRoutines.xml" );
+		bool loadOkay = doc.LoadFile();
+		loadOkay = true;	// get rid of compiler warning.
+		// Won't pass on non-dev systems. Just a "no crash" check.
+		//XmlTest( "Long filename. ", true, loadOkay );
+	}
+
+	{
+		// Entities not being written correctly.
+		// From Lynn Allen
+
+		const char* passages =
+			"<?xml version=\"1.0\" standalone=\"no\" ?>"
+			"<passages count=\"006\" formatversion=\"20020620\">"
+				"<psg context=\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
+				" It also has &lt;, &gt;, and &amp;, as well as a fake copyright &#xA9;.\"> </psg>"
+			"</passages>";
+
+		TiXmlDocument doc( "passages.xml" );
+		doc.Parse( passages );
+		TiXmlElement* psg = doc.RootElement()->FirstChildElement();
+		const char* context = psg->Attribute( "context" );
+		const char* expected = "Line 5 has \"quotation marks\" and 'apostrophe marks'. It also has <, >, and &, as well as a fake copyright \xC2\xA9.";
+
+		XmlTest( "Entity transformation: read. ", expected, context, true );
+
+		FILE* textfile = fopen( "textfile.txt", "w" );
+		if ( textfile )
+		{
+			psg->Print( textfile, 0 );
+			fclose( textfile );
+		}
+		textfile = fopen( "textfile.txt", "r" );
+		assert( textfile );
+		if ( textfile )
+		{
+			char buf[ 1024 ];
+			fgets( buf, 1024, textfile );
+			XmlTest( "Entity transformation: write. ",
+					 "<psg context=\'Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
+					 " It also has &lt;, &gt;, and &amp;, as well as a fake copyright \xC2\xA9.' />",
+					 buf,
+					 true );
+		}
+		fclose( textfile );
+	}
+
+    {
+		FILE* textfile = fopen( "test5.xml", "w" );
+		if ( textfile )
+		{
+            fputs("<?xml version='1.0'?><a.elem xmi.version='2.0'/>", textfile);
+            fclose(textfile);
+
+			TiXmlDocument doc;
+            doc.LoadFile( "test5.xml" );
+            XmlTest( "dot in element attributes and names", doc.Error(), 0);
+		}
+    }
+
+	{
+		FILE* textfile = fopen( "test6.xml", "w" );
+		if ( textfile )
+		{
+            fputs("<element><Name>1.1 Start easy ignore fin thickness&#xA;</Name></element>", textfile );
+            fclose(textfile);
+
+            TiXmlDocument doc;
+            bool result = doc.LoadFile( "test6.xml" );
+            XmlTest( "Entity with one digit.", result, true );
+
+			TiXmlText* text = doc.FirstChildElement()->FirstChildElement()->FirstChild()->ToText();
+			XmlTest( "Entity with one digit.",
+						text->Value(), "1.1 Start easy ignore fin thickness\n" );
+		}
+    }
+
+	{
+		// DOCTYPE not preserved (950171)
+		// 
+		const char* doctype =
+			"<?xml version=\"1.0\" ?>"
+			"<!DOCTYPE PLAY SYSTEM 'play.dtd'>"
+			"<!ELEMENT title (#PCDATA)>"
+			"<!ELEMENT books (title,authors)>"
+			"<element />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		doc.SaveFile( "test7.xml" );
+		doc.Clear();
+		doc.LoadFile( "test7.xml" );
+		
+		TiXmlHandle docH( &doc );
+		TiXmlUnknown* unknown = docH.Child( 1 ).Unknown();
+		XmlTest( "Correct value of unknown.", "!DOCTYPE PLAY SYSTEM 'play.dtd'", unknown->Value() );
+		#ifdef TIXML_USE_STL
+		TiXmlNode* node = docH.Child( 2 ).Node();
+		std::string str;
+		str << (*node);
+		XmlTest( "Correct streaming of unknown.", "<!ELEMENT title (#PCDATA)>", str.c_str() );
+		#endif
+	}
+
+	{
+		// [ 791411 ] Formatting bug
+		// Comments do not stream out correctly.
+		const char* doctype = 
+			"<!-- Somewhat<evil> -->";
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+
+		TiXmlHandle docH( &doc );
+		TiXmlComment* comment = docH.Child( 0 ).Node()->ToComment();
+
+		XmlTest( "Comment formatting.", " Somewhat<evil> ", comment->Value() );
+		#ifdef TIXML_USE_STL
+		std::string str;
+		str << (*comment);
+		XmlTest( "Comment streaming.", "<!-- Somewhat<evil> -->", str.c_str() );
+		#endif
+	}
+
+	{
+		// [ 870502 ] White space issues
+		TiXmlDocument doc;
+		TiXmlText* text;
+		TiXmlHandle docH( &doc );
+	
+		const char* doctype0 = "<element> This has leading and trailing space </element>";
+		const char* doctype1 = "<element>This has  internal space</element>";
+		const char* doctype2 = "<element> This has leading, trailing, and  internal space </element>";
+
+		TiXmlBase::SetCondenseWhiteSpace( false );
+		doc.Clear();
+		doc.Parse( doctype0 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", " This has leading and trailing space ", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype1 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", "This has  internal space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype2 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", " This has leading, trailing, and  internal space ", text->Value() );
+
+		TiXmlBase::SetCondenseWhiteSpace( true );
+		doc.Clear();
+		doc.Parse( doctype0 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has leading and trailing space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype1 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has internal space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype2 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has leading, trailing, and internal space", text->Value() );
+	}
+
+	{
+		// Double attributes
+		const char* doctype = "<element attr='red' attr='blue' />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		
+		XmlTest( "Parsing repeated attributes.", true, doc.Error() );	// is an  error to tinyxml (didn't use to be, but caused issues)
+		//XmlTest( "Parsing repeated attributes.", "blue", doc.FirstChildElement( "element" )->Attribute( "attr" ) );
+	}
+
+	{
+		// Embedded null in stream.
+		const char* doctype = "<element att\0r='red' attr='blue' />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		XmlTest( "Embedded null throws error.", true, doc.Error() );
+
+		#ifdef TIXML_USE_STL
+		istringstream strm( doctype );
+		doc.Clear();
+		doc.ClearError();
+		strm >> doc;
+		XmlTest( "Embedded null throws error.", true, doc.Error() );
+		#endif
+	}
+
+    {
+            // Legacy mode test. (This test may only pass on a western system)
+            const char* str =
+                        "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"
+                        "<>"
+                        "Cntnt"
+                        "</>";
+
+            TiXmlDocument doc;
+            doc.Parse( str );
+
+            TiXmlHandle docHandle( &doc );
+            TiXmlHandle aHandle = docHandle.FirstChildElement( "" );
+            TiXmlHandle tHandle = aHandle.Child( 0 );
+            assert( aHandle.Element() );
+            assert( tHandle.Text() );
+            XmlTest( "ISO-8859-1 Parsing.", "Cntnt", tHandle.Text()->Value() );
+    }
+
+	{
+		// Empty documents should return TIXML_ERROR_PARSING_EMPTY, bug 1070717
+		const char* str = "    ";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		XmlTest( "Empty document error TIXML_ERROR_DOCUMENT_EMPTY", TiXmlBase::TIXML_ERROR_DOCUMENT_EMPTY, doc.ErrorId() );
+	}
+	#ifndef TIXML_USE_STL
+	{
+		// String equality. [ 1006409 ] string operator==/!= no worky in all cases
+		TiXmlString temp;
+		XmlTest( "Empty tinyxml string compare equal", ( temp == "" ), true );
+
+		TiXmlString    foo;
+		TiXmlString    bar( "" );
+		XmlTest( "Empty tinyxml string compare equal", ( foo == bar ), true );
+	}
+
+	#endif
+	{
+		// Bug [ 1195696 ] from marlonism
+		TiXmlBase::SetCondenseWhiteSpace(false); 
+		TiXmlDocument xml; 
+		xml.Parse("<text><break/>This hangs</text>"); 
+		XmlTest( "Test safe error return.", xml.Error(), false );
+	}
+
+	{
+		// Bug [ 1243992 ] - another infinite loop
+		TiXmlDocument doc;
+		doc.SetCondenseWhiteSpace(false);
+		doc.Parse("<p><pb></pb>test</p>");
+	} 
+	{
+		// Low entities
+		TiXmlDocument xml;
+		xml.Parse( "<test>&#x0e;</test>" );
+		const char result[] = { 0x0e, 0 };
+		XmlTest( "Low entities.", xml.FirstChildElement()->GetText(), result );
+		xml.Print();
+	}
+	{
+		// Bug [ 1451649 ] Attribute values with trailing quotes not handled correctly
+		TiXmlDocument xml;
+		xml.Parse( "<foo attribute=bar\" />" );
+		XmlTest( "Throw error with bad end quotes.", xml.Error(), true );
+	}
+	#ifdef TIXML_USE_STL
+	{
+		// Bug [ 1449463 ] Consider generic query
+		TiXmlDocument xml;
+		xml.Parse( "<foo bar='3' barStr='a string'/>" );
+
+		TiXmlElement* ele = xml.FirstChildElement();
+		double d;
+		int i;
+		float f;
+		bool b;
+		std::string str;
+
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &d ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &i ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &f ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &b ), TIXML_WRONG_TYPE );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "nobar", &b ), TIXML_NO_ATTRIBUTE );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "barStr", &str ), TIXML_SUCCESS );
+
+		XmlTest( "QueryValueAttribute", (d==3.0), true );
+		XmlTest( "QueryValueAttribute", (i==3), true );
+		XmlTest( "QueryValueAttribute", (f==3.0f), true );
+		XmlTest( "QueryValueAttribute", (str==std::string( "a string" )), true );
+	}
+	#endif
+
+	#ifdef TIXML_USE_STL
+	{
+		// [ 1505267 ] redundant malloc in TiXmlElement::Attribute
+		TiXmlDocument xml;
+		xml.Parse( "<foo bar='3' />" );
+		TiXmlElement* ele = xml.FirstChildElement();
+		double d;
+		int i;
+
+		std::string bar = "bar";
+
+		const std::string* atrrib = ele->Attribute( bar );
+		ele->Attribute( bar, &d );
+		ele->Attribute( bar, &i );
+
+		XmlTest( "Attribute", atrrib->empty(), false );
+		XmlTest( "Attribute", (d==3.0), true );
+		XmlTest( "Attribute", (i==3), true );
+	}
+	#endif
+
+	{
+		// [ 1356059 ] Allow TiXMLDocument to only be at the top level
+		TiXmlDocument xml, xml2;
+		xml.InsertEndChild( xml2 );
+		XmlTest( "Document only at top level.", xml.Error(), true );
+		XmlTest( "Document only at top level.", xml.ErrorId(), TiXmlBase::TIXML_ERROR_DOCUMENT_TOP_ONLY );
+	}
+
+	{
+		// [ 1663758 ] Failure to report error on bad XML
+		TiXmlDocument xml;
+		xml.Parse("<x>");
+		XmlTest("Missing end tag at end of input", xml.Error(), true);
+		xml.Parse("<x> ");
+		XmlTest("Missing end tag with trailing whitespace", xml.Error(), true);
+	} 
+
+	{
+		// [ 1635701 ] fail to parse files with a tag separated into two lines
+		// I'm not sure this is a bug. Marked 'pending' for feedback.
+		TiXmlDocument xml;
+		xml.Parse( "<title><p>text</p\n><title>" );
+		//xml.Print();
+		//XmlTest( "Tag split by newline", xml.Error(), false );
+	}
+
+	#ifdef TIXML_USE_STL
+	{
+		// [ 1475201 ] TinyXML parses entities in comments
+		TiXmlDocument xml;
+		istringstream parse1( "<!-- declarations for <head> & <body> -->"
+						      "<!-- far &amp; away -->" );
+		parse1 >> xml;
+
+		TiXmlNode* e0 = xml.FirstChild();
+		TiXmlNode* e1 = e0->NextSibling();
+		TiXmlComment* c0 = e0->ToComment();
+		TiXmlComment* c1 = e1->ToComment();
+
+		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
+		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
+	}
+	#endif
+
+	{
+		// [ 1475201 ] TinyXML parses entities in comments
+		TiXmlDocument xml;
+		xml.Parse("<!-- declarations for <head> & <body> -->"
+				  "<!-- far &amp; away -->" );
+
+		TiXmlNode* e0 = xml.FirstChild();
+		TiXmlNode* e1 = e0->NextSibling();
+		TiXmlComment* c0 = e0->ToComment();
+		TiXmlComment* c1 = e1->ToComment();
+
+		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
+		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
+	}
+
+	{
+		TiXmlDocument xml;
+		xml.Parse( "<Parent>"
+						"<child1 att=''/>"
+						"<!-- With this comment, child2 will not be parsed! -->"
+						"<child2 att=''/>"
+					"</Parent>" );
+		int count = 0;
+
+		TiXmlNode* ele = 0;
+		while ( (ele = xml.FirstChildElement( "Parent" )->IterateChildren( ele ) ) != 0 ) {
+			++count;
+		}
+		XmlTest( "Comments iterate correctly.", 3, count );
+	}
+
+	{
+		// trying to repro ]1874301]. If it doesn't go into an infinite loop, all is well.
+		unsigned char buf[] = "<?xml version=\"1.0\" encoding=\"utf-8\"?><feed><![CDATA[Test XMLblablablalblbl";
+		buf[60] = 239;
+		buf[61] = 0;
+
+		TiXmlDocument doc;
+		doc.Parse( (const char*)buf);
+	} 
+
+
+	{
+		// bug 1827248 Error while parsing a little bit malformed file
+		// Actually not malformed - should work.
+		TiXmlDocument xml;
+		xml.Parse( "<attributelist> </attributelist >" );
+		XmlTest( "Handle end tag whitespace", false, xml.Error() );
+	}
+
+	{
+		// 1709904 - can not repro the crash
+		{
+			TiXmlDocument xml;
+			xml.Parse( "<tag>/</tag>" );
+			XmlTest( "Odd XML parsing.", xml.FirstChild()->Value(), "tag" );
+		}
+		/* Could not repro. {
+			TiXmlDocument xml;
+			xml.LoadFile( "EQUI_Inventory.xml" );
+			//XmlTest( "Odd XML parsing.", xml.FirstChildElement()->Value(), "XML" );
+			TiXmlPrinter printer;
+			xml.Accept( &printer );
+			fprintf( stdout, "%s", printer.CStr() );
+		}*/
+	}
+
+	/*  1417717 experiment
+	{
+		TiXmlDocument xml;
+		xml.Parse("<text>Dan & Tracie</text>");
+		xml.Print(stdout);
+	}
+	{
+		TiXmlDocument xml;
+		xml.Parse("<text>Dan &foo; Tracie</text>");
+		xml.Print(stdout);
+	}
+	*/
+	#if defined( WIN32 ) && defined( TUNE )
+	_CrtMemCheckpoint( &endMemState );
+	//_CrtMemDumpStatistics( &endMemState );
+
+	_CrtMemState diffMemState;
+	_CrtMemDifference( &diffMemState, &startMemState, &endMemState );
+	_CrtMemDumpStatistics( &diffMemState );
+	#endif
+
+	printf ("\nPass %d, Fail %d\n", gPass, gFail);
+	return gFail;
+}
diff -urN vdr-2.0.1/tinyxml.c vdr-2.0.1.reel/tinyxml.c
--- vdr-2.0.1/tinyxml.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml.c	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,1427 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include <ctype.h>
+#include "tinyxml.h"
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#endif
+
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_OSTREAM* stream )
+{
+	TIXML_STRING buffer;
+	PutString( str, &buffer );
+	(*stream) << buffer;
+}
+
+void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&'
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+			sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			outString->append( buf, strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+
+// <-- Strange class for a bug fix. Search for STL_STRING_BUG
+TiXmlBase::StringToBuffer::StringToBuffer( const TIXML_STRING& str )
+{
+	buffer = new char[ str.length()+1 ];
+	if ( buffer )
+	{
+		strcpy( buffer, str.c_str() );
+	}
+}
+
+
+TiXmlBase::StringToBuffer::~StringToBuffer()
+{
+	delete [] buffer;
+}
+// End strange bug fix. -->
+
+
+TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
+{
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData;
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{
+	if ( !beforeThis || beforeThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( replaceThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( removeThis->parent != this )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( node->SValue() == TIXML_STRING( _value ))
+			return node;
+	}
+	return 0;
+}
+
+TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( node->SValue() == TIXML_STRING (_value))
+			return node;
+	}
+	return 0;
+}
+
+TiXmlNode* TiXmlNode::IterateChildren( TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+TiXmlNode* TiXmlNode::IterateChildren( const char * val, TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( node->SValue() == TIXML_STRING (_value))
+			return node;
+	}
+	return 0;
+}
+
+
+TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( node->SValue() == TIXML_STRING (_value))
+			return node;
+	}
+	return 0;
+}
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	TiXmlNode* node;
+
+	for (	node = NextSibling();
+	node;
+	node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+	node;
+	node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+
+TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value )
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char * TiXmlElement::Attribute( const char * name ) const
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+
+	if ( node )
+		return node->Value();
+
+	return 0;
+}
+
+
+const char * TiXmlElement::Attribute( const char * name, int* i ) const
+{
+	const char * s = Attribute( name );
+	if ( i )
+	{
+		if ( s )
+			*i = atoi( s );
+		else
+			*i = 0;
+	}
+	return s;
+}
+
+
+const char * TiXmlElement::Attribute( const char * name, double* d ) const
+{
+	const char * s = Attribute( name );
+	if ( d )
+	{
+		if ( s )
+			*d = atof( s );
+		else
+			*d = 0;
+	}
+	return s;
+}
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+
+	return node->QueryIntValue( ival );
+}
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+
+	return node->QueryDoubleValue( dval );
+}
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{
+	char buf[64];
+	sprintf( buf, "%d", val );
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{
+	char buf[128];
+	sprintf( buf, "%f", val );
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetAttribute( const char * name, const char * _value )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	for ( i=0; i<depth; i++ )
+	{
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i )
+		fprintf( cfile, "    " );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+void TiXmlElement::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<" << value;
+
+	TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		(*stream) << " ";
+		attrib->StreamOut( stream );
+	}
+
+	// If this node has children, give it a closing tag. Else
+	// make it an empty tag.
+	TiXmlNode* node;
+	if ( firstChild )
+	{
+		(*stream) << ">";
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			node->StreamOut( stream );
+		}
+		(*stream) << "</" << value << ">";
+	}
+	else
+	{
+		(*stream) << " />";
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class:
+	// Clone the attributes, then clone the children.
+	TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	// See STL_STRING_BUG below.
+	StringToBuffer buf( value );
+
+	if ( buf.buffer && LoadFile( buf.buffer, encoding ) )
+		return true;
+
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	// See STL_STRING_BUG below.
+	StringToBuffer buf( value );
+
+	if ( buf.buffer && SaveFile( buf.buffer ) )
+		return true;
+
+	return false;
+}
+
+bool TiXmlDocument::LoadFile( const char* filename, TiXmlEncoding encoding )
+{
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// There was a really terrifying little bug here. The code:
+	//		value = filename
+	// in the STL case, cause the assignment method of the std::string to
+	// be called. What is strange, is that the std::string had the same
+	// address as it's c_str() method, and so bad things happen. Looks
+	// like a bug in the Microsoft STL implementation.
+	// See STL_STRING_BUG above.
+	// Fixed with the StringToBuffer class.
+	value = filename;
+
+	FILE* file = fopen( value.c_str (), "r" );
+
+	if ( file )
+	{
+		// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+		long length = 0;
+		fseek( file, 0, SEEK_END );
+		length = ftell( file );
+		fseek( file, 0, SEEK_SET );
+
+		// Strange case, but good to handle up front.
+		if ( length == 0 )
+		{
+			fclose( file );
+			return false;
+		}
+
+		// If we have a file, assume it is all one big XML file, and read it in.
+		// The document parser may decide the document ends sooner than the entire file, however.
+		TIXML_STRING data;
+		data.reserve( length );
+
+		const int BUF_SIZE = 2048;
+		char buf[BUF_SIZE];
+
+		while( fgets( buf, BUF_SIZE, file ) )
+		{
+			data += buf;
+		}
+		fclose( file );
+
+		Parse( data.c_str(), 0, encoding );
+
+		if (  Error() )
+            return false;
+        else
+			return true;
+	}
+	SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+	return false;
+}
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = fopen( filename, "w" );
+	if ( fp )
+	{
+		Print( fp, 0 );
+		fclose( fp );
+		return true;
+	}
+	return false;
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorDesc = errorDesc.c_str ();
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	TiXmlNode* node;
+	for ( node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+void TiXmlDocument::StreamOut( TIXML_OSTREAM * out ) const
+{
+	TiXmlNode* node;
+	for ( node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->StreamOut( out );
+
+		// Special rule for streams: stop after the root element.
+		// The stream in code will only read one element, so don't
+		// write more than one.
+		if ( node->ToElement() )
+			break;
+	}
+}
+
+
+TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+
+TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/ ) const
+{
+	TIXML_STRING n, v;
+
+	PutString( name, &n );
+	PutString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos)
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+	else
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+}
+
+
+void TiXmlAttribute::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	if (value.find( '\"' ) != TIXML_STRING::npos)
+	{
+		PutString( name, stream );
+		(*stream) << "=" << "'";
+		PutString( value, stream );
+		(*stream) << "'";
+	}
+	else
+	{
+		PutString( name, stream );
+		(*stream) << "=" << "\"";
+		PutString( value, stream );
+		(*stream) << "\"";
+	}
+}
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( sscanf( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( sscanf( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	sprintf (buf, "%d", _value);
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [64];
+	sprintf (buf, "%lf", _value);
+	SetValue (buf);
+}
+
+const int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+const double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+	{
+		fputs( "    ", cfile );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+void TiXmlComment::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<!--";
+	//PutString( value, stream );
+	(*stream) << value;
+	(*stream) << "-->";
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int /*depth*/ ) const
+{
+	TIXML_STRING buffer;
+	PutString( value, &buffer );
+	fprintf( cfile, "%s", buffer.c_str() );
+}
+
+
+void TiXmlText::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	PutString( value, stream );
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/ ) const
+{
+	fprintf (cfile, "<?xml ");
+
+	if ( !version.empty() )
+		fprintf (cfile, "version=\"%s\" ", version.c_str ());
+	if ( !encoding.empty() )
+		fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+	if ( !standalone.empty() )
+		fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+	fprintf (cfile, "?>");
+}
+
+void TiXmlDeclaration::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<?xml ";
+
+	if ( !version.empty() )
+	{
+		(*stream) << "version=\"";
+		PutString( version, stream );
+		(*stream) << "\" ";
+	}
+	if ( !encoding.empty() )
+	{
+		(*stream) << "encoding=\"";
+		PutString( encoding, stream );
+		(*stream ) << "\" ";
+	}
+	if ( !standalone.empty() )
+	{
+		(*stream) << "standalone=\"";
+		PutString( standalone, stream );
+		(*stream) << "\" ";
+	}
+	(*stream) << "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<" << value << ">";		// Don't use entities here! It is unknown.
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+TiXmlAttribute*	TiXmlAttributeSet::Find( const char * name ) const
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+TIXML_ISTREAM & operator >> (TIXML_ISTREAM & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+TIXML_OSTREAM & operator<< (TIXML_OSTREAM & out, const TiXmlNode & base)
+{
+	base.StreamOut (& out);
+	return out;
+}
+
+
+#ifdef TIXML_USE_STL
+std::string & operator<< (std::string& out, const TiXmlNode& base )
+{
+   std::ostringstream os_stream( std::ostringstream::out );
+   base.StreamOut( &os_stream );
+
+   out.append( os_stream.str() );
+   return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
diff -urN vdr-2.0.1/tinyxmlerror.c vdr-2.0.1.reel/tinyxmlerror.c
--- vdr-2.0.1/tinyxmlerror.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxmlerror.c	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,51 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// latin-1, but at least the error messages could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Memory allocation failed.",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+};
diff -urN vdr-2.0.1/tinyxml.h vdr-2.0.1.reel/tinyxml.h
--- vdr-2.0.1/tinyxml.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxml.h	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,1370 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#if defined( DEBUG ) && defined( _MSC_VER )
+#include <windows.h>
+#define TIXML_LOG OutputDebugString
+#else
+#define TIXML_LOG printf
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#define TIXML_STRING	std::string
+	#define TIXML_ISTREAM	std::istream
+	#define TIXML_OSTREAM	std::ostream
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING	TiXmlString
+	#define TIXML_OSTREAM	TiXmlOutStream
+#endif
+
+class TiXmlDocument;
+class TiXmlElement;
+class TiXmlComment;
+class TiXmlUnknown;
+class TiXmlAttribute;
+class TiXmlText;
+class TiXmlDeclaration;
+class TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 3;
+const int TIXML_PATCH_VERSION = 2;
+
+/*	Internal structure for tracking location of items
+	in the XML file.
+*/
+struct TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+// Only used by Attribute::Query functions
+enum
+{
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+class TiXmlBase
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0) {}
+	virtual ~TiXmlBase()					{}
+
+	/**	All TinyXml classes can print themselves to a filestream.
+		This is a formatted print, and will insert tabs and newlines.
+
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		values is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }
+	void* GetUserData()						{ return userData; }
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p,
+								TiXmlParsingData* data,
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+protected:
+
+	// See STL_STRING_BUG
+	// Utility class to overcome a bug.
+	class StringToBuffer
+	{
+	  public:
+		StringToBuffer( const TIXML_STRING& str );
+		~StringToBuffer();
+		char* buffer;
+	};
+
+	static const char*	SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+	inline static bool	IsWhiteSpace( char c )
+	{
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' );
+	}
+
+	virtual void StreamOut (TIXML_OSTREAM *) const = 0;
+
+	#ifdef TIXML_USE_STL
+	    static bool	StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	    static bool StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			strncpy( _value, p, *length );
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Puts a string to a stream, expanding entities as it goes.
+	// Note this should not contian the '<', '>', etc, or they will be transformed into entities!
+	static void PutString( const TIXML_STRING& str, TIXML_OSTREAM* out );
+
+	static void PutString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to Engilish words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_OUT_OF_MEMORY,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#else
+	    // Used internally, not part of the public API.
+	    friend TIXML_OSTREAM& operator<< (TIXML_OSTREAM& out, const TiXmlNode& base);
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		DOCUMENT,
+		ELEMENT,
+		COMMENT,
+		UNKNOWN,
+		TEXT,
+		DECLARATION,
+		TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char * Value() const { return value.c_str (); }
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )
+	{
+		StringToBuffer buf( _value );
+		SetValue( buf.buffer ? buf.buffer : "" );
+	}
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent() const					{ return parent; }
+
+	TiXmlNode* FirstChild()	const	{ return firstChild; }		///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+
+	TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+
+    #ifdef TIXML_USE_STL
+	TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value ) const		{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	TiXmlNode* IterateChildren( TiXmlNode* previous ) const;
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	TiXmlNode* IterateChildren( const char * value, TiXmlNode* previous ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlNode* IterateChildren( const std::string& _value, TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	TiXmlNode* PreviousSibling() const			{ return prev; }
+
+	/// Navigate to a sibling node.
+	TiXmlNode* PreviousSibling( const char * ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	TiXmlNode* NextSibling() const				{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	TiXmlNode* NextSibling( const char * ) const;
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	TiXmlElement* NextSiblingElement() const;
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	TiXmlElement* NextSiblingElement( const char * ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	TiXmlElement* FirstChildElement()	const;
+
+	/// Convenience function to get through elements.
+	TiXmlElement* FirstChildElement( const char * value ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	virtual int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	TiXmlDocument* GetDocument() const;
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	TiXmlDocument* ToDocument()	const		{ return ( this && type == DOCUMENT ) ? (TiXmlDocument*) this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlElement*  ToElement() const		{ return ( this && type == ELEMENT  ) ? (TiXmlElement*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlComment*  ToComment() const		{ return ( this && type == COMMENT  ) ? (TiXmlComment*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlUnknown*  ToUnknown() const		{ return ( this && type == UNKNOWN  ) ? (TiXmlUnknown*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlText*	   ToText()    const		{ return ( this && type == TEXT     ) ? (TiXmlText*)     this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlDeclaration* ToDeclaration() const	{ return ( this && type == DECLARATION ) ? (TiXmlDeclaration*) this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller.
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	    virtual void StreamIn( TIXML_ISTREAM* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	// Internal Value function returning a TIXML_STRING
+	const TIXML_STRING& SValue() const	{ return value ; }
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str (); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str (); }		///< Return the value of this attribute.
+	const int       IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	const double	DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int value );										///< Set the value from an integer.
+	void SetDoubleValue( double value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )
+	{
+		StringToBuffer buf( _name );
+		SetName ( buf.buffer ? buf.buffer : "error" );
+	}
+	/// STL std::string form.
+	void SetValue( const std::string& _value )
+	{
+		StringToBuffer buf( _value );
+		SetValue( buf.buffer ? buf.buffer : "error" );
+	}
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	TiXmlAttribute* Next() const;
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	TiXmlAttribute* Previous() const;
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	TiXmlAttribute* First() const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* Last()  const	{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute*	Find( const char * name ) const;
+
+private:
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/
+	int QueryIntAttribute( const char* name, int* value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* value ) const;
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * value );
+
+    #ifdef TIXML_USE_STL
+	const char* Attribute( const std::string& name ) const				{ return Attribute( name.c_str() ); }
+	const char* Attribute( const std::string& name, int* i ) const		{ return Attribute( name.c_str(), i ); }
+	const char* Attribute( const std::string& name, double* d ) const	{ return Attribute( name.c_str(), d ); }
+	int QueryIntAttribute( const std::string& name, int* value ) const	{ return QueryIntAttribute( name.c_str(), value ); }
+	int QueryDoubleAttribute( const std::string& name, double* value ) const { return QueryDoubleAttribute( name.c_str(), value ); }
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value )
+	{
+		StringToBuffer n( name );
+		StringToBuffer v( _value );
+		if ( n.buffer && v.buffer )
+			SetAttribute (n.buffer, v.buffer );
+	}
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value )
+	{
+		StringToBuffer n( name );
+		if ( n.buffer )
+			SetAttribute (n.buffer, _value);
+	}
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	/// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. Contained in an element.
+*/
+class TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/// Constructor.
+	TiXmlText (const char * initValue) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	/// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	virtual void StreamOut ( TIXML_OSTREAM * out ) const;
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+
+private:
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	/// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut ( TIXML_OSTREAM * out) const;
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	/// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut ( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+		StringToBuffer f( filename );
+		return ( f.buffer && LoadFile( f.buffer, encoding ));
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+		StringToBuffer f( filename );
+		return ( f.buffer && SaveFile( f.buffer ));
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	const int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1,
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow()	{ return errorLocation.row+1; }
+	int ErrorCol()	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false;
+												errorId = 0;
+												errorDesc = "";
+												errorLocation.row = errorLocation.col = 0;
+												//errorLocation.last = 0;
+											}
+
+	/** Dump the document to standard out. */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+protected :
+	virtual void StreamOut ( TIXML_OSTREAM * out) const;
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).Element();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0;
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).Element();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is
+	a linear walk to find the element, so this code would iterate much more than it needs
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).Element();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* node )					{ this->node = node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name.
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child.
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name.
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element.
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/// Return the handle as a TiXmlNode. This may return null.
+	TiXmlNode* Node() const			{ return node; }
+	/// Return the handle as a TiXmlElement. This may return null.
+	TiXmlElement* Element() const	{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/// Return the handle as a TiXmlText. This may return null.
+	TiXmlText* Text() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/// Return the handle as a TiXmlUnknown. This may return null;
+	TiXmlUnknown* Unknown() const			{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+#endif
diff -urN vdr-2.0.1/tinyxmlparser.c vdr-2.0.1.reel/tinyxmlparser.c
--- vdr-2.0.1/tinyxmlparser.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/tinyxmlparser.c	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,1492 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+#include <ctype.h>
+
+//#define DEBUG_PARSER
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] =
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf
+
+
+
+const int TiXmlBase::utf8ByteTable[256] =
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80)
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	// Scary scary fall throughs.
+	switch (*length)
+	{
+		case 4:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+		case 3:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+		case 2:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+		case 1:
+			--output;
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding encoding )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*p) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case (char)(0xef):
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(p+1)==(char)(0xbb) && *(p+2)==(char)(0xbf) )
+							p += 3;
+						else if ( *(p+1)==(char)(0xbf) && *(p+2)==(char)(0xbe) )
+							p += 3;
+						else if ( *(p+1)==(char)(0xbf) && *(p+2)==(char)(0xbf) )
+							p += 3;
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(p+0)==(char) 0xef
+				 && *(p+1)==(char) 0xbb
+				 && *(p+2)==(char) 0xbf )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(p+0)==(char) 0xef
+				 && *(p+1)==(char) 0xbf
+				 && *(p+2)==(char) 0xbe )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(p+0)==(char) 0xef
+				 && *(p+1)==(char) 0xbf
+				 && *(p+2)==(char) 0xbf )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( *p && IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding )
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			(*name) += *p;
+			++p;
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		unsigned delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p,
+									TIXML_STRING * text,
+									bool trimWhiteSpace,
+									const char* endTag,
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	return p + strlen( endTag );
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) )
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		if (	*(p+0) && *(p+0) == (char)(0xef)
+			 && *(p+1) && *(p+1) == (char)(0xbb)
+			 && *(p+2) && *(p+2) == (char)(0xbf) )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		//TiXmlParsingData data( pError, prevData );
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	TiXmlDocument* doc = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing?
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+
+	if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	else
+	{
+		if ( doc )
+			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (TIXML_ISTREAM * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>'
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' )
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+	endTag += ">";
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p )
+				return 0;
+
+			// We should find the end tag now
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				return p;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			const char* pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			if ( node )
+			{
+				node->SetValue( attrib->Value() );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	const char* pWithWhiteSpace = p;
+	// Read in text and elements in any order.
+	p = SkipWhiteSpace( p, encoding );
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
+				    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		}
+		else
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag?
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>'
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+	p = ReadText( p, &value, false, endTag, false, encoding );
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+	int tabsize = 4;
+	if ( document )
+		tabsize = document->TabSize();
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	const char* end;
+
+	if ( *p == '\'' )
+	{
+		++p;
+		end = "\'";
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == '"' )
+	{
+		++p;
+		end = "\"";
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p										// existence
+				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
+				&& *p != '/' && *p != '>' )						// tag end
+		{
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == '<' )
+			return;
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	bool ignoreWhite = true;
+
+	const char* end = "<";
+	p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+	if ( p )
+		return p-1;	// don't truncate the '<'
+	return 0;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
diff -urN vdr-2.0.1/vdr.5 vdr-2.0.1.reel/vdr.5
--- vdr-2.0.1/vdr.5	2013-03-29 11:25:56.000000000 +0100
+++ vdr-2.0.1.reel/vdr.5	2013-05-09 18:10:01.663874319 +0200
@@ -240,6 +240,12 @@
 
 .B ...:201;2001=deu,2002=eng:...
 
+Manual teletext subtitling pages can be defined separated by a '+' sign.
+The pages (separated by commas) can contain language codes, delimited by a '='
+sign, as in
+
+.B ...:201+150=deu,151=fin;2001,2002:...
+
 .TP
 .B Conditional access
 A hexadecimal integer defining how this channel can be accessed:
diff -urN vdr-2.0.1/vdr.c vdr-2.0.1.reel/vdr.c
--- vdr-2.0.1/vdr.c	2013-03-15 11:44:54.000000000 +0100
+++ vdr-2.0.1.reel/vdr.c	2013-05-09 18:10:01.663874319 +0200
@@ -44,7 +44,9 @@
 #include "diseqc.h"
 #include "dvbdevice.h"
 #include "eitscan.h"
+#include "debug.h"
 #include "epg.h"
+#include "filetransfer.h"
 #include "i18n.h"
 #include "interface.h"
 #include "keys.h"
@@ -65,6 +67,7 @@
 #include "tools.h"
 #include "transfer.h"
 #include "videodir.h"
+#include "status.h"
 
 #define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
 #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
@@ -85,6 +88,24 @@
 
 #define EXIT(v) { ShutdownHandler.Exit(v); goto Exit; }
 
+#ifdef USEMYSQL
+int ForceReloadDB = 0;
+int DBCounter = 0;
+int lastDBCounter = 0;
+#endif /* USEMYSQL */
+
+#ifdef REELVDR
+eOSState LastMenuMainFunc = osEnd;
+int lastReelboxModeTemp = eModeStandalone;
+
+#ifdef RBMINI
+bool isNetClient = true;
+#else
+bool isNetClient = false;
+#endif
+#endif
+
+
 static int LastSignal = 0;
 
 static bool SetUser(const char *UserName, bool UserDump)
@@ -655,6 +676,9 @@
   bool InhibitEpgScan = false;
   bool IsInfoMenu = false;
   cSkin *CurrentSkin = NULL;
+#ifdef USEMYSQL
+  bool loadSuccess = true;
+#endif
 
   // Load plugins:
 
@@ -675,14 +699,40 @@
   cPlugin::SetResourceDirectory(ResourceDirectory);
   cThemes::SetThemesDirectory(AddDirectory(ConfigDirectory, "themes"));
 
-  // Configuration data:
+  Setup.Load(AddDirectory(ConfigDirectory, "setup.conf"));
+#ifdef REELVDR
+  if (Setup.ReelboxMode == eModeClient)
+      Setup.ReelboxModeTemp = eModeStandalone;
+  else
+      Setup.ReelboxModeTemp = Setup.ReelboxMode;
+#endif
 
   Setup.Load(AddDirectory(ConfigDirectory, "setup.conf"));
   Sources.Load(AddDirectory(ConfigDirectory, "sources.conf"), true, true);
   Diseqcs.Load(AddDirectory(ConfigDirectory, "diseqc.conf"), true, Setup.DiSEqC);
   Scrs.Load(AddDirectory(ConfigDirectory, "scr.conf"), true);
   Channels.Load(AddDirectory(ConfigDirectory, "channels.conf"), false, true);
-  Timers.Load(AddDirectory(ConfigDirectory, "timers.conf"));
+
+#ifdef USEMYSQL
+  if ((Setup.ReelboxMode == eModeClient) || (Setup.ReelboxMode == eModeServer))
+  {
+      if (Setup.ReelboxMode == eModeServer) {
+          loadSuccess = Timers.LoadDB() && loadSuccess;
+          Timers.ClearAllRecordingFlags(); //so that all interrupted recordings are started
+      }
+      else
+          loadSuccess = Timers.Load() && loadSuccess;
+      //Timers.SetFilename(AddDirectory(ConfigDirectory, "timers.conf"));
+  }
+  else
+  {
+      loadSuccess = Timers.Load(AddDirectory(ConfigDirectory, "timers.conf")) && loadSuccess;
+      SystemExec("avahi-publish-avg-mysql.sh -2"); // -2 means kill avahi-publish
+  }
+#else
+  loadSuccess = Timers.Load(AddDirectory(ConfigDirectory, "timers.conf")) && loadSuccess;
+#endif
+
   Commands.Load(AddDirectory(ConfigDirectory, "commands.conf"));
   RecordingCommands.Load(AddDirectory(ConfigDirectory, "reccmds.conf"));
   SVDRPhosts.Load(AddDirectory(ConfigDirectory, "svdrphosts.conf"), true);
@@ -844,6 +894,65 @@
 #ifdef DEBUGRINGBUFFERS
         cRingBufferLinear::PrintDebugRBL();
 #endif
+
+#if USEMYSQL
+        if (Setup.ReelboxMode == eModeClient)
+        {
+            //printf("rbModeTemp %i rbm: %i dbc: %i\n", Setup.ReelboxModeTemp, Setup.ReelboxMode, DBCounter);
+            // If MultiRoom is en-/disabled do some actions here
+            if (lastReelboxModeTemp != Setup.ReelboxModeTemp) {
+                printf("rbmt: %i rbm: %i dbc: %i\n", Setup.ReelboxModeTemp, Setup.ReelboxMode, DBCounter);
+                if (Setup.ReelboxModeTemp != eModeStandalone) {
+
+                    // load timers
+                    printf("calling cTimers::LoadDB\n");
+                    Timers.Load(); // Clear old datas
+                    Timers.LoadDB();
+                    Timers.SetModified();
+                    DLOG("activating MultiRoom");
+
+                    // load data of every plugins, which works with MySQL
+                    cPluginManager::CallAllServices("Avahi MySQL enable", NULL);
+                    lastReelboxModeTemp = Setup.ReelboxMode;
+
+                    //TouchFile(UpdateFileName());
+                    Recordings.TouchUpdate();
+                    //Recordings.Update();
+                } else {
+                    // disable MySQL on Client
+                    Timers.Load(); // Clear Timers
+                    Timers.SetModified();
+                    DLOG("deactivating MultiRoom");
+                    cPluginManager::CallAllServices("Avahi MySQL disable", NULL);
+                    lastReelboxModeTemp = eModeStandalone;
+                    //Recordings.StopScan();
+                    Recordings.Clear();
+                    //Recordings.TouchUpdate();
+                    //Recordings.Update();
+                }
+            }
+
+            if (ForceReloadDB)
+            {
+                // Reload datas
+                Timers.Load(); // Clear old datas
+                Timers.LoadDB();
+                Timers.SetModified();
+                DLOG("forced reload of database");
+                // load data of every plugins, which works with MySQL
+                cPluginManager::CallAllServices("Avahi MySQL enable", NULL);
+                ForceReloadDB = 0;
+            }
+            else if (DBCounter != lastDBCounter && Setup.ReelboxModeTemp != eModeStandalone)
+            {
+                // Sync datas if DBCounter changed
+                Timers.SyncData();
+                cPluginManager::CallAllServices("Avahi MySQL sync", NULL); // Tell all plugins MySQL got new datas/modifications
+                DLOG("syncing database");
+                lastDBCounter = DBCounter;
+            }
+        }
+#endif
         // Attach launched player control:
         cControl::Attach();
 
@@ -932,6 +1041,14 @@
            PreviousChannel[PreviousChannelIndex ^= 1] = LastChannel;
         // Timers and Recordings:
         if (!Timers.BeingEdited()) {
+#if USEMYSQL
+        // If using MySQL then sync Data
+          if (Setup.ReelboxModeTemp == eModeServer)
+              Timers.SyncData();
+
+          if (Setup.ReelboxModeTemp != eModeClient) // Clients don't do timer-actions
+          {
+#endif
            // Assign events to timers:
            Timers.SetEvents();
            // Must do all following calls with the exact same time!
@@ -1001,10 +1118,28 @@
            // Delete expired timers:
            Timers.DeleteExpired();
            }
+#if USEMYSQL
+        }
+#endif
         if (!Menu && Recordings.NeedsUpdate()) {
            Recordings.Update();
            DeletedRecordings.Update();
            }
+#ifdef USE_MCLI
+        cPlugin *mcliPlugin = cPluginManager::GetPlugin("mcli");
+        if (mcliPlugin) {
+           if (!ShutdownHandler.countdown) { // if kPower has been pressed, cMenuShutdown takes precedence over other menus
+              cOsdObject *MyMenu = mcliPlugin->AltMenuAction();
+              if (MyMenu) { // is there any cam-menu waiting?
+                 DELETE_MENU;
+                 if (cControl::Control())
+                    cControl::Control()->Hide();
+                    Menu = MyMenu;
+                    Menu->Show();
+                 }
+              }
+           }
+#endif /* MCLI */
         // CAM control:
         if (!Menu && !cOsd::IsOpen())
            Menu = CamControl();
@@ -1015,6 +1150,7 @@
         cOsdObject *Interact = Menu ? Menu : cControl::Control();
         eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
         if (ISREALKEY(key)) {
+           cStatus::MsgUserAction(key, Interact);
            EITScanner.Activity();
            // Cancel shutdown countdown:
            if (ShutdownHandler.countdown)
@@ -1025,6 +1161,7 @@
         // Keys that must work independent of any interactive mode:
         switch (int(key)) {
           // Menu control:
+#ifndef REELVDR
           case kMenu: {
                key = kNone; // nobody else needs to see this key
                bool WasOpen = Interact != NULL;
@@ -1065,13 +1202,130 @@
                   }
                }
                break;
+#endif /* !REELVDR */
+
+#ifdef REELVDR
           // Direct main menu functions:
+
+
+          #define DirectMainFunction(function)                         \
+                  {                                                    \
+                     if(Menu)                                          \
+                       DELETE_MENU;                                    \
+                     else                                              \
+                       LastMenuMainFunc = osEnd;                       \
+                     if (cControl::Control())                          \
+                        cControl::Control()->Hide();                   \
+                     if (LastMenuMainFunc != function)  \
+                     {                                                 \
+                        LastMenuMainFunc = function;                   \
+                        CREATE_MENU_MAIN(function,Menu);               \
+                     }                                                 \
+                  }                                                    \
+                  key = kNone; // nobody else needs to see this key
+
+            // kMultimedia
+          case kMultimedia: {
+            cPlugin *p = cPluginManager::GetPlugin("setup");
+            static const char* multimedia = "Multimedia";
+            if (p)
+            {
+                // close any open menu
+                if(Menu)
+                    DELETE_MENU;
+
+                p->Service("link", (void*) multimedia );
+                key = kNone; // nobody else needs to see this key
+
+                cRemote::CallPlugin("setup");
+            }
+          }
+            break;
+
+          // Info:
+          case kInfo: {
+            // handle kInfo
+            // show channel information when live TV and livebuffer
+            // show recording information when replaying recordings
+            // shows channellist options (Not here, see code below) when
+            //   channellist osd (Menu!=NULL) is open
+
+            if (IsInfoMenu) {
+                key = kNone; // nobody else needs to see this key
+                DELETE_MENU;
+                IsInfoMenu=false;
+                }
+            else if (!Menu) {
+
+                if (cControl::Control()
+      #ifdef USE_LIVEBUFFER
+                        && cRecordControls::GetLiveIndex(cReplayControl::NowReplaying()) == NULL /*not live buffer*/
+      #endif
+                        ) {
+                    IsInfoMenu = true;
+
+                   cControl::Control()->Hide();
+                   Menu = cControl::Control()->GetInfo();
+
+                   if (Menu)
+                      Menu->Show();
+                   else
+                      IsInfoMenu = false;
+                   }
+                else {
+                    /* //XXX why show EPG ?
+                    cRemote::Put(kOk, true);
+                    cRemote::Put(kSchedule, true);
+                    */
+                    if ((Setup.WantChListOnOk && (key == kOk)) ||
+                        (!Setup.WantChListOnOk && (key == kInfo))) {
+                        DirectMainFunction(osChannels);
+                    } else
+                        LastChannel = -1;
+                   }
+                key = kNone; // nobody else needs to see this key
+            }
+          }
+          break;
+
+          case kMenu: {
+               key = kNone; // nobody else needs to see this key
+               bool WasOpen = Interact != NULL;
+               bool WasMenu = Interact && Interact->IsMenu();
+               if (Menu)
+                  DELETE_MENU;
+               else if (cControl::Control()) {
+                  if (cOsd::IsOpen())
+                     cControl::Control()->Hide();
+                  else
+                     WasOpen = false;
+                  }
+               if (!WasOpen || !WasMenu )//&& !Setup.MenuKeyCloses)
+                   //Menu = new cMenuMain;
+                   DirectMainFunction(osUnknown);
+               }
+               break;
+          case kSearch:     DirectMainFunction(osSearchtimers); break;
+          case kHelp:       DirectMainFunction(osActiveEvent);  break;
+          case kAddFavorite:
+          case k2digit:     DirectMainFunction(osAddFavourite); break;
+          case kFavourites: DirectMainFunction(osFavourites); break;
+              continue;
+          // Aspect ratio
+          case kAspect:
+              ::Setup.VideoFormat == 0 ? ::Setup.VideoFormat=1: ::Setup.VideoFormat=0;
+              cDevice::PrimaryDevice()->SetVideoFormat(::Setup.VideoFormat);
+              key = kNone;
+              break;
+         // case kEject:      Eject(); key = kNone; break;
+#else
           #define DirectMainFunction(function)\
-            { DELETE_MENU;\
+            DELETE_MENU;\
             if (cControl::Control())\
                cControl::Control()->Hide();\
             Menu = new cMenuMain(function);\
-            key = kNone; } // nobody else needs to see this key
+            key = kNone; // nobody else needs to see this key
+#endif /* REELVDR */
           case kSchedule:   DirectMainFunction(osSchedule); break;
           case kChannels:   DirectMainFunction(osChannels); break;
           case kTimers:     DirectMainFunction(osTimers); break;
@@ -1087,10 +1341,12 @@
                      cControl::Control()->Hide();
                   cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
                   if (plugin) {
+                  if (!cStatus::MsgPluginProtected(plugin)) {
                      Menu = plugin->MainMenuAction();
                      if (Menu)
                         Menu->Show();
                      }
+                     }
                   else
                      esyslog("ERROR: unknown plugin '%s'", PluginName);
                   }
@@ -1303,11 +1559,47 @@
              // Instant resume of the last viewed recording:
              case kPlay:
                   if (cReplayControl::LastReplayed()) {
+                     if (cStatus::MsgReplayProtected(0, cReplayControl::LastReplayed(), 0, false) == false) {  // PIN PATCH
                      cControl::Shutdown();
                      cControl::Launch(new cReplayControl);
                      }
+                     }
+#ifdef USEMYSQL
+                  if(Setup.ReelboxModeTemp == eModeClient)
+                  {
+                      std::vector<cTimer*> InstantRecording;
+                      Timers.GetInstantRecordings(&InstantRecording);
+                      if(InstantRecording.size())
+                      {
+                          cTimer *Timer = InstantRecording.at(InstantRecording.size()-1);
+                          if(Timer)
+                          {
+                              char *buffer;
+                              asprintf(&buffer,"%s \"%s\"?",tr("End recording"),Timer->Channel()->Name());
+                              if (Interface->Confirm(buffer))
+                                  Timers.Del(Timer);
+                              free(buffer);
+                          }
+                      }
+                  }
                   else
-                     DirectMainFunction(osRecordings); // no last viewed recording, so enter the Recordings menu
+#endif /*USEMYSQL*/
+                  {
+                  const char *s = NULL;
+                  const char *last = NULL;
+                  while ((s = cRecordControls::GetInstantId(s)) != NULL) {
+                      if(s)
+                        last = s;
+                  }
+                  if(last) {
+                     char *buffer;
+                     asprintf(&buffer,"%s \"%s\"?",tr("End recording"),last);
+                     if (Interface->Confirm(buffer)) {
+                        cRecordControls::Stop(last);
+                        }
+                     free(buffer);
+                     }
+                  }
                   break;
              default:    break;
              }
@@ -1321,6 +1613,12 @@
               else
                  Skins.Message(mtInfo, tr("Editing process finished"));
               }
+           if (!cFileTransfer::Active() && cFileTransfer::Ended()) {
+              if (cFileTransfer::Error())
+                 Skins.Message(mtError, tr("File transfer failed!"));
+              else
+                 Skins.Message(mtInfo, tr("File transfer finished"));
+              }
            }
 
         // SIGHUP shall cause a restart:
@@ -1336,7 +1634,7 @@
               ShutdownHandler.countdown.Cancel();
            }
 
-        if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
+        if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !cFileTransfer::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
            // Handle housekeeping tasks
 
            // Shutdown:
@@ -1385,6 +1683,7 @@
 
   PluginManager.StopPlugins();
   cRecordControls::Shutdown();
+  cFileTransfer::Stop();
   cCutter::Stop();
   delete Menu;
   cControl::Shutdown();
diff -urN vdr-2.0.1/vdrmysql.c vdr-2.0.1.reel/vdrmysql.c
--- vdr-2.0.1/vdrmysql.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/vdrmysql.c	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,1235 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Reel Multimedia;  Author:  Florian Erfurth      *
+ *                                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ ***************************************************************************
+ *
+ * vdrmysql.c
+ *
+ ***************************************************************************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <iostream>
+#include <fstream>
+#include <iomanip>
+#include <sstream>
+
+#include "thread.h"
+#include "vdrmysql.h"
+#include "status.h"
+#include "menu.h"
+
+#define MYSQL_TEMPLATE_PATH "/usr/share/reel/mysql/"
+#define MYSQL_VDRDB_TEMPLATE "vdr-db.sql"
+#define MYSQL_TIMERDB_TEMPLATE "timer-db.sql"
+#define MYSQL_TIMERSEARCHDB_TEMPLATE "timer-search.sql"
+
+static int AvahiLastEventID = -1;
+static cMutex SetLastEventIDMutex;
+
+char* GetIpAddress()
+{
+    int sock_fd = socket( AF_INET , SOCK_DGRAM , 0 );
+    if( sock_fd != -1 )
+    {
+        struct ifreq ifr;
+        strcpy(ifr.ifr_name, "eth0");
+        if(ioctl(sock_fd, SIOCGIFADDR, &ifr) != -1)
+        {
+            char *IpAddress = inet_ntoa( ((struct sockaddr_in *) (&ifr.ifr_addr))->sin_addr );
+            close( sock_fd );
+            return IpAddress;
+        }
+        else
+            esyslog("ERROR (%s,%d): Problem with ioctl", __FILE__, __LINE__);
+    }
+    else
+        esyslog("ERROR (%s,%d): Creating Socket failed", __FILE__, __LINE__);
+    return NULL;
+}
+
+//#########################################################################
+// class cVdrMysql
+//#########################################################################
+cVdrMysql::cVdrMysql(const char *Username, const char *Password, const char *Database)
+{
+    Server_ = NULL;
+    Username_ = strdup(Username);
+    Password_ = Password?strdup(Password):NULL;
+    Database_ = Database?strdup(Database):NULL;
+}
+
+cVdrMysql::~cVdrMysql()
+{
+    if(Server_)
+        free(Server_);
+    if(Username_)
+        free(Username_);
+    if(Password_)
+        free(Password_);
+    if(Database_)
+        free(Database_);
+}
+
+bool cVdrMysql::SetServer(const char *Server)
+{
+    if(Server == NULL)
+        return false;
+    else
+        free(Server_);
+
+    Server_ = strdup(Server);
+
+    // Test
+    MYSQL *Connection = mysql_init(NULL);
+    if(Connection)
+    {
+        if(ConnectDB(Connection))
+        {
+            DisconnectDB(Connection);
+            return true; // Server valid
+        }
+        else
+        {
+            free(Connection);
+            return false; // Connection failed
+        }
+    }
+    return false;
+};
+
+bool cVdrMysql::ConnectDB(MYSQL *Connection)
+{
+    if(!Server_)
+        return false; // no Server entered
+    mysql_options(Connection, MYSQL_OPT_CONNECT_TIMEOUT, "5");
+    if(!mysql_real_connect(Connection, Server_, Username_, Password_, Database_, 0, NULL, 0)) {
+        esyslog("Failed to connect to database: Error: %s\n", mysql_error(Connection));
+        return false; // Connection failed
+    } else
+        return true;
+}
+
+void cVdrMysql::DisconnectDB(MYSQL *Connection)
+{
+    mysql_close(Connection);
+}
+
+int cVdrMysql::GetLastEventID(int *id)
+{
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+
+    if (Connection == NULL)
+        return -1;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return -1; // Connection failed
+    }
+
+    int res = mysql_query(Connection, "SELECT MAX(id) FROM vdr_event");
+    if(res != 0) { // error
+        *id = 0;
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return res;
+    }
+
+    Result = mysql_store_result(Connection);
+
+    if(Result)
+    {
+        if((Row = mysql_fetch_row(Result)) != NULL)
+        {
+            if(Row[0])
+                *id = atoi(Row[0]);
+        }
+    }
+
+    mysql_free_result(Result);
+    DisconnectDB(Connection);
+
+    return 0;
+}
+
+void cVdrMysql::SetLastEventID(int LastEventID, bool force)
+{
+    cMutexLock MutexLock(&SetLastEventIDMutex);
+    if(force || (AvahiLastEventID != LastEventID))
+    {
+        char command[128];
+        snprintf(command, 128, "avahi-publish-avg-mysql.sh %i", LastEventID);
+        if(SystemExec(command))
+        {
+            esyslog("Error: couldn't publish avg-mysql.service in avahi");
+            AvahiLastEventID = -1;
+        }
+        else
+            AvahiLastEventID = LastEventID;
+    }
+
+// This didn't work reliable:
+// If this service is updated too often(?), avahi-daemon(?) won't publish it for a while.
+// => NetClients thinks AVG is not available => MultiRoom disabled :(
+#if 0
+    if(AvahiLastEventID != LastEventID)
+    {
+        std::ofstream file("/etc/avahi/services/reel-avg-mysql.service");
+        if(file.is_open())
+        {
+            file << "<?xml version=\"1.0\" standalone='no'?>" << std::endl;
+            file << "<service-group>" << std::endl;
+            file << "   <name replace-wildcards=\"yes\">%h</name>" << std::endl;
+            file << "   <service protocol=\"ipv4\">" << std::endl;
+            file << "      <type>_reelboxMySQL._tcp</type>" << std::endl;
+            file << "      <txt-record>lasteventid=" << LastEventID << "</txt-record>" << std::endl;
+            file << "   </service>" << std::endl;
+            file << "</service-group>" << std::endl;
+            file.close();
+            AvahiLastEventID = LastEventID;
+        } else
+            esyslog("Error: couldn't open \"/etc/avahi/services/reel-avg-mysql.service\"");
+    }
+#endif
+}
+
+//#########################################################################
+// class cVdrMysqlAdmin
+//#########################################################################
+
+cVdrMysqlAdmin::cVdrMysqlAdmin(const char *Username, const char *Password, const char *Database) : cVdrMysql(Username, Password, Database)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+}
+
+cVdrMysqlAdmin::~cVdrMysqlAdmin()
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+}
+
+bool cVdrMysqlAdmin::InitDatabase(bool RecreateDB, const char *NewDatabase)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    std::stringstream Query;
+    MYSQL *Connection = mysql_init(NULL);
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false;
+    }
+
+    if(RecreateDB && cVdrMysql::Database_)
+    {
+        // Delete database
+        Query << "DROP DATABASE IF EXISTS " << cVdrMysql::Database_; 
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;93m " << __FILE__ << '(' << __LINE__ << "): " << Query.str() << " \033[0m" << std::endl;
+#endif
+        int res = mysql_query(Connection, Query.str().c_str());
+        if (res != 0) {
+            esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+            return false;
+        }
+
+        Query.str("");
+    }
+
+    if(NewDatabase)
+    {
+        if(cVdrMysql::Database_)
+            free(cVdrMysql::Database_);
+        cVdrMysql::Database_ = strdup(NewDatabase);
+    }
+
+    if(cVdrMysql::Database_)
+    {
+        // Create database
+        Query << "CREATE DATABASE " << cVdrMysql::Database_;
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;93m " << __FILE__ << '(' << __LINE__ << "): " << Query.str() << " \033[0m" << std::endl;
+#endif
+        int res = mysql_query(Connection, Query.str().c_str());
+        if (res != 0) {
+            esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+            esyslog("%s (%s:%d) mysql error: %u '%s'",
+                    __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                    mysql_errno(Connection),
+                    mysql_error(Connection));
+            DisconnectDB(Connection);
+            return false;
+        }
+
+        Query.str("");
+    }
+
+    if(!cVdrMysql::Password_)
+    {
+        // Set password for root
+        Query << "SET PASSWORD = PASSWORD('" << MYSQLADMINPWD << "')";
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;93m " << __FILE__ << '(' << __LINE__ << "): " << Query.str() << " \033[0m" << std::endl;
+#endif
+        int res = mysql_query(Connection, Query.str().c_str());
+        if (res != 0) {
+            esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+            return false;
+        }
+
+    }
+
+    // Create tables from templates
+    GenerateTableFromTemplate(Connection, MYSQL_VDRDB_TEMPLATE);
+    GenerateTableFromTemplate(Connection, MYSQL_TIMERDB_TEMPLATE);
+    GenerateTableFromTemplate(Connection, MYSQL_TIMERSEARCHDB_TEMPLATE);
+
+    return true;
+}
+
+void cVdrMysqlAdmin::GenerateTableFromTemplate(MYSQL *Connection, const char *filename)
+{
+    std::string strBuff;
+    std::stringstream fullfilename;
+    std::ifstream file;
+
+    fullfilename << MYSQL_TEMPLATE_PATH << filename;
+    file.open(fullfilename.str().c_str());
+    if(file.is_open()) {
+        while ( file.good() ) {
+            getline(file, strBuff);
+            if(strBuff.length()) {
+                int res = mysql_query(Connection, strBuff.c_str());
+                if (res != 0) {
+                    esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+                }
+
+            }
+#ifdef MYSQL_DEBUG
+            std::cout << "\033[0;93m " << __FILE__ << '(' << __LINE__ << "): " << strBuff <<"\033[0m" << std::endl;
+#endif
+        }
+        file.close();
+    }
+}
+
+bool cVdrMysqlAdmin::CreateAccount()
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    bool retValue = false;
+    MYSQL *Connection = mysql_init(NULL);
+    if(ConnectDB(Connection))
+    {
+        int res = mysql_query(Connection, "GRANT ALL PRIVILEGES on vdr.* to 'reeluser'@'%' IDENTIFIED BY 'reeluser'");
+        if (res)
+            esyslog("%s(%i) ERROR: Grant 'reeluser'@'%%' => Database Error %i\n", __FILE__, __LINE__, res);
+
+        // TODO: Find a way to detect missing grants '%' and 'localhost' seperately and split up this function
+        int res2 = mysql_query(Connection, "GRANT ALL PRIVILEGES on vdr.* to 'reeluser'@'localhost' IDENTIFIED BY 'reeluser'");
+        if (res2)
+            esyslog("%s(%i) ERROR: Grant 'reeluser'@'localhost' => Database Error %i\n", __FILE__, __LINE__, res2);
+
+        // If one of both was successful, then return true since one of both grant may already exists and works
+        if((res==0) || (res2==0))
+            retValue = true;
+
+        DisconnectDB(Connection);
+    }
+    else
+        free(Connection);
+    return retValue;
+}
+
+bool cVdrMysqlAdmin::CreateTables()
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    bool retValue = true;
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+
+    if(ConnectDB(Connection))
+    {
+        std::vector<std::string> Queries;
+        bool CreateTable_vdr_event = true;
+        bool CreateTable_timer = true;
+        bool CreateTable_timer_search = true;
+
+        // First checks, which tables already exist
+        if(!mysql_query(Connection, "SHOW TABLES"))
+        {
+            Result = mysql_store_result(Connection);
+            if(Result)
+            {
+                while((Row=mysql_fetch_row(Result)) != NULL)
+                {
+                    if(!strcmp(Row[0], "vdr_event"))
+                        CreateTable_vdr_event = false;
+                    else if(!strcmp(Row[0], "timer"))
+                        CreateTable_timer = false;
+                    else if(!strcmp(Row[0], "timer_search"))
+                        CreateTable_timer_search = false;
+                }
+                mysql_free_result(Result);
+            }
+        }
+        else
+            retValue = false;
+
+        if(CreateTable_vdr_event)
+        {
+            Queries.push_back("CREATE TABLE vdr_event (id INT NOT NULL AUTO_INCREMENT, timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, object_id INT NOT NULL, table_name VARCHAR(16) NOT NULL, action VARCHAR(16) NOT NULL, PRIMARY KEY(id))");
+        }
+        if(CreateTable_timer)
+        {
+            Queries.push_back("CREATE TABLE timer (id INT NOT NULL AUTO_INCREMENT, flags TINYINT UNSIGNED, channel VARCHAR(128), date VARCHAR(64), start VARCHAR(4), stop VARCHAR(4), priority TINYINT, lifetime TINYINT, file VARCHAR(256), aux VARCHAR(512), ip VARCHAR(16), PRIMARY KEY(id))");
+            Queries.push_back("CREATE TRIGGER insert_timer AFTER INSERT ON timer FOR EACH ROW INSERT INTO vdr_event (object_id, table_name, action) VALUES (NEW.id, 'timer', 'insert')");
+            Queries.push_back("CREATE TRIGGER update_timer AFTER UPDATE ON timer FOR EACH ROW INSERT INTO vdr_event (object_id, table_name, action) VALUES (OLD.id, 'timer', 'update')");
+            Queries.push_back("CREATE TRIGGER delete_timer AFTER DELETE ON timer FOR EACH ROW INSERT INTO vdr_event (object_id, table_name, action) VALUES (OLD.id, 'timer', 'delete')");
+        }
+        if(CreateTable_timer_search)
+        {
+            Queries.push_back("CREATE TABLE timer_search (id INT NOT NULL, search VARCHAR(256), useTime TINYINT, startTime VARCHAR(4), stopTime VARCHAR(4), useChannel TINYINT, ChannelGroup VARCHAR(256), useCase TINYINT, mode TINYINT, useTitle TINYINT, useSubtitle TINYINT, useDescription TINYINT, useDuration TINYINT, minDuration VARCHAR(4), maxDuration VARCHAR(4), useAsSearchTimer TINYINT, useDayOfWeek TINYINT, DayOfWeek TINYINT, useEpisode TINYINT, directory VARCHAR(512), Priority TINYINT UNSIGNED, Lifetime TINYINT UNSIGNED, MarginStart SMALLINT, MarginStop SMALLINT, useVPS TINYINT, action TINYINT, useExtEPGInfo TINYINT, ExtEPGInfo VARCHAR(512), avoidRepeats TINYINT, allowedRepeats TINYINT, compareTitle TINYINT, compareSubtitle TINYINT, compareSummary TINYINT, catvaluesAvoidRepeat INT UNSIGNED, repeatsWithinDays TINYINT, delAfterDays TINYINT, recordingsKeep TINYINT, switchMinsBefore TINYINT, pauseOnNrRecordings TINYINT, blacklistMode TINYINT, blacklists VARCHAR(512), fuzzyTolerance TINYINT, useInFavorites TINYINT, menuTemplate TINYINT, delMode TINYINT, delAfterCountRecs SMALLINT, delAfterDaysOfFirstRec SMALLINT, useAsSearchTimerFrom INT, useAsSearchTimerTil INT, ignoreMissingEPGCats TINYINT, unmuteSoundOnSwitch TINYINT, PRIMARY KEY(id))");
+            Queries.push_back("CREATE TRIGGER insert_timer_search AFTER INSERT ON timer_search FOR EACH ROW INSERT INTO vdr_event (object_id, table_name, action) VALUES (NEW.id, 'timer_search', 'insert')");
+            Queries.push_back("CREATE TRIGGER update_timer_search AFTER UPDATE ON timer_search FOR EACH ROW INSERT INTO vdr_event (object_id, table_name, action) VALUES (OLD.id, 'timer_search', 'update')");
+            Queries.push_back("CREATE TRIGGER delete_timer_search AFTER DELETE ON timer_search FOR EACH ROW INSERT INTO vdr_event (object_id, table_name, action) VALUES (OLD.id, 'timer_search', 'delete')");
+        }
+
+        unsigned int i = 0;
+        while(retValue && (i < Queries.size()))
+        {
+            //PRINTF("\033[0;93m %s(%i): Query(%i) - %s \033[0m\n", __FILE__, __LINE__, i, Queries.at(i).c_str());
+            int res = mysql_query(Connection, Queries.at(i).c_str());
+            if(res)
+            {
+                retValue = false;
+                esyslog("%s(%i) ERROR: Database Error: %s\n", __FILE__, __LINE__, Queries.at(i).c_str());
+            }
+            ++i;
+        }
+        DisconnectDB(Connection);
+    }
+    else
+    {
+        retValue = false;
+        free(Connection);
+    }
+    return retValue;
+}
+
+bool cVdrMysqlAdmin::ClearEvents()
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    char Query[] = "DELETE FROM vdr_event";
+    MYSQL *Connection = mysql_init(NULL);
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false;
+    }
+
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m " << __FILE__ << '(' << __LINE__ << "): " << Query << " \033[0m" << std::endl;
+#endif
+    int res = mysql_query(Connection, Query);
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    SetLastEventID(0, true);
+
+    return true;
+}
+
+bool cVdrMysqlAdmin::TestTables() {
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    static const char *tables[] = { "vdr_event", "timer", "timer_search" };
+    for(unsigned int i=0; i < sizeof(tables)/sizeof(const char*); i++) {
+
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;41m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+
+        std::stringstream Query;
+        Query << "DESCRIBE " << tables[i];
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+        int res = mysql_query(Connection, Query.str().c_str());
+        if (res != 0) {
+            esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        }
+
+        Result = mysql_store_result(Connection);
+
+        if(Result) {
+            while((Row=mysql_fetch_row(Result)) != NULL) {
+                unsigned int numRes = mysql_num_fields(Result);
+                if(numRes == 0) {
+                    esyslog("%s(%i) ERROR: Database Error mysql_num_fields() returned 0", __FILE__, __LINE__);
+                    esyslog("%s (%s:%d) mysql error: %u '%s'",
+                            __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                            mysql_errno(Connection),
+                            mysql_error(Connection));
+                    DisconnectDB(Connection);
+                    return false;
+                }
+            }
+            mysql_free_result(Result);
+        } else {
+            DisconnectDB(Connection);
+            SetLastEventID(-1);
+            return false;
+        }
+    }
+    DisconnectDB(Connection);
+
+    return true;
+}
+
+bool cVdrMysqlAdmin::TestPermission()
+{
+    bool retValue = false;
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+
+    if(Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection))
+    {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    int res = mysql_query(Connection, "SHOW GRANTS FOR CURRENT_USER()");
+    if(res!=0)
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+
+    Result = mysql_store_result(Connection);
+    if(Result)
+    {
+        while((Row=mysql_fetch_row(Result)) != NULL)
+        {
+            //PRINTF("\033[0;93m %s(%i): %s \033[0m\n", __FILE__, __LINE__, Row[0]);
+            if(strstr(Row[0], "GRANT ALL PRIVILEGES ON `vdr`.* TO"))
+                retValue = true; // needed Permission found
+        }
+        mysql_free_result(Result);
+    }
+
+    DisconnectDB(Connection);
+    return retValue;    
+}
+
+//#########################################################################
+// class cTimersMysql
+//#########################################################################
+
+cTimersMysql::cTimersMysql(const char *Username, const char *Password, const char *Database) : cVdrMysql(Username, Password, Database), Table_("timer")
+{
+}
+
+cTimersMysql::~cTimersMysql()
+{
+}
+
+bool cTimersMysql::InsertTimer(cTimer *timer)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;101m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+    std::stringstream Query;
+    char *EscapedFile=NULL;
+    char *EscapedAux=NULL;
+
+    if(Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    // Get local IP-Adress
+    char* IpAddress = NULL;
+#ifdef RBMINI
+    IpAddress = GetIpAddress();
+#endif
+
+    // First escape strings
+    EscapedFile = (char*)malloc((strlen(timer->File())*2+1)*sizeof(char));
+    mysql_real_escape_string(Connection, EscapedFile, timer->File(), strlen(timer->File()));
+    if(timer->Aux()) {
+        EscapedAux = (char*)malloc((strlen(timer->Aux())*2+1)*sizeof(char));
+        mysql_real_escape_string(Connection, EscapedAux, timer->Aux(), strlen(timer->Aux()));
+    }
+    Query << "INSERT INTO " << Table_ << " (flags, channel, date, start, stop, priority, lifetime, file, aux, ip) VALUES ( ";
+    Query << timer->Flags();
+    Query << ", '" << *timer->Channel()->GetChannelID().ToString(); 
+    Query << "', '" << *(timer->PrintDay(timer->Day(), timer->WeekDays(), true));
+    Query << "', '" << std::setw(4) << std::setfill('0') << timer->Start(); 
+    Query << "', '" << std::setw(4) << std::setfill('0') << timer->Stop();
+    Query << "', " << timer->Priority();
+    Query << ", " << timer->Lifetime();
+    Query << ", '" << EscapedFile << "', '";
+    if(EscapedAux)
+        Query << EscapedAux;
+    if(IpAddress)
+        Query << "', '" << IpAddress << "')";
+    else
+        Query << "', '(null)')";
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    int res =mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i (%s)\n", __FILE__, __LINE__, res, Query.str().c_str());
+    }
+    Query.str(""); // Clear Query-string
+
+    Query << "SELECT id FROM " << Table_ << " WHERE flags=" << timer->Flags();
+    Query << " AND channel='" << *timer->Channel()->GetChannelID().ToString();
+    Query << "' AND date='" << *(timer->PrintDay(timer->Day(), timer->WeekDays(), true));
+    Query << "' AND start='" << std::setw(4) << std::setfill('0') << timer->Start();
+    Query << "' AND stop='" << std::setw(4) << std::setfill('0') << timer->Stop();
+    Query << "' AND priority=" << timer->Priority(); 
+    Query << " AND lifetime=" << timer->Lifetime();
+    Query << " AND file='" << EscapedFile << "' AND aux='";
+    if(EscapedAux)
+        Query << EscapedAux;
+    if(IpAddress)
+        Query << "' AND ip='" << IpAddress << '\'';
+    else
+        Query << "' AND ip='(null)'";
+    //std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+    res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i (%s)\n", __FILE__, __LINE__, res, Query.str().c_str());
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    Result = mysql_store_result(Connection);
+    if(Result) {
+        if((Row=mysql_fetch_row(Result)) != NULL)
+            timer->SetID(atoi(Row[0]));
+    } else {
+        esyslog("ERROR (%s,%d): %s - \"%s\"", __FILE__, __LINE__, "Could not insert Timer into DB!", timer->File());
+    }
+                      
+    if(EscapedFile)
+        free(EscapedFile);
+    if(EscapedAux)
+        free(EscapedAux);
+    mysql_free_result(Result);
+    DisconnectDB(Connection);
+    return true;
+}
+
+bool cTimersMysql::DeleteTimer(unsigned int ID)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;101m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    MYSQL *Connection = mysql_init(NULL);
+    std::stringstream Query;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    Query << "DELETE FROM " << Table_ << " WHERE id=" << ID;
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    int res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    DisconnectDB(Connection);
+    return true;
+}
+
+bool cTimersMysql::UpdateTimer(cTimer *timer)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;101m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    MYSQL *Connection = mysql_init(NULL);
+    std::stringstream Query;
+    char *EscapedFile=NULL;
+    char *EscapedAux=NULL;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    // First escape strings
+    EscapedFile = (char*)malloc((strlen(timer->File())*2+1)*sizeof(char));
+    mysql_real_escape_string(Connection, EscapedFile, timer->File(), strlen(timer->File()));
+    if(timer->Aux()) {
+        EscapedAux = (char*)malloc((strlen(timer->Aux())*2+1)*sizeof(char));
+        mysql_real_escape_string(Connection, EscapedAux, timer->Aux(), strlen(timer->Aux()));
+    }
+
+    Query << "UPDATE " << Table_ << " SET flags=" << timer->Flags();
+    Query << ", channel='" << *timer->Channel()->GetChannelID().ToString();
+    Query << "', date='" << *(timer->PrintDay(timer->Day(), timer->WeekDays(), true));
+    Query << "', start='" << std::setw(4) << std::setfill('0') << timer->Start();
+    Query << "', stop='" << std::setw(4) << std::setfill('0') << timer->Stop();
+    Query << "', priority=" << timer->Priority() << ", lifetime=" << timer->Lifetime(); 
+    Query << ", file='" << EscapedFile << "', aux='";
+    if(EscapedAux)
+        Query << EscapedAux;
+    Query << "' WHERE id=" << timer->GetID();
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    int res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    if(EscapedFile)
+        free(EscapedFile);
+    if(EscapedAux)
+        free(EscapedAux);
+    DisconnectDB(Connection);
+    return true;
+}
+
+bool cTimersMysql::LoadDB(std::vector<StringTimer> *StringTimers, int *LastEventID)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+    std::stringstream Query;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    Query << "SELECT id, flags, channel, date, start, stop, priority, lifetime, file, aux FROM " << Table_;
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    int res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    Result = mysql_store_result(Connection);
+
+    if(Result)
+    {
+        while((Row=mysql_fetch_row(Result)) != NULL)
+        {
+            int id = atoi(Row[0]);
+            std::stringstream strBuff;
+
+            unsigned int numRes = mysql_num_fields(Result);
+
+            // replace colons ':' with '|'. Colon is used as field separator, so no colons inside field strings.
+            if(numRes >= 1)
+                strBuff << strreplace(Row[1],':', '|');
+            for(unsigned int i=2; i<numRes; ++i)
+                strBuff << ':' << strreplace(Row[i],':', '|');
+
+            StringTimer Timer;
+            Timer.ID = id;
+            Timer.s = strdup(strBuff.str().c_str());
+            StringTimers->push_back(Timer);
+        }
+        mysql_free_result(Result);
+    } else {
+        DisconnectDB(Connection);
+        SetLastEventID(-1);
+        return false;
+    }
+    DisconnectDB(Connection);
+
+    res = GetLastEventID(LastEventID);
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        return false;
+    }
+        
+    if(Setup.ReelboxModeTemp==eModeServer) // On Server update Avahi-MySQL-file
+        SetLastEventID(*LastEventID);
+    return true;
+}
+
+bool cTimersMysql::Sync(int *LastEventID)
+{
+    //std::cout << "\033[0;41m " << __FILE__ << "(" << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+
+    int CurrentLastEventID=0;
+    int res = GetLastEventID(&CurrentLastEventID);
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        return false;
+    }
+
+    if(*LastEventID == CurrentLastEventID)
+        return false; // Already done!
+
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+    std::stringstream Query;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    Query << "SELECT object_id, action FROM vdr_event WHERE id>" << *LastEventID << " AND table_name='timer'";
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    Result = mysql_store_result(Connection);
+
+    if(Result)
+    {
+        while((Row=mysql_fetch_row(Result)) != NULL)
+        {
+            unsigned int ID = atoi(Row[0]);
+            const char *Action = Row[1];
+
+#ifdef MYSQL_DEBUG
+            std::cout << "\033[0;94m ID:" << ID << " Action: " << Action << " \033[0m" << std::endl;
+#endif
+            if(!strcmp(Action, "insert"))
+            {
+                if(!Timers.GetTimerByID(ID))
+                    PutTimer(ID);
+                else
+                    esyslog("ERROR: Timer(ID=%i) already exists!\n", ID);
+            }
+            else if(!strcmp(Action, "delete"))
+                RemoveTimer(ID);
+            else if(!strcmp(Action, "update"))
+                SyncTimer(ID);
+        }
+    }
+    mysql_free_result(Result);
+    DisconnectDB(Connection);
+
+    *LastEventID = CurrentLastEventID; // Update LastTimestamp
+    if(Setup.ReelboxModeTemp==eModeServer) // On Server update Avahi-MySQL-file
+        SetLastEventID(CurrentLastEventID);
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __PRETTY_FUNCTION__ << " FINISHED! \033[0m" << std::endl;
+#endif
+    return true;
+}
+
+#if 0
+void cTimersMysql::UpdateDB()
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __FILE__ << '(' << __LINE__ << "): " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    MYSQL *Connection = mysql_init(NULL);
+    std::stringstream Query;
+    char *EscapedFile=NULL;
+    char *EscapedAux=NULL;
+    
+    if (Connection == NULL)
+        return;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return; // Connection failed
+    }
+
+    for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
+        Query.str(""); // Clear Query-string
+
+        // First escape strings
+        EscapedFile = (char*)malloc((strlen(timer->File())*2+1)*sizeof(char));
+        mysql_real_escape_string(Connection, EscapedFile, timer->File(), strlen(timer->File()));
+        if(timer->Aux()) {
+            EscapedAux = (char*)malloc((strlen(timer->Aux())*2+1)*sizeof(char));
+            mysql_real_escape_string(Connection, EscapedAux, timer->Aux(), strlen(timer->Aux()));
+        }
+
+        Query << "UPDATE " << Table_ << " SET flags=" << timer->Flags();
+        Query << ", channel='" << *timer->Channel()->GetChannelID().ToString();
+        Query << "', date='" << *(timer->PrintDay(timer->Day(), timer->WeekDays(), true));
+        Query << "', start='" << std::setw(4) << std::setfill('0') << timer->Start();
+        Query << "', stop='" << std::setw(4) << std::setfill('0') << timer->Stop();
+        Query << "', priority=" << timer->Priority();
+        Query << ", lifetime=" << timer->Lifetime();
+        Query << ", file='" << EscapedFile << "', aux='";
+        if(EscapedAux)
+            Query << EscapedAux;
+        Query << "' WHERE id=" << timer->GetID();
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;93m " << __FILE__ << "(" << __LINE__ << "): \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+        int res = mysql_query(Connection, Query.str().c_str());
+        if (res != 0) {
+            esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        }
+
+        if(EscapedFile)
+            free(EscapedFile);
+        if(EscapedAux)
+            free(EscapedAux);
+    }
+    DisconnectDB(Connection);
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;41m " << __PRETTY_FUNCTION__ << " FINISHED! \033[0m" << std::endl;
+#endif
+}
+#endif
+
+bool cTimersMysql::PutTimer(unsigned int ID)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;104m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+    std::stringstream Query;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    Query << "SELECT flags, channel, date, start, stop, priority, lifetime, file, aux FROM " << Table_ << " WHERE id='" << ID << "'";
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    int res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    Result = mysql_store_result(Connection);
+
+    if(Result)
+    {
+        if((Row=mysql_fetch_row(Result)) != NULL)
+        {
+            std::stringstream strBuff;
+            unsigned int numRes = mysql_num_fields(Result);
+            if(numRes)
+                strBuff << Row[0];
+            for(unsigned int i=1; i<numRes; ++i)
+                strBuff << ':' << Row[i];
+
+            cTimer *timer = new cTimer;
+            if(timer->Parse(strBuff.str().c_str(), ID))
+            {
+                Timers.cConfig<cTimer>::Add(timer);
+                cStatus::MsgTimerChange(timer, tcAdd);
+            }
+            else
+                delete timer;
+        }
+        else {
+            esyslog("%s(%i) ERROR: Database Error mysql_fetch_row() returned NULL", __FILE__, __LINE__);
+            esyslog("%s (%s:%d) mysql error: %u '%s'",
+                    __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                    mysql_errno(Connection),
+                    mysql_error(Connection));
+            DisconnectDB(Connection);
+            return false; // Data not found
+        }
+    }
+    else
+    {
+        mysql_free_result(Result);
+        DisconnectDB(Connection);
+        return false; // No Result
+    }
+
+    mysql_free_result(Result);
+    DisconnectDB(Connection);
+    return true;
+}
+
+bool cTimersMysql::RemoveTimer(unsigned int ID)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;104m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    cTimer *deletetimer = Timers.GetTimerByID(ID);
+    if(deletetimer)
+    {
+        if(deletetimer->Recording())
+        {
+            deletetimer->Skip();
+            cRecordControls::Process(time(NULL));
+        }
+#ifdef MYSQL_DEBUG
+        std::cout << "\033[0;38m Timer found - Deleting! \033[0m" << std::endl;
+#endif
+        cStatus::MsgTimerChange(deletetimer, tcDel);
+        Timers.cConfig<cTimer>::Del(deletetimer);
+    }
+
+    return true;
+}
+
+bool cTimersMysql::SyncTimer(unsigned int ID)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;104m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    MYSQL *Connection = mysql_init(NULL);
+    MYSQL_RES *Result;
+    MYSQL_ROW Row;
+    std::stringstream Query;
+
+    if (Connection == NULL)
+        return false;
+
+    if(!ConnectDB(Connection)) {
+        free(Connection);
+        return false; // Connection failed
+    }
+
+    Query << "SELECT flags, channel, date, start, stop, priority, lifetime, file, aux FROM " << Table_ << " WHERE id='" << ID << "'";
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+    int res = mysql_query(Connection, Query.str().c_str());
+    if (res != 0) {
+        esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+        esyslog("%s (%s:%d) mysql error: %u '%s'",
+                __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                mysql_errno(Connection),
+                mysql_error(Connection));
+        DisconnectDB(Connection);
+        return false;
+    }
+
+    Result = mysql_store_result(Connection);
+
+    if(Result)
+    {
+        if((Row=mysql_fetch_row(Result)) != NULL)
+        {
+            std::stringstream strBuff;
+            unsigned int numRes = mysql_num_fields(Result);
+            if(numRes)
+                strBuff << Row[0];
+            for(unsigned int i=1; i<numRes; ++i)
+                strBuff << ':' << Row[i];
+
+            cTimer *timer = Timers.GetTimerByID(ID);
+            if (timer)
+            {
+                /* Donot update DB, as we have just got the changes from it
+                 * cTimer::Parse() updates database when it's ID is non-zero
+                 * Hence set it's ID = 0 before Parse()
+                 */
+                timer->SetID(0); 
+
+                if(timer->Parse(strBuff.str().c_str(), ID))
+                    Timers.SetModified();
+            }
+        }
+        else {
+            esyslog("%s(%i) ERROR: Database Error mysql_fetch_row() returned NULL", __FILE__, __LINE__);
+            esyslog("%s (%s:%d) mysql error: %u '%s'",
+                    __PRETTY_FUNCTION__, __FILE__, __LINE__,
+                    mysql_errno(Connection),
+                    mysql_error(Connection));
+            DisconnectDB(Connection);
+            return false; // Data not found
+        }
+    }
+    else
+    {
+        mysql_free_result(Result);
+        DisconnectDB(Connection);
+        return false; // No Result
+    }
+
+    mysql_free_result(Result);
+    DisconnectDB(Connection);
+    return true;
+}
+
+void cTimersMysql::GetInstantRecordings(std::vector<cTimer*> *InstantRecordings)
+{
+#ifdef MYSQL_DEBUG
+    std::cout << "\033[0;101m " << __PRETTY_FUNCTION__ << " \033[0m" << std::endl;
+#endif
+    InstantRecordings->clear();
+    char *IpAddress = NULL;
+#ifdef RBMINI
+    IpAddress = GetIpAddress();
+#endif
+    if(IpAddress || (Setup.ReelboxMode == eModeServer))
+    {
+        MYSQL *Connection = mysql_init(NULL);
+        MYSQL_RES *Result;
+        MYSQL_ROW Row;
+        std::stringstream Query;
+
+        if (Connection)
+        {
+            if(ConnectDB(Connection))
+            {
+                if(Setup.ReelboxMode == eModeClient) // Client
+                    Query << "SELECT id, flags FROM " << Table_ << " WHERE ip='" << IpAddress << '\'';
+                else // Server
+                    Query << "SELECT id, flags FROM " << Table_ << " WHERE ip='(null)'";
+#ifdef MYSQL_DEBUG
+                std::cout << "\033[0;93m \"" << Query.str() << "\" \033[0m" << std::endl;
+#endif
+                int res = mysql_query(Connection, Query.str().c_str());
+                if (res == 0)
+                {
+                    Result = mysql_store_result(Connection);
+
+                    while((Row=mysql_fetch_row(Result)) != NULL)
+                    {
+                        int flags = atoi(Row[1]);
+                        if(flags&tfInstant)
+                            InstantRecordings->push_back(Timers.GetTimerByID(atoi(Row[0])));
+                    }
+                    mysql_free_result(Result);
+                }
+                else
+                    esyslog("%s(%i) ERROR: Database Error %i\n", __FILE__, __LINE__, res);
+
+                DisconnectDB(Connection);
+            }
+            else
+                free(Connection);
+        }
+    }
+}
+
diff -urN vdr-2.0.1/vdrmysql.h vdr-2.0.1.reel/vdrmysql.h
--- vdr-2.0.1/vdrmysql.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/vdrmysql.h	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,166 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Reel Multimedia;  Author:  Florian Erfurth      *
+ *                                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ ***************************************************************************
+ *
+ * vdrmysql.h
+ *
+ ***************************************************************************/
+
+#ifndef VDRMYSQL_H
+#define VDRMYSQL_H
+
+#include <mysql/mysql.h>
+#include <vector>
+
+#include "timers.h"
+
+#define MYSQLREELUSER "reeluser"
+#define MYSQLREELPWD  "reeluser"
+#define MYSQLADMINUSER "root"
+#define MYSQLADMINPWD  "root"
+
+enum eEventAction { eActionUnknown, eActionInsert, eActionUpdate, eActionDelete };
+
+struct vdr_event
+{
+    unsigned int ID;
+    eEventAction Action;
+};
+
+struct StringTimer {
+  unsigned int ID;
+  char *s;
+};
+
+class cVdrMysql
+{
+    protected:
+        char *Server_;
+        char *Username_;
+        char *Password_;
+        char *Database_;
+
+        bool ConnectDB(MYSQL *Connection);
+        void DisconnectDB(MYSQL *Connection);
+        void SetLastEventID(int LastEventID, bool force=false);
+
+    public:
+        cVdrMysql(const char *Username, const char *Password, const char *Database);
+        ~cVdrMysql();
+
+        bool SetServer(const char *Server);
+        int GetLastEventID(int *id); /** set the lastEventId "id" - returns 0 if successful, the mysql-error otherwise */
+};
+
+// cVdrMysqlAdmin is used for administration of MySQL-Database
+class cVdrMysqlAdmin : public cVdrMysql
+{
+    private:
+        bool InitDatabase(bool RecreateDB=false, const char *Database=NULL);
+        void GenerateTableFromTemplate(MYSQL *Connection, const char *filename);
+    public:
+        cVdrMysqlAdmin(const char *Username, const char *Password, const char *Database);
+        ~cVdrMysqlAdmin();
+        bool CreateAccount();
+        bool CreateDatabase(const char *Database=NULL) { return InitDatabase(false, Database); };
+        bool ClearDatabase() { return InitDatabase(true); };
+        bool CreateTables();
+        bool ClearEvents();
+        bool TestTables();
+        bool TestPermission();
+};
+
+// Timer
+class cTimersMysql : public cVdrMysql
+{
+    private:
+        const char *Table_;
+
+    public:
+        cTimersMysql(const char *Username, const char *Password, const char *Database);
+        ~cTimersMysql();
+
+        /// the following makes changes to db
+        /// push changes from vdr to db
+
+        bool InsertTimer(cTimer *timer);
+        /* makes a new entry into db with timer(param) values
+          and reads back the ID given automatically by db
+          and sets it to timer (param) object
+        */
+
+        bool DeleteTimer(unsigned int ID);
+        /* deletes entry with id=ID (param) from db
+           does not delete corresponding timer object from vdr
+        */
+
+        bool UpdateTimer(cTimer *timer);
+        /* changes entry in db corresponding to timer->GetID() with the
+           timer's info (flags, start, stop, date etc)
+        */
+
+        bool LoadDB(std::vector<StringTimer> *StringTimers, int *LastEventID);
+        /*  reads ALL entries of 'timer' table from db
+            and creates a vector of 'StringTimer's
+
+            gets (updates) lastEventID from db with GetLastEventID(LastEventID)
+
+            if vdr is in server mode
+              calls SetLastEventID(*LastEventID) to publish last event id to clients
+        */
+
+
+
+        /// the following do not make any changes to db
+        /// they import info from db to vdr
+
+        bool Sync(int *LastEventID);
+        /* reads current LastEventID from db
+           if current LastEventID == lastEventID param nothing is done
+
+          else all entries with id > lastEventID (param) are read from 'vdr_event'
+          table of db and corresponding changes ('insert', 'delete' or 'update')
+          is done to timers ( with PutTimer(), RemoveTimer(), SyncTimer() )
+        */
+
+
+//        void UpdateDB();
+
+        bool PutTimer(unsigned int ID);
+        /* create new timer in vdr with ID (param) from db
+
+           read entry with id=ID and create a new timer from it
+           and adds into Timers list
+        */
+
+        bool RemoveTimer(unsigned int ID);
+        /* removes timer with id=ID (param) from Timers list
+           does not access db
+        */
+
+        bool SyncTimer(unsigned int ID);
+        /* reads db for entry with id=ID (param) and updates the timer
+          with id=ID in vdr
+        */
+
+        void GetInstantRecordings(std::vector<cTimer*> *InstantRecordings);
+};
+
+#endif
diff -urN vdr-2.0.1/vdrttxtsubshooks.c vdr-2.0.1.reel/vdrttxtsubshooks.c
--- vdr-2.0.1/vdrttxtsubshooks.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/vdrttxtsubshooks.c	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,63 @@
+/*
+ * vdr-ttxtsubs - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2003 - 2008 Ragnar Sundblad <ragge@nada.kth.se>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+
+#include "vdrttxtsubshooks.h"
+
+// XXX Really should be a list...
+static cVDRTtxtsubsHookListener *gListener;
+
+// ------ class cVDRTtxtsubsHookProxy ------
+
+class cVDRTtxtsubsHookProxy : public cVDRTtxtsubsHookListener
+{
+ public:
+  virtual void HideOSD(void) { if(gListener) gListener->HideOSD(); };
+  virtual void ShowOSD(void) { if(gListener) gListener->ShowOSD(); };
+  virtual void PlayerTeletextData(uint8_t *p, int length, bool IsPesRecording, const struct tTeletextSubtitlePage teletextSubtitlePages[] = NULL, int pageCount = 0)
+    { if(gListener) gListener->PlayerTeletextData(p, length, IsPesRecording, teletextSubtitlePages, pageCount); };
+  virtual int ManualPageNumber(const cChannel *channel)
+    { if(gListener) return gListener->ManualPageNumber(channel); else return 0; };
+};
+
+
+// ------ class cVDRTtxtsubsHookListener ------
+
+cVDRTtxtsubsHookListener::~cVDRTtxtsubsHookListener()
+{
+  gListener = 0;
+}
+
+void cVDRTtxtsubsHookListener::HookAttach(void)
+{
+  gListener = this;
+  //printf("cVDRTtxtsubsHookListener::HookAttach\n");
+}
+
+static cVDRTtxtsubsHookProxy gProxy;
+
+cVDRTtxtsubsHookListener *cVDRTtxtsubsHookListener::Hook(void)
+{
+  return &gProxy;
+}
+
diff -urN vdr-2.0.1/vdrttxtsubshooks.h vdr-2.0.1.reel/vdrttxtsubshooks.h
--- vdr-2.0.1/vdrttxtsubshooks.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.1.reel/vdrttxtsubshooks.h	2013-05-09 18:10:01.663874319 +0200
@@ -0,0 +1,46 @@
+/*
+ * vdr-ttxtsubs - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2003 - 2008 Ragnar Sundblad <ragge@nada.kth.se>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef __VDRTTXTSUBSHOOKS_H
+#define __VDRTTXTSUBSHOOKS_H
+
+#define TTXTSUBSVERSNUM 2
+
+class cDevice;
+class cChannel;
+struct tTeletextSubtitlePage;
+
+class cVDRTtxtsubsHookListener {
+ public:
+  cVDRTtxtsubsHookListener(void) {};
+  virtual ~cVDRTtxtsubsHookListener();
+
+  void HookAttach(void);
+
+  virtual void HideOSD(void) {};
+  virtual void ShowOSD(void) {};
+  virtual void PlayerTeletextData(uint8_t *p, int length, bool IsPesRecording = true, const struct tTeletextSubtitlePage teletextSubtitlePages[] = NULL, int pageCount = 0) {};
+  virtual int ManualPageNumber(const cChannel *channel) { return 0; };
+
+  // used by VDR to call hook listeners
+  static cVDRTtxtsubsHookListener *Hook(void);
+};
+
+#endif
diff -urN vdr-2.0.1/videodir.c vdr-2.0.1.reel/videodir.c
--- vdr-2.0.1/videodir.c	2012-09-30 14:06:33.000000000 +0200
+++ vdr-2.0.1.reel/videodir.c	2013-05-09 18:10:01.667874321 +0200
@@ -229,6 +229,22 @@
   return NULL;
 }
 
+cString NewVideoFileName(const char *FileName, const char *NewDirName)
+{
+  char *NewDir = ExchangeChars(strdup(NewDirName), true);
+  if (NewDir) {
+     const char *p = FileName + strlen(FileName); // p points at the terminating 0
+     while (p-- > FileName) {
+           if (*p == '/')
+              break;
+           }
+     cString NewName = cString::sprintf("%s/%s%s", VideoDirectory, NewDir, p);
+     free(NewDir);
+     return NewName;
+     }
+  return NULL;
+}
+
 void RemoveEmptyVideoDirectories(const char *IgnoreFiles[])
 {
   cVideoDirectory Dir;
diff -urN vdr-2.0.1/videodir.h vdr-2.0.1.reel/videodir.h
--- vdr-2.0.1/videodir.h	2012-09-30 13:01:15.000000000 +0200
+++ vdr-2.0.1.reel/videodir.h	2013-05-09 18:10:01.667874321 +0200
@@ -23,6 +23,7 @@
 bool VideoFileSpaceAvailable(int SizeMB);
 int VideoDiskSpace(int *FreeMB = NULL, int *UsedMB = NULL); // returns the used disk space in percent
 cString PrefixVideoFileName(const char *FileName, char Prefix);
+cString NewVideoFileName(const char *FileName, const char *NewDirName);
 void RemoveEmptyVideoDirectories(const char *IgnoreFiles[] = NULL);
 bool IsOnVideoDirectoryFileSystem(const char *FileName);
 
