diff --git a/HISTORY-liemikuutio b/HISTORY-liemikuutio
new file mode 100644
index 0000000..fc76c11
--- /dev/null
+++ b/HISTORY-liemikuutio
@@ -0,0 +1,165 @@
+-----------------------------------
+Liemikuutio for Video Disc Recorder
+
+Maintainer: Rolf Ahrenberg
+-----------------------------------
+
+2006-01-08: Version 1.0
+
+- Based on enAIO with these original patches:
+  Simple recordings sorting by Walter@VDRPortal
+  Alternate rename recordings by Ralf MÃŒller
+  Menu selection by Peter Dittmann
+  Recording length by Tobias Faust
+
+2006-01-15: Version 1.1
+
+- Removed patches already found in vdr-1.3.39.
+
+2006-01-25: Version 1.2
+
+- Added "Main menu command position" feature.
+
+2006-02-05: Version 1.3
+
+- Improved menu selection response.
+
+2006-04-18: Version 1.4
+
+- Added Estonian translation (Thanks to Arthur Konovalov).
+
+2006-04-30: Version 1.5
+
+- Added progress bar view into "What's on now?" menu.
+
+2006-06-06: Version 1.6
+
+- Added French translation (Thanks to ECLiPSE).
+
+2006-06-14: Version 1.7
+
+- Fixed RENR crash.
+
+2006-07-14: Version 1.8
+
+- Fixed RENR/OSD bug.
+
+2006-08-27: Version 1.9
+
+- Some modifications to the recording length and rename recordings
+  patches (Thanks to Firefly).
+- Added k1_k3_jumps_20s patch by Petri Hintukainen.
+
+2006-08-29: Version 1.10
+
+- The cRecording:Title() method now defaults to original formatting.
+
+2006-09-04: Version 1.11
+
+- Removed unused variable from cRecording::Title() method (Thanks to
+  C.Y.M.).
+- Some modifications to the rename recordings patch (Thanks to Firefly).
+
+2006-09-13: Version 1.12
+
+- More modifications to the rename recordings patch (Thanks to Firefly).
+
+2006-10-01: Version 1.13
+
+- Removed unnecessary syslog printing (Thanks to Firefly).
+
+2007-08-14: Version 1.14
+
+- Updated for vdr-1.5.7.
+
+2007-10-16: Version 1.15
+
+- Added recmenu play patch (Thanks to Ville Skyttä).
+- Updated French translation (Thanks to ECLiPSE).
+
+2007-11-04: Version 1.16
+
+- Updated for vdr-1.5.11.
+
+2007-12-08: Version 1.17
+
+- Added binary skip patch.
+- Removed k1_k3_jumps_20s patch.
+
+2008-02-17: Version 1.18
+
+- Updated for vdr-1.5.15.
+
+2008-03-02: Version 1.19
+
+- Modified binary skip to use kPrev and kNext keys and the skip is now
+  always shortened after a direction change (Thanks to Timo Eskola).
+- Readded k1_k3_jumps_20s patch.
+
+2008-04-04: Version 1.20
+
+- Added bitrate information into rename menu.
+- Readded the path editing support of rename recordings patch (Thanks
+  to Firefly).
+
+2008-05-08: Version 1.21
+
+- Fixed rename recordings (Thanks to Firefly).
+- Added a DVB subtitles hack for old recordings (Thanks to Anssi Hannula).
+
+2009-01-08: Version 1.22
+
+- Updated for vdr-1.7.3.
+
+2009-01-25: Version 1.23
+
+- Updated for vdr-1.7.4.
+
+2009-02-27: Version 1.24
+
+- Fixed compilation under gcc-4.4.
+
+2009-04-05: Version 1.25
+
+- Fixed the length detection of recordings (Thanks to Thomas Günther).
+
+2009-04-17: Version 1.26
+
+- Fixed the length detection of audio recordings (Thanks to Thomas Günther).
+
+2009-04-26: Version 1.27
+
+- Fixed the length detection of empty recordings (Thanks to Thomas Günther).
+
+2009-07-12: Version 1.28
+
+- Fixed the TS/PES detection of recording marks.
+
+2009-11-23: Version 1.29
+
+- Updated Estonian translation (Thanks to Arthur Konovalov).
+
+2010-02-01: Version 1.30
+
+- Updated for vdr-1.7.12.
+
+2011-09-04: Version 1.31
+
+- Updated for vdr-1.7.21.
+- Removed progress bar view form "What's on now?" menu.
+- Removed "Main menu command position" and recordings length/sorting features.
+- Changed renaming functionality to support different filesystems and binded it to key '0'.
+
+2011-10-19: Version 1.32
+
+- Refactored renaming functionality to support both background moving and copying.
+- Removed main menu command position changes completely.
+
+2011-11-16: Version 1.33
+
+- Updated the filetransfer patch.
+
+2012-03-03: Version 1.34
+
+- Updated the filetransfer patch.
+- Removed the DVB subtitles hack for old recordings.
diff --git a/MANUAL b/MANUAL
index 5d3c9a5..9338254 100644
--- a/MANUAL
+++ b/MANUAL
@@ -743,6 +743,9 @@ Version 1.6
                          background transparency. By default the values as broadcast
                          are used.
 
+  Record Teletext Subtitles = no
+                         If set to 'yes', teletext subtitles will be recorded.
+
   LNB:
 
   Use DiSEqC = no        Generally turns DiSEqC support on or off.
diff --git a/Make.config.template b/Make.config.template
index d51e20c..0cae5b9 100644
--- a/Make.config.template
+++ b/Make.config.template
@@ -41,8 +41,133 @@ LIRC_DEVICE = /var/run/lirc/lircd
 ## Define if you want vdr to not run as root
 #VDR_USER = vdr
 
+### VDR-Extensions:
+
+#ALTERNATECHANNEL = 1
+#CHANNELBIND = 1
+#CUTTERLIMIT = 1
+#DDEPGENTRY = 1
+#DVLVIDPREFER = 1
+#GRAPHTFT = 1
+#HARDLINKCUTTER = 1
+#JUMPINGSECONDS = 1
+#JUMPPLAY = 1
+#LIEMIKUUTIO = 1
+#LIRCSETTINGS = 1
+#MAINMENUHOOKS = 1
+#MCLI = 1
+#MENUORG = 1
+#NALUDUMP = 1
+#PINPLUGIN = 1
+#PLUGINMISSING = 1
+#ROTOR = 1
+#SETUP = 1
+#TIMERINFO = 1
+#TTXTSUBS = 1
+#VOLCTRL = 1
+#WAREAGLEICON = 1
+#YAEPG = 1
+
 ### You don't need to touch the following:
 
 ifdef DVBDIR
 INCLUDES += -I$(DVBDIR)/include
 endif
+
+ifdef ALTERNATECHANNEL
+DEFINES += -DUSE_ALTERNATECHANNEL
+endif
+
+ifdef CHANNELBIND
+DEFINES += -DUSE_CHANNELBIND
+endif
+
+ifdef CUTTERLIMIT
+DEFINES += -DUSE_CUTTERLIMIT
+endif
+
+ifdef DDEPGENTRY
+DEFINES += -DUSE_DDEPGENTRY
+endif
+
+ifdef DVLVIDPREFER
+DEFINES += -DUSE_DVLVIDPREFER
+endif
+
+ifdef GRAPHTFT
+DEFINES += -DUSE_GRAPHTFT
+endif
+
+ifdef HARDLINKCUTTER
+DEFINES += -DUSE_HARDLINKCUTTER
+endif
+
+ifdef JUMPINGSECONDS
+DEFINES += -DUSE_JUMPINGSECONDS
+endif
+
+ifdef JUMPPLAY
+DEFINES += -DUSE_JUMPPLAY
+endif
+
+ifdef LIRCSETTINGS
+DEFINES += -DUSE_LIRCSETTINGS
+endif
+
+ifdef LIEMIKUUTIO
+DEFINES += -DUSE_LIEMIKUUTIO
+endif
+
+ifdef MAINMENUHOOKS
+DEFINES += -DUSE_MAINMENUHOOKS
+endif
+
+ifdef MCLI
+DEFINES += -DUSE_MCLI
+endif
+
+ifdef MENUORG
+DEFINES += -DUSE_MENUORG
+endif
+
+ifdef NALUDUMP
+DEFINES += -DUSE_NALUDUMP
+endif
+
+ifdef PINPLUGIN
+DEFINES += -DUSE_PINPLUGIN
+endif
+
+ifdef PLUGINMISSING
+DEFINES += -DUSE_PLUGINMISSING
+endif
+
+ifdef ROTOR
+DEFINES += -DUSE_ROTOR
+endif
+
+ifdef SETUP
+DEFINES += -DUSE_SETUP
+endif
+
+ifdef TIMERINFO
+DEFINES += -DUSE_TIMERINFO
+endif
+
+ifdef TTXTSUBS
+DEFINES += -DUSE_TTXTSUBS
+endif
+
+ifdef VOLCTRL
+DEFINES += -DUSE_VOLCTRL
+endif
+
+ifdef WAREAGLEICON
+DEFINES += -DUSE_WAREAGLEICON
+endif
+
+ifdef YAEPG
+DEFINES += -DUSE_YAEPG
+//VDR_XINE_SET_VIDEO_WINDOW = 1
+endif
+
diff --git a/Makefile b/Makefile
index a0458d4..871e0ab 100644
--- a/Makefile
+++ b/Makefile
@@ -47,6 +47,23 @@ OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o d
        skinclassic.o skinlcars.o skins.o skinsttng.o sourceparams.o sources.o spu.o status.o svdrp.o themes.o thread.o\
        timers.o tools.o transfer.o vdr.o videodir.o
 
+ifdef LIEMIKUUTIO
+OBJS += filetransfer.o
+endif
+
+ifdef SETUP
+OBJS += submenu.o
+LIBS += -ltinyxml
+endif
+
+ifdef WAREAGLEICON
+OBJS += iconpatch.o
+endif
+
+ifdef TTXTSUBS
+OBJS += vdrttxtsubshooks.o
+endif
+
 ifndef NO_KBD
 DEFINES += -DREMOTE_KBD
 endif
diff --git a/README-HLCUTTER b/README-HLCUTTER
new file mode 100644
index 0000000..71f13d0
--- /dev/null
+++ b/README-HLCUTTER
@@ -0,0 +1,127 @@
+                    VDR-HLCUTTER README
+
+
+Written by:           Udo Richter
+Available at:         http://www.udo-richter.de/vdr/patches.html#hlcutter
+                      http://www.udo-richter.de/vdr/patches.en.html#hlcutter
+Contact:              udo_richter@gmx.de
+
+
+
+About
+-----
+
+The hard link cutter patch changes the recording editing algorithms of VDR to
+use filesystem hard links to 'copy' recording files whenever possible to speed
+up editing recordings noticeably.
+
+The patch has matured to be quite stable, at least I'm using it without issues.
+Nevertheless the patch is still in development and should be used with caution. 
+The patch is EXPERIMENTAL for multiple /videoxx folders. The safety checks 
+should prevent data loss, but you should always carefully check the results.
+
+While editing a recording, the patch searches for any 00x.vdr files that don't
+contain editing marks and would normally be copied 1:1 unmodified to the edited
+recording. In this case the current target 00x.vdr file will be aborted, and 
+the cutter process attempts to duplicate the source file as a hard link, so 
+that both files share the same disk space. If this succeeds, the editing 
+process fast-forwards through the duplicated file and continues normally 
+beginning with the next source file. If hard linking fails, the cutter process
+continues with plain old copying. (but does not take up the aborted last file.)
+
+After editing, the un-edited recording can be deleted as usual, the hard linked
+copies will continue to exist as the only remaining copy.
+
+To be effective, the default 'Max. video file size (MB)' should be lowered. 
+The patch lowers the smallest possible file size to 1mb. Since VDR only 
+supports up to 255 files, this would limit the recording size to 255Mb or
+10 minutes, in other words: This setting is insane!
+
+To make sure that the 255 file limit will not be reached, the patch also 
+introduces "Max. recording size (GB)" with a default of 100Gb (66 hours), and 
+increases the file size to 2000Mb early enough, so that 100Gb-recordings will
+fit into the 255 files.
+
+Picking the right parameters can be tricky. The smaller the file size, the 
+faster the editing process works. However, with a small file size, long 
+recordings will fall back to 2000Mb files soon, that are slow on editing again.
+
+Here are some examples:
+
+Max file size:      100Gb   100Gb   100Gb   100Gb   100Gb   100Gb   100Gb
+Max recording size: 1Mb     10Mb    20Mb    30Mb    40Mb    50Mb    100Mb
+
+Small files:        1-203   1-204   1-205   1-206   1-207   1-209   1-214
+  GBytes:           0.2     2.0     4.0     6.0     8.1     10.2    20.9
+  Hours:            0.13    1.3     2.65    4       5.4     6.8     13.9
+
+Big (2000mb) files: 204-255 204-255 206-255 207-255 208-255 210-255 215-255
+  GBytes:           101.5   99.6    97.7    95.7    93.8    89.8    80.1
+  Hours:            67      66      65      63      62      60      53
+
+A recording limit of 100Gb keeps plenty of reserve without blocking too much
+file numbers. And with a file size of 30-40Mb, recordings of 4-5 hours fit into
+small files completely. (depends on bit rate of course)
+
+
+
+The patch must be enabled in Setup-> Recordings-> Hard Link Cutter. When 
+disabled, the cutter process behaves identical to VDR's default cutter.
+
+There's a //#define HARDLINK_TEST_ONLY in the videodir.c file that enables a
+test-mode that hard-links 00x.vdr_ files only, and continues the classic 
+editing. The resulting 00x.vdr and 00x.vdr_ files should be identical. If you 
+delete the un-edited recording, don't forget to delete the *.vdr_ files too, 
+they will now eat real disk space.
+
+Note: 'du' displays the disk space of hard links only on first appearance, and
+usually you will see a noticeably smaller size on the edited recording.
+
+
+History
+-------
+
+Version 0.2.3
+  Fix: Compatible to VDR-1.7.27+ thx to Ville Skyttä
+  New: Add German translation
+  New: Add Finnish translation, thx to Ville Skyttä
+
+Version 0.2.2
+  Fix: Adapt to GCC-4.4, thx to Ville Skyttä
+
+Version 0.2.1
+  New: Support for TS recordings with up to 65535 files and up to 1TB per file
+
+Version 0.2.0
+  New: Support for multiple /videoXX recording folders, using advanced searching
+       for matching file systems where a hard link can be created.
+       Also supports deep mounted file systems.
+  Fix: Do not fail if last mark is a cut-in. (Again.)
+
+Version 0.1.4
+  New: Dynamic increase of file size before running out of xxx.vdr files
+  Fix: Last edit mark is not a cut-out
+  Fix: Write error if link-copied file is smaller than allowed file size
+  Fix: Broken index/marks if cut-in is at the start of a new file
+  Fix: Clear dangling pointer to free'd cUnbufferedFile, 
+       thx to Matthias Schwarzott
+
+Version 0.1.0
+  Initial release
+
+
+
+
+Future plans
+------------
+
+Since original and edited copy share disk space, free space is wrong if one of
+them is moved to *.del. Free space should only count files with hard link 
+count = 1. This still goes wrong if all copies get deleted.
+
+
+For more safety, the hard-linked files may be made read-only, as modifications
+to one copy will affect the other copy too. (except deleting, of course)
+
+
+SetBrokenLink may get lost on rare cases, this needs some more thoughts.
diff --git a/README.patches b/README.patches
new file mode 100644
index 0000000..b1b2e75
--- /dev/null
+++ b/README.patches
@@ -0,0 +1 @@
+liemikuutio - http://www.saunalahti.fi/~rahrenbe/vdr/patches/index.php
diff --git a/channels.c b/channels.c
index 4c04608..f67675f 100644
--- a/channels.c
+++ b/channels.c
@@ -13,6 +13,9 @@
 #include "epg.h"
 #include "libsi/si.h"
 #include "timers.h"
+#ifdef USE_ALTERNATECHANNEL
+#include "tools.h"
+#endif /* ALTERNATECHANNEL */
 
 // IMPORTANT NOTE: in the 'sscanf()' calls there is a blank after the '%d'
 // format characters in order to allow any number of blanks after a numeric
@@ -285,6 +288,14 @@ void cChannel::SetPortalName(const char *PortalName)
      }
 }
 
+#ifdef USE_ALTERNATECHANNEL
+void cChannel::SetAlternativeChannelID(const char *AlternativeChannelID)
+{
+  if (!isempty(AlternativeChannelID))
+    alternativeChannelID = tChannelID::FromString(AlternativeChannelID);
+}
+#endif /* ALTERNATECHANNEL */
+
 #define STRDIFF 0x01
 #define VALDIFF 0x02
 
@@ -408,6 +419,28 @@ void cChannel::SetSubtitlingDescriptors(uchar *SubtitlingTypes, uint16_t *Compos
      }
 }
 
+#ifdef USE_TTXTSUBS
+void cChannel::SetTeletextSubtitlePages(tTeletextSubtitlePage pages[], int numberOfPages)
+{
+  int mod = CHANNELMOD_NONE;
+  if (totalTtxtSubtitlePages != (fixedTtxtSubtitlePages + numberOfPages))
+     mod |= CHANNELMOD_PIDS;
+  totalTtxtSubtitlePages = fixedTtxtSubtitlePages;
+  for (int i = 0; (i < numberOfPages) && (totalTtxtSubtitlePages < MAXTXTPAGES); i++) {
+      if (teletextSubtitlePages[totalTtxtSubtitlePages].ttxtMagazine != pages[i].ttxtMagazine ||
+          teletextSubtitlePages[totalTtxtSubtitlePages].ttxtPage != pages[i].ttxtPage ||
+          teletextSubtitlePages[totalTtxtSubtitlePages].ttxtType != pages[i].ttxtType ||
+          strcmp(teletextSubtitlePages[totalTtxtSubtitlePages].ttxtLanguage, pages[i].ttxtLanguage)) {
+         mod |= CHANNELMOD_PIDS;
+         teletextSubtitlePages[totalTtxtSubtitlePages] = pages[i];
+         }
+      totalTtxtSubtitlePages++;
+      }
+  modification |= mod;
+  Channels.SetModified();
+}
+#endif // USE_TTXTSUBS
+
 void cChannel::SetCaIds(const int *CaIds)
 {
   if (caids[0] && caids[0] <= CA_USER_MAX)
@@ -536,10 +569,23 @@ cString cChannel::ToText(const cChannel *Channel)
         q += IntArrayToString(q, Channel->dpids, 10, Channel->dlangs, Channel->dtypes);
         }
      *q = 0;
+#ifdef USE_TTXTSUBS
+     const int TBufferSize = (MAXTXTPAGES * MAXSPIDS) * (5 + 1 + MAXLANGCODE2) + 10; // 5 digits plus delimiting ',' or ';' plus optional '=cod+cod', +10: paranoia and tpid
+#else
      const int TBufferSize = MAXSPIDS * (5 + 1 + MAXLANGCODE2) + 10; // 5 digits plus delimiting ',' or ';' plus optional '=cod+cod', +10: paranoia and tpid
+#endif
      char tpidbuf[TBufferSize];
      q = tpidbuf;
      q += snprintf(q, sizeof(tpidbuf), "%d", Channel->tpid);
+#ifdef USE_TTXTSUBS
+     if (Channel->fixedTtxtSubtitlePages > 0) {
+        *q++ = '+';
+        for (int i = 0; i < Channel->fixedTtxtSubtitlePages; ++i) {
+            tTeletextSubtitlePage page = Channel->teletextSubtitlePages[i];
+            q += snprintf(q, sizeof(tpidbuf) - (q - tpidbuf), "%d=%s", page.PageNumber(), page.ttxtLanguage);
+            }
+        }
+#endif // USE_TTXTSUBS
      if (Channel->spids[0]) {
         *q++ = ';';
         q += IntArrayToString(q, Channel->spids, 10, Channel->slangs);
@@ -710,6 +756,34 @@ bool cChannel::Parse(const char *s)
                     }
               spids[NumSpids] = 0;
               }
+#ifdef USE_TTXTSUBS
+           fixedTtxtSubtitlePages = 0;
+           if ((p = strchr(tpidbuf, '+')) != NULL) {
+              *p++ = 0;
+              char *q;
+              char *strtok_next;
+              while ((q = strtok_r(p, ",", &strtok_next)) != NULL) {
+                    if (fixedTtxtSubtitlePages < MAXTXTPAGES) {
+                       int page;
+                       char *l = strchr(q, '=');
+                       if (l)
+                          *l++ = 0;
+                       if (sscanf(q, "%d", &page) == 1) {
+                          teletextSubtitlePages[fixedTtxtSubtitlePages] = tTeletextSubtitlePage(page);
+                          if (l)
+                             strn0cpy(teletextSubtitlePages[fixedTtxtSubtitlePages].ttxtLanguage, l, MAXLANGCODE2);
+                          fixedTtxtSubtitlePages++;
+                          }
+                       else
+                          esyslog("ERROR: invalid Teletext page!"); // no need to set ok to 'false'
+                       }
+                    else
+                       esyslog("ERROR: too many Teletext pages!"); // no need to set ok to 'false'
+                    p = NULL;
+                    }
+              totalTtxtSubtitlePages = fixedTtxtSubtitlePages;
+              }
+#endif // USE_TTXTSUBS
            if (sscanf(tpidbuf, "%d", &tpid) != 1)
               return false;
            if (caidbuf) {
@@ -826,6 +900,50 @@ bool cChannels::Load(const char *FileName, bool AllowComments, bool MustExist)
   return false;
 }
 
+#ifdef USE_ALTERNATECHANNEL
+bool cChannels::LoadAlternativeChannels(const char *FileName)
+{
+  FILE *fp;
+  char *line;
+  cReadLine ReadLine;
+  cChannel *origChannel;
+  tChannelID channelID;
+  if ((fp = fopen(FileName,"r"))==NULL)
+  {
+    esyslog("Can't open Alternative Channels-File <%s>",FileName);
+    return false;
+  }
+  while ((line = ReadLine.Read(fp)) != NULL)
+  {
+    if (line[0] != '#')
+    {
+      line=strtok(line, ";");
+      if (line != NULL)
+      {
+        channelID = tChannelID::FromString(line);
+        if (channelID == tChannelID::InvalidID)
+          dsyslog("Skipping invalid channel ID <%s>",line);
+        else {
+          origChannel = Channels.GetByChannelID(channelID);
+          if (!origChannel)
+            dsyslog("Skipping unknown channel ID <%s>",line);
+          else {
+            line=strtok(NULL, ";");
+            channelID = tChannelID::FromString(line);
+            if (channelID == tChannelID::InvalidID || !Channels.GetByChannelID(channelID))
+              dsyslog("Skipping invalid/unknown alternative channel ID <%s>",line);
+            else
+              origChannel->SetAlternativeChannelID(line);
+          }
+        }
+      }
+    }
+  } while (line != NULL);
+  fclose(fp);
+  return true;
+}
+#endif /* ALTERNATECHANNEL */
+
 void cChannels::HashChannel(cChannel *Channel)
 {
   channelsHashSid.Add(Channel, Channel->Sid());
diff --git a/channels.h b/channels.h
index 815cb47..054dbde 100644
--- a/channels.h
+++ b/channels.h
@@ -35,6 +35,9 @@
 #define MAXDPIDS 16 // dolby (AC3 + DTS)
 #define MAXSPIDS 32 // subtitles
 #define MAXCAIDS 12 // conditional access
+#ifdef USE_TTXTSUBS
+#define MAXTXTPAGES 8 // teletext pages
+#endif // USE_TTXTSUBS
 
 #define MAXLANGCODE1 4 // a 3 letter language code, zero terminated
 #define MAXLANGCODE2 8 // up to two 3 letter language codes, separated by '+' and zero terminated
@@ -71,6 +74,17 @@ public:
   static const tChannelID InvalidID;
   };
 
+#ifdef USE_TTXTSUBS
+struct tTeletextSubtitlePage {
+  tTeletextSubtitlePage(void) { ttxtPage = ttxtMagazine = 0; ttxtType = 0x02; strcpy(ttxtLanguage, "und"); }
+  tTeletextSubtitlePage(int page) { ttxtMagazine = (page / 100) & 0x7; ttxtPage = (((page % 100) / 10) << 4) + (page % 10); ttxtType = 0x02; strcpy(ttxtLanguage, "und"); }
+  char ttxtLanguage[MAXLANGCODE1];
+  uchar ttxtPage;
+  uchar ttxtMagazine;
+  uchar ttxtType;
+  int PageNumber(void) const { return BCDCHARTOINT(ttxtMagazine) * 100 + BCDCHARTOINT(ttxtPage); }
+  };
+#endif // USE_TTXTSUBS
 class cChannel;
 
 class cLinkChannel : public cListObject {
@@ -96,6 +110,9 @@ private:
   char *shortName;
   char *provider;
   char *portalName;
+#ifdef USE_ALTERNATECHANNEL
+  tChannelID alternativeChannelID;
+#endif /* ALTERNATECHANNEL */
   int __BeginData__;
   int frequency; // MHz
   int source;
@@ -115,6 +132,11 @@ private:
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   int tpid;
+#ifdef USE_TTXTSUBS
+  int fixedTtxtSubtitlePages;
+  int totalTtxtSubtitlePages;
+  tTeletextSubtitlePage teletextSubtitlePages[MAXTXTPAGES];
+#endif // USE_TTXTSUBS
   int caids[MAXCAIDS + 1]; // list is zero-terminated
   int nid;
   int tid;
@@ -143,6 +165,9 @@ public:
   const char *ShortName(bool OrName = false) const;
   const char *Provider(void) const { return provider; }
   const char *PortalName(void) const { return portalName; }
+#ifdef USE_ALTERNATECHANNEL
+  const tChannelID AlternativeChannelID(void) const { return alternativeChannelID; }
+#endif /* ALTERNATECHANNEL */
   int Frequency(void) const { return frequency; } ///< Returns the actual frequency, as given in 'channels.conf'
   int Transponder(void) const;                    ///< Returns the transponder frequency in MHz, plus the polarization in case of sat
   static int Transponder(int Frequency, char Polarization); ///< builds the transponder from the given Frequency and Polarization
@@ -166,6 +191,10 @@ public:
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
   int Tpid(void) const { return tpid; }
+#ifdef USE_TTXTSUBS
+  const tTeletextSubtitlePage *TeletextSubtitlePages() const { return teletextSubtitlePages; }
+  int TotalTeletextSubtitlePages() const { return totalTtxtSubtitlePages; }
+#endif // USE_TTXTSUBS
   const int *Caids(void) const { return caids; }
   int Ca(int Index = 0) const { return Index < MAXCAIDS ? caids[Index] : 0; }
   int Nid(void) const { return nid; }
@@ -191,7 +220,13 @@ public:
   void SetId(int Nid, int Tid, int Sid, int Rid = 0);
   void SetName(const char *Name, const char *ShortName, const char *Provider);
   void SetPortalName(const char *PortalName);
+#ifdef USE_ALTERNATECHANNEL
+  void SetAlternativeChannelID(const char *AlternativeChannelID);
+#endif /* ALTERNATECHANNEL */
   void SetPids(int Vpid, int Ppid, int Vtype, int *Apids, int *Atypes, char ALangs[][MAXLANGCODE2], int *Dpids, int *Dtypes, char DLangs[][MAXLANGCODE2], int *Spids, char SLangs[][MAXLANGCODE2], int Tpid);
+#ifdef USE_TTXTSUBS
+  void SetTeletextSubtitlePages(tTeletextSubtitlePage pages[], int numberOfPages);
+#endif // USE_TTXTSUBS
   void SetCaIds(const int *CaIds); // list must be zero-terminated
   void SetCaDescriptors(int Level);
   void SetLinkChannels(cLinkChannels *LinkChannels);
@@ -211,6 +246,9 @@ private:
 public:
   cChannels(void);
   bool Load(const char *FileName, bool AllowComments = false, bool MustExist = false);
+#ifdef USE_ALTERNATECHANNEL
+  bool LoadAlternativeChannels(const char *FileName);
+#endif /* ALTERNATECHANNEL */
   void HashChannel(cChannel *Channel);
   void UnhashChannel(cChannel *Channel);
   int GetNextGroup(int Idx);   // Get next channel group
diff --git a/ci.c b/ci.c
index ebed320..d7791b9 100644
--- a/ci.c
+++ b/ci.c
@@ -1914,6 +1914,10 @@ void cCamSlot::AddChannel(const cChannel *Channel)
          AddPid(Channel->Sid(), *Dpid, STREAM_TYPE_PRIVATE);
      for (const int *Spid = Channel->Spids(); *Spid; Spid++)
          AddPid(Channel->Sid(), *Spid, STREAM_TYPE_PRIVATE);
+#ifdef USE_TTXTSUBS
+     if (Channel->Tpid() && Setup.SupportTeletext)
+        AddPid(Channel->Sid(), Channel->Tpid(), STREAM_TYPE_PRIVATE);
+#endif // USE_TTXTSUBS
      }
 }
 
@@ -1937,6 +1941,11 @@ bool cCamSlot::CanDecrypt(const cChannel *Channel)
          CaPmt.AddPid(*Dpid, STREAM_TYPE_PRIVATE);
      for (const int *Spid = Channel->Spids(); *Spid; Spid++)
          CaPmt.AddPid(*Spid, STREAM_TYPE_PRIVATE); 
+#ifdef USE_TTXTSUBS
+     if (Channel->Tpid() && Setup.SupportTeletext) {
+        CaPmt.AddPid(Channel->Tpid(), STREAM_TYPE_PRIVATE);
+        }
+#endif // USE_TTXTSUBS
      cas->SendPMT(&CaPmt);
      cTimeMs Timeout(QUERY_REPLY_TIMEOUT);
      do {
diff --git a/config.c b/config.c
index 56454df..839f0dc 100644
--- a/config.c
+++ b/config.c
@@ -375,6 +375,9 @@ cSetup::cSetup(void)
   strcpy(OSDLanguage, ""); // default is taken from environment
   strcpy(OSDSkin, "lcars");
   strcpy(OSDTheme, "default");
+#ifdef USE_WAREAGLEICON
+  WarEagleIcons = 1;
+#endif /* WAREAGLEICON */
   PrimaryDVB = 1;
   ShowInfoOnChSwitch = 1;
   TimeoutRequChInfo = 1;
@@ -396,11 +399,20 @@ cSetup::cSetup(void)
   MarginStop = 10;
   AudioLanguages[0] = -1;
   DisplaySubtitles = 0;
+#ifdef USE_TTXTSUBS
+  SupportTeletext = 0;
+#endif // USE_TTXTSUBS
   SubtitleLanguages[0] = -1;
   SubtitleOffset = 0;
   SubtitleFgTransparency = 0;
   SubtitleBgTransparency = 0;
   EPGLanguages[0] = -1;
+#ifdef USE_DDEPGENTRY
+  DoubleEpgTimeDelta = 15;
+  DoubleEpgAction = 0;
+  MixEpgAction = 0;
+  DisableVPS = 0;
+#endif /* DDEPGENTRY */
   EPGScanTimeout = 5;
   EPGBugfixLevel = 3;
   EPGLinger = 0;
@@ -421,6 +433,9 @@ cSetup::cSetup(void)
   VideoDisplayFormat = 1;
   VideoFormat = 0;
   UpdateChannels = 5;
+#ifdef USE_CHANNELBIND
+  ChannelBindingByRid = 0;
+#endif /* CHANNELBIND */
   UseDolbyDigital = 1;
   ChannelInfoPos = 0;
   ChannelInfoTime = 5;
@@ -446,8 +461,15 @@ cSetup::cSetup(void)
   FontSmlSize = 18;
   FontFixSize = 20;
   MaxVideoFileSize = MAXVIDEOFILESIZEDEFAULT;
+#ifdef USE_HARDLINKCUTTER
+  MaxRecordingSize = DEFAULTRECORDINGSIZE;
+  HardLinkCutter = 0;
+#endif /* HARDLINKCUTTER */
   SplitEditedFiles = 0;
   DelTimeshiftRec = 0;
+#ifdef USE_NALUDUMP
+  DumpNaluFill = 0;
+#endif // USE_NALUDUMP
   MinEventTimeout = 30;
   MinUserInactivity = 300;
   NextWakeupTime = 0;
@@ -455,15 +477,45 @@ cSetup::cSetup(void)
   ShowReplayMode = 0;
   ShowRemainingTime = 0;
   ResumeID = 0;
+#ifdef USE_JUMPPLAY
+  JumpPlay = 0;
+  PlayJump = 0;
+  PauseLastMark = 0;
+#endif /* JUMPPLAY */
   CurrentChannel = -1;
   CurrentVolume = MAXVOLUME;
   CurrentDolby = 0;
   InitialChannel = "";
   DeviceBondings = "";
   InitialVolume = -1;
+#ifdef USE_VOLCTRL
+  LRVolumeControl = 0;
+  LRChannelGroups = 1;
+  LRForwardRewind = 1;
+#endif // USE_VOLCTRL
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+#ifdef USE_JUMPINGSECONDS
+  JumpSeconds = 60;
+  JumpSecondsSlow = 10;
+  JumpSecondsRepeat = 300;
+#endif // USE_JUMPINGSECONDS
+#ifdef USE_LIRCSETTINGS
+  LircRepeatDelay = 350;
+  LircRepeatFreq = 100;
+  LircRepeatTimeout = 500;
+#endif /* LIRCSETTINGS */
+#ifdef USE_DVLVIDPREFER
+  UseVidPrefer = 0; // default = disabled
+  nVidPrefer = 1;
+  for (int zz = 1; zz < DVLVIDPREFER_MAX; zz++) {
+      VidPreferPrio[ zz ] = 50;
+      VidPreferSize[ zz ] = 100;
+      }
+  VidPreferSize[ 0 ] = 800;
+  VidPreferPrio[ 0 ] = 50;
+#endif /* DVLVIDPREFER */
 }
 
 cSetup& cSetup::operator= (const cSetup &s)
@@ -571,6 +623,9 @@ bool cSetup::Parse(const char *Name, const char *Value)
   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
   else if (!strcasecmp(Name, "OSDSkin"))             Utf8Strn0Cpy(OSDSkin, Value, MaxSkinName);
   else if (!strcasecmp(Name, "OSDTheme"))            Utf8Strn0Cpy(OSDTheme, Value, MaxThemeName);
+#ifdef USE_WAREAGLEICON
+  else if (!strcasecmp(Name, "WarEagleIcons"))       WarEagleIcons      = atoi(Value);
+#endif /* WAREAGLEICON */
   else if (!strcasecmp(Name, "PrimaryDVB"))          PrimaryDVB         = atoi(Value);
   else if (!strcasecmp(Name, "ShowInfoOnChSwitch"))  ShowInfoOnChSwitch = atoi(Value);
   else if (!strcasecmp(Name, "TimeoutRequChInfo"))   TimeoutRequChInfo  = atoi(Value);
@@ -592,11 +647,20 @@ bool cSetup::Parse(const char *Name, const char *Value)
   else if (!strcasecmp(Name, "MarginStop"))          MarginStop         = atoi(Value);
   else if (!strcasecmp(Name, "AudioLanguages"))      return ParseLanguages(Value, AudioLanguages);
   else if (!strcasecmp(Name, "DisplaySubtitles"))    DisplaySubtitles   = atoi(Value);
+#ifdef USE_TTXTSUBS
+  else if (!strcasecmp(Name, "SupportTeletext"))     SupportTeletext    = atoi(Value);
+#endif // USE_TTXTSUBS
   else if (!strcasecmp(Name, "SubtitleLanguages"))   return ParseLanguages(Value, SubtitleLanguages);
   else if (!strcasecmp(Name, "SubtitleOffset"))      SubtitleOffset     = atoi(Value);
   else if (!strcasecmp(Name, "SubtitleFgTransparency")) SubtitleFgTransparency = atoi(Value);
   else if (!strcasecmp(Name, "SubtitleBgTransparency")) SubtitleBgTransparency = atoi(Value);
   else if (!strcasecmp(Name, "EPGLanguages"))        return ParseLanguages(Value, EPGLanguages);
+#ifdef USE_DDEPGENTRY
+  else if (!strcasecmp(Name, "DoubleEpgTimeDelta"))  DoubleEpgTimeDelta = atoi(Value);
+  else if (!strcasecmp(Name, "DoubleEpgAction"))     DoubleEpgAction    = atoi(Value);
+  else if (!strcasecmp(Name, "MixEpgAction"))        MixEpgAction       = atoi(Value);
+  else if (!strcasecmp(Name, "DisableVPS"))          DisableVPS         = atoi(Value);
+#endif /* DDEPGENTRY */
   else if (!strcasecmp(Name, "EPGScanTimeout"))      EPGScanTimeout     = atoi(Value);
   else if (!strcasecmp(Name, "EPGBugfixLevel"))      EPGBugfixLevel     = atoi(Value);
   else if (!strcasecmp(Name, "EPGLinger"))           EPGLinger          = atoi(Value);
@@ -617,6 +681,9 @@ bool cSetup::Parse(const char *Name, const char *Value)
   else if (!strcasecmp(Name, "VideoDisplayFormat"))  VideoDisplayFormat = atoi(Value);
   else if (!strcasecmp(Name, "VideoFormat"))         VideoFormat        = atoi(Value);
   else if (!strcasecmp(Name, "UpdateChannels"))      UpdateChannels     = atoi(Value);
+#ifdef USE_CHANNELBIND
+  else if (!strcasecmp(Name, "ChannelBindingByRid")) ChannelBindingByRid= atoi(Value);
+#endif /* CHANNELBIND */
   else if (!strcasecmp(Name, "UseDolbyDigital"))     UseDolbyDigital    = atoi(Value);
   else if (!strcasecmp(Name, "ChannelInfoPos"))      ChannelInfoPos     = atoi(Value);
   else if (!strcasecmp(Name, "ChannelInfoTime"))     ChannelInfoTime    = atoi(Value);
@@ -642,8 +709,15 @@ bool cSetup::Parse(const char *Name, const char *Value)
   else if (!strcasecmp(Name, "FontSmlSize"))         FontSmlSize        = atoi(Value);
   else if (!strcasecmp(Name, "FontFixSize"))         FontFixSize        = atoi(Value);
   else if (!strcasecmp(Name, "MaxVideoFileSize"))    MaxVideoFileSize   = atoi(Value);
+#ifdef USE_HARDLINKCUTTER
+  else if (!strcasecmp(Name, "MaxRecordingSize"))    MaxRecordingSize   = atoi(Value);
+  else if (!strcasecmp(Name, "HardLinkCutter"))      HardLinkCutter     = atoi(Value);
+#endif /* HARDLINKCUTTER */
   else if (!strcasecmp(Name, "SplitEditedFiles"))    SplitEditedFiles   = atoi(Value);
   else if (!strcasecmp(Name, "DelTimeshiftRec"))     DelTimeshiftRec    = atoi(Value);
+#ifdef USE_NALUDUMP
+  else if (!strcasecmp(Name, "DumpNaluFill"))        DumpNaluFill       = atoi(Value);
+#endif // USE_NALUDUMP
   else if (!strcasecmp(Name, "MinEventTimeout"))     MinEventTimeout    = atoi(Value);
   else if (!strcasecmp(Name, "MinUserInactivity"))   MinUserInactivity  = atoi(Value);
   else if (!strcasecmp(Name, "NextWakeupTime"))      NextWakeupTime     = atoi(Value);
@@ -651,15 +725,63 @@ bool cSetup::Parse(const char *Name, const char *Value)
   else if (!strcasecmp(Name, "ShowReplayMode"))      ShowReplayMode     = atoi(Value);
   else if (!strcasecmp(Name, "ShowRemainingTime"))   ShowRemainingTime  = atoi(Value);
   else if (!strcasecmp(Name, "ResumeID"))            ResumeID           = atoi(Value);
+#ifdef USE_JUMPPLAY
+  else if (!strcasecmp(Name, "JumpPlay"))            JumpPlay           = atoi(Value);
+  else if (!strcasecmp(Name, "PlayJump"))            PlayJump           = atoi(Value);
+  else if (!strcasecmp(Name, "PauseLastMark"))       PauseLastMark      = atoi(Value);
+#endif /* JUMPPLAY */
   else if (!strcasecmp(Name, "CurrentChannel"))      CurrentChannel     = atoi(Value);
   else if (!strcasecmp(Name, "CurrentVolume"))       CurrentVolume      = atoi(Value);
   else if (!strcasecmp(Name, "CurrentDolby"))        CurrentDolby       = atoi(Value);
   else if (!strcasecmp(Name, "InitialChannel"))      InitialChannel     = Value;
   else if (!strcasecmp(Name, "InitialVolume"))       InitialVolume      = atoi(Value);
+#ifdef USE_VOLCTRL
+  else if (!strcasecmp(Name, "LRVolumeControl"))     LRVolumeControl    = atoi(Value);
+  else if (!strcasecmp(Name, "LRChannelGroups"))     LRChannelGroups    = atoi(Value);
+  else if (!strcasecmp(Name, "LRForwardRewind"))     LRForwardRewind    = atoi(Value);
+#endif // USE_VOLCTRL
   else if (!strcasecmp(Name, "DeviceBondings"))      DeviceBondings     = Value;
   else if (!strcasecmp(Name, "ChannelsWrap"))        ChannelsWrap       = atoi(Value);
   else if (!strcasecmp(Name, "ShowChannelNamesWithSource")) ShowChannelNamesWithSource = atoi(Value);
   else if (!strcasecmp(Name, "EmergencyExit"))       EmergencyExit      = atoi(Value);
+#ifdef USE_JUMPINGSECONDS
+  else if (!strcasecmp(Name, "JumpSeconds"))         JumpSeconds        = atoi(Value);
+  else if (!strcasecmp(Name, "JumpSecondsSlow"))     JumpSecondsSlow    = atoi(Value);
+  else if (!strcasecmp(Name, "JumpSecondsRepeat"))   JumpSecondsRepeat  = atoi(Value);
+#endif // USE_JUMPINGSECONDS
+#ifdef USE_LIRCSETTINGS
+  else if (!strcasecmp(Name, "LircRepeatDelay"))     LircRepeatDelay    = atoi(Value);
+  else if (!strcasecmp(Name, "LircRepeatFreq"))      LircRepeatFreq     = atoi(Value);
+  else if (!strcasecmp(Name, "LircRepeatTimeout"))   LircRepeatTimeout  = atoi(Value);
+#endif /* LIRCSETTINGS */
+#ifdef USE_DVLVIDPREFER
+  else if (strcasecmp(Name, "UseVidPrefer") == 0)    UseVidPrefer       = atoi(Value);
+  else if (strcasecmp(Name, "nVidPrefer") == 0)      nVidPrefer         = atoi(Value);
+  else if (strstr(Name, "VidPrefer") == Name) {
+     char *x = (char *)&Name[ strlen(Name) - 1 ];
+     int vN;
+
+     if (isdigit(*x) != 0) {
+        while (isdigit(*x) != 0)
+              x--;
+        x++;
+        }
+
+     vN = atoi(x);
+     if (vN < DVLVIDPREFER_MAX) {
+        if (strstr(Name, "VidPreferPrio") == Name) {
+           VidPreferPrio[ vN ] = atoi(Value);
+           if (VidPreferPrio[ vN ] > 99)
+              VidPreferPrio[ vN ] = 99;
+           }
+        else if (strstr(Name, "VidPreferSize") == Name) {
+           VidPreferSize[ vN ] = atoi(Value);
+           }
+        else
+           return false;
+        }
+     }
+#endif /* DVLVIDPREFER */
   else
      return false;
   return true;
@@ -670,6 +792,9 @@ bool cSetup::Save(void)
   Store("OSDLanguage",        OSDLanguage);
   Store("OSDSkin",            OSDSkin);
   Store("OSDTheme",           OSDTheme);
+#ifdef USE_WAREAGLEICON
+  Store("WarEagleIcons",      WarEagleIcons);
+#endif /* WAREAGLEICON */
   Store("PrimaryDVB",         PrimaryDVB);
   Store("ShowInfoOnChSwitch", ShowInfoOnChSwitch);
   Store("TimeoutRequChInfo",  TimeoutRequChInfo);
@@ -691,11 +816,20 @@ bool cSetup::Save(void)
   Store("MarginStop",         MarginStop);
   StoreLanguages("AudioLanguages", AudioLanguages);
   Store("DisplaySubtitles",   DisplaySubtitles);
+#ifdef USE_TTXTSUBS
+  Store("SupportTeletext",    SupportTeletext);
+#endif // USE_TTXTSUBS
   StoreLanguages("SubtitleLanguages", SubtitleLanguages);
   Store("SubtitleOffset",     SubtitleOffset);
   Store("SubtitleFgTransparency", SubtitleFgTransparency);
   Store("SubtitleBgTransparency", SubtitleBgTransparency);
   StoreLanguages("EPGLanguages", EPGLanguages);
+#ifdef USE_DDEPGENTRY
+  Store("DoubleEpgTimeDelta", DoubleEpgTimeDelta);
+  Store("DoubleEpgAction",    DoubleEpgAction);
+  Store("MixEpgAction",       MixEpgAction);
+  Store("DisableVPS",         DisableVPS);
+#endif /* DDEPGENTRY */
   Store("EPGScanTimeout",     EPGScanTimeout);
   Store("EPGBugfixLevel",     EPGBugfixLevel);
   Store("EPGLinger",          EPGLinger);
@@ -716,6 +850,9 @@ bool cSetup::Save(void)
   Store("VideoDisplayFormat", VideoDisplayFormat);
   Store("VideoFormat",        VideoFormat);
   Store("UpdateChannels",     UpdateChannels);
+#ifdef USE_CHANNELBIND
+  Store("ChannelBindingByRid",ChannelBindingByRid);
+#endif /* CHANNELBIND */
   Store("UseDolbyDigital",    UseDolbyDigital);
   Store("ChannelInfoPos",     ChannelInfoPos);
   Store("ChannelInfoTime",    ChannelInfoTime);
@@ -743,6 +880,9 @@ bool cSetup::Save(void)
   Store("MaxVideoFileSize",   MaxVideoFileSize);
   Store("SplitEditedFiles",   SplitEditedFiles);
   Store("DelTimeshiftRec",    DelTimeshiftRec);
+#ifdef USE_NALUDUMP
+  Store("DumpNaluFill",       DumpNaluFill);
+#endif // USE_NALUDUMP
   Store("MinEventTimeout",    MinEventTimeout);
   Store("MinUserInactivity",  MinUserInactivity);
   Store("NextWakeupTime",     NextWakeupTime);
@@ -750,15 +890,51 @@ bool cSetup::Save(void)
   Store("ShowReplayMode",     ShowReplayMode);
   Store("ShowRemainingTime",  ShowRemainingTime);
   Store("ResumeID",           ResumeID);
+#ifdef USE_JUMPPLAY
+  Store("JumpPlay",           JumpPlay);
+  Store("PlayJump",           PlayJump);
+  Store("PauseLastMark",      PauseLastMark);
+#endif /* JUMPPLAY */
   Store("CurrentChannel",     CurrentChannel);
   Store("CurrentVolume",      CurrentVolume);
   Store("CurrentDolby",       CurrentDolby);
+#ifdef USE_HARDLINKCUTTER
+  Store("MaxRecordingSize",   MaxRecordingSize);
+  Store("HardLinkCutter",     HardLinkCutter);
+#endif /* HARDLINKCUTTER */
   Store("InitialChannel",     InitialChannel);
   Store("InitialVolume",      InitialVolume);
+#ifdef USE_VOLCTRL
+  Store("LRVolumeControl",    LRVolumeControl);
+  Store("LRChannelGroups",    LRChannelGroups);
+  Store("LRForwardRewind",    LRForwardRewind);
+#endif // USE_VOLCTRL
   Store("DeviceBondings",     DeviceBondings);
   Store("ChannelsWrap",       ChannelsWrap);
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
+#ifdef USE_JUMPINGSECONDS
+  Store("JumpSeconds",        JumpSeconds);
+  Store("JumpSecondsSlow",    JumpSecondsSlow);
+  Store("JumpSecondsRepeat",  JumpSecondsRepeat);
+#endif // USE_JUMPINGSECONDS
+#ifdef USE_LIRCSETTINGS
+  Store("LircRepeatDelay",    LircRepeatDelay);
+  Store("LircRepeatFreq",     LircRepeatFreq);
+  Store("LircRepeatTimeout",  LircRepeatTimeout);
+#endif /* LIRCSETTINGS */
+#ifdef USE_DVLVIDPREFER
+  Store ("UseVidPrefer",      UseVidPrefer);
+  Store ("nVidPrefer",        nVidPrefer);
+
+  char vidBuf[32];
+  for (int zz = 0; zz < nVidPrefer; zz++) {
+      sprintf(vidBuf, "VidPreferPrio%d", zz);
+      Store (vidBuf, VidPreferPrio[zz]);
+      sprintf(vidBuf, "VidPreferSize%d", zz);
+      Store (vidBuf, VidPreferSize[zz]);
+      }
+#endif /* DVLVIDPREFER */
 
   Sort();
 
diff --git a/config.h b/config.h
index acdf77a..e53fffb 100644
--- a/config.h
+++ b/config.h
@@ -30,12 +30,34 @@
 #define APIVERSION  "1.7.29"
 #define APIVERSNUM   10729  // Version * 10000 + Major * 100 + Minor
 
+#ifdef USE_YAEPG
+#define YAEPGHDVERSNUM 1
+#endif /* YAEPG */
+
 // When loading plugins, VDR searches them by their APIVERSION, which
 // may be smaller than VDRVERSION in case there have been no changes to
 // VDR header files since the last APIVERSION. This allows compiled
 // plugins to work with newer versions of the core VDR as long as no
 // VDR header files have changed.
 
+#ifdef USE_CHANNELBIND
+#define CHANNELBINDINGVERSNUM 2
+#endif /* CHANNELBIND */
+
+#ifdef USE_MAINMENUHOOKS
+// The MainMenuHook Patch's version number:
+#define MAINMENUHOOKSVERSION "1.0.1"
+#define MAINMENUHOOKSVERSNUM 10001  // Version * 10000 + Major * 100 + Minor
+#endif /* MAINMENUHOOKS */
+
+#ifdef USE_JUMPPLAY
+#define JUMPPLAYVERSNUM 100
+#endif /* JUMPPLAY */
+
+#ifdef USE_LIEMIKUUTIO
+#define LIEMIKUUTIO  134
+#endif /* LIEMIKUUTIO */
+
 #define MAXPRIORITY       99
 #define MINPRIORITY       (-MAXPRIORITY)
 #define LIVEPRIORITY      0                  // priority used when selecting a device for live viewing
@@ -43,6 +65,10 @@
 #define IDLEPRIORITY      (MINPRIORITY - 1)  // priority of an idle device
 #define MAXLIFETIME       99
 
+#ifdef USE_DVLVIDPREFER
+#define DVLVIDPREFER_MAX 12
+#endif /* DVLVIDPREFER */
+
 #define MINOSDWIDTH   480
 #define MAXOSDWIDTH  1920
 #define MINOSDHEIGHT  324
@@ -249,6 +275,9 @@ public:
   char OSDLanguage[I18N_MAX_LOCALE_LEN];
   char OSDSkin[MaxSkinName];
   char OSDTheme[MaxThemeName];
+#ifdef USE_WAREAGLEICON
+  int WarEagleIcons;
+#endif /* WAREAGLEICON */
   int PrimaryDVB;
   int ShowInfoOnChSwitch;
   int TimeoutRequChInfo;
@@ -269,10 +298,19 @@ public:
   int MarginStart, MarginStop;
   int AudioLanguages[I18N_MAX_LANGUAGES + 1];
   int DisplaySubtitles;
+#ifdef USE_TTXTSUBS
+  int SupportTeletext;
+#endif // USE_TTXTSUBS
   int SubtitleLanguages[I18N_MAX_LANGUAGES + 1];
   int SubtitleOffset;
   int SubtitleFgTransparency, SubtitleBgTransparency;
   int EPGLanguages[I18N_MAX_LANGUAGES + 1];
+#ifdef USE_DDEPGENTRY
+  int DoubleEpgTimeDelta;
+  int DoubleEpgAction;
+  int MixEpgAction;
+  int DisableVPS;
+#endif /* DDEPPGENTRY */
   int EPGScanTimeout;
   int EPGBugfixLevel;
   int EPGLinger;
@@ -291,6 +329,9 @@ public:
   int VideoDisplayFormat;
   int VideoFormat;
   int UpdateChannels;
+#ifdef USE_CHANNELBIND
+  int ChannelBindingByRid;
+#endif /* CHANNELBIND */
   int UseDolbyDigital;
   int ChannelInfoPos;
   int ChannelInfoTime;
@@ -310,8 +351,15 @@ public:
   int FontSmlSize;
   int FontFixSize;
   int MaxVideoFileSize;
+#ifdef USE_HARDLINKCUTTER
+  int MaxRecordingSize;
+  int HardLinkCutter;
+#endif /* HARDLINKCUTTER */
   int SplitEditedFiles;
   int DelTimeshiftRec;
+#ifdef USE_NALUDUMP
+  int DumpNaluFill;
+#endif // USE_NALUDUMP
   int MinEventTimeout, MinUserInactivity;
   time_t NextWakeupTime;
   int MultiSpeedMode;
@@ -319,12 +367,38 @@ public:
   int ShowRemainingTime;
   int ResumeID;
   int CurrentChannel;
+#ifdef USE_JUMPPLAY
+  int JumpPlay;
+  int PlayJump;
+  int PauseLastMark;
+#endif /* JUMPPLAY */
   int CurrentVolume;
   int CurrentDolby;
   int InitialVolume;
+#ifdef USE_VOLCTRL
+  int LRVolumeControl;
+  int LRChannelGroups;
+  int LRForwardRewind;
+#endif // USE_VOLCTRL
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+#ifdef USE_JUMPINGSECONDS
+  int JumpSeconds;
+  int JumpSecondsSlow;
+  int JumpSecondsRepeat;
+#endif // USE_JUMPINGSECONDS
+#ifdef USE_LIRCSETTINGS
+  int LircRepeatDelay;
+  int LircRepeatFreq;
+  int LircRepeatTimeout;
+#endif /* LIRCSETTINGS */
+#ifdef USE_DVLVIDPREFER
+  int UseVidPrefer;  // 0 = VDR's default, 1 = use
+  int nVidPrefer;
+  int VidPreferPrio[DVLVIDPREFER_MAX];
+  int VidPreferSize[DVLVIDPREFER_MAX];
+#endif /* DVLVIDPREFER */
   int __EndData__;
   cString InitialChannel;
   cString DeviceBondings;
diff --git a/cutter.c b/cutter.c
index 62eae82..5845f5d 100644
--- a/cutter.c
+++ b/cutter.c
@@ -8,6 +8,9 @@
  */
 
 #include "cutter.h"
+#ifdef USE_LIEMIKUUTIO
+#include "interface.h"
+#endif /* LIEMIKUUTIO */
 #include "menu.h"
 #include "recording.h"
 #include "remux.h"
@@ -15,6 +18,19 @@
 
 // --- cCuttingThread --------------------------------------------------------
 
+#ifdef USE_CUTTERLIMIT
+#ifndef CUTTER_MAX_BANDWIDTH
+#define CUTTER_MAX_BANDWIDTH MEGABYTE(10) // 10 MB/s
+#endif
+#ifndef CUTTER_REL_BANDWIDTH
+#define CUTTER_REL_BANDWIDTH 75 // %
+#endif
+#ifndef CUTTER_PRIORITY
+#define CUTTER_PRIORITY sched_get_priority_min(SCHED_OTHER)
+#endif
+#define CUTTER_TIMESLICE   100   // ms
+#endif /* CUTTERLIMIT */
+
 class cCuttingThread : public cThread {
 private:
   const char *error;
@@ -67,6 +83,22 @@ cCuttingThread::~cCuttingThread()
 
 void cCuttingThread::Action(void)
 {
+#ifdef USE_CUTTERLIMIT
+#ifdef USE_HARDLINKCUTTER
+  if (!Setup.HardLinkCutter)
+#endif /* HARDLINKCUTTER */
+  {
+    sched_param tmp;
+    tmp.sched_priority = CUTTER_PRIORITY;
+    if(!pthread_setschedparam(pthread_self(), SCHED_OTHER, &tmp))
+      printf("cCuttingThread::Action: cant set priority\n");
+  }
+
+  int bytes = 0;
+  int __attribute__((unused)) burst_size = CUTTER_MAX_BANDWIDTH * CUTTER_TIMESLICE / 1000; // max bytes/timeslice
+  cTimeMs __attribute__((unused)) t;
+#endif /* CUTTERLIMIT */
+
   cMark *Mark = fromMarks.First();
   if (Mark) {
      SetPriority(19);
@@ -80,6 +112,9 @@ void cCuttingThread::Action(void)
      Mark = fromMarks.Next(Mark);
      off_t FileSize = 0;
      int CurrentFileNumber = 0;
+#ifdef USE_HARDLINKCUTTER
+     bool SkipThisSourceFile = false;
+#endif /* HARDLINKCUTTER */
      int LastIFrame = 0;
      toMarks.Add(0);
      toMarks.Save();
@@ -100,6 +135,95 @@ void cCuttingThread::Action(void)
 
            // Read one frame:
 
+#ifdef USE_HARDLINKCUTTER
+           if (!fromIndex->Get(Index++, &FileNumber, &FileOffset, &Independent, &Length)) {
+              // Error, unless we're past last cut-in and there's no cut-out
+              if (Mark || LastMark)
+                 error = "index";
+              break;
+              }
+
+           if (FileNumber != CurrentFileNumber) {
+              fromFile = fromFileName->SetOffset(FileNumber, FileOffset);
+              if (fromFile)
+                 fromFile->SetReadAhead(MEGABYTE(20));
+              CurrentFileNumber = FileNumber;
+              if (SkipThisSourceFile) {
+                 // At end of fast forward: Always skip to next file
+                 toFile = toFileName->NextFile();
+                 if (!toFile) {
+                    error = "toFile 4";
+                    break;
+                    }
+                 FileSize = 0;
+                 SkipThisSourceFile = false;
+                 }
+
+
+              if (Setup.HardLinkCutter && FileOffset == 0) {
+                 // We are at the beginning of a new source file.
+                 // Do we need to copy the whole file?
+
+                 // if !Mark && LastMark, then we're past the last cut-out and continue to next I-frame
+                 // if !Mark && !LastMark, then there's just a cut-in, but no cut-out
+                 // if Mark, then we're between a cut-in and a cut-out
+
+                 uint16_t MarkFileNumber;
+                 off_t MarkFileOffset;
+                 // Get file number of next cut mark
+                 if (!Mark && !LastMark
+                     || Mark
+                        && fromIndex->Get(Mark->Position(), &MarkFileNumber, &MarkFileOffset)
+                        && (MarkFileNumber != CurrentFileNumber)) {
+                    // The current source file will be copied completely.
+                    // Start new output file unless we did that already
+                    if (FileSize != 0) {
+                       toFile = toFileName->NextFile();
+                       if (!toFile) {
+                          error = "toFile 3";
+                          break;
+                          }
+                       FileSize = 0;
+                       }
+
+                    // Safety check that file has zero size
+                    struct stat buf;
+                    if (stat(toFileName->Name(), &buf) == 0) {
+                       if (buf.st_size != 0) {
+                          esyslog("cCuttingThread: File %s exists and has nonzero size", toFileName->Name());
+                          error = "nonzero file exist";
+                          break;
+                          }
+                       }
+                    else if (errno != ENOENT) {
+                       esyslog("cCuttingThread: stat failed on %s", toFileName->Name());
+                       error = "stat";
+                       break;
+                       }
+
+                    // Clean the existing 0-byte file
+                    toFileName->Close();
+                    cString ActualToFileName(ReadLink(toFileName->Name()), true);
+                    unlink(ActualToFileName);
+                    unlink(toFileName->Name());
+
+                    // Try to create a hard link
+                    if (HardLinkVideoFile(fromFileName->Name(), toFileName->Name())) {
+                       // Success. Skip all data transfer for this file
+                       SkipThisSourceFile = true;
+                       cutIn = false;
+                       toFile = NULL; // was deleted by toFileName->Close()
+                       }
+                    else {
+                       // Fallback: Re-open the file if necessary
+                       toFile = toFileName->Open();
+                       }
+                    }
+                 }
+              }
+
+           if (!SkipThisSourceFile) {
+#else
            if (fromIndex->Get(Index++, &FileNumber, &FileOffset, &Independent, &Length)) {
               if (FileNumber != CurrentFileNumber) {
                  fromFile = fromFileName->SetOffset(FileNumber, FileOffset);
@@ -107,6 +231,7 @@ void cCuttingThread::Action(void)
                     fromFile->SetReadAhead(MEGABYTE(20));
                  CurrentFileNumber = FileNumber;
                  }
+#endif /* HARDLINKCUTTER */
               if (fromFile) {
                  int len = ReadFrame(fromFile, buffer,  Length, sizeof(buffer));
                  if (len < 0) {
@@ -123,19 +248,25 @@ void cCuttingThread::Action(void)
                  break;
                  }
               }
+#ifndef USE_HARDLINKCUTTER
            else {
               // Error, unless we're past the last cut-in and there's no cut-out
               if (Mark || LastMark)
                  error = "index";
               break;
               }
+#endif /* HARDLINKCUTTER */
 
            // Write one frame:
 
            if (Independent) { // every file shall start with an independent frame
               if (LastMark) // edited version shall end before next I-frame
                  break;
+#ifdef USE_HARDLINKCUTTER
+              if (!SkipThisSourceFile && FileSize > toFileName->MaxFileSize()) {
+#else
               if (FileSize > maxVideoFileSize) {
+#endif /* HARDLINKCUTTER */
                  toFile = toFileName->NextFile();
                  if (!toFile) {
                     error = "toFile 1";
@@ -144,6 +275,10 @@ void cCuttingThread::Action(void)
                  FileSize = 0;
                  }
               LastIFrame = 0;
+
+#ifdef USE_HARDLINKCUTTER
+              if (!SkipThisSourceFile && cutIn) {
+#else
               // Compare the current frame with the previously stored one, to see if this is a seamlessly merged recording of the same stream:
               if (CheckForSeamlessStream) {
                  if (Length == Length2) {
@@ -160,6 +295,7 @@ void cCuttingThread::Action(void)
                  CheckForSeamlessStream = false;
                  }
               if (cutIn) {
+#endif /* HARDLINKCUTTER */
                  if (isPesRecording)
                     cRemux::SetBrokenLink(buffer, Length);
                  else
@@ -167,7 +303,11 @@ void cCuttingThread::Action(void)
                  cutIn = false;
                  }
               }
+#ifdef USE_HARDLINKCUTTER
+           if (!SkipThisSourceFile && toFile->Write(buffer, Length) < 0) {
+#else
            if (toFile->Write(buffer, Length) < 0) {
+#endif /* HARDLINKCUTTER */
               error = "safe_write";
               break;
               }
@@ -212,8 +352,45 @@ void cCuttingThread::Action(void)
                     }
                  }
               else
+#ifdef USE_HARDLINKCUTTER
+                 LastMark = true; // After last cut-out: Write on until next I-frame, then exit
+#else
                  LastMark = true;
+#endif /* HARDLINKCUTTER */
+              }
+
+#ifdef USE_CUTTERLIMIT
+#ifdef USE_HARDLINKCUTTER
+           if (!Setup.HardLinkCutter) {
+#endif /* HARDLINKCUTTER */
+           bytes += Length;
+           if(bytes >= burst_size) {
+             int elapsed = t.Elapsed();
+             int sleep = 0;
+
+#if CUTTER_REL_BANDWIDTH > 0 &&  CUTTER_REL_BANDWIDTH < 100
+             // stay under max. relative bandwidth
+
+             sleep = (elapsed * 100 / CUTTER_REL_BANDWIDTH) - elapsed;
+             //if(sleep<=0 && elapsed<=2) sleep = 1;
+             //if(sleep) esyslog("cutter: relative bandwidth limit, sleep %d ms (chunk %dk / %dms)", sleep, burst_size/1024, CUTTER_TIMESLICE);
+#endif
+             // stay under max. absolute bandwidth
+             if(elapsed < CUTTER_TIMESLICE) {
+               sleep = max(CUTTER_TIMESLICE - elapsed, sleep);
+               //if(sleep) esyslog("cutter: absolute bandwidth limit, sleep %d ms (chunk %dk / %dms)", sleep, burst_size/1024, CUTTER_TIMESLICE);
+             }
+
+             if(sleep>0)
+               cCondWait::SleepMs(sleep);
+             t.Set();
+             bytes = 0;
+              }
+#ifdef USE_HARDLINKCUTTER
               }
+#endif /* HARDLINKCUTTER */
+#endif /* CUTTERLIMIT */
+
            }
      Recordings.TouchUpdate();
      }
@@ -230,7 +407,11 @@ cCuttingThread *cCutter::cuttingThread = NULL;
 bool cCutter::error = false;
 bool cCutter::ended = false;
 
+#ifdef USE_LIEMIKUUTIO
+bool cCutter::Start(const char *FileName, const char *TargetFileName, bool Overwrite)
+#else
 bool cCutter::Start(const char *FileName)
+#endif /* LIEMIKUUTIO */
 {
   cMutexLock MutexLock(&mutex);
   if (!cuttingThread) {
@@ -244,11 +425,25 @@ bool cCutter::Start(const char *FileName)
      if (cMark *First = FromMarks.First())
         Recording.SetStartTime(Recording.Start() + (int(First->Position() / Recording.FramesPerSecond() + 30) / 60) * 60);
 
+#ifdef USE_LIEMIKUUTIO
+	 cString evn = (TargetFileName && *TargetFileName) ? Recording.UpdateFileName(TargetFileName) : Recording.PrefixFileName('%');
+	 if (!Overwrite && *evn && (access(*evn, F_OK) == 0) && !Interface->Confirm(tr("File already exists - overwrite?"))) {
+		 do {
+			 evn = PrefixVideoFileName(*evn, '%');
+		 } while (*evn && (access(*evn, F_OK) == 0));
+	 }
+	 if (*evn && RemoveVideoFile(*evn) && MakeDirs(*evn, true)) {
+#else
      const char *evn = Recording.PrefixFileName('%');
      if (evn && RemoveVideoFile(evn) && MakeDirs(evn, true)) {
+#endif /* LIEMIKUUTIO */
         // XXX this can be removed once RenameVideoFile() follows symlinks (see videodir.c)
         // remove a possible deleted recording with the same name to avoid symlink mixups:
+#ifdef USE_LIEMIKUUTIO
+		 char *s = strdup(*evn);
+#else
         char *s = strdup(evn);
+#endif /* LIEMIKUUTIO */
         char *e = strrchr(s, '.');
         if (e) {
            if (strcmp(e, ".rec") == 0) {
@@ -301,6 +496,7 @@ bool cCutter::Active(const char *FileName)
      editedVersionName = NULL;
      ended = true;
      }
+
   return false;
 }
 
diff --git a/cutter.h b/cutter.h
index f48ae3f..084a802 100644
--- a/cutter.h
+++ b/cutter.h
@@ -24,7 +24,11 @@ private:
   static bool error;
   static bool ended;
 public:
+#ifdef USE_LIEMIKUUTIO
+  static bool Start(const char *FileName, const char *TargetFileName = NULL, bool Overwrite = true);
+#else
   static bool Start(const char *FileName);
+#endif /* LIEMIKUUTIO */
   static void Stop(void);
   static bool Active(const char *FileName = NULL);
          ///< Returns true if the cutter is currently active.
diff --git a/device.c b/device.c
index 872b1aa..8167208 100644
--- a/device.c
+++ b/device.c
@@ -18,6 +18,9 @@
 #include "receiver.h"
 #include "status.h"
 #include "transfer.h"
+#ifdef USE_TTXTSUBS
+#include "vdrttxtsubshooks.h"
+#endif // USE_TTXTSUBS
 
 // --- cLiveSubtitle ---------------------------------------------------------
 
@@ -241,6 +244,9 @@ cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView
   int NumCamSlots = CamSlots.Count();
   int SlotPriority[NumCamSlots];
   int NumUsableSlots = 0;
+#ifdef USE_MCLI
+  bool InternalCamNeeded = false;
+#endif /* MCLI */
   if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
      for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
          SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
@@ -254,7 +260,11 @@ cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView
             }
          }
      if (!NumUsableSlots)
+#ifdef USE_MCLI
+        InternalCamNeeded = true; // no CAM is able to decrypt this channel
+#else
         return NULL; // no CAM is able to decrypt this channel
+#endif /* MCLI */
      }
 
   bool NeedsDetachReceivers = false;
@@ -268,11 +278,21 @@ cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView
       for (int i = 0; i < numDevices; i++) {
           if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
              continue; // a specific card was requested, but not this one
+#ifdef USE_MCLI
+          if (InternalCamNeeded && !device[i]->HasInternalCam())
+             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
+          if (NumUsableSlots && !device[i]->HasInternalCam() && !CamSlots.Get(j)->Assign(device[i], true))
+#else
           if (NumUsableSlots && !CamSlots.Get(j)->Assign(device[i], true))
+#endif /* MCLI */
              continue; // CAM slot can't be used with this device
           bool ndr;
           if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basically able to do the job
+#ifdef USE_MCLI
+             if (NumUsableSlots && !device[i]->HasInternalCam() && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#else
              if (NumUsableSlots && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#endif /* MCLI */
                 ndr = true; // using a different CAM slot requires detaching receivers
              // Put together an integer number that reflects the "impact" using
              // this device would have on the overall system. Each condition is represented
@@ -287,18 +307,34 @@ cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView
              imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
              imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
              imp <<= 8; imp |= device[i]->Priority() - IDLEPRIORITY;                                                 // use the device with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
+#ifdef USE_MCLI
+             imp <<= 8; imp |= ((NumUsableSlots && !device[i]->HasInternalCam()) ? SlotPriority[j] : IDLEPRIORITY) - IDLEPRIORITY;              // use the CAM slot with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
+#else
              imp <<= 8; imp |= (NumUsableSlots ? SlotPriority[j] : IDLEPRIORITY) - IDLEPRIORITY;                     // use the CAM slot with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
+#endif /* MCLI */
              imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
+#ifdef USE_MCLI
+             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
+#else
              imp <<= 1; imp |= NumUsableSlots ? 0 : device[i]->HasCi();                                              // avoid cards with Common Interface for FTA channels
+#endif /* MCLI */
              imp <<= 1; imp |= device[i]->AvoidRecording();                                                          // avoid SD full featured cards
+#ifdef USE_MCLI
+             imp <<= 1; imp |= (NumUsableSlots && !device[i]->HasInternalCam()) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#else
              imp <<= 1; imp |= NumUsableSlots ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#endif /* MCLI */
              imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
              if (imp < Impact) {
                 // This device has less impact than any previous one, so we take it.
                 Impact = imp;
                 d = device[i];
                 NeedsDetachReceivers = ndr;
+#ifdef USE_MCLI
+                if (NumUsableSlots && !device[i]->HasInternalCam())
+#else
                 if (NumUsableSlots)
+#endif /* MCLI */
                    s = CamSlots.Get(j);
                 }
              }
@@ -593,6 +629,13 @@ int cDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
   return -1;
 }
 
+#ifdef USE_MCLI
+int cDevice::ReadFilter(int Handle, void *Buffer, size_t Length)
+{
+  return safe_read(Handle, Buffer, Length);
+}
+#endif /* MCLI */
+
 void cDevice::CloseFilter(int Handle)
 {
   close(Handle);
@@ -682,6 +725,11 @@ bool cDevice::MaySwitchTransponder(const cChannel *Channel) const
 
 bool cDevice::SwitchChannel(const cChannel *Channel, bool LiveView)
 {
+#ifdef USE_PINPLUGIN
+  if (LiveView && cStatus::MsgChannelProtected(this, Channel) == true)
+     return scrNotAvailable;
+#endif /* PINPLUGIN */
+
   if (LiveView) {
      isyslog("switching to channel %d", Channel->Number());
      cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
@@ -712,6 +760,9 @@ bool cDevice::SwitchChannel(int Direction)
      cChannel *channel;
      while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
            // try only channels which are currently available
+#ifdef USE_PINPLUGIN
+        if (cStatus::MsgChannelProtected(0, channel) == false)
+#endif /* PINPLUGIN */
            if (GetDevice(channel, LIVEPRIORITY, true, true))
               break;
            n = channel->Number() + Direction;
@@ -1297,6 +1348,14 @@ int cDevice::PlayPesPacket(const uchar *Data, int Length, bool VideoOnly)
                   }
                break;
           case 0xBD: { // private stream 1
+#ifdef USE_TTXTSUBS
+               // EBU Teletext data, ETSI EN 300 472
+               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
+               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
+                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
+                  break;
+                  }
+#endif // USE_TTXTSUBS
                int PayloadOffset = Data[8] + 9;
 
                // Compatibility mode for old subtitles plugin:
@@ -1456,6 +1515,9 @@ int cDevice::PlayTs(const uchar *Data, int Length, bool VideoOnly)
      tsToPesVideo.Reset();
      tsToPesAudio.Reset();
      tsToPesSubtitle.Reset();
+#ifdef USE_TTXTSUBS
+     tsToPesTeletext.Reset();
+#endif // USE_TTXTSUBS
      }
   else if (Length < TS_SIZE) {
      esyslog("ERROR: skipped %d bytes of TS fragment", Length);
@@ -1501,6 +1563,19 @@ int cDevice::PlayTs(const uchar *Data, int Length, bool VideoOnly)
                     if (!VideoOnly || HasIBPTrickSpeed())
                        PlayTsSubtitle(Data, TS_SIZE);
                     }
+#ifdef USE_TTXTSUBS
+                 else if (Pid == patPmtParser.Tpid()) {
+                    if (!VideoOnly || HasIBPTrickSpeed()) {
+                       int l;
+                       tsToPesTeletext.PutTs(Data, Length);
+                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
+                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
+                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false, patPmtParser.TeletextSubtitlePages(), patPmtParser.TotalTeletextSubtitlePages());
+                          tsToPesTeletext.Reset();
+                          }
+                       }
+                    }
+#endif // USE_TTXTSUBS
                  }
               }
            else if (Pid == patPmtParser.Ppid()) {
diff --git a/device.h b/device.h
index f279fda..bcdff99 100644
--- a/device.h
+++ b/device.h
@@ -24,6 +24,10 @@
 #include "spu.h"
 #include "thread.h"
 #include "tools.h"
+#ifdef USE_ROTOR
+#include <asm/types.h>
+#include <linux/dvb/frontend.h>
+#endif /* ROTOR */
 
 #define MAXDEVICES         16 // the maximum number of devices in the system
 #define MAXPIDHANDLES      64 // the maximum number of different PIDs per device
@@ -304,12 +308,18 @@ public:
          ///< Direction (only the sign of Direction is evaluated, positive values
          ///< switch to higher channel numbers).
 private:
+#ifndef USE_YAEPG
   eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
          ///< Sets the device to the given channel (general setup).
+#endif /* YAEPG */
 protected:
   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
          ///< Sets the device to the given channel (actual physical setup).
 public:
+#ifdef USE_YAEPG
+  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
+         ///< Sets the device to the given channel (general setup).
+#endif /* YAEPG */
   static int CurrentChannel(void) { return primaryDevice ? currentChannel : 0; }
          ///< Returns the number of the current channel on the primary device.
   static void SetCurrentChannel(const cChannel *Channel) { currentChannel = Channel ? Channel->Number() : 0; }
@@ -337,6 +347,9 @@ public:
   virtual bool HasProgramme(void);
          ///< Returns true if the device is currently showing any programme to
          ///< the user, either through replaying or live.
+#ifdef USE_ROTOR
+  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd) {return false;}
+#endif /* ROTOR */
 
 // PID handle facilities
 
@@ -393,6 +406,12 @@ public:
        ///< Opens a file handle for the given filter data.
        ///< A derived device that provides section data must
        ///< implement this function.
+#ifdef USE_MCLI
+  virtual int ReadFilter(int Handle, void *Buffer, size_t Length);
+       ///< Read from a handle for the given filter data.
+       ///< a derived class need not implement this function, because this
+       ///< is done by the default implementation.
+#endif /* MCLI */
   virtual void CloseFilter(int Handle);
        ///< Closes a file handle that has previously been opened
        ///< by OpenFilter(). If this is as simple as calling close(Handle),
@@ -411,6 +430,14 @@ private:
 public:
   virtual bool HasCi(void);
          ///< Returns true if this device has a Common Interface.
+#ifdef USE_MCLI
+  virtual bool HasInternalCam(void) { return false; }
+         ///< Returns true if this device handles encrypted channels itself
+         ///< without VDR assistance. This can be e.g. when the device is a
+         ///< client that gets the stream from another VDR instance that has
+         ///< already decrypted the stream. In this case ProvidesChannel()
+         ///< shall check whether the channel can be decrypted.
+#endif /* MCLI */
   void SetCamSlot(cCamSlot *CamSlot);
          ///< Sets the given CamSlot to be used with this device.
   cCamSlot *CamSlot(void) const { return camSlot; }
@@ -569,6 +596,9 @@ private:
   cTsToPes tsToPesVideo;
   cTsToPes tsToPesAudio;
   cTsToPes tsToPesSubtitle;
+#ifdef USE_TTXTSUBS
+  cTsToPes tsToPesTeletext;
+#endif // USE_TTXTSUBS
   bool isPlayingVideo;
 protected:
   const cPatPmtParser *PatPmtParser(void) const { return &patPmtParser; }
diff --git a/dvbdevice.c b/dvbdevice.c
index 55cb912..da08a52 100644
--- a/dvbdevice.c
+++ b/dvbdevice.c
@@ -285,6 +285,9 @@ class cDvbTuner : public cThread {
 private:
   static cMutex bondMutex;
   enum eTunerStatus { tsIdle, tsSet, tsTuned, tsLocked };
+#ifdef USE_ROTOR
+  bool SendDiseqc;
+#endif /* ROTOR */
   int frontendType;
   const cDvbDevice *device;
   int fd_frontend;
@@ -301,6 +304,9 @@ private:
   cMutex mutex;
   cCondVar locked;
   cCondVar newSet;
+#ifdef USE_ROTOR
+  dvb_diseqc_master_cmd diseqc_cmd;
+#endif /* ROTOR */
   cDvbTuner *bondedTuner;
   bool bondedMaster;
   bool SetFrontendType(const cChannel *Channel);
@@ -323,6 +329,9 @@ public:
   uint32_t SubsystemId(void) const { return subsystemId; }
   bool IsTunedTo(const cChannel *Channel) const;
   void SetChannel(const cChannel *Channel);
+#ifdef USE_ROTOR
+  bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+#endif /* ROTOR */
   bool Locked(int TimeoutMs = 0);
   int GetSignalStrength(void) const;
   int GetSignalQuality(void) const;
@@ -335,6 +344,9 @@ cDvbTuner::cDvbTuner(const cDvbDevice *Device, int Fd_Frontend, int Adapter, int
   frontendType = SYS_UNDEFINED;
   device = Device;
   fd_frontend = Fd_Frontend;
+#ifdef USE_ROTOR
+  SendDiseqc=false;
+#endif /* ROTOR */
   adapter = Adapter;
   frontend = Frontend;
   subsystemId = cDvbDeviceProbe::GetSubsystemId(adapter, frontend);
@@ -848,6 +860,12 @@ void cDvbTuner::Action(void)
            Status = NewStatus;
         cMutexLock MutexLock(&mutex);
         int WaitTime = 1000;
+#ifdef USE_ROTOR
+        if (SendDiseqc) {
+           CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &diseqc_cmd));
+           SendDiseqc=false;
+           }
+#endif /* ROTOR */
         switch (tunerStatus) {
           case tsIdle:
                break;
@@ -898,6 +916,19 @@ void cDvbTuner::Action(void)
         }
 }
 
+#ifdef USE_ROTOR
+bool cDvbTuner::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
+{
+  cMutexLock MutexLock(&mutex);
+  if (SendDiseqc)
+    return false;
+  diseqc_cmd=cmd;
+  SendDiseqc=true;
+  newSet.Broadcast();
+  return true;
+}
+#endif /* ROTOR */
+
 // --- cDvbSourceParam -------------------------------------------------------
 
 class cDvbSourceParam : public cSourceParam {
@@ -1442,6 +1473,16 @@ bool cDvbDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *Ne
   bool needsDetachReceivers = false;
   needsDetachBondedReceivers = false;
 
+#ifdef USE_CHANNELBIND
+  if (Setup.ChannelBindingByRid && Channel->Rid()) {
+    if (0 == ((unsigned) Channel->Rid() & (1<<(unsigned) CardIndex())) ) {
+      #if 0
+      printf("device %d doesn't provide channel %s", CardIndex(), *Channel->ToText());
+      #endif
+      return false;
+      }
+    }
+#endif /* CHANNELBIND */
   if (dvbTuner && ProvidesTransponder(Channel)) {
      result = hasPriority;
      if (Priority > IDLEPRIORITY) {
@@ -1530,6 +1571,16 @@ bool cDvbDevice::HasLock(int TimeoutMs)
   return dvbTuner ? dvbTuner->Locked(TimeoutMs) : false;
 }
 
+#ifdef USE_ROTOR
+bool cDvbDevice::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
+{
+  if (ProvidesDeliverySystem(SYS_DVBS) || ProvidesDeliverySystem(SYS_DVBS2))
+     return dvbTuner->SendDiseqcCmd(cmd);
+  else
+     return false;
+}
+#endif /* ROTOR */
+
 void cDvbDevice::SetTransferModeForDolbyDigital(int Mode)
 {
   setTransferModeForDolbyDigital = Mode;
diff --git a/dvbdevice.h b/dvbdevice.h
index 7da9c56..fadb489 100644
--- a/dvbdevice.h
+++ b/dvbdevice.h
@@ -193,6 +193,9 @@ protected:
   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
 public:
   virtual bool HasLock(int TimeoutMs = 0);
+#ifdef USE_ROTOR
+  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+#endif /* ROTOR */
 
 // PID handle facilities
 
diff --git a/dvbplayer.c b/dvbplayer.c
index f2cb2d2..c3535b0 100644
--- a/dvbplayer.c
+++ b/dvbplayer.c
@@ -204,6 +204,9 @@ private:
   cNonBlockingFileReader *nonBlockingFileReader;
   cRingBufferFrame *ringBuffer;
   cPtsIndex ptsIndex;
+#ifdef USE_JUMPPLAY
+  cMarks marks;
+#endif /* JUMPPLAY */
   cFileName *fileName;
   cIndexFile *index;
   cUnbufferedFile *replayFile;
@@ -286,6 +289,9 @@ cDvbPlayer::cDvbPlayer(const char *FileName, bool PauseLive)
      }
   else if (PauseLive)
      framesPerSecond = cRecording(FileName).FramesPerSecond(); // the fps rate might have changed from the default
+#ifdef USE_JUMPPLAY
+  marks.Load(FileName, framesPerSecond, isPesRecording);
+#endif /* JUMPPLAY */
 }
 
 cDvbPlayer::~cDvbPlayer()
@@ -364,6 +370,12 @@ bool cDvbPlayer::Save(void)
   if (index) {
      int Index = ptsIndex.FindIndex(DeviceGetSTC());
      if (Index >= 0) {
+#ifdef USE_JUMPPLAY
+        // set resume position to 0 if replay stops at the first mark
+        if (Setup.PlayJump && marks.First() &&
+            abs(Index - marks.First()->Position()) <= int(round(RESUMEBACKUP * framesPerSecond)))
+           Index = 0;
+#endif /* JUMPPLAY */
         Index -= int(round(RESUMEBACKUP * framesPerSecond));
         if (Index > 0)
            Index = index->GetNextIFrame(Index, false);
@@ -390,11 +402,30 @@ void cDvbPlayer::Action(void)
 {
   uchar *p = NULL;
   int pc = 0;
+#ifdef USE_JUMPPLAY
+  bool cutIn = false;
+  int total = -1;
+#endif /* JUMPPLAY */
 
   readIndex = Resume();
   if (readIndex >= 0)
      isyslog("resuming replay at index %d (%s)", readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
 
+#ifdef USE_JUMPPLAY
+  if (Setup.PlayJump && readIndex <= 0 && marks.First() && index) {
+     int Index = marks.First()->Position();
+     uint16_t FileNumber;
+     off_t FileOffset;
+     if (index->Get(Index, &FileNumber, &FileOffset) &&
+         NextFile(FileNumber, FileOffset)) {
+        isyslog("PlayJump: start replay at first mark %d (%s)",
+                Index, *IndexToHMSF(Index, true, framesPerSecond));
+        readIndex = Index;
+        }
+     }
+
+  bool LastMarkPause = false;
+#endif /* JUMPPLAY */
   nonBlockingFileReader = new cNonBlockingFileReader;
   int Length = 0;
   bool Sleep = false;
@@ -421,7 +452,11 @@ void cDvbPlayer::Action(void)
 
           // Read the next frame from the file:
 
+#ifdef USE_JUMPPLAY
+          if (playMode != pmStill && playMode != pmPause && !LastMarkPause) {
+#else
           if (playMode != pmStill && playMode != pmPause) {
+#endif /* JUMPPLAY */
              if (!readFrame && (replayFile || readIndex >= 0)) {
                 if (!nonBlockingFileReader->Reading()) {
                    if (!SwitchToPlayFrame && (playMode == pmFast || (playMode == pmSlow && playDir == pdBackward))) {
@@ -458,6 +493,46 @@ void cDvbPlayer::Action(void)
                    else if (index) {
                       uint16_t FileNumber;
                       off_t FileOffset;
+#ifdef USE_JUMPPLAY
+                      if (Setup.PlayJump || Setup.PauseLastMark) {
+                         // check for end mark - jump to next mark or pause
+                         readIndex++;
+                         marks.Update();
+                         cMark *m = marks.Get(readIndex);
+                         if (m && (m->Index() & 0x01) != 0) {
+                            m = marks.Next(m);
+                            int Index;
+                            if (m)
+                               Index = m->Position();
+                            else if (Setup.PauseLastMark) {
+                               // pause at last mark
+                               isyslog("PauseLastMark: pause at position %d (%s)",
+                                       readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
+                               LastMarkPause = true;
+                               Index = -1;
+                               }
+                            else if (total == index->Last())
+                               // at last mark jump to end of recording
+                               Index = index->Last() - 1;
+                            else
+                               // jump but stay off end of live-recordings
+                               Index = index->GetNextIFrame(index->Last() - int(round(MAXSTUCKATEOF * framesPerSecond)), true);
+                            // don't jump in edited recordings
+                            if (Setup.PlayJump && Index > readIndex &&
+                                Index > index->GetNextIFrame(readIndex, true)) {
+                               isyslog("PlayJump: %d frames to %d (%s)",
+                                       Index - readIndex, Index,
+                                       *IndexToHMSF(Index, true, framesPerSecond));
+                               readIndex = Index;
+                               cutIn = true;
+                               }
+                            }
+                         readIndex--;
+                      }
+                      // for detecting growing length of live-recordings
+                      if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent) && readIndependent)
+                         total = index->Last();
+#endif /* JUMPPLAY */
                       if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent, &Length) && NextFile(FileNumber, FileOffset))
                          readIndex++;
                       else
@@ -502,6 +577,15 @@ void cDvbPlayer::Action(void)
              // Store the frame in the buffer:
 
              if (readFrame) {
+#ifdef USE_JUMPPLAY
+                if (cutIn) {
+                   if (isPesRecording)
+                      cRemux::SetBrokenLink(readFrame->Data(), readFrame->Count());
+                   else
+                      TsSetTeiOnBrokenPackets(readFrame->Data(), readFrame->Count());
+                   cutIn = false;
+                   }
+#endif /* JUMPPLAY */
                 if (ringBuffer->Put(readFrame))
                    readFrame = NULL;
                 else
@@ -567,8 +651,19 @@ void cDvbPlayer::Action(void)
                 p = NULL;
                 }
              }
+#ifdef USE_JUMPPLAY
+          else {
+             if (LastMarkPause) {
+                LastMarkPause = false;
+                playMode = pmPause;
+                }
+#else
           else
+#endif /* JUMPPLAY */
              Sleep = true;
+#ifdef USE_JUMPPLAY
+             }
+#endif /* JUMPPLAY */
 
           // Handle hitting begin/end of recording:
 
diff --git a/eit.c b/eit.c
index 12e1d24..ca52fe7 100644
--- a/eit.c
+++ b/eit.c
@@ -97,7 +97,87 @@ cEIT::cEIT(cSchedules *Schedules, int Source, u_char Tid, const u_char *Data, bo
          // each of them :-( So if one DVB card is tuned to the Premiere transponder, while an other one is tuned
          // to the Sat.1/Pro7 transponder, events will keep toggling because of the bogus version numbers.
          else if (Tid == TableID && pEvent->Version() == getVersionNumber())
+#ifdef USE_DDEPGENTRY
+            {
+               if(Setup.MixEpgAction == 0)
             continue;
+
+               //printf("in");
+               //printf("%s", pEvent->GetTimeString());
+               // to use the info of the original epg, update the extern one,
+               // if it has less info
+               SI::Descriptor *d;
+               SI::ExtendedEventDescriptors *ExtendedEventDescriptors = NULL;
+               //SI::ExtendedEventDescriptor *eed = NULL;
+               SI::ShortEventDescriptor *ShortEventDescriptor = NULL;
+               //SI::ShortEventDescriptor *sed = NULL;
+               //SI::TimeShiftedEventDescriptor *tsed = NULL;
+               //cLinkChannels *LinkChannels = NULL;
+               for (SI::Loop::Iterator it2; (d = SiEitEvent.eventDescriptors.getNext(it2));)
+               {
+                  if(d->getDescriptorTag() == SI::ShortEventDescriptorTag)
+                  {
+                     int LanguagePreferenceShort = -1;
+                     SI::ShortEventDescriptor *sed = (SI::ShortEventDescriptor *)d;
+                     if (I18nIsPreferredLanguage(Setup.EPGLanguages, sed->languageCode, LanguagePreferenceShort) || !ShortEventDescriptor)
+                     {
+                        delete ShortEventDescriptor;
+                        ShortEventDescriptor = sed;
+                        d = NULL; // so that it is not deleted
+                     }
+                  }
+                  else if(d->getDescriptorTag() == SI::ExtendedEventDescriptorTag)
+                  {
+                     int LanguagePreferenceExt = -1;
+                     bool UseExtendedEventDescriptor = false;
+                     SI::ExtendedEventDescriptor *eed = (SI::ExtendedEventDescriptor *)d;
+                     if (I18nIsPreferredLanguage(Setup.EPGLanguages, eed->languageCode, LanguagePreferenceExt) || !ExtendedEventDescriptors)
+                     {
+                        delete ExtendedEventDescriptors;
+                        ExtendedEventDescriptors = new SI::ExtendedEventDescriptors;
+                        UseExtendedEventDescriptor = true;
+                     }
+                     if (UseExtendedEventDescriptor)
+                     {
+                        ExtendedEventDescriptors->Add(eed);
+                        d = NULL; // so that it is not deleted
+                     }
+                     if (eed->getDescriptorNumber() == eed->getLastDescriptorNumber())
+                        UseExtendedEventDescriptor = false;
+                  }
+                  delete d;
+               }
+               if(pEvent)
+               {
+
+                  if(ShortEventDescriptor)
+                  {
+                     char buffer[256];
+                     if(ShortEventDescriptor->text.getText(buffer, sizeof(buffer)) && pEvent->ShortText() && (strlen(ShortEventDescriptor->text.getText(buffer, sizeof(buffer))) > strlen(pEvent->ShortText())))
+                     {
+                        pEvent->SetShortText(ShortEventDescriptor->text.getText(buffer, sizeof(buffer)));
+                        pEvent->FixEpgBugs();
+                     }
+                  }
+                  if(ExtendedEventDescriptors)
+                  {
+                     char buffer[ExtendedEventDescriptors->getMaximumTextLength(": ") + 1];
+                     //pEvent->SetDescription(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": "));
+
+                     if(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": ") && pEvent->Description() && (strlen(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": ")) > strlen(pEvent->Description())))
+                     {
+                        pEvent->SetDescription(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": "));
+                        pEvent->FixEpgBugs();
+                     }
+                  }
+               }
+               delete ExtendedEventDescriptors;
+               delete ShortEventDescriptor;
+               continue;
+            }
+#else
+            continue;
+#endif /* DDEPGENTRY */
          EpgHandlers.SetEventID(pEvent, SiEitEvent.getEventId()); // unfortunately some stations use different event ids for the same event in different tables :-(
          EpgHandlers.SetStartTime(pEvent, StartTime);
          EpgHandlers.SetDuration(pEvent, Duration);
@@ -105,7 +185,11 @@ cEIT::cEIT(cSchedules *Schedules, int Source, u_char Tid, const u_char *Data, bo
       if (pEvent->TableID() > 0x4E) // for backwards compatibility, table ids less than 0x4E are never overwritten
          pEvent->SetTableID(Tid);
       if (Tid == 0x4E) { // we trust only the present/following info on the actual TS
+#ifdef USE_DDEPGENTRY
+         if (Setup.DisableVPS == 0 && SiEitEvent.getRunningStatus() >= SI::RunningStatusNotRunning)
+#else
          if (SiEitEvent.getRunningStatus() >= SI::RunningStatusNotRunning)
+#endif /* DDEPGENTRY */
             pSchedule->SetRunningStatus(pEvent, SiEitEvent.getRunningStatus(), channel);
          }
       if (OnlyRunningStatus) {
@@ -292,8 +376,85 @@ cEIT::cEIT(cSchedules *Schedules, int Source, u_char Tid, const u_char *Data, bo
          channel->SetLinkChannels(LinkChannels);
       Modified = true;
       EpgHandlers.HandleEvent(pEvent);
+
       if (handledExternally)
          delete pEvent;
+
+#ifdef USE_DDEPGENTRY
+      //to avoid double epg-entrys from ext and int epg sources :EW
+      if (pEvent && pEvent->TableID() != 0x00)
+         {
+         cEvent *pPreviousEvent = (cEvent *)pSchedule->GetPreviousEvent(pEvent);
+
+         if (pPreviousEvent)
+            {
+            if(Setup.DoubleEpgAction == 0)
+               {
+               pPreviousEvent->SetStartTime(pEvent->StartTime());
+               pPreviousEvent->SetDuration(pEvent->Duration());
+
+               if(Setup.DisableVPS == 0)
+                  {
+                  if(channel)
+                     pPreviousEvent->SetRunningStatus(pEvent->RunningStatus(), channel);
+                  else
+                     pPreviousEvent->SetRunningStatus(pEvent->RunningStatus());
+                  }
+
+               // to use the info of the original epg, update the extern one,
+               // if it has less info
+               char buffer_short_intern[256];
+               char buffer_short_extern[256];
+               int len_short_intern = 0;
+               int len_short_extern = 0;
+
+               if (pEvent->ShortText())
+                  len_short_intern = snprintf (buffer_short_intern, sizeof(buffer_short_intern), "%s", pEvent->ShortText());
+
+               if (pPreviousEvent->ShortText())
+                  len_short_extern = snprintf (buffer_short_extern, sizeof(buffer_short_extern), "%s",pPreviousEvent->ShortText());
+
+               if(len_short_intern > 0)
+                  {
+                  if(len_short_extern < 1)
+                     pPreviousEvent->SetShortText(buffer_short_intern);
+                  else if (len_short_intern > len_short_extern)
+                     pPreviousEvent->SetShortText(buffer_short_intern);
+                  }
+
+               if(pEvent->Description())
+                  {
+                  char buffer_title_intern[4096];
+                  char buffer_title_extern[4096];
+                  int len_title_intern = 0;
+                  int len_title_extern = 0;
+
+                  if (pEvent->Description())
+                     len_title_intern = snprintf (buffer_title_intern, sizeof(buffer_title_intern), "%s", pEvent->Description());
+
+                  if (pPreviousEvent->Description())
+                     len_title_extern = snprintf (buffer_title_extern, sizeof(buffer_title_extern), "%s", pPreviousEvent->Description());
+
+                  if(len_title_intern > 0)
+                     {
+                     if(len_title_extern < 1)
+                        pPreviousEvent->SetDescription(buffer_title_intern);
+                     else if (len_title_intern > len_title_extern)
+                        pPreviousEvent->SetDescription(buffer_title_intern);
+                     }
+                  }
+
+               if(pPreviousEvent->Vps() == 0 && pEvent->Vps() != 0)
+                  pPreviousEvent->SetVps(pEvent->Vps());
+
+               pSchedule->DelEvent(pEvent);
+               pPreviousEvent->FixEpgBugs();
+               }
+            else
+               pSchedule->DelEvent(pPreviousEvent);
+            }
+         }
+#endif /* DDEPGENTRY */
       }
   if (Tid == 0x4E) {
      if (Empty && getSectionNumber() == 0)
diff --git a/epg.c b/epg.c
index d47c4a3..c586c30 100644
--- a/epg.c
+++ b/epg.c
@@ -946,6 +946,31 @@ const cEvent *cSchedule::GetEventAround(time_t Time) const
   return pe;
 }
 
+#ifdef USE_DDEPGENTRY
+const cEvent *cSchedule::GetPreviousEvent(cEvent *Event) const
+{
+
+   if(!Event || Event->Duration() == 0 || Event->StartTime() == 0)
+      return NULL;
+   // Returns either the event info to the previous/following event to the given EventID or, if that one can't be found NULL :EW
+   cEvent *pt = NULL;
+   int epgTimeDelta = Setup.DoubleEpgTimeDelta * 60 + 1;
+   for (pt = events.First(); pt; pt = events.Next(pt))
+      if(pt && pt->TableID() == 0x00)
+         if ((Event->StartTime() - pt->StartTime()) > -  epgTimeDelta && (Event->StartTime() - pt->StartTime()) < epgTimeDelta)
+         {
+            if((pt->Duration() + (pt->Duration()/ 5) + 1) > Event->Duration() && (pt->Duration() - (pt->Duration()/ 5) - 1) < Event->Duration())
+               return pt;
+            else if (pt->Title() && Event->Title() && (strcmp(pt->Title(), ".") != 0 && strcmp(Event->Title(), ".") != 0))
+            {
+               if (strstr(pt->Title(), Event->Title()) != NULL || strstr(Event->Title(), pt->Title()) != NULL)
+                  return pt;
+            }
+         }
+   return NULL;
+}
+#endif /* DDEPGENTRY */
+
 void cSchedule::SetRunningStatus(cEvent *Event, int RunningStatus, cChannel *Channel)
 {
   hasRunning = false;
diff --git a/epg.h b/epg.h
index 98cb776..66608ac 100644
--- a/epg.h
+++ b/epg.h
@@ -164,6 +164,9 @@ public:
   void DropOutdated(time_t SegmentStart, time_t SegmentEnd, uchar TableID, uchar Version);
   void Cleanup(time_t Time);
   void Cleanup(void);
+#ifdef USE_DDEPGENTRY
+  const cEvent *GetPreviousEvent(cEvent *Event) const; //:EW
+#endif /* DDEPGENTRY */
   cEvent *AddEvent(cEvent *Event);
   void DelEvent(cEvent *Event);
   void HashEvent(cEvent *Event);
diff --git a/filetransfer.c b/filetransfer.c
new file mode 100644
index 0000000..37b2d98
--- /dev/null
+++ b/filetransfer.c
@@ -0,0 +1,280 @@
+#ifdef USE_LIEMIKUUTIO
+/*
+ * filetransfer.c: The video file transfer facilities
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: $
+ */
+
+#include "videodir.h"
+#include "filetransfer.h"
+
+static cString StripLastDirectory(const char *DirName)
+{
+  if (DirName && *DirName) {
+     cString s(DirName);
+     int l = strlen(*s);
+     const char *p = *s + l;
+     while (l > 0) {
+           if (*p-- == '/')
+              break;
+           l--;
+           }
+     if (l)
+        s = s.Truncate(l);
+     return s;
+     }
+  return NULL;
+}
+
+// --- cCopyingThread --------------------------------------------------------
+
+class cCopyingThread : public cThread {
+private:
+  const char *error;
+  bool deleteSource;
+  cString source;
+  cString target;
+protected:
+  virtual void Action(void);
+public:
+  cCopyingThread(const char *SourceName, const char *ToFileName, bool DeleteSource = false);
+  virtual ~cCopyingThread();
+  const char *Error(void) { return error; }
+  };
+
+cCopyingThread::cCopyingThread(const char *SourceName, const char *TargetName, bool DeleteSource)
+:cThread("copying"),
+ error(NULL),
+ deleteSource(DeleteSource),
+ source(SourceName),
+ target(TargetName)
+{
+  // add missing directory delimiters
+  const char *delim = "/";
+  if (!endswith(*source, delim))
+     source = cString::sprintf("%s%s", *source, delim);
+  if (!endswith(*target, delim))
+     target = cString::sprintf("%s%s", *target, delim);
+
+  Start();
+}
+
+cCopyingThread::~cCopyingThread()
+{
+  Cancel(3);
+}
+
+void cCopyingThread::Action(void)
+{
+  SetPriority(19);
+  SetIOPriority(7);
+
+  if (strcmp(*source, *target)) {
+     // validate target directory
+     if (strstr(*target, *source)) {
+        error = "invalid target";
+        return;
+        }
+
+     // recordings methods require the last directory delimiter to be stripped off
+     cString recname = target;
+     recname.Truncate(strlen(*recname) - 1);
+     Recordings.AddByName(*recname, false);
+
+     RemoveFileOrDir(*target);
+     if (!MakeDirs(*target, true)) {
+        error = "MakeDirs";
+        return;
+        }
+
+     if (deleteSource && EntriesOnSameFileSystem(*source, *target)) {
+        if (rename(*source, *target) == -1) {
+           error = "rename";
+           return;
+           }
+        // delete all empty source directories
+        recname = source;
+        recname.Truncate(strlen(*recname) - 1);
+        recname = StripLastDirectory(*recname);
+        do {
+           if (!RemoveEmptyDirectories(*recname, true))
+              break;
+           recname = StripLastDirectory(*recname);
+           }
+        while (strcmp(*recname, VideoDirectory));
+        }
+     else {
+        int required = DirSizeMB(*source);
+        int available = FreeDiskSpaceMB(*target);
+
+        // validate free space
+        if (required < available) {
+           cReadDir d(*source);
+           struct dirent *e;
+           bool success = true;
+
+           // allocate copying buffer
+           const int len = 1024 * 1024;
+           char *buffer = MALLOC(char, len);
+           if (!buffer) {
+              error = "MALLOC";
+              return;
+              }
+
+           // loop through all files, but skip all sub-directories
+           while (Running() && (e = d.Next()) != NULL) {
+                 // skip generic entries
+                 if (strcmp(e->d_name, ".") && strcmp(e->d_name, "..") && strcmp(e->d_name, "lost+found")) {
+                    cString sourceFile = cString::sprintf("%s%s", *source, e->d_name);
+                    cString targetFile = cString::sprintf("%s%s", *target, e->d_name);
+
+                    // copy only regular files
+                    struct stat sts;
+                    if (!stat(*sourceFile, &sts) && S_ISREG(sts.st_mode)) {
+                       int r = -1, w = -1;
+                       cUnbufferedFile *inputFile = cUnbufferedFile::Create(*sourceFile, O_RDONLY | O_LARGEFILE);
+                       cUnbufferedFile *outputFile = cUnbufferedFile::Create(*targetFile, O_RDWR | O_CREAT | O_LARGEFILE);
+
+                       // validate files
+                       if (!inputFile || !outputFile) {
+                          success = false;
+                          break;
+                          }
+
+                       // do actual copy
+                       do {
+                         r = inputFile->Read(buffer, len);
+                         if (r > 0)
+                            w = outputFile->Write(buffer, r);
+                         else
+                            w = 0;
+                       } while (Running() && r > 0 && w > 0);
+                       DELETENULL(inputFile);
+                       DELETENULL(outputFile);
+
+                       // validate result
+                       if (!Running() || r < 0 || w < 0) {
+                          success = false;
+                          break;
+                          }
+                       }
+                   }
+                }
+
+           // release allocated buffer
+           free(buffer);
+
+           // delete all created target files and directories
+           if (!success) {
+              target = StripLastDirectory(*target);
+              RemoveFileOrDir(*target, true);
+              target = StripLastDirectory(*target);
+              RemoveEmptyDirectories(*target, true);
+              error = "copy failed";
+              return;
+              }
+           }
+        else {
+           // delete all created empty target directories
+           recname = target;
+           recname.Truncate(strlen(*recname) - 1);
+           recname = StripLastDirectory(*recname);
+           do {
+              if (!RemoveEmptyDirectories(*recname, true))
+                 break;
+              recname = StripLastDirectory(*recname);
+              }
+           while (strcmp(*recname, VideoDirectory));
+           error = "insufficient free space";
+           return;
+           }
+        }
+
+     if (deleteSource) {
+        // Recordings' methods require the last directory delimiter to be stripped off
+        source.Truncate(strlen(*source) - 1);
+        cRecording *recording = Recordings.GetByName(*source);
+        if (recording->Delete())
+           Recordings.DelByName(*source, false);
+        }
+     else
+        Recordings.TouchUpdate();
+     }
+}
+
+// --- cFileTransfer ----------------------------------------------------------------
+
+cMutex cFileTransfer::mutex;
+char *cFileTransfer::copiedVersionName = NULL;
+cCopyingThread *cFileTransfer::copyingThread = NULL;
+bool cFileTransfer::error = false;
+bool cFileTransfer::ended = false;
+
+bool cFileTransfer::Start(cRecording *Recording, const char *FileName, bool CopyOnly)
+{
+  cMutexLock MutexLock(&mutex);
+  if (!copyingThread) {
+     cString NewName = NewVideoFileName(Recording->FileName(), FileName);
+     error = false;
+     ended = false;
+     if (strlen(*NewName)) {
+        copiedVersionName = strdup(*NewName);
+        copyingThread = new cCopyingThread(Recording->FileName(), copiedVersionName, !CopyOnly);
+        return true;
+        }
+     }
+  return false;
+}
+
+void cFileTransfer::Stop(void)
+{
+  cMutexLock MutexLock(&mutex);
+  bool Interrupted = copyingThread && copyingThread->Active();
+  const char *Error = copyingThread ? copyingThread->Error() : NULL;
+  DELETENULL(copyingThread);
+  if ((Interrupted || Error)) {
+     if (Interrupted)
+        isyslog("file transfer has been interrupted");
+     if (Error)
+        esyslog("ERROR: '%s' during file transfer", Error);
+     RemoveVideoFile(copiedVersionName); //XXX what if this file is currently being replayed?
+     Recordings.DelByName(copiedVersionName);
+     free(copiedVersionName);
+     copiedVersionName = NULL;
+     }
+}
+
+bool cFileTransfer::Active(void)
+{
+  cMutexLock MutexLock(&mutex);
+  if (copyingThread) {
+     if (copyingThread->Active())
+        return true;
+     error = copyingThread->Error();
+     Stop();
+     free(copiedVersionName);
+     copiedVersionName = NULL;
+     ended = true;
+     }
+  return false;
+}
+
+bool cFileTransfer::Error(void)
+{
+  cMutexLock MutexLock(&mutex);
+  bool result = error;
+  error = false;
+  return result;
+}
+
+bool cFileTransfer::Ended(void)
+{
+  cMutexLock MutexLock(&mutex);
+  bool result = ended;
+  ended = false;
+  return result;
+}
+#endif /* LIEMIKUUTIO */
diff --git a/filetransfer.h b/filetransfer.h
new file mode 100644
index 0000000..ea3aaab
--- /dev/null
+++ b/filetransfer.h
@@ -0,0 +1,35 @@
+#ifdef USE_LIEMIKUUTIO
+/*
+ * filetransfer.h: The video file transfer facilities
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: $
+ */
+
+#ifndef __FILETRANSFER_H
+#define __FILETRANSFER_H
+
+#include "recording.h"
+#include "thread.h"
+
+class cCopyingThread;
+
+class cFileTransfer {
+private:
+  static cMutex mutex;
+  static char *copiedVersionName;
+  static cCopyingThread *copyingThread;
+  static bool error;
+  static bool ended;
+public:
+  static bool Start(cRecording *Recording, const char *NewName, bool CopyOnly = false);
+  static void Stop(void);
+  static bool Active(void);
+  static bool Error(void);
+  static bool Ended(void);
+  };
+
+#endif //__FILETRANSFER_H
+#endif /* LIEMIKUUTIO */
diff --git a/iconpatch.c b/iconpatch.c
new file mode 100644
index 0000000..9244452
--- /dev/null
+++ b/iconpatch.c
@@ -0,0 +1,31 @@
+#ifdef USE_WAREAGLEICON
+
+#include "iconpatch.h"
+
+#include <langinfo.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+bool IsLangUtf8(void)
+{
+  char *CodeSet = NULL;
+  if (setlocale(LC_CTYPE, ""))
+     CodeSet = nl_langinfo(CODESET);
+  else {
+     char *LangEnv = getenv("LANG"); // last resort in case locale stuff isn't installed
+     if (LangEnv) {
+        CodeSet = strchr(LangEnv, '.');
+        if (CodeSet)
+           CodeSet++; // skip the dot
+        }
+     }
+
+  if (CodeSet && strcasestr(CodeSet, "UTF-8") != 0)
+     return true;
+
+  return false;
+}
+
+#endif /* WAREAGLEICON */
diff --git a/iconpatch.h b/iconpatch.h
new file mode 100644
index 0000000..add9245
--- /dev/null
+++ b/iconpatch.h
@@ -0,0 +1,58 @@
+#ifdef USE_WAREAGLEICON
+
+#define ICON_NUMBERSIGN        "\x23"
+#define ICON_ASTERISK          "\x2A"
+#define ICON_GREATER           "\x3E"
+#define ICON_EXCLAM            "\x21"
+#define ICON_PLUSMINUS         "\xB1"
+
+#define ICON_RESUME            "\x80"
+#define ICON_DVD               "\x81"
+#define ICON_FOLDER            "\x82"
+#define ICON_BLANK             "\x83"
+#define ICON_CUTTING           "\x84"
+#define ICON_MOVE_FILE         "\x85"
+#define ICON_MOVE_FOLDER       "\x86"
+#define ICON_BAR_START         "\x87"
+#define ICON_BAR_FILLED        "\x88"
+#define ICON_BAR_CLEAR         "\x89"
+#define ICON_BAR_END           "\x8A"
+#define ICON_REC               "\x8B"
+#define ICON_CLOCK             "\x8C"
+#define ICON_TV_CRYPTED        "\x8D"
+#define ICON_RADIO             "\x8E"
+#define ICON_TV                "\x8F"
+#define ICON_NEW               "\x90"
+#define ICON_ARROW             "\x91"
+#define ICON_RUNNING           "\x92"
+#define ICON_VPS               "\x93"
+#define ICON_CLOCK_UH          "\x94"
+#define ICON_CLOCK_LH          "\x95"
+
+// UTF-8 Icons
+#define ICON_RESUME_UTF8       "\uE000"
+#define ICON_DVD_UTF8          "\uE001"
+#define ICON_FOLDER_UTF8       "\uE002"
+#define ICON_BLANK_UTF8        "\uE003"
+#define ICON_CUTTING_UTF8      "\uE004"
+#define ICON_MOVE_FILE_UTF8    "\uE005"
+#define ICON_MOVE_FOLDER_UTF8  "\uE006"
+#define ICON_BAR_START_UTF8    "\uE007"
+#define ICON_BAR_FILLED_UTF8   "\uE008"
+#define ICON_BAR_EMPTY_UTF8    "\uE009"
+#define ICON_BAR_CLOSE_UTF8    "\uE00A"
+#define ICON_REC_UTF8          "\uE00B"
+#define ICON_CLOCK_UTF8        "\uE00C"
+#define ICON_TV_CRYPTED_UTF8   "\uE00D"
+#define ICON_RADIO_UTF8        "\uE00E"
+#define ICON_TV_UTF8           "\uE00F"
+#define ICON_NEW_UTF8          "\uE010"
+#define ICON_ARROW_UTF8        "\uE011"
+#define ICON_RUNNING_UTF8      "\uE012"
+#define ICON_VPS_UTF8          "\uE013"
+#define ICON_CLOCK_UH_UTF8     "\uE014"
+#define ICON_CLOCK_LH_UTF8     "\uE015"
+
+bool IsLangUtf8(void);
+
+#endif /* WAREAGLEICON */
diff --git a/lirc.c b/lirc.c
index e3b68db..f9e57d1 100644
--- a/lirc.c
+++ b/lirc.c
@@ -12,6 +12,10 @@
 #include "lirc.h"
 #include <netinet/in.h>
 #include <sys/socket.h>
+#ifdef USE_LIRCSETTINGS
+#include "config.h"
+#endif /* LIRCSETTINGS */
+
 
 #define REPEATDELAY 350 // ms
 #define REPEATFREQ 100 // ms
@@ -95,7 +99,11 @@ void cLircRemote::Action(void)
               continue;
               }
            if (count == 0) {
+#ifdef USE_LIRCSETTINGS
+              if (strcmp(KeyName, LastKeyName) == 0 && FirstTime.Elapsed() < (unsigned int)Setup.LircRepeatDelay)
+#else
               if (strcmp(KeyName, LastKeyName) == 0 && FirstTime.Elapsed() < REPEATDELAY)
+#endif /* LIRCSETTINGS */
                  continue; // skip keys coming in too fast
               if (repeat)
                  Put(LastKeyName, false, true);
@@ -105,18 +113,34 @@ void cLircRemote::Action(void)
               timeout = -1;
               }
            else {
+#ifdef USE_LIRCSETTINGS
+              if (LastTime.Elapsed() < (unsigned int)Setup.LircRepeatFreq)
+#else
               if (LastTime.Elapsed() < REPEATFREQ)
+#endif /* LIRCSETTINGS */
                  continue; // repeat function kicks in after a short delay (after last key instead of first key)
+#ifdef USE_LIRCSETTINGS
+              if (FirstTime.Elapsed() < (unsigned int)Setup.LircRepeatDelay)
+#else
               if (FirstTime.Elapsed() < REPEATDELAY)
+#endif /* LIRCSETTINGS */
                  continue; // skip keys coming in too fast (for count != 0 as well)
               repeat = true;
+#ifdef USE_LIRCSETTINGS
+              timeout = Setup.LircRepeatDelay;
+#else
               timeout = REPEATDELAY;
+#endif /* LIRCSETTINGS */
               }
            LastTime.Set();
            Put(KeyName, repeat);
            }
         else if (repeat) { // the last one was a repeat, so let's generate a release
+#ifdef USE_LIRCSETTINGS
+           if (LastTime.Elapsed() >= (unsigned int)Setup.LircRepeatTimeout) {
+#else
            if (LastTime.Elapsed() >= REPEATTIMEOUT) {
+#endif /* LIRCSETTINGS */
               Put(LastKeyName, false, true);
               repeat = false;
               *LastKeyName = 0;
diff --git a/mainmenuitemsprovider.h b/mainmenuitemsprovider.h
new file mode 100644
index 0000000..bc3e3f6
--- /dev/null
+++ b/mainmenuitemsprovider.h
@@ -0,0 +1,62 @@
+#ifdef USE_MENUORG
+/*
+ * vdr-menuorg - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2007 - 2008 Tobias Grimm <vdr@e-tobi.net>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * $Id$
+ *
+ */
+
+#ifndef __MAINMENUITEMSPROVIDER_H
+#define __MAINMENUITEMSPROVIDER_H
+
+#include <vector>
+
+class cOsdItem;
+class cOsdMenu;
+
+class IMenuItemDefinition
+{
+   public:
+      virtual ~IMenuItemDefinition() {};
+      virtual bool IsCustomOsdItem() = 0;
+      virtual bool IsPluginItem() = 0;
+      virtual bool IsSeparatorItem() = 0;
+      virtual cOsdItem* CustomOsdItem() = 0;
+      virtual const char* PluginMenuEntry() = 0;
+      virtual bool IsSelected() = 0;
+      virtual int PluginIndex() = 0;
+};
+
+typedef std::vector<IMenuItemDefinition*> MenuItemDefinitions;
+
+#define MENU_ITEMS_PROVIDER_SERVICE_ID "MenuOrgPatch-v0.4.2::MainMenuItemsProvider"
+
+class IMainMenuItemsProvider
+{
+   public:
+      virtual ~IMainMenuItemsProvider() {};
+      virtual bool IsCustomMenuAvailable() = 0;
+      virtual MenuItemDefinitions* MainMenuItems() = 0;
+      virtual void EnterRootMenu() = 0;
+      virtual void EnterSubMenu(cOsdItem* item) = 0;
+      virtual bool LeaveSubMenu() = 0;
+      virtual cOsdMenu* Execute(cOsdItem* item) = 0;
+};
+
+#endif //__MAINMENUITEMSPROVIDER_H
+#endif /* MENUORG */
diff --git a/menu.c b/menu.c
index 9f4c54e..60d0485 100644
--- a/menu.c
+++ b/menu.c
@@ -8,6 +8,9 @@
  */
 
 #include "menu.h"
+#ifdef USE_WAREAGLEICON
+#include "iconpatch.h"
+#endif /* WAREAGLEICON */
 #include <ctype.h>
 #include <limits.h>
 #include <math.h>
@@ -18,6 +21,9 @@
 #include "config.h"
 #include "cutter.h"
 #include "eitscan.h"
+#ifdef USE_LIEMIKUUTIO
+#include "filetransfer.h"
+#endif /* LIEMIKUUTIO */
 #include "i18n.h"
 #include "interface.h"
 #include "plugin.h"
@@ -31,6 +37,9 @@
 #include "timers.h"
 #include "transfer.h"
 #include "videodir.h"
+#ifdef USE_MENUORG
+#include "menuorgpatch.h"
+#endif /* MENUORG */
 
 #define MAXWAIT4EPGINFO   3 // seconds
 #define MODETIMEOUT       3 // seconds
@@ -167,6 +176,9 @@ private:
 public:
   cMenuEditChannel(cChannel *Channel, bool New = false);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuEditChannel"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
@@ -215,6 +227,9 @@ void cMenuEditChannel::Setup(void)
   Add(new cMenuEditIntItem( tr("Tid"),          &data.tid, 0));
   Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0));
   XXX*/
+#ifdef USE_CHANNELBIND
+  Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0)); // channel binding patch
+#endif /* CHANNELBIND */
   // Parameters for specific types of sources:
   sourceParam = SourceParams.Get(**cSource::ToString(data.source));
   if (sourceParam) {
@@ -315,6 +330,16 @@ void cMenuChannelItem::Set(void)
   if (!channel->GroupSep()) {
      if (sortMode == csmProvider)
         buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
+#ifdef USE_WAREAGLEICON
+     else if (Setup.WarEagleIcons) {
+        if (channel->Vpid() == 1 || channel->Vpid() == 0)
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_RADIO_UTF8 : ICON_RADIO, channel->Name());
+        else if (channel->Ca() == 0)
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_UTF8 : ICON_TV, channel->Name());
+        else
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_CRYPTED_UTF8 : ICON_TV_CRYPTED, channel->Name());
+        }
+#endif /* WAREAGLEICON */
      else
         buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
      }
@@ -345,6 +370,9 @@ public:
   cMenuChannels(void);
   ~cMenuChannels();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuChannels"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuChannels::cMenuChannels(void)
@@ -889,6 +917,17 @@ cMenuEditTimer::cMenuEditTimer(cTimer *Timer, bool New)
      Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
      Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
      Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
+#ifdef USE_PINPLUGIN
+     if (cOsd::pinValid || !data.fskProtection) Add(new cMenuEditBoolItem(tr("Childlock"),&data.fskProtection));
+     else {
+        char* buf = 0;
+        if (asprintf(&buf, "%s\t%s", tr("Childlock"), data.fskProtection ? tr("yes") : tr("no")) > 0) {
+           Add(new cOsdItem(buf));
+           free(buf);
+           }
+        }
+
+#endif /* PINPLUGIN */
      Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
      SetFirstDayItem();
      }
@@ -996,8 +1035,14 @@ eOSState cMenuEditTimer::ProcessKey(eKeys Key)
 class cMenuTimerItem : public cOsdItem {
 private:
   cTimer *timer;
+#ifdef USE_TIMERINFO
+  char diskStatus;
+#endif /* TIMERINFO */
 public:
   cMenuTimerItem(cTimer *Timer);
+#ifdef USE_TIMERINFO
+  void SetDiskStatus(char DiskStatus);
+#endif /* TIMERINFO */
   virtual int Compare(const cListObject &ListObject) const;
   virtual void Set(void);
   cTimer *Timer(void) { return timer; }
@@ -1006,6 +1051,9 @@ public:
 cMenuTimerItem::cMenuTimerItem(cTimer *Timer)
 {
   timer = Timer;
+#ifdef USE_TIMERINFO
+  diskStatus = ' ';
+#endif /* TIMERINFO */
   Set();
 }
 
@@ -1036,8 +1084,30 @@ void cMenuTimerItem::Set(void)
      File++;
   else
      File = timer->File();
+#ifdef USE_TIMERINFO
+#ifdef USE_WAREAGLEICON
+  cCharSetConv csc("ISO-8859-1", cCharSetConv::SystemCharacterTable());
+  char diskStatusString[2] = { diskStatus, 0 };
+  SetText(cString::sprintf("%s%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+                    csc.Convert(diskStatusString),
+#else
+  cCharSetConv csc("ISO-8859-1", cCharSetConv::SystemCharacterTable());
+  char diskStatusString[2] = { diskStatus, 0 };
+  SetText(cString::sprintf("%s%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+                    csc.Convert(diskStatusString),
+#endif /* WAREAGLEICON */
+#else
+#ifdef USE_WAREAGLEICON
+  SetText(cString::sprintf("%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+#else
   SetText(cString::sprintf("%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+#endif /* WAREAGLEICON */
+#endif /* TIMERINFO */
+#ifdef USE_WAREAGLEICON
+                    !(timer->HasFlags(tfActive)) ? " " : timer->FirstDay() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_ARROW_UTF8 : ICON_ARROW : "!" : timer->Recording() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_REC_UTF8 : ICON_REC : "#" : Setup.WarEagleIcons ? IsLangUtf8() ? ICON_CLOCK_UTF8 : ICON_CLOCK : ">",
+#else
                     !(timer->HasFlags(tfActive)) ? ' ' : timer->FirstDay() ? '!' : timer->Recording() ? '#' : '>',
+#endif /* WAREAGLEICON */
                     timer->Channel()->Number(),
                     *name,
                     *name && **name ? " " : "",
@@ -1049,6 +1119,58 @@ void cMenuTimerItem::Set(void)
                     File));
 }
 
+#ifdef USE_TIMERINFO
+void cMenuTimerItem::SetDiskStatus(char DiskStatus)
+{
+  diskStatus = DiskStatus;
+  Set();
+}
+
+// --- cTimerEntry -----------------------------------------------------------
+
+class cTimerEntry : public cListObject {
+private:
+  cMenuTimerItem *item;
+  const cTimer *timer;
+  time_t start;
+public:
+  cTimerEntry(cMenuTimerItem *item) : item(item), timer(item->Timer()), start(timer->StartTime()) {}
+  cTimerEntry(const cTimer *timer, time_t start) : item(NULL), timer(timer), start(start) {}
+  virtual int Compare(const cListObject &ListObject) const;
+  bool active(void) const { return timer->HasFlags(tfActive); }
+  time_t startTime(void) const { return start; }
+  int priority(void) const { return timer->Priority(); }
+  int duration(void) const;
+  bool repTimer(void) const { return !timer->IsSingleEvent(); }
+  bool isDummy(void) const { return item == NULL; }
+  const cTimer *Timer(void) const { return timer; }
+  void SetDiskStatus(char DiskStatus);
+  };
+
+int cTimerEntry::Compare(const cListObject &ListObject) const
+{
+  cTimerEntry *entry = (cTimerEntry *)&ListObject;
+  int r = startTime() - entry->startTime();
+  if (r == 0)
+     r = entry->priority() - priority();
+  return r;
+}
+
+int cTimerEntry::duration(void) const
+{
+  int dur = (timer->Stop()  / 100 * 60 + timer->Stop()  % 100) -
+            (timer->Start() / 100 * 60 + timer->Start() % 100);
+  if (dur < 0)
+     dur += 24 * 60;
+  return dur;
+}
+
+void cTimerEntry::SetDiskStatus(char DiskStatus)
+{
+  if (item)
+     item->SetDiskStatus(DiskStatus);
+}
+#endif /* TIMERINFO */
 // --- cMenuTimers -----------------------------------------------------------
 
 class cMenuTimers : public cOsdMenu {
@@ -1061,14 +1183,25 @@ private:
   eOSState Info(void);
   cTimer *CurrentTimer(void);
   void SetHelpKeys(void);
+#ifdef USE_TIMERINFO
+  void ActualiseDiskStatus(void);
+  bool actualiseDiskStatus;
+#endif /* TIMERINFO */
 public:
   cMenuTimers(void);
   virtual ~cMenuTimers();
+#ifdef USE_TIMERINFO
+  virtual void Display(void);
+#endif /* TIMERINFO */
   virtual eOSState ProcessKey(eKeys Key);
   };
 
 cMenuTimers::cMenuTimers(void)
+#ifdef USE_TIMERINFO
+:cOsdMenu(tr("Timers"), 3, CHNUMWIDTH, 10, 6, 6)
+#else
 :cOsdMenu(tr("Timers"), 2, CHNUMWIDTH, 10, 6, 6)
+#endif /* TIMERINFO */
 {
   SetMenuCategory(mcTimer);
   helpKeys = -1;
@@ -1080,6 +1213,9 @@ cMenuTimers::cMenuTimers(void)
   SetCurrent(First());
   SetHelpKeys();
   Timers.IncBeingEdited();
+#ifdef USE_TIMERINFO
+  actualiseDiskStatus = true;
+#endif /* TIMERINFO */
 }
 
 cMenuTimers::~cMenuTimers()
@@ -1118,7 +1254,11 @@ eOSState cMenuTimers::OnOff(void)
      timer->OnOff();
      timer->SetEventFromSchedule();
      RefreshCurrent();
+#ifdef USE_TIMERINFO
+     Display();
+#else
      DisplayCurrent(true);
+#endif /* TIMERINFO */
      if (timer->FirstDay())
         isyslog("timer %s first day set to %s", *timer->ToDescr(), *timer->PrintFirstDay());
      else
@@ -1177,6 +1317,68 @@ eOSState cMenuTimers::Info(void)
   return osContinue;
 }
 
+#ifdef USE_TIMERINFO
+void cMenuTimers::ActualiseDiskStatus(void)
+{
+  if (!actualiseDiskStatus || !Count())
+     return;
+
+  // compute free disk space
+  int freeMB, freeMinutes, runshortMinutes;
+  VideoDiskSpace(&freeMB);
+  freeMinutes = int(double(freeMB) * 1.1 / MB_PER_MINUTE); // overestimate by 10 percent
+  runshortMinutes = freeMinutes / 5; // 20 Percent
+
+  // fill entries list
+  cTimerEntry *entry;
+  cList<cTimerEntry> entries;
+  for (cOsdItem *item = First(); item; item = Next(item))
+     entries.Add(new cTimerEntry((cMenuTimerItem *)item));
+
+  // search last start time
+  time_t last = 0;
+  for (entry = entries.First(); entry; entry = entries.Next(entry))
+     last = max(entry->startTime(), last);
+
+  // add entries for repeating timers
+  for (entry = entries.First(); entry; entry = entries.Next(entry))
+     if (entry->repTimer() && !entry->isDummy())
+        for (time_t start = cTimer::IncDay(entry->startTime(), 1);
+             start <= last;
+             start = cTimer::IncDay(start, 1))
+           if (entry->Timer()->DayMatches(start))
+              entries.Add(new cTimerEntry(entry->Timer(), start));
+
+  // set the disk-status
+  entries.Sort();
+  for (entry = entries.First(); entry; entry = entries.Next(entry)) {
+     char status = ' ';
+     if (entry->active()) {
+        freeMinutes -= entry->duration();
+        status = freeMinutes > runshortMinutes ? '+' : freeMinutes > 0 ? 177 /* +/- */ : '-';
+        }
+     entry->SetDiskStatus(status);
+#ifdef DEBUG_TIMER_INFO
+     dsyslog("timer-info: %c | %d | %s | %s | %3d | %+5d -> %+5d",
+             status,
+             entry->startTime(),
+             entry->active() ? "aktiv " : "n.akt.",
+             entry->repTimer() ? entry->isDummy() ? "  dummy  " : "mehrmalig" : "einmalig ",
+             entry->duration(),
+             entry->active() ? freeMinutes + entry->duration() : freeMinutes,
+             freeMinutes);
+#endif
+     }
+
+  actualiseDiskStatus = false;
+}
+
+void cMenuTimers::Display(void)
+{
+  ActualiseDiskStatus();
+  cOsdMenu::Display();
+}
+#endif /* TIMERINFO */
 eOSState cMenuTimers::ProcessKey(eKeys Key)
 {
   int TimerNumber = HasSubMenu() ? Count() : -1;
@@ -1185,18 +1387,36 @@ eOSState cMenuTimers::ProcessKey(eKeys Key)
   if (state == osUnknown) {
      switch (Key) {
        case kOk:     return Edit();
+#ifdef USE_TIMERINFO
+       case kRed:    actualiseDiskStatus = true;
+                     state = OnOff(); break; // must go through SetHelpKeys()!
+#else
        case kRed:    state = OnOff(); break; // must go through SetHelpKeys()!
+#endif /* TIMERINFO */
        case kGreen:  return New();
+#ifdef USE_TIMERINFO
+       case kYellow: actualiseDiskStatus = true;
+                     state = Delete(); break;
+#else
        case kYellow: state = Delete(); break;
+#endif /* TIMERINFO */
        case kInfo:
        case kBlue:   return Info();
                      break;
        default: break;
        }
      }
+#ifdef USE_TIMERINFO
+  if (TimerNumber >= 0 && !HasSubMenu()) {
+     if (Timers.Get(TimerNumber)) // a newly created timer was confirmed with Ok
+        Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
+     Sort();
+     actualiseDiskStatus = true;
+#else
   if (TimerNumber >= 0 && !HasSubMenu() && Timers.Get(TimerNumber)) {
      // a newly created timer was confirmed with Ok
      Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
+#endif /* TIMERINFO */
      Display();
      }
   if (Key != kNone)
@@ -1227,6 +1447,9 @@ void cMenuEvent::Display(void)
 {
   cOsdMenu::Display();
   DisplayMenu()->SetEvent(event);
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdSetEvent(event);
+#endif /* GRAPHTFT */
   if (event->Description())
      cStatus::MsgOsdTextItem(event->Description());
 }
@@ -1304,7 +1527,16 @@ int cMenuScheduleItem::Compare(const cListObject &ListObject) const
   return r;
 }
 
+#ifdef USE_WAREAGLEICON
+static const char *TimerMatchChars[9] =
+{
+  " ", "t", "T",
+  ICON_BLANK, ICON_CLOCK_UH, ICON_CLOCK,
+  ICON_BLANK_UTF8, ICON_CLOCK_UH_UTF8, ICON_CLOCK_UTF8
+};
+#else
 static const char *TimerMatchChars = " tT";
+#endif /* WAREAGLEICON */
 
 bool cMenuScheduleItem::Update(bool Force)
 {
@@ -1313,17 +1545,35 @@ bool cMenuScheduleItem::Update(bool Force)
   Timers.GetMatch(event, &timerMatch);
   if (Force || timerMatch != OldTimerMatch) {
      cString buffer;
+#ifdef USE_WAREAGLEICON
+     const char *t = Setup.WarEagleIcons ? IsLangUtf8() ? TimerMatchChars[timerMatch+6] : TimerMatchChars[timerMatch+3] : TimerMatchChars[timerMatch];
+     const char *v = event->Vps() && (event->Vps() - event->StartTime()) ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_VPS_UTF8 : ICON_VPS : "V" : " ";
+     const char *r = event->SeenWithin(30) && event->IsRunning() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_RUNNING_UTF8 : ICON_RUNNING : "*" : " ";
+#else
      char t = TimerMatchChars[timerMatch];
      char v = event->Vps() && (event->Vps() - event->StartTime()) ? 'V' : ' ';
      char r = event->SeenWithin(30) && event->IsRunning() ? '*' : ' ';
+#endif /* WAREAGLEICON */
      const char *csn = channel ? channel->ShortName(true) : NULL;
      cString eds = event->GetDateString();
      if (channel && withDate)
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#else
         buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
      else if (channel)
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
+#else
         buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
      else
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%.*s\t%s\t%s%s%s\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#else
         buffer = cString::sprintf("%.*s\t%s\t%c%c%c\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
      SetText(buffer);
      result = true;
      }
@@ -1349,6 +1599,10 @@ public:
   static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
   static const cEvent *ScheduleEvent(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
+  virtual void Display(void);
+#endif /* GRAPHTFT */
   };
 
 int cMenuWhatsOn::currentChannel = 0;
@@ -1377,6 +1631,20 @@ cMenuWhatsOn::cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentCha
   SetHelpKeys();
 }
 
+#ifdef USE_GRAPHTFT
+void cMenuWhatsOn::Display(void)
+{
+   cOsdMenu::Display();
+
+   if (Count() > 0) {
+      int ni = 0;
+      for (cOsdItem *item = First(); item; item = Next(item)) {
+         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
+      }
+   }
+}
+#endif /* GRAPHTFT */
+
 bool cMenuWhatsOn::Update(void)
 {
   bool result = false;
@@ -1517,6 +1785,10 @@ public:
   cMenuSchedule(void);
   virtual ~cMenuSchedule();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSchedule"; }
+  virtual void Display(void);
+#endif /* GRAPHTFT */
   };
 
 cMenuSchedule::cMenuSchedule(void)
@@ -1543,6 +1815,20 @@ cMenuSchedule::~cMenuSchedule()
   cMenuWhatsOn::ScheduleEvent(); // makes sure any posted data is cleared
 }
 
+#ifdef USE_GRAPHTFT
+void cMenuSchedule::Display(void)
+{
+   cOsdMenu::Display();
+
+   if (Count() > 0) {
+      int ni = 0;
+      for (cOsdItem *item = First(); item; item = Next(item)) {
+         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
+      }
+   }
+}
+#endif /* GRAPHTFT */
+
 void cMenuSchedule::PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel)
 {
   Clear();
@@ -1907,6 +2193,9 @@ public:
   cMenuCam(cCamSlot *CamSlot);
   virtual ~cMenuCam();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuCam"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuCam::cMenuCam(cCamSlot *CamSlot)
@@ -2094,6 +2383,9 @@ public:
   cMenuRecording(const cRecording *Recording, bool WithButtons = false);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuRecording"; }
+#endif /* GRAPHTFT */
 };
 
 cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
@@ -2110,6 +2402,9 @@ void cMenuRecording::Display(void)
 {
   cOsdMenu::Display();
   DisplayMenu()->SetRecording(recording);
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdSetRecording(recording);
+#endif /* GRAPHTFT */
   if (recording->Info()->Description())
      cStatus::MsgOsdTextItem(recording->Info()->Description());
 }
@@ -2189,6 +2484,169 @@ void cMenuRecordingItem::IncrementCounter(bool New)
   SetText(cString::sprintf("%d\t\t%d\t%s", totalEntries, newEntries, name));
 }
 
+#ifdef USE_LIEMIKUUTIO
+// --- cMenuEditRecording ----------------------------------------------------
+
+class cMenuEditRecording : public cOsdMenu {
+private:
+  char name[MaxFileName];
+  cMenuEditStrItem *file;
+  cOsdItem *marksItem, *resumeItem;
+  bool isResume, isMarks;
+  cRecording *recording;
+  void SetHelpKeys(void);
+  eOSState SetFolder(void);
+public:
+  cMenuEditRecording(cRecording *Recording);
+  virtual eOSState ProcessKey(eKeys Key);
+};
+
+cMenuEditRecording::cMenuEditRecording(cRecording *Recording)
+:cOsdMenu(tr("Edit recording"), 14)
+{
+  cMarks marks;
+
+  file = NULL;
+  recording = Recording;
+
+  if (recording) {
+     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
+     Add(file = new cMenuEditStrItem(tr("File"), name, sizeof(name)));
+
+     Add(new cOsdItem("", osUnknown, false));
+
+     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->Start())), osUnknown, false));
+
+     cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
+     if (channel)
+        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
+
+     int recLen = recording->LengthInSeconds();
+     if (recLen >= 0)
+        Add(new cOsdItem(cString::sprintf("%s:\t%d:%02d:%02d", tr("Length"), recLen / 3600, recLen / 60 % 60, recLen % 60), osUnknown, false));
+     else
+        recLen = 0;
+
+     int dirSize = DirSizeMB(recording->FileName());
+     cString bitRate = recLen ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / recLen) : cString("");
+     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Format"), recording->IsPesRecording() ? tr("PES") : tr("TS")), osUnknown, false));
+     Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
+
+     Add(new cOsdItem("", osUnknown, false));
+
+     isMarks = marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && marks.Count();
+     marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
+     Add(marksItem);
+
+     cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
+     isResume = (ResumeFile.Read() != -1);
+     resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
+     Add(resumeItem);
+     }
+
+  SetHelpKeys();
+}
+
+void cMenuEditRecording::SetHelpKeys(void)
+{
+  SetHelp(tr("Button$Folder"), tr("Button$Cut"), tr("Button$Copy"), tr("Button$Rename/Move"));
+}
+
+eOSState cMenuEditRecording::SetFolder(void)
+{
+  cMenuFolder *mf = (cMenuFolder *)SubMenu();
+  if (mf) {
+     cString Folder = mf->GetFolder();
+     char *p = strrchr(name, FOLDERDELIMCHAR);
+     if (p)
+        p++;
+     else
+        p = name;
+     if (!isempty(*Folder))
+        strn0cpy(name, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(name));
+     else if (p != name)
+        memmove(name, p, strlen(p) + 1);
+     SetCurrent(file);
+     Display();
+     }
+  return CloseSubMenu();
+}
+
+eOSState cMenuEditRecording::ProcessKey(eKeys Key)
+{
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  if (state == osUnknown) {
+     switch (Key) {
+       case kRed:
+            return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, name));
+            break;
+       case kGreen:
+            if (!cCutter::Active()) {
+               if (!isMarks)
+                  Skins.Message(mtError, tr("No editing marks defined!"));
+               else if (!cCutter::Start(recording->FileName(), strcmp(recording->Name(), name) ? *NewVideoFileName(recording->FileName(), name) : NULL, false))
+                  Skins.Message(mtError, tr("Can't start editing process!"));
+               else
+                  Skins.Message(mtInfo, tr("Editing process started"));
+               }
+            else
+               Skins.Message(mtError, tr("Editing process already active!"));
+            return osContinue;
+       case kYellow:
+       case kBlue:
+            if (strcmp(recording->Name(), name)) {
+               if (!cFileTransfer::Active()) {
+                  if (cFileTransfer::Start(recording, name, (Key == kYellow)))
+                     Skins.Message(mtInfo, tr("File transfer started"));
+                  else
+                     Skins.Message(mtError, tr("Can't start file transfer!"));
+                  }
+               else
+                  Skins.Message(mtError, tr("File transfer already active!"));
+               }
+            return osRecordings;
+       default:
+            break;
+       }
+     return osContinue;
+     }
+  else if (state == osEnd && HasSubMenu())
+     state = SetFolder();
+  else if (state == osUser1) {
+     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
+        cMarks marks;
+        marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording());
+        cMark *mark = marks.First();
+        while (mark) {
+              cMark *nextmark = marks.Next(mark);
+              marks.Del(mark);
+              mark = nextmark;
+              }
+        marks.Save();
+        isMarks = false;
+        marksItem->SetSelectable(isMarks);
+        SetCurrent(First());
+        Display();
+        }
+     return osContinue;
+     }
+  else if (state == osUser2) {
+     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
+        cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
+        ResumeFile.Delete();
+        isResume = false;
+        resumeItem->SetSelectable(isResume);
+        SetCurrent(First());
+        Display();
+        }
+     return osContinue;
+     }
+
+  return state;
+}
+#endif /* LIEMIKUUTIO */
+
 // --- cMenuRecordings -------------------------------------------------------
 
 cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
@@ -2261,7 +2719,13 @@ void cMenuRecordings::Set(bool Refresh)
   for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
       if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == FOLDERDELIMCHAR)) {
          cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
+#ifdef USE_PINPLUGIN
+         if ((*Item->Text() && (!Item->IsDirectory() || (!LastItem || !LastItem->IsDirectory() || strcmp(Item->Text(), LastItemText) != 0)))
+            && (!cStatus::MsgReplayProtected(GetRecording(Item), Item->Name(), base,
+                                             Item->IsDirectory(), true))) {
+#else
          if (*Item->Text() && (!Item->IsDirectory() || (!LastItem || !LastItem->IsDirectory() || strcmp(Item->Text(), LastItemText) != 0))) {
+#endif /* PINPLUGIN */
             Add(Item);
             LastItem = Item;
             free(LastItemText);
@@ -2321,6 +2785,11 @@ eOSState cMenuRecordings::Play(void)
 {
   cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
   if (ri) {
+#ifdef USE_PINPLUGIN
+     if (cStatus::MsgReplayProtected(GetRecording(ri), ri->Name(), base,
+                                     ri->IsDirectory()) == true)
+        return osContinue;
+#endif /* PINPLUGIN */
      if (ri->IsDirectory())
         Open();
      else {
@@ -2438,6 +2907,21 @@ eOSState cMenuRecordings::Commands(eKeys Key)
   return osContinue;
 }
 
+#ifdef USE_LIEMIKUUTIO
+eOSState cMenuRecordings::Edit(void)
+{
+  if (HasSubMenu() || Count() == 0)
+     return osContinue;
+  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
+  if (ri && !ri->IsDirectory()) {
+     cRecording *recording = GetRecording(ri);
+     if (recording)
+        return AddSubMenu(new cMenuEditRecording(recording));
+     }
+  return osContinue;
+}
+#endif /* LIEMIKUUTIO */
+
 eOSState cMenuRecordings::Sort(void)
 {
   if (HasSubMenu())
@@ -2461,7 +2945,11 @@ eOSState cMenuRecordings::ProcessKey(eKeys Key)
        case kYellow: return Delete();
        case kInfo:
        case kBlue:   return Info();
+#ifdef USE_LIEMIKUUTIO
+       case k0:      return Edit();
+#else
        case k0:      return Sort();
+#endif /* LIEMIKUUTIO */
        case k1...k9: return Commands(Key);
        case kNone:   if (Recordings.StateChanged(recordingsState))
                         Set(true);
@@ -2525,6 +3013,9 @@ public:
   cMenuSetupOSD(void);
   virtual ~cMenuSetupOSD();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupOsd"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupOSD::cMenuSetupOSD(void)
@@ -2566,6 +3057,9 @@ void cMenuSetupOSD::Set(void)
   Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
   if (themes.NumThemes())
   Add(new cMenuEditStraItem(tr("Setup.OSD$Theme"),                  &themeIndex, themes.NumThemes(), themes.Descriptions()));
+#ifdef USE_WAREAGLEICON
+  Add(new cMenuEditBoolItem(tr("Setup.OSD$WarEagle icons"),         &data.WarEagleIcons));
+#endif /* WAREAGLEICON */
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Left (%)"),               &data.OSDLeftP, 0.0, 0.5));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Top (%)"),                &data.OSDTopP, 0.0, 0.5));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Width (%)"),              &data.OSDWidthP, 0.5, 1.0));
@@ -2666,6 +3160,9 @@ private:
 public:
   cMenuSetupEPG(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupEpg"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupEPG::cMenuSetupEPG(void)
@@ -2695,6 +3192,12 @@ void cMenuSetupEPG::Setup(void)
   for (int i = 0; i < numLanguages; i++)
       // TRANSLATORS: note the singular!
       Add(new cMenuEditStraItem(tr("Setup.EPG$Preferred language"),    &data.EPGLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
+#ifdef USE_DDEPGENTRY
+  Add(new cMenuEditIntItem(tr("Setup.EPG$Period for double EPG search(min)"), &data.DoubleEpgTimeDelta));
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$extern double Epg entry"),   &data.DoubleEpgAction, "adjust", "delete"));
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$Mix intern and extern EPG"), &data.MixEpgAction));
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$Disable running VPS event"), &data.DisableVPS));
+#endif /* DDEPGENTRY */
 
   SetCurrent(Get(current));
   Display();
@@ -2762,6 +3265,9 @@ private:
 public:
   cMenuSetupDVB(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupDvb"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupDVB::cMenuSetupDVB(void)
@@ -2802,6 +3308,9 @@ void cMenuSetupDVB::Setup(void)
      Add(new cMenuEditStraItem(tr("Setup.DVB$Video display format"), &data.VideoDisplayFormat, 3, videoDisplayFormatTexts));
   Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Dolby Digital"),     &data.UseDolbyDigital));
   Add(new cMenuEditStraItem(tr("Setup.DVB$Update channels"),       &data.UpdateChannels, 6, updateChannelsTexts));
+#ifdef USE_CHANNELBIND
+  Add(new cMenuEditBoolItem(tr("Setup.DVB$channel binding by Rid"),&data.ChannelBindingByRid));
+#endif /* CHANNELBIND */
   Add(new cMenuEditIntItem( tr("Setup.DVB$Audio languages"),       &numAudioLanguages, 0, I18nLanguages()->Size()));
   for (int i = 0; i < numAudioLanguages; i++)
       Add(new cMenuEditStraItem(tr("Setup.DVB$Audio language"),    &data.AudioLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
@@ -2814,6 +3323,9 @@ void cMenuSetupDVB::Setup(void)
      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
      }
+#ifdef USE_TTXTSUBS
+  Add(new cMenuEditBoolItem(tr("Setup.DVB$Enable teletext support"), &data.SupportTeletext));
+#endif // USE_TTXTSUBS
 
   SetCurrent(Get(current));
   Display();
@@ -2906,6 +3418,9 @@ private:
 public:
   cMenuSetupLNB(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupLnb"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupLNB::cMenuSetupLNB(void)
@@ -3008,6 +3523,9 @@ private:
 public:
   cMenuSetupCAM(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupCam"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupCAM::cMenuSetupCAM(void)
@@ -3084,12 +3602,49 @@ class cMenuSetupRecord : public cMenuSetupBase {
 private:
   const char *pauseKeyHandlingTexts[3];
   const char *delTimeshiftRecTexts[3];
+#ifdef USE_DVLVIDPREFER
+  void Set(void);
+  int tmpNVidPrefer,
+      tmpUseVidPrefer;
+#endif /* DVLVIDPREFER */
 public:
   cMenuSetupRecord(void);
+#ifdef USE_DVLVIDPREFER
+  eOSState ProcessKey(eKeys key);
+#endif /* DVLVIDPREFER */
   };
 
 cMenuSetupRecord::cMenuSetupRecord(void)
 {
+#ifdef USE_DVLVIDPREFER
+  Set();
+}
+
+eOSState cMenuSetupRecord::ProcessKey(eKeys key)
+{
+  eOSState s = cMenuSetupBase::ProcessKey(key);;
+
+  if (key != kNone) {
+    if (tmpNVidPrefer != data.nVidPrefer || tmpUseVidPrefer != data.UseVidPrefer) {
+      int cur = Current();
+
+      tmpNVidPrefer = data.nVidPrefer;
+      tmpUseVidPrefer = data.UseVidPrefer;
+
+      Clear();
+      Set();
+      SetCurrent(Get(cur));
+      Display();
+      cMenuSetupBase::ProcessKey(kNone);
+      return osContinue;
+      }
+   }
+   return s;
+}
+
+void cMenuSetupRecord::Set(void)
+{
+#endif /* DVLVIDPREFER */
   pauseKeyHandlingTexts[0] = tr("do not pause live video");
   pauseKeyHandlingTexts[1] = tr("confirm pause live video");
   pauseKeyHandlingTexts[2] = tr("pause live video");
@@ -3104,6 +3659,22 @@ cMenuSetupRecord::cMenuSetupRecord(void)
   Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
+#ifdef USE_DVLVIDPREFER
+  tmpNVidPrefer = data.nVidPrefer;
+  tmpUseVidPrefer = data.UseVidPrefer;
+
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Video directory policy"),    &data.UseVidPrefer));
+  if (data.UseVidPrefer != 0) {
+     char tmp[ 64 ];
+     Add(new cMenuEditIntItem(tr("Setup.Recording$Number of video directories"), &data.nVidPrefer, 1, DVLVIDPREFER_MAX));
+     for (int zz = 0; zz < data.nVidPrefer; zz++) {
+         sprintf(tmp, tr("Setup.Recording$Video %d priority"), zz);
+         Add(new cMenuEditIntItem(tmp, &data.VidPreferPrio[ zz ], 0, 99));
+         sprintf(tmp, tr("Setup.Recording$Video %d min. free MB"), zz);
+         Add(new cMenuEditIntItem(tmp, &data.VidPreferSize[ zz ], -1, 99999));
+         }
+     }
+#endif /* DVLVIDPREFER */
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use VPS"),                   &data.UseVps));
   Add(new cMenuEditIntItem( tr("Setup.Recording$VPS margin (s)"),            &data.VpsMargin, 0));
@@ -3111,8 +3682,15 @@ cMenuSetupRecord::cMenuSetupRecord(void)
   Add(new cMenuEditStrItem( tr("Setup.Recording$Name instant recording"),     data.NameInstantRecord, sizeof(data.NameInstantRecord)));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 1, MAXINSTANTRECTIME));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZETS));
+#ifdef USE_HARDLINKCUTTER
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Max. recording size (GB)"),  &data.MaxRecordingSize, MINRECORDINGSIZE, MAXRECORDINGSIZE));
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Hard Link Cutter"),          &data.HardLinkCutter));
+#endif /* HARDLINKCUTTER */
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
   Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"),&data.DelTimeshiftRec, 3, delTimeshiftRecTexts));
+#ifdef USE_NALUDUMP
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Dump NALU Fill data"),       &data.DumpNaluFill));
+#endif // USE_NALUDUMP
 }
 
 // --- cMenuSetupReplay ------------------------------------------------------
@@ -3131,6 +3709,16 @@ cMenuSetupReplay::cMenuSetupReplay(void)
   Add(new cMenuEditBoolItem(tr("Setup.Replay$Show replay mode"), &data.ShowReplayMode));
   Add(new cMenuEditBoolItem(tr("Setup.Replay$Show remaining time"), &data.ShowRemainingTime));
   Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
+#ifdef USE_JUMPPLAY
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"),          &data.JumpPlay));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"),          &data.PlayJump));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
+#endif /* JUMPPLAY */
+#ifdef USE_JUMPINGSECONDS
+  Add(new cMenuEditIntItem(tr("Setup.Replay$Jump Seconds"),             &data.JumpSeconds));
+  Add(new cMenuEditIntItem(tr("Setup.Replay$Jump Seconds Slow"),        &data.JumpSecondsSlow));
+  Add(new cMenuEditIntItem(tr("Setup.Recording$Jump Seconds (Repeat)"), &data.JumpSecondsRepeat));
+#endif /* USE_JUMPINGSECONDS */
 }
 
 void cMenuSetupReplay::Store(void)
@@ -3143,13 +3731,50 @@ void cMenuSetupReplay::Store(void)
 // --- cMenuSetupMisc --------------------------------------------------------
 
 class cMenuSetupMisc : public cMenuSetupBase {
+#ifdef USE_VOLCTRL
+private:
+  const char *lrChannelGroupsTexts[3];
+  const char *lrForwardRewindTexts[3];
+  void Setup(void);
+#endif // USE_VOLCTRL
 public:
   cMenuSetupMisc(void);
+#ifdef USE_VOLCTRL
+  virtual eOSState ProcessKey(eKeys Key);
+#endif // USE_VOLCTRL
   };
 
 cMenuSetupMisc::cMenuSetupMisc(void)
 {
+#ifdef USE_VOLCTRL
+  lrChannelGroupsTexts[0] = tr("no");
+  lrChannelGroupsTexts[1] = tr("Setup.Miscellaneous$only in channelinfo");
+  lrChannelGroupsTexts[2] = tr("yes");
+  lrForwardRewindTexts[0] = tr("no");
+  lrForwardRewindTexts[1] = tr("Setup.Miscellaneous$only in progress display");
+  lrForwardRewindTexts[2] = tr("yes");
+#endif // USE_VOLCTRL
   SetSection(tr("Miscellaneous"));
+#ifdef USE_VOLCTRL
+  Setup();
+}
+
+eOSState cMenuSetupMisc::ProcessKey(eKeys Key)
+{
+  int newLRVolumeControl = data.LRVolumeControl;
+  eOSState state = cMenuSetupBase::ProcessKey(Key);
+
+  if (Key != kNone && data.LRVolumeControl != newLRVolumeControl)
+     Setup();
+  return state;
+}
+
+void cMenuSetupMisc::Setup(void)
+{
+  int current = Current();
+
+  Clear();
+#endif // USE_VOLCTRL
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. event timeout (min)"),   &data.MinEventTimeout));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. user inactivity (min)"), &data.MinUserInactivity));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$SVDRP timeout (s)"),          &data.SVDRPTimeout));
@@ -3157,9 +3782,25 @@ cMenuSetupMisc::cMenuSetupMisc(void)
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Channel entry timeout (ms)"), &data.ChannelEntryTimeout, 0));
   Add(new cMenuEditChanItem(tr("Setup.Miscellaneous$Initial channel"),            &data.InitialChannel, tr("Setup.Miscellaneous$as before")));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Initial volume"),             &data.InitialVolume, -1, 255, tr("Setup.Miscellaneous$as before")));
+#ifdef USE_VOLCTRL
+  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Volume ctrl with left/right"),     &data.LRVolumeControl));
+  if (data.LRVolumeControl) {
+     Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Channelgroups with left/right"),   &data.LRChannelGroups, 3, lrChannelGroupsTexts));
+     Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Search fwd/back with left/right"), &data.LRForwardRewind, 3, lrForwardRewindTexts));
+  }
+#endif // USE_VOLCTRL
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Channels wrap"),              &data.ChannelsWrap));
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Show channel names with source"), &data.ShowChannelNamesWithSource));
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Emergency exit"),             &data.EmergencyExit));
+#ifdef USE_LIRCSETTINGS
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat delay"),          &data.LircRepeatDelay, 0, 1000));
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat freq"),           &data.LircRepeatFreq, 0, 1000));
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat timeout"),        &data.LircRepeatTimeout, 0, 5000));
+#endif /* LIRCSETTINGS */
+#ifdef USE_VOLCTRL
+  SetCurrent(Get(current));
+  Display();
+#endif // USE_VOLCTRL
 }
 
 // --- cMenuSetupPluginItem --------------------------------------------------
@@ -3184,6 +3825,9 @@ class cMenuSetupPlugins : public cMenuSetupBase {
 public:
   cMenuSetupPlugins(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupPlugins::cMenuSetupPlugins(void)
@@ -3238,6 +3882,9 @@ private:
 public:
   cMenuSetup(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetup"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetup::cMenuSetup(void)
@@ -3328,25 +3975,70 @@ cOsdObject *cMenuMain::pluginOsdObject = NULL;
 cMenuMain::cMenuMain(eOSState State)
 :cOsdMenu("")
 {
+#ifdef USE_SETUP
+  // Load Menu Configuration
+  cString menuXML = cString::sprintf("%s/setup/vdr-menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+  if (access(menuXML, 04) == -1)
+     menuXML = cString::sprintf("%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
+  subMenu.LoadXml(menuXML);
+  nrDynamicMenuEntries = 0;
+#endif /* SETUP */
+
   SetMenuCategory(mcMain);
   replaying = false;
   stopReplayItem = NULL;
   cancelEditingItem = NULL;
+#ifdef USE_LIEMIKUUTIO
+  cancelFileTransferItem = NULL;
+#endif /* LIEMIKUUTIO */
   stopRecordingItem = NULL;
   recordControlsState = 0;
+
+#ifdef USE_MENUORG
+  MenuOrgPatch::EnterRootMenu();
+#endif /* MENUORG */
   Set();
 
   // Initial submenus:
 
+#ifdef USE_MAINMENUHOOKS
+  cOsdObject *menu = NULL;
+#endif /* MAINMENUHOOKS */
   switch (State) {
+#ifdef USE_MAINMENUHOOKS
+    case osSchedule:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
+            menu = new cMenuSchedule;
+        break;
+    case osChannels:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
+            menu = new cMenuChannels;
+        break;
+    case osTimers:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
+            menu = new cMenuTimers;
+        break;
+    case osRecordings:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
+            menu = new cMenuRecordings(NULL, 0, true);
+        break;
+    case osSetup:      menu = new cMenuSetup; break;
+    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+#else
     case osSchedule:   AddSubMenu(new cMenuSchedule); break;
     case osChannels:   AddSubMenu(new cMenuChannels); break;
     case osTimers:     AddSubMenu(new cMenuTimers); break;
     case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
     case osSetup:      AddSubMenu(new cMenuSetup); break;
     case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
+#endif /* MAINMENUHOOKS */
     default: break;
     }
+#ifdef USE_MAINMENUHOOKS
+  if (menu)
+     if (menu->IsMenu())
+        AddSubMenu((cOsdMenu *) menu);
+#endif /* MAINMENUHOOKS */
 }
 
 cOsdObject *cMenuMain::PluginOsdObject(void)
@@ -3356,37 +4048,156 @@ cOsdObject *cMenuMain::PluginOsdObject(void)
   return o;
 }
 
+#ifdef USE_SETUP
+void cMenuMain::Set(int current)
+#else
 void cMenuMain::Set(void)
+#endif /* SETUP */
 {
   Clear();
   SetTitle("VDR");
   SetHasHotkeys();
 
+#ifdef USE_MENUORG
+  if (MenuOrgPatch::IsCustomMenuAvailable()) {
+     MenuItemDefinitions* menuItems = MenuOrgPatch::MainMenuItems();
+     for (MenuItemDefinitions::iterator i = menuItems->begin(); i != menuItems->end(); i++) {
+        cOsdItem* osdItem = NULL;
+        if ((*i)->IsCustomOsdItem()) {
+           osdItem = (*i)->CustomOsdItem();
+           if (osdItem &&  !(*i)->IsSeparatorItem())
+              osdItem->SetText(hk(osdItem->Text()));
+           }
+        else if ((*i)->IsPluginItem()) {
+           const char *item = (*i)->PluginMenuEntry();
+           if (item)
+              osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
+           }
+        if (osdItem) {
+           Add(osdItem);
+           if ((*i)->IsSelected())
+              SetCurrent(osdItem);
+           }
+        }
+     }
+  else {
+#endif /* MENUORG */
+#ifdef USE_SETUP
+  stopReplayItem = NULL;
+  cancelEditingItem = NULL;
+  stopRecordingItem = NULL;
+
+  // remember initial dynamic MenuEntries added
+  nrDynamicMenuEntries = Count();
+  for (cSubMenuNode *node = subMenu.GetMenuTree()->First(); node; node = subMenu.GetMenuTree()->Next(node)) {
+      cSubMenuNode::Type type = node->GetType();
+      if (type==cSubMenuNode::PLUGIN) {
+         const char *item = node->GetPluginMainMenuEntry();
+#ifdef USE_PINPLUGIN
+         if (item && !cStatus::MsgPluginProtected(cPluginManager::GetPlugin(node->GetPluginIndex()), true))
+#else
+         if (item)
+#endif /* PINPLUGIN */
+            Add(new cMenuPluginItem(hk(item), node->GetPluginIndex()));
+         }
+      else if (type==cSubMenuNode::MENU) {
+         cString item = cString::sprintf("%s%s", node->GetName(), *subMenu.GetMenuSuffix());
+#ifdef USE_PINPLUGIN
+         if (!cStatus::MsgMenuItemProtected(item, true))
+            Add(new cOsdItem(hk(item), osUnknown, node));
+#else
+            Add(new cOsdItem(hk(item)));
+#endif /* PINPLUGIN */
+         }
+      else if ((type==cSubMenuNode::COMMAND) || (type==cSubMenuNode::THREAD)) {
+#ifdef USE_PINPLUGIN
+         if (!cStatus::MsgMenuItemProtected(node->GetName(), true))
+            Add(new cOsdItem(hk(node->GetName()), osUnknown, node));
+#else
+            Add(new cOsdItem(hk(node->GetName())));
+#endif /* PINPLUGIN */
+         }
+      else if (type==cSubMenuNode::SYSTEM) {
+         const char *item = node->GetName();
+#ifdef USE_PINPLUGIN
+         if (cStatus::MsgMenuItemProtected(item, true))
+            ; // nothing to do ;)
+         else
+#endif /* PINPLUGIN */
+         if (strcmp(item, "Schedule") == 0)
+            Add(new cOsdItem(hk(tr("Schedule")), osSchedule));
+         else if (strcmp(item, "Channels") == 0)
+            Add(new cOsdItem(hk(tr("Channels")), osChannels));
+         else if (strcmp(item, "Timers") == 0)
+            Add(new cOsdItem(hk(tr("Timers")), osTimers));
+         else if (strcmp(item, "Recordings") == 0)
+            Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+         else if (strcmp(item, "Setup") == 0) {
+            cString itemSetup = cString::sprintf("%s%s", tr("Setup"), *subMenu.GetMenuSuffix());
+            Add(new cOsdItem(hk(itemSetup), osSetup));
+            }
+         else if (strcmp(item, "Commands") == 0 && Commands.Count() > 0) {
+            cString itemCommands = cString::sprintf("%s%s", tr("Commands"), *subMenu.GetMenuSuffix());
+            Add(new cOsdItem(hk(itemCommands), osCommands));
+            }
+         }
+     }
+  if (current >=0 && current<Count()) {
+     SetCurrent(Get(current));
+     }
+
+#else /* NO SETUP */
+
   // Basic menu items:
 
+#ifdef USE_PINPLUGIN
+  if (!cStatus::MsgMenuItemProtected("Schedule", true))   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+  if (!cStatus::MsgMenuItemProtected("Channels", true))   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
+  if (!cStatus::MsgMenuItemProtected("Timers", true))     Add(new cOsdItem(hk(tr("Timers")),     osTimers));
+  if (!cStatus::MsgMenuItemProtected("Recordings", true)) Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+#else
   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
   Add(new cOsdItem(hk(tr("Timers")),     osTimers));
   Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+#endif /* PINPLUGIN */
 
   // Plugins:
 
   for (int i = 0; ; i++) {
       cPlugin *p = cPluginManager::GetPlugin(i);
       if (p) {
+#ifdef USE_PINPLUGIN
+         if (!cStatus::MsgPluginProtected(p, true)) {
+#endif /* PINPLUGIN */
          const char *item = p->MainMenuEntry();
          if (item)
             Add(new cMenuPluginItem(hk(item), i));
          }
+#ifdef USE_PINPLUGIN
+         }
+#endif /* PINPLUGIN */
       else
          break;
       }
 
   // More basic menu items:
 
+#ifdef USE_PINPLUGIN
+  if (!cStatus::MsgMenuItemProtected("Setup", true)) Add(new cOsdItem(hk(tr("Setup")), osSetup));
+#else
   Add(new cOsdItem(hk(tr("Setup")),      osSetup));
+#endif /* PINPLUGIN */
   if (Commands.Count())
+#ifdef USE_PINPLUGIN
+     if (!cStatus::MsgMenuItemProtected("Commands", true))
+#endif /* PINPLUGIN */
      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+#endif /* SETUP */
+
+#ifdef USE_MENUORG
+  }
+#endif /* MENUORG */
 
   Update(true);
 
@@ -3397,6 +4208,19 @@ bool cMenuMain::Update(bool Force)
 {
   bool result = false;
 
+#ifdef USE_SETUP
+  cOsdItem *fMenu = NULL;
+  if (Force && subMenu.isTopMenu()) {
+     fMenu = First();
+     nrDynamicMenuEntries = 0;
+     }
+
+  if (!subMenu.isTopMenu()) {
+     SetTitle(cString::sprintf("%s  -  %s", tr("VDR"), subMenu.GetParentMenuTitel()));
+     result = true;
+     }
+#endif /* SETUP */
+
   bool NewReplaying = cControl::Control() != NULL;
   if (Force || NewReplaying != replaying) {
      replaying = NewReplaying;
@@ -3426,6 +4250,21 @@ bool cMenuMain::Update(bool Force)
      result = true;
      }
 
+#ifdef USE_LIEMIKUUTIO
+  // File transfer control:
+  bool FileTransferActive = cFileTransfer::Active();
+  if (FileTransferActive && !cancelFileTransferItem) {
+	  // TRANSLATORS: note the leading blank!
+	  Add(cancelFileTransferItem = new cOsdItem(tr(" Cancel file transfer"), osCancelTransfer));
+	  result = true;
+  }
+  else if (cancelFileTransferItem && !FileTransferActive) {
+	  Del(cancelFileTransferItem->Index());
+	  cancelFileTransferItem = NULL;
+	  result = true;
+  }
+#endif /* LIEMIKUUTIO */
+
   // Record control:
   if (cRecordControls::StateChanged(recordControlsState)) {
      while (stopRecordingItem) {
@@ -3444,6 +4283,12 @@ bool cMenuMain::Update(bool Force)
      result = true;
      }
 
+#ifdef USE_SETUP
+  // adjust nrDynamicMenuEntries
+  if (fMenu != NULL)
+     nrDynamicMenuEntries = fMenu->Index();
+#endif /* SETUP */
+
   return result;
 }
 
@@ -3454,13 +4299,53 @@ eOSState cMenuMain::ProcessKey(eKeys Key)
   eOSState state = cOsdMenu::ProcessKey(Key);
   HadSubMenu |= HasSubMenu();
 
+#ifdef USE_PINPLUGIN
+  cOsdItem* item = Get(Current());
+
+  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
+     if (cStatus::MsgMenuItemProtected(item->Text()))
+        return osContinue;
+#endif /* PINPLUGIN */
+
+#ifdef USE_MAINMENUHOOKS
+  cOsdObject *menu = NULL;
+#endif /* MAINMENUHOOKS */
   switch (state) {
+#ifdef USE_MAINMENUHOOKS
+    case osSchedule:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
+            menu = new cMenuSchedule;
+        else
+            state = osContinue;
+        break;
+    case osChannels:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
+            menu = new cMenuChannels;
+        else
+            state = osContinue;
+        break;
+    case osTimers:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
+            menu = new cMenuTimers;
+        else
+            state = osContinue;
+        break;
+    case osRecordings:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
+            menu = new cMenuRecordings;
+        else
+            state = osContinue;
+        break;
+    case osSetup:      menu = new cMenuSetup; break;
+    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+#else
     case osSchedule:   return AddSubMenu(new cMenuSchedule);
     case osChannels:   return AddSubMenu(new cMenuChannels);
     case osTimers:     return AddSubMenu(new cMenuTimers);
     case osRecordings: return AddSubMenu(new cMenuRecordings);
     case osSetup:      return AddSubMenu(new cMenuSetup);
     case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
+#endif /* MAINMENUHOOKS */
     case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
                           cOsdItem *item = Get(Current());
                           if (item) {
@@ -3474,11 +4359,22 @@ eOSState cMenuMain::ProcessKey(eKeys Key)
                           return osEnd;
                           }
                        break;
+#ifdef USE_LIEMIKUUTIO
+    case osCancelTransfer:
+                       if (Interface->Confirm(tr("Cancel file transfer?"))) {
+                          cFileTransfer::Stop();
+                          return osEnd;
+                          }
+                       break;
+#endif
     case osPlugin:     {
                          cMenuPluginItem *item = (cMenuPluginItem *)Get(Current());
                          if (item) {
                             cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
                             if (p) {
+#ifdef USE_PINPLUGIN
+                               if (!cStatus::MsgPluginProtected(p)) {
+#endif /* PINPLUGIN */
                                cOsdObject *menu = p->MainMenuAction();
                                if (menu) {
                                   if (menu->IsMenu())
@@ -3488,11 +4384,63 @@ eOSState cMenuMain::ProcessKey(eKeys Key)
                                      return osPlugin;
                                      }
                                   }
+#ifdef USE_PINPLUGIN
+                               }
+#endif /* PINPLUGIN */
                                }
                             }
                          state = osEnd;
                        }
                        break;
+#ifdef USE_MENUORG
+    case osBack:       {
+                          if (MenuOrgPatch::IsCustomMenuAvailable())
+                          {
+                              bool leavingMenuSucceeded = MenuOrgPatch::LeaveSubMenu();
+                              Set();
+                              stopReplayItem = NULL;
+                              cancelEditingItem = NULL;
+                              stopRecordingItem = NULL;
+                              recordControlsState = 0;
+                              Update(true);
+                              Display();
+                              if (leavingMenuSucceeded)
+                                 return osContinue;
+                              else
+                                 return osEnd;
+                          }
+                       }
+                       break;
+    case osUser1:      {
+                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
+                             MenuOrgPatch::EnterSubMenu(Get(Current()));
+                             Set();
+                             return osContinue;
+                          }
+                       }
+                       break;
+    case osUser2:      {
+                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
+                             cOsdMenu* osdMenu = MenuOrgPatch::Execute(Get(Current()));
+                             if (osdMenu)
+                                return AddSubMenu(osdMenu);
+                             return osEnd;
+                          }
+                       }
+                       break;
+#endif /* MENUORG */
+#ifdef USE_SETUP
+    case osBack:       {
+                         int newCurrent = 0;
+                         if (subMenu.Up(&newCurrent)) {
+                            Set(newCurrent);
+                            return osContinue;
+                            }
+                         else
+                            return osEnd;
+                       }
+                       break;
+#endif /* SETUP */
     default: switch (Key) {
                case kRecord:
                case kRed:    if (!HadSubMenu)
@@ -3509,9 +4457,67 @@ eOSState cMenuMain::ProcessKey(eKeys Key)
                case kBlue:   if (!HadSubMenu)
                                 state = replaying ? osStopReplay : cReplayControl::LastReplayed() ? osReplay : osContinue;
                              break;
+#ifdef USE_SETUP
+               case kOk:     if (state == osUnknown) {
+                                cString buffer;
+                                int index = Current()-nrDynamicMenuEntries;
+                                cSubMenuNode *node = subMenu.GetNode(index);
+
+                                if (node != NULL) {
+                                   if (node->GetType() == cSubMenuNode::MENU) {
+#ifdef USE_PINPLUGIN
+                                      subMenu.Down(node, Current());
+#else
+                                      subMenu.Down(index);
+#endif /* PINPLUGIN */
+                                      }
+                                   else if (node->GetType() == cSubMenuNode::COMMAND) {
+                                      bool confirmed = true;
+                                      if (node->CommandConfirm()) {
+                                         buffer = cString::sprintf("%s?", node->GetName());
+                                         confirmed = Interface->Confirm(buffer);
+                                         }
+                                      if (confirmed) {
+                                         const char *Result = subMenu.ExecuteCommand(node->GetCommand());
+                                         if (Result)
+                                            return AddSubMenu(new cMenuText(node->GetName(), Result, fontFix));
+                                         return osEnd;
+                                         }
+                                      }
+                                   else if (node->GetType() == cSubMenuNode::THREAD) {
+                                      bool confirmed = true;
+                                      if (node->CommandConfirm()) {
+                                         buffer = cString::sprintf("%s?", node->GetName());
+                                         confirmed = Interface->Confirm(buffer);
+                                         }
+                                      if (confirmed) {
+                                         buffer = cString::sprintf("%s", node->GetCommand());
+                                         cExecCmdThread *execcmd = new cExecCmdThread(node->GetCommand());
+                                         if (execcmd->Start())
+                                            dsyslog("executing command '%s'", *buffer);
+                                         else
+                                            esyslog("ERROR: can't execute command '%s'", *buffer);
+                                         return osEnd;
+                                         }
+                                      }
+                                   }
+
+                                Set();
+                                return osContinue;
+                                }
+                             break;
+#endif /* SETUP */
                default:      break;
                }
     }
+#ifdef USE_MAINMENUHOOKS
+  if (menu) {
+     if (menu->IsMenu())
+        return AddSubMenu((cOsdMenu *) menu);
+     pluginOsdObject = menu;
+     return osPlugin;
+  }
+#endif /* MAINMENUHOOKS */
   if (!HasSubMenu() && Update(HadSubMenu))
      Display();
   if (Key != kNone) {
@@ -3658,6 +4664,9 @@ cChannel *cDisplayChannel::NextAvailableChannel(cChannel *Channel, int Direction
   if (Direction) {
      while (Channel) {
            Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
+#ifdef USE_PINPLUGIN
+        if (cStatus::MsgChannelProtected(0, Channel) == false)
+#endif /* PINPLUGIN */
            if (!Channel && Setup.ChannelsWrap)
               Channel = Direction > 0 ? Channels.First() : Channels.Last();
            if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, LIVEPRIORITY, true, true))
@@ -3718,6 +4727,13 @@ eOSState cDisplayChannel::ProcessKey(eKeys Key)
     case kLeft:
     case kRight|k_Repeat:
     case kRight:
+#ifdef USE_VOLCTRL
+        if (Setup.LRVolumeControl && !Setup.LRChannelGroups) {
+          cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
+          break;
+           }
+        // else fall through
+#endif // USE_VOLCTRL
     case kNext|k_Repeat:
     case kNext:
     case kPrev|k_Repeat:
@@ -3877,6 +4893,17 @@ void cDisplayVolume::Process(eKeys Key)
 eOSState cDisplayVolume::ProcessKey(eKeys Key)
 {
   switch (int(Key)) {
+#ifdef USE_VOLCTRL
+   case kLeft|k_Repeat:
+   case kLeft:
+   case kRight|k_Repeat:
+   case kRight:
+        if (Setup.LRVolumeControl) {
+          cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
+          break;
+           }
+        // else fall through
+#endif // USE_VOLCTRL
     case kVolUp|k_Repeat:
     case kVolUp:
     case kVolDn|k_Repeat:
@@ -4124,7 +5151,11 @@ eOSState cDisplaySubtitleTracks::ProcessKey(eKeys Key)
 
 // --- cRecordControl --------------------------------------------------------
 
+#ifdef USE_ALTERNATECHANNEL
+cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause, cChannel *Channel)
+#else
 cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
+#endif /* ALTERNATECHANNEL */
 {
   // Whatever happens here, the timers will be modified in some way...
   Timers.SetModified();
@@ -4173,9 +5204,16 @@ cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
   cRecordingUserCommand::InvokeCommand(RUC_BEFORERECORDING, fileName);
   isyslog("record %s", fileName);
   if (MakeDirs(fileName, true)) {
+#ifdef USE_ALTERNATECHANNEL
+     const cChannel *ch = Channel ? Channel : timer->Channel();
+     if (ch)
+        recorder = new cRecorder(fileName, ch, timer->Priority());
+     if (ch && device->AttachReceiver(recorder)) {
+#else
      const cChannel *ch = timer->Channel();
      recorder = new cRecorder(fileName, ch, timer->Priority());
      if (device->AttachReceiver(recorder)) {
+#endif /* ALTERNATECHANNEL */
         Recording.WriteInfo();
         cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
         if (!Timer && !cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
@@ -4198,7 +5236,12 @@ cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
         return;
         }
      else
+#ifdef USE_ALTERNATECHANNEL
+        if (ch)
         DELETENULL(recorder);
+#else
+        DELETENULL(recorder);
+#endif /* ALTERNATECHANNEL */
      }
   else
      timer->SetDeferred(DEFERTIMER);
@@ -4299,6 +5342,17 @@ bool cRecordControls::Start(cTimer *Timer, bool Pause)
   if (channel) {
      int Priority = Timer ? Timer->Priority() : Pause ? Setup.PausePriority : Setup.DefaultPriority;
      cDevice *device = cDevice::GetDevice(channel, Priority, false);
+
+#ifdef USE_ALTERNATECHANNEL
+     if (!device && channel->AlternativeChannelID().Valid()) {// check for alternatives
+        dsyslog("prepare to use alternative channel for channel %d", channel->Number());
+        channel = Channels.GetByChannelID(channel->AlternativeChannelID());
+        device = cDevice::GetDevice(channel, Priority, false);
+        if (device)
+            dsyslog("use of alternative channel %d successfully initiated", channel->Number());
+        }
+#endif /* ALTERNATECHANNEL */
+
      if (device) {
         dsyslog("switching device %d to channel %d", device->DeviceNumber() + 1, channel->Number());
         if (!device->SwitchChannel(channel, false)) {
@@ -4308,7 +5362,14 @@ bool cRecordControls::Start(cTimer *Timer, bool Pause)
         if (!Timer || Timer->Matches()) {
            for (int i = 0; i < MAXRECORDCONTROLS; i++) {
                if (!RecordControls[i]) {
+#ifdef USE_ALTERNATECHANNEL
+                  RecordControls[i] = new cRecordControl(device, Timer, Pause, channel);
+#else
                   RecordControls[i] = new cRecordControl(device, Timer, Pause);
+#endif /* ALTERNATECHANNEL */
+#ifdef USE_PINPLUGIN
+                  cStatus::MsgRecordingFile(RecordControls[i]->FileName());
+#endif /* PINPLUGIN */
                   return RecordControls[i]->Process(time(NULL));
                   }
                }
@@ -4447,6 +5508,12 @@ bool cRecordControls::StateChanged(int &State)
 
 // --- cReplayControl --------------------------------------------------------
 
+#ifdef USE_LIEMIKUUTIO
+#define REPLAYCONTROLSKIPLIMIT   9    // s
+#define REPLAYCONTROLSKIPSECONDS 90   // s
+#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
+#endif /* LIEMIKUUTIO */
+
 cReplayControl *cReplayControl::currentReplayControl = NULL;
 cString cReplayControl::fileName;
 
@@ -4459,6 +5526,11 @@ cReplayControl::cReplayControl(bool PauseLive)
   lastCurrent = lastTotal = -1;
   lastPlay = lastForward = false;
   lastSpeed = -2; // an invalid value
+#ifdef USE_LIEMIKUUTIO
+  lastSkipKey = kNone;
+  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+  lastSkipTimeout.Set(0);
+#endif /* LIEMIKUUTIO */
   timeoutShow = 0;
   timeSearchActive = false;
   cRecording Recording(fileName);
@@ -4725,8 +5797,16 @@ void cReplayControl::MarkToggle(void)
         marks.Add(Current);
         bool Play, Forward;
         int Speed;
+#ifdef USE_JUMPPLAY
+        if (GetReplayMode(Play, Forward, Speed) && !Play) {
+#else
         if (GetReplayMode(Play, Forward, Speed) && !Play)
+#endif /* JUMPPLAY */
            Goto(Current, true);
+#ifdef USE_JUMPPLAY
+           displayFrames = true;
+           }
+#endif /* JUMPPLAY */
         }
      ShowTimed(2);
      marks.Save();
@@ -4740,8 +5820,22 @@ void cReplayControl::MarkJump(bool Forward)
      if (GetIndex(Current, Total)) {
         cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current);
         if (m) {
+#ifdef USE_JUMPPLAY
+           bool Play2, Forward2;
+           int Speed;
+           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
+               Play2 && Forward && m->Position() < Total - SecondsToFrames(3, FramesPerSecond())) {
+              Goto(m->Position());
+              Play();
+              }
+           else {
+              Goto(m->Position(), true);
+              displayFrames = true;
+              }
+#else
            Goto(m->Position(), true);
            displayFrames = true;
+#endif /* JUMPPLAY */
            }
         }
      }
@@ -4778,7 +5872,11 @@ void cReplayControl::EditCut(void)
      if (!cCutter::Active()) {
         if (!marks.Count())
            Skins.Message(mtError, tr("No editing marks defined!"));
+#ifdef USE_LIEMIKUUTIO
+		else if (!cCutter::Start(fileName, NULL, false))
+#else
         else if (!cCutter::Start(fileName))
+#endif /* LIEMIKUUTIO */
            Skins.Message(mtError, tr("Can't start editing process!"));
         else
            Skins.Message(mtInfo, tr("Editing process started"));
@@ -4797,7 +5895,11 @@ void cReplayControl::EditTest(void)
      if (!m)
         m = marks.GetNext(Current);
      if (m) {
+#ifdef USE_JUMPPLAY
+        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
+#else
         if ((m->Index() & 0x01) != 0)
+#endif /* JUMPPLAY */
            m = marks.Next(m);
         if (m) {
            Goto(m->Position() - SecondsToFrames(3, FramesPerSecond()));
@@ -4846,6 +5948,24 @@ eOSState cReplayControl::ProcessKey(eKeys Key)
      return osContinue;
      }
   bool DoShowMode = true;
+#ifdef USE_VOLCTRL
+  if (Setup.LRVolumeControl &&
+       (!Setup.LRForwardRewind ||
+      (Setup.LRForwardRewind == 1 && !visible))) {
+    switch (int(Key)) {
+      // Left/Right volume control
+      case kLeft|k_Repeat:
+      case kLeft:
+      case kRight|k_Repeat:
+      case kRight:
+        cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
+        return osContinue;
+        break;
+      default:
+        break;
+    }
+  }
+#endif // USE_VOLCTRL
   switch (int(Key)) {
     // Positioning:
     case kPlay:
@@ -4863,10 +5983,53 @@ eOSState cReplayControl::ProcessKey(eKeys Key)
     case kFastFwd:
     case kRight:   Forward(); break;
     case kRed:     TimeSearch(); break;
+#ifdef USE_JUMPINGSECONDS
+    case kGreen|k_Repeat:
+                   SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
+    case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
+    case k1|k_Repeat:
+    case k1:       SkipSeconds(-Setup.JumpSecondsSlow); break;
+    case k3|k_Repeat:
+    case k3:       SkipSeconds( Setup.JumpSecondsSlow); break;
+    case kYellow|k_Repeat:
+                   SkipSeconds(Setup.JumpSecondsRepeat); break;
+    case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
+#else
     case kGreen|k_Repeat:
     case kGreen:   SkipSeconds(-60); break;
     case kYellow|k_Repeat:
     case kYellow:  SkipSeconds( 60); break;
+#endif /* JUMPINGSECONDS */
+#ifdef USE_LIEMIKUUTIO
+#ifndef USE_JUMPINGSECONDS
+    case k1|k_Repeat:
+    case k1:       SkipSeconds(-20); break;
+    case k3|k_Repeat:
+    case k3:       SkipSeconds( 20); break;
+#endif /* JUMPINGSECONDS */
+    case kPrev|k_Repeat:
+    case kPrev:    if (lastSkipTimeout.TimedOut()) {
+                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                      lastSkipKey = kPrev;
+                   }
+                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                      lastSkipSeconds /= 2;
+                      lastSkipKey = kNone;
+                   }
+                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                   SkipSeconds(-lastSkipSeconds); break;
+    case kNext|k_Repeat:
+    case kNext:    if (lastSkipTimeout.TimedOut()) {
+                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                      lastSkipKey = kNext;
+                   }
+                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                      lastSkipSeconds /= 2;
+                      lastSkipKey = kNone;
+                   }
+                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                   SkipSeconds(lastSkipSeconds); break;
+#endif /* LIEMIKUUTIO */
     case kStop:
     case kBlue:    Hide();
                    Stop();
@@ -4876,12 +6039,16 @@ eOSState cReplayControl::ProcessKey(eKeys Key)
       switch (int(Key)) {
         // Editing:
         case kMarkToggle:      MarkToggle(); break;
+#ifndef USE_LIEMIKUUTIO
         case kPrev|k_Repeat:
         case kPrev:
+#endif /* LIEMIKUUTIO */
         case kMarkJumpBack|k_Repeat:
         case kMarkJumpBack:    MarkJump(false); break;
+#ifndef USE_LIEMIKUUTIO
         case kNext|k_Repeat:
         case kNext:
+#endif /* LIEMIKUUTIO */
         case kMarkJumpForward|k_Repeat:
         case kMarkJumpForward: MarkJump(true); break;
         case kMarkMoveBack|k_Repeat:
diff --git a/menu.h b/menu.h
index ba93c5d..5ced0de 100644
--- a/menu.h
+++ b/menu.h
@@ -18,6 +18,9 @@
 #include "menuitems.h"
 #include "recorder.h"
 #include "skins.h"
+#ifdef USE_SETUP
+#include "submenu.h"
+#endif /* SETUP */
 
 class cMenuText : public cOsdMenu {
 private:
@@ -51,6 +54,9 @@ public:
   cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path = NULL);
   cString GetFolder(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuText"; }
+#endif /* GRAPHTFT */
   };
 
 class cMenuCommands : public cOsdMenu {
@@ -85,6 +91,9 @@ public:
   cMenuEditTimer(cTimer *Timer, bool New = false);
   virtual ~cMenuEditTimer();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuTimerEdit"; }
+#endif /* GRAPHTFT */
   };
 
 class cMenuEvent : public cOsdMenu {
@@ -94,22 +103,40 @@ public:
   cMenuEvent(const cEvent *Event, bool CanSwitch = false, bool Buttons = false);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuEvent"; }
+#endif /* GRAPHTFT */
   };
 
 class cMenuMain : public cOsdMenu {
 private:
+#ifdef USE_SETUP
+  int    nrDynamicMenuEntries;
+#endif /* SETUP */
   bool replaying;
   cOsdItem *stopReplayItem;
   cOsdItem *cancelEditingItem;
+#ifdef USE_LIEMIKUUTIO
+  cOsdItem *cancelFileTransferItem;
+#endif /* LIEMIKUUTIO */
   cOsdItem *stopRecordingItem;
   int recordControlsState;
   static cOsdObject *pluginOsdObject;
+#ifdef USE_SETUP
+  void Set(int current=0);
+  bool Update(bool Force = false);
+  cSubMenu subMenu;
+#else
   void Set(void);
   bool Update(bool Force = false);
+#endif /* SETUP */
 public:
   cMenuMain(eOSState State = osUnknown);
   virtual eOSState ProcessKey(eKeys Key);
   static cOsdObject *PluginOsdObject(void);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuMain"; }
+#endif /* GRAPHTFT */
   };
 
 class cDisplayChannel : public cOsdObject {
@@ -206,6 +233,9 @@ private:
   eOSState Info(void);
   eOSState Sort(void);
   eOSState Commands(eKeys Key = kNone);
+#ifdef USE_LIEMIKUUTIO
+  eOSState Edit(void);
+#endif /* LIEMIKUUTIO */
 protected:
   cString DirectoryName(void);
   cRecording *GetRecording(cMenuRecordingItem *Item);
@@ -225,7 +255,11 @@ private:
   char *fileName;
   bool GetEvent(void);
 public:
+#ifdef USE_ALTERNATECHANNEL
+  cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false, cChannel *Channel = NULL);
+#else
   cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false);
+#endif /* ALTERNATECHANNEL */
   virtual ~cRecordControl();
   bool Process(time_t t);
   cDevice *Device(void) { return device; }
@@ -264,6 +298,11 @@ private:
   int lastCurrent, lastTotal;
   bool lastPlay, lastForward;
   int lastSpeed;
+#ifdef USE_LIEMIKUUTIO
+  int lastSkipSeconds;
+  eKeys lastSkipKey;
+  cTimeMs lastSkipTimeout;
+#endif /* LIEMIKUUTIO */
   time_t timeoutShow;
   bool timeSearchActive, timeSearchHide;
   int timeSearchTime, timeSearchPos;
diff --git a/menuitems.h b/menuitems.h
index ffe9957..4262607 100644
--- a/menuitems.h
+++ b/menuitems.h
@@ -209,6 +209,9 @@ public:
   cMenuSetupPage(void);
   virtual eOSState ProcessKey(eKeys Key);
   void SetPlugin(cPlugin *Plugin);
+#ifdef USE_GRAPHTFT
+  const char* MenuKind() { return "MenuSetupPage"; }
+#endif /* GRAPHTFT */
   };
 
 #endif //__MENUITEMS_H
diff --git a/menuorgpatch.h b/menuorgpatch.h
new file mode 100644
index 0000000..289a4ea
--- /dev/null
+++ b/menuorgpatch.h
@@ -0,0 +1,102 @@
+#ifdef USE_MENUORG
+/*
+ * vdr-menuorg - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2007 - 2008 Tobias Grimm <vdr@e-tobi.net>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * $Id$
+ *
+ */
+
+#ifndef __MENUORGPATCH_H
+#define __MENUORGPATCH_H
+
+#include "mainmenuitemsprovider.h"
+
+class MenuOrgPatch
+{
+    private:
+        static IMainMenuItemsProvider* _mainMenuItemsProvider;
+
+    private:
+        static IMainMenuItemsProvider* MainMenuItemsProvider()
+        {
+            if (!_mainMenuItemsProvider)
+            {
+                IMainMenuItemsProvider* mainMenuItemsProvider;
+
+                if (cPluginManager::CallFirstService(MENU_ITEMS_PROVIDER_SERVICE_ID, &mainMenuItemsProvider))
+                {
+                    _mainMenuItemsProvider = mainMenuItemsProvider;
+                }
+            }
+            return _mainMenuItemsProvider;
+        }
+
+    public:
+        static bool IsCustomMenuAvailable()
+        {
+            return (MainMenuItemsProvider() != NULL) && (MainMenuItemsProvider()->IsCustomMenuAvailable());
+        }
+
+        static void EnterRootMenu()
+        {
+            if (MainMenuItemsProvider())
+            {
+                MainMenuItemsProvider()->EnterRootMenu();
+            }
+        }
+
+        static bool LeaveSubMenu()
+        {
+            if (MainMenuItemsProvider())
+            {
+                return MainMenuItemsProvider()->LeaveSubMenu();
+            }
+            return false;
+        }
+
+        static void EnterSubMenu(cOsdItem* item)
+        {
+            if (MainMenuItemsProvider())
+            {
+                MainMenuItemsProvider()->EnterSubMenu(item);
+            }
+        }
+
+        static MenuItemDefinitions* MainMenuItems()
+        {
+            if (MainMenuItemsProvider())
+            {
+                return MainMenuItemsProvider()->MainMenuItems();
+            }
+            return NULL;
+        }
+
+        static cOsdMenu* Execute(cOsdItem* item)
+        {
+            if (MainMenuItemsProvider())
+            {
+                return MainMenuItemsProvider()->Execute(item);
+            }
+            return NULL;
+        }
+};
+
+IMainMenuItemsProvider* MenuOrgPatch::_mainMenuItemsProvider = NULL;
+
+#endif //__MENUORGPATCH_H
+#endif /* MENUORG */
diff --git a/osd.c b/osd.c
index d82a27b..9b26b2b 100644
--- a/osd.c
+++ b/osd.c
@@ -1623,6 +1623,10 @@ int cOsd::osdWidth = 0;
 int cOsd::osdHeight = 0;
 cVector<cOsd *> cOsd::Osds;
 cMutex cOsd::mutex;
+#ifdef USE_PINPLUGIN
+bool cOsd::pinValid = false;
+#endif /* PINPLUGIN */
+
 
 cOsd::cOsd(int Left, int Top, uint Level)
 {
@@ -1637,6 +1641,9 @@ cOsd::cOsd(int Left, int Top, uint Level)
   width = height = 0;
   level = Level;
   active = false;
+#ifdef USE_YAEPG
+  vidWin.bpp = 0;
+#endif /* YAEPG */
   for (int i = 0; i < Osds.Size(); i++) {
       if (Osds[i]->level > level) {
          Osds.Insert(this, i);
diff --git a/osd.h b/osd.h
index 06c020a..bb47dd8 100644
--- a/osd.h
+++ b/osd.h
@@ -730,6 +730,10 @@ private:
   int left, top, width, height;
   uint level;
   bool active;
+#ifdef USE_YAEPG
+public:
+  tArea vidWin;
+#endif /* YAEPG */
 protected:
   cOsd(int Left, int Top, uint Level);
        ///< Initializes the OSD with the given coordinates.
@@ -931,6 +935,9 @@ public:
        ///<        MyOsdDrawPixmap(Left() + pm->ViewPort().X(), Top() + pm->ViewPort().Y(), pm->Data(), w, h, h * d);
        ///<        delete pm;
        ///<        }
+#ifdef USE_PINPLUGIN
+  static bool pinValid;
+#endif /* PINPLUGIN */
   };
 
 #define MAXOSDIMAGES 64
diff --git a/osdbase.c b/osdbase.c
index 3743730..3777da7 100644
--- a/osdbase.c
+++ b/osdbase.c
@@ -23,6 +23,9 @@ cOsdItem::cOsdItem(eOSState State)
   state = State;
   selectable = true;
   fresh = true;
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+  subMenu = 0;
+#endif /* SETUP & PINPLUGIN */
 }
 
 cOsdItem::cOsdItem(const char *Text, eOSState State, bool Selectable)
@@ -32,8 +35,23 @@ cOsdItem::cOsdItem(const char *Text, eOSState State, bool Selectable)
   selectable = Selectable;
   fresh = true;
   SetText(Text);
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+  subMenu = 0;
+#endif /* SETUP & PINPLUGIN */
 }
 
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+cOsdItem::cOsdItem(const char *Text, eOSState State, cSubMenuNode* SubMenu)
+{
+  text = NULL;
+  state = State;
+  selectable = true;
+  fresh = true;
+  SetText(Text);
+  subMenu = SubMenu;
+}
+#endif /* SETUP & PINPLUGIN */
+
 cOsdItem::~cOsdItem()
 {
   free(text);
@@ -77,6 +95,9 @@ cOsdMenu::cOsdMenu(const char *Title, int c0, int c1, int c2, int c3, int c4)
 {
   isMenu = true;
   digit = 0;
+#ifdef USE_LIEMIKUUTIO
+  key_nr = -1;
+#endif /* LIEMIKUUTIO */
   hasHotkeys = false;
   displayMenuItems = 0;
   title = NULL;
@@ -100,6 +121,9 @@ cOsdMenu::~cOsdMenu()
   free(status);
   displayMenu->Clear();
   cStatus::MsgOsdClear();
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdMenuDestroy();
+#endif /* GRAPHTFT */
   if (!--displayMenuCount)
      DELETENULL(displayMenu);
 }
@@ -126,7 +150,11 @@ const char *cOsdMenu::hk(const char *s)
         digit = -1; // prevents automatic hotkeys - input already has them
      if (digit >= 0) {
         digit++;
+#ifdef USE_LIEMIKUUTIO
+        buffer = cString::sprintf(" %2d%s %s", digit, (digit > 9) ? "" : " ", s);
+#else
         buffer = cString::sprintf(" %c %s", (digit < 10) ? '0' + digit : ' ' , s);
+#endif /* LIEMIKUUTIO */
         s = buffer;
         }
      }
@@ -217,6 +245,9 @@ void cOsdMenu::Display(void)
   displayMenu->SetMessage(mtStatus, NULL);
   displayMenu->Clear();
   cStatus::MsgOsdClear();
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdMenuDisplay(MenuKind());
+#endif /* GRAPHTFT */
   if (menuCategory != displayMenu->MenuCategory())
      displayMenu->SetMenuCategory(menuCategory);
   displayMenuItems = displayMenu->MaxItems();
@@ -472,20 +503,77 @@ void cOsdMenu::Mark(void)
      }
 }
 
+#ifdef USE_LIEMIKUUTIO
+#define MENUKEY_TIMEOUT 1500
+#endif /* LIEMIKUUTIO */
+
 eOSState cOsdMenu::HotKey(eKeys Key)
 {
+#ifdef USE_LIEMIKUUTIO
+  bool match = false;
+  bool highlight = false;
+  int  item_nr;
+  int  i;
+
+  if (Key == kNone) {
+     if (lastActivity.TimedOut())
+        Key = kOk;
+     else
+        return osContinue;
+     }
+  else
+     lastActivity.Set(MENUKEY_TIMEOUT);
+  for (cOsdItem *item = Last(); item; item = Prev(item)) {
+#else
   for (cOsdItem *item = First(); item; item = Next(item)) {
+#endif /* LIEMIKUUTIO */
       const char *s = item->Text();
+#ifdef USE_LIEMIKUUTIO
+      i = 0;
+      item_nr = 0;
+      if (s && (s = skipspace(s)) != '\0' && '0' <= s[i] && s[i] <= '9') {
+         do {
+            item_nr = item_nr * 10 + (s[i] - '0');
+            }
+         while ( !((s[++i] == '\t')||(s[i] == ' ')) && (s[i] != '\0') && ('0' <= s[i]) && (s[i] <= '9'));
+         if ((Key == kOk) && (item_nr == key_nr)) {
+#else
       if (s && (s = skipspace(s)) != NULL) {
          if (*s == Key - k1 + '1') {
+#endif /* LIEMIKUUTIO */
             current = item->Index();
             RefreshCurrent();
             Display();
             cRemote::Put(kOk, true);
+#ifdef USE_LIEMIKUUTIO
+            key_nr = -1;
+#endif /* LIEMIKUUTIO */
             break;
             }
+#ifdef USE_LIEMIKUUTIO
+         else if (Key != kOk) {
+            if (!highlight && (item_nr == (Key - k0))) {
+               highlight = true;
+               current = item->Index();
+               }
+            if (!match && (key_nr == -1) && ((item_nr / 10) == (Key - k0))) {
+               match = true;
+               key_nr = (Key - k0);
+               }
+			else if (((key_nr == -1) && (item_nr == (Key - k0))) || (!match && (key_nr >= 0) && (item_nr == (10 * key_nr + Key - k0)))) {
+               current = item->Index();
+               cRemote::Put(kOk, true);
+               key_nr = -1;
+               break;
+               }
+            }
+#endif /* LIEMIKUUTIO */
          }
       }
+#ifdef USE_LIEMIKUUTIO
+  if ((!match) && (Key != kNone))
+     key_nr = -1;
+#endif /* LIEMIKUUTIO */
   return osContinue;
 }
 
@@ -524,8 +612,13 @@ eOSState cOsdMenu::ProcessKey(eKeys Key)
         }
      }
   switch (int(Key)) {
+#ifdef USE_LIEMIKUUTIO
+    case kNone:
+    case k0...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
+#else
     case k0:      return osUnknown;
     case k1...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
+#endif /* LIEMIKUUTIO */
     case kUp|k_Repeat:
     case kUp:   CursorUp();   break;
     case kDown|k_Repeat:
diff --git a/osdbase.h b/osdbase.h
index a2e9914..a5c2e02 100644
--- a/osdbase.h
+++ b/osdbase.h
@@ -15,6 +15,10 @@
 #include "skins.h"
 #include "tools.h"
 
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+#include "submenu.h"
+#endif /* SETUP & PINPLUGIN */
+
 enum eOSState { osUnknown,
                 osContinue,
                 osSchedule,
@@ -30,6 +34,9 @@ enum eOSState { osUnknown,
                 osStopRecord,
                 osStopReplay,
                 osCancelEdit,
+#ifdef USE_LIEMIKUUTIO
+				osCancelTransfer,
+#endif /* LIEMIKUUTIO */
                 osSwitchDvb,
                 osBack,
                 osEnd,
@@ -51,16 +58,26 @@ private:
   char *text;
   eOSState state;
   bool selectable;
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+  cSubMenuNode* subMenu;
+#endif /* SETUP & PINPLUGIN */
 protected:
   bool fresh;
 public:
   cOsdItem(eOSState State = osUnknown);
   cOsdItem(const char *Text, eOSState State = osUnknown, bool Selectable = true);
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+  cOsdItem(const char *Text, eOSState State, cSubMenuNode* SubMenu);
+#endif /* SETUP & PINPLUGIN */
   virtual ~cOsdItem();
   bool Selectable(void) const { return selectable; }
   void SetText(const char *Text, bool Copy = true);
   void SetSelectable(bool Selectable);
   void SetFresh(bool Fresh);
+#if defined (USE_SETUP) && defined (USE_PINPLUGIN)
+  void SetSubMenu(cSubMenuNode* SubMenu) { subMenu = SubMenu; }
+  cSubMenuNode* SubMenu() { return subMenu; }
+#endif /* SETUP & PINPLUGIN */
   const char *Text(void) const { return text; }
   virtual void Set(void) {}
   virtual eOSState ProcessKey(eKeys Key);
@@ -98,6 +115,10 @@ private:
   int digit;
   bool hasHotkeys;
   void DisplayHelp(bool Force = false);
+#ifdef USE_LIEMIKUUTIO
+  int key_nr;
+  cTimeMs lastActivity;
+#endif /* LIEMIKUUTIO */
 protected:
   void SetDisplayMenu(void);
   cSkinDisplayMenu *DisplayMenu(void) { return displayMenu; }
@@ -135,6 +156,9 @@ public:
   void Ins(cOsdItem *Item, bool Current = false, cOsdItem *Before = NULL);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuUnknown"; }
+#endif /* GRAPHTFT */
   };
 
 #endif //__OSDBASE_H
diff --git a/pat.c b/pat.c
index 826e0ea..c964f57 100644
--- a/pat.c
+++ b/pat.c
@@ -13,6 +13,9 @@
 #include "libsi/section.h"
 #include "libsi/descriptor.h"
 #include "thread.h"
+#ifdef USE_TTXTSUBS
+#include "vdrttxtsubshooks.h"
+#endif  // USE_TTXTSUBS
 
 #define PMT_SCAN_TIMEOUT  10 // seconds
 
@@ -343,6 +346,10 @@ void cPatFilter::Process(u_short Pid, u_char Tid, const u_char *Data, int Length
         char DLangs[MAXDPIDS][MAXLANGCODE2] = { "" };
         char SLangs[MAXSPIDS][MAXLANGCODE2] = { "" };
         int Tpid = 0;
+#ifdef USE_TTXTSUBS
+        tTeletextSubtitlePage TeletextSubtitlePages[MAXTXTPAGES];
+        int NumTPages = 0;
+#endif // USE_TTXTSUBS
         int NumApids = 0;
         int NumDpids = 0;
         int NumSpids = 0;
@@ -436,6 +443,22 @@ void cPatFilter::Process(u_short Pid, u_char Tid, const u_char *Data, int Length
                                  break;
                             case SI::TeletextDescriptorTag:
                                  Tpid = esPid;
+#ifdef USE_TTXTSUBS
+                                 {
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                     bool isSubtitlePage = (ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05);
+                                     if ((NumTPages < MAXTXTPAGES) && ttxt.languageCode[0] && isSubtitlePage) {
+                                        strn0cpy(TeletextSubtitlePages[NumTPages].ttxtLanguage, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                        TeletextSubtitlePages[NumTPages].ttxtPage = ttxt.getTeletextPageNumber();
+                                        TeletextSubtitlePages[NumTPages].ttxtMagazine = ttxt.getTeletextMagazineNumber();
+                                        TeletextSubtitlePages[NumTPages].ttxtType = ttxt.getTeletextType();
+                                        NumTPages++;
+                                        }
+                                     }
+                                 }
+#endif // USE_TTXTSUBS
                                  break;
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
@@ -547,6 +570,14 @@ void cPatFilter::Process(u_short Pid, u_char Tid, const u_char *Data, int Length
             }
         if (Setup.UpdateChannels >= 2) {
            Channel->SetPids(Vpid, Ppid, Vtype, Apids, Atypes, ALangs, Dpids, Dtypes, DLangs, Spids, SLangs, Tpid);
+#ifdef USE_TTXTSUBS
+           if (NumTPages < MAXTXTPAGES) {
+              int manualPageNumber = cVDRTtxtsubsHookListener::Hook()->ManualPageNumber(Channel);
+              if (manualPageNumber)
+                 TeletextSubtitlePages[NumTPages++] = tTeletextSubtitlePage(manualPageNumber);
+              }
+           Channel->SetTeletextSubtitlePages(TeletextSubtitlePages, NumTPages);
+#endif // USE_TTXTSUBS
            Channel->SetCaIds(CaDescriptors->CaIds());
            Channel->SetSubtitlingDescriptors(SubtitlingTypes, CompositionPageIds, AncillaryPageIds);
            }
diff --git a/plugin.c b/plugin.c
index 52256ee..b0249dd 100644
--- a/plugin.c
+++ b/plugin.c
@@ -312,6 +312,14 @@ void cPluginManager::AddPlugin(const char *Args)
   char *p = strchr(s, ' ');
   if (p)
      *p = 0;
+#ifdef USE_PLUGINMISSING
+  struct stat st;
+  if (stat (cString::sprintf("%s/%s%s%s%s", directory, LIBVDR_PREFIX, s, SO_INDICATOR, APIVERSION), &st) && errno == ENOENT) {
+     esyslog("WARN: missing plugin '%s'", s);
+     fprintf(stderr, "vdr: missing plugin '%s'\n", s);
+     }
+  else
+#endif /* PLUGINMISSING */
   dlls.Add(new cDll(cString::sprintf("%s/%s%s%s%s", directory, LIBVDR_PREFIX, s, SO_INDICATOR, APIVERSION), Args));
   free(s);
 }
@@ -320,7 +328,11 @@ bool cPluginManager::LoadPlugins(bool Log)
 {
   for (cDll *dll = dlls.First(); dll; dll = dlls.Next(dll)) {
       if (!dll->Load(Log))
+#ifdef USE_PLUGINMISSING
+         ;
+#else
          return false;
+#endif /* PLUGINMISSING */
       }
   return true;
 }
diff --git a/plugin.h b/plugin.h
index 684b822..cdc8b2f 100644
--- a/plugin.h
+++ b/plugin.h
@@ -45,6 +45,9 @@ public:
 
   virtual const char *MainMenuEntry(void);
   virtual cOsdObject *MainMenuAction(void);
+#ifdef USE_MCLI
+  virtual cOsdObject *AltMenuAction(void) { return NULL; };
+#endif /* MCLI */
 
   virtual cMenuSetupPage *SetupMenu(void);
   virtual bool SetupParse(const char *Name, const char *Value);
diff --git a/po/ar.po b/po/ar.po
index ddfc50a..654c65b 100644
--- a/po/ar.po
+++ b/po/ar.po
@@ -568,6 +568,9 @@ msgstr "الكامة"
 msgid "Sid"
 msgstr ""
 
+msgid "Rid"
+msgstr ""
+
 msgid "Channel settings are not unique!"
 msgstr "اعدادات القناة غبر موحد"
 
@@ -647,6 +650,15 @@ msgstr "الاستقطاب"
 msgid "Lifetime"
 msgstr "معدل البقاء"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "نعم"
+
+msgid "no"
+msgstr "ﻻ"
+
 msgid "File"
 msgstr "ملف"
 
@@ -741,6 +753,33 @@ msgstr "عرض"
 msgid "Button$Rewind"
 msgstr "اعادة"
 
+msgid "Date"
+msgstr "التاريخ"
+
+msgid "Length"
+msgstr "الطول"
+
+msgid "Format"
+msgstr ""
+
+msgid "PES"
+msgstr ""
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr "الحجم"
+
+msgid "Delete marks information?"
+msgstr "حذف معلومات العلامة"
+
+msgid "Delete resume information?"
+msgstr "حذف معلومات المواصلة"
+
+msgid "Error while accessing recording!"
+msgstr "حدث خطاء عند محاولة الوصول لتسجيلات"
+
 msgid "Recordings"
 msgstr "التسجيلات"
 
@@ -750,9 +789,6 @@ msgstr "افتح"
 msgid "Commands"
 msgstr "الاوامر"
 
-msgid "Error while accessing recording!"
-msgstr "حدث خطاء عند محاولة الوصول لتسجيلات"
-
 msgid "Delete recording?"
 msgstr "حذف التسجيل"
 
@@ -787,6 +823,10 @@ msgid "Setup.OSD$Theme"
 msgstr " الثيمة"
 
 #, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "الخط صغير"
+
+#, fuzzy
 msgid "Setup.OSD$Left (%)"
 msgstr "يسار"
 
@@ -899,6 +939,18 @@ msgstr "اللغة المفضلة"
 msgid "Setup.EPG$Preferred language"
 msgstr "اللغة المقضلة"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "بحث خفيف"
 
@@ -908,9 +960,6 @@ msgstr "صندوق الحروف"
 msgid "center cut out"
 msgstr "قص من الوسط"
 
-msgid "no"
-msgstr "ﻻ"
-
 msgid "names only"
 msgstr "الاسماء فقط"
 
@@ -953,6 +1002,10 @@ msgstr "دولبى رقمى"
 msgid "Setup.DVB$Update channels"
 msgstr "تحديث القنوات"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr " موضع معلومات القناة"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "لغات الصوت"
 
@@ -977,6 +1030,9 @@ msgstr "درجة شفافية الترجمة"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "شفافية الخلفية"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "الاقط"
 
@@ -1044,9 +1100,6 @@ msgstr "تجميد العرض الحى"
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "نعم"
-
 msgid "Recording"
 msgstr "تسجيل"
 
@@ -1072,6 +1125,22 @@ msgstr "تعطيل الاولويات"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "معدل الايقاف باليوم"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "مجلد التسجيلات"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "مجلد التسجيلات"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "تعطيل الاولويات"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "اقصى حجم لملف الفيديو ب م ب"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "استخدم اسم المرحلة"
 
@@ -1093,6 +1162,12 @@ msgstr "مدة التسجيل الفورى بالدقيقة"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "اقصى حجم لملف الفيديو ب م ب"
 
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "اقصى حجم للتسجيل م ب"
+
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "قاطع وصلات الاختصرات"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "اقسم الملف المعدل"
 
@@ -1100,6 +1175,9 @@ msgstr "اقسم الملف المعدل"
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "اسم التسجيل الفورى"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "اعادة عرض"
 
@@ -1115,6 +1193,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "رقم المواصلة"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "رقم المواصلة"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "رقم المواصلة"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "موءقت النوم"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "رقم المواصلة"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "رقم المواصلة"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "رقم المواصلة"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "القناة الاساسية"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "خروج طارىء"
+
 msgid "Miscellaneous"
 msgstr "متفرقات"
 
@@ -1143,6 +1253,18 @@ msgid "Setup.Miscellaneous$Initial volume"
 msgstr "فعل الصوت"
 
 #, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "خروج طارىء"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "كسابق"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "كسابق"
+
+#, fuzzy
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "كسابق"
 
@@ -1152,6 +1274,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "خروج طارىء"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "خروج طارىء"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "كسابق"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "مدة انتهاء الحدث بالدقيقة"
+
 msgid "Plugins"
 msgstr "الملحقات"
 
@@ -1187,7 +1321,6 @@ msgstr "ايقاف"
 msgid "Button$Resume"
 msgstr "مواصلة"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " تعديل القناة"
 
diff --git a/po/ca_ES.po b/po/ca_ES.po
index ce13921..20e89a1 100644
--- a/po/ca_ES.po
+++ b/po/ca_ES.po
@@ -563,6 +563,10 @@ msgstr "Acc
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Propietats del canal duplicades!"
 
@@ -639,6 +643,15 @@ msgstr "Prioritat"
 msgid "Lifetime"
 msgstr "Durada"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "s"
+
+msgid "no"
+msgstr "no"
+
 msgid "File"
 msgstr "Arxiu"
 
@@ -732,6 +745,36 @@ msgstr "Reproduir"
 msgid "Button$Rewind"
 msgstr "Enrera"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Esborrar gravaci?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Esborrar gravaci?"
+
+msgid "Error while accessing recording!"
+msgstr "Error a l'accedir a la gravaci!"
+
 msgid "Recordings"
 msgstr "Veure programes gravats"
 
@@ -741,9 +784,6 @@ msgstr "Obrir"
 msgid "Commands"
 msgstr "Ordres"
 
-msgid "Error while accessing recording!"
-msgstr "Error a l'accedir a la gravaci!"
-
 msgid "Delete recording?"
 msgstr "Esborrar gravaci?"
 
@@ -777,6 +817,10 @@ msgstr "Aparen
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Font petita"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Esquerra (%)"
 
@@ -881,6 +925,18 @@ msgstr "Idiomes preferits"
 msgid "Setup.EPG$Preferred language"
 msgstr "Idioma preferit"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -890,9 +946,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "no"
-
 msgid "names only"
 msgstr "noms noms"
 
@@ -935,6 +988,10 @@ msgstr "Fer servir Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Actualitza canals"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Posici de la informaci del canal"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Idiomes d'udio"
 
@@ -959,6 +1016,9 @@ msgstr "Transpar
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparncia fons subttols"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "Configuraci de l'LNB"
 
@@ -1023,9 +1083,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "s"
-
 msgid "Recording"
 msgstr "Opcions de Gravaci"
 
@@ -1050,6 +1107,22 @@ msgstr "Prioritat de la pausa"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Durada de la pausa (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Gravacions en subcarpetes"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Gravacions en subcarpetes"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioritat de la pausa"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Mida mxima de l'arxiu (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Utilitzar el nom de l'episodi"
 
@@ -1071,12 +1144,23 @@ msgstr "Temps de gravaci
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Mida mxima de l'arxiu (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Mida mxima de l'arxiu (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Marcar gravaci instantnia"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Separar arxius"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Opcions de Reproducci"
 
@@ -1092,6 +1176,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID de Continuar"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID de Continuar"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID de Continuar"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Mode de multivelocitat"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID de Continuar"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID de Continuar"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID de Continuar"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Canal inicial"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Sortida d'emergncia"
+
 msgid "Miscellaneous"
 msgstr "Miscellnia"
 
@@ -1119,6 +1235,18 @@ msgstr "anterior"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Volum inicial"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Sortida d'emergncia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Temps d'introducci canal (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "anterior"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1128,6 +1256,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Sortida d'emergncia"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Sortida d'emergncia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "anterior"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Temps mnim en pausa (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1163,7 +1303,6 @@ msgstr "Aturar"
 msgid "Button$Resume"
 msgstr "Continuar"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Cancellar l'edici "
 
diff --git a/po/cs_CZ.po b/po/cs_CZ.po
index 9619361..9bd4b79 100644
--- a/po/cs_CZ.po
+++ b/po/cs_CZ.po
@@ -562,6 +562,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Nastavení kanálu není jedinečné!"
 
@@ -638,6 +642,15 @@ msgstr "Priorita"
 msgid "Lifetime"
 msgstr "Životnost"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "ano"
+
+msgid "no"
+msgstr "ne"
+
 msgid "File"
 msgstr "Soubor"
 
@@ -731,6 +744,36 @@ msgstr "Přehrát"
 msgid "Button$Rewind"
 msgstr "Na začátek"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Smazat nahrávku?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Smazat nahrávku?"
+
+msgid "Error while accessing recording!"
+msgstr "Chyba při přístupu k nahrávkám!"
+
 msgid "Recordings"
 msgstr "Nahrávky"
 
@@ -740,9 +783,6 @@ msgstr "Otevřít"
 msgid "Commands"
 msgstr "Příkazy"
 
-msgid "Error while accessing recording!"
-msgstr "Chyba při přístupu k nahrávkám!"
-
 msgid "Delete recording?"
 msgstr "Smazat nahrávku?"
 
@@ -776,6 +816,10 @@ msgstr "Vzhled"
 msgid "Setup.OSD$Theme"
 msgstr "Téma"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Malé písmo"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Vlevo (%)"
 
@@ -880,6 +924,18 @@ msgstr "Preferované jazyky"
 msgid "Setup.EPG$Preferred language"
 msgstr "Preferovaný jazyk"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -889,9 +945,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "dostředu oříznout"
 
-msgid "no"
-msgstr "ne"
-
 msgid "names only"
 msgstr "jen názvy"
 
@@ -934,6 +987,10 @@ msgstr "Používat zvuk v Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Aktualizace kanálů"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Pozice informace o kanálu"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Jazyky zvuku"
 
@@ -958,6 +1015,9 @@ msgstr "Průhlednost písma titulků"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Průhlednost pozadí titulků"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1022,9 +1082,6 @@ msgstr "přerušit běžící program"
 msgid "confirm"
 msgstr "potvrdit"
 
-msgid "yes"
-msgstr "ano"
-
 msgid "Recording"
 msgstr "Nahrávání"
 
@@ -1049,6 +1106,22 @@ msgstr "Priorita přerušení"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Životnost přerušení (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Seznam nahrávek"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Seznam nahrávek"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Priorita přerušení"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maximální velikost nahrávky (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Používat název epizody"
 
@@ -1070,12 +1143,23 @@ msgstr "Délka okamžitého nahrávání (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maximální velikost nahrávky (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maximální velikost nahrávky (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Označit okamžité nahrávky"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Dělit editované soubory"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Mazat nahrávky Timeshift"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Přehrávání"
 
@@ -1091,6 +1175,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID obnovení"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID obnovení"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID obnovení"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Vícerychlostní mód"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID obnovení"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID obnovení"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID obnovení"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanál po spuštění"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Nouzové ukončení"
+
 msgid "Miscellaneous"
 msgstr "Různé"
 
@@ -1118,6 +1234,18 @@ msgstr "jako naposledy"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Hlasitost po spuštění"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Nouzové ukončení"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Prodleva při volbě kanálu (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "jako naposledy"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1127,6 +1255,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Nouzové ukončení"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Nouzové ukončení"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "jako naposledy"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Min. pauza mezi událostmi (min)"
+
 msgid "Plugins"
 msgstr "Moduly"
 
@@ -1162,7 +1302,6 @@ msgstr "Ukončit"
 msgid "Button$Resume"
 msgstr "Pokračovat"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Zrušit editaci"
 
diff --git a/po/da_DK.po b/po/da_DK.po
index 5a463b9..3766c53 100644
--- a/po/da_DK.po
+++ b/po/da_DK.po
@@ -560,6 +560,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanalindstillinger er ikke entydige!"
 
@@ -636,6 +640,15 @@ msgstr "Prioritet"
 msgid "Lifetime"
 msgstr "Levetid"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "ja"
+
+msgid "no"
+msgstr "nej"
+
 msgid "File"
 msgstr "Fil"
 
@@ -729,6 +742,36 @@ msgstr "Afspil"
 msgid "Button$Rewind"
 msgstr "Forfra"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Slet optagelse?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Slet optagelse?"
+
+msgid "Error while accessing recording!"
+msgstr "Fejl ved lsning af optagelse!"
+
 msgid "Recordings"
 msgstr "Optagelser"
 
@@ -738,9 +781,6 @@ msgstr "
 msgid "Commands"
 msgstr "Kommandoer"
 
-msgid "Error while accessing recording!"
-msgstr "Fejl ved lsning af optagelse!"
-
 msgid "Delete recording?"
 msgstr "Slet optagelse?"
 
@@ -774,6 +814,10 @@ msgstr "Skin"
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Lille skrift"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Venstre (%)"
 
@@ -878,6 +922,18 @@ msgstr "Foretrukne sprog"
 msgid "Setup.EPG$Preferred language"
 msgstr "Foretrukket sprog"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -887,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "nej"
-
 msgid "names only"
 msgstr "kun navne"
 
@@ -932,6 +985,10 @@ msgstr "Anvend Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Opdatr kanaler"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Placering af kanalinfo"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio sprog (ant.)"
 
@@ -956,6 +1013,9 @@ msgstr "Undertekst forgrundsgennemsigtighed"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Undertekst baggrundsgennemsigtighed"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1020,9 +1080,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "ja"
-
 msgid "Recording"
 msgstr "Optagelse"
 
@@ -1047,6 +1104,22 @@ msgstr "Pause prioritet"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Pause levetid (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Optagelser i foldere"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Optagelser i foldere"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Pause prioritet"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Max. video filstrrelse (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Anvend udsendelsesnavn"
 
@@ -1068,12 +1141,23 @@ msgstr "L
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Max. video filstrrelse (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Max. video filstrrelse (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Markr direkte optagelse"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Opdel redigerede filer"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Afspilning"
 
@@ -1089,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Genoptagelses ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Genoptagelses ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Genoptagelses ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Multi hastighedsmodus"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Genoptagelses ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Genoptagelses ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Genoptagelses ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanal ved opstart"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Ndudgang"
+
 msgid "Miscellaneous"
 msgstr "Diverse"
 
@@ -1116,6 +1232,18 @@ msgstr "som f
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Lydstyrke ved opstart"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Ndudgang"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Kanal adgang timeout (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "som fr"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1125,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Ndudgang"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Ndudgang"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "som fr"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Mindste hndelsespause (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1160,7 +1300,6 @@ msgstr "Stop"
 msgid "Button$Resume"
 msgstr "Fortst"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Afbryd redigering"
 
diff --git a/po/de_DE.po b/po/de_DE.po
index 20a5476..7045548 100644
--- a/po/de_DE.po
+++ b/po/de_DE.po
@@ -560,6 +560,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanaleinstellungen sind nicht eindeutig!"
 
@@ -636,6 +640,15 @@ msgstr "Priorit
 msgid "Lifetime"
 msgstr "Lebensdauer"
 
+msgid "Childlock"
+msgstr "Kindersicherung"
+
+msgid "yes"
+msgstr "ja"
+
+msgid "no"
+msgstr "nein"
+
 msgid "File"
 msgstr "Datei"
 
@@ -729,6 +742,33 @@ msgstr "Wiedergabe"
 msgid "Button$Rewind"
 msgstr "Anfang"
 
+msgid "Date"
+msgstr "Datum"
+
+msgid "Length"
+msgstr "Lnge"
+
+msgid "Format"
+msgstr "Format"
+
+msgid "PES"
+msgstr "PES"
+
+msgid "TS"
+msgstr "TS"
+
+msgid "Size"
+msgstr "Gre"
+
+msgid "Delete marks information?"
+msgstr "Schnittmarken lschen?"
+
+msgid "Delete resume information?"
+msgstr "Gespeicherten Zeitpunkt der letzten Wiedergabe lschen?"
+
+msgid "Error while accessing recording!"
+msgstr "Fehler beim Ansprechen der Aufzeichnung!"
+
 msgid "Recordings"
 msgstr "Aufzeichnungen"
 
@@ -738,9 +778,6 @@ msgstr "
 msgid "Commands"
 msgstr "Befehle"
 
-msgid "Error while accessing recording!"
-msgstr "Fehler beim Ansprechen der Aufzeichnung!"
-
 msgid "Delete recording?"
 msgstr "Aufzeichnung lschen?"
 
@@ -774,6 +811,10 @@ msgstr "Oberfl
 msgid "Setup.OSD$Theme"
 msgstr "Thema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Kleine Schriftart"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Links (%)"
 
@@ -878,6 +919,18 @@ msgstr "Bevorzugte Sprachen"
 msgid "Setup.EPG$Preferred language"
 msgstr "Bevorzugte Sprache"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr "Zeitspanne fr dop. EPG-Suche(min)"
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr "Doppelten externen EPG-Eintrag"
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr "Internen und externen EPG mischen"
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr "Erk. des lauf. VPS-Events abschalten"
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -887,9 +940,6 @@ msgstr "Letterbox"
 msgid "center cut out"
 msgstr "Center-cut-out"
 
-msgid "no"
-msgstr "nein"
-
 msgid "names only"
 msgstr "nur Namen"
 
@@ -932,6 +982,9 @@ msgstr "Dolby-Digital-Ton benutzen"
 msgid "Setup.DVB$Update channels"
 msgstr "Kanle aktualisieren"
 
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Kanal per Rid zuordnen"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio-Sprachen"
 
@@ -956,6 +1009,9 @@ msgstr "Untertitel-Transparenz Vordergrund"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Untertitel-Transparenz Hintergrund"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr "Videotext-Untersttzung aktivieren"
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1020,9 +1076,6 @@ msgstr "Live-Signal anhalten"
 msgid "confirm"
 msgstr "besttigen"
 
-msgid "yes"
-msgstr "ja"
-
 msgid "Recording"
 msgstr "Aufnahme"
 
@@ -1047,6 +1100,21 @@ msgstr "Pause-Priorit
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Pause-Lebensdauer (d)"
 
+# DVLVIDPREFER
+msgid "Setup.Recording$Video directory policy"
+msgstr "Videoverzeichnispolitik"
+
+msgid "Setup.Recording$Number of video directories"
+msgstr "Anzahl der Videoverzeichnisse"
+
+#, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Video %d Prioritt"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Video %d min. MB frei"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Episodenname verwenden"
 
@@ -1068,12 +1136,25 @@ msgstr "Dauer der Direktaufzeichnung (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Max. Videodateigre (MB)"
 
+# HARDLINKCUTTER
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Max. Videodateigre (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Direktaufzeichnung markieren"
+# HARDLINKCUTTER END
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Editierte Dateien aufteilen"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Zeitversetzte Aufnahme lschen"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Wiedergabe"
 
@@ -1089,6 +1170,35 @@ msgstr "Verbleibende Zeit anzeigen"
 msgid "Setup.Replay$Resume ID"
 msgstr "Wiedergabe-ID"
 
+msgid "Setup.Replay$Jump&Play"
+msgstr "Wiedergabe nach Sprung"
+
+msgid "Setup.Replay$Play&Jump"
+msgstr "Sprung bei Schnittmarke"
+
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Pause bei letzter Marke"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Sprungweite in Sekunden"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Sprungweite in Sekunden"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Sprungweite in Sek. (wiederh.)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanal beim Einschalten"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Notausstieg"
+
 msgid "Miscellaneous"
 msgstr "Sonstiges"
 
@@ -1116,6 +1226,18 @@ msgstr "wie vorher"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Lautstrke beim Einschalten"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Notausstieg"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Rundum zappen"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "wie vorher"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Rundum zappen"
 
@@ -1125,6 +1247,18 @@ msgstr "Kanalnamen mit Quelle anzeigen"
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Notausstieg"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Notausstieg"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "wie vorher"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Brckenzeit zwischen Timern (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1160,7 +1294,6 @@ msgstr "Beenden"
 msgid "Button$Resume"
 msgstr "Weiter"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Schneiden abbrechen"
 
@@ -1362,3 +1495,48 @@ msgstr "Disk"
 
 msgid "free"
 msgstr "frei"
+
+#. USE_LIEMIKUUTIO
+msgid "Edit recording"
+msgstr "Aufnahme bearbeiten"
+
+msgid "Button$Cut"
+msgstr "Schneiden"
+
+msgid "Button$Copy"
+msgstr "Kopieren"
+
+msgid "Button$Rename/Move"
+msgstr "Umbenennen/Bewegen"
+
+msgid "File transfer started"
+msgstr "Dateibertragung gestartet"
+
+msgid "Can't start file transfer!"
+msgstr "Dateibertragung kann nicht gestartet werden!"
+
+msgid "File transfer already active!"
+msgstr "Dateibertragung bereits aktiv!"
+
+#. TRANSLATORS: note the leading blank!
+msgid " Cancel file transfer"
+msgstr " Dateibertragung beenden"
+
+msgid "Cancel file transfer?"
+msgstr "Dateibertragung beenden?"
+
+msgid "Transfering file - shut down anyway?"
+msgstr "bertrage Datei - trotzdem ausschalten?"
+
+msgid "Transfering file - restart anyway?"
+msgstr "bertrage Datei - trotzdem neustarten?"
+
+msgid "File transfer failed!"
+msgstr "Dateibertragung fehlgeschlagen!"
+
+msgid "File transfer finished"
+msgstr "Dateibertragung fertiggestellt"
+
+msgid "File already exists - overwrite?"
+msgstr "Datei besteht bereits - berschreiben?"
+#. LIEMIKUUTIO
diff --git a/po/el_GR.po b/po/el_GR.po
index d27af7e..bb7f350 100644
--- a/po/el_GR.po
+++ b/po/el_GR.po
@@ -560,6 +560,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "    !"
 
@@ -636,6 +640,15 @@ msgstr "
 msgid "Lifetime"
 msgstr " "
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr ""
+
+msgid "no"
+msgstr ""
+
 msgid "File"
 msgstr ""
 
@@ -729,6 +742,36 @@ msgstr "
 msgid "Button$Rewind"
 msgstr "  "
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr " ?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr " ?"
+
+msgid "Error while accessing recording!"
+msgstr "   !"
+
 msgid "Recordings"
 msgstr ""
 
@@ -738,9 +781,6 @@ msgstr "
 msgid "Commands"
 msgstr ""
 
-msgid "Error while accessing recording!"
-msgstr "   !"
-
 msgid "Delete recording?"
 msgstr " ?"
 
@@ -774,6 +814,10 @@ msgstr "
 msgid "Setup.OSD$Theme"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr ""
+
 msgid "Setup.OSD$Left (%)"
 msgstr " (%)"
 
@@ -878,6 +922,18 @@ msgstr "
 msgid "Setup.EPG$Preferred language"
 msgstr " "
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -887,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr ""
-
 msgid "names only"
 msgstr " "
 
@@ -932,6 +985,10 @@ msgstr "
 msgid "Setup.DVB$Update channels"
 msgstr " "
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "  "
+
 msgid "Setup.DVB$Audio languages"
 msgstr " "
 
@@ -956,6 +1013,9 @@ msgstr ""
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr ""
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1020,9 +1080,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr ""
-
 msgid "Recording"
 msgstr ""
 
@@ -1047,6 +1104,22 @@ msgstr "
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr " "
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr " "
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr " "
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr " "
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "   (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "  "
 
@@ -1068,12 +1141,23 @@ msgstr "
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "   (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "   (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "  "
+
 msgid "Setup.Recording$Split edited files"
 msgstr "  "
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr ""
 
@@ -1089,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID "
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "  "
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "   ()"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "   ()"
+
 msgid "Miscellaneous"
 msgstr ""
 
@@ -1116,6 +1232,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "   ()"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "  ()"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "   ()"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1125,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "   ()"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "  ()"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "   ()"
+
 msgid "Plugins"
 msgstr ""
 
@@ -1160,7 +1300,6 @@ msgstr "
 msgid "Button$Resume"
 msgstr ""
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr "  "
 
diff --git a/po/es_ES.po b/po/es_ES.po
index f38ce2f..1aa210e 100644
--- a/po/es_ES.po
+++ b/po/es_ES.po
@@ -561,6 +561,10 @@ msgstr "Acceso condicional (CA)"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "!Propiedades de canal duplicadas!"
 
@@ -637,6 +641,15 @@ msgstr "Prioridad"
 msgid "Lifetime"
 msgstr "Duracin"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "s"
+
+msgid "no"
+msgstr "no"
+
 msgid "File"
 msgstr "Fichero"
 
@@ -730,6 +743,36 @@ msgstr "Reproducir"
 msgid "Button$Rewind"
 msgstr "Rebobinar"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Eliminar grabacion?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Eliminar grabacion?"
+
+msgid "Error while accessing recording!"
+msgstr "Error al acceder a la grabacin!"
+
 msgid "Recordings"
 msgstr "Grabaciones"
 
@@ -739,9 +782,6 @@ msgstr "Abrir"
 msgid "Commands"
 msgstr "rdenes"
 
-msgid "Error while accessing recording!"
-msgstr "Error al acceder a la grabacin!"
-
 msgid "Delete recording?"
 msgstr "Eliminar grabacion?"
 
@@ -775,6 +815,10 @@ msgstr "Skin"
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Fuente pequea"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Izquierda (%)"
 
@@ -879,6 +923,18 @@ msgstr "Idiomas preferidos"
 msgid "Setup.EPG$Preferred language"
 msgstr "Idioma preferido"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -888,9 +944,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "no"
-
 msgid "names only"
 msgstr "slo nombres"
 
@@ -933,6 +986,10 @@ msgstr "Usar Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Actualizar canales"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Posicin para informacin de canal"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Idiomas de audio"
 
@@ -957,6 +1014,9 @@ msgstr "Transparencia primer plano subt
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparencia fondo subttulos"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1021,9 +1081,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "s"
-
 msgid "Recording"
 msgstr "Opciones de grabacin"
 
@@ -1048,6 +1105,22 @@ msgstr "Prioridad en modo pausa"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Duracin en modo pausa (das)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Mostrar directorios de grabaciones"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Mostrar directorios de grabaciones"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioridad en modo pausa"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Tamao mximo de fichero (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Utilizar nombre de episodo"
 
@@ -1069,12 +1142,23 @@ msgstr "Tiempo de grabaci
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Tamao mximo de fichero (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Tamao mximo de fichero (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Marcar grabaciones inmediatas"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Partir ficheros editados"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Opciones de reproduccin"
 
@@ -1090,6 +1174,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID de continuacin"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID de continuacin"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID de continuacin"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Modo multi-velocidad"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID de continuacin"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID de continuacin"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID de continuacin"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Canal inicial"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Salida de emergencia"
+
 msgid "Miscellaneous"
 msgstr "Varios"
 
@@ -1117,6 +1233,18 @@ msgstr "anterior"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Volumen inicial"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Salida de emergencia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Tiempo introduccin canal (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "anterior"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1126,6 +1254,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Salida de emergencia"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Salida de emergencia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "anterior"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Tiempo mn. antes de un evento (m)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1161,7 +1301,6 @@ msgstr "Parar"
 msgid "Button$Resume"
 msgstr "Continuar"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Anular edicin"
 
diff --git a/po/et_EE.po b/po/et_EE.po
index b136d37..76aa718 100644
--- a/po/et_EE.po
+++ b/po/et_EE.po
@@ -560,6 +560,9 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+msgid "Rid"
+msgstr ""
+
 msgid "Channel settings are not unique!"
 msgstr "Kanaliseaded ei ole unikaalsed!"
 
@@ -636,6 +639,15 @@ msgstr "Prioriteet"
 msgid "Lifetime"
 msgstr "Eluiga"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "jah"
+
+msgid "no"
+msgstr "ei"
+
 msgid "File"
 msgstr "Fail"
 
@@ -729,6 +741,33 @@ msgstr "Start"
 msgid "Button$Rewind"
 msgstr "Algusesse"
 
+msgid "Date"
+msgstr "Kuupäev"
+
+msgid "Length"
+msgstr "Kestus"
+
+msgid "Format"
+msgstr "Formaat"
+
+msgid "PES"
+msgstr "PES"
+
+msgid "TS"
+msgstr "TS"
+
+msgid "Size"
+msgstr "Suurus"
+
+msgid "Delete marks information?"
+msgstr "Kustutada märkide info?"
+
+msgid "Delete resume information?"
+msgstr "Kustutada jätkamise info?"
+
+msgid "Error while accessing recording!"
+msgstr "Salvestuse taasesitus nurjus!"
+
 msgid "Recordings"
 msgstr "Salvestused"
 
@@ -738,9 +777,6 @@ msgstr "Avada"
 msgid "Commands"
 msgstr "Käsud"
 
-msgid "Error while accessing recording!"
-msgstr "Salvestuse taasesitus nurjus!"
-
 msgid "Delete recording?"
 msgstr "Kustutada salvestus?"
 
@@ -774,6 +810,10 @@ msgstr "Kest"
 msgid "Setup.OSD$Theme"
 msgstr "Teema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Väike font"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Nihe paremale (%)"
 
@@ -878,6 +918,18 @@ msgstr "Eelistatuid keeli"
 msgid "Setup.EPG$Preferred language"
 msgstr "Eelistatud keel"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -887,9 +939,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "ei"
-
 msgid "names only"
 msgstr "nimed"
 
@@ -932,6 +981,10 @@ msgstr "Dolby Digital kasutamine"
 msgid "Setup.DVB$Update channels"
 msgstr "Kanalite uuendamine"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Kanaliinfo asukoht"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio keeli"
 
@@ -956,6 +1009,9 @@ msgstr "Subtiitri läbipaistvus"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Subtiitri tausta läbipaistvus"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr "Teleteksti tugi"
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1020,9 +1076,6 @@ msgstr "peatada"
 msgid "confirm"
 msgstr "kinnitada"
 
-msgid "yes"
-msgstr "jah"
-
 msgid "Recording"
 msgstr "Salvestamine"
 
@@ -1047,6 +1100,22 @@ msgstr "Pausi prioriteet"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Pausi eluiga (päevi)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Kausta nime salvestamine"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Kausta nime salvestamine"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Pausi prioriteet"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maks. failisuurus (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Episoodinime kasutamine"
 
@@ -1068,12 +1137,23 @@ msgstr "Kiirsalvestuse kestus (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maks. failisuurus (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maks. failisuurus (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Kiirsalvestuse märgistamine"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Failide jupitamine"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Kustutada ajanihke salvestus"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Taasesitus"
 
@@ -1089,6 +1169,38 @@ msgstr "Järelejäänud aja kuvamine"
 msgid "Setup.Replay$Resume ID"
 msgstr "Jätkamise ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Jätkamise ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Jätkamise ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Mitmekiiruse moodus"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Jätkamise ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Jätkamise ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Jätkamise ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanal käivitamisel"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Hädaväljumine"
+
 msgid "Miscellaneous"
 msgstr "Muud sätted"
 
@@ -1116,6 +1228,18 @@ msgstr "endine"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Helitugevus käivitamisel"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Hädaväljumine"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Kanalite ringkerimine"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "endine"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Kanalite ringkerimine"
 
@@ -1125,6 +1249,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Hädaväljumine"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Hädaväljumine"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "endine"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Min. saate taimaut (min)"
+
 msgid "Plugins"
 msgstr "Laiendusmoodulid"
 
@@ -1160,7 +1296,6 @@ msgstr "Stopp"
 msgid "Button$Resume"
 msgstr "Jätkata"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Katkestada redigeerimine"
 
diff --git a/po/fi_FI.po b/po/fi_FI.po
index aa76eef..03aa5e3 100644
--- a/po/fi_FI.po
+++ b/po/fi_FI.po
@@ -563,6 +563,10 @@ msgstr "Salaus (CA)"
 msgid "Sid"
 msgstr "Palvelu-ID"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Palvelu-ID"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanava-asetukset eivät ole yksilölliset!"
 
@@ -639,6 +643,15 @@ msgstr "Prioriteetti"
 msgid "Lifetime"
 msgstr "Elinikä"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "kyllä"
+
+msgid "no"
+msgstr "ei"
+
 msgid "File"
 msgstr "Tiedosto"
 
@@ -732,6 +745,33 @@ msgstr "Toista"
 msgid "Button$Rewind"
 msgstr "Alkuun"
 
+msgid "Date"
+msgstr "Päiväys"
+
+msgid "Length"
+msgstr "Pituus"
+
+msgid "Format"
+msgstr "Tiedostomuoto"
+
+msgid "PES"
+msgstr "PES"
+
+msgid "TS"
+msgstr "TS"
+
+msgid "Size"
+msgstr "Koko"
+
+msgid "Delete marks information?"
+msgstr "Poista tallenteen merkinnät?"
+
+msgid "Delete resume information?"
+msgstr "Poista tallenteen paluutiedot?"
+
+msgid "Error while accessing recording!"
+msgstr "Tallenteen toistaminen epäonnistui!"
+
 msgid "Recordings"
 msgstr "Tallenteet"
 
@@ -741,9 +781,6 @@ msgstr "Avaa"
 msgid "Commands"
 msgstr "Komennot"
 
-msgid "Error while accessing recording!"
-msgstr "Tallenteen toistaminen epäonnistui!"
-
 msgid "Delete recording?"
 msgstr "Poistetaanko tallenne?"
 
@@ -777,6 +814,10 @@ msgstr "Ulkoasu"
 msgid "Setup.OSD$Theme"
 msgstr "Teema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Pieni kirjasintyyppi"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Vaakakeskitys (%)"
 
@@ -881,6 +922,18 @@ msgstr "Suosikkikielet"
 msgid "Setup.EPG$Preferred language"
 msgstr "Suosikkikieli"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -890,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "ei"
-
 msgid "names only"
 msgstr "vain nimet"
 
@@ -935,6 +985,10 @@ msgstr "Käytä Dolby Digital -ääntä"
 msgid "Setup.DVB$Update channels"
 msgstr "Päivitä kanavat"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Kanavatiedon sijainti"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Äänen kielet"
 
@@ -959,6 +1013,9 @@ msgstr "Tekstityksen läpinäkyvyys"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Tekstityksen taustan läpinäkyvyys"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr "Salli teksti-TV-tuki"
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1023,9 +1080,6 @@ msgstr "pysäytä lähetys"
 msgid "confirm"
 msgstr "varmista"
 
-msgid "yes"
-msgstr "kyllä"
-
 msgid "Recording"
 msgstr "Tallennus"
 
@@ -1050,6 +1104,22 @@ msgstr "Taukotallenteen prioriteetti"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Taukotallenteen elinikä (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Näytä tallennehakemistot"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Näytä tallennehakemistot"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Taukotallenteen prioriteetti"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Suurin tiedostokoko (Mt)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Käytä jakson nimeä"
 
@@ -1071,12 +1141,25 @@ msgstr "Pikatallennuksen kesto (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Suurin tiedostokoko (Mt)"
 
+# HARDLINKCUTTER
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Suurin tiedostokoko (Mt)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Merkitse pikatallenne"
+# HARDLINKCUTTER END
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Jaottele muokatut tallenteet"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Poista ajansiirtotallenne"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Toisto"
 
@@ -1092,6 +1175,38 @@ msgstr "Näytä jäljellä oleva aika"
 msgid "Setup.Replay$Resume ID"
 msgstr "Tallenteen paluutunniste"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Tallenteen paluutunniste"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Tallenteen paluutunniste"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Käytä toiston moninopeustilaa"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Tallenteen paluutunniste"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Tallenteen paluutunniste"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Tallenteen paluutunniste"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanava käynnistettäessä"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Käytä hätäsammutusta"
+
 msgid "Miscellaneous"
 msgstr "Sekalaiset"
 
@@ -1119,6 +1234,18 @@ msgstr "edellinen"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Äänenvoimakkuus käynnistettäessä"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Käytä hätäsammutusta"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Kanavien rullaus"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "edellinen"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Kanavien rullaus"
 
@@ -1128,6 +1255,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Käytä hätäsammutusta"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Käytä hätäsammutusta"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "edellinen"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Tapahtuman odotusaika (min)"
+
 msgid "Plugins"
 msgstr "Laajennokset"
 
@@ -1163,7 +1302,6 @@ msgstr "Lopeta"
 msgid "Button$Resume"
 msgstr "Jatka"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Peru muokkaus"
 
@@ -1365,3 +1503,48 @@ msgstr "Levy"
 
 msgid "free"
 msgstr "vapaana"
+
+#. USE_LIEMIKUUTIO
+msgid "Edit recording"
+msgstr "Muokkaa tallennetta"
+
+msgid "Button$Cut"
+msgstr "Leikkaa"
+
+msgid "Button$Copy"
+msgstr "Kopioi"
+
+msgid "Button$Rename/Move"
+msgstr "Nimeä/Siirrä"
+
+msgid "File transfer started"
+msgstr "Tiedoston siirto aloitettu"
+
+msgid "Can't start file transfer!"
+msgstr "Tiedoston siirron aloitus epäonnistui!"
+
+msgid "File transfer already active!"
+msgstr "Tiedoston siirto on jo käynnissä!"
+
+#. TRANSLATORS: note the leading blank!
+msgid " Cancel file transfer"
+msgstr " Peru tiedoston siirto"
+
+msgid "Cancel file transfer?"
+msgstr "Perutaanko tiedoston siirto?"
+
+msgid "Transfering file - shut down anyway?"
+msgstr "Tiedoston siirto kesken - sammutetaanko?"
+
+msgid "Transfering file - restart anyway?"
+msgstr "Tiedoston siirto kesken - käynnistetäänkö uudelleen?"
+
+msgid "File transfer failed!"
+msgstr "Tiedoston siirto epäonnistui!"
+
+msgid "File transfer finished"
+msgstr "Tiedoston siirto valmis"
+
+msgid "File already exists - overwrite?"
+msgstr "Tiedosto on jo olemassa - ylikirjoitetaanko?"
+#. LIEMIKUUTIO
diff --git a/po/fr_FR.po b/po/fr_FR.po
index 451cf56..ee28c44 100644
--- a/po/fr_FR.po
+++ b/po/fr_FR.po
@@ -566,6 +566,10 @@ msgstr "Acc
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Caractristiques des chanes non uniques"
 
@@ -642,6 +646,15 @@ msgstr "Priorit
 msgid "Lifetime"
 msgstr "Dure de vie"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "oui"
+
+msgid "no"
+msgstr "non"
+
 msgid "File"
 msgstr "Fichier"
 
@@ -735,6 +748,33 @@ msgstr "Lire"
 msgid "Button$Rewind"
 msgstr "Retour"
 
+msgid "Date"
+msgstr "Date"
+
+msgid "Length"
+msgstr "Longueur"
+
+msgid "Format"
+msgstr "Format"
+
+msgid "PES"
+msgstr "PES"
+
+msgid "TS"
+msgstr "TS"
+
+msgid "Size"
+msgstr "Taille"
+
+msgid "Delete marks information?"
+msgstr "Effacer les informations de marquage"
+
+msgid "Delete resume information?"
+msgstr "Effacer les informations de reprise"
+
+msgid "Error while accessing recording!"
+msgstr "Impossible d'accder  l'enregistrement"
+
 msgid "Recordings"
 msgstr "Enregistrements"
 
@@ -744,9 +784,6 @@ msgstr "Ouvrir"
 msgid "Commands"
 msgstr "Commandes"
 
-msgid "Error while accessing recording!"
-msgstr "Impossible d'accder  l'enregistrement"
-
 msgid "Delete recording?"
 msgstr "Supprimer l'enregistrement ?"
 
@@ -780,6 +817,10 @@ msgstr "Skin"
 msgid "Setup.OSD$Theme"
 msgstr "Thme"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Petite police"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Gauche (%)"
 
@@ -884,6 +925,18 @@ msgstr "Langues pr
 msgid "Setup.EPG$Preferred language"
 msgstr "Langue prfre"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr "Intervalle de recherche du double EPG(min)"
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr "Entre EPG externe en double"
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr "Mixer EPG interne et externe"
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr "Dsactiver vnement VPS"
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -893,9 +946,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "non"
-
 msgid "names only"
 msgstr "noms uniquement"
 
@@ -938,6 +988,10 @@ msgstr "Utiliser le Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Mettre  jour les chanes"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Position infos chanes"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Langues audio"
 
@@ -962,6 +1016,9 @@ msgstr "Transparence de l'avant-plan"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparence du fond"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1026,9 +1083,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "oui"
-
 msgid "Recording"
 msgstr "Enregistrement"
 
@@ -1053,6 +1107,22 @@ msgstr "Priorit
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Dure de vie des pauses (j)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Dossiers d'enregistrements"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Dossiers d'enregistrements"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Priorit des pauses"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Taille maxi des fichiers (Mo)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Utiliser le nom de l'pisode"
 
@@ -1074,12 +1144,23 @@ msgstr "Dur
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Taille maxi des fichiers (Mo)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Taille maxi des fichiers (Mo)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Marquage enregistr. immdiats"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Sparer les squences dites"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Lecture"
 
@@ -1095,6 +1176,35 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID de reprise"
 
+msgid "Setup.Replay$Jump&Play"
+msgstr "Lecture aprs saut"
+
+msgid "Setup.Replay$Play&Jump"
+msgstr "Saut sur les marques de dcoupes"
+
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Pause aprs la dernire marque"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Lecture aprs saut"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Lecture aprs saut"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Lecture aprs saut"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Chane initiale"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Arrt d'urgence"
+
 msgid "Miscellaneous"
 msgstr "Divers"
 
@@ -1122,6 +1232,18 @@ msgstr "comme avant"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Volume initial"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Arrt d'urgence"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Entre chane timeout (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "comme avant"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1131,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Arrt d'urgence"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Arrt d'urgence"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "comme avant"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "MinEventTimeout (min)"
+
 msgid "Plugins"
 msgstr "Greffons"
 
@@ -1166,7 +1300,6 @@ msgstr "Arr
 msgid "Button$Resume"
 msgstr "Reprendre"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Annuler le montage"
 
diff --git a/po/hr_HR.po b/po/hr_HR.po
index 6fddf87..7c8728e 100644
--- a/po/hr_HR.po
+++ b/po/hr_HR.po
@@ -562,6 +562,10 @@ msgstr "Kodiranje (CA)"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Postavke programa nisu jedinstvene!"
 
@@ -638,6 +642,15 @@ msgstr "Prioritet"
 msgid "Lifetime"
 msgstr "Trajanje"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "da"
+
+msgid "no"
+msgstr "ne"
+
 msgid "File"
 msgstr "Datoteka"
 
@@ -731,6 +744,36 @@ msgstr "Start"
 msgid "Button$Rewind"
 msgstr "Na poetak"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Obrisati snimku?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Obrisati snimku?"
+
+msgid "Error while accessing recording!"
+msgstr "Greka pri pristupanju snimke!"
+
 msgid "Recordings"
 msgstr "Snimke"
 
@@ -740,9 +783,6 @@ msgstr "Otvori"
 msgid "Commands"
 msgstr "Naredbe"
 
-msgid "Error while accessing recording!"
-msgstr "Greka pri pristupanju snimke!"
-
 msgid "Delete recording?"
 msgstr "Obrisati snimku?"
 
@@ -776,6 +816,10 @@ msgstr "Povr
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Maleni font"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Lijevo (%)"
 
@@ -880,6 +924,18 @@ msgstr "Preferirani jezici"
 msgid "Setup.EPG$Preferred language"
 msgstr "Preferirani jezik"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "proiri I ispitaj"
 
@@ -889,9 +945,6 @@ msgstr "pravokutnik"
 msgid "center cut out"
 msgstr "izrei sredinu"
 
-msgid "no"
-msgstr "ne"
-
 msgid "names only"
 msgstr "samo imena"
 
@@ -934,6 +987,10 @@ msgstr "Koristi Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Aktualiziraj programe"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Pozicija informacija o programu"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio jezici"
 
@@ -958,6 +1015,9 @@ msgstr "Transparentnost titla"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparentnost pozadine titla"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1022,9 +1082,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "da"
-
 msgid "Recording"
 msgstr "Snimanje"
 
@@ -1049,6 +1106,22 @@ msgstr "Prioritet pauze"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Trajanje pauze (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Imenik za snimke"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Imenik za snimke"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioritet pauze"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maksimalna veliina datoteke (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Koristi ime epizode"
 
@@ -1070,12 +1143,23 @@ msgstr "Trajanje direktnog snimanja (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maksimalna veliina datoteke (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maksimalna veliina datoteke (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Oznai direktno snimanje"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Podijeli ureene datoteke"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Reprodukcija"
 
@@ -1091,6 +1175,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID nastavka"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Viestruke brzine prikaza"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Poetni kanal"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Izlaz u sluaju nude"
+
 msgid "Miscellaneous"
 msgstr "Raznovrsno"
 
@@ -1118,6 +1234,18 @@ msgstr "kao prethodno"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Poetna jaina zvuka"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Izlaz u sluaju nude"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Upis kanala istjee (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "kao prethodno"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1127,6 +1255,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Izlaz u sluaju nude"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Izlaz u sluaju nude"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "kao prethodno"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Minimalno vrijeme pauze"
+
 msgid "Plugins"
 msgstr "Dodaci"
 
@@ -1162,7 +1302,6 @@ msgstr "Stop"
 msgid "Button$Resume"
 msgstr "Nastavi"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Prekini ureivanje"
 
diff --git a/po/hu_HU.po b/po/hu_HU.po
index 71047a3..92b5a66 100644
--- a/po/hu_HU.po
+++ b/po/hu_HU.po
@@ -563,6 +563,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Az adbelltsok nem egyrtelmek"
 
@@ -639,6 +643,15 @@ msgstr "Priorit
 msgid "Lifetime"
 msgstr "lettartam"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "igen"
+
+msgid "no"
+msgstr "nem"
+
 msgid "File"
 msgstr "File"
 
@@ -732,6 +745,36 @@ msgstr "Lej
 msgid "Button$Rewind"
 msgstr "Vissza az elejre"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Felvtel trlse?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Felvtel trlse?"
+
+msgid "Error while accessing recording!"
+msgstr "Hiba a felvtel hozzfrsnl"
+
 msgid "Recordings"
 msgstr "Felvtelek"
 
@@ -741,9 +784,6 @@ msgstr "Kinyitni"
 msgid "Commands"
 msgstr "Parancsok"
 
-msgid "Error while accessing recording!"
-msgstr "Hiba a felvtel hozzfrsnl"
-
 msgid "Delete recording?"
 msgstr "Felvtel trlse?"
 
@@ -777,6 +817,10 @@ msgstr "Men
 msgid "Setup.OSD$Theme"
 msgstr "Tma"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Kis bettipus"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Balra (%)"
 
@@ -881,6 +925,18 @@ msgstr "Kedvenc nyelvek"
 msgid "Setup.EPG$Preferred language"
 msgstr "Kedvenc nyelv"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -890,9 +946,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "kpkzp kivgs"
 
-msgid "no"
-msgstr "nem"
-
 msgid "names only"
 msgstr "kizrlag nevek"
 
@@ -935,6 +988,10 @@ msgstr "Dolby-Digital hangot haszn
 msgid "Setup.DVB$Update channels"
 msgstr "Adk aktualizlsa"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Adsinformci pozicija"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Hangsv nyelvek"
 
@@ -959,6 +1016,9 @@ msgstr "Felirat transzparenci
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Felirat htternek transzparencija"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1024,9 +1084,6 @@ msgstr "
 msgid "confirm"
 msgstr "megersts"
 
-msgid "yes"
-msgstr "igen"
-
 msgid "Recording"
 msgstr "Felvtel"
 
@@ -1051,6 +1108,22 @@ msgstr "Id
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Ideltols lettartama"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Felvtelek listja"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Felvtelek listja"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Sznet priorits"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Max. video File-terjedelem (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Epizdnv"
 
@@ -1072,12 +1145,23 @@ msgstr "Direktfelv
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Max. video file mret (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Max. video File-terjedelem (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Direktfelvtel megjellse"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Feldolgozott file-ok felosztsa"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Ideltolsos felvtel trlse"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Lejtszs"
 
@@ -1093,6 +1177,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Lejtszs ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Lejtszs ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Lejtszs ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "MultiSpeed funkci"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Lejtszs ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Lejtszs ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Lejtszs ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Ads a bekapcsolsnl"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "ahogy az elbb"
+
 msgid "Miscellaneous"
 msgstr "Egyb"
 
@@ -1120,6 +1236,15 @@ msgstr "ahogy az el
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Hanger indulsnl"
 
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr ""
+
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr ""
+
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr ""
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Csatornalista grgetse"
 
@@ -1129,6 +1254,15 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Vszlellts"
 
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr ""
+
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr ""
+
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr ""
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1164,7 +1298,6 @@ msgstr "Stop"
 msgid "Button$Resume"
 msgstr "Tovbb"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Vgst megszaktani"
 
diff --git a/po/it_IT.po b/po/it_IT.po
index 03cfbe1..6d21e28 100644
--- a/po/it_IT.po
+++ b/po/it_IT.po
@@ -567,6 +567,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Parametri canale non univoci!"
 
@@ -643,6 +647,15 @@ msgstr "Priorità"
 msgid "Lifetime"
 msgstr "Scadenza"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "sì"
+
+msgid "no"
+msgstr "no"
+
 msgid "File"
 msgstr "Nome"
 
@@ -736,6 +749,36 @@ msgstr "Riproduci"
 msgid "Button$Rewind"
 msgstr "Riavvolgi"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Eliminare la registrazione?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Eliminare la registrazione?"
+
+msgid "Error while accessing recording!"
+msgstr "Errore accesso alla registrazione!"
+
 msgid "Recordings"
 msgstr "Registrazioni"
 
@@ -745,9 +788,6 @@ msgstr "Apri"
 msgid "Commands"
 msgstr "Comandi"
 
-msgid "Error while accessing recording!"
-msgstr "Errore accesso alla registrazione!"
-
 msgid "Delete recording?"
 msgstr "Eliminare la registrazione?"
 
@@ -781,6 +821,10 @@ msgstr "Stile interfaccia"
 msgid "Setup.OSD$Theme"
 msgstr "Tema colori"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Caratteri piccoli"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Sinistra (%)"
 
@@ -885,6 +929,18 @@ msgstr "Lingue preferite"
 msgid "Setup.EPG$Preferred language"
 msgstr "Lingua preferita"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -894,9 +950,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "no"
-
 msgid "names only"
 msgstr "solo nomi"
 
@@ -939,6 +992,10 @@ msgstr "Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Aggiornamento canali"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Posizione info canale"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Lingue audio"
 
@@ -963,6 +1020,9 @@ msgstr "Trasparenza sottotitoli"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Trasparenza sfondo sottotitoli"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1027,9 +1087,6 @@ msgstr "pausa video dal vivo"
 msgid "confirm"
 msgstr "conferma"
 
-msgid "yes"
-msgstr "sì"
-
 msgid "Recording"
 msgstr "Registrazione"
 
@@ -1054,6 +1111,22 @@ msgstr "Priorità di pausa"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Scadenza pausa (gg)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Directory di registrazione"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Directory di registrazione"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Priorità di pausa"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Dim. massima file video (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Utilizza nome episodio"
 
@@ -1075,12 +1148,23 @@ msgstr "Durata reg. immediata (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Dim. massima file video (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Dim. massima file video (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Segna reg. immediata"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Dividi i file modificati"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Elimina registrazione timeshift"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Riproduzione"
 
@@ -1096,6 +1180,38 @@ msgstr "Mostra tempo rimanente"
 msgid "Setup.Replay$Resume ID"
 msgstr "ID di ripristino"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID di ripristino"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID di ripristino"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Modalità multispeed"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID di ripristino"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID di ripristino"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID di ripristino"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Canale iniziale"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Uscita di emergenza"
+
 msgid "Miscellaneous"
 msgstr "Generici"
 
@@ -1123,6 +1239,18 @@ msgstr "come prima"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Volume iniziale"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Uscita di emergenza"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Riavvolgimento canali"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "come prima"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Riavvolgimento canali"
 
@@ -1132,6 +1260,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Uscita di emergenza"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Uscita di emergenza"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "come prima"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Scadenza min. evento (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1167,7 +1307,6 @@ msgstr "Ferma"
 msgid "Button$Resume"
 msgstr "Riprendi"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Annulla modifiche"
 
diff --git a/po/lt_LT.po b/po/lt_LT.po
index 98b8a68..1ed9f1a 100644
--- a/po/lt_LT.po
+++ b/po/lt_LT.po
@@ -560,6 +560,10 @@ msgstr "CA (dekodavimo sistema)"
 msgid "Sid"
 msgstr "Serviso id"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Serviso id"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanalų nustatymai neunikalūs!"
 
@@ -636,6 +640,15 @@ msgstr "Prioritetas"
 msgid "Lifetime"
 msgstr "Galiojimas"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "taip"
+
+msgid "no"
+msgstr "ne"
+
 msgid "File"
 msgstr "Failas"
 
@@ -729,6 +742,36 @@ msgstr "Groti"
 msgid "Button$Rewind"
 msgstr "Atsukti"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Ištrinti įrašą?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Ištrinti įrašą?"
+
+msgid "Error while accessing recording!"
+msgstr "Klaida atidarant įrašą!"
+
 msgid "Recordings"
 msgstr "Įrašai"
 
@@ -738,9 +781,6 @@ msgstr "Atidaryti"
 msgid "Commands"
 msgstr "Komandos"
 
-msgid "Error while accessing recording!"
-msgstr "Klaida atidarant įrašą!"
-
 msgid "Delete recording?"
 msgstr "Ištrinti įrašą?"
 
@@ -774,6 +814,10 @@ msgstr "Stilius"
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Mažas šriftas"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Atitraukimas nuo kairės (%)"
 
@@ -878,6 +922,18 @@ msgstr "Pageidaujamos kalbos"
 msgid "Setup.EPG$Preferred language"
 msgstr "Pageidaujama kalba"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "panŲscan"
 
@@ -887,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "ne"
-
 msgid "names only"
 msgstr "tik pavadinimai"
 
@@ -932,6 +985,10 @@ msgstr "Įjungti Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Atnaujinti kanalus"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Kanalo informacijos lango pozicija"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Garso takeliai"
 
@@ -956,6 +1013,9 @@ msgstr "Subtitrų fonto permatomumas"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Subtitrų fono permatomumas"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "Konverteris (LNB)"
 
@@ -1020,9 +1080,6 @@ msgstr "pristabdyti 'gyvą' video srautą"
 msgid "confirm"
 msgstr "patvirtinti"
 
-msgid "yes"
-msgstr "taip"
-
 msgid "Recording"
 msgstr "Įrašymas"
 
@@ -1047,6 +1104,22 @@ msgstr "Atidėtos peržiūros prioritetas"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Atidėtos peržiūroso saugojimas (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Įrašų katalogai"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Įrašų katalogai"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Atidėtos peržiūros prioritetas"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maks. video failo dydis (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Grupuoti pagal epizodus"
 
@@ -1068,12 +1141,23 @@ msgstr "Rankiniu būdu vykdomo įrašo laikas (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maks. video failo dydis (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maks. video failo dydis (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Pažymėti rankiniu būdu vykdomus įrašus"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Suskaidyti koreguotus failus"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Trinti atidėto grojimo įrašą"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Pakartojimai"
 
@@ -1089,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Kūrinio ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Kūrinio ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Kūrinio ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Prasukimo ręžimas"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Kūrinio ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Kūrinio ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Kūrinio ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanalas įjungimo metu"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Avarinis išėjimas"
+
 msgid "Miscellaneous"
 msgstr "Kiti"
 
@@ -1116,6 +1232,18 @@ msgstr "kaip anksčiau"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Garsas įjungimo metu"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Avarinis išėjimas"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Kanalų pridengimas"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "kaip anksčiau"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Kanalų pridengimas"
 
@@ -1125,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Avarinis išėjimas"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Avarinis išėjimas"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "kaip anksčiau"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Min. įvykio laukimo laikas (min)"
+
 msgid "Plugins"
 msgstr "Įskiepai"
 
@@ -1160,7 +1300,6 @@ msgstr "Sustabdyti"
 msgid "Button$Resume"
 msgstr "Pradėti"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Sustabdyti koregavimą"
 
diff --git a/po/mk_MK.po b/po/mk_MK.po
index a767aca..1d3e25d 100644
--- a/po/mk_MK.po
+++ b/po/mk_MK.po
@@ -561,6 +561,10 @@ msgstr "Кодирање (CA)"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Уредбите на каналот не се уникатни!"
 
@@ -637,6 +641,15 @@ msgstr "Приоритет"
 msgid "Lifetime"
 msgstr "Траење"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "да"
+
+msgid "no"
+msgstr "не"
+
 msgid "File"
 msgstr "Датотека"
 
@@ -730,6 +743,36 @@ msgstr "Старт"
 msgid "Button$Rewind"
 msgstr "Премотај"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Избриши снимка?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Избриши снимка?"
+
+msgid "Error while accessing recording!"
+msgstr "Грешка при пристап до снимката!"
+
 msgid "Recordings"
 msgstr "Снимки"
 
@@ -739,9 +782,6 @@ msgstr "Отвори"
 msgid "Commands"
 msgstr "Наредби"
 
-msgid "Error while accessing recording!"
-msgstr "Грешка при пристап до снимката!"
-
 msgid "Delete recording?"
 msgstr "Избриши снимка?"
 
@@ -775,6 +815,10 @@ msgstr "Фасада"
 msgid "Setup.OSD$Theme"
 msgstr "Тема"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Мал фонт"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Лево (%)"
 
@@ -879,6 +923,18 @@ msgstr "Омилени јазици"
 msgid "Setup.EPG$Preferred language"
 msgstr "Омилен јазик"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "прошири и барај"
 
@@ -888,9 +944,6 @@ msgstr "плико"
 msgid "center cut out"
 msgstr "исечи средина"
 
-msgid "no"
-msgstr "не"
-
 msgid "names only"
 msgstr "само имиња"
 
@@ -933,6 +986,10 @@ msgstr "Користи Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Ажурирај канали"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Позиција на информациите за каналот"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Аудио јазици"
 
@@ -957,6 +1014,9 @@ msgstr "Провидност на титлот"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Провидност на позадината на титлот"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1021,9 +1081,6 @@ msgstr "пауза на пренос во живо"
 msgid "confirm"
 msgstr "потврди"
 
-msgid "yes"
-msgstr "да"
-
 msgid "Recording"
 msgstr "Снимање"
 
@@ -1048,6 +1105,22 @@ msgstr "Приоритет на пауза"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Траење на пауза (денови)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Директориум за снимки"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Директориум за снимки"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Приоритет на пауза"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Максимална големина на датотека (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Користи име на епизода"
 
@@ -1069,12 +1142,23 @@ msgstr "Траење на директно снимање (мин)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Максимална големина на датотека (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Максимална големина на датотека (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Означи директно снимање"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Раздвои уредени датотеки"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Избриши временски поместена снимка"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Репродукција"
 
@@ -1090,6 +1174,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID на продолжеток"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID на продолжеток"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID на продолжеток"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Повеќебрзински режим"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID на продолжеток"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID на продолжеток"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID на продолжеток"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Почетен канал"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Итен излез"
+
 msgid "Miscellaneous"
 msgstr "Разно"
 
@@ -1117,6 +1233,18 @@ msgstr "како претходно"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Почетна јачина на звук"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Итен излез"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Премотување канали"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "како претходно"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Премотување канали"
 
@@ -1126,6 +1254,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Итен излез"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Итен излез"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "како претходно"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Минимално време на тајмаут (мин)"
+
 msgid "Plugins"
 msgstr "Додатоци"
 
@@ -1161,7 +1301,6 @@ msgstr "Стоп"
 msgid "Button$Resume"
 msgstr "Продолжи"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Откажи уредување"
 
diff --git a/po/nl_NL.po b/po/nl_NL.po
index a312fdc..2c2e3c7 100644
--- a/po/nl_NL.po
+++ b/po/nl_NL.po
@@ -564,6 +564,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanaalinstellingen zijn niet uniek!"
 
@@ -640,6 +644,15 @@ msgstr "Prioriteit"
 msgid "Lifetime"
 msgstr "Bewaarduur"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "ja"
+
+msgid "no"
+msgstr "nee"
+
 msgid "File"
 msgstr "Bestandnaam"
 
@@ -733,6 +746,36 @@ msgstr "Afspelen"
 msgid "Button$Rewind"
 msgstr "Naar begin"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Opname verwijderen?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Opname verwijderen?"
+
+msgid "Error while accessing recording!"
+msgstr "Fout bij lezen opname!"
+
 msgid "Recordings"
 msgstr "Opnames"
 
@@ -742,9 +785,6 @@ msgstr "Openen"
 msgid "Commands"
 msgstr "Commando's"
 
-msgid "Error while accessing recording!"
-msgstr "Fout bij lezen opname!"
-
 msgid "Delete recording?"
 msgstr "Opname verwijderen?"
 
@@ -778,6 +818,10 @@ msgstr "Skin"
 msgid "Setup.OSD$Theme"
 msgstr "Thema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Kleine lettertype"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Links (%)"
 
@@ -882,6 +926,18 @@ msgstr "Voorkeurstalen"
 msgid "Setup.EPG$Preferred language"
 msgstr "Voorkeurstaal"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -891,9 +947,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "nee"
-
 msgid "names only"
 msgstr "alleen namen"
 
@@ -936,6 +989,10 @@ msgstr "Dolby Digital gebruiken"
 msgid "Setup.DVB$Update channels"
 msgstr "Kanalen actualiseren"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Kanaal info positie"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio talen"
 
@@ -960,6 +1017,9 @@ msgstr "Transparantie voorgrond ondertiteling"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparantie achtergrond ondertiteling"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1024,9 +1084,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "ja"
-
 msgid "Recording"
 msgstr "Opname"
 
@@ -1051,6 +1108,22 @@ msgstr "Pauze prioriteit"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Pauze levensduur (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Opname mappen"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Opname mappen"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Pauze prioriteit"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maximale omvang video file (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Gebruik episode naam"
 
@@ -1072,12 +1145,23 @@ msgstr "Duur van de directe opname (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maximale omvang video file (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maximale omvang video file (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Direkte opnamen markeren"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Bewerkte files opdelen"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Afspelen"
 
@@ -1093,6 +1177,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Hervattings ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Hervattings ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Hervattings ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Multi-speed mode"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Hervattings ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Hervattings ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Hervattings ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Opstartkanaal"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Nooduitgang"
+
 msgid "Miscellaneous"
 msgstr "Overig"
 
@@ -1120,6 +1236,18 @@ msgstr "zoals eerder"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Opstartvolume"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Nooduitgang"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Tijdsduur kanaalinvoer (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "zoals eerder"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1129,6 +1257,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Nooduitgang"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Nooduitgang"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "zoals eerder"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Minimale event time-out (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1164,7 +1304,6 @@ msgstr "Eindigen"
 msgid "Button$Resume"
 msgstr "Hervat"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Bewerken afbreken"
 
diff --git a/po/nn_NO.po b/po/nn_NO.po
index 2612be2..37463c1 100644
--- a/po/nn_NO.po
+++ b/po/nn_NO.po
@@ -561,6 +561,10 @@ msgstr "Kortleser"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr ""
 
@@ -637,6 +641,15 @@ msgstr "Prioritet"
 msgid "Lifetime"
 msgstr "Levetid"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "ja"
+
+msgid "no"
+msgstr "nei"
+
 msgid "File"
 msgstr "Filnavn"
 
@@ -730,6 +743,35 @@ msgstr "Spill av"
 msgid "Button$Rewind"
 msgstr "Spol tilbake"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+msgid "PES"
+msgstr ""
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Slette opptak?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Slette opptak?"
+
+msgid "Error while accessing recording!"
+msgstr "Feil under lesing av opptak!"
+
 msgid "Recordings"
 msgstr "Opptak"
 
@@ -739,9 +781,6 @@ msgstr "
 msgid "Commands"
 msgstr "Kommandoer"
 
-msgid "Error while accessing recording!"
-msgstr "Feil under lesing av opptak!"
-
 msgid "Delete recording?"
 msgstr "Slette opptak?"
 
@@ -775,6 +814,10 @@ msgstr ""
 msgid "Setup.OSD$Theme"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Sprk"
+
 msgid "Setup.OSD$Left (%)"
 msgstr ""
 
@@ -879,6 +922,18 @@ msgstr ""
 msgid "Setup.EPG$Preferred language"
 msgstr ""
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -888,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "nei"
-
 msgid "names only"
 msgstr ""
 
@@ -933,6 +985,10 @@ msgstr ""
 msgid "Setup.DVB$Update channels"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Posisjon p kanalinformasjon"
+
 msgid "Setup.DVB$Audio languages"
 msgstr ""
 
@@ -957,6 +1013,9 @@ msgstr ""
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr ""
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1021,9 +1080,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "ja"
-
 msgid "Recording"
 msgstr "Opptak"
 
@@ -1048,6 +1104,22 @@ msgstr ""
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Kataloger til opptak"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Kataloger til opptak"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Normal prioritet (Timer)"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maksimal strrelse p videofiler (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Bruk episodenavn"
 
@@ -1069,12 +1141,23 @@ msgstr ""
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maksimal strrelse p videofiler (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maksimal strrelse p videofiler (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Markere direkteopptak"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Splitt redigerte filer"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Spill av"
 
@@ -1090,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Resume ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Resume ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Resume ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Multispeed modus"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Resume ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Resume ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Resume ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Minste hendelsespause (min)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Minste hendelsespause (min)"
+
 msgid "Miscellaneous"
 msgstr "Forskjellig"
 
@@ -1117,6 +1232,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Minste hendelsespause (min)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Minste hendelsespause (min)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "Minste hendelsespause (min)"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1126,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Minste hendelsespause (min)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "Minste hendelsespause (min)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Minste hendelsespause (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1161,7 +1300,6 @@ msgstr "Stopp"
 msgid "Button$Resume"
 msgstr "Fortsett"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Avbryt redigering"
 
diff --git a/po/pl_PL.po b/po/pl_PL.po
index 166b35b..52c6e61 100644
--- a/po/pl_PL.po
+++ b/po/pl_PL.po
@@ -561,6 +561,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Ustawienia kanau nie s unikalne!"
 
@@ -637,6 +641,15 @@ msgstr "Priorytet"
 msgid "Lifetime"
 msgstr "Czas ycia"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "tak"
+
+msgid "no"
+msgstr "nie"
+
 msgid "File"
 msgstr "Plik"
 
@@ -730,6 +743,36 @@ msgstr "Odtw
 msgid "Button$Rewind"
 msgstr "Pocztek"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Usun nagranie?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Usun nagranie?"
+
+msgid "Error while accessing recording!"
+msgstr "Bld podczas dostpu do nagrania!"
+
 msgid "Recordings"
 msgstr "Nagrania"
 
@@ -739,9 +782,6 @@ msgstr "Otw
 msgid "Commands"
 msgstr "Polecenia"
 
-msgid "Error while accessing recording!"
-msgstr "Bld podczas dostpu do nagrania!"
-
 msgid "Delete recording?"
 msgstr "Usun nagranie?"
 
@@ -775,6 +815,10 @@ msgstr "Sk
 msgid "Setup.OSD$Theme"
 msgstr "Motyw"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Maa czcionka"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Od lewej (%)"
 
@@ -879,6 +923,18 @@ msgstr "Preferowanych j
 msgid "Setup.EPG$Preferred language"
 msgstr "Preferowany jzyk"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -888,9 +944,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "nie"
-
 msgid "names only"
 msgstr "tylko nazwy"
 
@@ -933,6 +986,10 @@ msgstr "U
 msgid "Setup.DVB$Update channels"
 msgstr "Aktualizuj kanay"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Pozycja informacji o kanale"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Jzykw dwiku"
 
@@ -957,6 +1014,9 @@ msgstr "Prze
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Przerocze podtytuw: To"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1021,9 +1081,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "tak"
-
 msgid "Recording"
 msgstr "Nagranie"
 
@@ -1048,6 +1105,22 @@ msgstr "Priorytet pauzy"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Czas ycia pauzy (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Katalogi nagra"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Katalogi nagra"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Priorytet pauzy"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maksymalny rozmiar pliku (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Uywaj nazwy epizodu"
 
@@ -1069,12 +1142,23 @@ msgstr "Czas natychm. nagrywania (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maksymalny rozmiar pliku (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maksymalny rozmiar pliku (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Zaznaczaj natychm. nagrywanie"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Dziel edytowane pliki"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Odtwarzanie"
 
@@ -1090,6 +1174,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID wznowienia"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID wznowienia"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID wznowienia"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Tryb wieloprdkociowy"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID wznowienia"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID wznowienia"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID wznowienia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Pocztkowy kana"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Wyjcie awaryjne"
+
 msgid "Miscellaneous"
 msgstr "Rne"
 
@@ -1117,6 +1233,18 @@ msgstr "jak ostatnio"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Pocztkowa gono"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Wyjcie awaryjne"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Min czas wejcia do kanau"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "jak ostatnio"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1126,6 +1254,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Wyjcie awaryjne"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Wyjcie awaryjne"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "jak ostatnio"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Minimalny czas audycji (min)"
+
 msgid "Plugins"
 msgstr "Wtyczki"
 
@@ -1161,7 +1301,6 @@ msgstr "Zatrzymaj"
 msgid "Button$Resume"
 msgstr "Wznw"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Anuluj edycj"
 
diff --git a/po/pt_PT.po b/po/pt_PT.po
index da11c07..c380dc0 100644
--- a/po/pt_PT.po
+++ b/po/pt_PT.po
@@ -561,6 +561,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Parmetros do canal no so nicos!"
 
@@ -637,6 +641,15 @@ msgstr "Prioridade"
 msgid "Lifetime"
 msgstr "Validade"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "sim"
+
+msgid "no"
+msgstr "no"
+
 msgid "File"
 msgstr "Ficheiro"
 
@@ -730,6 +743,36 @@ msgstr "Reproduzir"
 msgid "Button$Rewind"
 msgstr "Retroceder"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Eliminar gravao?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Eliminar gravao?"
+
+msgid "Error while accessing recording!"
+msgstr "Erro a aceder s gravaes!"
+
 msgid "Recordings"
 msgstr "Gravaes"
 
@@ -739,9 +782,6 @@ msgstr "Abrir"
 msgid "Commands"
 msgstr "Comandos"
 
-msgid "Error while accessing recording!"
-msgstr "Erro a aceder s gravaes!"
-
 msgid "Delete recording?"
 msgstr "Eliminar gravao?"
 
@@ -775,6 +815,10 @@ msgstr "Tema"
 msgid "Setup.OSD$Theme"
 msgstr "Cor do tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Fonte pequena"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Esquerda (%)"
 
@@ -879,6 +923,18 @@ msgstr "L
 msgid "Setup.EPG$Preferred language"
 msgstr "Lngua preferida"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -888,9 +944,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "no"
-
 msgid "names only"
 msgstr "apenas nomes"
 
@@ -933,6 +986,10 @@ msgstr "Usar Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Actualizar canais"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Posio da informao de canal"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Idiomas do udio"
 
@@ -957,6 +1014,9 @@ msgstr "Transpar
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparncia de fundo das legendas"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1021,9 +1081,6 @@ msgstr "pausar emiss
 msgid "confirm"
 msgstr "confirmar"
 
-msgid "yes"
-msgstr "sim"
-
 msgid "Recording"
 msgstr "Gravao"
 
@@ -1048,6 +1105,22 @@ msgstr "Prioridade da pausa"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Validade da pausa (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Pasta de gravaes"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Pasta de gravaes"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioridade da pausa"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Tamanho mximo do ficheiro de vdeo (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Usar nome do episdio"
 
@@ -1069,12 +1142,23 @@ msgstr "Validade da grava
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Tamanho mximo do ficheiro de vdeo (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Tamanho mximo do ficheiro de vdeo (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Marcar gravao instantnea"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Dividir ficheiros editados"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Eliminar gravaes timeshift"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Reproduzir"
 
@@ -1090,6 +1174,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID de resumo"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID de resumo"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID de resumo"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Modo multi velocidade"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID de resumo"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID de resumo"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID de resumo"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Canal inicial"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Sada de emergncia"
+
 msgid "Miscellaneous"
 msgstr "Outros"
 
@@ -1117,6 +1233,18 @@ msgstr "como estava"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Volume inicial"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Sada de emergncia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Retroceder canais"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "como estava"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Retroceder canais"
 
@@ -1126,6 +1254,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Sada de emergncia"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Sada de emergncia"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "como estava"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Tempo de espera mnimo antes de evento (min)"
+
 msgid "Plugins"
 msgstr "Plugins"
 
@@ -1161,7 +1301,6 @@ msgstr "Parar"
 msgid "Button$Resume"
 msgstr "Continuar"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Cancelar edio"
 
diff --git a/po/ro_RO.po b/po/ro_RO.po
index 3f6d1e1..3881057 100644
--- a/po/ro_RO.po
+++ b/po/ro_RO.po
@@ -563,6 +563,10 @@ msgstr "CA (Acces Condi
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Parametrii canalului nu sunt univoci!"
 
@@ -639,6 +643,15 @@ msgstr "Prioritate"
 msgid "Lifetime"
 msgstr "Timp de pstrare"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "da"
+
+msgid "no"
+msgstr "nu"
+
 msgid "File"
 msgstr "Fiier"
 
@@ -732,6 +745,36 @@ msgstr "Redare"
 msgid "Button$Rewind"
 msgstr "napoi"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "terg nregistrarea?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "terg nregistrarea?"
+
+msgid "Error while accessing recording!"
+msgstr "Eroare la accesarea nregistrrii"
+
 msgid "Recordings"
 msgstr "nregistrri"
 
@@ -741,9 +784,6 @@ msgstr "Deschide"
 msgid "Commands"
 msgstr "Comenzi"
 
-msgid "Error while accessing recording!"
-msgstr "Eroare la accesarea nregistrrii"
-
 msgid "Delete recording?"
 msgstr "terg nregistrarea?"
 
@@ -777,6 +817,10 @@ msgstr "Skin"
 msgid "Setup.OSD$Theme"
 msgstr "Tem"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Font mic"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Stnga (%)"
 
@@ -881,6 +925,18 @@ msgstr "Limbi preferate"
 msgid "Setup.EPG$Preferred language"
 msgstr "Limba preferat"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -890,9 +946,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "nu"
-
 msgid "names only"
 msgstr "doar numele"
 
@@ -935,6 +988,10 @@ msgstr "Sunet Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Actualizare canale"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Poziia informaiilor despre canal"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Limbi sunet"
 
@@ -959,6 +1016,9 @@ msgstr "Transparen
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparena fundalului subtitrrii"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1023,9 +1083,6 @@ msgstr "
 msgid "confirm"
 msgstr "confirmare"
 
-msgid "yes"
-msgstr "da"
-
 msgid "Recording"
 msgstr "nregistrare"
 
@@ -1050,6 +1107,22 @@ msgstr "Prioritate pauz
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Pstrarea emisiunilor 'pauzate' (zile)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Directoare nregistrri"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Directoare nregistrri"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioritate pauz"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Dimensiune maxim a fiierului video (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Utilizeaz numele episodului"
 
@@ -1071,12 +1144,23 @@ msgstr "Timpul de 
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Dimensiune maxim a fiierului video (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Dimensiune maxim a fiierului video (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Marcheaz nregistrare imediat"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Separare fiiere montate"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "terge nregistrarea pentru vizionare decalat"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Redare"
 
@@ -1092,6 +1176,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Identificator continuare"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Identificator continuare"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Identificator continuare"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Mod multi-vitez"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Identificator continuare"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Identificator continuare"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Identificator continuare"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Canalul de pornire"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Oprire de urgen"
+
 msgid "Miscellaneous"
 msgstr "Diverse"
 
@@ -1119,6 +1235,18 @@ msgstr "ca mai 
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Volumul la pornire"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Oprire de urgen"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Lista de canale n bucl"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "ca mai nainte"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Lista de canale n bucl"
 
@@ -1128,6 +1256,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Oprire de urgen"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Oprire de urgen"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "ca mai nainte"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Durat minim emisiuni (min)"
+
 msgid "Plugins"
 msgstr "Plugin-uri"
 
@@ -1163,7 +1303,6 @@ msgstr "Stop"
 msgid "Button$Resume"
 msgstr "Continuare"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Oprete montajul nregistrrii"
 
diff --git a/po/ru_RU.po b/po/ru_RU.po
index 4ed7801..35c123e 100644
--- a/po/ru_RU.po
+++ b/po/ru_RU.po
@@ -561,6 +561,10 @@ msgstr "CA (
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "   !"
 
@@ -637,6 +641,15 @@ msgstr "
 msgid "Lifetime"
 msgstr " "
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr ""
+
+msgid "no"
+msgstr ""
+
 msgid "File"
 msgstr ""
 
@@ -730,6 +743,33 @@ msgstr "
 msgid "Button$Rewind"
 msgstr ""
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+msgid "PES"
+msgstr ""
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+msgid "Delete marks information?"
+msgstr ""
+
+msgid "Delete resume information?"
+msgstr ""
+
+msgid "Error while accessing recording!"
+msgstr "   !"
+
 msgid "Recordings"
 msgstr ""
 
@@ -739,9 +779,6 @@ msgstr "
 msgid "Commands"
 msgstr ""
 
-msgid "Error while accessing recording!"
-msgstr "   !"
-
 msgid "Delete recording?"
 msgstr " ?"
 
@@ -775,6 +812,10 @@ msgstr "
 msgid "Setup.OSD$Theme"
 msgstr ""
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr " "
+
 msgid "Setup.OSD$Left (%)"
 msgstr "  (%)"
 
@@ -879,6 +920,18 @@ msgstr "
 msgid "Setup.EPG$Preferred language"
 msgstr ""
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr ""
 
@@ -888,9 +941,6 @@ msgstr "
 msgid "center cut out"
 msgstr " "
 
-msgid "no"
-msgstr ""
-
 msgid "names only"
 msgstr " "
 
@@ -933,6 +983,10 @@ msgstr "
 msgid "Setup.DVB$Update channels"
 msgstr "  "
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "    "
+
 msgid "Setup.DVB$Audio languages"
 msgstr "  ()"
 
@@ -957,6 +1011,9 @@ msgstr "
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "  "
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr ""
 
@@ -1021,9 +1078,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr ""
-
 msgid "Recording"
 msgstr ""
 
@@ -1048,6 +1102,22 @@ msgstr "
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "   ()"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "  "
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "  "
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "  "
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr ".   ()"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "   "
 
@@ -1069,12 +1139,23 @@ msgstr "
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr ".   ()"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr ".   ()"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "   "
+
 msgid "Setup.Recording$Split edited files"
 msgstr "  "
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr ""
 
@@ -1090,6 +1171,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID "
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr " "
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID "
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "  "
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr " "
+
 msgid "Miscellaneous"
 msgstr ""
 
@@ -1117,6 +1230,18 @@ msgstr "
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "  "
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr " "
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "     (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr " "
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1126,6 +1251,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr " "
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr " "
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr " "
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr ".    ()"
+
 msgid "Plugins"
 msgstr " "
 
@@ -1161,7 +1298,6 @@ msgstr "
 msgid "Button$Resume"
 msgstr ""
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr "   "
 
diff --git a/po/sk_SK.po b/po/sk_SK.po
index 069fd55..4a6f8d9 100644
--- a/po/sk_SK.po
+++ b/po/sk_SK.po
@@ -560,6 +560,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Nastavenia kanlu nie s obyajn!"
 
@@ -636,6 +640,15 @@ msgstr "Priorita"
 msgid "Lifetime"
 msgstr "ivotnos"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "no"
+
+msgid "no"
+msgstr "nie"
+
 msgid "File"
 msgstr "Sbor"
 
@@ -729,6 +742,36 @@ msgstr "Prehra
 msgid "Button$Rewind"
 msgstr "Na zaiatok"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Zmaza nahrvku?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Zmaza nahrvku?"
+
+msgid "Error while accessing recording!"
+msgstr "Chyba pri prstupe k nahrvkam!"
+
 msgid "Recordings"
 msgstr "Nahrvky"
 
@@ -738,9 +781,6 @@ msgstr "Otvori
 msgid "Commands"
 msgstr "Prkazy"
 
-msgid "Error while accessing recording!"
-msgstr "Chyba pri prstupe k nahrvkam!"
-
 msgid "Delete recording?"
 msgstr "Zmaza nahrvku?"
 
@@ -774,6 +814,10 @@ msgstr "Vzh
 msgid "Setup.OSD$Theme"
 msgstr "Tma"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Mal psmo"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Vavo (%)"
 
@@ -878,6 +922,18 @@ msgstr "Uprednost
 msgid "Setup.EPG$Preferred language"
 msgstr "Uprednostni jazyk"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -887,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "oreza do stredu"
 
-msgid "no"
-msgstr "nie"
-
 msgid "names only"
 msgstr "iba nzvy"
 
@@ -932,6 +985,10 @@ msgstr "Pou
 msgid "Setup.DVB$Update channels"
 msgstr "Aktualizcia kanlov"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Pozcia informci o kanle"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Jazyky zvuku"
 
@@ -956,6 +1013,9 @@ msgstr "Prieh
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Priehadnos pozadia titulkov"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1020,9 +1080,6 @@ msgstr "preru
 msgid "confirm"
 msgstr "overi"
 
-msgid "yes"
-msgstr "no"
-
 msgid "Recording"
 msgstr "Nahrvanie"
 
@@ -1047,6 +1104,22 @@ msgstr "Priorita preru
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "ivotnos preruenia (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Zoznam nahrvok"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Zoznam nahrvok"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Priorita preruenia"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maximlna vekos nahrvky (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Pouva nzov epizdy"
 
@@ -1068,12 +1141,23 @@ msgstr "D
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maximlna vekos nahrvky (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maximlna vekos nahrvky (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Oznai okamit nahrvky"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Deli upravovan sbory"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Vymaza timeshift zznamy"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Prehrvanie"
 
@@ -1089,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID obnovenie"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID obnovenie"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID obnovenie"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Viac rchlostn reim"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID obnovenie"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID obnovenie"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID obnovenie"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanl po spusten"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Ndzov ukonenie"
+
 msgid "Miscellaneous"
 msgstr "Rzne"
 
@@ -1116,6 +1232,18 @@ msgstr "ako naposledy"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Hlasitos po spusten"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Ndzov ukonenie"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Prepna z prvho na posledn a opane"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "ako naposledy"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Prepna z prvho na posledn a opane"
 
@@ -1125,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Ndzov ukonenie"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Ndzov ukonenie"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "ako naposledy"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Min. pauza medzi udalosami (min)"
+
 msgid "Plugins"
 msgstr "Moduly"
 
@@ -1160,7 +1300,6 @@ msgstr "Zastavi
 msgid "Button$Resume"
 msgstr "Pokraova"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Zrui pravu"
 
diff --git a/po/sl_SI.po b/po/sl_SI.po
index 5bb6b9b..1979029 100644
--- a/po/sl_SI.po
+++ b/po/sl_SI.po
@@ -561,6 +561,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Nastavitve kanala niso edinstvene!"
 
@@ -637,6 +641,15 @@ msgstr "Prioriteta"
 msgid "Lifetime"
 msgstr "Veljavnost"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "da"
+
+msgid "no"
+msgstr "ne"
+
 msgid "File"
 msgstr "Datoteka"
 
@@ -730,6 +743,36 @@ msgstr "Predvajaj"
 msgid "Button$Rewind"
 msgstr "Na zaetek"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Izbrii posnetek?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Izbrii posnetek?"
+
+msgid "Error while accessing recording!"
+msgstr "Napaka pri dostopu do posnetka!"
+
 msgid "Recordings"
 msgstr "Posnetki"
 
@@ -739,9 +782,6 @@ msgstr "Odpri"
 msgid "Commands"
 msgstr "Ukazi"
 
-msgid "Error while accessing recording!"
-msgstr "Napaka pri dostopu do posnetka!"
-
 msgid "Delete recording?"
 msgstr "Izbrii posnetek?"
 
@@ -775,6 +815,10 @@ msgstr "Preobleka"
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Mala pisava"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Levo (%)"
 
@@ -879,6 +923,18 @@ msgstr "Prednostni jeziki"
 msgid "Setup.EPG$Preferred language"
 msgstr "Prednostni jezik"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -888,9 +944,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "ne"
-
 msgid "names only"
 msgstr "samo imena"
 
@@ -933,6 +986,10 @@ msgstr "Uporabljaj Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Posodobi kanale"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Pozicija informacije o kanalu"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Jeziki za zvok"
 
@@ -957,6 +1014,9 @@ msgstr "Transparentnost podnapisov"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparentnost ozadja podnapisov"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1021,9 +1081,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "da"
-
 msgid "Recording"
 msgstr "Snemanje"
 
@@ -1048,6 +1105,22 @@ msgstr "Prioriteta pavze"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "as pavze (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Direktoriji za posnetke"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Direktoriji za posnetke"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioriteta pavze"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Najveja velikost datoteke (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Uporabi ime epizode"
 
@@ -1069,12 +1142,23 @@ msgstr "
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Najveja velikost datoteke (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Najveja velikost datoteke (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Oznai direktno snemanje"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Razdeli urejene datoteke"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Predvajanje"
 
@@ -1090,6 +1174,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID za predvajanje"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID za predvajanje"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID za predvajanje"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Reim z ve hitrostmi"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID za predvajanje"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID za predvajanje"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID za predvajanje"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Privzeti kanal"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Izhod v sili"
+
 msgid "Miscellaneous"
 msgstr "Ostalo"
 
@@ -1117,6 +1233,18 @@ msgstr "kot prej"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Privzeta glasnost"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Izhod v sili"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Timeout za vnos kanala (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "kot prej"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1126,6 +1254,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Izhod v sili"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Izhod v sili"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "kot prej"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Najmanji as dogodka (min)"
+
 msgid "Plugins"
 msgstr "Vstavki"
 
@@ -1161,7 +1301,6 @@ msgstr "Ustavi"
 msgid "Button$Resume"
 msgstr "Nadaljuj"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Prekini urejanje"
 
diff --git a/po/sr_SR.po b/po/sr_SR.po
index 4be71c5..07c07dc 100644
--- a/po/sr_SR.po
+++ b/po/sr_SR.po
@@ -562,6 +562,10 @@ msgstr "Kodiranje (CA)"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Postavke programa nisu jedinstvene!"
 
@@ -641,6 +645,16 @@ msgstr "Prioritet"
 msgid "Lifetime"
 msgstr "Trajanje"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr ""
+
+#, fuzzy
+msgid "no"
+msgstr "nita"
+
 msgid "File"
 msgstr "Datoteka"
 
@@ -735,6 +749,36 @@ msgstr "Start"
 msgid "Button$Rewind"
 msgstr "Poetak"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Obrii snimku?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Obrii snimku?"
+
+msgid "Error while accessing recording!"
+msgstr "Greka prilikom pristupa snimanju!"
+
 #, fuzzy
 msgid "Recordings"
 msgstr "Snimanje"
@@ -747,9 +791,6 @@ msgstr "Meni"
 msgid "Commands"
 msgstr "Naredbe"
 
-msgid "Error while accessing recording!"
-msgstr "Greka prilikom pristupa snimanju!"
-
 msgid "Delete recording?"
 msgstr "Obrii snimku?"
 
@@ -784,6 +825,10 @@ msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
 #, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Mali font"
+
+#, fuzzy
 msgid "Setup.OSD$Left (%)"
 msgstr "Levo(%)"
 
@@ -896,6 +941,18 @@ msgstr "Odaberi jezike"
 msgid "Setup.EPG$Preferred language"
 msgstr "Odaberi jezik"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "proiri i ispitaj"
 
@@ -905,10 +962,6 @@ msgstr "pravougaonik"
 msgid "center cut out"
 msgstr "izrei sredinu"
 
-#, fuzzy
-msgid "no"
-msgstr "nita"
-
 msgid "names only"
 msgstr "samo imena"
 
@@ -951,6 +1004,10 @@ msgstr "Koristi Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Auriranje kanala"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Pozicija informacija o programu"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio jezici"
 
@@ -975,6 +1032,9 @@ msgstr "Providnost titla"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Providnost pozadine titla"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1042,9 +1102,6 @@ msgstr "Zaustavljanje izravnog prenosa..."
 msgid "confirm"
 msgstr "potvrdi"
 
-msgid "yes"
-msgstr ""
-
 msgid "Recording"
 msgstr "Snimanje"
 
@@ -1070,6 +1127,22 @@ msgstr "Prioritet pauze"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Trajanje pauze (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Direktorij za snimke"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Direktorij za snimke"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioritet pauze"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maks. veliina datoteke (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Koristi naziv epizode"
 
@@ -1091,12 +1164,23 @@ msgstr "Trajanje trenutnog snimanja (min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maks. veliina datoteke (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maks. veliina datoteke (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Oznai trenutno snimanje"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Podeli ureene datoteke"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Brii vremenski pomak snimke"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Reprodukcija"
 
@@ -1112,6 +1196,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID nastavka"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Viestruke brzine reprodukcije"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID nastavka"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Poetni kanal"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Izlaz u sluaju nude"
+
 msgid "Miscellaneous"
 msgstr "Razno"
 
@@ -1140,6 +1256,18 @@ msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Poetna jaina tona"
 
 #, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Izlaz u sluaju nude"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Kanal spakovan"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "kao prethodno"
+
+#, fuzzy
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Kanal spakovan"
 
@@ -1149,6 +1277,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Izlaz u sluaju nude"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Izlaz u sluaju nude"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "kao prethodno"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Min. vreme pauze (min)"
+
 msgid "Plugins"
 msgstr "Dodaci"
 
@@ -1184,7 +1324,6 @@ msgstr "Stop"
 msgid "Button$Resume"
 msgstr "Nastavi"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr "Zaustavi ispravke"
 
diff --git a/po/sv_SE.po b/po/sv_SE.po
index 4e99893..7c86873 100644
--- a/po/sv_SE.po
+++ b/po/sv_SE.po
@@ -563,6 +563,10 @@ msgstr "Kortl
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanalinstllningarna r ej unika!"
 
@@ -639,6 +643,15 @@ msgstr "Prioritet"
 msgid "Lifetime"
 msgstr "Livstid"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "ja"
+
+msgid "no"
+msgstr "nej"
+
 msgid "File"
 msgstr "Filnamn"
 
@@ -732,6 +745,36 @@ msgstr "Spela upp"
 msgid "Button$Rewind"
 msgstr "terspolning"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Ta bort inspelningen?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Ta bort inspelningen?"
+
+msgid "Error while accessing recording!"
+msgstr "Inspelningen gr inte att lsa!"
+
 msgid "Recordings"
 msgstr "Inspelningar"
 
@@ -741,9 +784,6 @@ msgstr "
 msgid "Commands"
 msgstr "Kommandon"
 
-msgid "Error while accessing recording!"
-msgstr "Inspelningen gr inte att lsa!"
-
 msgid "Delete recording?"
 msgstr "Ta bort inspelningen?"
 
@@ -777,6 +817,10 @@ msgstr "Skin"
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Sm typsnitt"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Vnster (%)"
 
@@ -881,6 +925,18 @@ msgstr "
 msgid "Setup.EPG$Preferred language"
 msgstr "nskat sprk"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -890,9 +946,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "nej"
-
 msgid "names only"
 msgstr "bara namn"
 
@@ -935,6 +988,10 @@ msgstr "Anv
 msgid "Setup.DVB$Update channels"
 msgstr "Uppdatera kanaler"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Placering av kanalinformation"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Antal ljudsprk"
 
@@ -959,6 +1016,9 @@ msgstr "Transparent f
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Transparent bakgrund textremsa"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1023,9 +1083,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "ja"
-
 msgid "Recording"
 msgstr "Inspelning"
 
@@ -1050,6 +1107,22 @@ msgstr "Prioritet f
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Livstid fr direktinspelning (dagar)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Kataloger fr inspelningar"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Kataloger fr inspelningar"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Prioritet fr direktinspelning"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maximal filstorlek fr inspelning (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Anvnd episodnamn"
 
@@ -1071,12 +1144,23 @@ msgstr "Direktinspelning l
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maximal filstorlek fr inspelning (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maximal filstorlek fr inspelning (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Mrk direktinspelning"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Dela upp redigerade filer"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Uppspelning"
 
@@ -1092,6 +1176,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "teruppta ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "teruppta ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "teruppta ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Multispeed mode"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "teruppta ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "teruppta ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "teruppta ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Kanal vid uppstart"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Ofrutsedd avslutning"
+
 msgid "Miscellaneous"
 msgstr "Diverse"
 
@@ -1119,6 +1235,18 @@ msgstr "som f
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Ljudstyrka vid uppstart"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Ofrutsedd avslutning"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Timeout kanal (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "som frut"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1128,6 +1256,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Ofrutsedd avslutning"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Ofrutsedd avslutning"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "som frut"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Minsta hndelse-pause (min)"
+
 msgid "Plugins"
 msgstr "Moduler"
 
@@ -1163,7 +1303,6 @@ msgstr "Stopp"
 msgid "Button$Resume"
 msgstr "Fortstt"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Avbryt redigering"
 
diff --git a/po/tr_TR.po b/po/tr_TR.po
index d38761a..3737812 100644
--- a/po/tr_TR.po
+++ b/po/tr_TR.po
@@ -560,6 +560,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Kanal ayarlar belli del!"
 
@@ -636,6 +640,15 @@ msgstr "
 msgid "Lifetime"
 msgstr "mr"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "evet"
+
+msgid "no"
+msgstr "hayr"
+
 msgid "File"
 msgstr "Ktk"
 
@@ -729,6 +742,36 @@ msgstr "G
 msgid "Button$Rewind"
 msgstr "Baslang"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Kayt sil?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Kayt sil?"
+
+msgid "Error while accessing recording!"
+msgstr "Kayt okuma hatas!"
+
 msgid "Recordings"
 msgstr "Kaytlar"
 
@@ -738,9 +781,6 @@ msgstr "A
 msgid "Commands"
 msgstr "Komutlar"
 
-msgid "Error while accessing recording!"
-msgstr "Kayt okuma hatas!"
-
 msgid "Delete recording?"
 msgstr "Kayt sil?"
 
@@ -774,6 +814,10 @@ msgstr "Y
 msgid "Setup.OSD$Theme"
 msgstr "Tema"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Kk font"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Sol (%)"
 
@@ -878,6 +922,18 @@ msgstr "Dil tercihleri"
 msgid "Setup.EPG$Preferred language"
 msgstr "Dil tercihi"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan"
 
@@ -887,9 +943,6 @@ msgstr "letterbox"
 msgid "center cut out"
 msgstr "center cut out"
 
-msgid "no"
-msgstr "hayr"
-
 msgid "names only"
 msgstr "srf isimler"
 
@@ -932,6 +985,10 @@ msgstr "Dolby Dijital ses kullan"
 msgid "Setup.DVB$Update channels"
 msgstr "Kanallar yenile"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Kanal bilgi pozisyonu"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Audio dilleri"
 
@@ -956,6 +1013,9 @@ msgstr "Altyaz
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Altyaz arka effaflk"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "LNB"
 
@@ -1020,9 +1080,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "evet"
-
 msgid "Recording"
 msgstr "Kayt"
 
@@ -1047,6 +1104,22 @@ msgstr "Duraklama prioritesi"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Duraklama mr (gn)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Kayt dizinleri"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Kayt dizinleri"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Duraklama prioritesi"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Maksimum Video ktk byklg (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Episod ismini kullan"
 
@@ -1068,12 +1141,23 @@ msgstr "Derhal 
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Maksimum Video ktk byklg (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Maksimum Video ktk byklg (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Derhal ekimi iaretle"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Dzenlenmi ktkleri ayr"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Tekrar"
 
@@ -1089,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "Gsteri ID'si"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "Gsteri ID'si"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "Gsteri ID'si"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Katl hz sarma"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "Gsteri ID'si"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "Gsteri ID'si"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "Gsteri ID'si"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Aldaki kanal"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Acil ck"
+
 msgid "Miscellaneous"
 msgstr "Dierler"
 
@@ -1116,6 +1232,18 @@ msgstr "
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Aldaki ses"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Acil ck"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Kanal giri zaman am (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "nceki gibi"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1125,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Acil ck"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Acil ck"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "nceki gibi"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Minimum olay zaman am (dak)"
+
 msgid "Plugins"
 msgstr "Eklentiler"
 
@@ -1160,7 +1300,6 @@ msgstr "Durdur"
 msgid "Button$Resume"
 msgstr "Srdr"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Kesimi iptal et"
 
diff --git a/po/uk_UA.po b/po/uk_UA.po
index 5ec4a0b..8667591 100644
--- a/po/uk_UA.po
+++ b/po/uk_UA.po
@@ -560,6 +560,10 @@ msgstr "CA (декодер)"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "Настройки каналу не єдині!"
 
@@ -636,6 +640,15 @@ msgstr "Пріоритет"
 msgid "Lifetime"
 msgstr "Строк зберігання"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "так"
+
+msgid "no"
+msgstr "ні"
+
 msgid "File"
 msgstr "Файл"
 
@@ -729,6 +742,36 @@ msgstr "Програвати"
 msgid "Button$Rewind"
 msgstr "Назад"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS поправка"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "Витерти запис?"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "Витерти запис?"
+
+msgid "Error while accessing recording!"
+msgstr "Помилка доступу до запису!"
+
 msgid "Recordings"
 msgstr "Записи"
 
@@ -738,9 +781,6 @@ msgstr "Відкрити"
 msgid "Commands"
 msgstr "Команди"
 
-msgid "Error while accessing recording!"
-msgstr "Помилка доступу до запису!"
-
 msgid "Delete recording?"
 msgstr "Витерти запис?"
 
@@ -774,6 +814,10 @@ msgstr "Стиль"
 msgid "Setup.OSD$Theme"
 msgstr "Тема"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "Малий фонт"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "Відступ зліва (%)"
 
@@ -878,6 +922,18 @@ msgstr "Бажані мови (телегід)"
 msgid "Setup.EPG$Preferred language"
 msgstr "Бажана мова (телегід)"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "панорамувати"
 
@@ -887,9 +943,6 @@ msgstr "зменшувати"
 msgid "center cut out"
 msgstr "обрізати по боках"
 
-msgid "no"
-msgstr "ні"
-
 msgid "names only"
 msgstr "тільки назви"
 
@@ -932,6 +985,10 @@ msgstr "Викор. Dolby Digital"
 msgid "Setup.DVB$Update channels"
 msgstr "Оновлювати канали"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "Положення інформації про канал"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "Бажані мови (звук)"
 
@@ -956,6 +1013,9 @@ msgstr "Прозорість переднього плану субтитрів"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "Прозорість заднього плану субтитрів"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "Конвертер"
 
@@ -1020,9 +1080,6 @@ msgstr "призупинити перегляд"
 msgid "confirm"
 msgstr "підтвердити"
 
-msgid "yes"
-msgstr "так"
-
 msgid "Recording"
 msgstr "Запис"
 
@@ -1047,6 +1104,22 @@ msgstr "Пріоритет відкладеного перегляду"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "Зберігання відкладеного перегляду (дні)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "Каталоги зберігання записів"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "Каталоги зберігання записів"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "Пріоритет відкладеного перегляду"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "Макс. размір відеофайлу (Мб)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "Викор. назву епізоду"
 
@@ -1068,12 +1141,23 @@ msgstr "Протяжність ручного запису (хв)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "Макс. размір відеофайлу (Мб)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "Макс. размір відеофайлу (Мб)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "Помітити зроблені вручну записи"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "Поділити відредаговані файли"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr "Видалити записи з зсувом по часу"
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "Перегляд"
 
@@ -1089,6 +1173,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "ID продовження"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "ID продовження"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "ID продовження"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "Багатошвидкісний режим"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "ID продовження"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "ID продовження"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "ID продовження"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "Канал при включенні"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "Аварійний вихід"
+
 msgid "Miscellaneous"
 msgstr "Різне"
 
@@ -1116,6 +1232,18 @@ msgstr "як раніше"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "Гучність при включенні"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "Аварійний вихід"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "Кінець каналів"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "як раніше"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr "Кінець каналів"
 
@@ -1125,6 +1253,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "Аварійний вихід"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "Аварійний вихід"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "як раніше"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Мін. час очікування події (хв)"
+
 msgid "Plugins"
 msgstr "Модулі розширення"
 
@@ -1160,7 +1300,6 @@ msgstr "Стоп"
 msgid "Button$Resume"
 msgstr "Продовжити"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr " Перервати монтаж"
 
diff --git a/po/zh_CN.po b/po/zh_CN.po
index 0c1e18b..462ed03 100644
--- a/po/zh_CN.po
+++ b/po/zh_CN.po
@@ -563,6 +563,10 @@ msgstr "CA"
 msgid "Sid"
 msgstr "Sid"
 
+#, fuzzy
+msgid "Rid"
+msgstr "Sid"
+
 msgid "Channel settings are not unique!"
 msgstr "频道设置不是唯一的！"
 
@@ -639,6 +643,15 @@ msgstr "优先"
 msgid "Lifetime"
 msgstr "终生"
 
+msgid "Childlock"
+msgstr ""
+
+msgid "yes"
+msgstr "是"
+
+msgid "no"
+msgstr "不"
+
 msgid "File"
 msgstr "文件"
 
@@ -732,6 +745,36 @@ msgstr "播放"
 msgid "Button$Rewind"
 msgstr "重放"
 
+msgid "Date"
+msgstr ""
+
+msgid "Length"
+msgstr ""
+
+msgid "Format"
+msgstr ""
+
+#, fuzzy
+msgid "PES"
+msgstr "VPS"
+
+msgid "TS"
+msgstr ""
+
+msgid "Size"
+msgstr ""
+
+#, fuzzy
+msgid "Delete marks information?"
+msgstr "是否删除录像？"
+
+#, fuzzy
+msgid "Delete resume information?"
+msgstr "是否删除录像？"
+
+msgid "Error while accessing recording!"
+msgstr "存取录像错误！"
+
 msgid "Recordings"
 msgstr "录像回放列表"
 
@@ -741,9 +784,6 @@ msgstr "打开"
 msgid "Commands"
 msgstr "常用操作命令"
 
-msgid "Error while accessing recording!"
-msgstr "存取录像错误！"
-
 msgid "Delete recording?"
 msgstr "是否删除录像？"
 
@@ -777,6 +817,10 @@ msgstr "皮肤选择"
 msgid "Setup.OSD$Theme"
 msgstr "主题选择"
 
+#, fuzzy
+msgid "Setup.OSD$WarEagle icons"
+msgstr "小字体选择"
+
 msgid "Setup.OSD$Left (%)"
 msgstr "左边距离设置 (%)"
 
@@ -881,6 +925,18 @@ msgstr "首选语种 "
 msgid "Setup.EPG$Preferred language"
 msgstr "首选语言"
 
+msgid "Setup.EPG$Period for double EPG search(min)"
+msgstr ""
+
+msgid "Setup.EPG$extern double Epg entry"
+msgstr ""
+
+msgid "Setup.EPG$Mix intern and extern EPG"
+msgstr ""
+
+msgid "Setup.EPG$Disable running VPS event"
+msgstr ""
+
 msgid "pan&scan"
 msgstr "pan&scan模式"
 
@@ -890,9 +946,6 @@ msgstr "letterbox模式"
 msgid "center cut out"
 msgstr "Center-cut-out模式"
 
-msgid "no"
-msgstr "不"
-
 msgid "names only"
 msgstr "仅是名字"
 
@@ -935,6 +988,10 @@ msgstr "杜比-数码-使用"
 msgid "Setup.DVB$Update channels"
 msgstr "更新频道"
 
+#, fuzzy
+msgid "Setup.DVB$channel binding by Rid"
+msgstr "频道信息位置"
+
 msgid "Setup.DVB$Audio languages"
 msgstr "声道语言"
 
@@ -959,6 +1016,9 @@ msgstr "字幕前景透明度"
 msgid "Setup.DVB$Subtitle background transparency"
 msgstr "字幕背景透明度"
 
+msgid "Setup.DVB$Enable teletext support"
+msgstr ""
+
 msgid "LNB"
 msgstr "切换器设置"
 
@@ -1023,9 +1083,6 @@ msgstr ""
 msgid "confirm"
 msgstr ""
 
-msgid "yes"
-msgstr "是"
-
 msgid "Recording"
 msgstr "录像设置"
 
@@ -1050,6 +1107,22 @@ msgstr "暂停优先"
 msgid "Setup.Recording$Pause lifetime (d)"
 msgstr "暂停终身 (d)"
 
+#, fuzzy
+msgid "Setup.Recording$Video directory policy"
+msgstr "录像目录"
+
+#, fuzzy
+msgid "Setup.Recording$Number of video directories"
+msgstr "录像目录"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d priority"
+msgstr "暂停优先"
+
+#, fuzzy, c-format
+msgid "Setup.Recording$Video %d min. free MB"
+msgstr "最大的视频文件容量 (MB)"
+
 msgid "Setup.Recording$Use episode name"
 msgstr "插入使用名字"
 
@@ -1071,12 +1144,23 @@ msgstr "直接录像时间(min)"
 msgid "Setup.Recording$Max. video file size (MB)"
 msgstr "最大的视频文件容量 (MB)"
 
+#, fuzzy
+msgid "Setup.Recording$Max. recording size (GB)"
+msgstr "最大的视频文件容量 (MB)"
+
+#, fuzzy
+msgid "Setup.Recording$Hard Link Cutter"
+msgstr "标记直接记录"
+
 msgid "Setup.Recording$Split edited files"
 msgstr "分离编辑文件"
 
 msgid "Setup.Recording$Delete timeshift recording"
 msgstr ""
 
+msgid "Setup.Recording$Dump NALU Fill data"
+msgstr ""
+
 msgid "Replay"
 msgstr "回放设置"
 
@@ -1092,6 +1176,38 @@ msgstr ""
 msgid "Setup.Replay$Resume ID"
 msgstr "恢复 ID"
 
+#, fuzzy
+msgid "Setup.Replay$Jump&Play"
+msgstr "恢复 ID"
+
+#, fuzzy
+msgid "Setup.Replay$Play&Jump"
+msgstr "恢复 ID"
+
+#, fuzzy
+msgid "Setup.Replay$Pause at last mark"
+msgstr "媒体速度模式"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds"
+msgstr "恢复 ID"
+
+#, fuzzy
+msgid "Setup.Replay$Jump Seconds Slow"
+msgstr "恢复 ID"
+
+#, fuzzy
+msgid "Setup.Recording$Jump Seconds (Repeat)"
+msgstr "恢复 ID"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in channelinfo"
+msgstr "初始频道"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$only in progress display"
+msgstr "突发事件退出"
+
 msgid "Miscellaneous"
 msgstr "其它设置"
 
@@ -1119,6 +1235,18 @@ msgstr "之前"
 msgid "Setup.Miscellaneous$Initial volume"
 msgstr "初始化声音"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Volume ctrl with left/right"
+msgstr "突发事件退出"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Channelgroups with left/right"
+msgstr "频道进入超时 (ms)"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Search fwd/back with left/right"
+msgstr "之前"
+
 msgid "Setup.Miscellaneous$Channels wrap"
 msgstr ""
 
@@ -1128,6 +1256,18 @@ msgstr ""
 msgid "Setup.Miscellaneous$Emergency exit"
 msgstr "突发事件退出"
 
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat delay"
+msgstr "突发事件退出"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat freq"
+msgstr "之前"
+
+#, fuzzy
+msgid "Setup.Miscellaneous$Lirc repeat timeout"
+msgstr "Min. 结果超时 (min)"
+
 msgid "Plugins"
 msgstr "插件设置"
 
@@ -1163,7 +1303,6 @@ msgstr "停止"
 msgid "Button$Resume"
 msgstr "重置"
 
-#. TRANSLATORS: note the leading blank!
 msgid " Cancel editing"
 msgstr "取消编辑"
 
diff --git a/receiver.c b/receiver.c
index bde60e4..ba6cc0d 100644
--- a/receiver.c
+++ b/receiver.c
@@ -67,7 +67,12 @@ bool cReceiver::SetPids(const cChannel *Channel)
             (Channel->Ppid() == Channel->Vpid() || AddPid(Channel->Ppid())) &&
             AddPids(Channel->Apids()) &&
             AddPids(Channel->Dpids()) &&
+#ifdef USE_TTXTSUBS
+            AddPids(Channel->Spids()) &&
+            (!Setup.SupportTeletext || AddPid(Channel->Tpid()));
+#else
             AddPids(Channel->Spids());
+#endif // USE_TTXTSUBS
      }
   return true;
 }
diff --git a/recorder.c b/recorder.c
index a6cab47..ee735a3 100644
--- a/recorder.c
+++ b/recorder.c
@@ -45,6 +45,16 @@ cRecorder::cRecorder(const char *FileName, const cChannel *Channel, int Priority
      Type = 0x06;
      }
   frameDetector = new cFrameDetector(Pid, Type);
+#ifdef USE_NALUDUMP
+  if (   Type == 0x1B // MPEG4 video
+      && (Setup.DumpNaluFill ? (strstr(FileName, "NALUKEEP") == NULL) : (strstr(FileName, "NALUDUMP") != NULL))) { // MPEG4
+     isyslog("Starting NALU fill dumper");
+     naluStreamProcessor = new cNaluStreamProcessor();
+     naluStreamProcessor->SetPid(Pid);
+     }
+  else
+     naluStreamProcessor = NULL;
+#endif // USE_NALUDUMP
   index = NULL;
   fileSize = 0;
   lastDiskSpaceCheck = time(NULL);
@@ -66,6 +76,14 @@ cRecorder::cRecorder(const char *FileName, const cChannel *Channel, int Priority
 cRecorder::~cRecorder()
 {
   Detach();
+#ifdef USE_NALUDUMP
+  if (naluStreamProcessor) {
+     long long int TotalPackets = naluStreamProcessor->GetTotalPackets();
+     long long int DroppedPackets = naluStreamProcessor->GetDroppedPackets();
+     isyslog("NALU fill dumper: %lld of %lld packets dropped, %lli%%", DroppedPackets, TotalPackets, TotalPackets ? DroppedPackets*100/TotalPackets : 0);
+     delete naluStreamProcessor;
+     }
+#endif // USE_NALUDUMP
   delete index;
   delete fileName;
   delete frameDetector;
@@ -89,7 +107,11 @@ bool cRecorder::RunningLowOnDiskSpace(void)
 bool cRecorder::NextFile(void)
 {
   if (recordFile && frameDetector->IndependentFrame()) { // every file shall start with an independent frame
+#ifdef USE_HARDLINKCUTTER
+     if (fileSize > fileName->MaxFileSize() || RunningLowOnDiskSpace()) {
+#else
      if (fileSize > MEGABYTE(off_t(Setup.MaxVideoFileSize)) || RunningLowOnDiskSpace()) {
+#endif /* HARDLINKCUTTER */
         recordFile = fileName->NextFile();
         fileSize = 0;
         }
@@ -154,11 +176,38 @@ void cRecorder::Action(void)
                              fileSize += TS_SIZE;
                              }
                        }
+#ifndef USE_NALUDUMP
+                    if (recordFile->Write(b, Count) < 0) {
+                       LOG_ERROR_STR(fileName->Name());
+                       break;
+                    fileSize += Count;
+#else
+                    if (naluStreamProcessor) {
+                       naluStreamProcessor->PutBuffer(b, Count);
+                       bool Fail = false;
+                       while (true) {
+                             int OutLength = 0;
+                             uchar *OutData = naluStreamProcessor->GetBuffer(OutLength);
+                             if (!OutData || OutLength <= 0)
+                                break;
+                             if (recordFile->Write(OutData, OutLength) < 0) {
+                                LOG_ERROR_STR(fileName->Name());
+                                Fail = true;
+                                break;
+                                }
+                             fileSize += OutLength;
+                             }
+                       if (Fail)
+                          break;
+                       }
+                    else {
                     if (recordFile->Write(b, Count) < 0) {
                        LOG_ERROR_STR(fileName->Name());
                        break;
                        }
                     fileSize += Count;
+#endif // USE_NALUDUMP
+                       }
                     t = time(NULL);
                     }
                  }
diff --git a/recorder.h b/recorder.h
index 05cc42b..18e0461 100644
--- a/recorder.h
+++ b/recorder.h
@@ -21,6 +21,9 @@ private:
   cRingBufferLinear *ringBuffer;
   cFrameDetector *frameDetector;
   cPatPmtGenerator patPmtGenerator;
+#ifdef USE_NALUDUMP
+  cNaluStreamProcessor *naluStreamProcessor;
+#endif // USE_NALUDUMP
   cFileName *fileName;
   cIndexFile *index;
   cUnbufferedFile *recordFile;
diff --git a/recording.c b/recording.c
index d13225b..bb75b75 100644
--- a/recording.c
+++ b/recording.c
@@ -8,6 +8,9 @@
  */
 
 #include "recording.h"
+#ifdef USE_WAREAGLEICON
+#include "iconpatch.h"
+#endif /* WAREAGLEICON */
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -874,7 +877,11 @@ const char *cRecording::FileName(void) const
 
 const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level) const
 {
+#ifdef USE_WAREAGLEICON
+  const char *New = NewIndicator && IsNew() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_NEW_UTF8 : ICON_NEW : "*" : " ";
+#else
   char New = NewIndicator && IsNew() ? '*' : ' ';
+#endif /* WAREAGLEICON */
   free(titleBuffer);
   titleBuffer = NULL;
   if (Level < 0 || Level == HierarchyLevels()) {
@@ -894,7 +901,11 @@ const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level) cons
                    Minutes % 60
                    );
         }
+#ifdef USE_WAREAGLEICON
+     titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%s%s%c%s",
+#else
      titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%s%c%c%s",
+#endif /* WAREAGLEICON */
                             t->tm_mday,
                             t->tm_mon + 1,
                             t->tm_year % 100,
@@ -944,6 +955,18 @@ const char *cRecording::PrefixFileName(char Prefix)
   return NULL;
 }
 
+#ifdef USE_LIEMIKUUTIO
+const char *cRecording::UpdateFileName(const char *FileName)
+{
+	if (FileName && *FileName) {
+		free(fileName);
+		fileName = strdup(FileName);
+		return fileName;
+	}
+	return NULL;
+}
+#endif /* LIEMIKUUTIO */
+
 int cRecording::HierarchyLevels(void) const
 {
   const char *s = name;
@@ -1234,7 +1257,11 @@ void cRecordings::AddByName(const char *FileName, bool TriggerUpdate)
      }
 }
 
+#ifdef USE_LIEMIKUUTIO
+void cRecordings::DelByName(const char *FileName, bool RemoveRecording)
+#else
 void cRecordings::DelByName(const char *FileName)
+#endif /* LIEMIKUUTIO */
 {
   LOCK_THREAD;
   cRecording *recording = GetByName(FileName);
@@ -1242,7 +1269,11 @@ void cRecordings::DelByName(const char *FileName)
      cThreadLock DeletedRecordingsLock(&DeletedRecordings);
      Del(recording, false);
      char *ext = strrchr(recording->fileName, '.');
+#ifdef USE_LIEMIKUUTIO
+	 if (ext && RemoveRecording) {
+#else
      if (ext) {
+#endif /* LIEMIKUUTIO */
         strncpy(ext, DELEXT, strlen(ext));
         if (access(recording->FileName(), F_OK) == 0) {
            recording->deleted = time(NULL);
@@ -2087,6 +2118,22 @@ cUnbufferedFile *cFileName::SetOffset(int Number, off_t Offset)
   return NULL;
 }
 
+#ifdef USE_HARDLINKCUTTER
+off_t cFileName::MaxFileSize() {
+  const int maxVideoFileSize = isPesRecording ? MAXVIDEOFILESIZEPES : MAXVIDEOFILESIZETS;
+  const int setupMaxVideoFileSize = min(maxVideoFileSize, Setup.MaxVideoFileSize);
+  const int maxFileNumber = isPesRecording ? 255 : 65535;
+
+  const off_t smallFiles = (maxFileNumber * off_t(maxVideoFileSize) - 1024 * Setup.MaxRecordingSize)
+                           / max(maxVideoFileSize - setupMaxVideoFileSize, 1);
+
+  if (fileNumber <= smallFiles)
+     return MEGABYTE(off_t(setupMaxVideoFileSize));
+
+  return MEGABYTE(off_t(maxVideoFileSize));
+}
+#endif /* HARDLINKCUTTER */
+
 cUnbufferedFile *cFileName::NextFile(void)
 {
   return SetOffset(fileNumber + 1);
diff --git a/recording.h b/recording.h
index 8e71230..78e663b 100644
--- a/recording.h
+++ b/recording.h
@@ -68,6 +68,9 @@ public:
   const cEvent *GetEvent(void) const { return event; }
   const char *Title(void) const { return event->Title(); }
   const char *ShortText(void) const { return event->ShortText(); }
+#ifdef USE_GRAPHTFT
+  tEventID EventID(void) const { return event->EventID(); }
+#endif /* GRAPHTFT */
   const char *Description(void) const { return event->Description(); }
   const cComponents *Components(void) const { return event->Components(); }
   const char *Aux(void) const { return aux; }
@@ -118,6 +121,9 @@ public:
   const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1) const;
   const cRecordingInfo *Info(void) const { return info; }
   const char *PrefixFileName(char Prefix);
+#ifdef USE_LIEMIKUUTIO
+  const char *UpdateFileName(const char *FileName);
+#endif /* LIEMIKUUTIO */
   int HierarchyLevels(void) const;
   void ResetResume(void) const;
   double FramesPerSecond(void) const { return framesPerSecond; }
@@ -189,7 +195,11 @@ public:
   void ResetResume(const char *ResumeFileName = NULL);
   cRecording *GetByName(const char *FileName);
   void AddByName(const char *FileName, bool TriggerUpdate = true);
+#ifdef USE_LIEMIKUUTIO
+  void DelByName(const char *FileName, bool RemoveRecording = true);
+#else
   void DelByName(const char *FileName);
+#endif /* LIEMIKUUTIO */
   void UpdateByName(const char *FileName);
   int TotalFileSizeMB(void);
   double MBperMinute(void);
@@ -259,9 +269,23 @@ public:
 // before the next independent frame, to have a complete Group Of Pictures):
 #define MAXVIDEOFILESIZETS  1048570 // MB
 #define MAXVIDEOFILESIZEPES    2000 // MB
+#ifdef USE_HARDLINKCUTTER
+#define MINVIDEOFILESIZE          1 // MB
+#else
 #define MINVIDEOFILESIZE        100 // MB
+#endif /* HARDLINKCUTTER */
 #define MAXVIDEOFILESIZEDEFAULT MAXVIDEOFILESIZEPES
 
+#ifdef USE_HARDLINKCUTTER
+#define MINRECORDINGSIZE      25 // GB
+#define MAXRECORDINGSIZE     500 // GB
+#define DEFAULTRECORDINGSIZE 100 // GB
+// Dynamic recording size:
+// Keep recording file size at Setup.MaxVideoFileSize for as long as possible,
+// but switch to MAXVIDEOFILESIZE early enough, so that Setup.MaxRecordingSize
+// will be reached, before recording to file 65535.vdr
+#endif /* HARDLINKCUTTER */
+
 struct tIndexTs;
 class cIndexFileGenerator;
 
@@ -314,6 +338,10 @@ public:
   cUnbufferedFile *Open(void);
   void Close(void);
   cUnbufferedFile *SetOffset(int Number, off_t Offset = 0); // yes, Number is int for easier internal calculating
+#ifdef USE_HARDLINKCUTTER
+  off_t MaxFileSize();
+      // Dynamic file size for this file
+#endif /* HARDLINKCUTTER */
   cUnbufferedFile *NextFile(void);
   };
 
diff --git a/remux.c b/remux.c
index bd06e7c..68f8039 100644
--- a/remux.c
+++ b/remux.c
@@ -146,6 +146,44 @@ void TsSetTeiOnBrokenPackets(uchar *p, int l)
         }
 }
 
+#ifdef USE_NALUDUMP
+void TsExtendAdaptionField(unsigned char *Packet, int ToLength)
+{
+    // Hint: ExtenAdaptionField(p, TsPayloadOffset(p) - 4) is a null operation
+
+    int Offset = TsPayloadOffset(Packet); // First byte after existing adaption field
+
+    if (ToLength <= 0)
+    {
+        // Remove adaption field
+        Packet[3] = Packet[3] & ~TS_ADAPT_FIELD_EXISTS;
+        return;
+    }
+
+    // Set adaption field present
+    Packet[3] = Packet[3] | TS_ADAPT_FIELD_EXISTS;
+
+    // Set new length of adaption field:
+    Packet[4] = ToLength <= TS_SIZE-4 ? ToLength-1 : TS_SIZE-4-1;
+
+    if (Packet[4] == TS_SIZE-4-1)
+    {
+        // No more payload, remove payload flag
+        Packet[3] = Packet[3] & ~TS_PAYLOAD_EXISTS;
+    }
+
+    int NewPayload = TsPayloadOffset(Packet); // First byte after new adaption field
+
+    // Fill new adaption field
+    if (Offset == 4 && Offset < NewPayload)
+        Offset++; // skip adaptation_field_length
+    if (Offset == 5 && Offset < NewPayload)
+        Packet[Offset++] = 0; // various flags set to 0
+    while (Offset < NewPayload)
+        Packet[Offset++] = 0xff; // stuffing byte
+}
+
+#endif // USE_NALUDUMP
 // --- cPatPmtGenerator ------------------------------------------------------
 
 cPatPmtGenerator::cPatPmtGenerator(const cChannel *Channel)
@@ -219,6 +257,31 @@ int cPatPmtGenerator::MakeSubtitlingDescriptor(uchar *Target, const char *Langua
   return i;
 }
 
+#ifdef USE_TTXTSUBS
+int cPatPmtGenerator::MakeTeletextDescriptor(uchar *Target, const tTeletextSubtitlePage *pages, int pageCount)
+{
+  int i = 0, j = 0;
+  Target[i++] = SI::TeletextDescriptorTag;
+  int l = i;
+  Target[i++] = 0x00; // length
+  for (int n = 0; n < pageCount; n++) {
+      const char* Language = pages[n].ttxtLanguage;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = (pages[n].ttxtType << 3) + pages[n].ttxtMagazine;
+      Target[i++] = pages[n].ttxtPage;
+      j++;
+      }
+  if (j > 0) {
+     Target[l] = j * 5; // update length
+     IncEsInfoLength(i);
+     return i;
+     }
+  return 0;
+}
+#endif // USE_TTXTSUBS
+
 int cPatPmtGenerator::MakeLanguageDescriptor(uchar *Target, const char *Language)
 {
   int i = 0;
@@ -306,6 +369,9 @@ void cPatPmtGenerator::GeneratePmt(const cChannel *Channel)
   if (Channel) {
      int Vpid = Channel->Vpid();
      int Ppid = Channel->Ppid();
+#ifdef USE_TTXTSUBS
+     int Tpid = Channel->Tpid();
+#endif // USE_TTXTSUBS
      uchar *p = buf;
      int i = 0;
      p[i++] = 0x02; // table id
@@ -338,6 +404,12 @@ void cPatPmtGenerator::GeneratePmt(const cChannel *Channel)
          i += MakeStream(buf + i, 0x06, Channel->Spid(n));
          i += MakeSubtitlingDescriptor(buf + i, Channel->Slang(n), Channel->SubtitlingType(n), Channel->CompositionPageId(n), Channel->AncillaryPageId(n));
          }
+#ifdef USE_TTXTSUBS
+     if (Tpid) {
+        i += MakeStream(buf + i, 0x06, Tpid);
+        i += MakeTeletextDescriptor(buf + i, Channel->TeletextSubtitlePages(), Channel->TotalTeletextSubtitlePages());
+        }
+#endif // USE_TTXTSUBS
 
      int sl = i - SectionLength - 2 + 4; // -2 = SectionLength storage, +4 = length of CRC
      buf[SectionLength] |= (sl >> 8) & 0x0F;
@@ -411,6 +483,9 @@ void cPatPmtParser::Reset(void)
   pmtPid = -1;
   vpid = vtype = 0;
   ppid = 0;
+#ifdef USE_TTXTSUBS
+  tpid = 0;
+#endif // USE_TTXTSUBS
 }
 
 void cPatPmtParser::ParsePat(const uchar *Data, int Length)
@@ -496,11 +571,17 @@ void cPatPmtParser::ParsePmt(const uchar *Data, int Length)
      int NumSpids = 0;
      vpid = vtype = 0;
      ppid = 0;
+#ifdef USE_TTXTSUBS
+     tpid = 0;
+#endif // USE_TTXTSUBS
      apids[0] = 0;
      dpids[0] = 0;
      spids[0] = 0;
      atypes[0] = 0;
      dtypes[0] = 0;
+#ifdef USE_TTXTSUBS
+     totalTtxtSubtitlePages = 0;
+#endif // USE_TTXTSUBS
      SI::PMT::Stream stream;
      for (SI::Loop::Iterator it; Pmt.streamLoop.getNext(stream, it); ) {
          dbgpatpmt("     stream type = %02X, pid = %d", stream.getStreamType(), stream.getPid());
@@ -599,6 +680,30 @@ void cPatPmtParser::ParsePmt(const uchar *Data, int Length)
                                     spids[NumSpids]= 0;
                                     }
                                  break;
+#ifdef USE_TTXTSUBS
+                            case SI::TeletextDescriptorTag: {
+                                 dbgpatpmt(" teletext");
+                                 tpid = stream.getPid();
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 if (totalTtxtSubtitlePages < MAXTXTPAGES) {
+                                    for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                        bool isSubtitlePage = (ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05);
+                                        if (isSubtitlePage && ttxt.languageCode[0]) {
+                                           dbgpatpmt(" '%s:%x.%x'", ttxt.languageCode, ttxt.getTeletextMagazineNumber(), ttxt.getTeletextPageNumber());
+                                           strn0cpy(teletextSubtitlePages[totalTtxtSubtitlePages].ttxtLanguage, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtPage = ttxt.getTeletextPageNumber();
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtMagazine = ttxt.getTeletextMagazineNumber();
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtType = ttxt.getTeletextType();
+                                           totalTtxtSubtitlePages++;
+                                           if (totalTtxtSubtitlePages >= MAXTXTPAGES)
+                                              break;
+                                           }
+                                        }
+                                    }
+                                 }
+                                 break;
+#endif // USE_TTXTSUBS
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
                                  dbgpatpmt(" '%s'", ld->languageCode);
@@ -1033,3 +1138,346 @@ int cFrameDetector::Analyze(const uchar *Data, int Length)
         }
   return Processed;
 }
+#ifdef USE_NALUDUMP
+
+// --- cNaluDumper ---------------------------------------------------------
+
+cNaluDumper::cNaluDumper()
+{
+    LastContinuityOutput = -1;
+    reset();
+}
+
+void cNaluDumper::reset()
+{
+    LastContinuityInput = -1;
+    ContinuityOffset = 0;
+    PesId = -1;
+    PesOffset = 0;
+    NaluFillState = NALU_NONE;
+    NaluOffset = 0;
+    History = 0xffffffff;
+    DropAllPayload = false;
+}
+
+void cNaluDumper::ProcessPayload(unsigned char *Payload, int size, bool PayloadStart, sPayloadInfo &Info)
+{
+    Info.DropPayloadStartBytes = 0;
+    Info.DropPayloadEndBytes = 0;
+    int LastKeepByte = -1;
+
+    if (PayloadStart)
+    {
+        History = 0xffffffff;
+        PesId = -1;
+        NaluFillState = NALU_NONE;
+    }
+
+    for (int i=0; i<size; i++) {
+        History = (History << 8) | Payload[i];
+
+        PesOffset++;
+        NaluOffset++;
+
+        bool DropByte = false;
+
+        if (History >= 0x00000180 && History <= 0x000001FF)
+        {
+            // Start of PES packet
+            PesId = History & 0xff;
+            PesOffset = 0;
+            NaluFillState = NALU_NONE;
+        }
+        else if (PesId >= 0xe0 && PesId <= 0xef // video stream
+                 && History >= 0x00000100 && History <= 0x0000017F) // NALU start code
+        {
+            int NaluId = History & 0xff;
+            NaluOffset = 0;
+            NaluFillState = ((NaluId & 0x1f) == 0x0c) ? NALU_FILL : NALU_NONE;
+        }
+
+        if (PesId >= 0xe0 && PesId <= 0xef // video stream
+            && PesOffset >= 1 && PesOffset <= 2)
+        {
+            Payload[i] = 0; // Zero out PES length field
+        }
+
+        if (NaluFillState == NALU_FILL && NaluOffset > 0) // Within NALU fill data
+        {
+            // We expect a series of 0xff bytes terminated by a single 0x80 byte.
+
+            if (Payload[i] == 0xFF)
+            {
+                DropByte = true;
+            }
+            else if (Payload[i] == 0x80)
+            {
+                NaluFillState = NALU_TERM; // Last byte of NALU fill, next byte sets NaluFillEnd=true
+                DropByte = true;
+            }
+            else // Invalid NALU fill
+            {
+                dsyslog("cNaluDumper: Unexpected NALU fill data: %02x", Payload[i]);
+                NaluFillState = NALU_END;
+                if (LastKeepByte == -1)
+                {
+                    // Nalu fill from beginning of packet until last byte
+                    // packet start needs to be dropped
+                    Info.DropPayloadStartBytes = i;
+                }
+            }
+        }
+        else if (NaluFillState == NALU_TERM) // Within NALU fill data
+        {
+            // We are after the terminating 0x80 byte
+            NaluFillState = NALU_END;
+            if (LastKeepByte == -1)
+            {
+                // Nalu fill from beginning of packet until last byte
+                // packet start needs to be dropped
+                Info.DropPayloadStartBytes = i;
+            }
+        }
+
+        if (!DropByte)
+            LastKeepByte = i; // Last useful byte
+    }
+
+    Info.DropAllPayloadBytes = (LastKeepByte == -1);
+    Info.DropPayloadEndBytes = size-1-LastKeepByte;
+}
+
+bool cNaluDumper::ProcessTSPacket(unsigned char *Packet)
+{
+    bool HasAdaption = TsHasAdaptationField(Packet);
+    bool HasPayload = TsHasPayload(Packet);
+
+    // Check continuity:
+    int ContinuityInput = TsContinuityCounter(Packet);
+    if (LastContinuityInput >= 0)
+    {
+        int NewContinuityInput = HasPayload ? (LastContinuityInput + 1) & TS_CONT_CNT_MASK : LastContinuityInput;
+        int Offset = (NewContinuityInput - ContinuityInput) & TS_CONT_CNT_MASK;
+        if (Offset > 0)
+            dsyslog("cNaluDumper: TS continuity offset %i", Offset);
+        if (Offset > ContinuityOffset)
+            ContinuityOffset = Offset; // max if packets get dropped, otherwise always the current one.
+    }
+    LastContinuityInput = ContinuityInput;
+
+    if (HasPayload) {
+        sPayloadInfo Info;
+        int Offset = TsPayloadOffset(Packet);
+        ProcessPayload(Packet + Offset, TS_SIZE - Offset, TsPayloadStart(Packet), Info);
+
+        if (DropAllPayload && !Info.DropAllPayloadBytes)
+        {
+            // Return from drop packet mode to normal mode
+            DropAllPayload = false;
+
+            // Does the packet start with some remaining NALU fill data?
+            if (Info.DropPayloadStartBytes > 0)
+            {
+                // Add these bytes as stuffing to the adaption field.
+
+                // Sample payload layout:
+                // FF FF FF FF FF 80 00 00 01 xx xx xx xx
+                //                   ^DropPayloadStartBytes
+
+                TsExtendAdaptionField(Packet, Offset - 4 + Info.DropPayloadStartBytes);
+            }
+        }
+
+        bool DropThisPayload = DropAllPayload;
+
+        if (!DropAllPayload && Info.DropPayloadEndBytes > 0) // Payload ends with 0xff NALU Fill
+        {
+            // Last packet of useful data
+            // Do early termination of NALU fill data
+            Packet[TS_SIZE-1] = 0x80;
+            DropAllPayload = true;
+            // Drop all packets AFTER this one
+
+            // Since we already wrote the 0x80, we have to make sure that
+            // as soon as we stop dropping packets, any beginning NALU fill of next
+            // packet gets dumped. (see DropPayloadStartBytes above)
+        }
+
+        if (DropThisPayload && HasAdaption)
+        {
+            // Drop payload data, but keep adaption field data
+            TsExtendAdaptionField(Packet, TS_SIZE-4);
+            DropThisPayload = false;
+        }
+
+        if (DropThisPayload)
+        {
+            return true; // Drop packet
+        }
+    }
+
+    // Fix Continuity Counter and reproduce incoming offsets:
+    int NewContinuityOutput = TsHasPayload(Packet) ? (LastContinuityOutput + 1) & TS_CONT_CNT_MASK : LastContinuityOutput;
+    NewContinuityOutput = (NewContinuityOutput + ContinuityOffset) & TS_CONT_CNT_MASK;
+    TsSetContinuityCounter(Packet, NewContinuityOutput);
+    LastContinuityOutput = NewContinuityOutput;
+    ContinuityOffset = 0;
+
+    return false; // Keep packet
+}
+
+// --- cNaluStreamProcessor ---------------------------------------------------------
+
+cNaluStreamProcessor::cNaluStreamProcessor()
+{
+    pPatPmtParser = NULL;
+    vpid = -1;
+    data = NULL;
+    length = 0;
+    tempLength = 0;
+    tempLengthAtEnd = false;
+    TotalPackets = 0;
+    DroppedPackets = 0;
+}
+
+void cNaluStreamProcessor::PutBuffer(uchar *Data, int Length)
+{
+    if (length > 0)
+        esyslog("cNaluStreamProcessor::PutBuffer: New data before old data was processed!");
+
+    data = Data;
+    length = Length;
+}
+
+uchar* cNaluStreamProcessor::GetBuffer(int &OutLength)
+{
+    if (length <= 0)
+    {
+        // Need more data - quick exit
+        OutLength = 0;
+        return NULL;
+    }
+    if (tempLength > 0) // Data in temp buffer?
+    {
+        if (tempLengthAtEnd) // Data is at end, copy to beginning
+        {
+            // Overlapping src and dst!
+            for (int i=0; i<tempLength; i++)
+                tempBuffer[i] = tempBuffer[TS_SIZE-tempLength+i];
+        }
+        // Normalize TempBuffer fill
+        if (tempLength < TS_SIZE && length > 0)
+        {
+            int Size = min(TS_SIZE-tempLength, length);
+            memcpy(tempBuffer+tempLength, data, Size);
+            data += Size;
+            length -= Size;
+            tempLength += Size;
+        }
+        if (tempLength < TS_SIZE)
+        {
+            // All incoming data buffered, but need more data
+            tempLengthAtEnd = false;
+            OutLength = 0;
+            return NULL;
+        }
+        // Now: TempLength==TS_SIZE
+        if (tempBuffer[0] != TS_SYNC_BYTE)
+        {
+            // Need to sync on TS within temp buffer
+            int Skipped = 1;
+            while (Skipped < TS_SIZE && (tempBuffer[Skipped] != TS_SYNC_BYTE || (Skipped < length && data[Skipped] != TS_SYNC_BYTE)))
+                Skipped++;
+            esyslog("ERROR: skipped %d bytes to sync on start of TS packet", Skipped);
+            // Pass through skipped bytes
+            tempLengthAtEnd = true;
+            tempLength = TS_SIZE - Skipped; // may be 0, thats ok
+            OutLength = Skipped;
+            return tempBuffer;
+        }
+        // Now: TempBuffer is a TS packet
+        int Pid = TsPid(tempBuffer);
+        if (pPatPmtParser)
+        {
+            if (Pid == 0)
+                pPatPmtParser->ParsePat(tempBuffer, TS_SIZE);
+            else if (Pid == pPatPmtParser->PmtPid())
+                pPatPmtParser->ParsePmt(tempBuffer, TS_SIZE);
+        }
+
+        TotalPackets++;
+        bool Drop = false;
+        if (Pid == vpid || (pPatPmtParser && Pid == pPatPmtParser->Vpid() && pPatPmtParser->Vtype() == 0x1B))
+            Drop = NaluDumper.ProcessTSPacket(tempBuffer);
+        if (!Drop)
+        {
+            // Keep this packet, then continue with new data
+            tempLength = 0;
+            OutLength = TS_SIZE;
+            return tempBuffer;
+        }
+        // Drop TempBuffer
+        DroppedPackets++;
+        tempLength = 0;
+    }
+    // Now: TempLength==0, just process data/length
+
+    // Pointer to processed data / length:
+    uchar *Out = data;
+    uchar *OutEnd = Out;
+
+    while (length >= TS_SIZE)
+    {
+        if (data[0] != TS_SYNC_BYTE) {
+            int Skipped = 1;
+            while (Skipped < length && (data[Skipped] != TS_SYNC_BYTE || (length - Skipped > TS_SIZE && data[Skipped + TS_SIZE] != TS_SYNC_BYTE)))
+                Skipped++;
+            esyslog("ERROR: skipped %d bytes to sync on start of TS packet", Skipped);
+
+            // Pass through skipped bytes
+            if (OutEnd != data)
+                memcpy(OutEnd, data, Skipped);
+            OutEnd += Skipped;
+            continue;
+        }
+        // Now: Data starts with complete TS packet
+
+        int Pid = TsPid(data);
+        if (pPatPmtParser)
+        {
+            if (Pid == 0)
+                pPatPmtParser->ParsePat(data, TS_SIZE);
+            else if (Pid == pPatPmtParser->PmtPid())
+                pPatPmtParser->ParsePmt(data, TS_SIZE);
+        }
+
+        TotalPackets++;
+        bool Drop = false;
+        if (Pid == vpid || (pPatPmtParser && Pid == pPatPmtParser->Vpid() && pPatPmtParser->Vtype() == 0x1B))
+            Drop = NaluDumper.ProcessTSPacket(data);
+        if (!Drop)
+        {
+            if (OutEnd != data)
+                memcpy(OutEnd, data, TS_SIZE);
+            OutEnd += TS_SIZE;
+        }
+        else
+        {
+            DroppedPackets++;
+        }
+        data += TS_SIZE;
+        length -= TS_SIZE;
+    }
+    // Now: Less than a packet remains.
+    if (length > 0)
+    {
+        // copy remains into temp buffer
+        memcpy(tempBuffer, data, length);
+        tempLength = length;
+        tempLengthAtEnd = false;
+        length = 0;
+    }
+    OutLength = (OutEnd - Out);
+    return OutLength > 0 ? Out : NULL;
+}
+#endif // USE_NALUDUMP
diff --git a/remux.h b/remux.h
index b882279..896718f 100644
--- a/remux.h
+++ b/remux.h
@@ -57,6 +57,13 @@ inline bool TsHasPayload(const uchar *p)
   return p[3] & TS_PAYLOAD_EXISTS;
 }
 
+#ifdef USE_NALUDUMP
+inline bool TsSetPayload(const uchar *p)
+{
+  return p[3] & TS_PAYLOAD_EXISTS;
+}
+
+#endif // USE_NALUDUMP
 inline bool TsHasAdaptationField(const uchar *p)
 {
   return p[3] & TS_ADAPT_FIELD_EXISTS;
@@ -103,6 +110,13 @@ inline int TsContinuityCounter(const uchar *p)
   return p[3] & TS_CONT_CNT_MASK;
 }
 
+#ifdef USE_NALUDUMP
+inline void TsSetContinuityCounter(uchar *p, int Counter)
+{
+  p[3] = (p[3] & ~TS_CONT_CNT_MASK) | (Counter & TS_CONT_CNT_MASK);
+}
+
+#endif // USE_NALUDUMP
 inline int TsGetAdaptationField(const uchar *p)
 {
   return TsHasAdaptationField(p) ? p[5] : 0x00;
@@ -112,6 +126,9 @@ inline int TsGetAdaptationField(const uchar *p)
 
 int64_t TsGetPts(const uchar *p, int l);
 void TsSetTeiOnBrokenPackets(uchar *p, int l);
+#ifdef USE_NALUDUMP
+void TsExtendAdaptionField(unsigned char *Packet, int ToLength);
+#endif // USE_NALUDUMP
 
 // Some PES handling tools:
 // The following functions that take a pointer to PES data all assume that
@@ -174,6 +191,9 @@ protected:
   int MakeStream(uchar *Target, uchar Type, int Pid);
   int MakeAC3Descriptor(uchar *Target, uchar Type);
   int MakeSubtitlingDescriptor(uchar *Target, const char *Language, uchar SubtitlingType, uint16_t CompositionPageId, uint16_t AncillaryPageId);
+#ifdef USE_TTXTSUBS
+  int MakeTeletextDescriptor(uchar *Target, const tTeletextSubtitlePage *pages, int pageCount);
+#endif // USE_TTXTSUBS
   int MakeLanguageDescriptor(uchar *Target, const char *Language);
   int MakeCRC(uchar *Target, const uchar *Data, int Length);
   void GeneratePmtPid(const cChannel *Channel);
@@ -219,6 +239,9 @@ private:
   int vpid;
   int ppid;
   int vtype;
+#ifdef USE_TTXTSUBS
+  int tpid;
+#endif // USE_TTXTSUBS
   int apids[MAXAPIDS + 1]; // list is zero-terminated
   int atypes[MAXAPIDS + 1]; // list is zero-terminated
   char alangs[MAXAPIDS][MAXLANGCODE2];
@@ -231,6 +254,10 @@ private:
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   bool updatePrimaryDevice;
+#ifdef USE_TTXTSUBS
+  int totalTtxtSubtitlePages;
+  tTeletextSubtitlePage teletextSubtitlePages[MAXTXTPAGES];
+#endif // USE_TTXTSUBS
 protected:
   int SectionLength(const uchar *Data, int Length) { return (Length >= 3) ? ((int(Data[1]) & 0x0F) << 8)| Data[2] : 0; }
 public:
@@ -263,6 +290,11 @@ public:
   int Vtype(void) const { return vtype; }
        ///< Returns the video stream type as defined by the current PMT, or 0 if no video
        ///< stream type has been detected, yet.
+#ifdef USE_TTXTSUBS
+  int Tpid(void) { return tpid; }
+       ///< Returns the teletext pid as defined by the current PMT, or 0 if no teletext
+       ///< pid has been detected, yet.
+#endif // USE_TTXTSUBS
   const int *Apids(void) const { return apids; }
   const int *Dpids(void) const { return dpids; }
   const int *Spids(void) const { return spids; }
@@ -277,6 +309,10 @@ public:
   uchar SubtitlingType(int i) const { return (0 <= i && i < MAXSPIDS) ? subtitlingTypes[i] : uchar(0); }
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
+#ifdef USE_TTXTSUBS
+  const tTeletextSubtitlePage *TeletextSubtitlePages() const { return teletextSubtitlePages; }
+  int TotalTeletextSubtitlePages() const { return totalTtxtSubtitlePages; }
+#endif // USE_TTXTSUBS
   };
 
 // TS to PES converter:
@@ -390,4 +426,80 @@ public:
       ///< available.
   };
 
+#ifdef USE_NALUDUMP
+
+#define PATCH_NALUDUMP 100
+
+class cNaluDumper {
+    unsigned int History;
+
+    int LastContinuityInput;
+    int LastContinuityOutput;
+    int ContinuityOffset;
+
+    bool DropAllPayload;
+
+    int PesId;
+    int PesOffset;
+
+    int NaluOffset;
+
+    enum eNaluFillState {
+        NALU_NONE=0,    // currently not NALU fill stream
+        NALU_FILL,      // Within NALU fill stream, 0xff bytes and NALU start code in byte 0
+        NALU_TERM,      // Within NALU fill stream, read 0x80 terminating byte
+        NALU_END        // Beyond end of NALU fill stream, expecting 0x00 0x00 0x01 now
+        };
+
+    eNaluFillState NaluFillState;
+
+    struct sPayloadInfo {
+        int DropPayloadStartBytes;
+        int DropPayloadEndBytes;
+        bool DropAllPayloadBytes;
+    };
+
+public:
+    cNaluDumper();
+
+    void reset();
+
+    // Single packet interface:
+    bool ProcessTSPacket(unsigned char *Packet);
+
+private:
+    void ProcessPayload(unsigned char *Payload, int size, bool PayloadStart, sPayloadInfo &Info);
+};
+
+class cNaluStreamProcessor {
+    //Buffer stream interface:
+    int vpid;
+    uchar *data;
+    int length;
+    uchar tempBuffer[TS_SIZE];
+    int tempLength;
+    bool tempLengthAtEnd;
+    cPatPmtParser *pPatPmtParser;
+    cNaluDumper NaluDumper;
+
+    long long int TotalPackets;
+    long long int DroppedPackets;
+public:
+    cNaluStreamProcessor();
+
+    void SetPid(int VPid) { vpid = VPid; }
+    void SetPatPmtParser(cPatPmtParser *_pPatPmtParser) { pPatPmtParser = _pPatPmtParser; }
+    // Set either a PID or set a pointer to an PatPmtParser that will detect _one_ PID
+
+    void PutBuffer(uchar *Data, int Length);
+    // Add new data to be processed. Data must be valid until Get() returns NULL.
+    uchar* GetBuffer(int &OutLength);
+    // Returns filtered data, or NULL/0 to indicate that all data from Put() was processed
+    // or buffered.
+
+    long long int GetTotalPackets() { return TotalPackets; }
+    long long int GetDroppedPackets() { return DroppedPackets; }
+};
+
+#endif // USE_NALUDUMP
 #endif // __REMUX_H
diff --git a/sections.c b/sections.c
index 6b9cbe2..f9627a6 100644
--- a/sections.c
+++ b/sections.c
@@ -198,7 +198,11 @@ void cSectionHandler::Action(void)
                   if (fh) {
                      // Read section data:
                      unsigned char buf[4096]; // max. allowed size for any EIT section
+#ifdef USE_MCLI
+                     int r = device->ReadFilter(fh->handle, buf, sizeof(buf));
+#else
                      int r = safe_read(fh->handle, buf, sizeof(buf));
+#endif /* MCLI */
                      if (!DeviceHasLock)
                         continue; // we do the read anyway, to flush any data that might have come from a different transponder
                      if (r > 3) { // minimum number of bytes necessary to get section length
diff --git a/shutdown.c b/shutdown.c
index 09d4a1a..06248b7 100644
--- a/shutdown.c
+++ b/shutdown.c
@@ -17,6 +17,9 @@
 #include "channels.h"
 #include "config.h"
 #include "cutter.h"
+#ifdef USE_LIEMIKUUTIO
+#include "filetransfer.h"
+#endif /* LIEMIKUUTIO */
 #include "i18n.h"
 #include "interface.h"
 #include "menu.h"
@@ -166,6 +169,12 @@ bool cShutdownHandler::ConfirmShutdown(bool Interactive)
      if (!Interactive || !Interface->Confirm(tr("Editing - shut down anyway?")))
         return false;
      }
+#ifdef USE_LIEMIKUUTIO
+  if (cFileTransfer::Active()) {
+	  if (!Interactive || !Interface->Confirm(tr("Transfering file - shut down anyway?")))
+		  return false;
+  }
+#endif /* LIEMIKUUTIO */
 
   cTimer *timer = Timers.GetNextActiveTimer();
   time_t Next = timer ? timer->StartTime() : 0;
@@ -209,6 +218,12 @@ bool cShutdownHandler::ConfirmRestart(bool Interactive)
      if (!Interactive || !Interface->Confirm(tr("Editing - restart anyway?")))
         return false;
      }
+#ifdef USE_LIEMIKUUTIO
+  if (cFileTransfer::Active()) {
+	  if (!Interactive || !Interface->Confirm(tr("Transfering file - restart anyway?")))
+		  return false;
+  }
+#endif /* LIEMIKUUTIO */
 
   cTimer *timer = Timers.GetNextActiveTimer();
   time_t Next  = timer ? timer->StartTime() : 0;
diff --git a/status.c b/status.c
index b0a6aba..e4641a3 100644
--- a/status.c
+++ b/status.c
@@ -124,3 +124,88 @@ void cStatus::MsgOsdProgramme(time_t PresentTime, const char *PresentTitle, cons
   for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
       sm->OsdProgramme(PresentTime, PresentTitle, PresentSubtitle, FollowingTime, FollowingTitle, FollowingSubtitle);
 }
+#ifdef USE_GRAPHTFT
+
+void cStatus::MsgOsdSetEvent(const cEvent* event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetEvent(event);
+}
+
+void cStatus::MsgOsdSetRecording(const cRecording* recording)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetRecording(recording);
+}
+
+void cStatus::MsgOsdMenuDisplay(const char* kind)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDisplay(kind);
+}
+
+void cStatus::MsgOsdMenuDestroy()
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDestroy();
+}
+void cStatus::MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->OsdEventItem(Event, Text, Index, Count);
+}
+#endif /* GRAPHTFT */
+#ifdef USE_PINPLUGIN
+
+bool cStatus::MsgChannelProtected(const cDevice* Device, const cChannel* Channel)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      if (sm->ChannelProtected(Device, Channel) == true)
+          return true;
+
+  return false;
+}
+
+bool cStatus::MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->ReplayProtected(Recording, Name, Base, isDirectory, menuView) == true)
+         return true;
+     return false;
+}
+
+void cStatus::MsgRecordingFile(const char* FileName)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->RecordingFile(FileName);
+}
+
+void cStatus::MsgTimerCreation(cTimer* Timer, const cEvent *Event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->TimerCreation(Timer, Event);
+}
+
+bool cStatus::MsgPluginProtected(cPlugin* Plugin, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->PluginProtected(Plugin, menuView) == true)
+         return true;
+     return false;
+}
+
+void cStatus::MsgUserAction(const eKeys key, const cOsdObject* Interact)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->UserAction(key, Interact);
+}
+
+bool cStatus::MsgMenuItemProtected(const char* Name, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->MenuItemProtected(Name, menuView) == true)
+         return true;
+     return false;
+}
+#endif /* PINPLUGIN */
diff --git a/status.h b/status.h
index 6319165..9735074 100644
--- a/status.h
+++ b/status.h
@@ -14,6 +14,9 @@
 #include "device.h"
 #include "player.h"
 #include "tools.h"
+#ifdef USE_PINPLUGIN
+#include "plugin.h"
+#endif
 
 enum eTimerChange { tcMod, tcAdd, tcDel };
 
@@ -81,6 +84,38 @@ protected:
                // The OSD displays the single line Text with the current channel information.
   virtual void OsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle) {}
                // The OSD displays the given programme information.
+#ifdef USE_GRAPHTFT
+  virtual void OsdSetRecording(const cRecording* recording) {}
+               // The OSD displays the recording information.
+  virtual void OsdSetEvent(const cEvent* event) {}
+               // The OSD displays the event information.
+  virtual void OsdMenuDisplay(const char* kind) {}
+               // report menu creation
+  virtual void OsdMenuDestroy() {}
+               // report menu destruvtion
+  virtual void OsdEventItem(const cEvent* Event, const char *Text, int Index, int Count) {}
+               // The OSD displays the given single line Event as menu item at Index.
+#endif /* GRAPHTFT */
+#ifdef USE_PINPLUGIN
+  virtual bool ChannelProtected(const cDevice *Device, const cChannel* Channel)  { return false; }
+               // Checks if a channel is protected.
+  virtual bool ReplayProtected(const cRecording* Recording, const char* Name,
+                               const char* Base, bool isDirectory, int menuView = false) { return false; }
+               // Checks if a recording is protected.
+  virtual void RecordingFile(const char* FileName) {}
+               // The given DVB device has started recording to FileName. FileName is the name of the
+               // recording directory
+  virtual void TimerCreation(cTimer* Timer, const cEvent *Event) {}
+               // The given timer is created
+  virtual bool PluginProtected(cPlugin* Plugin, int menuView = false)  { return false; }
+               // Checks if a plugin is protected.
+  virtual void UserAction(const eKeys key, const cOsdObject* Interact) {}
+               // report user action
+  virtual bool MenuItemProtected(const char* Name, int menuView = false)  { return false; }
+               // Checks if a menu entry is protected.
+#endif /* PINPLUGIn */
+
+
 public:
   cStatus(void);
   virtual ~cStatus();
@@ -102,6 +137,23 @@ public:
   static void MsgOsdTextItem(const char *Text,  bool Scroll = false);
   static void MsgOsdChannel(const char *Text);
   static void MsgOsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle);
+#ifdef USE_GRAPHTFT
+  static void MsgOsdSetEvent(const cEvent* event);
+  static void MsgOsdSetRecording(const cRecording* recording);
+  static void MsgOsdMenuDisplay(const char* kind);
+  static void MsgOsdMenuDestroy();
+  static void MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count);
+#endif /* GRAPHTFT */
+#ifdef USE_PINPLUGIN
+  static bool MsgChannelProtected(const cDevice* Device, const cChannel* Channel);
+  static bool MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView = false);
+  static void MsgRecordingFile(const char* FileName);
+  static void MsgTimerCreation(cTimer* Timer, const cEvent *Event);
+  static bool MsgPluginProtected(cPlugin* Plugin, int menuView = false);
+  static void MsgUserAction(const eKeys key, const cOsdObject* Interact);
+  static bool MsgMenuItemProtected(const char* Name, int menuView = false);
+#endif /* PINPLUGIN */
   };
 
 #endif //__STATUS_H
diff --git a/submenu.c b/submenu.c
new file mode 100644
index 0000000..26344dc
--- /dev/null
+++ b/submenu.c
@@ -0,0 +1,947 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Submenu
+ *
+ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004, 2005 by Ralf Dotzert
+ *
+ * modified for the VDR Extensions Patch by zulu @vdr-portal
+ ****************************************************************************/
+
+#ifndef SUBMENU_H
+#include "submenu.h"
+#include "plugin.h"
+#ifdef USE_WAREAGLEICON
+#include "iconpatch.h"
+#endif /* WAREAGLEICON */
+
+static const char* TAG_SYSTEM      = "system";
+static const char* TAG_PLUGIN      = "plugin";
+static const char* TAG_COMMAND     = "command";
+static const char* TAG_THREAD      = "thread";
+static const char* TAG_MENU        = "menu";
+static const char* TAG_UNDEFINED   = "undefined";
+static const char* TRUE_STR        = "yes";
+
+
+//################################################################################
+//# SubMenuNode
+//################################################################################
+
+cSubMenuNode::cSubMenuNode(TiXmlElement *xml, int level,  cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
+{
+  init();
+  _parentMenu  = parentMenu;
+  _currentMenu = currentMenu;
+  _level       = level;
+
+  if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT) {
+     const char *tag = xml->Value();
+
+     if (cSubMenuNode::IsType(tag) != cSubMenuNode::UNDEFINED) {
+        SetType(tag);
+        SetName(xml->Attribute("name"));
+        if ((_type == COMMAND) || (_type == THREAD)) {
+           SetCommand(xml->Attribute("execute"));
+           const char *confirmStr = xml->Attribute("confirm");
+           if (confirmStr != NULL && strcmp(confirmStr, TRUE_STR) == 0)
+              _commandConfirm = true;
+           }
+        else if (_type == PLUGIN) { // Add Plugin Index
+           SetCustomTitle(xml->Attribute("title"));
+           SetPlugin();
+           }
+        else if (_type == MENU && xml->NoChildren() == false) {
+           xml = xml->FirstChildElement();
+           do {
+              cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
+              _subMenus.Add(node);
+              } while ((xml=xml->NextSiblingElement()) != NULL);
+           }
+        }
+     }
+  else
+     throw "Invalid XML Node";
+}
+
+/**
+ * Construct new Node empty Node
+ *
+ *
+ */
+cSubMenuNode::cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
+{
+  init();
+  _parentMenu  = parentMenu;
+  _currentMenu = currentMenu;
+
+}
+
+
+/**
+ *
+ */
+void cSubMenuNode::init()
+{
+  _name                = NULL;
+  _command             = NULL;
+  _title               = NULL;
+  _pluginMainMenuEntry = NULL;
+  _type                = UNDEFINED;
+  _level               = 0;
+  _parentMenu          = NULL;
+  _currentMenu         = NULL;
+  _pluginIndex         = 0;
+  _commandConfirm      = false;
+}
+
+
+cSubMenuNode::~ cSubMenuNode()
+{
+  if (_name != NULL)
+     free((void*)_name);
+  if (_command != NULL)
+     free((void*)_command);
+  if (_title != NULL)
+     free((void*)_title);
+  if (_pluginMainMenuEntry != NULL)
+     free((void*)_pluginMainMenuEntry);
+}
+
+/**
+ *
+ */
+void cSubMenuNode::SetPlugin()
+{
+  bool found = false;
+  for (int i = 0; ; i++) {
+      cPlugin *p = cPluginManager::GetPlugin(i);
+      if (p) {
+         if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL) {
+            SetPluginMainMenuEntry(p->MainMenuEntry());
+            _pluginIndex = i;
+            found = true;
+            break;
+            }
+         }
+      else
+         break;
+      }
+
+      if (!found)
+         _type = UNDEFINED;
+}
+
+
+bool cSubMenuNode::SaveXml(TiXmlElement *root)
+{
+  bool ok = true;
+
+  if (root!=NULL) {
+     TiXmlElement *e = NULL;
+     switch(_type) {
+        case SYSTEM:
+           e = new TiXmlElement(TAG_SYSTEM);
+           e->SetAttribute("name", GetName());
+           break;
+        case COMMAND:
+           e = new TiXmlElement(TAG_COMMAND);
+           e->SetAttribute("name", GetName());
+           e->SetAttribute("execute", GetCommand());
+           if (_commandConfirm)
+              e->SetAttribute("confirm", TRUE_STR);
+           break;
+        case THREAD:
+           e = new TiXmlElement(TAG_THREAD);
+           e->SetAttribute("name", GetName());
+           e->SetAttribute("execute", GetCommand());
+           if (_commandConfirm)
+              e->SetAttribute("confirm", TRUE_STR);
+           break;
+        case PLUGIN:
+           e = new TiXmlElement(TAG_PLUGIN);
+           e->SetAttribute("name", GetName());
+           if (GetCustomTitle() != NULL && strcmp(GetCustomTitle(), "") != 0)
+              e->SetAttribute("title", GetCustomTitle());
+           break;
+        case MENU:
+           e = new TiXmlElement(TAG_MENU);
+           e->SetAttribute("name", GetName());
+           break;
+        case UNDEFINED:
+        default:
+           ok = false;
+           break;
+        }
+        if (ok) {
+           root->LinkEndChild(e);
+           if (HasSubMenus())
+              for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+                  node->SaveXml(e);
+           }
+     }
+
+  return(ok);
+}
+
+
+cSubMenuNode::Type cSubMenuNode::IsType(const char *name)
+{
+  Type type = UNDEFINED;
+
+  if (strcmp(name ,TAG_SYSTEM) == 0)
+     type = cSubMenuNode::SYSTEM;
+  else if (strcmp(name ,TAG_PLUGIN) == 0)
+     type = cSubMenuNode::PLUGIN;
+  else if (strcmp(name ,TAG_COMMAND) == 0)
+     type = cSubMenuNode::COMMAND;
+  else if (strcmp(name ,TAG_THREAD) == 0)
+     type = cSubMenuNode::THREAD;
+  else if (strcmp(name ,TAG_MENU) == 0)
+     type = cSubMenuNode::MENU;
+
+  return(type);
+}
+
+void cSubMenuNode::SetType(const char *name)
+{
+   _type = IsType(name);
+}
+
+void cSubMenuNode::SetType(enum Type type)
+{
+  _type = type;
+}
+
+
+cSubMenuNode::Type cSubMenuNode::GetType()
+{
+  return(_type);
+}
+
+const char *cSubMenuNode::GetTypeAsString()
+{
+  const char *str=NULL;
+  switch(_type) {
+     case SYSTEM:
+        str = TAG_SYSTEM;
+        break;
+     case COMMAND:
+        str = TAG_COMMAND;
+        break;
+     case THREAD:
+        str = TAG_THREAD;
+        break;
+     case PLUGIN:
+        str = TAG_PLUGIN;
+        break;
+     case MENU:
+        str = TAG_MENU;
+        break;
+     case UNDEFINED:
+        str = TAG_UNDEFINED;
+     default:
+        break;
+    }
+
+  return(str);
+}
+
+void cSubMenuNode::SetCommand(const char *command)
+{
+  if (_command != NULL)
+     free((void*)_command);
+
+  if (command != NULL)
+     _command = strdup(command);
+  else
+     _command = NULL;
+}
+
+const char *cSubMenuNode::GetCommand()
+{
+  return(_command);
+}
+
+bool cSubMenuNode::CommandConfirm()
+{
+  return(_commandConfirm);
+}
+
+void cSubMenuNode::SetCommandConfirm(int val)
+{
+  if (val == 1)
+     _commandConfirm = true;
+  else
+     _commandConfirm = false;
+}
+
+void cSubMenuNode::SetCustomTitle(const char *title)
+{
+  if (_title != NULL)
+     free((void*)_title);
+
+  if (title != NULL)
+     _title = strdup(title);
+  else
+     _title = NULL;
+}
+
+const char *cSubMenuNode::GetCustomTitle()
+{
+  return(_title);
+}
+
+void cSubMenuNode::SetName(const char *name)
+{
+  if (_name)
+     free ((void*)_name);
+
+  if (name != NULL)
+     _name = strdup(name);
+  else
+     _name = NULL;
+}
+
+const char *cSubMenuNode::GetName()
+{
+  return(_name);
+}
+
+int cSubMenuNode::GetLevel()
+{
+  return(_level);
+}
+
+void cSubMenuNode::SetLevel(int level)
+{
+  _level = level;
+  if (HasSubMenus()) { //Adjust Levels of Subnodes
+     for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+         node->SetLevel(level+1);
+     }
+}
+
+int cSubMenuNode::GetPluginIndex()
+{
+  return(_pluginIndex);
+}
+
+void cSubMenuNode::SetPluginIndex(int index)
+{
+  _pluginIndex = index;
+}
+
+void cSubMenuNode::SetPluginMainMenuEntry(const char *mainMenuEntry)
+{
+  if (_pluginMainMenuEntry != NULL)
+     free((void*)_pluginMainMenuEntry);
+
+  if (_title != NULL && strcmp(_title, "") != 0)
+     _pluginMainMenuEntry = strdup(_title);
+  else if (mainMenuEntry != NULL)
+     _pluginMainMenuEntry = strdup(mainMenuEntry);
+  else
+     _pluginMainMenuEntry = NULL;
+}
+
+const char *cSubMenuNode::GetPluginMainMenuEntry()
+{
+  return(_pluginMainMenuEntry);
+}
+
+
+cSubMenuNodes *cSubMenuNode::GetParentMenu()
+{
+  return(_parentMenu);
+}
+
+void cSubMenuNode::SetParentMenu(cSubMenuNodes *parent)
+{
+  _parentMenu = parent;
+}
+
+cSubMenuNodes *cSubMenuNode::GetCurrentMenu()
+{
+  return(_currentMenu);
+}
+
+void cSubMenuNode::SetCurrentMenu(cSubMenuNodes *current)
+{
+  _currentMenu = current;
+}
+
+
+cSubMenuNodes *cSubMenuNode::GetSubMenus()
+{
+  return(&_subMenus);
+}
+
+bool cSubMenuNode::HasSubMenus()
+{
+  if (_subMenus.Count() > 0)
+     return(true);
+  else
+     return(false);
+}
+
+
+void cSubMenuNode::Print(int index)
+{
+  for (int i = 0; i < index; i++)
+      printf(" ");
+
+  printf("Name=%s Type=%s Level=%d", _name, GetTypeAsString(), _level);
+  if (_type == COMMAND || _type == THREAD)
+     printf(" Command=%s", _command);
+  else if (_type == PLUGIN && _title != NULL)
+     printf(" Title=%s", _title);
+  printf("\n");
+
+  for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+      node->Print(index+4);
+}
+
+
+//################################################################################
+//#
+//################################################################################
+cSubMenu::cSubMenu()
+{
+  _commandResult         = NULL;
+  _currentMenuTree       = &_menuTree;
+  _currentParentMenuTree = NULL;
+#ifdef USE_PINPLUGIN
+  _currentParentIndex    = -1;
+#endif /* PINPLUGIN */
+  _nodeArray             = NULL;
+  _nrNodes               = 0;
+}
+
+
+cSubMenu::~cSubMenu()
+{
+  if (_commandResult)
+     free(_commandResult);
+  if (_nodeArray)
+     free(_nodeArray);
+  _nrNodes = 0;
+}
+
+
+bool cSubMenu::LoadXml(cString fname)
+{
+  TiXmlDocument  xmlDoc = TiXmlDocument(fname);
+  TiXmlElement  *root   = NULL;
+  cSubMenuNode  *node   = NULL;
+
+  bool  ok = true;
+  // Clear previously loaded Menu
+  _menuTree.Clear();
+  _fname = fname;
+
+  if ((ok = xmlDoc.LoadFile())) {
+     if ((root = xmlDoc.FirstChildElement("menus")) != NULL) {
+        cString tmp = root->Attribute("suffix");
+#ifdef USE_WAREAGLEICON
+        if      (strcmp(tmp, "ICON_FOLDER") == 0)      tmp = cString::sprintf(" %s", IsLangUtf8() ? ICON_FOLDER_UTF8 : ICON_FOLDER);
+        else if (strcmp(tmp, "ICON_MOVE_FOLDER") == 0) tmp = cString::sprintf(" %s", IsLangUtf8() ? ICON_MOVE_FOLDER_UTF8 : ICON_MOVE_FOLDER);
+#endif /* WAREAGLEICON */
+        if (*tmp)
+           _menuSuffix = tmp;
+        else
+           _menuSuffix = cString::sprintf(" ");
+
+        if ((root = root->FirstChildElement()) != NULL) {
+           do {
+              try {
+                 node = new cSubMenuNode(root, 0,  &_menuTree, NULL);
+                 _menuTree.Add(node);
+                 }
+              catch (char *message) {
+                 esyslog("ERROR: while decoding XML Node");
+                 ok = false;
+                 }
+              } while (ok == true && (root = root->NextSiblingElement()) != NULL);
+           addMissingPlugins();
+           removeUndefinedNodes();
+           }
+        }
+     else {
+        esyslog("ERROR: in %s, missing Tag <menus>\n", *fname);
+        ok = false;
+        }
+     }
+  else {
+     esyslog("ERROR: in %s : %s  Col=%d Row=%d\n",
+            *fname,
+            xmlDoc.ErrorDesc(),
+            xmlDoc.ErrorCol(),
+            xmlDoc.ErrorRow());
+     ok = false;
+     }
+
+  return(ok);
+}
+
+
+bool cSubMenu::SaveXml()
+{
+  return(SaveXml(_fname));
+}
+
+
+bool cSubMenu::SaveXml(cString fname)
+{
+  bool ok = true;
+
+  if (*_fname) {
+     TiXmlDocument xml = TiXmlDocument(fname);
+     TiXmlComment  comment;
+     comment.SetValue("\n\
+-    VDR Menu-Configuration File\n\
+-\n\
+-\n\
+-   Example:\n\
+-\n\
+ <menus>\n\
+    <system name=\"Schedule\" />\n\
+    <system name=\"Channels\" />\n\
+    <system name=\"Timers\" />\n\
+    <system name=\"Recordings\" />\n\
+    <menu name=\"System\">\n\
+        <system name=\"Setup\" />\n\
+        <system name=\"Commands\" />\n\
+        <plugin name=\"setup\" title=\"My Setup\" />\n\
+        <command name=\"myCommand1\" execute=\"/usr/bin/mycommand1\" />\n\
+        <command name=\"myCommand2\" execute=\"/usr/bin/mycommand2\" confirm=\"yes\" />\n\
+        <thread name=\"myCommand3\" execute=\"/usr/bin/mycommand3\" confirm=\"yes\" />\n\
+        <plugin name=\"epgsearch\" title=\"myProgram\" />\n\
+        <menu name=\"mySubSubMenu\">\n\
+            ...\n\
+        </menu>\n\
+    </menu>\n\
+     <menu name=\"Suche\">\n\
+        <plugin name=\"epgsearch\" />\n\
+        ...\n\
+    </menu>\n\
+ </menus>\n\
+");
+
+     TiXmlElement root("menus");
+     root.SetAttribute("suffix", _menuSuffix);
+     for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
+         node->SaveXml(&root);
+
+         if (xml.InsertEndChild(comment) != NULL && xml.InsertEndChild(root) != NULL)
+            ok = xml.SaveFile(fname);
+     }
+  else
+     ok = false;
+
+  return(ok);
+}
+
+
+cSubMenuNodes *cSubMenu::GetMenuTree()
+{
+  return(_currentMenuTree);
+}
+
+
+void cSubMenu::PrintMenuTree()
+{
+  for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
+      node->Print();
+}
+
+
+int cSubMenu::GetNrOfNodes()
+{
+  if (_nrNodes == 0) {
+     if ((_nrNodes = countNodes(&_menuTree)) > 0) {
+        _nodeArray = (cSubMenuNode**) malloc(sizeof(cSubMenuNode*)*_nrNodes);
+        int index = 0;
+        tree2Array(&_menuTree, index);
+        }
+     }
+
+  return(_nrNodes);
+}
+
+
+/**
+ * returns the specified node within the current menu
+ * @param index position in the current menu
+ * @return node or null if not found
+ */
+cSubMenuNode *cSubMenu::GetNode(int index)
+{
+  cSubMenuNode *node = NULL;
+  if (_currentMenuTree == NULL || (node=_currentMenuTree->Get(index)) == NULL)
+     esyslog("ERROR: illegal call of cSubMenu::GetNode(%d)", index);
+
+  return(node);
+}
+
+
+/**
+ * Get the specified Node
+ * @param index specfies the absolut indes in the list of all nodes
+ * @return node or NULL if not found
+ */
+cSubMenuNode *cSubMenu::GetAbsNode(int index)
+{
+  cSubMenuNode *node = NULL;
+  GetNrOfNodes();
+  if (_nrNodes > 0 && index >= 0 && index < _nrNodes)
+     node = _nodeArray[index];
+
+  return(node);
+}
+
+
+#ifdef USE_PINPLUGIN
+bool cSubMenu::Down(cSubMenuNode *node, int currentIndex)
+#else
+bool cSubMenu::Down(int index)
+#endif /* PINPLUGIN */
+{
+  bool ok = true;
+#ifdef USE_PINPLUGIN
+  if (_currentMenuTree != NULL && node && node->GetType() == cSubMenuNode::MENU) {
+#else
+  cSubMenuNode *node = NULL;
+
+  if (_currentMenuTree != NULL && (node=_currentMenuTree->Get(index)) != NULL && node->GetType() == cSubMenuNode::MENU) {
+#endif /* PINPLUGIN */
+     _currentParentMenuTree = _currentMenuTree;
+#ifdef USE_PINPLUGIN
+     _currentParentIndex = currentIndex;
+#endif /* PINPLUGIN */
+     _currentMenuTree = node->GetSubMenus();
+     }
+  else {
+     ok = false;
+#ifdef USE_PINPLUGIN
+     esyslog("ERROR: illegal call of cSubMenu::Down");
+#else
+     esyslog("ERROR: illegal call of cSubMenu::Down(%d)", index);
+#endif /* PINPLUGIN */
+     }
+
+  return(ok);
+}
+
+bool cSubMenu::Up(int *parentIndex)
+{
+  bool ok = true;
+
+  if (_currentMenuTree != NULL && parentIndex != NULL) {
+#ifndef USE_PINPLUGIN
+     cSubMenuNode *node = NULL;
+#endif /* PINPLUGIN */
+     *parentIndex = 0;
+#ifdef USE_PINPLUGIN
+     if (_currentParentIndex >= 0)
+        *parentIndex = _currentParentIndex;
+#else
+     if (_currentParentMenuTree != NULL)
+        for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
+            if (_currentMenuTree == node->GetSubMenus()) {
+               *parentIndex = i;
+               break;
+               }
+            }
+#endif /* PINPLUGIN */
+
+     _currentMenuTree = _currentParentMenuTree;
+     if (_currentMenuTree != NULL)
+        _currentParentMenuTree = _currentMenuTree->Get(0)->GetParentMenu();
+     else
+        ok = false;
+     }
+  else {
+     ok = false;
+     esyslog("ERROR: illegal call of cSubMenu::Up()");
+     }
+
+  return(ok);
+}
+
+const char *cSubMenu::ExecuteCommand(const char *cmd)
+{
+  free(_commandResult);
+  _commandResult = NULL;
+
+  dsyslog("executing command '%s'", cmd);
+  FILE *p = popen(cmd, "r");
+  if (p) {
+     int l = 0;
+     int c;
+     while ((c = fgetc(p)) != EOF) {
+           if (l % 20 == 0)
+              _commandResult = (char *)realloc(_commandResult, l + 21);
+           _commandResult[l++] = c;
+           }
+     if (_commandResult)
+        _commandResult[l] = 0;
+     pclose(p);
+     }
+  else
+     esyslog("ERROR: can't open pipe for command '%s'", cmd);
+
+  return _commandResult;
+}
+
+/**
+ * Move Menu Entry to new Position
+ * @param index  index of menu entry to move
+ * @param toIndex index of destination
+ * @param where After ore before the destination index
+ */
+void cSubMenu::MoveMenu(int index, int toIndex, enum Where where)
+{
+  if (index < 0 || index > _nrNodes || // invalid index is ignored
+     toIndex < 0 || toIndex > _nrNodes || index == toIndex)
+     return;
+
+  cSubMenuNode *srcNode  = GetAbsNode(index);
+  cSubMenuNode *destNode = GetAbsNode(toIndex);
+
+  if (where == cSubMenu::INTO && destNode->GetType() != cSubMenuNode::MENU)
+     return;
+
+  if (where == cSubMenu::INTO) {
+     if (destNode->GetType() == cSubMenuNode::MENU) {
+        srcNode->GetCurrentMenu()->Del(srcNode, false);
+        srcNode->SetLevel(destNode->GetLevel()+1);
+        srcNode->SetParentMenu(destNode->GetCurrentMenu());
+        srcNode->SetCurrentMenu(destNode->GetSubMenus());
+
+        destNode->GetSubMenus()->Add(srcNode);
+        reloadNodeArray();
+        }
+     }
+  else {
+     srcNode->GetCurrentMenu()->Del(srcNode, false);
+     srcNode->SetLevel(destNode->GetLevel());
+     srcNode->SetParentMenu(destNode->GetParentMenu());
+     srcNode->SetCurrentMenu(destNode->GetCurrentMenu());
+
+     if (where == cSubMenu::BEHIND) {
+        destNode->GetCurrentMenu()->Add(srcNode, GetAbsNode(toIndex));
+        reloadNodeArray();
+        }
+     else {
+        destNode->GetCurrentMenu()->Ins(srcNode, GetAbsNode(toIndex));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * Create a new Menu Entry
+ * @param index index of destination
+ * @param menuTitle  Titel of new Menu entry
+ */
+void cSubMenu::CreateMenu(int index, const char *menuTitle)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(menuTitle);
+        newNode->SetType(cSubMenuNode::MENU);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * delete the specified entry, or subtree if the specified entry is a menu
+ * @param index destion index
+ */
+void cSubMenu::DeleteMenu(int index)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode = GetAbsNode(index);
+     srcNode->GetCurrentMenu()->Del(srcNode, true);
+     reloadNodeArray();
+     }
+}
+
+
+// Private Methods
+
+int cSubMenu::countNodes(cSubMenuNodes *tree)
+{
+  int count = 0;
+  if (tree != NULL) {
+     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
+         count++;
+         if (node->HasSubMenus())
+            count += countNodes(node->GetSubMenus());
+         }
+     }
+  return(count);
+}
+
+
+void cSubMenu::tree2Array(cSubMenuNodes *tree, int &index)
+{
+  if (tree != NULL) {
+     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
+         _nodeArray[index++]=node;
+         if (node->HasSubMenus())
+            tree2Array(node->GetSubMenus(), index);
+         }
+     }
+
+}
+
+bool cSubMenu::IsPluginInMenu(const char *name)
+{
+  bool found = false;
+  for (int i = 0; i < _nrNodes && found == false; i++) {
+      cSubMenuNode *node = GetAbsNode(i);
+      if (node != NULL && node->GetType() == cSubMenuNode::PLUGIN && strcmp(name, node->GetName()) == 0)
+         found = true;
+      }
+  return(found);
+}
+
+/**
+ * Adds the given plugin to the Menu-Tree if not allready in List
+ * @param name specifies the name of the plugin
+ */
+void cSubMenu::AddPlugin(const char *name)
+{
+  if (! IsPluginInMenu(name)) {
+     cSubMenuNode *node = new  cSubMenuNode(&_menuTree, NULL);
+     node->SetName(name);
+     node->SetType("plugin");
+     node->SetPlugin();
+     _menuTree.Add(node);
+     }
+}
+
+void cSubMenu::addMissingPlugins()
+{
+  _nrNodes = GetNrOfNodes();
+  for (int i = 0; ; i++) {
+      cPlugin *p = cPluginManager::GetPlugin(i);
+      if (p)
+         AddPlugin(p->Name());
+      else
+         break;
+      }
+  reloadNodeArray();
+}
+
+/**
+ * Adds the given command to the Menu-Tree
+ * @param name specifies the name of the command
+ */
+void cSubMenu::CreateCommand(int index, const char *name, const char *execute, int confirm)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(name);
+        newNode->SetType("command");
+        newNode->SetCommand(execute);
+        newNode->SetCommandConfirm(confirm);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+void cSubMenu::CreateThread(int index, const char *name, const char *execute, int confirm)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(name);
+        newNode->SetType("thread");
+        newNode->SetCommand(execute);
+        newNode->SetCommandConfirm(confirm);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * reloads the internal Array of Nodes
+ */
+void cSubMenu::reloadNodeArray()
+{
+  if (_nrNodes > 0)
+     free(_nodeArray);
+  _nodeArray = NULL;
+  _nrNodes = 0;
+  _nrNodes = GetNrOfNodes();
+}
+
+/**
+ * remove Undefined Nodes
+ */
+void cSubMenu::removeUndefinedNodes()
+{
+  bool remove = false;
+
+  reloadNodeArray();
+  for (int i = 0; i < _nrNodes; i++) {
+      cSubMenuNode *node = GetAbsNode(i);
+      if (node != NULL && node->GetType() == cSubMenuNode::UNDEFINED) {
+         cSubMenuNodes *pMenu = node->GetCurrentMenu();
+         pMenu->Del(node, true);
+         remove = true;
+         }
+      }
+  if (remove)
+     reloadNodeArray();
+}
+
+
+/**
+* Retrieves the Menutitel of the parent Menu
+*/
+const char *cSubMenu::GetParentMenuTitel()
+{
+  const char *result = "";
+
+  if (_currentMenuTree != NULL && _currentParentMenuTree != NULL) {
+     cSubMenuNode *node = NULL;
+     for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
+         if (_currentMenuTree == node->GetSubMenus()) {
+            result = node->GetName();
+            break;
+            }
+         }
+     }
+
+  return(result);
+}
+
+#endif
diff --git a/submenu.h b/submenu.h
new file mode 100644
index 0000000..5c3fe84
--- /dev/null
+++ b/submenu.h
@@ -0,0 +1,159 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Submenu
+ *
+ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004, 2005 by Ralf Dotzert
+ *
+ * modified for the VDR Extensions Patch by zulu @vdr-portal
+ ****************************************************************************/
+
+#ifndef SUBMENU_H
+#define SUBMENU_H
+
+#include "thread.h"
+#include "tools.h"
+#define  TIXML_USE_STL
+#include <tinystr.h>
+#include <tinyxml.h>
+
+class cSubMenuNode;
+class cSubMenuNodes;
+class cSubMenu;
+
+
+class cSubMenuNodes : public cList<cSubMenuNode> {};
+
+// execute cmd thread
+class cExecCmdThread : public cThread {
+private:
+  cString ExecCmd;
+protected:
+  virtual void Action(void) {
+     if (system(ExecCmd) == 0)
+        esyslog("%s - finished", *ExecCmd);
+     delete(this);
+     };
+public:
+  cExecCmdThread(char *cmd) {
+     ExecCmd = cString::sprintf("%s", cmd);
+     }
+  cExecCmdThread(const char *cmd) {
+     ExecCmd = cString::sprintf("%s", cmd);
+     }
+  ~cExecCmdThread() {
+     };
+  };
+
+//################################################################################
+//# SubMenuNode
+//################################################################################
+class cSubMenuNode : public cListObject {
+public:
+  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU };
+  cSubMenuNode(TiXmlElement *xml, int level, cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
+  cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
+  ~cSubMenuNode();
+  bool SaveXml(TiXmlElement *root);
+  static cSubMenuNode::Type IsType(const char *name);
+  void  SetType(const char *name);
+  void  SetType(enum Type type);
+  void  SetPlugin();
+  cSubMenuNode::Type GetType();
+  const char *GetTypeAsString();
+  void SetCommand(const char *command);
+  bool CommandConfirm();
+  void SetCommandConfirm(int val);
+  const char *GetCommand();
+  void SetCustomTitle(const char *title);
+  const char *GetCustomTitle();
+  void SetName(const char *name);
+  const char*GetName();
+  int  GetLevel();
+  void SetLevel(int level);
+  int  GetPluginIndex();
+  void SetPluginIndex(int index);
+  void SetPluginMainMenuEntry(const char *mainMenuEntry);
+  const char *GetPluginMainMenuEntry();
+  cSubMenuNodes *GetParentMenu();
+  void SetParentMenu(cSubMenuNodes *parent);
+  cSubMenuNodes *GetCurrentMenu();
+  void SetCurrentMenu(cSubMenuNodes *current);
+  cSubMenuNodes *GetSubMenus();
+  bool HasSubMenus();
+  void Print(int index = 0);
+private:
+  Type _type;
+  int _level;
+  // Plugin Variables
+  int _pluginIndex;
+  const char *_pluginMainMenuEntry;
+  // common
+  const char *_name;
+  const char *_command;
+  bool _commandConfirm;
+  const char *_title;
+  cSubMenuNodes _subMenus;
+  cSubMenuNodes *_parentMenu;
+  cSubMenuNodes *_currentMenu;
+  void init();
+  };
+
+
+//################################################################################
+//# SubMenu Class
+//################################################################################
+class cSubMenu {
+public:
+  cSubMenu();
+  ~cSubMenu();
+  enum Where { BEFORE, BEHIND, INTO};
+  bool LoadXml(cString fname);
+  bool SaveXml(cString fname);
+  bool SaveXml();
+  cSubMenuNodes *GetMenuTree();
+  bool Up(int *ParentIndex);
+#ifdef USE_PINPLUGIN
+  bool Down(cSubMenuNode* node, int currentIndex);
+#else
+  bool Down(int index);
+#endif /* PINPLUGIN */
+  int  GetNrOfNodes();
+  cSubMenuNode* GetAbsNode(int index);
+  cSubMenuNode* GetNode(int index);
+  void PrintMenuTree();
+  bool IsPluginInMenu(const char *name);
+  void AddPlugin(const char *name);
+  void CreateCommand(int index, const char *name, const char *execute, int confirm);
+  void CreateThread(int index, const char *name, const char *execute, int confirm);
+  const char *ExecuteCommand(const char *command);
+  void MoveMenu(int index, int toindex, enum Where);
+  void CreateMenu(int index, const char *menuTitle);
+  void DeleteMenu(int index);
+  cString GetMenuSuffix() { return _menuSuffix; }
+  void SetMenuSuffix(char *suffix) { _menuSuffix = suffix; }
+  bool isTopMenu() { return (_currentParentMenuTree == NULL); }
+  const char *GetParentMenuTitel();
+private:
+  cSubMenuNodes _menuTree;
+  cSubMenuNodes *_currentMenuTree;
+  cSubMenuNodes *_currentParentMenuTree;
+#ifdef USE_PINPLUGIN
+  int _currentParentIndex;
+#endif /* PINPLUGIN */
+  cString _fname;
+  char *_commandResult;
+  int _nrNodes;
+  cSubMenuNode **_nodeArray;
+  cString _menuSuffix;
+  int countNodes(cSubMenuNodes *tree);
+  void tree2Array(cSubMenuNodes *tree, int &index);
+  void addMissingPlugins();
+  void reloadNodeArray();
+  void removeUndefinedNodes();
+  };
+
+#endif //__SUBMENU_H
diff --git a/svdrp.c b/svdrp.c
index f8db847..104198b 100644
--- a/svdrp.c
+++ b/svdrp.c
@@ -31,6 +31,9 @@
 #include "cutter.h"
 #include "device.h"
 #include "eitscan.h"
+#ifdef USE_LIEMIKUUTIO
+#include "filetransfer.h"
+#endif /* LIEMIKUUTIO */
 #include "keys.h"
 #include "menu.h"
 #include "plugin.h"
@@ -193,6 +196,13 @@ const char *HelpPages[] = {
   "    After a CLRE command, no further EPG processing is done for 10\n"
   "    seconds, so that data sent with subsequent PUTE commands doesn't\n"
   "    interfere with data from the broadcasters.",
+#ifdef USE_LIEMIKUUTIO
+  "CPYR <number> <new name>\n"
+  "    Copy the recording with the given number. Before a recording can be\n"
+  "    copied, an LSTR command must have been executed in order to retrieve\n"
+  "    the recording numbers. The numbers don't change during subsequent CPYR\n"
+  "    commands.",
+#endif /* LIEMIKUUTIO */
   "DELC <number>\n"
   "    Delete channel.",
   "DELR <number>\n"
@@ -256,6 +266,13 @@ const char *HelpPages[] = {
   "    used to easily activate or deactivate a timer.",
   "MOVC <number> <to>\n"
   "    Move a channel to a new position.",
+#ifdef USE_LIEMIKUUTIO
+  "MOVR <number> <new name>\n"
+  "    Move the recording with the given number. Before a recording can be\n"
+  "    moved, an LSTR command must have been executed in order to retrieve\n"
+  "    the recording numbers. The numbers don't change during subsequent MOVR\n"
+  "    commands.",
+#endif /* LIEMIKUUTIO */
   "NEWC <settings>\n"
   "    Create a new channel. Settings must be in the same format as returned\n"
   "    by the LSTC command.",
@@ -611,6 +628,34 @@ void cSVDRP::CmdCLRE(const char *Option)
      }
 }
 
+#ifdef USE_LIEMIKUUTIO
+void cSVDRP::CmdCPYR(const char *Option)
+{
+  if (*Option) {
+     char *tail;
+     int n = strtol(Option, &tail, 10);
+     cRecording *recording = Recordings.Get(n - 1);
+     if (recording && tail && tail != Option) {
+        char *oldName = strdup(recording->Name());
+        tail = skipspace(tail);
+        if (!cFileTransfer::Active()) {
+           if (cFileTransfer::Start(recording, tail, true))
+              Reply(250, "Copying recording \"%s\" to \"%s\"", oldName, tail);
+           else
+              Reply(554, "Can't start file transfer");
+           }
+        else
+           Reply(554, "File transfer already active");
+        free(oldName);
+        }
+     else
+        Reply(550, "Recording \"%d\" not found%s", n, Recordings.Count() ? "" : " (use LSTR before copying)");
+     }
+  else
+     Reply(501, "Invalid Option \"%s\"", Option);
+}
+#endif /* LIEMIKUUTIO */
+
 void cSVDRP::CmdDELC(const char *Option)
 {
   if (*Option) {
@@ -1289,6 +1334,34 @@ void cSVDRP::CmdMOVC(const char *Option)
      Reply(501, "Missing channel number");
 }
 
+#ifdef USE_LIEMIKUUTIO
+void cSVDRP::CmdMOVR(const char *Option)
+{
+  if (*Option) {
+     char *tail;
+     int n = strtol(Option, &tail, 10);
+     cRecording *recording = Recordings.Get(n - 1);
+     if (recording && tail && tail != Option) {
+        char *oldName = strdup(recording->Name());
+        tail = skipspace(tail);
+        if (!cFileTransfer::Active()) {
+           if (cFileTransfer::Start(recording, tail))
+              Reply(250, "Moving recording \"%s\" to \"%s\"", oldName, tail);
+           else
+              Reply(554, "Can't start file transfer");
+           }
+        else
+           Reply(554, "File transfer already active");
+        free(oldName);
+        }
+     else
+        Reply(550, "Recording \"%d\" not found%s", n, Recordings.Count() ? "" : " (use LSTR before moving)");
+     }
+  else
+     Reply(501, "Invalid Option \"%s\"", Option);
+}
+#endif /* LIEMIKUUTIO */
+
 void cSVDRP::CmdNEWC(const char *Option)
 {
   if (*Option) {
@@ -1618,6 +1691,9 @@ void cSVDRP::Execute(char *Cmd)
   s = skipspace(s);
   if      (CMD("CHAN"))  CmdCHAN(s);
   else if (CMD("CLRE"))  CmdCLRE(s);
+#ifdef USE_LIEMIKUUTIO
+  else if (CMD("CPYR"))  CmdCPYR(s);
+#endif /* LIEMIKUUTIO */
   else if (CMD("DELC"))  CmdDELC(s);
   else if (CMD("DELR"))  CmdDELR(s);
   else if (CMD("DELT"))  CmdDELT(s);
@@ -1633,6 +1709,9 @@ void cSVDRP::Execute(char *Cmd)
   else if (CMD("MODC"))  CmdMODC(s);
   else if (CMD("MODT"))  CmdMODT(s);
   else if (CMD("MOVC"))  CmdMOVC(s);
+#ifdef USE_LIEMIKUUTIO
+  else if (CMD("MOVR"))  CmdMOVR(s);
+#endif /* LIEMIKUUTIO */
   else if (CMD("NEWC"))  CmdNEWC(s);
   else if (CMD("NEWT"))  CmdNEWT(s);
   else if (CMD("NEXT"))  CmdNEXT(s);
diff --git a/svdrp.h b/svdrp.h
index 5ec9bc7..d4e0f63 100644
--- a/svdrp.h
+++ b/svdrp.h
@@ -56,6 +56,9 @@ private:
   void PrintHelpTopics(const char **hp);
   void CmdCHAN(const char *Option);
   void CmdCLRE(const char *Option);
+#ifdef USE_LIEMIKUUTIO
+  void CmdCPYR(const char *Option);
+#endif /* LIEMIKUUTIO */
   void CmdDELC(const char *Option);
   void CmdDELR(const char *Option);
   void CmdDELT(const char *Option);
@@ -71,6 +74,9 @@ private:
   void CmdMODC(const char *Option);
   void CmdMODT(const char *Option);
   void CmdMOVC(const char *Option);
+#ifdef USE_LIEMIKUUTIO
+  void CmdMOVR(const char *Option);
+#endif /* LIEMIKUUTIO */
   void CmdNEWC(const char *Option);
   void CmdNEWT(const char *Option);
   void CmdNEXT(const char *Option);
diff --git a/timers.c b/timers.c
index c4f4f7a..a11a586 100644
--- a/timers.c
+++ b/timers.c
@@ -47,6 +47,9 @@ cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel)
      stop -= 2400;
   priority = Pause ? Setup.PausePriority : Setup.DefaultPriority;
   lifetime = Pause ? Setup.PauseLifetime : Setup.DefaultLifetime;
+#ifdef USE_PINPLUGIN
+  fskProtection = 0;
+#endif /* PINPLUGIN */
   *file = 0;
   aux = NULL;
   event = NULL;
@@ -86,6 +89,9 @@ cTimer::cTimer(const cEvent *Event)
      stop -= 2400;
   priority = Setup.DefaultPriority;
   lifetime = Setup.DefaultLifetime;
+#ifdef USE_PINPLUGIN
+  fskProtection = 0;
+#endif /* PINPLUGIN */
   *file = 0;
   const char *Title = Event->Title();
   if (!isempty(Title))
@@ -97,6 +103,9 @@ cTimer::cTimer(const cEvent *Event)
      }
   aux = NULL;
   event = NULL; // let SetEvent() be called to get a log message
+#ifdef USE_PINPLUGIN
+  cStatus::MsgTimerCreation(this, Event);
+#endif /* PINPLUGIN */
 }
 
 cTimer::cTimer(const cTimer &Timer)
@@ -132,6 +141,9 @@ cTimer& cTimer::operator= (const cTimer &Timer)
      stop         = Timer.stop;
      priority     = Timer.priority;
      lifetime     = Timer.lifetime;
+#ifdef USE_PINPLUGIN
+     fskProtection = Timer.fskProtection;
+#endif /* PINPLUGIN */
      strncpy(file, Timer.file, sizeof(file));
      free(aux);
      aux = Timer.aux ? strdup(Timer.aux) : NULL;
@@ -326,6 +338,9 @@ bool cTimer::Parse(const char *s)
         result = false;
         }
      }
+#ifdef USE_PINPLUGIN
+  fskProtection = aux && strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>");
+#endif /* PINPLUGIN */
   free(channelbuffer);
   free(daybuffer);
   free(filebuffer);
@@ -681,6 +696,37 @@ void cTimer::OnOff(void)
   Matches(); // refresh start and end time
 }
 
+#ifdef USE_PINPLUGIN
+void cTimer::SetFskProtection(int aFlag)
+{
+   char* p;
+   char* tmp = 0;
+
+   fskProtection = aFlag;
+
+   if (fskProtection && (!aux || !strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // add protection info to aux
+
+      if (aux) { tmp = strdup(aux); free(aux); }
+      if (asprintf(&aux,"%s<pin-plugin><protected>yes</protected></pin-plugin>", tmp ? tmp : "") < 0 )
+         aux = NULL;
+   }
+   else if (!fskProtection && aux && (p = strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // remove protection info to aux
+
+      if (asprintf(&tmp, "%.*s%s", p-aux, aux, p+strlen("<pin-plugin><protected>yes</protected></pin-plugin>")) >= 0 ) {
+         free(aux);
+         aux = strdup(tmp);
+         }
+   }
+
+   if (tmp)
+      free(tmp);
+}
+#endif /* PINPLUGIN */
+
 // --- cTimers ---------------------------------------------------------------
 
 cTimers Timers;
diff --git a/timers.h b/timers.h
index e2734c6..1091886 100644
--- a/timers.h
+++ b/timers.h
@@ -38,6 +38,9 @@ private:
   int start;
   int stop;
   int priority;
+#ifdef USE_PINPLUGIN
+  int fskProtection;
+#endif /* PINPLUGIN */
   int lifetime;
   mutable char file[MaxFileName];
   char *aux;
@@ -59,6 +62,9 @@ public:
   int Start(void) const { return start; }
   int Stop(void) const { return stop; }
   int Priority(void) const { return priority; }
+#ifdef USE_PINPLUGIN
+  int FskProtection(void) const { return fskProtection; }
+#endif /* PINPLUGIN */
   int Lifetime(void) const { return lifetime; }
   const char *File(void) const { return file; }
   time_t FirstDay(void) const { return weekdays ? day : 0; }
@@ -95,6 +101,9 @@ public:
   void SetAux(const char *Aux);
   void SetDeferred(int Seconds);
   void SetFlags(uint Flags);
+#ifdef USE_PINPLUGIN
+  void SetFskProtection(int aFlag);
+#endif /* PINPLUGIN */
   void ClrFlags(uint Flags);
   void InvFlags(uint Flags);
   bool HasFlags(uint Flags) const;
diff --git a/vdr.5 b/vdr.5
index a606dde..d442466 100644
--- a/vdr.5
+++ b/vdr.5
@@ -233,6 +233,12 @@ by an '=' sign, as in
 
 .B ...:201;2001=deu,2002=eng:...
 
+Manual teletext subtitling pages can be defined separated by a '+' sign.
+The pages (separated by commas) can contain language codes, delimited by a '='
+sign, as in
+
+.B ...:201+150=deu,151=fin;2001,2002:...
+
 .TP
 .B Conditional access
 A hexadecimal integer defining how this channel can be accessed:
diff --git a/vdr.c b/vdr.c
index c075dbe..db4d429 100644
--- a/vdr.c
+++ b/vdr.c
@@ -45,6 +45,9 @@
 #include "dvbdevice.h"
 #include "eitscan.h"
 #include "epg.h"
+#ifdef USE_LIEMIKUUTIO
+#include "filetransfer.h"
+#endif /* LIEMIKUUTIO */
 #include "i18n.h"
 #include "interface.h"
 #include "keys.h"
@@ -65,6 +68,9 @@
 #include "tools.h"
 #include "transfer.h"
 #include "videodir.h"
+#ifdef USE_PINPLUGIN
+#include "status.h"
+#endif /* USE_PINPLUGIN */
 
 #define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
 #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
@@ -595,7 +601,12 @@ int main(int argc, char *argv[])
   RecordingCommands.Load(AddDirectory(ConfigDirectory, "reccmds.conf"));
   SVDRPhosts.Load(AddDirectory(ConfigDirectory, "svdrphosts.conf"), true);
   Keys.Load(AddDirectory(ConfigDirectory, "remote.conf"));
+#ifdef USE_ALTERNATECHANNEL
+  KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true) &&
+    Channels.LoadAlternativeChannels(AddDirectory(ConfigDirectory, "channel_alternative.conf"));
+#else
   KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true);
+#endif /* ALTERNATECHANNEL */
   Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
 
   if (!*cFont::GetFontFileName(Setup.FontOsd)) {
@@ -909,6 +920,21 @@ int main(int argc, char *argv[])
            Recordings.Update();
            DeletedRecordings.Update();
            }
+#ifdef USE_MCLI
+        cPlugin *mcliPlugin = cPluginManager::GetPlugin("mcli");
+        if (mcliPlugin) {
+           if (!ShutdownHandler.countdown) { // if kPower has been pressed, cMenuShutdown takes precedence over other menus
+              cOsdObject *MyMenu = mcliPlugin->AltMenuAction();
+              if (MyMenu) { // is there any cam-menu waiting?
+                 DELETE_MENU;
+                 if (cControl::Control())
+                    cControl::Control()->Hide();
+                    Menu = MyMenu;
+                    Menu->Show();
+                 }
+              }
+           }
+#endif /* MCLI */
         // CAM control:
         if (!Menu && !cOsd::IsOpen())
            Menu = CamControl();
@@ -919,6 +945,9 @@ int main(int argc, char *argv[])
         cOsdObject *Interact = Menu ? Menu : cControl::Control();
         eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
         if (ISREALKEY(key)) {
+#ifdef USE_PINPLUGIN
+           cStatus::MsgUserAction(key, Interact);
+#endif /* PINPLUGIN */
            EITScanner.Activity();
            // Cancel shutdown countdown:
            if (ShutdownHandler.countdown)
@@ -991,10 +1020,16 @@ int main(int argc, char *argv[])
                      cControl::Control()->Hide();
                   cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
                   if (plugin) {
+#ifdef USE_PINPLUGIN
+                  if (!cStatus::MsgPluginProtected(plugin)) {
+#endif /* PINPLUGIN */
                      Menu = plugin->MainMenuAction();
                      if (Menu)
                         Menu->Show();
                      }
+#ifdef USE_PINPLUGIN
+                     }
+#endif /* PINPLUGIN */
                   else
                      esyslog("ERROR: unknown plugin '%s'", PluginName);
                   }
@@ -1182,13 +1217,26 @@ int main(int argc, char *argv[])
                   Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
                   break;
                   }
+#ifdef USE_VOLCTRL
+             // Left/Right volume control
+#else
              // Direct Channel Select:
              case k1 ... k9:
              // Left/Right rotates through channel groups:
+#endif // USE_VOLCTRL
              case kLeft|k_Repeat:
              case kLeft:
              case kRight|k_Repeat:
              case kRight:
+#ifdef USE_VOLCTRL
+                  if (Setup.LRVolumeControl && Setup.LRChannelGroups < 2) {
+                    cRemote::Put(NORMALKEY(key) == kLeft ? kVolDn : kVolUp, true);
+                    break;
+                    }
+                  // else fall through
+             // Direct Channel Select:
+             case k1 ... k9:
+#endif // USE_VOLCTRL
              // Previous/Next rotates through channel groups:
              case kPrev|k_Repeat:
              case kPrev:
@@ -1206,9 +1254,15 @@ int main(int argc, char *argv[])
              // Instant resume of the last viewed recording:
              case kPlay:
                   if (cReplayControl::LastReplayed()) {
+#ifdef USE_PINPLUGIN
+                     if (cStatus::MsgReplayProtected(0, cReplayControl::LastReplayed(), 0, false) == false) {
+#endif /* PINPLUGIN */
                      cControl::Shutdown();
                      cControl::Launch(new cReplayControl);
                      }
+#ifdef USE_PINPLUGIN
+                     }
+#endif /* PINPLUGIN */
                   break;
              default:    break;
              }
@@ -1222,6 +1276,14 @@ int main(int argc, char *argv[])
               else
                  Skins.Message(mtInfo, tr("Editing process finished"));
               }
+#ifdef USE_LIEMIKUUTIO
+		   if (!cFileTransfer::Active() && cFileTransfer::Ended()) {
+			   if (cFileTransfer::Error())
+				   Skins.Message(mtError, tr("File transfer failed!"));
+			   else
+				   Skins.Message(mtInfo, tr("File transfer finished"));
+		   }
+#endif /* LIEMIKUUTIO */
            }
 
         // SIGHUP shall cause a restart:
@@ -1237,7 +1299,11 @@ int main(int argc, char *argv[])
               ShutdownHandler.countdown.Cancel();
            }
 
+#ifdef USE_LIEMIKUUTIO
+		if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !cFileTransfer::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
+#else
         if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
+#endif /* LIEMIKUUTIO */
            // Handle housekeeping tasks
 
            // Shutdown:
@@ -1284,6 +1350,9 @@ Exit:
 
   PluginManager.StopPlugins();
   cRecordControls::Shutdown();
+#ifdef USE_LIEMIKUUTIO
+  cFileTransfer::Stop();
+#endif /* LIEMIKUUTIO */
   cCutter::Stop();
   delete Menu;
   cControl::Shutdown();
diff --git a/vdrttxtsubshooks.c b/vdrttxtsubshooks.c
new file mode 100644
index 0000000..c96e043
--- /dev/null
+++ b/vdrttxtsubshooks.c
@@ -0,0 +1,63 @@
+/*                                                                  -*- c++ -*-
+ * vdr-ttxtsubs - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2003 - 2008 Ragnar Sundblad <ragge@nada.kth.se>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+
+#include "vdrttxtsubshooks.h"
+
+// XXX Really should be a list...
+static cVDRTtxtsubsHookListener *gListener;
+
+// ------ class cVDRTtxtsubsHookProxy ------
+
+class cVDRTtxtsubsHookProxy : public cVDRTtxtsubsHookListener
+{
+ public:
+  virtual void HideOSD(void) { if(gListener) gListener->HideOSD(); };
+  virtual void ShowOSD(void) { if(gListener) gListener->ShowOSD(); };
+  virtual void PlayerTeletextData(uint8_t *p, int length, bool IsPesRecording, const struct tTeletextSubtitlePage teletextSubtitlePages[] = NULL, int pageCount = 0)
+    { if(gListener) gListener->PlayerTeletextData(p, length, IsPesRecording, teletextSubtitlePages, pageCount); };
+  virtual int ManualPageNumber(const cChannel *channel)
+    { if(gListener) return gListener->ManualPageNumber(channel); else return 0; };
+};
+
+
+// ------ class cVDRTtxtsubsHookListener ------
+
+cVDRTtxtsubsHookListener::~cVDRTtxtsubsHookListener()
+{
+  gListener = 0;
+}
+
+void cVDRTtxtsubsHookListener::HookAttach(void)
+{
+  gListener = this;
+  //printf("cVDRTtxtsubsHookListener::HookAttach\n");
+}
+
+static cVDRTtxtsubsHookProxy gProxy;
+
+cVDRTtxtsubsHookListener *cVDRTtxtsubsHookListener::Hook(void)
+{
+  return &gProxy;
+}
+
diff --git a/vdrttxtsubshooks.h b/vdrttxtsubshooks.h
new file mode 100644
index 0000000..31c2061
--- /dev/null
+++ b/vdrttxtsubshooks.h
@@ -0,0 +1,46 @@
+/*                                                                  -*- c++ -*-
+ * vdr-ttxtsubs - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2003 - 2008 Ragnar Sundblad <ragge@nada.kth.se>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef __VDRTTXTSUBSHOOKS_H
+#define __VDRTTXTSUBSHOOKS_H
+
+#define TTXTSUBSVERSNUM 2
+
+class cDevice;
+class cChannel;
+struct tTeletextSubtitlePage;
+
+class cVDRTtxtsubsHookListener {
+ public:
+  cVDRTtxtsubsHookListener(void) {};
+  virtual ~cVDRTtxtsubsHookListener();
+
+  void HookAttach(void);
+
+  virtual void HideOSD(void) {};
+  virtual void ShowOSD(void) {};
+  virtual void PlayerTeletextData(uint8_t *p, int length, bool IsPesRecording = true, const struct tTeletextSubtitlePage teletextSubtitlePages[] = NULL, int pageCount = 0) {};
+  virtual int ManualPageNumber(const cChannel *channel) { return 0; };
+
+  // used by VDR to call hook listeners
+  static cVDRTtxtsubsHookListener *Hook(void);
+};
+
+#endif
diff --git a/videodir.c b/videodir.c
index 5f94d33..1c54585 100644
--- a/videodir.c
+++ b/videodir.c
@@ -36,6 +36,11 @@ public:
   bool Next(void);
   void Store(void);
   const char *Adjust(const char *FileName);
+#ifdef USE_DVLVIDPREFER
+  char *GetVidPath(int nVid);
+  bool GetPreferedVideoDir(void);
+  bool IsVidDirOK(int nVid, int *freeMB = NULL);
+#endif /* DVLVIDPREFER */
   };
 
 cVideoDirectory::cVideoDirectory(void)
@@ -117,6 +122,9 @@ cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags)
   if ((Flags & O_CREAT) != 0) {
      cVideoDirectory Dir;
      if (Dir.IsDistributed()) {
+#ifdef USE_DVLVIDPREFER
+        if (Setup.UseVidPrefer == 0) {
+#endif /* DVLVIDPREFER */
         // Find the directory with the most free space:
         int MaxFree = Dir.FreeMB();
         while (Dir.Next()) {
@@ -126,14 +134,24 @@ cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags)
                  MaxFree = Free;
                  }
               }
+#ifdef USE_DVLVIDPREFER
+        }
+          else Dir.GetPreferedVideoDir();
+#endif /* DVLVIDPREFER */
         if (Dir.Stored()) {
            ActualFileName = Dir.Adjust(FileName);
            if (!MakeDirs(ActualFileName, false))
               return NULL; // errno has been set by MakeDirs()
+#ifdef USE_DVLVIDPREFER
+           if (strcmp(ActualFileName, FileName) != 0) {
+#endif /* DVLVIDPREFER */
            if (symlink(ActualFileName, FileName) < 0) {
               LOG_ERROR_STR(FileName);
               return NULL;
               }
+#ifdef USE_DVLVIDPREFER
+              }
+#endif /* DVLVIDPREFER */
            ActualFileName = strdup(ActualFileName); // must survive Dir!
            }
         }
@@ -168,6 +186,122 @@ bool RemoveVideoFile(const char *FileName)
   return RemoveFileOrDir(FileName, true);
 }
 
+#ifdef USE_HARDLINKCUTTER
+static bool StatNearestDir(const char *FileName, struct stat *Stat)
+{
+  cString Name(FileName);
+  char *p;
+  while ((p = strrchr((char*)(const char*)Name + 1, '/')) != NULL) {
+        *p = 0; // truncate at last '/'
+        if (stat(Name, Stat) == 0) {
+           isyslog("StatNearestDir: Stating %s", (const char*)Name);
+           return true;
+           }
+        }
+  return false;
+}
+
+bool HardLinkVideoFile(const char *OldName, const char *NewName)
+{
+  // Incoming name must be in base video directory:
+  if (strstr(OldName, VideoDirectory) != OldName) {
+     esyslog("ERROR: %s not in %s", OldName, VideoDirectory);
+     return false;
+     }
+  if (strstr(NewName, VideoDirectory) != NewName) {
+     esyslog("ERROR: %s not in %s", NewName, VideoDirectory);
+     return false;
+     }
+
+  const char *ActualNewName = NewName;
+  cString ActualOldName(ReadLink(OldName), true);
+
+  // Some safety checks:
+  struct stat StatOldName;
+  if (lstat(ActualOldName, &StatOldName) == 0) {
+     if (S_ISLNK(StatOldName.st_mode)) {
+        esyslog("HardLinkVideoFile: Failed to resolve symbolic link %s", (const char*)ActualOldName);
+        return false;
+        }
+     }
+  else {
+     esyslog("HardLinkVideoFile: lstat failed on %s", (const char*)ActualOldName);
+     return false;
+     }
+  isyslog("HardLinkVideoFile: %s is on %i", (const char*)ActualOldName, (int)StatOldName.st_dev);
+
+  // Find the video directory where ActualOldName is located
+
+  cVideoDirectory Dir;
+  struct stat StatDir;
+  if (!StatNearestDir(NewName, &StatDir)) {
+     esyslog("HardLinkVideoFile: stat failed on %s", NewName);
+     return false;
+     }
+
+  isyslog("HardLinkVideoFile: %s is on %i", NewName, (int)StatDir.st_dev);
+  if (StatDir.st_dev != StatOldName.st_dev) {
+     // Not yet found.
+
+     if (!Dir.IsDistributed()) {
+        esyslog("HardLinkVideoFile: No matching video folder to hard link %s", (const char*)ActualOldName);
+        return false;
+        }
+
+     // Search in video01 and upwards
+     bool found = false;
+     while (Dir.Next()) {
+           Dir.Store();
+           const char *TmpNewName = Dir.Adjust(NewName);
+           if (StatNearestDir(TmpNewName, &StatDir) && StatDir.st_dev == StatOldName.st_dev) {
+              isyslog("HardLinkVideoFile: %s is on %i (match)", TmpNewName, (int)StatDir.st_dev);
+              ActualNewName = TmpNewName;
+              found = true;
+              break;
+              }
+           isyslog("HardLinkVideoFile: %s is on %i", TmpNewName, (int)StatDir.st_dev);
+           }
+     if (ActualNewName == NewName) {
+        esyslog("HardLinkVideoFile: No matching video folder to hard link %s", (const char*)ActualOldName);
+        return false;
+        }
+
+     // Looking good, we have a match. Create necessary folders.
+     if (!MakeDirs(ActualNewName, false))
+        return false;
+     // There's no guarantee that the directory of ActualNewName
+     // is on the same device as the dir that StatNearestDir found.
+     // But worst case is that the link fails.
+     }
+
+#ifdef HARDLINK_TEST_ONLY
+  // Do the hard link to *.vdr_ for testing only
+  char *name = NULL;
+  asprintf(&name, "%s_",ActualNewName);
+  link(ActualOldName, name);
+  free(name);
+  return false;
+#endif // HARDLINK_TEST_ONLY
+
+  // Try creating the hard link
+  if (link(ActualOldName, ActualNewName) != 0) {
+     // Failed to hard link. Maybe not allowed on file system.
+     LOG_ERROR_STR(ActualNewName);
+     isyslog("HardLinkVideoFile: failed to hard link from %s to %s", (const char*)ActualOldName, ActualNewName);
+     return false;
+     }
+
+  if (ActualNewName != NewName) {
+     // video01 and up. Do the remaining symlink
+     if (symlink(ActualNewName, NewName) < 0) {
+        LOG_ERROR_STR(NewName);
+        return false;
+        }
+     }
+  return true;
+}
+#endif /* HARDLINKCUTTER */
+
 bool VideoFileSpaceAvailable(int SizeMB)
 {
   cVideoDirectory Dir;
@@ -224,6 +358,24 @@ cString PrefixVideoFileName(const char *FileName, char Prefix)
   return NULL;
 }
 
+#ifdef USE_LIEMIKUUTIO
+cString NewVideoFileName(const char *FileName, const char *NewDirName)
+{
+	char *NewDir = ExchangeChars(strdup(NewDirName), true);
+	if (NewDir) {
+		const char *p = FileName + strlen(FileName); // p points at the terminating 0
+		while (p-- > FileName) {
+			if (*p == '/')
+				break;
+		}
+		cString NewName = cString::sprintf("%s/%s%s", VideoDirectory, NewDir, p);
+		free(NewDir);
+		return NewName;
+	}
+	return NULL;
+}
+#endif /* LIEMIKUUTIO */
+
 void RemoveEmptyVideoDirectories(void)
 {
   cVideoDirectory Dir;
@@ -232,6 +384,129 @@ void RemoveEmptyVideoDirectories(void)
      } while (Dir.Next());
 }
 
+#ifdef USE_DVLVIDPREFER
+// returns path to nVid'th video directory or NULL if not existing
+char *cVideoDirectory::GetVidPath(int nVid)
+{
+  char *b = strdup(VideoDirectory);
+  int l = strlen(b), di, n;
+
+  while (l-- > 0 && isdigit(b[ l ]));
+
+  l++;
+  di = strlen(b) - l;
+
+  // di == number of digits
+  n = atoi(&b[ l ]);
+  if (n != 0)
+     return NULL;
+
+  // add requested number to dir name
+  sprintf(&b[ l ], "%0*d", di, nVid);
+
+  if (DirectoryOk(b) == true)
+     return b;
+
+  free(b);
+  return NULL;
+}
+
+// checks if a video dir is 'valid'
+bool cVideoDirectory::IsVidDirOK(int nVid, int *freeMB)
+{
+  char *dn;
+  int fMB;
+
+  if (nVid >= Setup.nVidPrefer)
+     return false;
+
+  if (Setup.VidPreferSize[ nVid ] == -1)
+     return false;
+
+  dn = GetVidPath(nVid);
+  if (dn == NULL)
+     return false;
+
+  fMB = FreeDiskSpaceMB(dn, NULL);
+  if (freeMB != NULL)
+     *freeMB = fMB;
+
+  free(dn);
+
+  if (Setup.VidPreferSize[ nVid ] >= fMB)
+     return false;
+  return true;
+}
+
+
+// calculates which video dir to use
+bool cVideoDirectory::GetPreferedVideoDir(void)
+{
+  cVideoDirectory d;
+  int nDirs = 1,
+  vidUse = Setup.nVidPrefer;
+  int i, top, topFree, x;
+
+  if (name == NULL)
+     return(false);
+
+  // count available video dirs
+  while (d.Next() == true)
+        nDirs++;
+
+  if (vidUse > nDirs)
+     vidUse = nDirs;
+
+  // check for prefered video dir
+  for (i = 0, top = -1, topFree = 0; i < vidUse; i++) {
+      if (IsVidDirOK(i, &x) == true) {
+         if (top == -1) {
+            // nothing set yet, use first 'ok' dir
+            top = i;
+            topFree = x;
+            }
+         else {
+            // check if we got a higher priority
+            if (Setup.VidPreferPrio[ i ] >= Setup.VidPreferPrio[ top ]) {
+               top = i;
+               topFree = x;
+               }
+            // check if we got same priority but more space
+            else if (Setup.VidPreferPrio[ i ] == Setup.VidPreferPrio[ top ] && x >= topFree) {
+               top = i;
+               topFree = x;
+               }
+            }
+         }
+      }
+
+  if (top == -1) {
+     isyslog("VidPrefer: no prefered video directory could be determined!");
+
+     // something went wrong here...
+     // let VDR determine the video directory
+     int MaxFree = FreeMB();
+
+     while (Next()) {
+           int Free = FreeDiskSpaceMB(Name());
+
+           if (Free > MaxFree) {
+              Store();
+              MaxFree = Free;
+              }
+           }
+     }
+  else {
+     isyslog("VidPrefer: prefered video directory '%d' set.", top);
+     if (stored != NULL)
+        free(stored);
+     stored = GetVidPath(top);
+     }
+
+  return true;
+}
+#endif /* DVLVIDPREFER */
+
 bool IsOnVideoDirectoryFileSystem(const char *FileName)
 {
   cVideoDirectory Dir;
diff --git a/videodir.h b/videodir.h
index 0a0587a..4086a34 100644
--- a/videodir.h
+++ b/videodir.h
@@ -19,9 +19,15 @@ cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags);
 int CloseVideoFile(cUnbufferedFile *File);
 bool RenameVideoFile(const char *OldName, const char *NewName);
 bool RemoveVideoFile(const char *FileName);
+#ifdef USE_HARDLINKCUTTER
+bool HardLinkVideoFile(const char *OldName, const char *NewName);
+#endif /* HARDLINKCUTTER */
 bool VideoFileSpaceAvailable(int SizeMB);
 int VideoDiskSpace(int *FreeMB = NULL, int *UsedMB = NULL); // returns the used disk space in percent
 cString PrefixVideoFileName(const char *FileName, char Prefix);
+#ifdef USE_LIEMIKUUTIO
+cString NewVideoFileName(const char *FileName, const char *NewDirName);
+#endif /* LIEMIKUUTIO */
 void RemoveEmptyVideoDirectories(void);
 bool IsOnVideoDirectoryFileSystem(const char *FileName);
 
