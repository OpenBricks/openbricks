diff -urN vdr-2.0.0/config.c vdr-2.0.0.livebuffer/config.c
--- vdr-2.0.0/config.c	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/config.c	2013-04-02 23:26:49.378825394 +0200
@@ -485,6 +485,8 @@
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+  LiveBufferSize = 15;
+  LiveBufferMaxFileSize = 100;
   ExpertOptions  = 0;
   AddNewChannels = 0;
   UseBouquetList = 1;
@@ -716,6 +718,8 @@
   else if (!strcasecmp(Name, "VolumeSteps"))         VolumeSteps        = atoi(Value);
   else if (!strcasecmp(Name, "VolumeLinearize"))     VolumeLinearize    = atoi(Value);
   else if (!strcasecmp(Name, "InitialVolume"))       InitialVolume      = atoi(Value);
+  else if (!strcasecmp(Name, "LiveBufferSize"))        LiveBufferSize        = atoi(Value);
+  else if (!strcasecmp(Name, "LiveBufferMaxFileSize")) LiveBufferMaxFileSize = atoi(Value);
   else if (!strcasecmp(Name, "DeviceBondings"))      DeviceBondings     = Value;
   else if (!strcasecmp(Name, "ChannelsWrap"))        ChannelsWrap       = atoi(Value);
   else if (!strcasecmp(Name, "ShowChannelNamesWithSource")) ShowChannelNamesWithSource = atoi(Value);
@@ -840,6 +844,7 @@
   Store("ChannelsWrap",       ChannelsWrap);
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
+  Store("LiveBufferSize",     LiveBufferSize);
   Store("ExpertOptions",      ExpertOptions);
   Store("AddNewChannels",     AddNewChannels);
   Store("UseBouquetList",     UseBouquetList);
diff -urN vdr-2.0.0/config.h vdr-2.0.0.livebuffer/config.h
--- vdr-2.0.0/config.h	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/config.h	2013-04-02 23:26:59.314825096 +0200
@@ -353,6 +353,8 @@
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+  int LiveBufferSize;
+  int LiveBufferMaxFileSize;
   int ExpertOptions;
   int AddNewChannels;
   int UseBouquetList;
diff -urN vdr-2.0.0/device.c vdr-2.0.0.livebuffer/device.c
--- vdr-2.0.0/device.c	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/device.c	2013-04-02 23:26:16.562826370 +0200
@@ -19,6 +19,8 @@
 #include "receiver.h"
 #include "status.h"
 #include "transfer.h"
+#include "menu.h"
+#include "interface.h"
 #include "vdrttxtsubshooks.h"
 
 // --- cLiveSubtitle ---------------------------------------------------------
@@ -759,6 +761,12 @@
                               return false;
         case scrNoTransfer:   Skins.Message(mtError, tr("Can't start Transfer Mode!"));
                               return false;
+        case srcStillWritingLiveBuffer:
+           if(Interface->Confirm(tr("Still writing timeshift data to recording. Abort?")))
+              cRecordControls::CancelWritingBuffer();
+           else
+              if(cRecordControls::IsWritingBuffer()) return false;
+           break;
         case scrFailed:       break; // loop will retry
         default:              esyslog("ERROR: invalid return value from SetChannel");
         }
@@ -818,8 +826,13 @@
 
   if (NeedsTransferMode) {
      if (Device && CanReplay()) {
-        if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
-           cControl::Launch(new cTransferControl(Device, Channel));
+        if(LiveView && !cRecordControls::CanSetLiveChannel(Channel))
+           return cRecordControls::IsWritingBuffer() ? srcStillWritingLiveBuffer : scrFailed;
+	if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
+           if(LiveView)
+              cRecordControls::SetLiveChannel(Device, Channel);
+           else
+	   cControl::Launch(new cTransferControl(Device, Channel));
         else
            Result = scrNoTransfer;
         }
diff -urN vdr-2.0.0/device.h vdr-2.0.0.livebuffer/device.h
--- vdr-2.0.0/device.h	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/device.h	2013-04-02 23:26:27.782826040 +0200
@@ -34,7 +34,7 @@
 #define VOLUMEDELTA       (MAXVOLUME/Setup.VolumeSteps) // used to increase/decrease the volume
 #define MAXOCCUPIEDTIMEOUT 99 // max. time (in seconds) a device may be occupied
 
-enum eSetChannelResult { scrOk, scrNotAvailable, scrNoTransfer, scrFailed };
+enum eSetChannelResult { scrOk, scrNotAvailable, scrNoTransfer, scrFailed, srcStillWritingLiveBuffer };
 
 enum ePlayMode { pmNone,           // audio/video from decoder
                  pmAudioVideo,     // audio/video from player
diff -urN vdr-2.0.0/dvbplayer.c vdr-2.0.0.livebuffer/dvbplayer.c
--- vdr-2.0.0/dvbplayer.c	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/dvbplayer.c	2013-04-02 23:23:47.846830805 +0200
@@ -15,6 +15,7 @@
 #include "ringbuffer.h"
 #include "thread.h"
 #include "tools.h"
+#include "menu.h"
 
 // --- cPtsIndex -------------------------------------------------------------
 
@@ -36,6 +37,7 @@
   bool IsEmpty(void);
   void Put(uint32_t Pts, int Index);
   int FindIndex(uint32_t Pts);
+  void SetIndex(int Index) {lastFound = Index;};
   };
 
 cPtsIndex::cPtsIndex(void)
@@ -213,7 +215,8 @@
   cPtsIndex ptsIndex;
   cMarks marks;
   cFileName *fileName;
-  cIndexFile *index;
+  cIndex *index;
+  cIndexFile *indexFile;
   cUnbufferedFile *replayFile;
   double framesPerSecond;
   bool isPesRecording;
@@ -290,7 +293,10 @@
      return;
   ringBuffer = new cRingBufferFrame(PLAYERBUFSIZE);
   // Create the index file:
-  index = new cIndexFile(FileName, false, isPesRecording, pauseLive);
+  indexFile = NULL;
+  index = cRecordControls::GetLiveIndex(FileName);
+  if(!index)
+     index = indexFile = new cIndexFile(FileName, false, isPesRecording, pauseLive);
   if (!index)
      esyslog("ERROR: can't allocate index");
   else if (!index->Ok()) {
@@ -299,6 +305,12 @@
      }
   else if (PauseLive)
      framesPerSecond = cRecording(FileName).FramesPerSecond(); // the fps rate might have changed from the default
+  readIndex = Resume();
+  if (readIndex >= 0) {
+     ptsIndex.SetIndex(readIndex);
+     isyslog("resuming replay at index %d (%s)", readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
+  } else
+     replayFile = fileName->Open();
   marks.Load(FileName, framesPerSecond, isPesRecording);
 }
 
@@ -307,7 +319,7 @@
   Save();
   Detach();
   delete readFrame; // might not have been stored in the buffer in Action()
-  delete index;
+  delete indexFile;
   delete fileName;
   delete ringBuffer;
 }
@@ -489,7 +501,9 @@
                          if (NewIndex <= 0 && readIndex > 0)
                             NewIndex = 1; // make sure the very first frame is delivered
                          NewIndex = index->GetNextIFrame(NewIndex, playDir == pdForward, &FileNumber, &FileOffset, &Length);
-                         if (NewIndex < 0 && TimeShiftMode && playDir == pdForward)
+			if (NewIndex < 0 && TimeShiftMode) // Why should we wait for a timeout if not pdForward
+                            SwitchToPlayFrame = Index;
+			if (NewIndex < 0 && TimeShiftMode && playDir == pdForward)
                             SwitchToPlayFrame = readIndex;
                          Index = NewIndex;
                          readIndependent = true;
@@ -545,6 +559,13 @@
                          total = index->Last();
                       if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent, &Length) && NextFile(FileNumber, FileOffset))
                          readIndex++;
+                      else if(index && index->First() && (readIndex < index->First())) {
+                         int old = readIndex;
+                         readIndex = index->GetNextIFrame(index->First()+1, true, NULL, NULL, NULL);
+                         isyslog("Jump before start of livebuffer cortrected %d->%d First %d", old, readIndex, index->First());
+                         if(readIndex <= index->First())
+                            eof = true;
+                      }
                       else
                          eof = true;
                       }
@@ -691,7 +712,7 @@
              else if (Index <= 0 || SwitchToPlayFrame && Index >= SwitchToPlayFrame)
                 SwitchToPlay = true;
              if (SwitchToPlay) {
-                if (!SwitchToPlayFrame)
+                if (!SwitchToPlayFrame || (playDir == pdBackward))
                    Empty();
                 DevicePlay();
                 playMode = pmPlay;
diff -urN vdr-2.0.0/livebuffer.c vdr-2.0.0.livebuffer/livebuffer.c
--- vdr-2.0.0/livebuffer.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.0.livebuffer/livebuffer.c	2013-04-02 23:24:16.502829950 +0200
@@ -0,0 +1,401 @@
+#include "livebuffer.h"
+#if VDRVERSNUM >= 10716
+
+#include <vector>
+#include "videodir.h"
+#include "recording.h"
+#include "skins.h"
+#include "player.h"
+
+#define WAIT_WRITING_COUNT 1000
+#define WAIT_WRITING_SLEEP 10000
+
+#define WAIT_TERMINATE_COUNT 300
+#define WAIT_TERMINATE_SLEEP 10000
+
+struct tLiveIndex {
+  int index;
+  uint64_t offset:40; // up to 1TB per file (not using off_t here - must definitely be exactly 64 bit!)
+  int reserved:7;     // reserved for future use
+  int independent:1;  // marks frames that can be displayed by themselves (for trick modes)
+  uint16_t number:16; // up to 64K files per recording
+  tLiveIndex(int Index, bool Independent, uint16_t Number, off_t Offset)
+  {
+    index = Index;
+    offset = Offset;
+    reserved = 0;
+    independent = Independent;
+    number = Number;
+  }
+}; // tLiveIndex
+
+class cLiveIndex : public cIndex {
+public:
+	cLiveIndex(const char *FileName): bufferFileName(FileName, false), bufferBaseName(FileName) {
+		resumePos = -1;
+		lastPos = lastGet = lastBuf = 0;
+		lastFileNumber=1;
+		dropFile = false;
+		maxSize = Setup.LiveBufferSize * 60 * DEFAULTFRAMESPERSECOND;
+		idx.reserve(maxSize+1);
+	}; // cLiveIndex
+	virtual ~cLiveIndex() {
+	}; // ~cLiveIndex
+	virtual bool Write(bool Independent, uint16_t FileNumber, off_t FileOffset) {
+		cMutexLock lock(&idx_lock);
+		idx.push_back(tLiveIndex(++lastPos, Independent, FileNumber, FileOffset));
+		while(((idx.size() > maxSize) && (lastGet ? (lastGet > First()) : true) && (lastBuf ? (lastBuf > First()) : true)) || dropFile) {
+			if(idx.front().number != lastFileNumber) {
+				isyslog("Deleting old livebuffer file #%d (%d)", lastFileNumber, dropFile);
+				system(cString::sprintf("ls -l %s/%05d.ts | grep -- '->' | sed -e's/.*-> //' | xargs rm -rf", (const char *)bufferBaseName, lastFileNumber));  // for symlink video.xx
+				unlink(cString::sprintf("%s/%05d.ts", (const char *)bufferBaseName, lastFileNumber));
+				lastFileNumber = idx.front().number;
+				dropFile=false;
+			} // if
+			idx.erase(idx.begin());
+		} // if
+		return true;
+	}; // Write
+	virtual bool Get(int Index, uint16_t *FileNumber, off_t *FileOffset, bool *Independent = NULL, int *Length = NULL) {
+		cMutexLock lock(&idx_lock);
+		std::vector<tLiveIndex>::iterator item = GetIndex(Index);
+		if(item == idx.end()) return false;
+		*FileNumber = item->number;
+		*FileOffset = item->offset;
+		if (Independent)
+			*Independent = item->independent;
+		item++;
+		if(item == idx.end()) return false;
+		if (Length) {
+			uint16_t fn = item->number;
+			off_t fo = item->offset;
+			if (fn == *FileNumber)
+				*Length = int(fo - *FileOffset);
+			else
+				*Length = -1; // this means "everything up to EOF" (the buffer's Read function will act accordingly)
+		} // if
+		lastGet = Index;
+		return true;
+	}; // Get
+	virtual int GetNextIFrame(int Index, bool Forward, uint16_t *FileNumber = NULL, off_t *FileOffset = NULL, int *Length = NULL) {
+		cMutexLock lock(&idx_lock);
+		std::vector<tLiveIndex>::iterator item = GetIndex(Index);
+		if(item == idx.end()) {
+			if(Index < First() && Forward)
+				item = idx.begin();
+			else
+				return -1;
+		}
+		if(Forward) {
+			do {
+				item++;
+				if(item == idx.end()) return -1;
+			} while(!item->independent);
+		} else {
+			do {
+				if(item == idx.begin()) return -1;
+				item--;
+			} while(!item->independent);
+		} // if
+		uint16_t fn;
+		if (!FileNumber)
+			FileNumber = &fn;
+		off_t fo;
+		if (!FileOffset)
+			FileOffset = &fo;
+		*FileNumber = item->number;
+		*FileOffset = item->offset;
+		item++;
+		if(item == idx.end()) return -1;
+		if (Length) {
+			// all recordings end with a non-independent frame, so the following should be safe:
+			uint16_t fn = item->number;
+			off_t fo = item->offset;
+			if (fn == *FileNumber) {
+				*Length = int(fo - *FileOffset);
+			} else {
+				esyslog("ERROR: 'I' frame at end of file #%d", *FileNumber);
+				*Length = -1;
+			} // if
+		} // if
+		return Index;
+	}; // GetNextIFrame
+	virtual bool SetBufferStart(int Frames) {
+		cMutexLock lock(&idx_lock);
+		abortBuf = false;
+		if(Frames <= 0) {
+			lastBuf = 0;
+			return false;
+		} // if
+		lastBuf = Last()-Frames;
+		if(lastBuf < First())
+			lastBuf = First();
+		lastBuf = GetNextIFrame(lastBuf, true);
+		return true;
+	} // SetBufferStart
+	virtual cUnbufferedFile *GetNextBuffer(int &Length, bool &Independent) {
+		if(abortBuf || !lastBuf) return NULL;
+		cMutexLock lock(&idx_lock);
+		std::vector<tLiveIndex>::iterator buff = GetIndex(lastBuf);
+		if((buff == idx.end()) || ((buff+1) == idx.end())) return NULL;
+		off_t offset = buff->offset;
+		int number   = buff->number;
+		cUnbufferedFile *ret = bufferFileName.SetOffset(number, offset);
+		Independent = buff->independent;
+		buff++;
+		lastBuf = buff->index;
+		if(number != buff->number)
+			Length = -1;
+		else
+			Length = buff->offset-offset;
+		return ret;
+	} // GetNextBuffer
+	virtual int Get(uint16_t FileNumber, off_t FileOffset) {
+		for ( std::vector<tLiveIndex>::iterator item = idx.begin(); item != idx.end(); item++)
+			if (item->number > FileNumber || ((item->number == FileNumber) && off_t(item->offset) >= FileOffset))
+				return item->index;
+		return lastPos;
+	}; // Get
+	virtual bool Ok(void)                    {return true;};
+	virtual int  First(void)                 {return idx.size() ? idx.front().index : -1;};
+	virtual int  Last(void)                  {return idx.size() ? idx.back().index  : -1;};
+	virtual void SetResume(int Index)        {resumePos = lastGet = Index;};
+	virtual int  GetResume(void)             {return resumePos;};
+	virtual bool StoreResume(int Index)      {resumePos=Index; lastGet=0; return true;};
+	virtual bool IsStillRecording(void)      {return true;};
+	virtual void Delete(void)                {};
+	virtual void DropFile(void)              {dropFile=true;};
+	virtual bool IsWritingBuffer(void)       {return lastBuf != 0;};
+	virtual void CancelWritingBuffer(void)   {abortBuf = true;};
+	virtual bool WritingBufferCanceled(void) {return abortBuf;};
+protected:
+	int firstPos;
+	int lastPos;
+	int resumePos;
+	int lastFileNumber;
+	int lastGet;
+	int lastBuf;
+	bool abortBuf;
+	bool dropFile;
+	unsigned int maxSize;
+	cFileName bufferFileName;
+	cString bufferBaseName;
+	cMutex idx_lock;
+	std::vector<tLiveIndex> idx;
+	virtual std::vector<tLiveIndex>::iterator GetIndex(int Index) {
+		if(!idx.size()) return idx.end();
+		std::vector<tLiveIndex>::iterator item = idx.begin();
+
+		unsigned int guess = Index-First(); // Try to guess the position
+		if(guess > 0) {
+			if(guess < idx.size())
+				item += guess;
+			else
+				item = idx.end()-1;
+		} // if
+		while(item->index < Index) {
+			item++;
+			if(item == idx.end())
+				return idx.end();
+		} // while
+		while(item->index > Index) {
+			if(item == idx.begin())
+				return idx.end();
+			item--;
+		} // while
+		if(item->index != Index)
+			return idx.end();
+		return item;
+	}; // GetIndex
+}; // cLiveIndex
+
+/*****************************************************************************/
+
+cString cLiveRecorder::liveFileName;
+
+cLiveRecorder::cLiveRecorder(const cChannel *Channel):cRecorder(FileName(), Channel, -1)
+              ,broken(false) {
+	handleError = false;
+	if(index) delete index;
+	index = new cLiveIndex(FileName());
+	Activate(true);
+}; // cLiveRecorder::cLiveRecorder
+
+cLiveRecorder::~cLiveRecorder() {
+	int maxWait = WAIT_TERMINATE_COUNT;
+	CancelWritingBuffer();
+	while(IsWritingBuffer() && maxWait--)
+		usleep(WAIT_TERMINATE_SLEEP);
+	Activate(false);
+	Cleanup();
+}; // cLiveRecorder::~cLiveRecorder
+
+bool cLiveRecorder::IsWritingBuffer() {
+	return index && ((cLiveIndex *)index)->IsWritingBuffer();
+} // cLiveRecorder::IsWritingBuffer
+
+void cLiveRecorder::CancelWritingBuffer() {
+	if(index) ((cLiveIndex *)index)->CancelWritingBuffer();
+} // cLiveRecorder::CancelWritingBuffer
+
+bool cLiveRecorder::NextFile(void) {
+	if (recordFile && frameDetector->IndependentFrame()) { // every file shall start with an independent frame
+		if(RunningLowOnDiskSpace() && index)
+			((cLiveIndex *)index)->DropFile();
+		if (fileSize > MEGABYTE(off_t(Setup.LiveBufferMaxFileSize)) || RunningLowOnDiskSpace()) {
+			recordFile = fileName->NextFile();
+			fileSize = 0;
+		} // if
+	} // if
+	return recordFile != NULL;
+} // cLiveRecorder::NextFile
+
+int cLiveRecorder::LastIFrame() {
+	if(!index) return 0;
+	int ret = index->GetNextIFrame(index->Last()-1, false);
+	return (ret > 0) ? ret : 0;
+}; // cLiveRecorder::LastIFrame
+
+int cLiveRecorder::LastFrame() { 
+	return index ? index->Last() : 0;
+}; // cLiveRecorder::LastFrame
+
+void cLiveRecorder::SetResume(int Index) { 
+	if(index) ((cLiveIndex *)index)->SetResume(Index);
+}; // cLiveRecorder::SetResume
+
+bool cLiveRecorder::SetBufferStart(time_t Start) {
+	if(!index) return false;
+	if(time(NULL) <= Start) return false;
+	int Frames = SecondsToFrames(time(NULL)-Start, frameDetector ? frameDetector->FramesPerSecond() : DEFAULTFRAMESPERSECOND); //test stop livebuffer 
+	return ((cLiveIndex *)index)->SetBufferStart(Frames);
+} // cLiveRecorder::SetBufferStart
+
+cIndex *cLiveRecorder::GetIndex() { 
+	return index;
+}; // cLiveRecorder::GetIndex
+
+bool cLiveRecorder::Cleanup() {
+	if(FileName()) 
+                if(-1 == system(cString::sprintf("ls -l %s/* 2>/dev/null | grep -- '->' | sed -e's/.*-> //' | xargs rm -rf", FileName()))) // for symlink video.xx
+                        return false;
+        else 
+		if(-1 == system(cString::sprintf("rm -rf %s/* 2>/dev/null", FileName())))
+			return false;
+	return true;
+}; // cLiveRecorder::Cleanup
+
+bool cLiveRecorder::Prepare() {
+	if (!MakeDirs(FileName(), true)) return false;
+	return Cleanup();
+}; // cLiveRecorder::Prepare
+
+const char *cLiveRecorder::FileName() {
+	if(!(const char *)liveFileName && BufferDirectory)
+		liveFileName = cString::sprintf("%s/LiveBuffer", BufferDirectory);
+	return liveFileName;
+}; // cLiveRecorder::FileName
+
+void cLiveRecorder::Activate(bool On) {
+	cRecorder::Activate(On);
+	if(!On) broken=true;
+} // cLiveRecorder::Activate
+
+void cLiveRecorder::Receive(uchar *Data, int Length) {
+	if(broken) {
+		isyslog("Continue live recorder on broken stream (maybe due to switching to same channel on other device)");
+		TsExtendAdaptionField(Data, Length);
+		broken = false;
+	} // if
+	cRecorder::Receive(Data, Length);
+} // cLiveRecorder::Receive
+
+/*****************************************************************************/
+
+cBufferRecorder::cBufferRecorder(const char *FileName, const cChannel *Channel, int Priority, cIndex *LiveBufferIndex)
+                :cRecorder(FileName, Channel, Priority)
+                ,liveBufferIndex(LiveBufferIndex)
+                ,dropData(false) {
+	if(liveBufferIndex) dropData=true; // Drop new data till we have written most of the live buffer data
+} // cBufferRecorder::cBufferRecorder
+
+cBufferRecorder::~cBufferRecorder() {
+	if(liveBufferIndex) ((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+} // cBufferRecorder::~cBufferRecorder
+
+void cBufferRecorder::Action(void) {
+	if(liveBufferIndex)
+		FillInitialData(NULL, 0);
+	dropData=false;
+	cRecorder::Action();
+	if(liveBufferIndex) ((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+	liveBufferIndex = NULL;
+} // cBufferRecorder::Action
+
+void cBufferRecorder::Activate(bool On) {
+	if(!On && liveBufferIndex) ((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+	cRecorder::Activate(On);
+} // cBufferRecorder::Activate
+
+void cBufferRecorder::Receive(uchar *Data, int Length) {
+	if(!dropData) cRecorder::Receive(Data, Length);
+} // cBufferRecorder::Receive
+
+void cBufferRecorder::FillInitialData(uchar *Data, int Size) {
+	if(liveBufferIndex) {
+		int64_t search_pts = Data ? TsGetPts(Data, Size) : -1;
+		int maxWait = WAIT_WRITING_COUNT;
+		uchar buffer[MAXFRAMESIZE];
+		int Length;
+		bool Independent;
+		bool found = false;
+		while(!Data || (Size >= TS_SIZE)) {
+			cUnbufferedFile *file = ((cLiveIndex *)liveBufferIndex)->GetNextBuffer(Length, Independent);
+			if(!file) {
+				if(((cLiveIndex *)liveBufferIndex)->WritingBufferCanceled()) {
+					isyslog("Writing buffer canceled by user");
+					if(fileSize) TsExtendAdaptionField(Data, Size);
+					((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+					liveBufferIndex = NULL;
+					return;
+				} // if
+				if(!Data || !Size) return;
+				if(!maxWait--)
+					break;
+				usleep(WAIT_WRITING_SLEEP);
+				continue;
+			} // if
+			if (!NextFile())
+				break;
+			int len = ReadFrame(file, buffer, Length, sizeof(buffer));
+			if(len < TS_SIZE) {
+				isyslog("Failed to read live buffer data");
+				break;
+			} // if
+			if(Data && Independent && (search_pts == TsGetPts(buffer, len))) {
+				found = true;
+				break;
+			} // if
+			if (index)
+				index->Write(Independent, fileName->Number(), fileSize);
+			if (recordFile->Write(buffer, len) < 0) {
+				isyslog("Failed to write live buffer data");
+				break;
+			} // if
+			fileSize += len;
+		} // while
+		if(Data) {
+			isyslog("%lld bytes from live buffer %swritten to recording", fileSize, found ? "seamless ": "");
+			if(!found && fileSize) TsExtendAdaptionField(Data, Size);
+			((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+			liveBufferIndex = NULL;
+		} else if(((cLiveIndex *)liveBufferIndex)->WritingBufferCanceled()) {
+			isyslog("%lld bytes from live buffer written to recording (aborted)", fileSize);
+			((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+			liveBufferIndex = NULL;
+		} // if
+	} else if (Data && fileSize)
+		TsExtendAdaptionField(Data, Size);
+} // cBufferRecorder::FillInitialData
+
+#endif /*VDRVERSNUM*/
diff -urN vdr-2.0.0/livebuffer.h vdr-2.0.0.livebuffer/livebuffer.h
--- vdr-2.0.0/livebuffer.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.0.livebuffer/livebuffer.h	2013-04-02 23:25:32.258827690 +0200
@@ -0,0 +1,45 @@
+#ifndef LIVEBUFFER_H
+#define LIVEBUFFER_H
+
+#include "config.h"
+//#if VDRVERSNUM >= 10716
+
+#include "recorder.h"
+
+class cLiveRecorder : public cRecorder {
+public:
+	cLiveRecorder(const cChannel *Channel);
+	virtual bool NextFile(void);
+	virtual ~cLiveRecorder();
+	virtual bool IsWritingBuffer();
+	virtual void CancelWritingBuffer();
+	virtual int LastIFrame();
+	virtual int LastFrame();
+	virtual void SetResume(int Index);
+	virtual bool SetBufferStart(time_t Start);
+	virtual cIndex *GetIndex();
+	static bool Cleanup();
+	static bool Prepare();
+	static const char *FileName();
+protected:
+	virtual void Activate(bool On);
+	virtual void Receive(uchar *Data, int Length);
+	bool broken;
+	static cString liveFileName;
+}; // cLiveRecorder
+
+class cBufferRecorder : public cRecorder {
+public:
+	cBufferRecorder(const char *FileName, const cChannel *Channel, int Priority, cIndex *LiveBufferIndex);
+	virtual ~cBufferRecorder();
+	virtual void FillInitialData(uchar *Data, int Size);
+protected:
+	virtual void Action(void);
+	virtual void Activate(bool On);
+	virtual void Receive(uchar *Data, int Length);
+	cIndex *liveBufferIndex;
+	bool dropData;
+}; // cBufferRecorder
+
+//#endif /*VDRVERSNUM*/
+#endif /*LIVEBUFFER_H*/
diff -urN vdr-2.0.0/Makefile vdr-2.0.0.livebuffer/Makefile
--- vdr-2.0.0/Makefile	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/Makefile	2013-04-02 23:10:10.002855178 +0200
@@ -97,6 +97,11 @@
 LIBS += $(shell pkg-config --libs fribidi)
 endif
 
+ifdef LIVEBUFFER
+DEFINES += -DUSE_LIVEBUFFER
+OBJS += livebuffer.o
+endif
+
 LIRC_DEVICE ?= /var/run/lirc/lircd
 
 DEFINES += -DLIRC_DEVICE=\"$(LIRC_DEVICE)\"
diff -urN vdr-2.0.0/menu.c vdr-2.0.0.livebuffer/menu.c
--- vdr-2.0.0/menu.c	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/menu.c	2013-04-02 23:21:21.830835158 +0200
@@ -3339,7 +3339,7 @@
 
 class cMenuSetupRecord : public cMenuSetupBase {
 private:
-  const char *pauseKeyHandlingTexts[3];
+  const char *pauseKeyHandlingTexts[4];
   const char *delTimeshiftRecTexts[3];
 public:
   cMenuSetupRecord(void);
@@ -3351,6 +3351,7 @@
   pauseKeyHandlingTexts[0] = tr("do not pause live video");
   pauseKeyHandlingTexts[1] = tr("confirm pause live video");
   pauseKeyHandlingTexts[2] = tr("pause live video");
+  pauseKeyHandlingTexts[3] = tr("Timeshift");
   delTimeshiftRecTexts[0] = tr("no");
   delTimeshiftRecTexts[1] = tr("confirm");
   delTimeshiftRecTexts[2] = tr("yes");
@@ -3359,7 +3360,8 @@
   Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at stop (min)"),      &data.MarginStop));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Default priority"),          &data.DefaultPriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Default lifetime (d)"),      &data.DefaultLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
+  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 4, pauseKeyHandlingTexts));
+  Add(new cMenuEditIntItem( tr("Timeshift size (min)"),                     &data.LiveBufferSize, 1, 300)); // TODO fix name and min/max values
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
@@ -4574,7 +4576,7 @@
   isyslog("record %s", fileName);
   if (MakeDirs(fileName, true)) {
      const cChannel *ch = timer->Channel();
-     recorder = new cRecorder(fileName, ch, timer->Priority());
+     recorder = new cBufferRecorder(fileName, ch, timer->Priority(), cRecordControls::GetLiveBuffer(timer));
      if (device->AttachReceiver(recorder)) {
         Recording.WriteInfo();
         cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
@@ -4673,6 +4675,8 @@
 cRecordControl *cRecordControls::RecordControls[MAXRECORDCONTROLS] = { NULL };
 int cRecordControls::state = 0;
 
+cLiveRecorder *cRecordControls::liveRecorder = NULL;
+
 bool cRecordControls::Start(cTimer *Timer, bool Pause, bool* reused)
 {
   if (!Timer) {
@@ -4835,8 +4839,27 @@
   return false;
 }
 
+
+bool cRecordControls::StartLiveBuffer(eKeys Key) {
+   if(Setup.PauseKeyHandling == 3 && liveRecorder) {
+     int pos = liveRecorder->LastIFrame();
+     isyslog("Enter timeshift at %d / %d", pos, liveRecorder->LastFrame());
+     liveRecorder->SetResume(pos?pos:liveRecorder->LastFrame());
+     cReplayControl::SetRecording(cLiveRecorder::FileName());
+     cReplayControl *rc = new cReplayControl;
+     cControl::Launch(rc);
+     cControl::Attach();
+     rc->ProcessKey(Key);
+     rc->Show(); // show progressbar at the start of livebuffer
+     return true;
+  } // if
+  return false;
+} // cRecordControls::StartLiveBuffer
+
 bool cRecordControls::PauseLiveVideo(void)
 {
+  if(StartLiveBuffer(kPause))
+     return true;
   Skins.Message(mtStatus, tr("Pausing live video..."));
   bool reused = false;
   cReplayControl::SetRecording(NULL); // make sure the new cRecordControl will set cReplayControl::LastReplayed()
@@ -4851,6 +4874,51 @@
   return false;
 }
 
+void cRecordControls::SetLiveChannel(cDevice *Device, const cChannel *Channel) {
+	if(liveRecorder) {
+		if(Channel && Device && (liveRecorder->ChannelID()==Channel->GetChannelID()))
+			Device->AttachReceiver(liveRecorder);
+		else
+			DELETENULL(liveRecorder);
+	} // if
+	if(Device && Channel) cControl::Launch(new cTransferControl(Device, Channel));
+	if(Setup.PauseKeyHandling == 3 && Channel && Device && !liveRecorder) { 
+		if (cLiveRecorder::Prepare()) {
+			liveRecorder = new cLiveRecorder(Channel);
+			if(!Device->AttachReceiver(liveRecorder))
+				DELETENULL(liveRecorder);
+		} // if
+	} // if
+} // cRecordControls::SetLiveChannel
+
+bool cRecordControls::CanSetLiveChannel(const cChannel *Channel) {
+	if(liveRecorder && Channel && (liveRecorder->ChannelID()==Channel->GetChannelID())) return true;
+	return !IsWritingBuffer();
+} // cRecordControls::CanSetLiveChannel
+
+bool cRecordControls::IsWritingBuffer() {
+	return liveRecorder ? liveRecorder->IsWritingBuffer() : false;
+} // cRecordControls::IsWritingBuffer
+
+void cRecordControls::CancelWritingBuffer() {
+	if(liveRecorder && liveRecorder->IsWritingBuffer()) {
+		liveRecorder->CancelWritingBuffer();
+		sleep(1); // allow recorder to really stop
+	} // if
+} // cRecordControls::CancelWritingBuffer
+
+cIndex *cRecordControls::GetLiveBuffer(cTimer *Timer) {
+	if(!liveRecorder || !Timer || !Timer->Channel()) return NULL;
+	if(!(liveRecorder->ChannelID() == Timer->Channel()->GetChannelID())) return NULL;
+	if(!liveRecorder->SetBufferStart(Timer->StartTime())) return NULL;
+	return liveRecorder->GetIndex();
+} // cRecordControls::GetLiveBuffer
+
+cIndex *cRecordControls::GetLiveIndex(const char *FileName) {
+	if(!FileName || strcmp(cLiveRecorder::FileName(), FileName)) return NULL;
+	return liveRecorder ? liveRecorder->GetIndex() : NULL;
+} // cRecordControls::GetLiveIndex
+
 const char *cRecordControls::GetInstantId(const char *LastInstantId)
 {
   for (int i = 0; i < MAXRECORDCONTROLS; i++) {
@@ -5090,21 +5158,30 @@
 
 void cReplayControl::ShowMode(void)
 {
-  if (visible || Setup.ShowReplayMode && !cOsd::IsOpen()) {
+  if (visible || (Setup.ShowReplayMode && !cOsd::IsOpen())) {
      bool Play, Forward;
      int Speed;
      if (GetReplayMode(Play, Forward, Speed) && (!visible || Play != lastPlay || Forward != lastForward || Speed != lastSpeed)) {
         bool NormalPlay = (Play && Speed == -1);
+        bool Paused = (!Play && Speed == -1);
 
         if (!visible) {
            if (NormalPlay)
               return; // no need to do indicate ">" unless there was a different mode displayed before
            visible = modeOnly = true;
+
+           // if newly paused show full replay osd; ie modeOnly = false
+           if (Paused)  {
+               modeOnly = (lastPlay == Play);
+           }
+
            displayReplay = Skins.Current()->DisplayReplay(modeOnly);
            }
 
-        if (modeOnly && !timeoutShow && NormalPlay)
+        // osd times out when replaying normally OR when paused and full osd is shown
+        if (!timeoutShow && (NormalPlay|| (!modeOnly && Paused)))
            timeoutShow = time(NULL) + MODETIMEOUT;
+
         displayReplay->SetMode(Play, Forward, Speed);
         lastPlay = Play;
         lastForward = Forward;
@@ -5118,6 +5195,43 @@
   int Current, Total;
 
   if (GetIndex(Current, Total) && Total > 0) {
+     int first=0;
+     cIndex *idx = cRecordControls::GetLiveIndex(fileName);
+     if(idx) first = idx->First(); // Normalize displayed values
+     Current -= first;
+     if(Current < 0) Current = 0;
+     Total   -= first;
+     if(Total < 0) Total = 0;
+     time_t now = time(NULL);
+     static time_t last_sched_check = 0;
+     if(displayReplay && idx && (last_sched_check != now)) {
+        last_sched_check = now; // Only check every second
+        cSchedulesLock SchedulesLock;
+        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
+        if (Schedules) {
+           const char *display_title = NULL;// = title;
+           const cSchedule *Schedule = Schedules->GetSchedule(Channels.GetByNumber(cDevice::CurrentChannel()));
+           if (Schedule) {
+              time_t Time = now - round(((double)Total - Current) / FramesPerSecond());
+              const cEvent *event = Schedule->GetEventAround(Time);
+              if (event) display_title = event->Title();
+           } // if
+
+           // no event title; show channel name
+           if (!display_title) {
+               cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
+               display_title = channel->Name();
+           }
+
+           // set title as "Timeshift mode: <event title> "
+           // OR "Timeshift mode: <channel name>"
+           // if neither is possible leave title as such
+           if (display_title)
+               displayReplay->SetTitle(cString::sprintf("%s: %s",
+                                                        tr("Timeshift mode"),
+                                                        display_title));
+        } // if
+     } // if
      if (!visible) {
         displayReplay = Skins.Current()->DisplayReplay(modeOnly);
         displayReplay->SetMarks(&marks);
@@ -5227,6 +5341,11 @@
 
 void cReplayControl::TimeSearch(void)
 {
+	if (cRecordControls::GetLiveIndex(fileName)) {
+       if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+          return;
+       }
+    }
   timeSearchTime = timeSearchPos = 0;
   timeSearchHide = false;
   if (modeOnly)
@@ -5245,6 +5364,11 @@
 
 void cReplayControl::MarkToggle(void)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) { 
+     	return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total, true)) {
      lastCurrent = -1; // triggers redisplay
@@ -5266,6 +5390,11 @@
 
 void cReplayControl::MarkJump(bool Forward)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total)) {
      if (marks.Count()) {
@@ -5292,6 +5421,11 @@
 
 void cReplayControl::MarkMove(bool Forward)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total)) {
      if (cMark *m = marks.Get(Current)) {
@@ -5315,6 +5449,11 @@
 
 void cReplayControl::EditCut(void)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return;
+     }
+  }
   if (*fileName) {
      Hide();
      if (!cCutter::Active()) {
@@ -5335,6 +5474,11 @@
 
 void cReplayControl::EditTest(void)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+   	    return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total)) {
      cMark *m = marks.Get(Current);
@@ -5373,7 +5517,14 @@
   if (Key == kNone && !marksModified)
      marks.Update();
   if (visible) {
+
+      if (Key != kNone /*&& !modeOnly*/ && timeoutShow) {
+          printf("timeout reset +%d\n", MODETIMEOUT);
+          timeoutShow = time(NULL) + MODETIMEOUT;
+      }
+
      if (timeoutShow && time(NULL) > timeoutShow) {
+         printf("timed out \n");
         Hide();
         ShowMode();
         timeoutShow = 0;
@@ -5399,12 +5550,17 @@
         Key = Play ? kPause : kPlay;
      }
   bool DoShowMode = true;
+  if (cRecordControls::GetLiveIndex(fileName) && (Key >= k0) && (Key <= k9)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return osSwitchChannel;
+     }
+  }
   switch (int(Key)) {
     // Positioning:
-    case kPlay:
     case kUp:      Play(); break;
-    case kPause:
+    case kPlay:    Play(); break;
     case kDown:    Pause(); break;
+    case kPause:   Pause(); break;
     case kFastRew|k_Release:
     case kLeft|k_Release:
                    if (Setup.MultiSpeedMode) break;
@@ -5415,7 +5571,60 @@
                    if (Setup.MultiSpeedMode) break;
     case kFastFwd:
     case kRight:   Forward(); break;
-    case kRed:     TimeSearch(); break;
+    //case kRed:     TimeSearch(); break;
+        case kRed:     if(cRecordControls::GetLiveIndex(fileName)) {
+                           if (!(visible && !modeOnly)) return osUnknown;
+                           else {} // fall through to case kRecord
+                                   // since Timeshift ON and replay OSD is shown
+                           } // if
+                           else { //timeshift off
+                               TimeSearch();
+                               break;
+                           } // else
+                           // No break
+        case kRecord:  if(cRecordControls::GetLiveIndex(fileName)) {
+                          int frames = 0;
+                          int Current, Total;
+                          if(GetIndex(Current, Total))
+                             frames = Total-Current;
+                          cTimer *timer = new cTimer(true, false, Channels.GetByNumber(cDevice::CurrentChannel()), frames / FramesPerSecond());
+                          Timers.Add(timer);
+                          Timers.SetModified();
+                          if (cRecordControls::Start(timer))
+                             Skins.Message(mtInfo, tr("Recording started"));
+                          else
+                             Timers.Del(timer);
+                       } // if
+                       break;
+        case kPrev|k_Repeat:
+        case kPrev:    if (lastSkipTimeout.TimedOut()) {
+                          lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                          lastSkipKey = kPrev;
+                       }
+                       else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                          lastSkipSeconds /= 2;
+                          lastSkipKey = kNone;
+                       }
+                       lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                       SkipSeconds(-lastSkipSeconds); break;
+        case kNext|k_Repeat:
+        case kNext:    if (lastSkipTimeout.TimedOut()) {
+                          lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                          lastSkipKey = kNext;
+                       }
+                       else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                          lastSkipSeconds /= 2;
+                          lastSkipKey = kNone;
+                       }
+                       lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                       SkipSeconds(lastSkipSeconds); break;
+        case kBlue:    if(cRecordControls::GetLiveIndex(fileName))
+                           if(!(visible && !modeOnly))
+                               return osUnknown;
+                       //NO break
+        case kStop:    Hide();
+                       Stop();
+                       return osEnd;
     case kGreen|k_Repeat:
                    SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
     case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
@@ -5426,7 +5635,7 @@
     case kYellow|k_Repeat:
                    SkipSeconds(Setup.JumpSecondsRepeat); break;
     case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
-    case kPrev|k_Repeat:
+/*    case kPrev|k_Repeat:
     case kPrev:    if (lastSkipTimeout.TimedOut()) {
                       lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
                       lastSkipKey = kPrev;
@@ -5452,6 +5661,7 @@
     case kBlue:    Hide();
                    Stop();
                    return osEnd;
+*/
     default: {
       DoShowMode = false;
       switch (int(Key)) {
@@ -5478,7 +5688,19 @@
                            else
                               Show();
                            break;
-            case kBack:    if (Setup.DelTimeshiftRec) {
+//            case kBack:    if (Setup.DelTimeshiftRec) {
+            case kBack:
+                           if (visible && !modeOnly) {
+                              Hide();
+                              DoShowMode = true;
+                              break;
+                           }
+                           if(cRecordControls::GetLiveIndex(fileName)) {
+                              Hide();
+                              Stop();
+                              return osEnd;
+                           } // if
+                           if (Setup.DelTimeshiftRec) {
                               cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
                               return rc && rc->InstantId() ? osEnd : osRecordings;
                               }
diff -urN vdr-2.0.0/menu.h vdr-2.0.0.livebuffer/menu.h
--- vdr-2.0.0/menu.h	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/menu.h	2013-04-02 23:19:00.838839356 +0200
@@ -18,6 +18,7 @@
 #include "menuitems.h"
 #include "recorder.h"
 #include "skins.h"
+#include "livebuffer.h"
 
 class cMenuEditSrcItem : public cMenuEditIntItem {
 private:
@@ -276,10 +277,14 @@
   static bool TryReuseRecording(bool Pause);
          ///< Tries to reuse an existing recording instead of creating a second one in parallel.
          ///< Returns true if successful.
+protected:
+  friend class cRecordControl;
+  static cLiveRecorder *liveRecorder;
 public:
   static bool Start(cTimer *Timer = NULL, bool Pause = false, bool* reused = NULL);
   static void Stop(const char *InstantId);
   static bool PauseLiveVideo(void);
+  static bool StartLiveBuffer(eKeys Key);
   static const char *GetInstantId(const char *LastInstantId);
   static cRecordControl *GetRecordControl(const char *FileName);
   static cRecordControl *GetRecordControl(const cTimer *Timer);
@@ -294,6 +299,12 @@
   static void Shutdown(void);
   static void ChangeState(void) { state++; }
   static bool StateChanged(int &State);
+  static void SetLiveChannel(cDevice *Device, const cChannel *Channel);
+  static bool CanSetLiveChannel(const cChannel *Channel);
+  static bool IsWritingBuffer();
+  static void CancelWritingBuffer();
+  static cIndex *GetLiveBuffer(cTimer *Timer);
+  static cIndex *GetLiveIndex(const char *FileName);
   };
 
 class cReplayControl : public cDvbPlayerControl {
diff -urN vdr-2.0.0/osdbase.h vdr-2.0.0.livebuffer/osdbase.h
--- vdr-2.0.0/osdbase.h	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/osdbase.h	2013-04-02 23:22:11.662833671 +0200
@@ -38,6 +38,7 @@
                 osActiveBouquet,
                 osFavourites,
                 osAddFavourite,
+                osSwitchChannel,
                 os_User, // the following values can be used locally
                 osUser1,
                 osUser2,
diff -urN vdr-2.0.0/player.c vdr-2.0.0.livebuffer/player.c
--- vdr-2.0.0/player.c	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/player.c	2013-04-02 23:21:44.142834489 +0200
@@ -10,6 +10,9 @@
 #include "player.h"
 #include "i18n.h"
 
+#include "menu.h"
+#include "transfer.h"
+
 // --- cPlayer ---------------------------------------------------------------
 
 cPlayer::cPlayer(ePlayMode PlayMode)
@@ -78,6 +81,10 @@
 
 void cControl::Launch(cControl *Control)
 {
+  if(!dynamic_cast<cTransferControl *>(Control)) {
+     if(!dynamic_cast<cReplayControl *>(Control) || strcmp(cLiveRecorder::FileName(), cReplayControl::NowReplaying()))
+        cRecordControls::SetLiveChannel(NULL, NULL);
+  } // if
   cMutexLock MutexLock(&mutex);
   cControl *c = control; // keeps control from pointing to uninitialized memory
   control = Control;
diff -urN vdr-2.0.0/po/de_DE.po vdr-2.0.0.livebuffer/po/de_DE.po
--- vdr-2.0.0/po/de_DE.po	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/po/de_DE.po	2013-04-02 23:10:10.010855177 +0200
@@ -25,6 +25,9 @@
 msgid "Can't start Transfer Mode!"
 msgstr "Transfer-Mode kann nicht gestartet werden!"
 
+msgid "Still writing timeshift data to recording. Abort?"
+msgstr "Timeshift-Daten werden noch in Aufnahme kopiert. Abbrechen?"
+
 msgid "off"
 msgstr "aus"
 
diff -urN vdr-2.0.0/recorder.c vdr-2.0.0.livebuffer/recorder.c
--- vdr-2.0.0/recorder.c	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/recorder.c	2013-04-02 23:18:29.246840295 +0200
@@ -24,6 +24,7 @@
 cRecorder::cRecorder(const char *FileName, const cChannel *Channel, int Priority)
 :cReceiver(Channel, Priority)
 ,cThread("recording")
+,handleError(true)
 {
   recordingName = strdup(FileName);
 
@@ -141,6 +142,7 @@
                     InfoWritten = true;
                     }
                  if (FirstIframeSeen || frameDetector->IndependentFrame()) {
+                    if(!FirstIframeSeen) FillInitialData(b, r);
                     FirstIframeSeen = true; // start recording with the first I-frame
                     if (!NextFile())
                        break;
@@ -166,7 +168,7 @@
               ringBuffer->Del(Count);
               }
            }
-        if (time(NULL) - t > MAXBROKENTIMEOUT) {
+        if (handleError && (time(NULL) - t > MAXBROKENTIMEOUT)) {
            esyslog("ERROR: video data stream broken");
            ShutdownHandler.RequestEmergencyExit();
            t = time(NULL);
diff -urN vdr-2.0.0/recorder.h vdr-2.0.0.livebuffer/recorder.h
--- vdr-2.0.0/recorder.h	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/recorder.h	2013-04-02 23:18:03.862841054 +0200
@@ -17,18 +17,20 @@
 #include "thread.h"
 
 class cRecorder : public cReceiver, cThread {
-private:
+protected:
   cRingBufferLinear *ringBuffer;
   cFrameDetector *frameDetector;
   cPatPmtGenerator patPmtGenerator;
   cFileName *fileName;
-  cIndexFile *index;
+  cIndex *index;
+  bool handleError;
   cUnbufferedFile *recordFile;
   char *recordingName;
   off_t fileSize;
   time_t lastDiskSpaceCheck;
-  bool RunningLowOnDiskSpace(void);
-  bool NextFile(void);
+  virtual bool RunningLowOnDiskSpace(void);
+  virtual bool NextFile(void);
+  virtual void FillInitialData(uchar *Data, int Size) {};
 protected:
   virtual void Activate(bool On);
   virtual void Receive(uchar *Data, int Length);
diff -urN vdr-2.0.0/recording.c vdr-2.0.0.livebuffer/recording.c
--- vdr-2.0.0/recording.c	2013-04-02 23:28:21.382822652 +0200
+++ vdr-2.0.0.livebuffer/recording.c	2013-04-02 23:10:10.010855177 +0200
@@ -1202,8 +1202,10 @@
 {
   if (numFrames < 0) {
      int nf = cIndexFile::GetLength(FileName(), IsPesRecording());
-     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
-        return nf; // check again later for ongoing recordings
+//     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
+//        return nf; // check again later for ongoing recordings
+     if (time(NULL) - LastModifiedTime(FileName()) < MININDEXAGE)
+     return nf; // check again later for ongoing recordings
      numFrames = nf;
      }
   return numFrames;
@@ -1221,8 +1223,10 @@
 {
   if (fileSizeMB < 0) {
      int fs = DirSizeMB(FileName());
-     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
-        return fs; // check again later for ongoing recordings
+//     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
+//        return fs; // check again later for ongoing recordings
+     if (time(NULL) - LastModifiedTime(FileName()) < MININDEXAGE)
+     return fs; // check again later for ongoing recordings
      fileSizeMB = fs;
      }
   return fileSizeMB;
diff -urN vdr-2.0.0/recording.h vdr-2.0.0.livebuffer/recording.h
--- vdr-2.0.0/recording.h	2013-04-02 23:28:21.362822653 +0200
+++ vdr-2.0.0.livebuffer/recording.h	2013-04-02 23:17:13.162842565 +0200
@@ -287,7 +287,22 @@
 struct tIndexTs;
 class cIndexFileGenerator;
 
-class cIndexFile {
+class cIndex {
+public:
+  virtual bool Ok(void) =0;
+  virtual bool Write(bool Independent, uint16_t FileNumber, off_t FileOffset) =0;
+  virtual bool Get(int Index, uint16_t *FileNumber, off_t *FileOffset, bool *Independent = NULL, int *Length = NULL) =0;
+  virtual int GetNextIFrame(int Index, bool Forward, uint16_t *FileNumber = NULL, off_t *FileOffset = NULL, int *Length = NULL) =0;
+  virtual int Get(uint16_t FileNumber, off_t FileOffset) =0;
+  virtual int First(void) {return 0;};
+  virtual int Last(void) =0;
+  virtual int GetResume(void) =0;
+  virtual bool StoreResume(int Index) =0;
+  virtual bool IsStillRecording(void) =0;
+  virtual void Delete(void) =0;
+  };
+
+class cIndexFile : public cIndex {
 private:
   int f;
   cString fileName;
diff -urN vdr-2.0.0/remux.c vdr-2.0.0.livebuffer/remux.c
--- vdr-2.0.0/remux.c	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/remux.c	2013-04-02 23:10:10.010855177 +0200
@@ -152,6 +152,43 @@
         }
   return -1;
 }
+void TsExtendAdaptionField(unsigned char *Packet, int ToLength)
+{
+    // Hint: ExtenAdaptionField(p, TsPayloadOffset(p) - 4) is a null operation
+
+    int Offset = TsPayloadOffset(Packet); // First byte after existing adaption field
+
+    if (ToLength <= 0)
+    {
+        // Remove adaption field
+        Packet[3] = Packet[3] & ~TS_ADAPT_FIELD_EXISTS;
+        return;
+    }
+
+    // Set adaption field present
+    Packet[3] = Packet[3] | TS_ADAPT_FIELD_EXISTS;
+
+    // Set new length of adaption field:
+    Packet[4] = ToLength <= TS_SIZE-4 ? ToLength-1 : TS_SIZE-4-1;
+
+    if (Packet[4] == TS_SIZE-4-1)
+
+    if (Packet[4] == TS_SIZE-4-1)
+    {
+        // No more payload, remove payload flag
+        Packet[3] = Packet[3] & ~TS_PAYLOAD_EXISTS;
+    }
+
+    int NewPayload = TsPayloadOffset(Packet); // First byte after new adaption field
+
+    // Fill new adaption field
+    if (Offset == 4 && Offset < NewPayload)
+        Offset++; // skip adaptation_field_length
+    if (Offset == 5 && Offset < NewPayload)
+        Packet[Offset++] = 0; // various flags set to 0
+    while (Offset < NewPayload)
+        Packet[Offset++] = 0xff; // stuffing byte
+}
 
 int64_t TsGetDts(const uchar *p, int l)
 {
diff -urN vdr-2.0.0/remux.h vdr-2.0.0.livebuffer/remux.h
--- vdr-2.0.0/remux.h	2013-04-02 23:28:21.382822652 +0200
+++ vdr-2.0.0.livebuffer/remux.h	2013-04-02 23:10:10.010855177 +0200
@@ -140,6 +140,7 @@
 // The following functions all take a pointer to a sequence of complete TS packets.
 
 int64_t TsGetPts(const uchar *p, int l);
+void TsExtendAdaptionField(unsigned char *Packet, int ToLength);
 int64_t TsGetDts(const uchar *p, int l);
 void TsSetPts(uchar *p, int l, int64_t Pts);
 void TsSetDts(uchar *p, int l, int64_t Dts);
diff -urN vdr-2.0.0/timers.c vdr-2.0.0.livebuffer/timers.c
--- vdr-2.0.0/timers.c	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/timers.c	2013-04-02 23:13:12.762849731 +0200
@@ -23,7 +23,7 @@
 
 // --- cTimer ----------------------------------------------------------------
 
-cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel)
+cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel, int Forerun)
 {
   startTime = stopTime = 0;
   lastSetEvent = 0;
@@ -36,7 +36,7 @@
   if (Instant)
      SetFlags(tfActive | tfInstant);
   channel = Channel ? Channel : Channels.GetByNumber(cDevice::CurrentChannel());
-  time_t t = time(NULL);
+  time_t t = time(NULL) - Forerun;
   struct tm tm_r;
   struct tm *now = localtime_r(&t, &tm_r);
   day = SetTime(t, 0);
diff -urN vdr-2.0.0/timers.h vdr-2.0.0.livebuffer/timers.h
--- vdr-2.0.0/timers.h	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/timers.h	2013-04-02 23:12:39.838850713 +0200
@@ -43,7 +43,7 @@
   char *aux;
   const cEvent *event;
 public:
-  cTimer(bool Instant = false, bool Pause = false, cChannel *Channel = NULL);
+  cTimer(bool Instant = false, bool Pause = false, cChannel *Channel = NULL, int Forerun = 0);
   cTimer(const cEvent *Event);
   cTimer(const cTimer &Timer);
   virtual ~cTimer();
diff -urN vdr-2.0.0/vdr.c vdr-2.0.0.livebuffer/vdr.c
--- vdr-2.0.0/vdr.c	2013-04-02 23:28:21.382822652 +0200
+++ vdr-2.0.0.livebuffer/vdr.c	2013-04-02 23:12:23.366851202 +0200
@@ -228,6 +228,7 @@
 
   static struct option long_options[] = {
       { "audio",    required_argument, NULL, 'a' },
+      { "buffer",   required_argument, NULL, 'b' },
       { "cachedir", required_argument, NULL, 'c' | 0x100 },
       { "config",   required_argument, NULL, 'c' },
       { "daemon",   no_argument,       NULL, 'd' },
@@ -263,10 +264,14 @@
     };
 
   int c;
-  while ((c = getopt_long(argc, argv, "a:c:dD:e:E:g:hi:l:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
+  while ((c = getopt_long(argc, argv, "a:b:c:dD:e:E:g:hi:kl:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
         switch (c) {
           case 'a': AudioCommand = optarg;
                     break;
+          case 'b': BufferDirectory = optarg;
+                    if(optarg && *optarg && optarg[strlen(optarg)-1] == '/')
+                       optarg[strlen(optarg)-1] = 0;
+                    break;
           case 'c' | 0x100:
                     CacheDirectory = optarg;
                     break;
@@ -484,6 +489,7 @@
         printf("Usage: vdr [OPTIONS]\n\n"          // for easier orientation, this is column 80|
                "  -a CMD,   --audio=CMD    send Dolby Digital audio to stdin of command CMD\n"
                "            --cachedir=DIR save cache files in DIR (default: %s)\n"
+               "  -b DIR,   --buffer=DIR   use DIR as LiveBuffer directory\n"
                "  -c DIR,   --config=DIR   read config files from DIR (default: %s)\n"
                "  -d,       --daemon       run in daemon mode\n"
                "  -D NUM,   --device=NUM   use only the given DVB device (NUM = 0, 1, 2...)\n"
@@ -664,6 +670,8 @@
 
   // Directories:
 
+  if (!BufferDirectory)
+     BufferDirectory = VideoDirectory;
   SetVideoDirectory(VideoDirectory);
   if (!ConfigDirectory)
      ConfigDirectory = DEFAULTCONFDIR;
@@ -1179,6 +1187,13 @@
                   cDisplaySubtitleTracks::Process(key);
                key = kNone;
                break;
+          case kFastRew:
+               if (!Interact) {
+                  DELETE_MENU;
+                  if(cRecordControls::StartLiveBuffer(key))
+                     key = kNone;
+               } // if
+               break;
           // Pausing live video:
           case kPlayPause:
           case kPause:
@@ -1285,6 +1300,26 @@
                             else
                                cControl::Shutdown();
                             break;
+             case osSwitchChannel:
+                            switch (key) {
+                                // Toggle channels:
+                                case kChanPrev:
+                                case k0: {
+                                    if (PreviousChannel[PreviousChannelIndex ^ 1] == LastChannel
+                                        || (LastChannel != PreviousChannel[0] && LastChannel != PreviousChannel[1]))
+                                        PreviousChannelIndex ^= 1;
+                                    Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
+                                    break;
+                                }
+                                case k1 ... k9:
+                                    DELETE_MENU;
+                                    cControl::Shutdown();
+                                    Menu = new cDisplayChannel(NORMALKEY(key));
+                                    break;
+                                default:
+                                    break;
+                            } // switch
+                            break;
              default:       ;
              }
            }
diff -urN vdr-2.0.0/videodir.c vdr-2.0.0.livebuffer/videodir.c
--- vdr-2.0.0/videodir.c	2013-04-02 23:28:21.366822653 +0200
+++ vdr-2.0.0.livebuffer/videodir.c	2013-04-02 23:11:30.458852781 +0200
@@ -20,6 +20,7 @@
 #include "tools.h"
 
 const char *VideoDirectory = VIDEODIR;
+const char *BufferDirectory = NULL;
 
 void SetVideoDirectory(const char *Directory)
 {
@@ -111,17 +112,22 @@
 cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags)
 {
   const char *ActualFileName = FileName;
+  bool SepBufferDir = false;
 
   // Incoming name must be in base video directory:
-  if (strstr(FileName, VideoDirectory) != FileName) {
+   if (strstr(FileName, VideoDirectory) != FileName) {
+     if (strstr(FileName, BufferDirectory) == FileName)
+        SepBufferDir = true;
+     else {
      esyslog("ERROR: %s not in %s", FileName, VideoDirectory);
      errno = ENOENT; // must set 'errno' - any ideas for a better value?
      return NULL;
      }
+     }
   // Are we going to create a new file?
   if ((Flags & O_CREAT) != 0) {
      cVideoDirectory Dir;
-     if (Dir.IsDistributed()) {
+     if (Dir.IsDistributed() && !SepBufferDir) {
         // Find the directory with the most free space:
         int MaxFree = Dir.FreeMB();
         while (Dir.Next()) {
diff -urN vdr-2.0.0/videodir.h vdr-2.0.0.livebuffer/videodir.h
--- vdr-2.0.0/videodir.h	2013-04-02 23:28:21.382822652 +0200
+++ vdr-2.0.0.livebuffer/videodir.h	2013-04-02 23:10:37.670854353 +0200
@@ -14,6 +14,7 @@
 #include "tools.h"
 
 extern const char *VideoDirectory;
+extern const char *BufferDirectory;
 
 void SetVideoDirectory(const char *Directory);
 cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags);
