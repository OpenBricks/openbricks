diff -urN vdr-2.0.4-org/config.c vdr-2.0.4/config.c
--- vdr-2.0.4-org/config.c	2013-10-25 09:44:22.080680539 +0200
+++ vdr-2.0.4/config.c	2013-10-25 10:07:11.948704053 +0200
@@ -485,6 +485,8 @@
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+  LiveBufferSize = 15;
+  LiveBufferMaxFileSize = 100;
   ExpertOptions  = 0;
   AddNewChannels = 0;
   UseBouquetList = 1;
@@ -716,6 +718,8 @@
   else if (!strcasecmp(Name, "VolumeSteps"))         VolumeSteps        = atoi(Value);
   else if (!strcasecmp(Name, "VolumeLinearize"))     VolumeLinearize    = atoi(Value);
   else if (!strcasecmp(Name, "InitialVolume"))       InitialVolume      = atoi(Value);
+  else if (!strcasecmp(Name, "LiveBufferSize"))        LiveBufferSize        = atoi(Value);
+  else if (!strcasecmp(Name, "LiveBufferMaxFileSize")) LiveBufferMaxFileSize = atoi(Value);
   else if (!strcasecmp(Name, "DeviceBondings"))      DeviceBondings     = Value;
   else if (!strcasecmp(Name, "ChannelsWrap"))        ChannelsWrap       = atoi(Value);
   else if (!strcasecmp(Name, "ShowChannelNamesWithSource")) ShowChannelNamesWithSource = atoi(Value);
@@ -840,6 +844,7 @@
   Store("ChannelsWrap",       ChannelsWrap);
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
+  Store("LiveBufferSize",     LiveBufferSize);
   Store("ExpertOptions",      ExpertOptions);
   Store("AddNewChannels",     AddNewChannels);
   Store("UseBouquetList",     UseBouquetList);
diff -urN vdr-2.0.4-org/config.h vdr-2.0.4/config.h
--- vdr-2.0.4-org/config.h	2013-10-25 09:44:22.452680545 +0200
+++ vdr-2.0.4/config.h	2013-10-25 10:07:11.952704053 +0200
@@ -353,6 +353,8 @@
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+  int LiveBufferSize;
+  int LiveBufferMaxFileSize;
   int ExpertOptions;
   int AddNewChannels;
   int UseBouquetList;
diff -urN vdr-2.0.4-org/device.c vdr-2.0.4/device.c
--- vdr-2.0.4-org/device.c	2013-10-25 09:44:22.080680539 +0200
+++ vdr-2.0.4/device.c	2013-10-25 10:07:11.952704053 +0200
@@ -19,6 +19,8 @@
 #include "receiver.h"
 #include "status.h"
 #include "transfer.h"
+#include "menu.h"
+#include "interface.h"
 #include "vdrttxtsubshooks.h"
 
 // --- cLiveSubtitle ---------------------------------------------------------
@@ -760,6 +762,12 @@
                               return false;
         case scrNoTransfer:   Skins.Message(mtError, tr("Can't start Transfer Mode!"));
                               return false;
+        case srcStillWritingLiveBuffer:
+           if(Interface->Confirm(tr("Still writing timeshift data to recording. Abort?")))
+              cRecordControls::CancelWritingBuffer();
+           else
+              if(cRecordControls::IsWritingBuffer()) return false;
+           break;
         case scrFailed:       break; // loop will retry
         default:              esyslog("ERROR: invalid return value from SetChannel");
         }
@@ -819,8 +827,13 @@
 
   if (NeedsTransferMode) {
      if (Device && CanReplay()) {
-        if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
-           cControl::Launch(new cTransferControl(Device, Channel));
+        if(LiveView && !cRecordControls::CanSetLiveChannel(Channel))
+           return cRecordControls::IsWritingBuffer() ? srcStillWritingLiveBuffer : scrFailed;
+	if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
+           if(LiveView)
+              cRecordControls::SetLiveChannel(Device, Channel);
+           else
+	   cControl::Launch(new cTransferControl(Device, Channel));
         else
            Result = scrNoTransfer;
         }
diff -urN vdr-2.0.4-org/device.c.orig vdr-2.0.4/device.c.orig
--- vdr-2.0.4-org/device.c.orig	2013-10-25 09:44:22.504680546 +0200
+++ vdr-2.0.4/device.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1911 +0,0 @@
-/*
- * device.c: The basic device interface
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: device.c 2.74.1.2 2013/08/22 10:35:30 kls Exp $
- */
-
-#include "device.h"
-#include <errno.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include "audio.h"
-#include "channels.h"
-#include "i18n.h"
-#include "player.h"
-#include "receiver.h"
-#include "status.h"
-#include "transfer.h"
-#include "vdrttxtsubshooks.h"
-
-// --- cLiveSubtitle ---------------------------------------------------------
-
-class cLiveSubtitle : public cReceiver {
-protected:
-  virtual void Receive(uchar *Data, int Length);
-public:
-  cLiveSubtitle(int SPid);
-  virtual ~cLiveSubtitle();
-  };
-
-cLiveSubtitle::cLiveSubtitle(int SPid)
-{
-  AddPid(SPid);
-}
-
-cLiveSubtitle::~cLiveSubtitle()
-{
-  cReceiver::Detach();
-}
-
-void cLiveSubtitle::Receive(uchar *Data, int Length)
-{
-  if (cDevice::PrimaryDevice())
-     cDevice::PrimaryDevice()->PlayTs(Data, Length);
-}
-
-// --- cDeviceHook -----------------------------------------------------------
-
-cDeviceHook::cDeviceHook(void)
-{
-  cDevice::deviceHooks.Add(this);
-}
-
-bool cDeviceHook::DeviceProvidesTransponder(const cDevice *Device, const cChannel *Channel) const
-{
-  return true;
-}
-
-// --- cDevice ---------------------------------------------------------------
-
-// The minimum number of unknown PS1 packets to consider this a "pre 1.3.19 private stream":
-#define MIN_PRE_1_3_19_PRIVATESTREAM 10
-
-int cDevice::numDevices = 0;
-int cDevice::useDevice = 0;
-int cDevice::nextCardIndex = 0;
-int cDevice::currentChannel = 1;
-cDevice *cDevice::device[MAXDEVICES] = { NULL };
-cDevice *cDevice::primaryDevice = NULL;
-cList<cDeviceHook> cDevice::deviceHooks;
-cDevice *cDevice::nextParentDevice = NULL;
- 
-cDevice::cDevice(cDevice *ParentDevice)
-:patPmtParser(true)
-,isIdle(false)
-,parentDevice(ParentDevice)
-,subDevice(NULL)
-{
-  if (!ParentDevice)
-     parentDevice = nextParentDevice;
-  cDevice::nextParentDevice = NULL;
-  if (parentDevice)
-     cardIndex = parentDevice->cardIndex;
-  else
-     cardIndex = nextCardIndex++;
-  dsyslog("new %sdevice number %d", parentDevice ? "sub-" : "", CardIndex() + 1);
-
-  SetDescription("receiver on device %d", CardIndex() + 1);
-
-  mute = false;
-  volume = Setup.CurrentVolume;
-
-  sectionHandler = NULL;
-  eitFilter = NULL;
-  patFilter = NULL;
-  sdtFilter = NULL;
-  nitFilter = NULL;
-
-  camSlot = NULL;
-  startScrambleDetection = 0;
-
-  occupiedTimeout = 0;
-
-  player = NULL;
-  isPlayingVideo = false;
-  keepTracks = false; // used in ClrAvailableTracks()!
-  ClrAvailableTracks();
-  currentAudioTrack = ttNone;
-  currentAudioTrackMissingCount = 0;
-  currentSubtitleTrack = ttNone;
-  liveSubtitle = NULL;
-  dvbSubtitleConverter = NULL;
-  autoSelectPreferredSubtitleLanguage = true;
-
-  for (int i = 0; i < MAXRECEIVERS; i++)
-      receiver[i] = NULL;
-
-  if (!parentDevice) {
-     if (numDevices < MAXDEVICES)
-        device[numDevices++] = this;
-     else
-        esyslog("ERROR: too many devices or \"dynamite\"-unpatched device creator!");
-     }
-  else
-     parentDevice->subDevice = this;
-}
-
-cDevice::~cDevice()
-{
-  Detach(player);
-  DetachAllReceivers();
-  delete liveSubtitle;
-  delete dvbSubtitleConverter;
-  if (this == primaryDevice)
-     primaryDevice = NULL;
-  if (parentDevice && (parentDevice->subDevice == this))
-     parentDevice->subDevice = NULL;
-}
-
-bool cDevice::SetIdle(bool Idle)
-{
-  if (parentDevice)
-     return parentDevice->SetIdle(Idle);
-  if (isIdle == Idle)
-     return true;
-  if (Receiving(false))
-     return false;
-  if (Idle) {
-     Detach(player);
-     DetachAllReceivers();
-     }
-  if (!SetIdleDevice(Idle, true))
-     return false;
-  isIdle = Idle;
-  if (SetIdleDevice(Idle, false))
-     return true;
-  isIdle = !Idle;
-  return false;
-}
-
-bool cDevice::WaitForAllDevicesReady(int Timeout)
-{
-  for (time_t t0 = time(NULL); time(NULL) - t0 < Timeout; ) {
-      bool ready = true;
-      for (int i = 0; i < numDevices; i++) {
-          if (device[i] && !device[i]->Ready()) {
-             ready = false;
-             cCondWait::SleepMs(100);
-             }
-          }
-      if (ready)
-         return true;
-      }
-  return false;
-}
-
-void cDevice::SetUseDevice(int n)
-{
-  if (n < MAXDEVICES)
-     useDevice |= (1 << n);
-}
-
-int cDevice::NextCardIndex(int n)
-{
-  if (n > 0) {
-     nextCardIndex += n;
-     if (nextCardIndex >= MAXDEVICES)
-        esyslog("ERROR: nextCardIndex too big (%d)", nextCardIndex);
-     }
-  else if (n < 0)
-     esyslog("ERROR: invalid value in nextCardIndex(%d)", n);
-  return nextCardIndex;
-}
-
-int cDevice::DeviceNumber(void) const
-{
-  if (parentDevice)
-     return parentDevice->DeviceNumber();
-  for (int i = 0; i < numDevices; i++) {
-      if (device[i] == this)
-         return i;
-      }
-  return -1;
-}
-
-cString cDevice::DeviceType(void) const
-{
-  return "";
-}
-
-cString cDevice::DeviceName(void) const
-{
-  return "";
-}
-
-void cDevice::MakePrimaryDevice(bool On)
-{
-  if (!On) {
-     DELETENULL(liveSubtitle);
-     DELETENULL(dvbSubtitleConverter);
-     }
-}
-
-bool cDevice::SetPrimaryDevice(int n)
-{
-  n--;
-  if (0 <= n && n < numDevices && device[n]) {
-     isyslog("setting primary device to %d", n + 1);
-     if (primaryDevice)
-        primaryDevice->MakePrimaryDevice(false);
-     primaryDevice = device[n];
-     primaryDevice->MakePrimaryDevice(true);
-     primaryDevice->SetVideoFormat(Setup.VideoFormat);
-     primaryDevice->SetVolumeDevice(Setup.CurrentVolume);
-     return true;
-     }
-  esyslog("ERROR: invalid primary device number: %d", n + 1);
-  return false;
-}
-
-bool cDevice::HasDecoder(void) const
-{
-  return false;
-}
-
-cSpuDecoder *cDevice::GetSpuDecoder(void)
-{
-  return NULL;
-}
-
-cDevice *cDevice::ActualDevice(void)
-{
-  cDevice *d = cTransferControl::ReceiverDevice();
-  if (!d)
-     d = PrimaryDevice();
-  return d;
-}
-
-cDevice *cDevice::GetDevice(int Index)
-{
-  return (0 <= Index && Index < numDevices) ? device[Index] : NULL;
-}
-
-static int GetClippedNumProvidedSystems(int AvailableBits, cDevice *Device)
-{
-  int MaxNumProvidedSystems = (1 << AvailableBits) - 1;
-  int NumProvidedSystems = Device->NumProvidedSystems();
-  if (NumProvidedSystems > MaxNumProvidedSystems) {
-     esyslog("ERROR: device %d supports %d modulation systems but cDevice::GetDevice() currently only supports %d delivery systems which should be fixed", Device->CardIndex() + 1, NumProvidedSystems, MaxNumProvidedSystems);
-     NumProvidedSystems = MaxNumProvidedSystems;
-     }
-  else if (NumProvidedSystems <= 0) {
-     esyslog("ERROR: device %d reported an invalid number (%d) of supported delivery systems - assuming 1", Device->CardIndex() + 1, NumProvidedSystems);
-     NumProvidedSystems = 1;
-     }
-  return NumProvidedSystems;
-}
-
-cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView, bool Query)
-{
-  // Collect the current priorities of all CAM slots that can decrypt the channel:
-  int NumCamSlots = CamSlots.Count();
-  int SlotPriority[NumCamSlots];
-  int NumUsableSlots = 0;
-  bool InternalCamNeeded = false;
-  if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
-     for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
-         SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
-         if (CamSlot->ModuleStatus() == msReady) {
-            if (CamSlot->ProvidesCa(Channel->Caids())) {
-               if (!ChannelCamRelations.CamChecked(Channel->GetChannelID(), CamSlot->SlotNumber())) {
-                  SlotPriority[CamSlot->Index()] = CamSlot->Priority();
-                  NumUsableSlots++;
-                  }
-               }
-            }
-         }
-     if (!NumUsableSlots)
-        InternalCamNeeded = true; // no CAM is able to decrypt this channel
-     }
-
-  bool NeedsDetachReceivers = false;
-  cDevice *d = NULL;
-  cCamSlot *s = NULL;
-
-  uint32_t Impact = 0xFFFFFFFF; // we're looking for a device with the least impact
-  for (int j = 0; j < NumCamSlots || !NumUsableSlots; j++) {
-      if (NumUsableSlots && SlotPriority[j] > MAXPRIORITY)
-         continue; // there is no CAM available in this slot
-      for (int i = 0; i < numDevices; i++) {
-          if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
-             continue; // a specific card was requested, but not this one
-          bool HasInternalCam = device[i]->HasInternalCam();
-          if (InternalCamNeeded && !HasInternalCam)
-             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
-          if (NumUsableSlots && !HasInternalCam && !CamSlots.Get(j)->Assign(device[i], true))
-             continue; // CAM slot can't be used with this device
-          bool ndr;
-          if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basically able to do the job
-             if (NumUsableSlots && !HasInternalCam && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
-                ndr = true; // using a different CAM slot requires detaching receivers
-             // Put together an integer number that reflects the "impact" using
-             // this device would have on the overall system. Each condition is represented
-             // by one bit in the number (or several bits, if the condition is actually
-             // a numeric value). The sequence in which the conditions are listed corresponds
-             // to their individual severity, where the one listed first will make the most
-             // difference, because it results in the most significant bit of the result.
-             uint32_t imp = 0;
-             imp <<= 1; imp |= LiveView ? !device[i]->IsPrimaryDevice() || ndr : 0;                                  // prefer the primary device for live viewing if we don't need to detach existing receivers
-             imp <<= 1; imp |= !device[i]->Receiving() && (device[i] != cTransferControl::ReceiverDevice() || device[i]->IsPrimaryDevice()) || ndr; // use receiving devices if we don't need to detach existing receivers, but avoid primary device in local transfer mode
-             imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
-             imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
-             imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
-             imp <<= 8; imp |= device[i]->Priority() - IDLEPRIORITY;                                                 // use the device with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
-             imp <<= 8; imp |= ((NumUsableSlots && !HasInternalCam) ? SlotPriority[j] : IDLEPRIORITY) - IDLEPRIORITY;// use the CAM slot with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
-             imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
-             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
-             imp <<= 1; imp |= device[i]->AvoidRecording();                                                          // avoid SD full featured cards
-             imp <<= 1; imp |= (NumUsableSlots && !HasInternalCam) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
-             imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
-             if (imp < Impact) {
-                // This device has less impact than any previous one, so we take it.
-                Impact = imp;
-                d = device[i];
-                NeedsDetachReceivers = ndr;
-                if (NumUsableSlots && !HasInternalCam)
-                   s = CamSlots.Get(j);
-                }
-             }
-          }
-      if (!NumUsableSlots)
-         break; // no CAM necessary, so just one loop over the devices
-      }
-  if (d && !Query) {
-     if (NeedsDetachReceivers)
-        d->DetachAllReceivers();
-     if (s) {
-        if (s->Device() != d) {
-           if (s->Device())
-              s->Device()->DetachAllReceivers();
-           if (d->CamSlot())
-              d->CamSlot()->Assign(NULL);
-           s->Assign(d);
-           }
-        }
-     else if (d->CamSlot() && !d->CamSlot()->IsDecrypting())
-        d->CamSlot()->Assign(NULL);
-     }
-  return d;
-}
-
-cDevice *cDevice::GetDeviceForTransponder(const cChannel *Channel, int Priority)
-{
-  cDevice *Device = NULL;
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      if (cDevice *d = cDevice::GetDevice(i)) {
-         if (d->IsTunedToTransponder(Channel))
-            return d; // if any device is tuned to the transponder, we're done
-         if (d->ProvidesTransponder(Channel)) {
-            if (d->MaySwitchTransponder(Channel))
-               Device = d; // this device may switch to the transponder without disturbing any receiver or live view
-            else if (!d->Occupied() && d->MaySwitchTransponder(Channel)) { // MaySwitchTransponder() implicitly calls Occupied()
-               if (d->Priority() < Priority && (!Device || d->Priority() < Device->Priority()))
-                  Device = d; // use this one only if no other with less impact can be found
-               }
-            }
-         }
-      }
-  return Device;
-}
-
-bool cDevice::HasCi(void)
-{
-  return false;
-}
-
-void cDevice::SetCamSlot(cCamSlot *CamSlot)
-{
-  if (parentDevice)
-     return parentDevice->SetCamSlot(CamSlot);
-  camSlot = CamSlot;
-}
-
-void cDevice::Shutdown(void)
-{
-  deviceHooks.Clear();
-  for (int i = 0; i < numDevices; i++) {
-      delete device[i];
-      device[i] = NULL;
-      }
-}
-
-uchar *cDevice::GrabImage(int &Size, bool Jpeg, int Quality, int SizeX, int SizeY)
-{
-  return NULL;
-}
-
-bool cDevice::GrabImageFile(const char *FileName, bool Jpeg, int Quality, int SizeX, int SizeY)
-{
-  int result = 0;
-  int fd = open(FileName, O_WRONLY | O_CREAT | O_NOFOLLOW | O_TRUNC, DEFFILEMODE);
-  if (fd >= 0) {
-     int ImageSize;
-     uchar *Image = GrabImage(ImageSize, Jpeg, Quality, SizeX, SizeY);
-     if (Image) {
-        if (safe_write(fd, Image, ImageSize) == ImageSize)
-           isyslog("grabbed image to %s", FileName);
-        else {
-           LOG_ERROR_STR(FileName);
-           result |= 1;
-           }
-        free(Image);
-        }
-     else
-        result |= 1;
-     close(fd);
-     }
-  else {
-     LOG_ERROR_STR(FileName);
-     result |= 1;
-     }
-  return result == 0;
-}
-
-void cDevice::SetVideoDisplayFormat(eVideoDisplayFormat VideoDisplayFormat)
-{
-  cSpuDecoder *spuDecoder = GetSpuDecoder();
-  if (spuDecoder) {
-     if (Setup.VideoFormat)
-        spuDecoder->setScaleMode(cSpuDecoder::eSpuNormal);
-     else {
-        switch (VideoDisplayFormat) {
-               case vdfPanAndScan:
-                    spuDecoder->setScaleMode(cSpuDecoder::eSpuPanAndScan);
-                    break;
-               case vdfLetterBox:
-                    spuDecoder->setScaleMode(cSpuDecoder::eSpuLetterBox);
-                    break;
-               case vdfCenterCutOut:
-                    spuDecoder->setScaleMode(cSpuDecoder::eSpuNormal);
-                    break;
-               default: esyslog("ERROR: invalid value for VideoDisplayFormat '%d'", VideoDisplayFormat);
-               }
-        }
-     }
-}
-
-void cDevice::SetVideoFormat(bool VideoFormat16_9)
-{
-}
-
-eVideoSystem cDevice::GetVideoSystem(void)
-{
-  return vsPAL;
-}
-
-void cDevice::GetVideoSize(int &Width, int &Height, double &VideoAspect)
-{
-  Width = 0;
-  Height = 0;
-  VideoAspect = 1.0;
-}
-
-void cDevice::GetOsdSize(int &Width, int &Height, double &PixelAspect)
-{
-  Width = 720;
-  Height = 480;
-  PixelAspect = 1.0;
-}
-
-//#define PRINTPIDS(s) { char b[500]; char *q = b; q += sprintf(q, "%d %s ", CardIndex(), s); for (int i = 0; i < MAXPIDHANDLES; i++) q += sprintf(q, " %s%4d %d", i == ptOther ? "* " : "", pidHandles[i].pid, pidHandles[i].used); dsyslog("%s", b); }
-#define PRINTPIDS(s)
-
-bool cDevice::HasPid(int Pid) const
-{
-  for (int i = 0; i < MAXPIDHANDLES; i++) {
-      if (pidHandles[i].pid == Pid)
-         return true;
-      }
-  return false;
-}
-
-bool cDevice::AddPid(int Pid, ePidType PidType, int StreamType)
-{
-  if (Pid || PidType == ptPcr) {
-     int n = -1;
-     int a = -1;
-     if (PidType != ptPcr) { // PPID always has to be explicit
-        for (int i = 0; i < MAXPIDHANDLES; i++) {
-            if (i != ptPcr) {
-               if (pidHandles[i].pid == Pid)
-                  n = i;
-               else if (a < 0 && i >= ptOther && !pidHandles[i].used)
-                  a = i;
-               }
-            }
-        }
-     if (n >= 0) {
-        // The Pid is already in use
-        if (++pidHandles[n].used == 2 && n <= ptTeletext) {
-           // It's a special PID that may have to be switched into "tap" mode
-           PRINTPIDS("A");
-           if (!SetPid(&pidHandles[n], n, true)) {
-              esyslog("ERROR: can't set PID %d on device %d", Pid, CardIndex() + 1);
-              if (PidType <= ptTeletext)
-                 DetachAll(Pid);
-              DelPid(Pid, PidType);
-              return false;
-              }
-           if (camSlot)
-              camSlot->SetPid(Pid, true);
-           }
-        PRINTPIDS("a");
-        return true;
-        }
-     else if (PidType < ptOther) {
-        // The Pid is not yet in use and it is a special one
-        n = PidType;
-        }
-     else if (a >= 0) {
-        // The Pid is not yet in use and we have a free slot
-        n = a;
-        }
-     else {
-        esyslog("ERROR: no free slot for PID %d on device %d", Pid, CardIndex() + 1);
-        return false;
-        }
-     if (n >= 0) {
-        pidHandles[n].pid = Pid;
-        pidHandles[n].streamType = StreamType;
-        pidHandles[n].used = 1;
-        PRINTPIDS("C");
-        if (!SetPid(&pidHandles[n], n, true)) {
-           esyslog("ERROR: can't set PID %d on device %d", Pid, CardIndex() + 1);
-           if (PidType <= ptTeletext)
-              DetachAll(Pid);
-           DelPid(Pid, PidType);
-           return false;
-           }
-        if (camSlot)
-           camSlot->SetPid(Pid, true);
-        }
-     }
-  return true;
-}
-
-void cDevice::DelPid(int Pid, ePidType PidType)
-{
-  if (Pid || PidType == ptPcr) {
-     int n = -1;
-     if (PidType == ptPcr)
-        n = PidType; // PPID always has to be explicit
-     else {
-        for (int i = 0; i < MAXPIDHANDLES; i++) {
-            if (pidHandles[i].pid == Pid) {
-               n = i;
-               break;
-               }
-            }
-        }
-     if (n >= 0 && pidHandles[n].used) {
-        PRINTPIDS("D");
-        if (--pidHandles[n].used < 2) {
-           SetPid(&pidHandles[n], n, false);
-           if (pidHandles[n].used == 0) {
-              pidHandles[n].handle = -1;
-              pidHandles[n].pid = 0;
-              if (camSlot)
-                 camSlot->SetPid(Pid, false);
-              }
-           }
-        PRINTPIDS("E");
-        }
-     }
-}
-
-bool cDevice::SetPid(cPidHandle *Handle, int Type, bool On)
-{
-  return false;
-}
-
-void cDevice::DelLivePids(void)
-{
-  for (int i = ptAudio; i < ptOther; i++) {
-      if (pidHandles[i].pid)
-         DelPid(pidHandles[i].pid, ePidType(i));
-      }
-}
-
-void cDevice::StartSectionHandler(void)
-{
-  if (parentDevice) {
-     parentDevice->StartSectionHandler();
-     return;
-     }
-  if (!sectionHandler) {
-     sectionHandler = new cSectionHandler(this);
-     AttachFilter(eitFilter = new cEitFilter);
-     AttachFilter(patFilter = new cPatFilter);
-     AttachFilter(sdtFilter = new cSdtFilter(patFilter));
-     AttachFilter(nitFilter = new cNitFilter);
-     }
-}
-
-void cDevice::StopSectionHandler(void)
-{
-  if (parentDevice) {
-     parentDevice->StopSectionHandler();
-     return;
-     }
-  if (sectionHandler) {
-     delete nitFilter;
-     delete sdtFilter;
-     delete patFilter;
-     delete eitFilter;
-     delete sectionHandler;
-     nitFilter = NULL;
-     sdtFilter = NULL;
-     patFilter = NULL;
-     eitFilter = NULL;
-     sectionHandler = NULL;
-     }
-}
-
-int cDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
-{
-  return -1;
-}
-
-int cDevice::ReadFilter(int Handle, void *Buffer, size_t Length)
-{
-  return safe_read(Handle, Buffer, Length);
-}
-
-void cDevice::CloseFilter(int Handle)
-{
-  close(Handle);
-}
-
-void cDevice::AttachFilter(cFilter *Filter)
-{
-  if (parentDevice)
-     return parentDevice->AttachFilter(Filter);
-  SetIdle(false);
-  if (sectionHandler)
-     sectionHandler->Attach(Filter);
-}
-
-void cDevice::Detach(cFilter *Filter)
-{
-  if (parentDevice)
-     return parentDevice->Detach(Filter);
-  if (sectionHandler)
-     sectionHandler->Detach(Filter);
-}
-
-bool cDevice::ProvidesSource(int Source) const
-{
-  return false;
-}
-
-bool cDevice::DeviceHooksProvidesTransponder(const cChannel *Channel) const
-{
-  cDeviceHook *Hook = deviceHooks.First();
-  while (Hook) {
-        if (!Hook->DeviceProvidesTransponder(this, Channel))
-           return false;
-        Hook = deviceHooks.Next(Hook);
-        }
-  return true;
-}
-
-bool cDevice::ProvidesTransponder(const cChannel *Channel) const
-{
-  return false;
-}
-
-bool cDevice::ProvidesTransponderExclusively(const cChannel *Channel) const
-{
-  for (int i = 0; i < numDevices; i++) {
-      if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel))
-         return false;
-      }
-  return true;
-}
-
-bool cDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
-{
-  return false;
-}
-
-bool cDevice::ProvidesEIT(void) const
-{
-  return false;
-}
-
-int cDevice::NumProvidedSystems(void) const
-{
-  return 0;
-}
-
-int cDevice::SignalStrength(void) const
-{
-  return -1;
-}
-
-int cDevice::SignalQuality(void) const
-{
-  return -1;
-}
-
-const cChannel *cDevice::GetCurrentlyTunedTransponder(void) const
-{
-  return NULL;
-}
-
-bool cDevice::IsTunedToTransponder(const cChannel *Channel) const
-{
-  return false;
-}
-
-bool cDevice::MaySwitchTransponder(const cChannel *Channel) const
-{
-  return time(NULL) > occupiedTimeout && !Receiving() && !(pidHandles[ptAudio].pid || pidHandles[ptVideo].pid || pidHandles[ptDolby].pid);
-}
-
-bool cDevice::SwitchChannel(const cChannel *Channel, bool LiveView)
-{
-  if (LiveView) {
-     isyslog("switching to channel %d", Channel->Number());
-     cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
-     }
-  for (int i = 3; i--;) {
-      switch (SetChannel(Channel, LiveView)) {
-        case scrOk:           return true;
-        case scrNotAvailable: Skins.Message(mtInfo, tr("Channel not available!"));
-                              return false;
-        case scrNoTransfer:   Skins.Message(mtError, tr("Can't start Transfer Mode!"));
-                              return false;
-        case scrFailed:       break; // loop will retry
-        default:              esyslog("ERROR: invalid return value from SetChannel");
-        }
-      esyslog("retrying");
-      }
-  return false;
-}
-
-bool cDevice::SwitchChannel(int Direction)
-{
-  bool result = false;
-  Direction = sgn(Direction);
-  if (Direction) {
-     cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
-     int n = CurrentChannel() + Direction;
-     int first = n;
-     cChannel *channel;
-     while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
-           // try only channels which are currently available
-           if (GetDevice(channel, LIVEPRIORITY, true, true))
-              break;
-           n = channel->Number() + Direction;
-           }
-     if (channel) {
-        int d = n - first;
-        if (abs(d) == 1)
-           dsyslog("skipped channel %d", first);
-        else if (d)
-           dsyslog("skipped channels %d..%d", first, n - sgn(d));
-        if (PrimaryDevice()->SwitchChannel(channel, true))
-           result = true;
-        }
-     else if (n != first)
-        Skins.Message(mtError, tr("Channel not available!"));
-     }
-  return result;
-}
-
-eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
-{
-  cStatus::MsgChannelSwitch(this, 0, LiveView);
-
-  if (LiveView) {
-     StopReplay();
-     DELETENULL(liveSubtitle);
-     DELETENULL(dvbSubtitleConverter);
-     }
-
-  cDevice *Device = (LiveView && IsPrimaryDevice()) ? GetDevice(Channel, LIVEPRIORITY, true) : this;
-
-  bool NeedsTransferMode = Device != this;
-
-  eSetChannelResult Result = scrOk;
-
-  // If this DVB card can't receive this channel, let's see if we can
-  // use the card that actually can receive it and transfer data from there:
-
-  if (NeedsTransferMode) {
-     if (Device && CanReplay()) {
-        if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
-           cControl::Launch(new cTransferControl(Device, Channel));
-        else
-           Result = scrNoTransfer;
-        }
-     else
-        Result = scrNotAvailable;
-     }
-  else {
-     Channels.Lock(false);
-     // Stop section handling:
-     if (sectionHandler) {
-        sectionHandler->SetStatus(false);
-        sectionHandler->SetChannel(NULL);
-        }
-     SetIdle(false);
-     // Tell the camSlot about the channel switch and add all PIDs of this
-     // channel to it, for possible later decryption:
-     if (camSlot)
-        camSlot->AddChannel(Channel);
-     if (SetChannelDevice(Channel, LiveView)) {
-        // Start section handling:
-        if (sectionHandler) {
-           sectionHandler->SetChannel(Channel);
-           sectionHandler->SetStatus(true);
-           }
-        // Start decrypting any PIDs that might have been set in SetChannelDevice():
-        if (camSlot)
-           camSlot->StartDecrypting();
-        }
-     else
-        Result = scrFailed;
-     Channels.Unlock();
-     }
-
-  if (Result == scrOk) {
-     if (LiveView && IsPrimaryDevice()) {
-        currentChannel = Channel->Number();
-        // Set the available audio tracks:
-        ClrAvailableTracks();
-        for (int i = 0; i < MAXAPIDS; i++)
-            SetAvailableTrack(ttAudio, i, Channel->Apid(i), Channel->Alang(i));
-        if (Setup.UseDolbyDigital) {
-           for (int i = 0; i < MAXDPIDS; i++)
-               SetAvailableTrack(ttDolby, i, Channel->Dpid(i), Channel->Dlang(i));
-           }
-        for (int i = 0; i < MAXSPIDS; i++)
-            SetAvailableTrack(ttSubtitle, i, Channel->Spid(i), Channel->Slang(i));
-        if (!NeedsTransferMode)
-           EnsureAudioTrack(true);
-        EnsureSubtitleTrack();
-        }
-     cStatus::MsgChannelSwitch(this, Channel->Number(), LiveView); // only report status if channel switch successful
-     }
-
-  return Result;
-}
-
-void cDevice::ForceTransferMode(void)
-{
-  if (!cTransferControl::ReceiverDevice()) {
-     cChannel *Channel = Channels.GetByNumber(CurrentChannel());
-     if (Channel) {
-        SetIdle(false);
-        SetChannelDevice(Channel, false); // this implicitly starts Transfer Mode
-        }
-     }
-}
-
-int cDevice::Occupied(void) const
-{
-  if (parentDevice)
-     return parentDevice->Occupied();
-  int Seconds = occupiedTimeout - time(NULL);
-  return Seconds > 0 ? Seconds : 0;
-}
-
-void cDevice::SetOccupied(int Seconds)
-{
-  if (parentDevice) {
-     parentDevice->SetOccupied(Seconds);
-     return;
-     }
-  if (Seconds >= 0)
-     occupiedTimeout = time(NULL) + min(Seconds, MAXOCCUPIEDTIMEOUT);
-}
-
-bool cDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
-{
-  return false;
-}
-
-bool cDevice::HasLock(int TimeoutMs) const
-{
-  return true;
-}
-
-bool cDevice::HasProgramme(void) const
-{
-  return Replaying() || pidHandles[ptAudio].pid || pidHandles[ptVideo].pid;
-}
-
-int cDevice::GetAudioChannelDevice(void)
-{
-  return 0;
-}
-
-void cDevice::SetAudioChannelDevice(int AudioChannel)
-{
-}
-
-void cDevice::SetVolumeDevice(int Volume)
-{
-}
-
-void cDevice::SetDigitalAudioDevice(bool On)
-{
-}
-
-void cDevice::SetAudioTrackDevice(eTrackType Type)
-{
-}
-
-void cDevice::SetSubtitleTrackDevice(eTrackType Type)
-{
-}
-
-bool cDevice::ToggleMute(void)
-{
-  int OldVolume = volume;
-  mute = !mute;
-  //XXX why is it necessary to use different sequences???
-  if (mute) {
-     SetVolume(0, true);
-     Audios.MuteAudio(mute); // Mute external audio after analog audio
-     }
-  else {
-     Audios.MuteAudio(mute); // Enable external audio before analog audio
-     SetVolume(OldVolume, true);
-     }
-  volume = OldVolume;
-  return mute;
-}
-
-int cDevice::GetAudioChannel(void)
-{
-  int c = GetAudioChannelDevice();
-  return (0 <= c && c <= 2) ? c : 0;
-}
-
-void cDevice::SetAudioChannel(int AudioChannel)
-{
-  if (0 <= AudioChannel && AudioChannel <= 2)
-     SetAudioChannelDevice(AudioChannel);
-}
-
-void cDevice::SetVolume(int Volume, bool Absolute)
-{
-  int OldVolume = volume;
-  volume = constrain(Absolute ? Volume : volume + Volume, 0, MAXVOLUME);
-  SetVolumeDevice(volume);
-  Absolute |= mute;
-  cStatus::MsgSetVolume(Absolute ? volume : volume - OldVolume, Absolute);
-  if (volume > 0) {
-     mute = false;
-     Audios.MuteAudio(mute);
-     }
-}
-
-void cDevice::ClrAvailableTracks(bool DescriptionsOnly, bool IdsOnly)
-{
-  if (keepTracks)
-     return;
-  if (DescriptionsOnly) {
-     for (int i = ttNone; i < ttMaxTrackTypes; i++)
-         *availableTracks[i].description = 0;
-     }
-  else {
-     if (IdsOnly) {
-        for (int i = ttNone; i < ttMaxTrackTypes; i++)
-            availableTracks[i].id = 0;
-        }
-     else
-        memset(availableTracks, 0, sizeof(availableTracks));
-     pre_1_3_19_PrivateStream = 0;
-     SetAudioChannel(0); // fall back to stereo
-     currentAudioTrackMissingCount = 0;
-     currentAudioTrack = ttNone;
-     currentSubtitleTrack = ttNone;
-     }
-}
-
-bool cDevice::SetAvailableTrack(eTrackType Type, int Index, uint16_t Id, const char *Language, const char *Description)
-{
-  eTrackType t = eTrackType(Type + Index);
-  if (Type == ttAudio && IS_AUDIO_TRACK(t) ||
-      Type == ttDolby && IS_DOLBY_TRACK(t) ||
-      Type == ttSubtitle && IS_SUBTITLE_TRACK(t)) {
-     if (Language)
-        strn0cpy(availableTracks[t].language, Language, sizeof(availableTracks[t].language));
-     if (Description)
-        Utf8Strn0Cpy(availableTracks[t].description, Description, sizeof(availableTracks[t].description));
-     if (Id) {
-        availableTracks[t].id = Id; // setting 'id' last to avoid the need for extensive locking
-        if (Type == ttAudio || Type == ttDolby) {
-           int numAudioTracks = NumAudioTracks();
-           if (!availableTracks[currentAudioTrack].id && numAudioTracks && currentAudioTrackMissingCount++ > numAudioTracks * 10)
-              EnsureAudioTrack();
-           else if (t == currentAudioTrack)
-              currentAudioTrackMissingCount = 0;
-           }
-        else if (Type == ttSubtitle && autoSelectPreferredSubtitleLanguage)
-           EnsureSubtitleTrack();
-        }
-     return true;
-     }
-  else
-     esyslog("ERROR: SetAvailableTrack called with invalid Type/Index (%d/%d)", Type, Index);
-  return false;
-}
-
-const tTrackId *cDevice::GetTrack(eTrackType Type)
-{
-  return (ttNone < Type && Type < ttMaxTrackTypes) ? &availableTracks[Type] : NULL;
-}
-
-int cDevice::NumTracks(eTrackType FirstTrack, eTrackType LastTrack) const
-{
-  int n = 0;
-  for (int i = FirstTrack; i <= LastTrack; i++) {
-      if (availableTracks[i].id)
-         n++;
-      }
-  return n;
-}
-
-int cDevice::NumAudioTracks(void) const
-{
-  return NumTracks(ttAudioFirst, ttDolbyLast);
-}
-
-int cDevice::NumSubtitleTracks(void) const
-{
-  return NumTracks(ttSubtitleFirst, ttSubtitleLast);
-}
-
-bool cDevice::SetCurrentAudioTrack(eTrackType Type)
-{
-  if (ttNone < Type && Type <= ttDolbyLast) {
-     cMutexLock MutexLock(&mutexCurrentAudioTrack);
-     if (IS_DOLBY_TRACK(Type))
-        SetDigitalAudioDevice(true);
-     currentAudioTrack = Type;
-     if (player)
-        player->SetAudioTrack(currentAudioTrack, GetTrack(currentAudioTrack));
-     else
-        SetAudioTrackDevice(currentAudioTrack);
-     if (IS_AUDIO_TRACK(Type))
-        SetDigitalAudioDevice(false);
-     return true;
-     }
-  return false;
-}
-
-bool cDevice::SetCurrentSubtitleTrack(eTrackType Type, bool Manual)
-{
-  if (Type == ttNone || IS_SUBTITLE_TRACK(Type)) {
-     currentSubtitleTrack = Type;
-     autoSelectPreferredSubtitleLanguage = !Manual;
-     if (dvbSubtitleConverter)
-        dvbSubtitleConverter->Reset();
-     if (Type == ttNone && dvbSubtitleConverter) {
-        cMutexLock MutexLock(&mutexCurrentSubtitleTrack);
-        DELETENULL(dvbSubtitleConverter);
-        }
-     DELETENULL(liveSubtitle);
-     if (player)
-        player->SetSubtitleTrack(currentSubtitleTrack, GetTrack(currentSubtitleTrack));
-     else
-        SetSubtitleTrackDevice(currentSubtitleTrack);
-     if (currentSubtitleTrack != ttNone && !Replaying() && !Transferring()) {
-        const tTrackId *TrackId = GetTrack(currentSubtitleTrack);
-        if (TrackId && TrackId->id) {
-           liveSubtitle = new cLiveSubtitle(TrackId->id);
-           AttachReceiver(liveSubtitle);
-           }
-        }
-     return true;
-     }
-  return false;
-}
-
-void cDevice::EnsureAudioTrack(bool Force)
-{
-  if (keepTracks)
-     return;
-  if (Force || !availableTracks[currentAudioTrack].id) {
-     eTrackType PreferredTrack = ttAudioFirst;
-     int PreferredAudioChannel = 0;
-     int LanguagePreference = -1;
-     int StartCheck = Setup.CurrentDolby ? ttDolbyFirst : ttAudioFirst;
-     int EndCheck = ttDolbyLast;
-     for (int i = StartCheck; i <= EndCheck; i++) {
-         const tTrackId *TrackId = GetTrack(eTrackType(i));
-         int pos = 0;
-         if (TrackId && TrackId->id && I18nIsPreferredLanguage(Setup.AudioLanguages, TrackId->language, LanguagePreference, &pos)) {
-            PreferredTrack = eTrackType(i);
-            PreferredAudioChannel = pos;
-            }
-         if (Setup.CurrentDolby && i == ttDolbyLast) {
-            i = ttAudioFirst - 1;
-            EndCheck = ttAudioLast;
-            }
-         }
-     // Make sure we're set to an available audio track:
-     const tTrackId *Track = GetTrack(GetCurrentAudioTrack());
-     if (Force || !Track || !Track->id || PreferredTrack != GetCurrentAudioTrack()) {
-        if (!Force) // only log this for automatic changes
-           dsyslog("setting audio track to %d (%d)", PreferredTrack, PreferredAudioChannel);
-        SetCurrentAudioTrack(PreferredTrack);
-        SetAudioChannel(PreferredAudioChannel);
-        }
-     }
-}
-
-void cDevice::EnsureSubtitleTrack(void)
-{
-  if (keepTracks)
-     return;
-  if (Setup.DisplaySubtitles) {
-     eTrackType PreferredTrack = ttNone;
-     int LanguagePreference = INT_MAX; // higher than the maximum possible value
-     for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
-         const tTrackId *TrackId = GetTrack(eTrackType(i));
-         if (TrackId && TrackId->id && (I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference) ||
-            (i == ttSubtitleFirst + 8 && !*TrackId->language && LanguagePreference == INT_MAX))) // compatibility mode for old subtitles plugin
-            PreferredTrack = eTrackType(i);
-         }
-     // Make sure we're set to an available subtitle track:
-     const tTrackId *Track = GetTrack(GetCurrentSubtitleTrack());
-     if (!Track || !Track->id || PreferredTrack != GetCurrentSubtitleTrack())
-        SetCurrentSubtitleTrack(PreferredTrack);
-     }
-  else
-     SetCurrentSubtitleTrack(ttNone);
-}
-
-bool cDevice::CanReplay(void) const
-{
-  return HasDecoder();
-}
-
-bool cDevice::SetPlayMode(ePlayMode PlayMode)
-{
-  return false;
-}
-
-int64_t cDevice::GetSTC(void)
-{
-  return -1;
-}
-
-void cDevice::TrickSpeed(int Speed)
-{
-}
-
-void cDevice::Clear(void)
-{
-  Audios.ClearAudio();
-  if (dvbSubtitleConverter)
-     dvbSubtitleConverter->Reset();
-}
-
-void cDevice::Play(void)
-{
-  Audios.MuteAudio(mute);
-  if (dvbSubtitleConverter)
-     dvbSubtitleConverter->Freeze(false);
-}
-
-void cDevice::Freeze(void)
-{
-  Audios.MuteAudio(true);
-  if (dvbSubtitleConverter)
-     dvbSubtitleConverter->Freeze(true);
-}
-
-void cDevice::Mute(void)
-{
-  Audios.MuteAudio(true);
-}
-
-void cDevice::StillPicture(const uchar *Data, int Length)
-{
-  if (Data[0] == 0x47) {
-     // TS data
-     cTsToPes TsToPes;
-     uchar *buf = NULL;
-     int Size = 0;
-     while (Length >= TS_SIZE) {
-           int Pid = TsPid(Data);
-           if (Pid == PATPID)
-              patPmtParser.ParsePat(Data, TS_SIZE);
-           else if (patPmtParser.IsPmtPid(Pid))
-              patPmtParser.ParsePmt(Data, TS_SIZE);
-           else if (Pid == patPmtParser.Vpid()) {
-              if (TsPayloadStart(Data)) {
-                 int l;
-                 while (const uchar *p = TsToPes.GetPes(l)) {
-                       int Offset = Size;
-                       int NewSize = Size + l;
-                       if (uchar *NewBuffer = (uchar *)realloc(buf, NewSize)) {
-                          Size = NewSize;
-                          buf = NewBuffer;
-                          memcpy(buf + Offset, p, l);
-                          }
-                       else {
-                          LOG_ERROR_STR("out of memory");
-                          free(buf);
-                          return;
-                          }
-                       }
-                 TsToPes.Reset();
-                 }
-              TsToPes.PutTs(Data, TS_SIZE);
-              }
-           Length -= TS_SIZE;
-           Data += TS_SIZE;
-           }
-     int l;
-     while (const uchar *p = TsToPes.GetPes(l)) {
-           int Offset = Size;
-           int NewSize = Size + l;
-           if (uchar *NewBuffer = (uchar *)realloc(buf, NewSize)) {
-              Size = NewSize;
-              buf = NewBuffer;
-              memcpy(buf + Offset, p, l);
-              }
-           else {
-              esyslog("ERROR: out of memory");
-              free(buf);
-              return;
-              }
-           }
-     if (buf) {
-        StillPicture(buf, Size);
-        free(buf);
-        }
-     }
-}
-
-bool cDevice::Replaying(void) const
-{
-  return player != NULL;
-}
-
-bool cDevice::Transferring(void) const
-{
-  return cTransferControl::ReceiverDevice() != NULL;
-}
-
-bool cDevice::AttachPlayer(cPlayer *Player)
-{
-  if (parentDevice)
-     return parentDevice->AttachPlayer(Player);
-  if (CanReplay()) {
-     SetIdle(false);
-     if (player)
-        Detach(player);
-     DELETENULL(liveSubtitle);
-     DELETENULL(dvbSubtitleConverter);
-     patPmtParser.Reset();
-     player = Player;
-     if (!Transferring())
-        ClrAvailableTracks(false, true);
-     SetPlayMode(player->playMode);
-     player->device = this;
-     player->Activate(true);
-     return true;
-     }
-  return false;
-}
-
-void cDevice::Detach(cPlayer *Player)
-{
-  if (parentDevice)
-     return parentDevice->Detach(Player);
-  if (Player && player == Player) {
-     cPlayer *p = player;
-     player = NULL; // avoids recursive calls to Detach()
-     p->Activate(false);
-     p->device = NULL;
-     cMutexLock MutexLock(&mutexCurrentSubtitleTrack);
-     delete dvbSubtitleConverter;
-     dvbSubtitleConverter = NULL;
-     SetPlayMode(pmNone);
-     SetVideoDisplayFormat(eVideoDisplayFormat(Setup.VideoDisplayFormat));
-     PlayTs(NULL, 0);
-     patPmtParser.Reset();
-     Audios.ClearAudio();
-     isPlayingVideo = false;
-     }
-}
-
-void cDevice::StopReplay(void)
-{
-  if (parentDevice)
-     return parentDevice->StopReplay();
-  if (player) {
-     Detach(player);
-     if (IsPrimaryDevice())
-        cControl::Shutdown();
-     }
-}
-
-bool cDevice::Poll(cPoller &Poller, int TimeoutMs)
-{
-  return false;
-}
-
-bool cDevice::Flush(int TimeoutMs)
-{
-  return true;
-}
-
-int cDevice::PlayVideo(const uchar *Data, int Length)
-{
-  return -1;
-}
-
-int cDevice::PlayAudio(const uchar *Data, int Length, uchar Id)
-{
-  return -1;
-}
-
-int cDevice::PlaySubtitle(const uchar *Data, int Length)
-{
-  if (!dvbSubtitleConverter)
-     dvbSubtitleConverter = new cDvbSubtitleConverter;
-  return dvbSubtitleConverter->ConvertFragments(Data, Length);
-}
-
-int cDevice::PlayPesPacket(const uchar *Data, int Length, bool VideoOnly)
-{
-  bool FirstLoop = true;
-  uchar c = Data[3];
-  const uchar *Start = Data;
-  const uchar *End = Start + Length;
-  while (Start < End) {
-        int d = End - Start;
-        int w = d;
-        switch (c) {
-          case 0xBE:          // padding stream, needed for MPEG1
-          case 0xE0 ... 0xEF: // video
-               isPlayingVideo = true;
-               w = PlayVideo(Start, d);
-               break;
-          case 0xC0 ... 0xDF: // audio
-               SetAvailableTrack(ttAudio, c - 0xC0, c);
-               if ((!VideoOnly || HasIBPTrickSpeed()) && c == availableTracks[currentAudioTrack].id) {
-                  w = PlayAudio(Start, d, c);
-                  if (FirstLoop)
-                     Audios.PlayAudio(Data, Length, c);
-                  }
-               break;
-          case 0xBD: { // private stream 1
-               // EBU Teletext data, ETSI EN 300 472
-               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
-               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
-                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
-                  break;
-                  }
-
-               int PayloadOffset = Data[8] + 9;
-
-               // Compatibility mode for old subtitles plugin:
-               if ((Data[7] & 0x01) && (Data[PayloadOffset - 3] & 0x81) == 0x01 && Data[PayloadOffset - 2] == 0x81)
-                  PayloadOffset--;
-
-               uchar SubStreamId = Data[PayloadOffset];
-               uchar SubStreamType = SubStreamId & 0xF0;
-               uchar SubStreamIndex = SubStreamId & 0x1F;
-
-               // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
-pre_1_3_19_PrivateStreamDetected:
-               if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
-                  SubStreamId = c;
-                  SubStreamType = 0x80;
-                  SubStreamIndex = 0;
-                  }
-               else if (pre_1_3_19_PrivateStream)
-                  pre_1_3_19_PrivateStream--; // every known PS1 packet counts down towards 0 to recover from glitches...
-               switch (SubStreamType) {
-                 case 0x20: // SPU
-                 case 0x30: // SPU
-                      SetAvailableTrack(ttSubtitle, SubStreamIndex, SubStreamId);
-                      if ((!VideoOnly || HasIBPTrickSpeed()) && currentSubtitleTrack != ttNone && SubStreamId == availableTracks[currentSubtitleTrack].id)
-                         w = PlaySubtitle(Start, d);
-                      break;
-                 case 0x80: // AC3 & DTS
-                      if (Setup.UseDolbyDigital) {
-                         SetAvailableTrack(ttDolby, SubStreamIndex, SubStreamId);
-                         if ((!VideoOnly || HasIBPTrickSpeed()) && SubStreamId == availableTracks[currentAudioTrack].id) {
-                            w = PlayAudio(Start, d, SubStreamId);
-                            if (FirstLoop)
-                               Audios.PlayAudio(Data, Length, SubStreamId);
-                            }
-                         }
-                      break;
-                 case 0xA0: // LPCM
-                      SetAvailableTrack(ttAudio, SubStreamIndex, SubStreamId);
-                      if ((!VideoOnly || HasIBPTrickSpeed()) && SubStreamId == availableTracks[currentAudioTrack].id) {
-                         w = PlayAudio(Start, d, SubStreamId);
-                         if (FirstLoop)
-                            Audios.PlayAudio(Data, Length, SubStreamId);
-                         }
-                      break;
-                 default:
-                      // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
-                      if (pre_1_3_19_PrivateStream <= MIN_PRE_1_3_19_PRIVATESTREAM) {
-                         dsyslog("unknown PS1 packet, substream id = %02X (counter is at %d)", SubStreamId, pre_1_3_19_PrivateStream);
-                         pre_1_3_19_PrivateStream += 2; // ...and every unknown PS1 packet counts up (the very first one counts twice, but that's ok)
-                         if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
-                            dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode - substream id = %02X", SubStreamId);
-                            ClrAvailableTracks();
-                            pre_1_3_19_PrivateStream = MIN_PRE_1_3_19_PRIVATESTREAM + 1;
-                            goto pre_1_3_19_PrivateStreamDetected;
-                            }
-                         }
-                 }
-               }
-               break;
-          default:
-               ;//esyslog("ERROR: unexpected packet id %02X", c);
-          }
-        if (w > 0)
-           Start += w;
-        else {
-           if (Start != Data)
-              esyslog("ERROR: incomplete PES packet write!");
-           return Start == Data ? w : Start - Data;
-           }
-        FirstLoop = false;
-        }
-  return Length;
-}
-
-int cDevice::PlayPes(const uchar *Data, int Length, bool VideoOnly)
-{
-  if (!Data) {
-     if (dvbSubtitleConverter)
-        dvbSubtitleConverter->Reset();
-     return 0;
-     }
-  int i = 0;
-  while (i <= Length - 6) {
-        if (Data[i] == 0x00 && Data[i + 1] == 0x00 && Data[i + 2] == 0x01) {
-           int l = PesLength(Data + i);
-           if (i + l > Length) {
-              esyslog("ERROR: incomplete PES packet!");
-              return Length;
-              }
-           int w = PlayPesPacket(Data + i, l, VideoOnly);
-           if (w > 0)
-              i += l;
-           else
-              return i == 0 ? w : i;
-           }
-        else
-           i++;
-        }
-  if (i < Length)
-     esyslog("ERROR: leftover PES data!");
-  return Length;
-}
-
-int cDevice::PlayTsVideo(const uchar *Data, int Length)
-{
-  // Video PES has no explicit length, so we can only determine the end of
-  // a PES packet when the next TS packet that starts a payload comes in:
-  if (TsPayloadStart(Data)) {
-     int l;
-     while (const uchar *p = tsToPesVideo.GetPes(l)) {
-           int w = PlayVideo(p, l);
-           if (w <= 0) {
-              tsToPesVideo.SetRepeatLast();
-              return w;
-              }
-           }
-     tsToPesVideo.Reset();
-     }
-  tsToPesVideo.PutTs(Data, Length);
-  return Length;
-}
-
-int cDevice::PlayTsAudio(const uchar *Data, int Length)
-{
-  // Audio PES always has an explicit length and consists of single packets:
-  int l;
-  if (const uchar *p = tsToPesAudio.GetPes(l)) {
-     int w = PlayAudio(p, l, p[3]);
-     if (w <= 0) {
-        tsToPesAudio.SetRepeatLast();
-        return w;
-        }
-     tsToPesAudio.Reset();
-     }
-  tsToPesAudio.PutTs(Data, Length);
-  return Length;
-}
-
-int cDevice::PlayTsSubtitle(const uchar *Data, int Length)
-{
-  if (!dvbSubtitleConverter)
-     dvbSubtitleConverter = new cDvbSubtitleConverter;
-  tsToPesSubtitle.PutTs(Data, Length);
-  int l;
-  if (const uchar *p = tsToPesSubtitle.GetPes(l)) {
-     dvbSubtitleConverter->Convert(p, l);
-     tsToPesSubtitle.Reset();
-     }
-  return Length;
-}
-
-//TODO detect and report continuity errors?
-int cDevice::PlayTs(const uchar *Data, int Length, bool VideoOnly)
-{
-  int Played = 0;
-  if (!Data) {
-     tsToPesVideo.Reset();
-     tsToPesAudio.Reset();
-     tsToPesSubtitle.Reset();
-     tsToPesTeletext.Reset();
-     }
-  else if (Length < TS_SIZE) {
-     esyslog("ERROR: skipped %d bytes of TS fragment", Length);
-     return Length;
-     }
-  else {
-     while (Length >= TS_SIZE) {
-           if (Data[0] != TS_SYNC_BYTE) {
-              int Skipped = 1;
-              while (Skipped < Length && (Data[Skipped] != TS_SYNC_BYTE || Length - Skipped > TS_SIZE && Data[Skipped + TS_SIZE] != TS_SYNC_BYTE))
-                    Skipped++;
-              esyslog("ERROR: skipped %d bytes to sync on start of TS packet", Skipped);
-              return Played + Skipped;
-              }
-           int Pid = TsPid(Data);
-           if (TsHasPayload(Data)) { // silently ignore TS packets w/o payload
-              int PayloadOffset = TsPayloadOffset(Data);
-              if (PayloadOffset < TS_SIZE) {
-                 if (Pid == PATPID)
-                    patPmtParser.ParsePat(Data, TS_SIZE);
-                 else if (patPmtParser.IsPmtPid(Pid))
-                    patPmtParser.ParsePmt(Data, TS_SIZE);
-                 else if (Pid == patPmtParser.Vpid()) {
-                    isPlayingVideo = true;
-                    int w = PlayTsVideo(Data, TS_SIZE);
-                    if (w < 0)
-                       return Played ? Played : w;
-                    if (w == 0)
-                       break;
-                    }
-                 else if (Pid == availableTracks[currentAudioTrack].id) {
-                    if (!VideoOnly || HasIBPTrickSpeed()) {
-                       int w = PlayTsAudio(Data, TS_SIZE);
-                       if (w < 0)
-                          return Played ? Played : w;
-                       if (w == 0)
-                          break;
-                       Audios.PlayTsAudio(Data, TS_SIZE);
-                       }
-                    }
-                 else if (Pid == availableTracks[currentSubtitleTrack].id) {
-                    if (!VideoOnly || HasIBPTrickSpeed())
-                       PlayTsSubtitle(Data, TS_SIZE);
-                    }
-                 else if (Pid == patPmtParser.Tpid()) {
-                    if (!VideoOnly || HasIBPTrickSpeed()) {
-                       int l;
-                       tsToPesTeletext.PutTs(Data, Length);
-                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
-                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
-                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false, patPmtParser.TeletextSubtitlePages(), patPmtParser.TotalTeletextSubtitlePages());
-                          tsToPesTeletext.Reset();
-                          }
-                       }
-                    }
-                 }
-              }
-           else if (Pid == patPmtParser.Ppid()) {
-              int w = PlayTsVideo(Data, TS_SIZE);
-              if (w < 0)
-                 return Played ? Played : w;
-              if (w == 0)
-                 break;
-              }
-           Played += TS_SIZE;
-           Length -= TS_SIZE;
-           Data += TS_SIZE;
-           }
-     }
-  return Played;
-}
-
-int cDevice::Priority(void) const
-{
-  if (parentDevice)
-     return parentDevice->Priority();
-  int priority = IDLEPRIORITY;
-  if (IsPrimaryDevice() && !Replaying() && HasProgramme())
-     priority = TRANSFERPRIORITY; // we use the same value here, no matter whether it's actual Transfer Mode or real live viewing
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (receiver[i])
-         priority = max(receiver[i]->priority, priority);
-      }
-  return priority;
-}
-
-bool cDevice::Ready(void)
-{
-  return true;
-}
-
-bool cDevice::Receiving(bool Dummy) const
-{
-  if (parentDevice)
-     return parentDevice->Receiving(Dummy);
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (receiver[i])
-         return true;
-      }
-  return false;
-}
-
-#define TS_SCRAMBLING_TIMEOUT     3 // seconds to wait until a TS becomes unscrambled
-#define TS_SCRAMBLING_TIME_OK    10 // seconds before a Channel/CAM combination is marked as known to decrypt
-
-void cDevice::Action(void)
-{
-  if (Running() && OpenDvr()) {
-     while (Running()) {
-           // Read data from the DVR device:
-           uchar *b = NULL;
-           if (GetTSPacket(b)) {
-              if (b) {
-                 int Pid = TsPid(b);
-                 // Check whether the TS packets are scrambled:
-                 bool DetachReceivers = false;
-                 bool DescramblingOk = false;
-                 int CamSlotNumber = 0;
-                 if (startScrambleDetection) {
-                    cCamSlot *cs = CamSlot();
-                    CamSlotNumber = cs ? cs->SlotNumber() : 0;
-                    if (CamSlotNumber) {
-                       bool Scrambled = b[3] & TS_SCRAMBLING_CONTROL;
-                       int t = time(NULL) - startScrambleDetection;
-                       if (Scrambled) {
-                          if (t > TS_SCRAMBLING_TIMEOUT)
-                             DetachReceivers = true;
-                          }
-                       else if (t > TS_SCRAMBLING_TIME_OK) {
-                          DescramblingOk = true;
-                          startScrambleDetection = 0;
-                          }
-                       }
-                    }
-                 // Distribute the packet to all attached receivers:
-                 Lock();
-                 for (int i = 0; i < MAXRECEIVERS; i++) {
-                     if (receiver[i] && receiver[i]->WantsPid(Pid)) {
-                        if (DetachReceivers) {
-                           ChannelCamRelations.SetChecked(receiver[i]->ChannelID(), CamSlotNumber);
-                           Detach(receiver[i]);
-                           }
-                        else
-                           receiver[i]->Receive(b, TS_SIZE);
-                        if (DescramblingOk)
-                           ChannelCamRelations.SetDecrypt(receiver[i]->ChannelID(), CamSlotNumber);
-                        }
-                     }
-                 Unlock();
-                 }
-              }
-           else
-              break;
-           }
-     CloseDvr();
-     }
-}
-
-bool cDevice::OpenDvr(void)
-{
-  return false;
-}
-
-void cDevice::CloseDvr(void)
-{
-}
-
-bool cDevice::GetTSPacket(uchar *&Data)
-{
-  return false;
-}
-
-bool cDevice::AttachReceiver(cReceiver *Receiver)
-{
-  if (parentDevice)
-     return parentDevice->AttachReceiver(Receiver);
-  if (!Receiver)
-     return false;
-  if (Receiver->device == this)
-     return true;
-  SetIdle(false);
-// activate the following line if you need it - actually the driver should be fixed!
-//#define WAIT_FOR_TUNER_LOCK
-#ifdef WAIT_FOR_TUNER_LOCK
-#define TUNER_LOCK_TIMEOUT 5000 // ms
-  if (!HasLock(TUNER_LOCK_TIMEOUT)) {
-     esyslog("ERROR: device %d has no lock, can't attach receiver!", CardIndex() + 1);
-     return false;
-     }
-#endif
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (!receiver[i]) {
-         for (int n = 0; n < Receiver->numPids; n++) {
-             if (!AddPid(Receiver->pids[n])) {
-                for ( ; n-- > 0; )
-                    DelPid(Receiver->pids[n]);
-                return false;
-                }
-             }
-         Receiver->Activate(true);
-         Lock();
-         Receiver->device = this;
-         receiver[i] = Receiver;
-         Unlock();
-         if (camSlot) {
-            camSlot->StartDecrypting();
-            startScrambleDetection = time(NULL);
-            }
-         Start();
-         return true;
-         }
-      }
-  esyslog("ERROR: no free receiver slot!");
-  return false;
-}
-
-void cDevice::Detach(cReceiver *Receiver)
-{
-  if (parentDevice)
-     return parentDevice->Detach(Receiver);
-  if (!Receiver || Receiver->device != this)
-     return;
-  bool receiversLeft = false;
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (receiver[i] == Receiver) {
-         Lock();
-         receiver[i] = NULL;
-         Receiver->device = NULL;
-         Unlock();
-         Receiver->Activate(false);
-         for (int n = 0; n < Receiver->numPids; n++)
-             DelPid(Receiver->pids[n]);
-         }
-      else if (receiver[i])
-         receiversLeft = true;
-      }
-  if (camSlot)
-     camSlot->StartDecrypting();
-  if (!receiversLeft)
-     Cancel(-1);
-}
-
-void cDevice::DetachAll(int Pid)
-{
-  if (parentDevice)
-     return parentDevice->DetachAll(Pid);
-  if (Pid) {
-     cMutexLock MutexLock(&mutexReceiver);
-     for (int i = 0; i < MAXRECEIVERS; i++) {
-         cReceiver *Receiver = receiver[i];
-         if (Receiver && Receiver->WantsPid(Pid))
-            Detach(Receiver);
-         }
-     }
-}
-
-void cDevice::DetachAllReceivers(void)
-{
-  if (parentDevice)
-     return parentDevice->DetachAllReceivers();
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++)
-      Detach(receiver[i]);
-}
-
-// --- cTSBuffer -------------------------------------------------------------
-
-cTSBuffer::cTSBuffer(int File, int Size, int CardIndex)
-{
-  SetDescription("TS buffer on device %d", CardIndex);
-  f = File;
-  cardIndex = CardIndex;
-  delivered = false;
-  ringBuffer = new cRingBufferLinear(Size, TS_SIZE, true, "TS");
-  ringBuffer->SetTimeouts(100, 100);
-  ringBuffer->SetIoThrottle();
-  Start();
-}
-
-cTSBuffer::~cTSBuffer()
-{
-  Cancel(3);
-  delete ringBuffer;
-}
-
-void cTSBuffer::Action(void)
-{
-  if (ringBuffer) {
-     bool firstRead = true;
-     cPoller Poller(f);
-     while (Running()) {
-           if (firstRead || Poller.Poll(100)) {
-              firstRead = false;
-              int r = ringBuffer->Read(f);
-              if (r < 0 && FATALERRNO) {
-                 if (errno == EOVERFLOW)
-                    esyslog("ERROR: driver buffer overflow on device %d", cardIndex);
-                 else {
-                    LOG_ERROR;
-                    break;
-                    }
-                 }
-              }
-           }
-     }
-}
-
-uchar *cTSBuffer::Get(void)
-{
-  int Count = 0;
-  if (delivered) {
-     ringBuffer->Del(TS_SIZE);
-     delivered = false;
-     }
-  uchar *p = ringBuffer->Get(Count);
-  if (p && Count >= TS_SIZE) {
-     if (*p != TS_SYNC_BYTE) {
-        for (int i = 1; i < Count; i++) {
-            if (p[i] == TS_SYNC_BYTE) {
-               Count = i;
-               break;
-               }
-            }
-        ringBuffer->Del(Count);
-        esyslog("ERROR: skipped %d bytes to sync on TS packet on device %d", Count, cardIndex);
-        return NULL;
-        }
-     delivered = true;
-     return p;
-     }
-  return NULL;
-}
-
-// --- cDynamicDeviceProbe -------------------------------------------------------
-
-cList<cDynamicDeviceProbe> DynamicDeviceProbes;
-
-cList<cDynamicDeviceProbe::cDynamicDeviceProbeItem> cDynamicDeviceProbe::commandQueue;
-
-void cDynamicDeviceProbe::QueueDynamicDeviceCommand(eDynamicDeviceProbeCommand Cmd, const char *DevPath)
-{
-  if (DevPath)
-     commandQueue.Add(new cDynamicDeviceProbeItem(Cmd, new cString(DevPath)));
-}
-
-cDynamicDeviceProbe::cDynamicDeviceProbe(void)
-{
-  DynamicDeviceProbes.Add(this);
-}
-
-cDynamicDeviceProbe::~cDynamicDeviceProbe()
-{
-  DynamicDeviceProbes.Del(this, false);
-}
diff -urN vdr-2.0.4-org/device.h vdr-2.0.4/device.h
--- vdr-2.0.4-org/device.h	2013-10-25 09:44:22.456680545 +0200
+++ vdr-2.0.4/device.h	2013-10-25 10:07:11.952704053 +0200
@@ -34,7 +34,7 @@
 #define VOLUMEDELTA       (MAXVOLUME/Setup.VolumeSteps) // used to increase/decrease the volume
 #define MAXOCCUPIEDTIMEOUT 99 // max. time (in seconds) a device may be occupied
 
-enum eSetChannelResult { scrOk, scrNotAvailable, scrNoTransfer, scrFailed };
+enum eSetChannelResult { scrOk, scrNotAvailable, scrNoTransfer, scrFailed, srcStillWritingLiveBuffer };
 
 enum ePlayMode { pmNone,           // audio/video from decoder
                  pmAudioVideo,     // audio/video from player
diff -urN vdr-2.0.4-org/device.h.orig vdr-2.0.4/device.h.orig
--- vdr-2.0.4-org/device.h.orig	2013-10-25 09:44:22.472680545 +0200
+++ vdr-2.0.4/device.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,904 +0,0 @@
-/*
- * device.h: The basic device interface
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: device.h 2.47.1.1 2013/08/22 12:01:48 kls Exp $
- */
-
-#ifndef __DEVICE_H
-#define __DEVICE_H
-
-#include "channels.h"
-#include "ci.h"
-#include "dvbsubtitle.h"
-#include "eit.h"
-#include "filter.h"
-#include "nit.h"
-#include "pat.h"
-#include "remux.h"
-#include "ringbuffer.h"
-#include "sdt.h"
-#include "sections.h"
-#include "spu.h"
-#include "thread.h"
-#include "tools.h"
-#include <asm/types.h>
-#include <linux/dvb/frontend.h>
-
-#define MAXDEVICES         16 // the maximum number of devices in the system
-#define MAXPIDHANDLES      64 // the maximum number of different PIDs per device
-#define MAXRECEIVERS       16 // the maximum number of receivers per device
-#define MAXVOLUME         255
-#define VOLUMEDELTA       (MAXVOLUME/Setup.VolumeSteps) // used to increase/decrease the volume
-#define MAXOCCUPIEDTIMEOUT 99 // max. time (in seconds) a device may be occupied
-
-enum eSetChannelResult { scrOk, scrNotAvailable, scrNoTransfer, scrFailed };
-
-enum ePlayMode { pmNone,           // audio/video from decoder
-                 pmAudioVideo,     // audio/video from player
-                 pmAudioOnly,      // audio only from player, video from decoder
-                 pmAudioOnlyBlack, // audio only from player, no video (black screen)
-                 pmVideoOnly,      // video only from player, audio from decoder
-                 pmExtern_THIS_SHOULD_BE_AVOIDED
-                 // external player (e.g. MPlayer), release the device
-                 // WARNING: USE THIS MODE ONLY AS A LAST RESORT, IF YOU
-                 // ABSOLUTELY, POSITIVELY CAN'T IMPLEMENT YOUR PLAYER
-                 // THE WAY IT IS SUPPOSED TO WORK. FORCING THE DEVICE
-                 // TO RELEASE ITS FILES HANDLES (OR WHATEVER RESOURCES
-                 // IT MAY USE) TO ALLOW AN EXTERNAL PLAYER TO ACCESS
-                 // THEM MEANS THAT SUCH A PLAYER WILL NEED TO HAVE
-                 // DETAILED KNOWLEDGE ABOUT THE INTERNALS OF THE DEVICE
-                 // IN USE. AS A CONSEQUENCE, YOUR PLAYER MAY NOT WORK
-                 // IF A PARTICULAR VDR INSTALLATION USES A DEVICE NOT
-                 // KNOWN TO YOUR PLAYER.
-               };
-
-enum eVideoSystem { vsPAL,
-                    vsNTSC
-                  };
-
-enum eVideoDisplayFormat { vdfPanAndScan,
-                           vdfLetterBox,
-                           vdfCenterCutOut
-                         };
-
-enum eTrackType { ttNone,
-                  ttAudio,
-                  ttAudioFirst = ttAudio,
-                  ttAudioLast  = ttAudioFirst + 31, // MAXAPIDS - 1
-                  ttDolby,
-                  ttDolbyFirst = ttDolby,
-                  ttDolbyLast  = ttDolbyFirst + 15, // MAXDPIDS - 1
-                  ttSubtitle,
-                  ttSubtitleFirst = ttSubtitle,
-                  ttSubtitleLast  = ttSubtitleFirst + 31, // MAXSPIDS - 1
-                  ttMaxTrackTypes
-                };
-
-#define IS_AUDIO_TRACK(t) (ttAudioFirst <= (t) && (t) <= ttAudioLast)
-#define IS_DOLBY_TRACK(t) (ttDolbyFirst <= (t) && (t) <= ttDolbyLast)
-#define IS_SUBTITLE_TRACK(t) (ttSubtitleFirst <= (t) && (t) <= ttSubtitleLast)
-
-struct tTrackId {
-  uint16_t id;                  // The PES packet id or the PID.
-  char language[MAXLANGCODE2];  // something like either "eng" or "deu+eng"
-  char description[32];         // something like "Dolby Digital 5.1"
-  };
-
-class cPlayer;
-class cReceiver;
-class cLiveSubtitle;
-
-class cDeviceHook : public cListObject {
-public:
-  cDeviceHook(void);
-          ///< Creates a new device hook object.
-          ///< Do not delete this object - it will be automatically deleted when the
-          ///< program ends.
-  virtual bool DeviceProvidesTransponder(const cDevice *Device, const cChannel *Channel) const;
-          ///< Returns true if the given Device can provide the given Channel's transponder.
-  };
-
-/// The cDevice class is the base from which actual devices can be derived.
-
-class cDevice : public cThread {
-  friend class cLiveSubtitle;
-  friend class cDeviceHook;
-private:
-  static int numDevices;
-  static int useDevice;
-  static cDevice *device[MAXDEVICES];
-  static cDevice *primaryDevice;
-public:
-  static int NumDevices(void) { return numDevices; }
-         ///< Returns the total number of devices.
-  static bool WaitForAllDevicesReady(int Timeout = 0);
-         ///< Waits until all devices have become ready, or the given Timeout
-         ///< (seconds) has expired. While waiting, the Ready() function of each
-         ///< device is called in turn, until they all return true.
-         ///< Returns true if all devices have become ready within the given
-         ///< timeout.
-  static void SetUseDevice(int n);
-         ///< Sets the 'useDevice' flag of the given device.
-         ///< If this function is not called before initializing, all devices
-         ///< will be used.
-  static bool UseDevice(int n) { return useDevice == 0 || (useDevice & (1 << n)) != 0; }
-         ///< Tells whether the device with the given card index shall be used in
-         ///< this instance of VDR.
-  static bool SetPrimaryDevice(int n);
-         ///< Sets the primary device to 'n'.
-         ///< n must be in the range 1...numDevices.
-         ///< Returns true if this was possible.
-  static cDevice *PrimaryDevice(void) { return primaryDevice; }
-         ///< Returns the primary device.
-  static cDevice *ActualDevice(void);
-         ///< Returns the actual receiving device in case of Transfer Mode, or the
-         ///< primary device otherwise.
-  static cDevice *GetDevice(int Index);
-         ///< Gets the device with the given Index.
-         ///< Index must be in the range 0..numDevices-1.
-         ///< Returns a pointer to the device, or NULL if the Index was invalid.
-  static cDevice *GetDevice(const cChannel *Channel, int Priority, bool LiveView, bool Query = false);
-         ///< Returns a device that is able to receive the given Channel at the
-         ///< given Priority, with the least impact on active recordings and
-         ///< live viewing. The LiveView parameter tells whether the device will
-         ///< be used for live viewing or a recording.
-         ///< If the Channel is encrypted, a CAM slot that claims to be able to
-         ///< decrypt the channel is automatically selected and assigned to the
-         ///< returned device. Whether or not this combination of device and CAM
-         ///< slot is actually able to decrypt the channel can only be determined
-         ///< by checking the "scrambling control" bits of the received TS packets.
-         ///< The Action() function automatically does this and takes care that
-         ///< after detaching any receivers because the channel can't be decrypted,
-         ///< this device/CAM combination will be skipped in the next call to
-         ///< GetDevice().
-         ///< If Query is true, no actual CAM assignments or receiver detachments will
-         ///< be done, so that this function can be called without any side effects
-         ///< in order to just determine whether a device is available for the given
-         ///< Channel.
-         ///< See also ProvidesChannel().
-  static cDevice *GetDeviceForTransponder(const cChannel *Channel, int Priority);
-         ///< Returns a device that is not currently "occupied" and can be tuned to
-         ///< the transponder of the given Channel, without disturbing any receiver
-         ///< at priorities higher or equal to Priority.
-         ///< If no such device is currently available, NULL will be returned.
-  static void Shutdown(void);
-         ///< Closes down all devices.
-         ///< Must be called at the end of the program.
-private:
-  static int nextCardIndex;
-  int cardIndex;
-protected:
-  virtual ~cDevice();
-  virtual bool Ready(void);
-         ///< Returns true if this device is ready. Devices with conditional
-         ///< access hardware may need some time until they are up and running.
-         ///< This function is called in a loop at startup until all devices
-         ///< are ready (see WaitForAllDevicesReady()).
-  static int NextCardIndex(int n = 0);
-         ///< Calculates the next card index.
-         ///< Each device in a given machine must have a unique card index, which
-         ///< will be used to identify the device for assigning Ca parameters and
-         ///< deciding whether to actually use that device in this particular
-         ///< instance of VDR. Every time a new cDevice is created, it will be
-         ///< given the current nextCardIndex, and then nextCardIndex will be
-         ///< automatically incremented by 1. A derived class can determine whether
-         ///< a given device shall be used by checking UseDevice(NextCardIndex()).
-         ///< If a device is skipped, or if there are possible device indexes left
-         ///< after a derived class has set up all its devices, NextCardIndex(n)
-         ///< must be called, where n is the number of card indexes to skip.
-  virtual void MakePrimaryDevice(bool On);
-         ///< Informs a device that it will be the primary device. If there is
-         ///< anything the device needs to set up when it becomes the primary
-         ///< device (On = true) or to shut down when it no longer is the primary
-         ///< device (On = false), it should do so in this function.
-         ///< A derived class must call the MakePrimaryDevice() function of its
-         ///< base class.
-public:
-  int DeviceNumber(void) const;
-         ///< Returns the number of this device (0 ... numDevices).
-  virtual cString DeviceType(void) const;
-         ///< Returns a string identifying the type of this device (like "DVB-S").
-         ///< If this device can receive different delivery systems, the returned
-         ///< string shall be that of the currently used system.
-         ///< The length of the returned string should not exceed 6 characters.
-         ///< The default implementation returns an empty string.
-  virtual cString DeviceName(void) const;
-         ///< Returns a string identifying the name of this device.
-         ///< The default implementation returns an empty string.
-  virtual bool HasDecoder(void) const;
-         ///< Tells whether this device has an MPEG decoder.
-  virtual bool AvoidRecording(void) const { return false; }
-         ///< Returns true if this device should only be used for recording
-         ///< if no other device is available.
-
-// Device hooks
-
-private:
-  static cList<cDeviceHook> deviceHooks;
-protected:
-  bool DeviceHooksProvidesTransponder(const cChannel *Channel) const;
-
-// SPU facilities
-
-private:
-  cLiveSubtitle *liveSubtitle;
-  cDvbSubtitleConverter *dvbSubtitleConverter;
-public:
-  virtual cSpuDecoder *GetSpuDecoder(void);
-         ///< Returns a pointer to the device's SPU decoder (or NULL, if this
-         ///< device doesn't have an SPU decoder).
-
-// Channel facilities
-
-private:
-  time_t occupiedTimeout;
-protected:
-  static int currentChannel;
-public:
-  virtual bool ProvidesSource(int Source) const;
-         ///< Returns true if this device can provide the given source.
-  virtual bool ProvidesTransponder(const cChannel *Channel) const;
-         ///< Returns true if this device can provide the transponder of the
-         ///< given Channel (which implies that it can provide the Channel's
-         ///< source).
-  virtual bool ProvidesTransponderExclusively(const cChannel *Channel) const;
-         ///< Returns true if this is the only device that is able to provide
-         ///< the given channel's transponder.
-  virtual bool ProvidesChannel(const cChannel *Channel, int Priority = IDLEPRIORITY, bool *NeedsDetachReceivers = NULL) const;
-         ///< Returns true if this device can provide the given channel.
-         ///< In case the device has cReceivers attached to it, Priority is used to
-         ///< decide whether the caller's request can be honored.
-         ///< The special Priority value IDLEPRIORITY will tell the caller whether this device
-         ///< is principally able to provide the given Channel, regardless of any
-         ///< attached cReceivers.
-         ///< If NeedsDetachReceivers is given, the resulting value in it will tell the
-         ///< caller whether or not it will have to detach any currently attached
-         ///< receivers from this device before calling SwitchChannel. Note
-         ///< that the return value in NeedsDetachReceivers is only meaningful if the
-         ///< function itself actually returns true.
-         ///< The default implementation always returns false, so a derived cDevice
-         ///< class that can provide channels must implement this function.
-  virtual bool ProvidesEIT(void) const;
-         ///< Returns true if this device provides EIT data and thus wants to be tuned
-         ///< to the channels it can receive regularly to update the data.
-         ///< The default implementation returns false.
-  virtual int NumProvidedSystems(void) const;
-         ///< Returns the number of individual "delivery systems" this device provides.
-         ///< The default implementation returns 0, so any derived class that can
-         ///< actually provide channels must implement this function.
-         ///< The result of this function is used when selecting a device, in order
-         ///< to avoid devices that provide more than one system.
-  virtual int SignalStrength(void) const;
-         ///< Returns the "strength" of the currently received signal.
-         ///< This is a value in the range 0 (no signal at all) through
-         ///< 100 (best possible signal). A value of -1 indicates that this
-         ///< device has no concept of a "signal strength".
-  virtual int SignalQuality(void) const;
-         ///< Returns the "quality" of the currently received signal.
-         ///< This is a value in the range 0 (worst quality) through
-         ///< 100 (best possible quality). A value of -1 indicates that this
-         ///< device has no concept of a "signal quality".
-  virtual const cChannel *GetCurrentlyTunedTransponder(void) const;
-         ///< Returns a pointer to the currently tuned transponder.
-         ///< This is not one of the channels in the global cChannels list, but rather
-         ///< a local copy. The result may be NULL if the device is not tuned to any
-         ///< transponder.
-  virtual bool IsTunedToTransponder(const cChannel *Channel) const;
-         ///< Returns true if this device is currently tuned to the given Channel's
-         ///< transponder.
-  virtual bool MaySwitchTransponder(const cChannel *Channel) const;
-         ///< Returns true if it is ok to switch to the Channel's transponder on this
-         ///< device, without disturbing any other activities. If an occupied timeout
-         ///< has been set for this device, and that timeout has not yet expired,
-         ///< this function returns false,
-  bool SwitchChannel(const cChannel *Channel, bool LiveView);
-         ///< Switches the device to the given Channel, initiating transfer mode
-         ///< if necessary.
-  static bool SwitchChannel(int Direction);
-         ///< Switches the primary device to the next available channel in the given
-         ///< Direction (only the sign of Direction is evaluated, positive values
-         ///< switch to higher channel numbers).
-private:
-  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
-         ///< Sets the device to the given channel (general setup).
-protected:
-  virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
-         ///< Sets the device to the given channel (actual physical setup).
-public:
-  static int CurrentChannel(void) { return primaryDevice ? currentChannel : 0; }
-         ///< Returns the number of the current channel on the primary device.
-  static void SetCurrentChannel(const cChannel *Channel) { currentChannel = Channel ? Channel->Number() : 0; }
-         ///< Sets the number of the current channel on the primary device, without
-         ///< actually switching to it. This can be used to correct the current
-         ///< channel number while replaying.
-  void ForceTransferMode(void);
-         ///< Forces the device into transfermode for the current channel.
-  int Occupied(void) const;
-         ///< Returns the number of seconds this device is still occupied for.
-  void SetOccupied(int Seconds);
-         ///< Sets the occupied timeout for this device to the given number of
-         ///< Seconds, This can be used to tune a device to a particular transponder
-         ///< and make sure it will stay there for a certain amount of time, for
-         ///< instance to collect EPG data. This function shall only be called
-         ///< after the device has been successfully tuned to the requested transponder.
-         ///< Seconds will be silently limited to MAXOCCUPIEDTIMEOUT. Values less than
-         ///< 0 will be silently ignored.
-  virtual bool HasLock(int TimeoutMs = 0) const;
-         ///< Returns true if the device has a lock on the requested transponder.
-         ///< Default is true, a specific device implementation may return false
-         ///< to indicate that it is not ready yet.
-         ///< If TimeoutMs is not zero, waits for the given number of milliseconds
-         ///< before returning false.
-  virtual bool HasProgramme(void) const;
-         ///< Returns true if the device is currently showing any programme to
-         ///< the user, either through replaying or live.
-  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd) {return false;}
-
-// PID handle facilities
-
-private:
-  virtual void Action(void);
-protected:
-  enum ePidType { ptAudio, ptVideo, ptPcr, ptTeletext, ptDolby, ptOther };
-  class cPidHandle {
-  public:
-    int pid;
-    int streamType;
-    int handle;
-    int used;
-    cPidHandle(void) { pid = streamType = used = 0; handle = -1; }
-    };
-  cPidHandle pidHandles[MAXPIDHANDLES];
-  bool HasPid(int Pid) const;
-         ///< Returns true if this device is currently receiving the given PID.
-  bool AddPid(int Pid, ePidType PidType = ptOther, int StreamType = 0);
-         ///< Adds a PID to the set of PIDs this device shall receive.
-  void DelPid(int Pid, ePidType PidType = ptOther);
-         ///< Deletes a PID from the set of PIDs this device shall receive.
-  virtual bool SetPid(cPidHandle *Handle, int Type, bool On);
-         ///< Does the actual PID setting on this device.
-         ///< On indicates whether the PID shall be added or deleted.
-         ///< Handle->handle can be used by the device to store information it
-         ///< needs to receive this PID (for instance a file handle).
-         ///< Handle->used indicates how many receivers are using this PID.
-         ///< Type indicates some special types of PIDs, which the device may
-         ///< need to set in a specific way.
-public:
-  void DelLivePids(void);
-         ///< Deletes the live viewing PIDs.
-
-// Section filter facilities
-
-private:
-  cSectionHandler *sectionHandler;
-  cEitFilter *eitFilter;
-  cPatFilter *patFilter;
-  cSdtFilter *sdtFilter;
-  cNitFilter *nitFilter;
-protected:
-  void StartSectionHandler(void);
-       ///< A derived device that provides section data must call
-       ///< this function (typically in its constructor) to actually set
-       ///< up the section handler.
-  void StopSectionHandler(void);
-       ///< A device that has called StartSectionHandler() must call this
-       ///< function (typically in its destructor) to stop the section
-       ///< handler.
-public:
-  virtual int OpenFilter(u_short Pid, u_char Tid, u_char Mask);
-       ///< Opens a file handle for the given filter data.
-       ///< A derived device that provides section data must
-       ///< implement this function.
-  virtual int ReadFilter(int Handle, void *Buffer, size_t Length);
-       ///< Reads data from a handle for the given filter.
-       ///< A derived class need not implement this function, because this
-       ///< is done by the default implementation.
-  virtual void CloseFilter(int Handle);
-       ///< Closes a file handle that has previously been opened
-       ///< by OpenFilter(). If this is as simple as calling close(Handle),
-       ///< a derived class need not implement this function, because this
-       ///< is done by the default implementation.
-  void AttachFilter(cFilter *Filter);
-       ///< Attaches the given filter to this device.
-  void Detach(cFilter *Filter);
-       ///< Detaches the given filter from this device.
-
-// Common Interface facilities:
-
-private:
-  time_t startScrambleDetection;
-  cCamSlot *camSlot;
-public:
-  virtual bool HasCi(void);
-         ///< Returns true if this device has a Common Interface.
-  virtual bool HasInternalCam(void) { return false; }
-         ///< Returns true if this device handles encrypted channels itself
-         ///< without VDR assistance. This can be e.g. if the device is a
-         ///< client that gets the stream from another VDR instance that has
-         ///< already decrypted the stream. In this case ProvidesChannel()
-         ///< shall check whether the channel can be decrypted.
-  void SetCamSlot(cCamSlot *CamSlot);
-         ///< Sets the given CamSlot to be used with this device.
-
-// Image Grab facilities
-
-public:
-  virtual uchar *GrabImage(int &Size, bool Jpeg = true, int Quality = -1, int SizeX = -1, int SizeY = -1);
-         ///< Grabs the currently visible screen image.
-         ///< Size is the size of the returned data block.
-         ///< If Jpeg is true it will write a JPEG file. Otherwise a PNM file will be written.
-         ///< Quality is the compression factor for JPEG. 1 will create a very blocky
-         ///< and small image, 70..80 will yield reasonable quality images while keeping the
-         ///< image file size around 50 KB for a full frame. The default will create a big
-         ///< but very high quality image.
-         ///< SizeX is the number of horizontal pixels in the frame (default is the current screen width).
-         ///< SizeY is the number of vertical pixels in the frame (default is the current screen height).
-         ///< Returns a pointer to the grabbed image data, or NULL in case of an error.
-         ///< The caller takes ownership of the returned memory and must free() it once it isn't needed any more.
-  bool GrabImageFile(const char *FileName, bool Jpeg = true, int Quality = -1, int SizeX = -1, int SizeY = -1);
-         ///< Calls GrabImage() and stores the resulting image in a file with the given name.
-         ///< Returns true if all went well.
-         ///< The caller is responsible for making sure that the given file name
-         ///< doesn't lead to overwriting any important other file.
-
-// Video format facilities
-
-public:
-  virtual void SetVideoDisplayFormat(eVideoDisplayFormat VideoDisplayFormat);
-         ///< Sets the video display format to the given one (only useful
-         ///< if this device has an MPEG decoder).
-         ///< A derived class must first call the base class function!
-  virtual void SetVideoFormat(bool VideoFormat16_9);
-         ///< Sets the output video format to either 16:9 or 4:3 (only useful
-         ///< if this device has an MPEG decoder).
-  virtual eVideoSystem GetVideoSystem(void);
-         ///< Returns the video system of the currently displayed material
-         ///< (default is PAL).
-  virtual void GetVideoSize(int &Width, int &Height, double &VideoAspect);
-         ///< Returns the Width, Height and VideoAspect ratio of the currently
-         ///< displayed video material. Width and Height are given in pixel
-         ///< (e.g. 720x576) and VideoAspect is e.g. 1.33333 for a 4:3 broadcast,
-         ///< or 1.77778 for 16:9.
-         ///< The default implementation returns 0 for Width and Height
-         ///< and 1.0 for VideoAspect.
-  virtual void GetOsdSize(int &Width, int &Height, double &PixelAspect);
-         ///< Returns the Width, Height and PixelAspect ratio the OSD should use
-         ///< to best fit the resolution of the output device. If PixelAspect
-         ///< is not 1.0, the OSD may take this as a hint to scale its
-         ///< graphics in a way that, e.g., a circle will actually
-         ///< show up as a circle on the screen, and not as an ellipse.
-         ///< Values greater than 1.0 mean to stretch the graphics in the
-         ///< vertical direction (or shrink it in the horizontal direction,
-         ///< depending on which dimension shall be fixed). Values less than
-         ///< 1.0 work the other way round. Note that the OSD is not guaranteed
-         ///< to actually use this hint.
-
-// Track facilities
-
-private:
-  tTrackId availableTracks[ttMaxTrackTypes];
-  eTrackType currentAudioTrack;
-  eTrackType currentSubtitleTrack;
-  cMutex mutexCurrentAudioTrack;
-  cMutex mutexCurrentSubtitleTrack;
-  int currentAudioTrackMissingCount;
-  bool autoSelectPreferredSubtitleLanguage;
-  bool keepTracks;
-  int pre_1_3_19_PrivateStream;
-protected:
-  virtual void SetAudioTrackDevice(eTrackType Type);
-       ///< Sets the current audio track to the given value.
-  virtual void SetSubtitleTrackDevice(eTrackType Type);
-       ///< Sets the current subtitle track to the given value.
-public:
-  void ClrAvailableTracks(bool DescriptionsOnly = false, bool IdsOnly = false);
-       ///< Clears the list of currently available tracks. If DescriptionsOnly
-       ///< is true, only the track descriptions will be cleared. With IdsOnly
-       ///< set to true only the ids will be cleared. IdsOnly is only taken
-       ///< into account if DescriptionsOnly is false.
-  bool SetAvailableTrack(eTrackType Type, int Index, uint16_t Id, const char *Language = NULL, const char *Description = NULL);
-       ///< Sets the track of the given Type and Index to the given values.
-       ///< Type must be one of the basic eTrackType values, like ttAudio or ttDolby.
-       ///< Index tells which track of the given basic type is meant.
-       ///< If Id is 0 any existing id will be left untouched and only the
-       ///< given Language and Description will be set.
-       ///< Returns true if the track was set correctly, false otherwise.
-  const tTrackId *GetTrack(eTrackType Type);
-       ///< Returns a pointer to the given track id, or NULL if Type is not
-       ///< less than ttMaxTrackTypes.
-  int NumTracks(eTrackType FirstTrack, eTrackType LastTrack) const;
-       ///< Returns the number of tracks in the given range that are currently
-       ///< available.
-  int NumAudioTracks(void) const;
-       ///< Returns the number of audio tracks that are currently available.
-       ///< This is just for information, to quickly find out whether there
-       ///< is more than one audio track.
-  int NumSubtitleTracks(void) const;
-       ///< Returns the number of subtitle tracks that are currently available.
-  eTrackType GetCurrentAudioTrack(void) const { return currentAudioTrack; }
-  bool SetCurrentAudioTrack(eTrackType Type);
-       ///< Sets the current audio track to the given Type.
-       ///< Returns true if Type is a valid audio track, false otherwise.
-  eTrackType GetCurrentSubtitleTrack(void) const { return currentSubtitleTrack; }
-  bool SetCurrentSubtitleTrack(eTrackType Type, bool Manual = false);
-       ///< Sets the current subtitle track to the given Type.
-       ///< IF Manual is true, no automatic preferred subtitle language selection
-       ///< will be done for the rest of the current replay session, or until
-       ///< the channel is changed.
-       ///< Returns true if Type is a valid subtitle track, false otherwise.
-  void EnsureAudioTrack(bool Force = false);
-       ///< Makes sure an audio track is selected that is actually available.
-       ///< If Force is true, the language and Dolby Digital settings will
-       ///< be verified even if the current audio track is available.
-  void EnsureSubtitleTrack(void);
-       ///< Makes sure one of the preferred language subtitle tracks is selected.
-       ///< Only has an effect if Setup.DisplaySubtitles is on.
-  void SetKeepTracks(bool KeepTracks) { keepTracks = KeepTracks; }
-       ///< Controls whether the current audio and subtitle track settings shall
-       ///< be kept as they currently are, or if they shall be automatically
-       ///< adjusted. This is used when pausing live video.
-
-// Audio facilities
-
-private:
-  bool mute;
-  int volume;
-protected:
-  virtual int GetAudioChannelDevice(void);
-       ///< Gets the current audio channel, which is stereo (0), mono left (1) or
-       ///< mono right (2).
-  virtual void SetAudioChannelDevice(int AudioChannel);
-       ///< Sets the audio channel to stereo (0), mono left (1) or mono right (2).
-  virtual void SetVolumeDevice(int Volume);
-       ///< Sets the audio volume on this device (Volume = 0...255).
-  virtual void SetDigitalAudioDevice(bool On);
-       ///< Tells the actual device that digital audio output shall be switched
-       ///< on or off.
-public:
-  bool IsMute(void) const { return mute; }
-  bool ToggleMute(void);
-       ///< Turns the volume off or on and returns the new mute state.
-  int GetAudioChannel(void);
-       ///< Gets the current audio channel, which is stereo (0), mono left (1) or
-       ///< mono right (2).
-  void SetAudioChannel(int AudioChannel);
-       ///< Sets the audio channel to stereo (0), mono left (1) or mono right (2).
-       ///< Any other values will be silently ignored.
-  void SetVolume(int Volume, bool Absolute = false);
-       ///< Sets the volume to the given value, either absolutely or relative to
-       ///< the current volume.
-  static int CurrentVolume(void) { return primaryDevice ? primaryDevice->volume : 0; }//XXX???
-
-// Player facilities
-
-private:
-  cPlayer *player;
-  cPatPmtParser patPmtParser;
-  cTsToPes tsToPesVideo;
-  cTsToPes tsToPesAudio;
-  cTsToPes tsToPesSubtitle;
-  cTsToPes tsToPesTeletext;
-  bool isPlayingVideo;
-protected:
-  virtual bool CanReplay(void) const;
-       ///< Returns true if this device can currently start a replay session.
-  virtual bool SetPlayMode(ePlayMode PlayMode);
-       ///< Sets the device into the given play mode.
-       ///< Returns true if the operation was successful.
-  virtual int PlayVideo(const uchar *Data, int Length);
-       ///< Plays the given data block as video.
-       ///< Data points to exactly one complete PES packet of the given Length.
-       ///< PlayVideo() shall process the packet either as a whole (returning
-       ///< Length) or not at all (returning 0 or -1 and setting 'errno' accordingly).
-       ///< Returns the number of bytes actually taken from Data, or -1
-       ///< in case of an error.
-  virtual int PlayAudio(const uchar *Data, int Length, uchar Id);
-       ///< Plays the given data block as audio.
-       ///< Data points to exactly one complete PES packet of the given Length.
-       ///< Id indicates the type of audio data this packet holds.
-       ///< PlayAudio() shall process the packet either as a whole (returning
-       ///< Length) or not at all (returning 0 or -1 and setting 'errno' accordingly).
-       ///< Returns the number of bytes actually taken from Data, or -1
-       ///< in case of an error.
-  virtual int PlaySubtitle(const uchar *Data, int Length);
-       ///< Plays the given data block as a subtitle.
-       ///< Data points to exactly one complete PES packet of the given Length.
-       ///< PlaySubtitle() shall process the packet either as a whole (returning
-       ///< Length) or not at all (returning 0 or -1 and setting 'errno' accordingly).
-       ///< Returns the number of bytes actually taken from Data, or -1
-       ///< in case of an error.
-  virtual int PlayPesPacket(const uchar *Data, int Length, bool VideoOnly = false);
-       ///< Plays the single PES packet in Data with the given Length.
-       ///< If VideoOnly is true, only the video will be displayed,
-       ///< which is necessary for trick modes like 'fast forward'.
-       ///< Data must point to one single, complete PES packet.
-  virtual int PlayTsVideo(const uchar *Data, int Length);
-       ///< Plays the given data block as video.
-       ///< Data points to exactly one complete TS packet of the given Length
-       ///< (which is always TS_SIZE).
-       ///< PlayTsVideo() shall process the packet either as a whole (returning
-       ///< Length) or not at all (returning 0 or -1 and setting 'errno' accordingly).
-       ///< The default implementation collects all incoming TS payload belonging
-       ///< to one PES packet and calls PlayVideo() with the resulting packet.
-  virtual int PlayTsAudio(const uchar *Data, int Length);
-       ///< Plays the given data block as audio.
-       ///< Data points to exactly one complete TS packet of the given Length
-       ///< (which is always TS_SIZE).
-       ///< PlayTsAudio() shall process the packet either as a whole (returning
-       ///< Length) or not at all (returning 0 or -1 and setting 'errno' accordingly).
-       ///< The default implementation collects all incoming TS payload belonging
-       ///< to one PES packet and calls PlayAudio() with the resulting packet.
-  virtual int PlayTsSubtitle(const uchar *Data, int Length);
-       ///< Plays the given data block as a subtitle.
-       ///< Data points to exactly one complete TS packet of the given Length
-       ///< (which is always TS_SIZE).
-       ///< PlayTsSubtitle() shall process the packet either as a whole (returning
-       ///< Length) or not at all (returning 0 or -1 and setting 'errno' accordingly).
-       ///< The default implementation collects all incoming TS payload belonging
-       ///< to one PES packet and displays the resulting subtitle via the OSD.
-public:
-  virtual int64_t GetSTC(void);
-       ///< Gets the current System Time Counter, which can be used to
-       ///< synchronize audio, video and subtitles. If this device is able to
-       ///< replay, it must provide an STC.
-       ///< The value returned doesn't need to be an actual "clock" value,
-       ///< it is sufficient if it holds the PTS (Presentation Time Stamp) of
-       ///< the most recently presented frame. A proper value must be returned
-       ///< in normal replay mode as well as in any trick modes (like slow motion,
-       ///< fast forward/rewind).
-       ///< Only the lower 32 bit of this value are actually used, since some
-       ///< devices can't handle the msb correctly.
-  virtual bool IsPlayingVideo(void) const { return isPlayingVideo; }
-       ///< Returns true if the currently attached player has delivered
-       ///< any video packets.
-  virtual cRect CanScaleVideo(const cRect &Rect, int Alignment = taCenter) { return cRect::Null; }
-       ///< Asks the output device whether it can scale the currently shown video in
-       ///< such a way that it fits into the given Rect, while retaining its proper
-       ///< aspect ratio. If the scaled video doesn't exactly fit into Rect, Alignment
-       ///< is used to determine how to align the actual rectangle with the requested
-       ///< one. The actual rectangle can be smaller, larger or the same size as the
-       ///< given Rect, and its location may differ, depending on the capabilities of
-       ///< the output device, which may not be able to display a scaled video at
-       ///< arbitrary sizes and locations. The device shall, however, do its best to
-       ///< match the requested Rect as closely as possible, preferring a size and
-       ///< location that fits completely into the requested Rect if possible.
-       ///< Returns the rectangle that can actually be used when scaling the video.
-       ///< A skin plugin using this function should rearrange its content according
-       ///< to the rectangle returned from calling this function, and should especially
-       ///< be prepared for cases where the returned rectangle is way off the requested
-       ///< Rect, or even Null. In such cases, the skin may want to fall back to
-       ///< working with full screen video.
-       ///< The coordinates of Rect are in the range of the width and height returned
-       ///< by GetOsdSize().
-       ///< If this device can't scale the video, a Null rectangle is returned (this
-       ///< is also the default implementation).
-  virtual void ScaleVideo(const cRect &Rect = cRect::Null) {}
-       ///< Scales the currently shown video in such a way that it fits into the given
-       ///< Rect. Rect should be one retrieved through a previous call to
-       ///< CanScaleVideo() (otherwise results may be undefined).
-       ///< Even if video output is scaled, the functions GetVideoSize() and
-       ///< GetOsdSize() must still return the same values as if in full screen mode!
-       ///< If this device can't scale the video, nothing happens.
-       ///< To restore full screen video, call this function with a Null rectangle.
-  virtual bool HasIBPTrickSpeed(void) { return false; }
-       ///< Returns true if this device can handle all frames in 'fast forward'
-       ///< trick speeds.
-  virtual void TrickSpeed(int Speed);
-       ///< Sets the device into a mode where replay is done slower.
-       ///< Every single frame shall then be displayed the given number of
-       ///< times.
-       ///< The cDvbPlayer uses the following values for the various speeds:
-       ///<                   1x   2x   3x
-       ///< Fast Forward       6    3    1
-       ///< Fast Reverse       6    3    1
-       ///< Slow Forward       8    4    2
-       ///< Slow Reverse      63   48   24
-  virtual void Clear(void);
-       ///< Clears all video and audio data from the device.
-       ///< A derived class must call the base class function to make sure
-       ///< all registered cAudio objects are notified.
-  virtual void Play(void);
-       ///< Sets the device into play mode (after a previous trick
-       ///< mode).
-  virtual void Freeze(void);
-       ///< Puts the device into "freeze frame" mode.
-  virtual void Mute(void);
-       ///< Turns off audio while replaying.
-       ///< A derived class must call the base class function to make sure
-       ///< all registered cAudio objects are notified.
-  virtual void StillPicture(const uchar *Data, int Length);
-       ///< Displays the given I-frame as a still picture.
-       ///< Data points either to TS (first byte is 0x47) or PES (first byte
-       ///< is 0x00) data of the given Length. The default implementation
-       ///< converts TS to PES and calls itself again, allowing a derived class
-       ///< to display PES if it can't handle TS directly.
-  virtual bool Poll(cPoller &Poller, int TimeoutMs = 0);
-       ///< Returns true if the device itself or any of the file handles in
-       ///< Poller is ready for further action.
-       ///< If TimeoutMs is not zero, the device will wait up to the given number
-       ///< of milliseconds before returning in case it can't accept any data.
-  virtual bool Flush(int TimeoutMs = 0);
-       ///< Returns true if the device's output buffers are empty, i. e. any
-       ///< data which was buffered so far has been processed.
-       ///< If TimeoutMs is not zero, the device will wait up to the given
-       ///< number of milliseconds before returning in case there is still
-       ///< data in the buffers.
-  virtual int PlayPes(const uchar *Data, int Length, bool VideoOnly = false);
-       ///< Plays all valid PES packets in Data with the given Length.
-       ///< If Data is NULL any leftover data from a previous call will be
-       ///< discarded. If VideoOnly is true, only the video will be displayed,
-       ///< which is necessary for trick modes like 'fast forward'.
-       ///< Data should point to a sequence of complete PES packets. If the
-       ///< last packet in Data is not complete, it will be copied and combined
-       ///< to a complete packet with data from the next call to PlayPes().
-       ///< That way any functions called from within PlayPes() will be
-       ///< guaranteed to always receive complete PES packets.
-  virtual int PlayTs(const uchar *Data, int Length, bool VideoOnly = false);
-       ///< Plays the given TS packet.
-       ///< If VideoOnly is true, only the video will be displayed,
-       ///< which is necessary for trick modes like 'fast forward'.
-       ///< Data points to a single TS packet, Length is always TS_SIZE (the total
-       ///< size of a single TS packet).
-       ///< If Data is NULL any leftover data from a previous call will be
-       ///< discarded.
-       ///< A derived device can reimplement this function to handle the
-       ///< TS packets itself. Any packets the derived function can't handle
-       ///< must be sent to the base class function. This applies especially
-       ///< to the PAT/PMT packets.
-       ///< Returns -1 in case of error, otherwise the number of actually
-       ///< processed bytes is returned.
-       ///< PlayTs() shall process the TS packets either as a whole (returning
-       ///< TS_SIZE) or not at all, returning 0 or -1 and setting 'errno' accordingly).
-  bool Replaying(void) const;
-       ///< Returns true if we are currently replaying.
-  bool Transferring(void) const;
-       ///< Returns true if we are currently in Transfer Mode.
-  void StopReplay(void);
-       ///< Stops the current replay session (if any).
-  bool AttachPlayer(cPlayer *Player);
-       ///< Attaches the given player to this device.
-  void Detach(cPlayer *Player);
-       ///< Detaches the given player from this device.
-
-// Receiver facilities
-
-private:
-  mutable cMutex mutexReceiver;
-  cReceiver *receiver[MAXRECEIVERS];
-public:
-  int Priority(void) const;
-      ///< Returns the priority of the current receiving session (-MAXPRIORITY..MAXPRIORITY),
-      ///< or IDLEPRIORITY if no receiver is currently active.
-protected:
-  virtual bool OpenDvr(void);
-      ///< Opens the DVR of this device and prepares it to deliver a Transport
-      ///< Stream for use in a cReceiver.
-  virtual void CloseDvr(void);
-      ///< Shuts down the DVR.
-  virtual bool GetTSPacket(uchar *&Data);
-      ///< Gets exactly one TS packet from the DVR of this device and returns
-      ///< a pointer to it in Data. Only the first 188 bytes (TS_SIZE) Data
-      ///< points to are valid and may be accessed. If there is currently no
-      ///< new data available, Data will be set to NULL. The function returns
-      ///< false in case of a non recoverable error, otherwise it returns true,
-      ///< even if Data is NULL.
-public:
-  bool Receiving(bool Dummy = false) const;
-       ///< Returns true if we are currently receiving. The parameter has no meaning (for backwards compatibility only).
-  bool AttachReceiver(cReceiver *Receiver);
-       ///< Attaches the given receiver to this device.
-  void Detach(cReceiver *Receiver);
-       ///< Detaches the given receiver from this device.
-  void DetachAll(int Pid);
-       ///< Detaches all receivers from this device for this pid.
-  virtual void DetachAllReceivers(void);
-       ///< Detaches all receivers from this device.
-       
-// --- dynamite subdevice patch start ---
-  friend class cDynamicDevice;
-private:
-  static cDevice *nextParentDevice;
-         ///< Holds the parent device for the next subdevice
-         ///< so the dynamite-plugin can work with unpatched plugins
-  bool isIdle;
-protected:
-  cDevice *parentDevice;
-  cDevice *subDevice;
-  cDevice(cDevice *ParentDevice = NULL);
-  const cPatPmtParser *PatPmtParser(void) const { if (parentDevice) return parentDevice->PatPmtParser(); return &patPmtParser; }
-       ///< Returns a pointer to the patPmtParser, so that a derived device
-       ///< can use the stream information from it.
-public:
-  bool IsPrimaryDevice(void) const { if (parentDevice) return parentDevice->IsPrimaryDevice(); return this == primaryDevice; }
-  int CardIndex(void) const { if (parentDevice) return parentDevice->cardIndex; return cardIndex; }
-         ///< Returns the card index of this device (0 ... MAXDEVICES - 1).
-  cCamSlot *CamSlot(void) const { if (parentDevice) return parentDevice->CamSlot(); return camSlot; }
-         ///< Returns the CAM slot that is currently used with this device,
-         ///< or NULL if no CAM slot is in use.
-  bool IsSubDevice(void) const { return (parentDevice != NULL); }
-  bool HasSubDevice(void) const { return (subDevice != NULL); }
-  cDevice *SubDevice(void) const { return subDevice; }
-  bool IsIdle(void) const { if (parentDevice) return parentDevice->IsIdle(); return isIdle; }
-  bool SetIdle(bool Idle);
-  virtual bool SetIdleDevice(bool Idle, bool TestOnly) { return false; }
-         ///< Called by SetIdle
-         ///< if TestOnly, don't do anything, just return, if the device
-         ///< can be set to the new idle state
-  // --- dynamite subdevice patch end ---
-  };
-
-/// Derived cDevice classes that can receive channels will have to provide
-/// Transport Stream (TS) packets one at a time. cTSBuffer implements a
-/// simple buffer that allows the device to read a larger amount of data
-/// from the driver with each call to Read(), thus avoiding the overhead
-/// of getting each TS packet separately from the driver. It also makes
-/// sure the returned data points to a TS packet and automatically
-/// re-synchronizes after broken packets.
-
-class cTSBufferBase {
-public:
-  cTSBufferBase() {}
-  virtual ~cTSBufferBase() {}
-  virtual uchar *Get(void) = 0;
-  };
-
-class cTSBuffer : public cTSBufferBase, public cThread {
-private:
-  int f;
-  int cardIndex;
-  bool delivered;
-  cRingBufferLinear *ringBuffer;
-  virtual void Action(void);
-public:
-  cTSBuffer(int File, int Size, int CardIndex);
-  virtual ~cTSBuffer();
-  virtual uchar *Get(void);
-  };
-
-/// A plugin that want to create devices handled by the dynamite-plugin needs to create
-/// a cDynamicDeviceProbe derived object on the heap in order to have its Probe()
-/// function called, where it can actually create the appropriate device.
-/// The cDynamicDeviceProbe object must be created in the plugin's constructor,
-/// and deleted in its destructor.
-/// The "DevPath" hasn't to be a physical device or a path in the filesystem.
-/// It can be any string a plugin may react on.
-
-#define __DYNAMIC_DEVICE_PROBE
-
-enum eDynamicDeviceProbeCommand { ddpcAttach, ddpcDetach, ddpcService };
-
-class cDynamicDeviceProbe : public cListObject {
-  friend class cDynamicDevice;
-private:
-  class cDynamicDeviceProbeItem : public cListObject {
-  public:
-    eDynamicDeviceProbeCommand cmd;
-    cString *devpath;
-    cDynamicDeviceProbeItem(eDynamicDeviceProbeCommand Cmd, cString *DevPath):cmd(Cmd),devpath(DevPath) {}
-    virtual ~cDynamicDeviceProbeItem() { if (devpath) delete devpath; }
-    };
-  static cList<cDynamicDeviceProbeItem> commandQueue;
-     ///< A list where all attach/detach commands are queued
-     ///< so they can be processed in the MainThreadHook of
-     ///< the dynamite plugin.
-public:
-  static void QueueDynamicDeviceCommand(eDynamicDeviceProbeCommand Cmd, const char *DevPath);
-     ///< Plugins which support cDynamicDeviceProbe must use this function
-     ///< to queue the devices they normally create in their Initialize method.
-     ///< These devices are created as subdevices in the Start-method of the dynamite-plugin.
-  cDynamicDeviceProbe(void);
-  virtual ~cDynamicDeviceProbe();
-  virtual cDevice *Attach(cDevice *ParentDevice, const char *DevPath) = 0;
-     ///< Probes for a device at the given device-path like /dev/dvb/adapter0/frontend0
-     ///< or /dev/video0 etc. and creates the appropriate
-     ///< object derived from cDevice if applicable.
-     ///< Returns the device that has been created or NULL if not.
-     ///< The dynamite-plugin will delete the device if it is detached.
-  };
-
-extern cList<cDynamicDeviceProbe> DynamicDeviceProbes;
-  
-#endif //__DEVICE_H
diff -urN vdr-2.0.4-org/dvbdevice.c.orig vdr-2.0.4/dvbdevice.c.orig
--- vdr-2.0.4-org/dvbdevice.c.orig	2013-10-25 09:44:22.520680546 +0200
+++ vdr-2.0.4/dvbdevice.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1682 +0,0 @@
-/*
- * dvbdevice.c: The DVB device tuner interface
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: dvbdevice.c 2.88.1.4 2013/10/21 09:01:21 kls Exp $
- */
-
-#include "dvbdevice.h"
-#include <ctype.h>
-#include <errno.h>
-#include <limits.h>
-#include <linux/dvb/dmx.h>
-#include <linux/dvb/frontend.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include "channels.h"
-#include "diseqc.h"
-#include "dvbci.h"
-#include "menuitems.h"
-#include "sourceparams.h"
-
-static int DvbApiVersion = 0x0000; // the version of the DVB driver actually in use (will be determined by the first device created)
-
-#define DVBS_TUNE_TIMEOUT  9000 //ms
-#define DVBS_LOCK_TIMEOUT  2000 //ms
-#define DVBC_TUNE_TIMEOUT  9000 //ms
-#define DVBC_LOCK_TIMEOUT  2000 //ms
-#define DVBT_TUNE_TIMEOUT  9000 //ms
-#define DVBT_LOCK_TIMEOUT  2000 //ms
-#define ATSC_TUNE_TIMEOUT  9000 //ms
-#define ATSC_LOCK_TIMEOUT  2000 //ms
-
-#define SCR_RANDOM_TIMEOUT  500 // ms (add random value up to this when tuning SCR device to avoid lockups)
-
-// --- DVB Parameter Maps ----------------------------------------------------
-
-const tDvbParameterMap InversionValues[] = {
-  {   0, INVERSION_OFF,  trNOOP("off") },
-  {   1, INVERSION_ON,   trNOOP("on") },
-  { 999, INVERSION_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap BandwidthValues[] = {
-  {    5,  5000000, "5 MHz" },
-  {    6,  6000000, "6 MHz" },
-  {    7,  7000000, "7 MHz" },
-  {    8,  8000000, "8 MHz" },
-  {   10, 10000000, "10 MHz" },
-  { 1712,  1712000, "1.712 MHz" },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap CoderateValues[] = {
-  {   0, FEC_NONE, trNOOP("none") },
-  {  12, FEC_1_2,  "1/2" },
-  {  23, FEC_2_3,  "2/3" },
-  {  34, FEC_3_4,  "3/4" },
-  {  35, FEC_3_5,  "3/5" },
-  {  45, FEC_4_5,  "4/5" },
-  {  56, FEC_5_6,  "5/6" },
-  {  67, FEC_6_7,  "6/7" },
-  {  78, FEC_7_8,  "7/8" },
-  {  89, FEC_8_9,  "8/9" },
-  { 910, FEC_9_10, "9/10" },
-  { 999, FEC_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap ModulationValues[] = {
-  {  16, QAM_16,   "QAM16" },
-  {  32, QAM_32,   "QAM32" },
-  {  64, QAM_64,   "QAM64" },
-  { 128, QAM_128,  "QAM128" },
-  { 256, QAM_256,  "QAM256" },
-  {   2, QPSK,     "QPSK" },
-  {   5, PSK_8,    "8PSK" },
-  {   6, APSK_16,  "16APSK" },
-  {   7, APSK_32,  "32APSK" },
-  {  10, VSB_8,    "VSB8" },
-  {  11, VSB_16,   "VSB16" },
-  {  12, DQPSK,    "DQPSK" },
-  { 999, QAM_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-#define DVB_SYSTEM_1 0 // see also nit.c
-#define DVB_SYSTEM_2 1
-
-const tDvbParameterMap SystemValuesSat[] = {
-  {   0, DVB_SYSTEM_1, "DVB-S" },
-  {   1, DVB_SYSTEM_2, "DVB-S2" },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap SystemValuesTerr[] = {
-  {   0, DVB_SYSTEM_1, "DVB-T" },
-  {   1, DVB_SYSTEM_2, "DVB-T2" },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap TransmissionValues[] = {
-  {   1, TRANSMISSION_MODE_1K,   "1K" },
-  {   2, TRANSMISSION_MODE_2K,   "2K" },
-  {   4, TRANSMISSION_MODE_4K,   "4K" },
-  {   8, TRANSMISSION_MODE_8K,   "8K" },
-  {  16, TRANSMISSION_MODE_16K,  "16K" },
-  {  32, TRANSMISSION_MODE_32K,  "32K" },
-  { 999, TRANSMISSION_MODE_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap GuardValues[] = {
-  {     4, GUARD_INTERVAL_1_4,    "1/4" },
-  {     8, GUARD_INTERVAL_1_8,    "1/8" },
-  {    16, GUARD_INTERVAL_1_16,   "1/16" },
-  {    32, GUARD_INTERVAL_1_32,   "1/32" },
-  {   128, GUARD_INTERVAL_1_128,  "1/128" },
-  { 19128, GUARD_INTERVAL_19_128, "19/128" },
-  { 19256, GUARD_INTERVAL_19_256, "19/256" },
-  {   999, GUARD_INTERVAL_AUTO,   trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap HierarchyValues[] = {
-  {   0, HIERARCHY_NONE, trNOOP("none") },
-  {   1, HIERARCHY_1,    "1" },
-  {   2, HIERARCHY_2,    "2" },
-  {   4, HIERARCHY_4,    "4" },
-  { 999, HIERARCHY_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap RollOffValues[] = {
-  {   0, ROLLOFF_AUTO, trNOOP("auto") },
-  {  20, ROLLOFF_20, "0.20" },
-  {  25, ROLLOFF_25, "0.25" },
-  {  35, ROLLOFF_35, "0.35" },
-  {  -1, 0, NULL }
-  };
-
-int UserIndex(int Value, const tDvbParameterMap *Map)
-{
-  const tDvbParameterMap *map = Map;
-  while (map && map->userValue != -1) {
-        if (map->userValue == Value)
-           return map - Map;
-        map++;
-        }
-  return -1;
-}
-
-int DriverIndex(int Value, const tDvbParameterMap *Map)
-{
-  const tDvbParameterMap *map = Map;
-  while (map && map->userValue != -1) {
-        if (map->driverValue == Value)
-           return map - Map;
-        map++;
-        }
-  return -1;
-}
-
-int MapToUser(int Value, const tDvbParameterMap *Map, const char **String)
-{
-  int n = DriverIndex(Value, Map);
-  if (n >= 0) {
-     if (String)
-        *String = tr(Map[n].userString);
-     return Map[n].userValue;
-     }
-  return -1;
-}
-
-const char *MapToUserString(int Value, const tDvbParameterMap *Map)
-{
-  int n = DriverIndex(Value, Map);
-  if (n >= 0)
-     return Map[n].userString;
-  return "???";
-}
-
-int MapToDriver(int Value, const tDvbParameterMap *Map)
-{
-  int n = UserIndex(Value, Map);
-  if (n >= 0)
-     return Map[n].driverValue;
-  return -1;
-}
-
-// --- cDvbTransponderParameters ---------------------------------------------
-
-cDvbTransponderParameters::cDvbTransponderParameters(const char *Parameters)
-{
-  polarization = 0;
-  inversion    = INVERSION_AUTO;
-  bandwidth    = 8000000;
-  coderateH    = FEC_AUTO;
-  coderateL    = FEC_AUTO;
-  modulation   = QPSK;
-  system       = DVB_SYSTEM_1;
-  transmission = TRANSMISSION_MODE_AUTO;
-  guard        = GUARD_INTERVAL_AUTO;
-  hierarchy    = HIERARCHY_AUTO;
-  rollOff      = ROLLOFF_AUTO;
-  streamId     = 0;
-  Parse(Parameters);
-}
-
-int cDvbTransponderParameters::PrintParameter(char *p, char Name, int Value) const
-{
-  return Value >= 0 && Value != 999 ? sprintf(p, "%c%d", Name, Value) : 0;
-}
-
-cString cDvbTransponderParameters::ToString(char Type) const
-{
-#define ST(s) if (strchr(s, Type) && (strchr(s, '0' + system + 1) || strchr(s, '*')))
-  char buffer[64];
-  char *q = buffer;
-  *q = 0;
-  ST("  S *")  q += sprintf(q, "%c", polarization);
-  ST("   T*")  q += PrintParameter(q, 'B', MapToUser(bandwidth, BandwidthValues));
-  ST(" CST*")  q += PrintParameter(q, 'C', MapToUser(coderateH, CoderateValues));
-  ST("   T*")  q += PrintParameter(q, 'D', MapToUser(coderateL, CoderateValues));
-  ST("   T*")  q += PrintParameter(q, 'G', MapToUser(guard, GuardValues));
-  ST("ACST*")  q += PrintParameter(q, 'I', MapToUser(inversion, InversionValues));
-  ST("ACST*")  q += PrintParameter(q, 'M', MapToUser(modulation, ModulationValues));
-  ST("  S 2")  q += PrintParameter(q, 'O', MapToUser(rollOff, RollOffValues));
-  ST("  ST2")  q += PrintParameter(q, 'P', streamId);
-  ST("  ST*")  q += PrintParameter(q, 'S', MapToUser(system, SystemValuesSat)); // we only need the numerical value, so Sat or Terr doesn't matter
-  ST("   T*")  q += PrintParameter(q, 'T', MapToUser(transmission, TransmissionValues));
-  ST("   T*")  q += PrintParameter(q, 'Y', MapToUser(hierarchy, HierarchyValues));
-  return buffer;
-}
-
-const char *cDvbTransponderParameters::ParseParameter(const char *s, int &Value, const tDvbParameterMap *Map)
-{
-  if (*++s) {
-     char *p = NULL;
-     errno = 0;
-     int n = strtol(s, &p, 10);
-     if (!errno && p != s) {
-        Value = Map ? MapToDriver(n, Map) : n;
-        if (Value >= 0)
-           return p;
-        }
-     }
-  esyslog("ERROR: invalid value for parameter '%c'", *(s - 1));
-  return NULL;
-}
-
-bool cDvbTransponderParameters::Parse(const char *s)
-{
-  while (s && *s) {
-        switch (toupper(*s)) {
-          case 'B': s = ParseParameter(s, bandwidth, BandwidthValues); break;
-          case 'C': s = ParseParameter(s, coderateH, CoderateValues); break;
-          case 'D': s = ParseParameter(s, coderateL, CoderateValues); break;
-          case 'G': s = ParseParameter(s, guard, GuardValues); break;
-          case 'H': polarization = 'H'; s++; break;
-          case 'I': s = ParseParameter(s, inversion, InversionValues); break;
-          case 'L': polarization = 'L'; s++; break;
-          case 'M': s = ParseParameter(s, modulation, ModulationValues); break;
-          case 'O': s = ParseParameter(s, rollOff, RollOffValues); break;
-          case 'P': s = ParseParameter(s, streamId); break;
-          case 'R': polarization = 'R'; s++; break;
-          case 'S': s = ParseParameter(s, system, SystemValuesSat); break; // we only need the numerical value, so Sat or Terr doesn't matter
-          case 'T': s = ParseParameter(s, transmission, TransmissionValues); break;
-          case 'V': polarization = 'V'; s++; break;
-          case 'Y': s = ParseParameter(s, hierarchy, HierarchyValues); break;
-          default: esyslog("ERROR: unknown parameter key '%c'", *s);
-                   return false;
-          }
-        }
-  return true;
-}
-
-// --- cDvbTuner -------------------------------------------------------------
-
-#define TUNER_POLL_TIMEOUT  10 // ms
-
-class cDvbTuner : public cThread {
-private:
-  static cMutex bondMutex;
-  enum eTunerStatus { tsIdle, tsSet, tsTuned, tsLocked };
-  int frontendType;
-  const cDvbDevice *device;
-  int fd_frontend;
-  int adapter, frontend;
-  uint32_t subsystemId;
-  int tuneTimeout;
-  int lockTimeout;
-  time_t lastTimeoutReport;
-  cChannel channel;
-  const cDiseqc *lastDiseqc;
-  const cScr *scr;
-  bool lnbPowerTurnedOn;
-  eTunerStatus tunerStatus;
-  cMutex mutex;
-  cCondVar locked;
-  cCondVar newSet;
-  cDvbTuner *bondedTuner;
-  bool bondedMaster;
-  bool SetFrontendType(const cChannel *Channel);
-  cString GetBondingParams(const cChannel *Channel = NULL) const;
-  cDvbTuner *GetBondedMaster(void);
-  bool IsBondedMaster(void) const { return !bondedTuner || bondedMaster; }
-  void ClearEventQueue(void) const;
-  bool GetFrontendStatus(fe_status_t &Status) const;
-  void ExecuteDiseqc(const cDiseqc *Diseqc, unsigned int *Frequency);
-  void ResetToneAndVoltage(void);
-  bool SetFrontend(void);
-  virtual void Action(void);
-public:
-  cDvbTuner(const cDvbDevice *Device, int Fd_Frontend, int Adapter, int Frontend);
-  virtual ~cDvbTuner();
-  int FrontendType(void) const { return frontendType; }
-  bool Bond(cDvbTuner *Tuner);
-  void UnBond(void);
-  bool BondingOk(const cChannel *Channel, bool ConsiderOccupied = false) const;
-  const cChannel *GetTransponder(void) const { return &channel; }
-  uint32_t SubsystemId(void) const { return subsystemId; }
-  bool IsTunedTo(const cChannel *Channel) const;
-  void SetChannel(const cChannel *Channel);
-  bool Locked(int TimeoutMs = 0);
-  int GetSignalStrength(void) const;
-  int GetSignalQuality(void) const;
-  };
-
-cMutex cDvbTuner::bondMutex;
-
-cDvbTuner::cDvbTuner(const cDvbDevice *Device, int Fd_Frontend, int Adapter, int Frontend)
-{
-  frontendType = SYS_UNDEFINED;
-  device = Device;
-  fd_frontend = Fd_Frontend;
-  adapter = Adapter;
-  frontend = Frontend;
-  subsystemId = cDvbDeviceProbe::GetSubsystemId(adapter, frontend);
-  tuneTimeout = 0;
-  lockTimeout = 0;
-  lastTimeoutReport = 0;
-  lastDiseqc = NULL;
-  scr = NULL;
-  lnbPowerTurnedOn = false;
-  tunerStatus = tsIdle;
-  bondedTuner = NULL;
-  bondedMaster = false;
-  SetDescription("tuner on frontend %d/%d", adapter, frontend);
-  Start();
-}
-
-cDvbTuner::~cDvbTuner()
-{
-  tunerStatus = tsIdle;
-  newSet.Broadcast();
-  locked.Broadcast();
-  Cancel(3);
-  UnBond();
-  /* looks like this irritates the SCR switch, so let's leave it out for now
-  if (lastDiseqc && lastDiseqc->IsScr()) {
-     unsigned int Frequency = 0;
-     ExecuteDiseqc(lastDiseqc, &Frequency);
-     }
-  */
-}
-
-bool cDvbTuner::Bond(cDvbTuner *Tuner)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (!bondedTuner) {
-     ResetToneAndVoltage();
-     bondedMaster = false; // makes sure we don't disturb an existing master
-     bondedTuner = Tuner->bondedTuner ? Tuner->bondedTuner : Tuner;
-     Tuner->bondedTuner = this;
-     dsyslog("tuner %d/%d bonded with tuner %d/%d", adapter, frontend, bondedTuner->adapter, bondedTuner->frontend);
-     return true;
-     }
-  else
-     esyslog("ERROR: tuner %d/%d already bonded with tuner %d/%d, can't bond with tuner %d/%d", adapter, frontend, bondedTuner->adapter, bondedTuner->frontend, Tuner->adapter, Tuner->frontend);
-  return false;
-}
-
-void cDvbTuner::UnBond(void)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (cDvbTuner *t = bondedTuner) {
-     dsyslog("tuner %d/%d unbonded from tuner %d/%d", adapter, frontend, bondedTuner->adapter, bondedTuner->frontend);
-     while (t->bondedTuner != this)
-           t = t->bondedTuner;
-     if (t == bondedTuner)
-        t->bondedTuner = NULL;
-     else
-        t->bondedTuner = bondedTuner;
-     bondedMaster = false; // another one will automatically become master whenever necessary
-     bondedTuner = NULL;
-     }
-}
-
-cString cDvbTuner::GetBondingParams(const cChannel *Channel) const
-{
-  if (!Channel)
-     Channel = &channel;
-  cDvbTransponderParameters dtp(Channel->Parameters());
-  if (Setup.DiSEqC) {
-     if (const cDiseqc *diseqc = Diseqcs.Get(device->CardIndex() + 1, Channel->Source(), Channel->Frequency(), dtp.Polarization(), NULL))
-        return diseqc->Commands();
-     }
-  else {
-     bool ToneOff = Channel->Frequency() < Setup.LnbSLOF;
-     bool VoltOff = dtp.Polarization() == 'V' || dtp.Polarization() == 'R';
-     return cString::sprintf("%c %c", ToneOff ? 't' : 'T', VoltOff ? 'v' : 'V');
-     }
-  return "";
-}
-
-bool cDvbTuner::BondingOk(const cChannel *Channel, bool ConsiderOccupied) const
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (cDvbTuner *t = bondedTuner) {
-     cString BondingParams = GetBondingParams(Channel);
-     do {
-        if (t->device->Priority() > IDLEPRIORITY || ConsiderOccupied && t->device->Occupied()) {
-           if (strcmp(BondingParams, t->GetBondedMaster()->GetBondingParams()) != 0)
-              return false;
-           }
-        t = t->bondedTuner;
-        } while (t != bondedTuner);
-     }
-  return true;
-}
-
-cDvbTuner *cDvbTuner::GetBondedMaster(void)
-{
-  if (!bondedTuner)
-     return this; // an unbonded tuner is always "master"
-  cMutexLock MutexLock(&bondMutex);
-  if (bondedMaster)
-     return this;
-  // This tuner is bonded, but it's not the master, so let's see if there is a master at all:
-  if (cDvbTuner *t = bondedTuner) {
-     while (t != this) {
-           if (t->bondedMaster)
-              return t;
-           t = t->bondedTuner;
-           }
-     }
-  // None of the other bonded tuners is master, so make this one the master:
-  bondedMaster = true;
-  dsyslog("tuner %d/%d is now bonded master", adapter, frontend);
-  return this;
-}
-
-bool cDvbTuner::IsTunedTo(const cChannel *Channel) const
-{
-  if (tunerStatus == tsIdle)
-     return false; // not tuned to
-  if (channel.Source() != Channel->Source() || channel.Transponder() != Channel->Transponder())
-     return false; // sufficient mismatch
-  // Polarization is already checked as part of the Transponder.
-  return strcmp(channel.Parameters(), Channel->Parameters()) == 0;
-}
-
-void cDvbTuner::SetChannel(const cChannel *Channel)
-{
-  if (Channel) {
-     if (bondedTuner) {
-        cMutexLock MutexLock(&bondMutex);
-        cDvbTuner *BondedMaster = GetBondedMaster();
-        if (BondedMaster == this) {
-           if (strcmp(GetBondingParams(Channel), GetBondingParams()) != 0) {
-              // switching to a completely different band, so set all others to idle:
-              for (cDvbTuner *t = bondedTuner; t && t != this; t = t->bondedTuner)
-                  t->SetChannel(NULL);
-              }
-           }
-        else if (strcmp(GetBondingParams(Channel), BondedMaster->GetBondingParams()) != 0)
-           BondedMaster->SetChannel(Channel);
-        }
-     cMutexLock MutexLock(&mutex);
-     if (!IsTunedTo(Channel))
-        tunerStatus = tsSet;
-     channel = *Channel;
-     lastTimeoutReport = 0;
-     newSet.Broadcast();
-     }
-  else {
-     cMutexLock MutexLock(&mutex);
-     tunerStatus = tsIdle;
-     ResetToneAndVoltage();
-     }
-  if (bondedTuner && device->IsPrimaryDevice())
-     cDevice::PrimaryDevice()->DelLivePids(); // 'device' is const, so we must do it this way
-}
-
-bool cDvbTuner::Locked(int TimeoutMs)
-{
-  bool isLocked = (tunerStatus >= tsLocked);
-  if (isLocked || !TimeoutMs)
-     return isLocked;
-
-  cMutexLock MutexLock(&mutex);
-  if (TimeoutMs && tunerStatus < tsLocked)
-     locked.TimedWait(mutex, TimeoutMs);
-  return tunerStatus >= tsLocked;
-}
-
-void cDvbTuner::ClearEventQueue(void) const
-{
-  cPoller Poller(fd_frontend);
-  if (Poller.Poll(TUNER_POLL_TIMEOUT)) {
-     dvb_frontend_event Event;
-     while (ioctl(fd_frontend, FE_GET_EVENT, &Event) == 0)
-           ; // just to clear the event queue - we'll read the actual status below
-     }
-}
-
-bool cDvbTuner::GetFrontendStatus(fe_status_t &Status) const
-{
-  ClearEventQueue();
-  while (1) {
-        if (ioctl(fd_frontend, FE_READ_STATUS, &Status) != -1)
-           return true;
-        if (errno != EINTR)
-           break;
-        }
-  return false;
-}
-
-//#define DEBUG_SIGNALSTRENGTH
-//#define DEBUG_SIGNALQUALITY
-
-int cDvbTuner::GetSignalStrength(void) const
-{
-  ClearEventQueue();
-  uint16_t Signal;
-  while (1) {
-        if (ioctl(fd_frontend, FE_READ_SIGNAL_STRENGTH, &Signal) != -1)
-           break;
-        if (errno != EINTR)
-           return -1;
-        }
-  uint16_t MaxSignal = 0xFFFF; // Let's assume the default is using the entire range.
-  // Use the subsystemId to identify individual devices in case they need
-  // special treatment to map their Signal value into the range 0...0xFFFF.
-  switch (subsystemId) {
-    case 0x13C21019: // TT-budget S2-3200 (DVB-S/DVB-S2)
-    case 0x1AE40001: // TechniSat SkyStar HD2 (DVB-S/DVB-S2)
-                     MaxSignal = 670; break;
-    }
-  int s = int(Signal) * 100 / MaxSignal;
-  if (s > 100)
-     s = 100;
-#ifdef DEBUG_SIGNALSTRENGTH
-  fprintf(stderr, "FE %d/%d: %08X S = %04X %04X %3d%%\n", adapter, frontend, subsystemId, MaxSignal, Signal, s);
-#endif
-  return s;
-}
-
-#define LOCK_THRESHOLD 5 // indicates that all 5 FE_HAS_* flags are set
-
-int cDvbTuner::GetSignalQuality(void) const
-{
-  fe_status_t Status;
-  if (GetFrontendStatus(Status)) {
-     // Actually one would expect these checks to be done from FE_HAS_SIGNAL to FE_HAS_LOCK, but some drivers (like the stb0899) are broken, so FE_HAS_LOCK is the only one that (hopefully) is generally reliable...
-     if ((Status & FE_HAS_LOCK) == 0) {
-        if ((Status & FE_HAS_SIGNAL) == 0)
-           return 0;
-        if ((Status & FE_HAS_CARRIER) == 0)
-           return 1;
-        if ((Status & FE_HAS_VITERBI) == 0)
-           return 2;
-        if ((Status & FE_HAS_SYNC) == 0)
-           return 3;
-        return 4;
-        }
-#ifdef DEBUG_SIGNALQUALITY
-     bool HasSnr = true;
-#endif
-     uint16_t Snr;
-     while (1) {
-           if (ioctl(fd_frontend, FE_READ_SNR, &Snr) != -1)
-              break;
-           if (errno != EINTR) {
-              Snr = 0xFFFF;
-#ifdef DEBUG_SIGNALQUALITY
-              HasSnr = false;
-#endif
-              break;
-              }
-           }
-#ifdef DEBUG_SIGNALQUALITY
-     bool HasBer = true;
-#endif
-     uint32_t Ber;
-     while (1) {
-           if (ioctl(fd_frontend, FE_READ_BER, &Ber) != -1)
-              break;
-           if (errno != EINTR) {
-              Ber = 0;
-#ifdef DEBUG_SIGNALQUALITY
-              HasBer = false;
-#endif
-              break;
-              }
-           }
-#ifdef DEBUG_SIGNALQUALITY
-     bool HasUnc = true;
-#endif
-     uint32_t Unc;
-     while (1) {
-           if (ioctl(fd_frontend, FE_READ_UNCORRECTED_BLOCKS, &Unc) != -1)
-              break;
-           if (errno != EINTR) {
-              Unc = 0;
-#ifdef DEBUG_SIGNALQUALITY
-              HasUnc = false;
-#endif
-              break;
-              }
-           }
-     uint16_t MinSnr = 0x0000;
-     uint16_t MaxSnr = 0xFFFF; // Let's assume the default is using the entire range.
-     // Use the subsystemId to identify individual devices in case they need
-     // special treatment to map their Snr value into the range 0...0xFFFF.
-     switch (subsystemId) {
-       case 0x13C21019: // TT-budget S2-3200 (DVB-S/DVB-S2)
-       case 0x1AE40001: // TechniSat SkyStar HD2 (DVB-S/DVB-S2)
-                        if (frontendType == SYS_DVBS2) {
-                           MinSnr = 10;
-                           MaxSnr = 70;
-                           }
-                        else
-                           MaxSnr = 200;
-                        break;
-       case 0x20130245: // PCTV Systems PCTV 73ESE
-       case 0x2013024F: // PCTV Systems nanoStick T2 290e
-                        MaxSnr = 255; break;
-       }
-     int a = int(constrain(Snr, MinSnr, MaxSnr)) * 100 / (MaxSnr - MinSnr);
-     int b = 100 - (Unc * 10 + (Ber / 256) * 5);
-     if (b < 0)
-        b = 0;
-     int q = LOCK_THRESHOLD + a * b * (100 - LOCK_THRESHOLD) / 100 / 100;
-     if (q > 100)
-        q = 100;
-#ifdef DEBUG_SIGNALQUALITY
-     fprintf(stderr, "FE %d/%d: %08X Q = %04X %04X %d %5d %5d %3d%%\n", adapter, frontend, subsystemId, MaxSnr, Snr, HasSnr, HasBer ? int(Ber) : -1, HasUnc ? int(Unc) : -1, q);
-#endif
-     return q;
-     }
-  return -1;
-}
-
-static unsigned int FrequencyToHz(unsigned int f)
-{
-  while (f && f < 1000000)
-        f *= 1000;
-  return f;
-}
-
-void cDvbTuner::ExecuteDiseqc(const cDiseqc *Diseqc, unsigned int *Frequency)
-{
-  if (!lnbPowerTurnedOn) {
-     CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13)); // must explicitly turn on LNB power
-     lnbPowerTurnedOn = true;
-     }
-  static cMutex Mutex;
-  if (Diseqc->IsScr())
-     Mutex.Lock();
-  struct dvb_diseqc_master_cmd cmd;
-  const char *CurrentAction = NULL;
-  for (;;) {
-      cmd.msg_len = sizeof(cmd.msg);
-      cDiseqc::eDiseqcActions da = Diseqc->Execute(&CurrentAction, cmd.msg, &cmd.msg_len, scr, Frequency);
-      if (da == cDiseqc::daNone)
-         break;
-      switch (da) {
-        case cDiseqc::daToneOff:   CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_OFF)); break;
-        case cDiseqc::daToneOn:    CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_ON)); break;
-        case cDiseqc::daVoltage13: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13)); break;
-        case cDiseqc::daVoltage18: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_18)); break;
-        case cDiseqc::daMiniA:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_A)); break;
-        case cDiseqc::daMiniB:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_B)); break;
-        case cDiseqc::daCodes:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &cmd)); break;
-        default: esyslog("ERROR: unknown diseqc command %d", da);
-        }
-      }
-  if (scr)
-     ResetToneAndVoltage(); // makes sure we don't block the bus!
-  if (Diseqc->IsScr())
-     Mutex.Unlock();
-}
-
-void cDvbTuner::ResetToneAndVoltage(void)
-{
-  CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, bondedTuner ? SEC_VOLTAGE_OFF : SEC_VOLTAGE_13));
-  CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_OFF));
-}
-
-static int GetRequiredDeliverySystem(const cChannel *Channel, const cDvbTransponderParameters *Dtp)
-{
-  int ds = SYS_UNDEFINED;
-  if (Channel->IsAtsc())
-     ds = SYS_ATSC;
-  else if (Channel->IsCable())
-     ds = SYS_DVBC_ANNEX_AC;
-  else if (Channel->IsSat())
-     ds = Dtp->System() == DVB_SYSTEM_1 ? SYS_DVBS : SYS_DVBS2;
-  else if (Channel->IsTerr())
-     ds = Dtp->System() == DVB_SYSTEM_1 ? SYS_DVBT : SYS_DVBT2;
-  else
-     esyslog("ERROR: can't determine frontend type for channel %d", Channel->Number());
-  return ds;
-}
-
-bool cDvbTuner::SetFrontend(void)
-{
-#define MAXFRONTENDCMDS 16
-#define SETCMD(c, d) { Frontend[CmdSeq.num].cmd = (c);\
-                       Frontend[CmdSeq.num].u.data = (d);\
-                       if (CmdSeq.num++ > MAXFRONTENDCMDS) {\
-                          esyslog("ERROR: too many tuning commands on frontend %d/%d", adapter, frontend);\
-                          return false;\
-                          }\
-                     }
-  dtv_property Frontend[MAXFRONTENDCMDS];
-  memset(&Frontend, 0, sizeof(Frontend));
-  dtv_properties CmdSeq;
-  memset(&CmdSeq, 0, sizeof(CmdSeq));
-  CmdSeq.props = Frontend;
-  SETCMD(DTV_CLEAR, 0);
-  if (ioctl(fd_frontend, FE_SET_PROPERTY, &CmdSeq) < 0) {
-     esyslog("ERROR: frontend %d/%d: %m", adapter, frontend);
-     return false;
-     }
-  CmdSeq.num = 0;
-
-  cDvbTransponderParameters dtp(channel.Parameters());
-
-  // Determine the required frontend type:
-  frontendType = GetRequiredDeliverySystem(&channel, &dtp);
-  if (frontendType == SYS_UNDEFINED)
-     return false;
-
-  SETCMD(DTV_DELIVERY_SYSTEM, frontendType);
-  if (frontendType == SYS_DVBS || frontendType == SYS_DVBS2) {
-     unsigned int frequency = channel.Frequency();
-     if (Setup.DiSEqC) {
-        if (const cDiseqc *diseqc = Diseqcs.Get(device->CardIndex() + 1, channel.Source(), frequency, dtp.Polarization(), &scr)) {
-           frequency -= diseqc->Lof();
-           if (diseqc != lastDiseqc || diseqc->IsScr()) {
-              if (IsBondedMaster()) {
-                 ExecuteDiseqc(diseqc, &frequency);
-                 if (frequency == 0)
-                    return false;
-                 }
-              else
-                 ResetToneAndVoltage();
-              lastDiseqc = diseqc;
-              }
-           }
-        else {
-           esyslog("ERROR: no DiSEqC parameters found for channel %d", channel.Number());
-           return false;
-           }
-        }
-     else {
-        int tone = SEC_TONE_OFF;
-        if (frequency < (unsigned int)Setup.LnbSLOF) {
-           frequency -= Setup.LnbFrequLo;
-           tone = SEC_TONE_OFF;
-           }
-        else {
-           frequency -= Setup.LnbFrequHi;
-           tone = SEC_TONE_ON;
-           }
-        int volt = (dtp.Polarization() == 'V' || dtp.Polarization() == 'R') ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18;
-        if (!IsBondedMaster()) {
-           tone = SEC_TONE_OFF;
-           volt = SEC_VOLTAGE_13;
-           }
-        CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, volt));
-        CHECK(ioctl(fd_frontend, FE_SET_TONE, tone));
-        }
-     frequency = abs(frequency); // Allow for C-band, where the frequency is less than the LOF
-
-     // DVB-S/DVB-S2 (common parts)
-     SETCMD(DTV_FREQUENCY, frequency * 1000UL);
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-     SETCMD(DTV_SYMBOL_RATE, channel.Srate() * 1000UL);
-     SETCMD(DTV_INNER_FEC, dtp.CoderateH());
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     if (frontendType == SYS_DVBS2) {
-        // DVB-S2
-        SETCMD(DTV_PILOT, PILOT_AUTO);
-        SETCMD(DTV_ROLLOFF, dtp.RollOff());
-        if (DvbApiVersion >= 0x0508)
-           SETCMD(DTV_STREAM_ID, dtp.StreamId());
-        }
-     else {
-        // DVB-S
-        SETCMD(DTV_ROLLOFF, ROLLOFF_35); // DVB-S always has a ROLLOFF of 0.35
-        }
-
-     tuneTimeout = DVBS_TUNE_TIMEOUT;
-     lockTimeout = DVBS_LOCK_TIMEOUT;
-     }
-  else if (frontendType == SYS_DVBC_ANNEX_AC || frontendType == SYS_DVBC_ANNEX_B) {
-     // DVB-C
-     SETCMD(DTV_FREQUENCY, FrequencyToHz(channel.Frequency()));
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     SETCMD(DTV_SYMBOL_RATE, channel.Srate() * 1000UL);
-     SETCMD(DTV_INNER_FEC, dtp.CoderateH());
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-
-     tuneTimeout = DVBC_TUNE_TIMEOUT;
-     lockTimeout = DVBC_LOCK_TIMEOUT;
-     }
-  else if (frontendType == SYS_DVBT || frontendType == SYS_DVBT2) {
-     // DVB-T/DVB-T2 (common parts)
-     SETCMD(DTV_FREQUENCY, FrequencyToHz(channel.Frequency()));
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     SETCMD(DTV_BANDWIDTH_HZ, dtp.Bandwidth());
-     SETCMD(DTV_CODE_RATE_HP, dtp.CoderateH());
-     SETCMD(DTV_CODE_RATE_LP, dtp.CoderateL());
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-     SETCMD(DTV_TRANSMISSION_MODE, dtp.Transmission());
-     SETCMD(DTV_GUARD_INTERVAL, dtp.Guard());
-     SETCMD(DTV_HIERARCHY, dtp.Hierarchy());
-     if (frontendType == SYS_DVBT2) {
-        // DVB-T2
-        if (DvbApiVersion >= 0x0508) {
-           SETCMD(DTV_STREAM_ID, dtp.StreamId());
-           }
-        else if (DvbApiVersion >= 0x0503)
-           SETCMD(DTV_DVBT2_PLP_ID_LEGACY, dtp.StreamId());
-        }
-
-     tuneTimeout = DVBT_TUNE_TIMEOUT;
-     lockTimeout = DVBT_LOCK_TIMEOUT;
-     }
-  else if (frontendType == SYS_ATSC) {
-     // ATSC
-     SETCMD(DTV_FREQUENCY, FrequencyToHz(channel.Frequency()));
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-
-     tuneTimeout = ATSC_TUNE_TIMEOUT;
-     lockTimeout = ATSC_LOCK_TIMEOUT;
-     }
-  else {
-     esyslog("ERROR: attempt to set channel with unknown DVB frontend type");
-     return false;
-     }
-  SETCMD(DTV_TUNE, 0);
-  if (ioctl(fd_frontend, FE_SET_PROPERTY, &CmdSeq) < 0) {
-     esyslog("ERROR: frontend %d/%d: %m", adapter, frontend);
-     return false;
-     }
-  return true;
-}
-
-void cDvbTuner::Action(void)
-{
-  cTimeMs Timer;
-  bool LostLock = false;
-  fe_status_t Status = (fe_status_t)0;
-  while (Running()) {
-        fe_status_t NewStatus;
-        if (GetFrontendStatus(NewStatus))
-           Status = NewStatus;
-        cMutexLock MutexLock(&mutex);
-        int WaitTime = 1000;
-        switch (tunerStatus) {
-          case tsIdle:
-               break;
-          case tsSet:
-               tunerStatus = SetFrontend() ? tsTuned : tsIdle;
-               Timer.Set(tuneTimeout + (scr ? rand() % SCR_RANDOM_TIMEOUT : 0));
-               continue;
-          case tsTuned:
-               if (Timer.TimedOut()) {
-                  tunerStatus = tsSet;
-                  lastDiseqc = NULL;
-                  if (time(NULL) - lastTimeoutReport > 60) { // let's not get too many of these
-                     isyslog("frontend %d/%d timed out while tuning to channel %d, tp %d", adapter, frontend, channel.Number(), channel.Transponder());
-                     lastTimeoutReport = time(NULL);
-                     }
-                  continue;
-                  }
-               WaitTime = 100; // allows for a quick change from tsTuned to tsLocked
-          case tsLocked:
-               if (Status & FE_REINIT) {
-                  tunerStatus = tsSet;
-                  lastDiseqc = NULL;
-                  isyslog("frontend %d/%d was reinitialized", adapter, frontend);
-                  lastTimeoutReport = 0;
-                  continue;
-                  }
-               else if (Status & FE_HAS_LOCK) {
-                  if (LostLock) {
-                     isyslog("frontend %d/%d regained lock on channel %d, tp %d", adapter, frontend, channel.Number(), channel.Transponder());
-                     LostLock = false;
-                     }
-                  tunerStatus = tsLocked;
-                  locked.Broadcast();
-                  lastTimeoutReport = 0;
-                  }
-               else if (tunerStatus == tsLocked) {
-                  LostLock = true;
-                  isyslog("frontend %d/%d lost lock on channel %d, tp %d", adapter, frontend, channel.Number(), channel.Transponder());
-                  tunerStatus = tsTuned;
-                  Timer.Set(lockTimeout);
-                  lastTimeoutReport = 0;
-                  continue;
-                  }
-               break;
-          default: esyslog("ERROR: unknown tuner status %d", tunerStatus);
-          }
-        newSet.TimedWait(mutex, WaitTime);
-        }
-}
-
-// --- cDvbSourceParam -------------------------------------------------------
-
-class cDvbSourceParam : public cSourceParam {
-private:
-  int param;
-  int srate;
-  cDvbTransponderParameters dtp;
-public:
-  cDvbSourceParam(char Source, const char *Description);
-  virtual void SetData(cChannel *Channel);
-  virtual void GetData(cChannel *Channel);
-  virtual cOsdItem *GetOsdItem(void);
-  };
-
-cDvbSourceParam::cDvbSourceParam(char Source, const char *Description)
-:cSourceParam(Source, Description)
-{
-  param = 0;
-  srate = 0;
-}
-
-void cDvbSourceParam::SetData(cChannel *Channel)
-{
-  srate = Channel->Srate();
-  dtp.Parse(Channel->Parameters());
-  param = 0;
-}
-
-void cDvbSourceParam::GetData(cChannel *Channel)
-{
-  Channel->SetTransponderData(Channel->Source(), Channel->Frequency(), srate, dtp.ToString(Source()), true);
-}
-
-cOsdItem *cDvbSourceParam::GetOsdItem(void)
-{
-  char type = Source();
-  const tDvbParameterMap *SystemValues = type == 'S' ? SystemValuesSat : SystemValuesTerr;
-#undef ST
-#define ST(s) if (strchr(s, type))
-  switch (param++) {
-    case  0: ST("  S ")  return new cMenuEditChrItem( tr("Polarization"), &dtp.polarization, "HVLR");             else return GetOsdItem();
-    case  1: ST("  ST")  return new cMenuEditMapItem( tr("System"),       &dtp.system,       SystemValues);       else return GetOsdItem();
-    case  2: ST(" CS ")  return new cMenuEditIntItem( tr("Srate"),        &srate);                                else return GetOsdItem();
-    case  3: ST("ACST")  return new cMenuEditMapItem( tr("Inversion"),    &dtp.inversion,    InversionValues);    else return GetOsdItem();
-    case  4: ST(" CST")  return new cMenuEditMapItem( tr("CoderateH"),    &dtp.coderateH,    CoderateValues);     else return GetOsdItem();
-    case  5: ST("   T")  return new cMenuEditMapItem( tr("CoderateL"),    &dtp.coderateL,    CoderateValues);     else return GetOsdItem();
-    case  6: ST("ACST")  return new cMenuEditMapItem( tr("Modulation"),   &dtp.modulation,   ModulationValues);   else return GetOsdItem();
-    case  7: ST("   T")  return new cMenuEditMapItem( tr("Bandwidth"),    &dtp.bandwidth,    BandwidthValues);    else return GetOsdItem();
-    case  8: ST("   T")  return new cMenuEditMapItem( tr("Transmission"), &dtp.transmission, TransmissionValues); else return GetOsdItem();
-    case  9: ST("   T")  return new cMenuEditMapItem( tr("Guard"),        &dtp.guard,        GuardValues);        else return GetOsdItem();
-    case 10: ST("   T")  return new cMenuEditMapItem( tr("Hierarchy"),    &dtp.hierarchy,    HierarchyValues);    else return GetOsdItem();
-    case 11: ST("  S ")  return new cMenuEditMapItem( tr("Rolloff"),      &dtp.rollOff,      RollOffValues);      else return GetOsdItem();
-    case 12: ST("  ST")  return new cMenuEditIntItem( tr("StreamId"),     &dtp.streamId,     0, 255);             else return GetOsdItem();
-    default: return NULL;
-    }
-  return NULL;
-}
-
-// --- cDvbDevice ------------------------------------------------------------
-
-int cDvbDevice::setTransferModeForDolbyDigital = 1;
-cMutex cDvbDevice::bondMutex;
-
-const char *DeliverySystemNames[] = {
-  "",
-  "DVB-C",
-  "DVB-C",
-  "DVB-T",
-  "DSS",
-  "DVB-S",
-  "DVB-S2",
-  "DVB-H",
-  "ISDBT",
-  "ISDBS",
-  "ISDBC",
-  "ATSC",
-  "ATSCMH",
-  "DMBTH",
-  "CMMB",
-  "DAB",
-  "DVB-T2",
-  "TURBO",
-  NULL
-  };
-
-cDvbDevice::cDvbDevice(int Adapter, int Frontend)
-{
-  adapter = Adapter;
-  frontend = Frontend;
-  ciAdapter = NULL;
-  dvbTuner = NULL;
-  numDeliverySystems = 0;
-  numModulations = 0;
-  bondedDevice = NULL;
-  needsDetachBondedReceivers = false;
-  tsBuffer = NULL;
-
-  // Devices that are present on all card types:
-
-  int fd_frontend = DvbOpen(DEV_DVB_FRONTEND, adapter, frontend, O_RDWR | O_NONBLOCK);
-
-  // Common Interface:
-
-  fd_ca = DvbOpen(DEV_DVB_CA, adapter, frontend, O_RDWR);
-  if (fd_ca >= 0)
-     ciAdapter = cDvbCiAdapter::CreateCiAdapter(this, fd_ca);
-
-  // The DVR device (will be opened and closed as needed):
-
-  fd_dvr = -1;
-
-  // We only check the devices that must be present - the others will be checked before accessing them://XXX
-
-  if (fd_frontend >= 0) {
-     if (QueryDeliverySystems(fd_frontend))
-        dvbTuner = new cDvbTuner(this, fd_frontend, adapter, frontend);
-     }
-  else
-     esyslog("ERROR: can't open DVB device %d/%d", adapter, frontend);
-
-  StartSectionHandler();
-}
-
-cDvbDevice::~cDvbDevice()
-{
-  StopSectionHandler();
-  delete dvbTuner;
-  delete ciAdapter;
-  UnBond();
-  // We're not explicitly closing any device files here, since this sometimes
-  // caused segfaults. Besides, the program is about to terminate anyway...
-}
-
-cString cDvbDevice::DvbName(const char *Name, int Adapter, int Frontend)
-{
-  return cString::sprintf("%s/%s%d/%s%d", DEV_DVB_BASE, DEV_DVB_ADAPTER, Adapter, Name, Frontend);
-}
-
-int cDvbDevice::DvbOpen(const char *Name, int Adapter, int Frontend, int Mode, bool ReportError)
-{
-  cString FileName = DvbName(Name, Adapter, Frontend);
-  int fd = open(FileName, Mode);
-  if (fd < 0 && ReportError)
-     LOG_ERROR_STR(*FileName);
-  return fd;
-}
-
-bool cDvbDevice::Exists(int Adapter, int Frontend)
-{
-  cString FileName = DvbName(DEV_DVB_FRONTEND, Adapter, Frontend);
-  if (access(FileName, F_OK) == 0) {
-     int f = open(FileName, O_RDONLY);
-     if (f >= 0) {
-        close(f);
-        return true;
-        }
-     else if (errno != ENODEV && errno != EINVAL)
-        LOG_ERROR_STR(*FileName);
-     }
-  else if (errno != ENOENT)
-     LOG_ERROR_STR(*FileName);
-  return false;
-}
-
-bool cDvbDevice::Probe(int Adapter, int Frontend)
-{
-  cString FileName = DvbName(DEV_DVB_FRONTEND, Adapter, Frontend);
-  dsyslog("probing %s", *FileName);
-  for (cDvbDeviceProbe *dp = DvbDeviceProbes.First(); dp; dp = DvbDeviceProbes.Next(dp)) {
-      if (dp->Probe(Adapter, Frontend))
-         return true; // a plugin has created the actual device
-      }
-  dsyslog("creating cDvbDevice");
-  new cDvbDevice(Adapter, Frontend); // it's a "budget" device
-  return true;
-}
-
-cString cDvbDevice::DeviceType(void) const
-{
-  if (dvbTuner) {
-     if (dvbTuner->FrontendType() != SYS_UNDEFINED)
-        return DeliverySystemNames[dvbTuner->FrontendType()];
-     if (numDeliverySystems)
-        return DeliverySystemNames[deliverySystems[0]]; // to have some reasonable default
-     }
-  return "";
-}
-
-cString cDvbDevice::DeviceName(void) const
-{
-  return frontendInfo.name;
-}
-
-bool cDvbDevice::Initialize(void)
-{
-  new cDvbSourceParam('A', "ATSC");
-  new cDvbSourceParam('C', "DVB-C");
-  new cDvbSourceParam('S', "DVB-S");
-  new cDvbSourceParam('T', "DVB-T");
-  cStringList Nodes;
-  cReadDir DvbDir(DEV_DVB_BASE);
-  if (DvbDir.Ok()) {
-     struct dirent *a;
-     while ((a = DvbDir.Next()) != NULL) {
-           if (strstr(a->d_name, DEV_DVB_ADAPTER) == a->d_name) {
-              int Adapter = strtol(a->d_name + strlen(DEV_DVB_ADAPTER), NULL, 10);
-              cReadDir AdapterDir(AddDirectory(DEV_DVB_BASE, a->d_name));
-              if (AdapterDir.Ok()) {
-                 struct dirent *f;
-                 while ((f = AdapterDir.Next()) != NULL) {
-                       if (strstr(f->d_name, DEV_DVB_FRONTEND) == f->d_name) {
-                          int Frontend = strtol(f->d_name + strlen(DEV_DVB_FRONTEND), NULL, 10);
-                          Nodes.Append(strdup(cString::sprintf("%2d %2d", Adapter, Frontend)));
-                          }
-                       }
-                 }
-              }
-           }
-     }
-  int Checked = 0;
-  int Found = 0;
-  if (Nodes.Size() > 0) {
-     Nodes.Sort();
-     for (int i = 0; i < Nodes.Size(); i++) {
-         int Adapter;
-         int Frontend;
-         if (2 == sscanf(Nodes[i], "%d %d", &Adapter, &Frontend)) {
-            if (Exists(Adapter, Frontend)) {
-               if (Checked++ < MAXDVBDEVICES) {
-                  if (UseDevice(NextCardIndex())) {
-                     if (Probe(Adapter, Frontend))
-                        Found++;
-                     }
-                  else
-                     NextCardIndex(1); // skips this one
-                  }
-               }
-            }
-         }
-     }
-  NextCardIndex(MAXDVBDEVICES - Checked); // skips the rest
-  if (Found > 0)
-     isyslog("found %d DVB device%s", Found, Found > 1 ? "s" : "");
-  else
-     isyslog("no DVB device found");
-  return Found > 0;
-}
-
-bool cDvbDevice::QueryDeliverySystems(int fd_frontend)
-{
-  numDeliverySystems = 0;
-  if (ioctl(fd_frontend, FE_GET_INFO, &frontendInfo) < 0) {
-     LOG_ERROR;
-     return false;
-     }
-  dtv_property Frontend[1];
-  dtv_properties CmdSeq;
-  // Determine the version of the running DVB API:
-  if (!DvbApiVersion) {
-     memset(&Frontend, 0, sizeof(Frontend));
-     memset(&CmdSeq, 0, sizeof(CmdSeq));
-     CmdSeq.props = Frontend;
-     SETCMD(DTV_API_VERSION, 0);
-     if (ioctl(fd_frontend, FE_GET_PROPERTY, &CmdSeq) != 0) {
-        LOG_ERROR;
-        return false;
-        }
-     DvbApiVersion = Frontend[0].u.data;
-     isyslog("DVB API version is 0x%04X (VDR was built with 0x%04X)", DvbApiVersion, DVBAPIVERSION);
-     }
-  // Determine the types of delivery systems this device provides:
-  bool LegacyMode = true;
-  if (DvbApiVersion >= 0x0505) {
-     memset(&Frontend, 0, sizeof(Frontend));
-     memset(&CmdSeq, 0, sizeof(CmdSeq));
-     CmdSeq.props = Frontend;
-     SETCMD(DTV_ENUM_DELSYS, 0);
-     int Result = ioctl(fd_frontend, FE_GET_PROPERTY, &CmdSeq);
-     if (Result == 0) {
-        for (uint i = 0; i < Frontend[0].u.buffer.len; i++) {
-            if (numDeliverySystems >= MAXDELIVERYSYSTEMS) {
-               esyslog("ERROR: too many delivery systems on frontend %d/%d", adapter, frontend);
-               break;
-               }
-            deliverySystems[numDeliverySystems++] = Frontend[0].u.buffer.data[i];
-            }
-        LegacyMode = false;
-        }
-     else {
-        esyslog("ERROR: can't query delivery systems on frontend %d/%d - falling back to legacy mode", adapter, frontend);
-        }
-     }
-  if (LegacyMode) {
-     // Legacy mode (DVB-API < 5.5):
-     switch (frontendInfo.type) {
-       case FE_QPSK: deliverySystems[numDeliverySystems++] = SYS_DVBS;
-                     if (frontendInfo.caps & FE_CAN_2G_MODULATION)
-                        deliverySystems[numDeliverySystems++] = SYS_DVBS2;
-                     break;
-       case FE_OFDM: deliverySystems[numDeliverySystems++] = SYS_DVBT;
-                     if (frontendInfo.caps & FE_CAN_2G_MODULATION)
-                        deliverySystems[numDeliverySystems++] = SYS_DVBT2;
-                     break;
-       case FE_QAM:  deliverySystems[numDeliverySystems++] = SYS_DVBC_ANNEX_AC; break;
-       case FE_ATSC: deliverySystems[numDeliverySystems++] = SYS_ATSC; break;
-       default: esyslog("ERROR: unknown frontend type %d on frontend %d/%d", frontendInfo.type, adapter, frontend);
-       }
-     }
-  if (numDeliverySystems > 0) {
-     cString ds("");
-     for (int i = 0; i < numDeliverySystems; i++)
-         ds = cString::sprintf("%s%s%s", *ds, i ? "," : "", DeliverySystemNames[deliverySystems[i]]);
-     cString ms("");
-     if (frontendInfo.caps & FE_CAN_QPSK)      { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QPSK, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_16)    { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_16, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_32)    { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_32, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_64)    { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_64, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_128)   { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_128, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_256)   { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_256, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_8VSB)      { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(VSB_8, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_16VSB)     { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(VSB_16, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_TURBO_FEC) { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", "TURBO_FEC"); }
-     if (!**ms)
-        ms = "unknown modulations";
-     isyslog("frontend %d/%d provides %s with %s (\"%s\")", adapter, frontend, *ds, *ms, frontendInfo.name);
-     return true;
-     }
-  else
-     esyslog("ERROR: frontend %d/%d doesn't provide any delivery systems", adapter, frontend);
-  return false;
-}
-
-bool cDvbDevice::Ready(void)
-{
-  if (ciAdapter)
-     return ciAdapter->Ready();
-  return true;
-}
-
-bool cDvbDevice::BondDevices(const char *Bondings)
-{
-  UnBondDevices();
-  if (Bondings) {
-     cSatCableNumbers SatCableNumbers(MAXDEVICES, Bondings);
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         int d = SatCableNumbers.FirstDeviceIndex(i);
-         if (d >= 0) {
-            int ErrorDevice = 0;
-            if (cDevice *Device1 = cDevice::GetDevice(i)) {
-               if (cDevice *Device2 = cDevice::GetDevice(d)) {
-                  if (cDvbDevice *DvbDevice1 = dynamic_cast<cDvbDevice *>(Device1)) {
-                     if (cDvbDevice *DvbDevice2 = dynamic_cast<cDvbDevice *>(Device2)) {
-                        if (!DvbDevice1->Bond(DvbDevice2))
-                           return false; // Bond() has already logged the error
-                        }
-                     else
-                        ErrorDevice = d + 1;
-                     }
-                  else
-                     ErrorDevice = i + 1;
-                  if (ErrorDevice) {
-                     esyslog("ERROR: device '%d' in device bondings '%s' is not a cDvbDevice", ErrorDevice, Bondings);
-                     return false;
-                     }
-                  }
-               else
-                  ErrorDevice = d + 1;
-               }
-            else
-               ErrorDevice = i + 1;
-            if (ErrorDevice) {
-               esyslog("ERROR: unknown device '%d' in device bondings '%s'", ErrorDevice, Bondings);
-               return false;
-               }
-            }
-         }
-     }
-  return true;
-}
-
-void cDvbDevice::UnBondDevices(void)
-{
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      if (cDvbDevice *d = dynamic_cast<cDvbDevice *>(cDevice::GetDevice(i)))
-         d->UnBond();
-      }
-}
-
-bool cDvbDevice::Bond(cDvbDevice *Device)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (!bondedDevice) {
-     if (Device != this) {
-        if ((ProvidesDeliverySystem(SYS_DVBS) || ProvidesDeliverySystem(SYS_DVBS2)) && (Device->ProvidesDeliverySystem(SYS_DVBS) || Device->ProvidesDeliverySystem(SYS_DVBS2))) {
-           if (dvbTuner && Device->dvbTuner && dvbTuner->Bond(Device->dvbTuner)) {
-              bondedDevice = Device->bondedDevice ? Device->bondedDevice : Device;
-              Device->bondedDevice = this;
-              dsyslog("device %d bonded with device %d", CardIndex() + 1, bondedDevice->CardIndex() + 1);
-              return true;
-              }
-           }
-        else
-           esyslog("ERROR: can't bond device %d with device %d (only DVB-S(2) devices can be bonded)", CardIndex() + 1, Device->CardIndex() + 1);
-        }
-     else
-        esyslog("ERROR: can't bond device %d with itself", CardIndex() + 1);
-     }
-  else
-     esyslog("ERROR: device %d already bonded with device %d, can't bond with device %d", CardIndex() + 1, bondedDevice->CardIndex() + 1, Device->CardIndex() + 1);
-  return false;
-}
-
-void cDvbDevice::UnBond(void)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (cDvbDevice *d = bondedDevice) {
-     if (dvbTuner)
-        dvbTuner->UnBond();
-     dsyslog("device %d unbonded from device %d", CardIndex() + 1, bondedDevice->CardIndex() + 1);
-     while (d->bondedDevice != this)
-           d = d->bondedDevice;
-     if (d == bondedDevice)
-        d->bondedDevice = NULL;
-     else
-        d->bondedDevice = bondedDevice;
-     bondedDevice = NULL;
-     }
-}
-
-bool cDvbDevice::BondingOk(const cChannel *Channel, bool ConsiderOccupied) const
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (bondedDevice)
-     return dvbTuner && dvbTuner->BondingOk(Channel, ConsiderOccupied);
-  return true;
-}
-
-bool cDvbDevice::HasCi(void)
-{
-  return ciAdapter;
-}
-
-bool cDvbDevice::SetPid(cPidHandle *Handle, int Type, bool On)
-{
-  if (Handle->pid) {
-     dmx_pes_filter_params pesFilterParams;
-     memset(&pesFilterParams, 0, sizeof(pesFilterParams));
-     if (On) {
-        if (Handle->handle < 0) {
-           Handle->handle = DvbOpen(DEV_DVB_DEMUX, adapter, frontend, O_RDWR | O_NONBLOCK, true);
-           if (Handle->handle < 0) {
-              LOG_ERROR;
-              return false;
-              }
-           }
-        pesFilterParams.pid     = Handle->pid;
-        pesFilterParams.input   = DMX_IN_FRONTEND;
-        pesFilterParams.output  = DMX_OUT_TS_TAP;
-        pesFilterParams.pes_type= DMX_PES_OTHER;
-        pesFilterParams.flags   = DMX_IMMEDIATE_START;
-        if (ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams) < 0) {
-           LOG_ERROR;
-           return false;
-           }
-        }
-     else if (!Handle->used) {
-        CHECK(ioctl(Handle->handle, DMX_STOP));
-        if (Type <= ptTeletext) {
-           pesFilterParams.pid     = 0x1FFF;
-           pesFilterParams.input   = DMX_IN_FRONTEND;
-           pesFilterParams.output  = DMX_OUT_DECODER;
-           pesFilterParams.pes_type= DMX_PES_OTHER;
-           pesFilterParams.flags   = DMX_IMMEDIATE_START;
-           CHECK(ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams));
-           }
-        close(Handle->handle);
-        Handle->handle = -1;
-        }
-     }
-  return true;
-}
-
-int cDvbDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
-{
-  cString FileName = DvbName(DEV_DVB_DEMUX, adapter, frontend);
-  int f = open(FileName, O_RDWR | O_NONBLOCK);
-  if (f >= 0) {
-     dmx_sct_filter_params sctFilterParams;
-     memset(&sctFilterParams, 0, sizeof(sctFilterParams));
-     sctFilterParams.pid = Pid;
-     sctFilterParams.timeout = 0;
-     sctFilterParams.flags = DMX_IMMEDIATE_START;
-     sctFilterParams.filter.filter[0] = Tid;
-     sctFilterParams.filter.mask[0] = Mask;
-     if (ioctl(f, DMX_SET_FILTER, &sctFilterParams) >= 0)
-        return f;
-     else {
-        esyslog("ERROR: can't set filter (pid=%d, tid=%02X, mask=%02X): %m", Pid, Tid, Mask);
-        close(f);
-        }
-     }
-  else
-     esyslog("ERROR: can't open filter handle on '%s'", *FileName);
-  return -1;
-}
-
-void cDvbDevice::CloseFilter(int Handle)
-{
-  close(Handle);
-}
-
-bool cDvbDevice::ProvidesDeliverySystem(int DeliverySystem) const
-{
-  for (int i = 0; i < numDeliverySystems; i++) {
-      if (deliverySystems[i] == DeliverySystem)
-         return true;
-      }
-  return false;
-}
-
-bool cDvbDevice::ProvidesSource(int Source) const
-{
-  if (Setup.ChannelBlocker == 1) {
-      if (IsPrimaryDevice()) return false;
-      //isyslog("ChannelBlocker aktive on primary Interface");
-  }
-  int type = Source & cSource::st_Mask;
-  return type == cSource::stNone
-      || type == cSource::stAtsc  && ProvidesDeliverySystem(SYS_ATSC)
-      || type == cSource::stCable && (ProvidesDeliverySystem(SYS_DVBC_ANNEX_AC) || ProvidesDeliverySystem(SYS_DVBC_ANNEX_B))
-      || type == cSource::stSat   && (ProvidesDeliverySystem(SYS_DVBS) || ProvidesDeliverySystem(SYS_DVBS2))
-      || type == cSource::stTerr  && (ProvidesDeliverySystem(SYS_DVBT) || ProvidesDeliverySystem(SYS_DVBT2));
-}
-
-bool cDvbDevice::ProvidesTransponder(const cChannel *Channel) const
-{
-  if (!ProvidesSource(Channel->Source()))
-     return false; // doesn't provide source
-  cDvbTransponderParameters dtp(Channel->Parameters());
-  if (!ProvidesDeliverySystem(GetRequiredDeliverySystem(Channel, &dtp)) ||
-     dtp.StreamId()   != 0        && !(frontendInfo.caps & FE_CAN_MULTISTREAM) ||
-     dtp.Modulation() == QPSK     && !(frontendInfo.caps & FE_CAN_QPSK) ||
-     dtp.Modulation() == QAM_16   && !(frontendInfo.caps & FE_CAN_QAM_16) ||
-     dtp.Modulation() == QAM_32   && !(frontendInfo.caps & FE_CAN_QAM_32) ||
-     dtp.Modulation() == QAM_64   && !(frontendInfo.caps & FE_CAN_QAM_64) ||
-     dtp.Modulation() == QAM_128  && !(frontendInfo.caps & FE_CAN_QAM_128) ||
-     dtp.Modulation() == QAM_256  && !(frontendInfo.caps & FE_CAN_QAM_256) ||
-     dtp.Modulation() == QAM_AUTO && !(frontendInfo.caps & FE_CAN_QAM_AUTO) ||
-     dtp.Modulation() == VSB_8    && !(frontendInfo.caps & FE_CAN_8VSB) ||
-     dtp.Modulation() == VSB_16   && !(frontendInfo.caps & FE_CAN_16VSB) ||
-     dtp.Modulation() == PSK_8    && !(frontendInfo.caps & FE_CAN_TURBO_FEC) && dtp.System() == SYS_DVBS) // "turbo fec" is a non standard FEC used by North American broadcasters - this is a best guess to determine this condition
-     return false; // requires modulation system which frontend doesn't provide
-  if (!cSource::IsSat(Channel->Source()) ||
-     (!Setup.DiSEqC || Diseqcs.Get(CardIndex() + 1, Channel->Source(), Channel->Frequency(), dtp.Polarization(), NULL)))
-     return DeviceHooksProvidesTransponder(Channel);
-  return false;
-}
-
-bool cDvbDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
-{
-  bool result = false;
-  bool hasPriority = Priority == IDLEPRIORITY || Priority > this->Priority();
-  bool needsDetachReceivers = false;
-  needsDetachBondedReceivers = false;
-
-  if (dvbTuner && ProvidesTransponder(Channel)) {
-     result = hasPriority;
-     if (Priority > IDLEPRIORITY) {
-        if (Receiving()) {
-           if (dvbTuner->IsTunedTo(Channel)) {
-              if (Channel->Vpid() && !HasPid(Channel->Vpid()) || Channel->Apid(0) && !HasPid(Channel->Apid(0)) || Channel->Dpid(0) && !HasPid(Channel->Dpid(0))) {
-                 if (CamSlot() && Channel->Ca() >= CA_ENCRYPTED_MIN) {
-                    if (CamSlot()->CanDecrypt(Channel))
-                       result = true;
-                    else
-                       needsDetachReceivers = true;
-                    }
-                 else
-                    result = true;
-                 }
-              else
-                 result = true;
-              }
-           else
-              needsDetachReceivers = Receiving();
-           }
-        if (result) {
-           cMutexLock MutexLock(&bondMutex);
-           if (!BondingOk(Channel)) {
-              // This device is bonded, so we need to check the priorities of the others:
-              for (cDvbDevice *d = bondedDevice; d && d != this; d = d->bondedDevice) {
-                  if (d->Priority() >= Priority) {
-                     result = false;
-                     break;
-                     }
-                  needsDetachReceivers |= d->Receiving();
-                  }
-              needsDetachBondedReceivers = true;
-              needsDetachReceivers |= Receiving();
-              }
-           }
-        }
-     }
-  if (NeedsDetachReceivers)
-     *NeedsDetachReceivers = needsDetachReceivers;
-  return result;
-}
-
-bool cDvbDevice::ProvidesEIT(void) const
-{
-  return dvbTuner != NULL;
-}
-
-int cDvbDevice::NumProvidedSystems(void) const
-{
-  return numDeliverySystems + numModulations;
-}
-
-int cDvbDevice::SignalStrength(void) const
-{
-  return dvbTuner ? dvbTuner->GetSignalStrength() : -1;
-}
-
-int cDvbDevice::SignalQuality(void) const
-{
-  return dvbTuner ? dvbTuner->GetSignalQuality() : -1;
-}
-
-const cChannel *cDvbDevice::GetCurrentlyTunedTransponder(void) const
-{
-  return dvbTuner ? dvbTuner->GetTransponder() : NULL;
-}
-
-bool cDvbDevice::IsTunedToTransponder(const cChannel *Channel) const
-{
-  return dvbTuner ? dvbTuner->IsTunedTo(Channel) : false;
-}
-
-bool cDvbDevice::MaySwitchTransponder(const cChannel *Channel) const
-{
-  return BondingOk(Channel, true) && cDevice::MaySwitchTransponder(Channel);
-}
-
-bool cDvbDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
-{
-  if (dvbTuner)
-     dvbTuner->SetChannel(Channel);
-  return true;
-}
-
-bool cDvbDevice::HasLock(int TimeoutMs) const
-{
-  return dvbTuner ? dvbTuner->Locked(TimeoutMs) : false;
-}
-
-void cDvbDevice::SetTransferModeForDolbyDigital(int Mode)
-{
-  setTransferModeForDolbyDigital = Mode;
-}
-
-bool cDvbDevice::OpenDvr(void)
-{
-  CloseDvr();
-  fd_dvr = DvbOpen(DEV_DVB_DVR, adapter, frontend, O_RDONLY | O_NONBLOCK, true);
-  if (fd_dvr >= 0)
-     tsBuffer = new cTSBuffer(fd_dvr, MEGABYTE(5), CardIndex() + 1);
-  return fd_dvr >= 0;
-}
-
-void cDvbDevice::CloseDvr(void)
-{
-  if (fd_dvr >= 0) {
-     delete tsBuffer;
-     tsBuffer = NULL;
-     close(fd_dvr);
-     fd_dvr = -1;
-     }
-}
-
-bool cDvbDevice::GetTSPacket(uchar *&Data)
-{
-  if (tsBuffer) {
-     Data = tsBuffer->Get();
-     return true;
-     }
-  return false;
-}
-
-void cDvbDevice::DetachAllReceivers(void)
-{
-  cMutexLock MutexLock(&bondMutex);
-  cDvbDevice *d = this;
-  do {
-     d->cDevice::DetachAllReceivers();
-     d = d->bondedDevice;
-     } while (d && d != this && needsDetachBondedReceivers);
-  needsDetachBondedReceivers = false;
-}
-
-// --- cDvbDeviceProbe -------------------------------------------------------
-
-cList<cDvbDeviceProbe> DvbDeviceProbes;
-
-cDvbDeviceProbe::cDvbDeviceProbe(void)
-{
-  DvbDeviceProbes.Add(this);
-}
-
-cDvbDeviceProbe::~cDvbDeviceProbe()
-{
-  DvbDeviceProbes.Del(this, false);
-}
-
-uint32_t cDvbDeviceProbe::GetSubsystemId(int Adapter, int Frontend)
-{
-  uint32_t SubsystemId = 0;
-  cString FileName = cString::sprintf("/dev/dvb/adapter%d/frontend%d", Adapter, Frontend);
-  struct stat st;
-  if (stat(FileName, &st) == 0) {
-     cReadDir d("/sys/class/dvb");
-     if (d.Ok()) {
-        struct dirent *e;
-        while ((e = d.Next()) != NULL) {
-              if (strstr(e->d_name, "frontend")) {
-                 FileName = cString::sprintf("/sys/class/dvb/%s/dev", e->d_name);
-                 if (FILE *f = fopen(FileName, "r")) {
-                    cReadLine ReadLine;
-                    char *s = ReadLine.Read(f);
-                    fclose(f);
-                    unsigned Major;
-                    unsigned Minor;
-                    if (s && 2 == sscanf(s, "%u:%u", &Major, &Minor)) {
-                       if (((Major << 8) | Minor) == st.st_rdev) {
-                          FileName = cString::sprintf("/sys/class/dvb/%s/device/subsystem_vendor", e->d_name);
-                          if ((f = fopen(FileName, "r")) != NULL) {
-                             if (char *s = ReadLine.Read(f))
-                                SubsystemId = strtoul(s, NULL, 0) << 16;
-                             fclose(f);
-                             }
-                          FileName = cString::sprintf("/sys/class/dvb/%s/device/subsystem_device", e->d_name);
-                          if ((f = fopen(FileName, "r")) != NULL) {
-                             if (char *s = ReadLine.Read(f))
-                                SubsystemId |= strtoul(s, NULL, 0);
-                             fclose(f);
-                             }
-                          break;
-                          }
-                       }
-                    }
-                 }
-              }
-        }
-     }
-  return SubsystemId;
-}
diff -urN vdr-2.0.4-org/dvbdevice.h.orig vdr-2.0.4/dvbdevice.h.orig
--- vdr-2.0.4-org/dvbdevice.h.orig	2013-10-25 09:44:22.520680546 +0200
+++ vdr-2.0.4/dvbdevice.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,304 +0,0 @@
-/*
- * dvbdevice.h: The DVB device tuner interface
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: dvbdevice.h 2.29.1.1 2013/04/09 13:43:33 kls Exp $
- */
-
-#ifndef __DVBDEVICE_H
-#define __DVBDEVICE_H
-
-#include <linux/dvb/frontend.h>
-#include <linux/dvb/version.h>
-#include "device.h"
-
-#define DVBAPIVERSION (DVB_API_VERSION << 8 | DVB_API_VERSION_MINOR)
-
-#if DVBAPIVERSION < 0x0500
-#error VDR requires Linux DVB driver API version 5.0 or higher!
-#endif
-
-// --- Definitions for older DVB API versions --------------------------------
-
-#if DVBAPIVERSION < 0x0501
-enum {
-  FE_CAN_2G_MODULATION = 0x10000000,
-  };
-enum {
-  TRANSMISSION_MODE_4K = TRANSMISSION_MODE_AUTO + 1,
-  };
-#endif
-
-#if DVBAPIVERSION < 0x0502
-enum {
-  FE_CAN_TURBO_FEC = 0x8000000,
-  };
-#endif
-
-#if DVBAPIVERSION < 0x0503
-enum {
-  TRANSMISSION_MODE_1K = TRANSMISSION_MODE_4K + 1,
-  TRANSMISSION_MODE_16K,
-  TRANSMISSION_MODE_32K,
-  };
-enum {
-  GUARD_INTERVAL_1_128 = GUARD_INTERVAL_AUTO + 1,
-  GUARD_INTERVAL_19_128,
-  GUARD_INTERVAL_19_256,
-  };
-enum {
-  SYS_DVBT2 = SYS_DAB + 1,
-  };
-#endif
-
-#if DVBAPIVERSION < 0x0505
-#define DTV_ENUM_DELSYS  44
-#endif
-
-#if DVBAPIVERSION < 0x0508
-enum {
-  FE_CAN_MULTISTREAM = 0x4000000,
-  };
-#define DTV_STREAM_ID            42
-#define DTV_DVBT2_PLP_ID_LEGACY  43
-#endif
-
-// --- End of definitions for older DVB API versions -------------------------
-
-#define MAXDVBDEVICES  8
-#define MAXDELIVERYSYSTEMS 8
-
-#define DEV_VIDEO         "/dev/video"
-#define DEV_DVB_BASE      "/dev/dvb"
-#define DEV_DVB_ADAPTER   "adapter"
-#define DEV_DVB_OSD       "osd"
-#define DEV_DVB_FRONTEND  "frontend"
-#define DEV_DVB_DVR       "dvr"
-#define DEV_DVB_DEMUX     "demux"
-#define DEV_DVB_VIDEO     "video"
-#define DEV_DVB_AUDIO     "audio"
-#define DEV_DVB_CA        "ca"
-
-struct tDvbParameterMap {
-  int userValue;
-  int driverValue;
-  const char *userString;
-  };
-
-const char *MapToUserString(int Value, const tDvbParameterMap *Map);
-int MapToUser(int Value, const tDvbParameterMap *Map, const char **String = NULL);
-int MapToDriver(int Value, const tDvbParameterMap *Map);
-int UserIndex(int Value, const tDvbParameterMap *Map);
-int DriverIndex(int Value, const tDvbParameterMap *Map);
-
-extern const tDvbParameterMap InversionValues[];
-extern const tDvbParameterMap BandwidthValues[];
-extern const tDvbParameterMap CoderateValues[];
-extern const tDvbParameterMap ModulationValues[];
-extern const tDvbParameterMap SystemValuesSat[];
-extern const tDvbParameterMap SystemValuesTerr[];
-extern const tDvbParameterMap TransmissionValues[];
-extern const tDvbParameterMap GuardValues[];
-extern const tDvbParameterMap HierarchyValues[];
-extern const tDvbParameterMap RollOffValues[];
-
-class cDvbTransponderParameters {
-friend class cDvbSourceParam;
-private:
-  char polarization;
-  int inversion;
-  int bandwidth;
-  int coderateH;
-  int coderateL;
-  int modulation;
-  int system;
-  int transmission;
-  int guard;
-  int hierarchy;
-  int rollOff;
-  int streamId;
-  int PrintParameter(char *p, char Name, int Value) const;
-  const char *ParseParameter(const char *s, int &Value, const tDvbParameterMap *Map = NULL);
-public:
-  cDvbTransponderParameters(const char *Parameters = NULL);
-  char Polarization(void) const { return polarization; }
-  int Inversion(void) const { return inversion; }
-  int Bandwidth(void) const { return bandwidth; }
-  int CoderateH(void) const { return coderateH; }
-  int CoderateL(void) const { return coderateL; }
-  int Modulation(void) const { return modulation; }
-  int System(void) const { return system; }
-  int Transmission(void) const { return transmission; }
-  int Guard(void) const { return guard; }
-  int Hierarchy(void) const { return hierarchy; }
-  int RollOff(void) const { return rollOff; }
-  int StreamId(void) const { return streamId; }
-  void SetPolarization(char Polarization) { polarization = Polarization; }
-  void SetInversion(int Inversion) { inversion = Inversion; }
-  void SetBandwidth(int Bandwidth) { bandwidth = Bandwidth; }
-  void SetCoderateH(int CoderateH) { coderateH = CoderateH; }
-  void SetCoderateL(int CoderateL) { coderateL = CoderateL; }
-  void SetModulation(int Modulation) { modulation = Modulation; }
-  void SetSystem(int System) { system = System; }
-  void SetTransmission(int Transmission) { transmission = Transmission; }
-  void SetGuard(int Guard) { guard = Guard; }
-  void SetHierarchy(int Hierarchy) { hierarchy = Hierarchy; }
-  void SetRollOff(int RollOff) { rollOff = RollOff; }
-  void SetStreamId(int StreamId) { streamId = StreamId; }
-  cString ToString(char Type) const;
-  bool Parse(const char *s);
-  };
-
-class cDvbTuner;
-
-/// The cDvbDevice implements a DVB device which can be accessed through the Linux DVB driver API.
-
-class cDvbDevice : public cDevice {
-protected:
-  static cString DvbName(const char *Name, int Adapter, int Frontend);
-  static int DvbOpen(const char *Name, int Adapter, int Frontend, int Mode, bool ReportError = false);
-private:
-  static bool Exists(int Adapter, int Frontend);
-         ///< Checks whether the given adapter/frontend exists.
-  static bool Probe(int Adapter, int Frontend);
-         ///< Probes for existing DVB devices.
-public:
-  static bool Initialize(void);
-         ///< Initializes the DVB devices.
-         ///< Must be called before accessing any DVB functions.
-         ///< Returns true if any devices are available.
-protected:
-  int adapter, frontend;
-private:
-  dvb_frontend_info frontendInfo;
-  int deliverySystems[MAXDELIVERYSYSTEMS];
-  int numDeliverySystems;
-  int numModulations;
-  int fd_dvr, fd_ca;
-  static cMutex bondMutex;
-  cDvbDevice *bondedDevice;
-  mutable bool needsDetachBondedReceivers;
-  bool QueryDeliverySystems(int fd_frontend);
-public:
-  cDvbDevice(int Adapter, int Frontend);
-  virtual ~cDvbDevice();
-  int Adapter(void) const { return adapter; }
-  int Frontend(void) const { return frontend; }
-  virtual bool Ready(void);
-  virtual cString DeviceType(void) const;
-  virtual cString DeviceName(void) const;
-  static bool BondDevices(const char *Bondings);
-       ///< Bonds the devices as defined in the given Bondings string.
-       ///< A bonding is a sequence of device numbers (starting at 1),
-       ///< separated by '+' characters. Several bondings are separated by
-       ///< commas, as in "1+2,3+4+5".
-       ///< Returns false if an error occurred.
-  static void UnBondDevices(void);
-       ///< Unbonds all devices.
-  bool Bond(cDvbDevice *Device);
-       ///< Bonds this device with the given Device, making both of them use
-       ///< the same satellite cable and LNB. Only DVB-S(2) devices can be
-       ///< bonded. When this function is called, the calling device must
-       ///< not be bonded to any other device. The given Device, however,
-       ///< may already be bonded to an other device. That way several devices
-       ///< can be bonded together.
-       ///< Returns true if the bonding was successful.
-  void UnBond(void);
-       ///< Removes this device from any bonding it might have with other
-       ///< devices. If this device is not bonded with any other device,
-       ///< nothing happens.
-  bool BondingOk(const cChannel *Channel, bool ConsiderOccupied = false) const;
-       ///< Returns true if this device is either not bonded to any other
-       ///< device, or the given Channel is on the same satellite, polarization
-       ///< and band as those the bonded devices are tuned to (if any).
-       ///< If ConsiderOccupied is true, any bonded devices that are currently
-       ///< occupied but not otherwise receiving will cause this function to
-       ///< return false.
-
-// Common Interface facilities:
-
-private:
-  cCiAdapter *ciAdapter;
-
-// Channel facilities
-
-private:
-  cDvbTuner *dvbTuner;
-public:
-  virtual bool ProvidesDeliverySystem(int DeliverySystem) const;
-  virtual bool ProvidesSource(int Source) const;
-  virtual bool ProvidesTransponder(const cChannel *Channel) const;
-  virtual bool ProvidesChannel(const cChannel *Channel, int Priority = IDLEPRIORITY, bool *NeedsDetachReceivers = NULL) const;
-  virtual bool ProvidesEIT(void) const;
-  virtual int NumProvidedSystems(void) const;
-  virtual int SignalStrength(void) const;
-  virtual int SignalQuality(void) const;
-  virtual const cChannel *GetCurrentlyTunedTransponder(void) const;
-  virtual bool IsTunedToTransponder(const cChannel *Channel) const;
-  virtual bool MaySwitchTransponder(const cChannel *Channel) const;
-protected:
-  virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
-public:
-  virtual bool HasLock(int TimeoutMs = 0) const;
-
-// PID handle facilities
-
-protected:
-  virtual bool SetPid(cPidHandle *Handle, int Type, bool On);
-
-// Section filter facilities
-
-protected:
-  virtual int OpenFilter(u_short Pid, u_char Tid, u_char Mask);
-  virtual void CloseFilter(int Handle);
-
-// Common Interface facilities:
-
-public:
-  virtual bool HasCi(void);
-
-// Audio facilities
-
-protected:
-  static int setTransferModeForDolbyDigital;
-public:
-  static void SetTransferModeForDolbyDigital(int Mode); // needs to be here for backwards compatibility
-         ///< Controls how the DVB device handles Transfer Mode when replaying
-         ///< Dolby Digital audio.
-         ///< 0 = don't set "audio bypass" in driver/firmware, don't force Transfer Mode
-         ///< 1 = set "audio bypass" in driver/firmware, force Transfer Mode (default)
-         ///< 2 = don't set "audio bypass" in driver/firmware, force Transfer Mode
-
-// Receiver facilities
-
-private:
-  cTSBuffer *tsBuffer;
-protected:
-  virtual bool OpenDvr(void);
-  virtual void CloseDvr(void);
-  virtual bool GetTSPacket(uchar *&Data);
-  virtual void DetachAllReceivers(void);
-  };
-
-// A plugin that implements a DVB device derived from cDvbDevice needs to create
-// a cDvbDeviceProbe derived object on the heap in order to have its Probe()
-// function called, where it can actually create the appropriate device.
-// The cDvbDeviceProbe object must be created in the plugin's constructor,
-// and deleted in its destructor.
-
-class cDvbDeviceProbe : public cListObject {
-public:
-  cDvbDeviceProbe(void);
-  virtual ~cDvbDeviceProbe();
-  static uint32_t GetSubsystemId(int Adapter, int Frontend);
-  virtual bool Probe(int Adapter, int Frontend) = 0;
-     ///< Probes for a DVB device at the given Adapter and creates the appropriate
-     ///< object derived from cDvbDevice if applicable.
-     ///< Returns true if a device has been created.
-  };
-
-extern cList<cDvbDeviceProbe> DvbDeviceProbes;
-
-#endif //__DVBDEVICE_H
diff -urN vdr-2.0.4-org/dvbplayer.c vdr-2.0.4/dvbplayer.c
--- vdr-2.0.4-org/dvbplayer.c	2013-10-25 09:44:22.452680545 +0200
+++ vdr-2.0.4/dvbplayer.c	2013-10-25 10:07:11.956704053 +0200
@@ -15,6 +15,7 @@
 #include "ringbuffer.h"
 #include "thread.h"
 #include "tools.h"
+#include "menu.h"
 
 // --- cPtsIndex -------------------------------------------------------------
 
@@ -36,6 +37,7 @@
   bool IsEmpty(void);
   void Put(uint32_t Pts, int Index);
   int FindIndex(uint32_t Pts);
+  void SetIndex(int Index) {lastFound = Index;};
   };
 
 cPtsIndex::cPtsIndex(void)
@@ -213,7 +215,8 @@
   cPtsIndex ptsIndex;
   cMarks marks;
   cFileName *fileName;
-  cIndexFile *index;
+  cIndex *index;
+  cIndexFile *indexFile;
   cUnbufferedFile *replayFile;
   double framesPerSecond;
   bool isPesRecording;
@@ -290,7 +293,10 @@
      return;
   ringBuffer = new cRingBufferFrame(PLAYERBUFSIZE);
   // Create the index file:
-  index = new cIndexFile(FileName, false, isPesRecording, pauseLive);
+  indexFile = NULL;
+  index = cRecordControls::GetLiveIndex(FileName);
+  if(!index)
+     index = indexFile = new cIndexFile(FileName, false, isPesRecording, pauseLive);
   if (!index)
      esyslog("ERROR: can't allocate index");
   else if (!index->Ok()) {
@@ -299,6 +305,12 @@
      }
   else if (PauseLive)
      framesPerSecond = cRecording(FileName).FramesPerSecond(); // the fps rate might have changed from the default
+  readIndex = Resume();
+  if (readIndex >= 0) {
+     ptsIndex.SetIndex(readIndex);
+     isyslog("resuming replay at index %d (%s)", readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
+  } else
+     replayFile = fileName->Open();
   marks.Load(FileName, framesPerSecond, isPesRecording);
 }
 
@@ -307,7 +319,7 @@
   Save();
   Detach();
   delete readFrame; // might not have been stored in the buffer in Action()
-  delete index;
+  delete indexFile;
   delete fileName;
   delete ringBuffer;
 }
@@ -489,7 +501,9 @@
                          if (NewIndex <= 0 && readIndex > 0)
                             NewIndex = 1; // make sure the very first frame is delivered
                          NewIndex = index->GetNextIFrame(NewIndex, playDir == pdForward, &FileNumber, &FileOffset, &Length);
-                         if (NewIndex < 0 && TimeShiftMode && playDir == pdForward)
+			if (NewIndex < 0 && TimeShiftMode) // Why should we wait for a timeout if not pdForward
+                            SwitchToPlayFrame = Index;
+			if (NewIndex < 0 && TimeShiftMode && playDir == pdForward)
                             SwitchToPlayFrame = readIndex;
                          Index = NewIndex;
                          readIndependent = true;
@@ -545,6 +559,13 @@
                          total = index->Last();
                       if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent, &Length) && NextFile(FileNumber, FileOffset))
                          readIndex++;
+                      else if(index && index->First() && (readIndex < index->First())) {
+                         int old = readIndex;
+                         readIndex = index->GetNextIFrame(index->First()+1, true, NULL, NULL, NULL);
+                         isyslog("Jump before start of livebuffer cortrected %d->%d First %d", old, readIndex, index->First());
+                         if(readIndex <= index->First())
+                            eof = true;
+                      }
                       else
                          eof = true;
                       }
@@ -691,7 +712,7 @@
              else if (Index <= 0 || SwitchToPlayFrame && Index >= SwitchToPlayFrame)
                 SwitchToPlay = true;
              if (SwitchToPlay) {
-                if (!SwitchToPlayFrame)
+                if (!SwitchToPlayFrame || (playDir == pdBackward))
                    Empty();
                 DevicePlay();
                 playMode = pmPlay;
diff -urN vdr-2.0.4-org/livebuffer.c vdr-2.0.4/livebuffer.c
--- vdr-2.0.4-org/livebuffer.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.4/livebuffer.c	2013-10-25 10:07:11.956704053 +0200
@@ -0,0 +1,401 @@
+#include "livebuffer.h"
+#if VDRVERSNUM >= 10716
+
+#include <vector>
+#include "videodir.h"
+#include "recording.h"
+#include "skins.h"
+#include "player.h"
+
+#define WAIT_WRITING_COUNT 1000
+#define WAIT_WRITING_SLEEP 10000
+
+#define WAIT_TERMINATE_COUNT 300
+#define WAIT_TERMINATE_SLEEP 10000
+
+struct tLiveIndex {
+  int index;
+  uint64_t offset:40; // up to 1TB per file (not using off_t here - must definitely be exactly 64 bit!)
+  int reserved:7;     // reserved for future use
+  int independent:1;  // marks frames that can be displayed by themselves (for trick modes)
+  uint16_t number:16; // up to 64K files per recording
+  tLiveIndex(int Index, bool Independent, uint16_t Number, off_t Offset)
+  {
+    index = Index;
+    offset = Offset;
+    reserved = 0;
+    independent = Independent;
+    number = Number;
+  }
+}; // tLiveIndex
+
+class cLiveIndex : public cIndex {
+public:
+	cLiveIndex(const char *FileName): bufferFileName(FileName, false), bufferBaseName(FileName) {
+		resumePos = -1;
+		lastPos = lastGet = lastBuf = 0;
+		lastFileNumber=1;
+		dropFile = false;
+		maxSize = Setup.LiveBufferSize * 60 * DEFAULTFRAMESPERSECOND;
+		idx.reserve(maxSize+1);
+	}; // cLiveIndex
+	virtual ~cLiveIndex() {
+	}; // ~cLiveIndex
+	virtual bool Write(bool Independent, uint16_t FileNumber, off_t FileOffset) {
+		cMutexLock lock(&idx_lock);
+		idx.push_back(tLiveIndex(++lastPos, Independent, FileNumber, FileOffset));
+		while(((idx.size() > maxSize) && (lastGet ? (lastGet > First()) : true) && (lastBuf ? (lastBuf > First()) : true)) || dropFile) {
+			if(idx.front().number != lastFileNumber) {
+				isyslog("Deleting old livebuffer file #%d (%d)", lastFileNumber, dropFile);
+				system(cString::sprintf("ls -l %s/%05d.ts | grep -- '->' | sed -e's/.*-> //' | xargs rm -rf", (const char *)bufferBaseName, lastFileNumber));  // for symlink video.xx
+				unlink(cString::sprintf("%s/%05d.ts", (const char *)bufferBaseName, lastFileNumber));
+				lastFileNumber = idx.front().number;
+				dropFile=false;
+			} // if
+			idx.erase(idx.begin());
+		} // if
+		return true;
+	}; // Write
+	virtual bool Get(int Index, uint16_t *FileNumber, off_t *FileOffset, bool *Independent = NULL, int *Length = NULL) {
+		cMutexLock lock(&idx_lock);
+		std::vector<tLiveIndex>::iterator item = GetIndex(Index);
+		if(item == idx.end()) return false;
+		*FileNumber = item->number;
+		*FileOffset = item->offset;
+		if (Independent)
+			*Independent = item->independent;
+		item++;
+		if(item == idx.end()) return false;
+		if (Length) {
+			uint16_t fn = item->number;
+			off_t fo = item->offset;
+			if (fn == *FileNumber)
+				*Length = int(fo - *FileOffset);
+			else
+				*Length = -1; // this means "everything up to EOF" (the buffer's Read function will act accordingly)
+		} // if
+		lastGet = Index;
+		return true;
+	}; // Get
+	virtual int GetNextIFrame(int Index, bool Forward, uint16_t *FileNumber = NULL, off_t *FileOffset = NULL, int *Length = NULL) {
+		cMutexLock lock(&idx_lock);
+		std::vector<tLiveIndex>::iterator item = GetIndex(Index);
+		if(item == idx.end()) {
+			if(Index < First() && Forward)
+				item = idx.begin();
+			else
+				return -1;
+		}
+		if(Forward) {
+			do {
+				item++;
+				if(item == idx.end()) return -1;
+			} while(!item->independent);
+		} else {
+			do {
+				if(item == idx.begin()) return -1;
+				item--;
+			} while(!item->independent);
+		} // if
+		uint16_t fn;
+		if (!FileNumber)
+			FileNumber = &fn;
+		off_t fo;
+		if (!FileOffset)
+			FileOffset = &fo;
+		*FileNumber = item->number;
+		*FileOffset = item->offset;
+		item++;
+		if(item == idx.end()) return -1;
+		if (Length) {
+			// all recordings end with a non-independent frame, so the following should be safe:
+			uint16_t fn = item->number;
+			off_t fo = item->offset;
+			if (fn == *FileNumber) {
+				*Length = int(fo - *FileOffset);
+			} else {
+				esyslog("ERROR: 'I' frame at end of file #%d", *FileNumber);
+				*Length = -1;
+			} // if
+		} // if
+		return Index;
+	}; // GetNextIFrame
+	virtual bool SetBufferStart(int Frames) {
+		cMutexLock lock(&idx_lock);
+		abortBuf = false;
+		if(Frames <= 0) {
+			lastBuf = 0;
+			return false;
+		} // if
+		lastBuf = Last()-Frames;
+		if(lastBuf < First())
+			lastBuf = First();
+		lastBuf = GetNextIFrame(lastBuf, true);
+		return true;
+	} // SetBufferStart
+	virtual cUnbufferedFile *GetNextBuffer(int &Length, bool &Independent) {
+		if(abortBuf || !lastBuf) return NULL;
+		cMutexLock lock(&idx_lock);
+		std::vector<tLiveIndex>::iterator buff = GetIndex(lastBuf);
+		if((buff == idx.end()) || ((buff+1) == idx.end())) return NULL;
+		off_t offset = buff->offset;
+		int number   = buff->number;
+		cUnbufferedFile *ret = bufferFileName.SetOffset(number, offset);
+		Independent = buff->independent;
+		buff++;
+		lastBuf = buff->index;
+		if(number != buff->number)
+			Length = -1;
+		else
+			Length = buff->offset-offset;
+		return ret;
+	} // GetNextBuffer
+	virtual int Get(uint16_t FileNumber, off_t FileOffset) {
+		for ( std::vector<tLiveIndex>::iterator item = idx.begin(); item != idx.end(); item++)
+			if (item->number > FileNumber || ((item->number == FileNumber) && off_t(item->offset) >= FileOffset))
+				return item->index;
+		return lastPos;
+	}; // Get
+	virtual bool Ok(void)                    {return true;};
+	virtual int  First(void)                 {return idx.size() ? idx.front().index : -1;};
+	virtual int  Last(void)                  {return idx.size() ? idx.back().index  : -1;};
+	virtual void SetResume(int Index)        {resumePos = lastGet = Index;};
+	virtual int  GetResume(void)             {return resumePos;};
+	virtual bool StoreResume(int Index)      {resumePos=Index; lastGet=0; return true;};
+	virtual bool IsStillRecording(void)      {return true;};
+	virtual void Delete(void)                {};
+	virtual void DropFile(void)              {dropFile=true;};
+	virtual bool IsWritingBuffer(void)       {return lastBuf != 0;};
+	virtual void CancelWritingBuffer(void)   {abortBuf = true;};
+	virtual bool WritingBufferCanceled(void) {return abortBuf;};
+protected:
+	int firstPos;
+	int lastPos;
+	int resumePos;
+	int lastFileNumber;
+	int lastGet;
+	int lastBuf;
+	bool abortBuf;
+	bool dropFile;
+	unsigned int maxSize;
+	cFileName bufferFileName;
+	cString bufferBaseName;
+	cMutex idx_lock;
+	std::vector<tLiveIndex> idx;
+	virtual std::vector<tLiveIndex>::iterator GetIndex(int Index) {
+		if(!idx.size()) return idx.end();
+		std::vector<tLiveIndex>::iterator item = idx.begin();
+
+		unsigned int guess = Index-First(); // Try to guess the position
+		if(guess > 0) {
+			if(guess < idx.size())
+				item += guess;
+			else
+				item = idx.end()-1;
+		} // if
+		while(item->index < Index) {
+			item++;
+			if(item == idx.end())
+				return idx.end();
+		} // while
+		while(item->index > Index) {
+			if(item == idx.begin())
+				return idx.end();
+			item--;
+		} // while
+		if(item->index != Index)
+			return idx.end();
+		return item;
+	}; // GetIndex
+}; // cLiveIndex
+
+/*****************************************************************************/
+
+cString cLiveRecorder::liveFileName;
+
+cLiveRecorder::cLiveRecorder(const cChannel *Channel):cRecorder(FileName(), Channel, -1)
+              ,broken(false) {
+	handleError = false;
+	if(index) delete index;
+	index = new cLiveIndex(FileName());
+	Activate(true);
+}; // cLiveRecorder::cLiveRecorder
+
+cLiveRecorder::~cLiveRecorder() {
+	int maxWait = WAIT_TERMINATE_COUNT;
+	CancelWritingBuffer();
+	while(IsWritingBuffer() && maxWait--)
+		usleep(WAIT_TERMINATE_SLEEP);
+	Activate(false);
+	Cleanup();
+}; // cLiveRecorder::~cLiveRecorder
+
+bool cLiveRecorder::IsWritingBuffer() {
+	return index && ((cLiveIndex *)index)->IsWritingBuffer();
+} // cLiveRecorder::IsWritingBuffer
+
+void cLiveRecorder::CancelWritingBuffer() {
+	if(index) ((cLiveIndex *)index)->CancelWritingBuffer();
+} // cLiveRecorder::CancelWritingBuffer
+
+bool cLiveRecorder::NextFile(void) {
+	if (recordFile && frameDetector->IndependentFrame()) { // every file shall start with an independent frame
+		if(RunningLowOnDiskSpace() && index)
+			((cLiveIndex *)index)->DropFile();
+		if (fileSize > MEGABYTE(off_t(Setup.LiveBufferMaxFileSize)) || RunningLowOnDiskSpace()) {
+			recordFile = fileName->NextFile();
+			fileSize = 0;
+		} // if
+	} // if
+	return recordFile != NULL;
+} // cLiveRecorder::NextFile
+
+int cLiveRecorder::LastIFrame() {
+	if(!index) return 0;
+	int ret = index->GetNextIFrame(index->Last()-1, false);
+	return (ret > 0) ? ret : 0;
+}; // cLiveRecorder::LastIFrame
+
+int cLiveRecorder::LastFrame() { 
+	return index ? index->Last() : 0;
+}; // cLiveRecorder::LastFrame
+
+void cLiveRecorder::SetResume(int Index) { 
+	if(index) ((cLiveIndex *)index)->SetResume(Index);
+}; // cLiveRecorder::SetResume
+
+bool cLiveRecorder::SetBufferStart(time_t Start) {
+	if(!index) return false;
+	if(time(NULL) <= Start) return false;
+	int Frames = SecondsToFrames(time(NULL)-Start, frameDetector ? frameDetector->FramesPerSecond() : DEFAULTFRAMESPERSECOND); //test stop livebuffer 
+	return ((cLiveIndex *)index)->SetBufferStart(Frames);
+} // cLiveRecorder::SetBufferStart
+
+cIndex *cLiveRecorder::GetIndex() { 
+	return index;
+}; // cLiveRecorder::GetIndex
+
+bool cLiveRecorder::Cleanup() {
+	if(FileName()) 
+                if(-1 == system(cString::sprintf("ls -l %s/* 2>/dev/null | grep -- '->' | sed -e's/.*-> //' | xargs rm -rf", FileName()))) // for symlink video.xx
+                        return false;
+        else 
+		if(-1 == system(cString::sprintf("rm -rf %s/* 2>/dev/null", FileName())))
+			return false;
+	return true;
+}; // cLiveRecorder::Cleanup
+
+bool cLiveRecorder::Prepare() {
+	if (!MakeDirs(FileName(), true)) return false;
+	return Cleanup();
+}; // cLiveRecorder::Prepare
+
+const char *cLiveRecorder::FileName() {
+	if(!(const char *)liveFileName && BufferDirectory)
+		liveFileName = cString::sprintf("%s/LiveBuffer", BufferDirectory);
+	return liveFileName;
+}; // cLiveRecorder::FileName
+
+void cLiveRecorder::Activate(bool On) {
+	cRecorder::Activate(On);
+	if(!On) broken=true;
+} // cLiveRecorder::Activate
+
+void cLiveRecorder::Receive(uchar *Data, int Length) {
+	if(broken) {
+		isyslog("Continue live recorder on broken stream (maybe due to switching to same channel on other device)");
+		TsExtendAdaptionField(Data, Length);
+		broken = false;
+	} // if
+	cRecorder::Receive(Data, Length);
+} // cLiveRecorder::Receive
+
+/*****************************************************************************/
+
+cBufferRecorder::cBufferRecorder(const char *FileName, const cChannel *Channel, int Priority, cIndex *LiveBufferIndex)
+                :cRecorder(FileName, Channel, Priority)
+                ,liveBufferIndex(LiveBufferIndex)
+                ,dropData(false) {
+	if(liveBufferIndex) dropData=true; // Drop new data till we have written most of the live buffer data
+} // cBufferRecorder::cBufferRecorder
+
+cBufferRecorder::~cBufferRecorder() {
+	if(liveBufferIndex) ((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+} // cBufferRecorder::~cBufferRecorder
+
+void cBufferRecorder::Action(void) {
+	if(liveBufferIndex)
+		FillInitialData(NULL, 0);
+	dropData=false;
+	cRecorder::Action();
+	if(liveBufferIndex) ((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+	liveBufferIndex = NULL;
+} // cBufferRecorder::Action
+
+void cBufferRecorder::Activate(bool On) {
+	if(!On && liveBufferIndex) ((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+	cRecorder::Activate(On);
+} // cBufferRecorder::Activate
+
+void cBufferRecorder::Receive(uchar *Data, int Length) {
+	if(!dropData) cRecorder::Receive(Data, Length);
+} // cBufferRecorder::Receive
+
+void cBufferRecorder::FillInitialData(uchar *Data, int Size) {
+	if(liveBufferIndex) {
+		int64_t search_pts = Data ? TsGetPts(Data, Size) : -1;
+		int maxWait = WAIT_WRITING_COUNT;
+		uchar buffer[MAXFRAMESIZE];
+		int Length;
+		bool Independent;
+		bool found = false;
+		while(!Data || (Size >= TS_SIZE)) {
+			cUnbufferedFile *file = ((cLiveIndex *)liveBufferIndex)->GetNextBuffer(Length, Independent);
+			if(!file) {
+				if(((cLiveIndex *)liveBufferIndex)->WritingBufferCanceled()) {
+					isyslog("Writing buffer canceled by user");
+					if(fileSize) TsExtendAdaptionField(Data, Size);
+					((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+					liveBufferIndex = NULL;
+					return;
+				} // if
+				if(!Data || !Size) return;
+				if(!maxWait--)
+					break;
+				usleep(WAIT_WRITING_SLEEP);
+				continue;
+			} // if
+			if (!NextFile())
+				break;
+			int len = ReadFrame(file, buffer, Length, sizeof(buffer));
+			if(len < TS_SIZE) {
+				isyslog("Failed to read live buffer data");
+				break;
+			} // if
+			if(Data && Independent && (search_pts == TsGetPts(buffer, len))) {
+				found = true;
+				break;
+			} // if
+			if (index)
+				index->Write(Independent, fileName->Number(), fileSize);
+			if (recordFile->Write(buffer, len) < 0) {
+				isyslog("Failed to write live buffer data");
+				break;
+			} // if
+			fileSize += len;
+		} // while
+		if(Data) {
+			isyslog("%lld bytes from live buffer %swritten to recording", fileSize, found ? "seamless ": "");
+			if(!found && fileSize) TsExtendAdaptionField(Data, Size);
+			((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+			liveBufferIndex = NULL;
+		} else if(((cLiveIndex *)liveBufferIndex)->WritingBufferCanceled()) {
+			isyslog("%lld bytes from live buffer written to recording (aborted)", fileSize);
+			((cLiveIndex *)liveBufferIndex)->SetBufferStart(0);
+			liveBufferIndex = NULL;
+		} // if
+	} else if (Data && fileSize)
+		TsExtendAdaptionField(Data, Size);
+} // cBufferRecorder::FillInitialData
+
+#endif /*VDRVERSNUM*/
diff -urN vdr-2.0.4-org/livebuffer.h vdr-2.0.4/livebuffer.h
--- vdr-2.0.4-org/livebuffer.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.0.4/livebuffer.h	2013-10-25 10:07:11.956704053 +0200
@@ -0,0 +1,45 @@
+#ifndef LIVEBUFFER_H
+#define LIVEBUFFER_H
+
+#include "config.h"
+//#if VDRVERSNUM >= 10716
+
+#include "recorder.h"
+
+class cLiveRecorder : public cRecorder {
+public:
+	cLiveRecorder(const cChannel *Channel);
+	virtual bool NextFile(void);
+	virtual ~cLiveRecorder();
+	virtual bool IsWritingBuffer();
+	virtual void CancelWritingBuffer();
+	virtual int LastIFrame();
+	virtual int LastFrame();
+	virtual void SetResume(int Index);
+	virtual bool SetBufferStart(time_t Start);
+	virtual cIndex *GetIndex();
+	static bool Cleanup();
+	static bool Prepare();
+	static const char *FileName();
+protected:
+	virtual void Activate(bool On);
+	virtual void Receive(uchar *Data, int Length);
+	bool broken;
+	static cString liveFileName;
+}; // cLiveRecorder
+
+class cBufferRecorder : public cRecorder {
+public:
+	cBufferRecorder(const char *FileName, const cChannel *Channel, int Priority, cIndex *LiveBufferIndex);
+	virtual ~cBufferRecorder();
+	virtual void FillInitialData(uchar *Data, int Size);
+protected:
+	virtual void Action(void);
+	virtual void Activate(bool On);
+	virtual void Receive(uchar *Data, int Length);
+	cIndex *liveBufferIndex;
+	bool dropData;
+}; // cBufferRecorder
+
+//#endif /*VDRVERSNUM*/
+#endif /*LIVEBUFFER_H*/
diff -urN vdr-2.0.4-org/Makefile vdr-2.0.4/Makefile
--- vdr-2.0.4-org/Makefile	2013-10-25 09:44:22.468680545 +0200
+++ vdr-2.0.4/Makefile	2013-10-25 10:07:11.956704053 +0200
@@ -97,6 +97,11 @@
 LIBS += $(shell pkg-config --libs fribidi)
 endif
 
+ifdef LIVEBUFFER
+DEFINES += -DUSE_LIVEBUFFER
+OBJS += livebuffer.o
+endif
+
 LIRC_DEVICE ?= /var/run/lirc/lircd
 
 DEFINES += -DLIRC_DEVICE=\"$(LIRC_DEVICE)\"
diff -urN vdr-2.0.4-org/menu.c vdr-2.0.4/menu.c
--- vdr-2.0.4-org/menu.c	2013-10-25 09:44:22.080680539 +0200
+++ vdr-2.0.4/menu.c	2013-10-25 10:10:52.448707838 +0200
@@ -3349,7 +3349,7 @@
 
 class cMenuSetupRecord : public cMenuSetupBase {
 private:
-  const char *pauseKeyHandlingTexts[3];
+  const char *pauseKeyHandlingTexts[4];
   const char *delTimeshiftRecTexts[3];
 public:
   cMenuSetupRecord(void);
@@ -3361,6 +3361,7 @@
   pauseKeyHandlingTexts[0] = tr("do not pause live video");
   pauseKeyHandlingTexts[1] = tr("confirm pause live video");
   pauseKeyHandlingTexts[2] = tr("pause live video");
+  pauseKeyHandlingTexts[3] = tr("Timeshift");
   delTimeshiftRecTexts[0] = tr("no");
   delTimeshiftRecTexts[1] = tr("confirm");
   delTimeshiftRecTexts[2] = tr("yes");
@@ -3369,7 +3370,8 @@
   Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at stop (min)"),      &data.MarginStop));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Default priority"),          &data.DefaultPriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Default lifetime (d)"),      &data.DefaultLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
+  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 4, pauseKeyHandlingTexts));
+  Add(new cMenuEditIntItem( tr("Timeshift size (min)"),                     &data.LiveBufferSize, 1, 300)); // TODO fix name and min/max values
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
@@ -4586,7 +4588,7 @@
   isyslog("record %s", fileName);
   if (MakeDirs(fileName, true)) {
      const cChannel *ch = timer->Channel();
-     recorder = new cRecorder(fileName, ch, timer->Priority());
+     recorder = new cBufferRecorder(fileName, ch, timer->Priority(), cRecordControls::GetLiveBuffer(timer));
      if (device->AttachReceiver(recorder)) {
         Recording.WriteInfo();
         cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
@@ -4685,6 +4687,8 @@
 cRecordControl *cRecordControls::RecordControls[MAXRECORDCONTROLS] = { NULL };
 int cRecordControls::state = 0;
 
+cLiveRecorder *cRecordControls::liveRecorder = NULL;
+
 bool cRecordControls::Start(cTimer *Timer, bool Pause, bool* reused)
 {
   if (!Timer) {
@@ -4847,8 +4851,27 @@
   return false;
 }
 
+
+bool cRecordControls::StartLiveBuffer(eKeys Key) {
+   if(Setup.PauseKeyHandling == 3 && liveRecorder) {
+     int pos = liveRecorder->LastIFrame();
+     isyslog("Enter timeshift at %d / %d", pos, liveRecorder->LastFrame());
+     liveRecorder->SetResume(pos?pos:liveRecorder->LastFrame());
+     cReplayControl::SetRecording(cLiveRecorder::FileName());
+     cReplayControl *rc = new cReplayControl;
+     cControl::Launch(rc);
+     cControl::Attach();
+     rc->ProcessKey(Key);
+     rc->Show(); // show progressbar at the start of livebuffer
+     return true;
+  } // if
+  return false;
+} // cRecordControls::StartLiveBuffer
+
 bool cRecordControls::PauseLiveVideo(void)
 {
+  if(StartLiveBuffer(kPause))
+     return true;
   Skins.Message(mtStatus, tr("Pausing live video..."));
   bool reused = false;
   cReplayControl::SetRecording(NULL); // make sure the new cRecordControl will set cReplayControl::LastReplayed()
@@ -4863,6 +4886,51 @@
   return false;
 }
 
+void cRecordControls::SetLiveChannel(cDevice *Device, const cChannel *Channel) {
+	if(liveRecorder) {
+		if(Channel && Device && (liveRecorder->ChannelID()==Channel->GetChannelID()))
+			Device->AttachReceiver(liveRecorder);
+		else
+			DELETENULL(liveRecorder);
+	} // if
+	if(Device && Channel) cControl::Launch(new cTransferControl(Device, Channel));
+	if(Setup.PauseKeyHandling == 3 && Channel && Device && !liveRecorder) { 
+		if (cLiveRecorder::Prepare()) {
+			liveRecorder = new cLiveRecorder(Channel);
+			if(!Device->AttachReceiver(liveRecorder))
+				DELETENULL(liveRecorder);
+		} // if
+	} // if
+} // cRecordControls::SetLiveChannel
+
+bool cRecordControls::CanSetLiveChannel(const cChannel *Channel) {
+	if(liveRecorder && Channel && (liveRecorder->ChannelID()==Channel->GetChannelID())) return true;
+	return !IsWritingBuffer();
+} // cRecordControls::CanSetLiveChannel
+
+bool cRecordControls::IsWritingBuffer() {
+	return liveRecorder ? liveRecorder->IsWritingBuffer() : false;
+} // cRecordControls::IsWritingBuffer
+
+void cRecordControls::CancelWritingBuffer() {
+	if(liveRecorder && liveRecorder->IsWritingBuffer()) {
+		liveRecorder->CancelWritingBuffer();
+		sleep(1); // allow recorder to really stop
+	} // if
+} // cRecordControls::CancelWritingBuffer
+
+cIndex *cRecordControls::GetLiveBuffer(cTimer *Timer) {
+	if(!liveRecorder || !Timer || !Timer->Channel()) return NULL;
+	if(!(liveRecorder->ChannelID() == Timer->Channel()->GetChannelID())) return NULL;
+	if(!liveRecorder->SetBufferStart(Timer->StartTime())) return NULL;
+	return liveRecorder->GetIndex();
+} // cRecordControls::GetLiveBuffer
+
+cIndex *cRecordControls::GetLiveIndex(const char *FileName) {
+	if(!FileName || strcmp(cLiveRecorder::FileName(), FileName)) return NULL;
+	return liveRecorder ? liveRecorder->GetIndex() : NULL;
+} // cRecordControls::GetLiveIndex
+
 const char *cRecordControls::GetInstantId(const char *LastInstantId)
 {
   for (int i = 0; i < MAXRECORDCONTROLS; i++) {
@@ -5103,21 +5171,30 @@
 
 void cReplayControl::ShowMode(void)
 {
-  if (visible || Setup.ShowReplayMode && !cOsd::IsOpen()) {
+  if (visible || (Setup.ShowReplayMode && !cOsd::IsOpen())) {
      bool Play, Forward;
      int Speed;
      if (GetReplayMode(Play, Forward, Speed) && (!visible || Play != lastPlay || Forward != lastForward || Speed != lastSpeed)) {
         bool NormalPlay = (Play && Speed == -1);
+        bool Paused = (!Play && Speed == -1);
 
         if (!visible) {
            if (NormalPlay)
               return; // no need to do indicate ">" unless there was a different mode displayed before
            visible = modeOnly = true;
+
+           // if newly paused show full replay osd; ie modeOnly = false
+           if (Paused)  {
+               modeOnly = (lastPlay == Play);
+           }
+
            displayReplay = Skins.Current()->DisplayReplay(modeOnly);
            }
 
-        if (modeOnly && !timeoutShow && NormalPlay)
+        // osd times out when replaying normally OR when paused and full osd is shown
+        if (!timeoutShow && (NormalPlay|| (!modeOnly && Paused)))
            timeoutShow = time(NULL) + MODETIMEOUT;
+
         displayReplay->SetMode(Play, Forward, Speed);
         lastPlay = Play;
         lastForward = Forward;
@@ -5131,6 +5208,43 @@
   int Current, Total;
 
   if (GetIndex(Current, Total) && Total > 0) {
+     int first=0;
+     cIndex *idx = cRecordControls::GetLiveIndex(fileName);
+     if(idx) first = idx->First(); // Normalize displayed values
+     Current -= first;
+     if(Current < 0) Current = 0;
+     Total   -= first;
+     if(Total < 0) Total = 0;
+     time_t now = time(NULL);
+     static time_t last_sched_check = 0;
+     if(displayReplay && idx && (last_sched_check != now)) {
+        last_sched_check = now; // Only check every second
+        cSchedulesLock SchedulesLock;
+        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
+        if (Schedules) {
+           const char *display_title = NULL;// = title;
+           const cSchedule *Schedule = Schedules->GetSchedule(Channels.GetByNumber(cDevice::CurrentChannel()));
+           if (Schedule) {
+              time_t Time = now - round(((double)Total - Current) / FramesPerSecond());
+              const cEvent *event = Schedule->GetEventAround(Time);
+              if (event) display_title = event->Title();
+           } // if
+
+           // no event title; show channel name
+           if (!display_title) {
+               cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
+               display_title = channel->Name();
+           }
+
+           // set title as "Timeshift mode: <event title> "
+           // OR "Timeshift mode: <channel name>"
+           // if neither is possible leave title as such
+           if (display_title)
+               displayReplay->SetTitle(cString::sprintf("%s: %s",
+                                                        tr("Timeshift mode"),
+                                                        display_title));
+        } // if
+     } // if
      if (!visible) {
         displayReplay = Skins.Current()->DisplayReplay(modeOnly);
         displayReplay->SetMarks(&marks);
@@ -5240,6 +5354,11 @@
 
 void cReplayControl::TimeSearch(void)
 {
+	if (cRecordControls::GetLiveIndex(fileName)) {
+       if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+          return;
+       }
+    }
   timeSearchTime = timeSearchPos = 0;
   timeSearchHide = false;
   if (modeOnly)
@@ -5258,6 +5377,11 @@
 
 void cReplayControl::MarkToggle(void)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) { 
+     	return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total, true)) {
      lastCurrent = -1; // triggers redisplay
@@ -5279,6 +5403,11 @@
 
 void cReplayControl::MarkJump(bool Forward)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total)) {
      if (marks.Count()) {
@@ -5305,6 +5434,11 @@
 
 void cReplayControl::MarkMove(bool Forward)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total)) {
      if (cMark *m = marks.Get(Current)) {
@@ -5328,6 +5462,11 @@
 
 void cReplayControl::EditCut(void)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return;
+     }
+  }
   if (*fileName) {
      Hide();
      if (!cCutter::Active()) {
@@ -5348,6 +5487,11 @@
 
 void cReplayControl::EditTest(void)
 {
+  if (cRecordControls::GetLiveIndex(fileName)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+   	    return;
+     }
+  }
   int Current, Total;
   if (GetIndex(Current, Total)) {
      cMark *m = marks.Get(Current);
@@ -5386,7 +5530,14 @@
   if (Key == kNone && !marksModified)
      marks.Update();
   if (visible) {
+
+      if (Key != kNone /*&& !modeOnly*/ && timeoutShow) {
+          printf("timeout reset +%d\n", MODETIMEOUT);
+          timeoutShow = time(NULL) + MODETIMEOUT;
+      }
+
      if (timeoutShow && time(NULL) > timeoutShow) {
+         printf("timed out \n");
         Hide();
         ShowMode();
         timeoutShow = 0;
@@ -5412,12 +5563,17 @@
         Key = Play ? kPause : kPlay;
      }
   bool DoShowMode = true;
+  if (cRecordControls::GetLiveIndex(fileName) && (Key >= k0) && (Key <= k9)) {
+     if (Interface->Confirm(tr("Interrompere il Timeshift?"))) {
+        return osSwitchChannel;
+     }
+  }
   switch (int(Key)) {
     // Positioning:
-    case kPlay:
     case kUp:      Play(); break;
-    case kPause:
+    case kPlay:    Play(); break;
     case kDown:    Pause(); break;
+    case kPause:   Pause(); break;
     case kFastRew|k_Release:
     case kLeft|k_Release:
                    if (Setup.MultiSpeedMode) break;
@@ -5428,14 +5584,67 @@
                    if (Setup.MultiSpeedMode) break;
     case kFastFwd:
     case kRight:   Forward(); break;
-    case kRed:     TimeSearch(); break;
+    //case kRed:     TimeSearch(); break;
+        case kRed:     if(cRecordControls::GetLiveIndex(fileName)) {
+                           if (!(visible && !modeOnly)) return osUnknown;
+                           else {} // fall through to case kRecord
+                                   // since Timeshift ON and replay OSD is shown
+                           } // if
+                           else { //timeshift off
+                               TimeSearch();
+                               break;
+                           } // else
+                           // No break
+        case kRecord:  if(cRecordControls::GetLiveIndex(fileName)) {
+                          int frames = 0;
+                          int Current, Total;
+                          if(GetIndex(Current, Total))
+                             frames = Total-Current;
+                          cTimer *timer = new cTimer(true, false, Channels.GetByNumber(cDevice::CurrentChannel()), frames / FramesPerSecond());
+                          Timers.Add(timer);
+                          Timers.SetModified();
+                          if (cRecordControls::Start(timer))
+                             Skins.Message(mtInfo, tr("Recording started"));
+                          else
+                             Timers.Del(timer);
+                       } // if
+                       break;
+        case kPrev|k_Repeat:
+        case kPrev:    if (lastSkipTimeout.TimedOut()) {
+                          lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                          lastSkipKey = kPrev;
+                       }
+                       else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                          lastSkipSeconds /= 2;
+                          lastSkipKey = kNone;
+                       }
+                       lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                       SkipSeconds(-lastSkipSeconds); break;
+        case kNext|k_Repeat:
+        case kNext:    if (lastSkipTimeout.TimedOut()) {
+                          lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                          lastSkipKey = kNext;
+                       }
+                       else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                          lastSkipSeconds /= 2;
+                          lastSkipKey = kNone;
+                       }
+                       lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                       SkipSeconds(lastSkipSeconds); break;
+        case kBlue:    if(cRecordControls::GetLiveIndex(fileName))
+                           if(!(visible && !modeOnly))
+                               return osUnknown;
+                       //NO break
+        case kStop:    Hide();
+                       Stop();
+                       return osEnd;
     case kGreen|k_Repeat:
                    SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
     case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
     case kYellow|k_Repeat:
                    SkipSeconds(Setup.JumpSecondsRepeat); break;
     case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
-    case kPrev|k_Repeat:
+/*    case kPrev|k_Repeat:
     case kPrev:    if (lastSkipTimeout.TimedOut()) {
                       lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
                       lastSkipKey = kPrev;
@@ -5461,6 +5670,7 @@
     case kBlue:    Hide();
                    Stop();
                    return osEnd;
+*/
     default: {
       bool play, forward;
       int speed;
@@ -5523,9 +5733,22 @@
                            else
                               Show();
                            break;
-            case kBack:    Hide();
-                           Stop();
+            //case kBack:    Hide();
+            //               Stop();
+            case kBack:
+                           if (visible && !modeOnly) {
+                              Hide();
+                              DoShowMode = true;
+                              break;
+                           }
+                           if(cRecordControls::GetLiveIndex(fileName)) {
+                              Hide();
+                              Stop();
+                              return osEnd;
+                           } // if
+                           if (Setup.DelTimeshiftRec) {
                            return osRecordings;
+			    }
             default:       return osUnknown;
             }
           }
diff -urN vdr-2.0.4-org/menu.c.orig vdr-2.0.4/menu.c.orig
--- vdr-2.0.4-org/menu.c.orig	2013-10-25 09:44:22.080680539 +0200
+++ vdr-2.0.4/menu.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,5546 +0,0 @@
-/*
- * menu.c: The actual menu implementations
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: menu.c 2.82.1.5 2013/10/16 09:46:24 kls Exp $
- */
-
-#include "menu.h"
-#include "iconpatch.h"
-#include <ctype.h>
-#include <limits.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "channels.h"
-#include "config.h"
-#include "cutter.h"
-#include "eitscan.h"
-#include "filetransfer.h"
-#include "i18n.h"
-#include "interface.h"
-#include "plugin.h"
-#include "recording.h"
-#include "remote.h"
-#include "shutdown.h"
-#include "sourceparams.h"
-#include "sources.h"
-#include "status.h"
-#include "themes.h"
-#include "timers.h"
-#include "transfer.h"
-#include "videodir.h"
-#include "menuorgpatch.h"
-
-#include "remotetimers.h"
-
-#define MAXWAIT4EPGINFO   3 // seconds
-#define MODETIMEOUT       3 // seconds
-#define NEWTIMERLIMIT   120 // seconds until the start time of a new timer created from the Schedule menu,
-                            // within which it will go directly into the "Edit timer" menu to allow
-                            // further parameter settings
-#define DEFERTIMER       60 // seconds by which a timer is deferred in case of problems
-
-#define MAXRECORDCONTROLS (MAXDEVICES * MAXRECEIVERS)
-#define MAXINSTANTRECTIME (24 * 60 - 1) // 23:59 hours
-#define MAXWAITFORCAMMENU  10 // seconds to wait for the CAM menu to open
-#define CAMMENURETYTIMEOUT  3 // seconds after which opening the CAM menu is retried
-#define CAMRESPONSETIMEOUT  5 // seconds to wait for a response from a CAM
-#define MINFREEDISK       300 // minimum free disk space (in MB) required to start recording
-#define NODISKSPACEDELTA  300 // seconds between "Not enough disk space to start recording!" messages
-#define MAXCHNAMWIDTH      16 // maximum number of characters of channels' short names shown in schedules menus
-
-#define CHNUMWIDTH  (numdigits(Channels.MaxNumber()) + 1)
-#define CHNAMWIDTH  (min(MAXCHNAMWIDTH, Channels.MaxShortChannelNameLength() + 1))
-
-// --- cMenuEditCaItem -------------------------------------------------------
-
-class cMenuEditCaItem : public cMenuEditIntItem {
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditCaItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditCaItem::cMenuEditCaItem(const char *Name, int *Value)
-:cMenuEditIntItem(Name, Value, 0)
-{
-  Set();
-}
-
-void cMenuEditCaItem::Set(void)
-{
-  if (*value == CA_FTA)
-     SetValue(tr("Free To Air"));
-  else if (*value >= CA_ENCRYPTED_MIN)
-     SetValue(tr("encrypted"));
-  else
-     cMenuEditIntItem::Set();
-}
-
-eOSState cMenuEditCaItem::ProcessKey(eKeys Key)
-{
-  eOSState state = cMenuEditItem::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     if (NORMALKEY(Key) == kLeft && *value >= CA_ENCRYPTED_MIN)
-        *value = CA_FTA;
-     else
-        return cMenuEditIntItem::ProcessKey(Key);
-     Set();
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cMenuEditSrcItem ------------------------------------------------------
-
-class cMenuEditSrcItem : public cMenuEditIntItem {
-private:
-  const cSource *source;
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditSrcItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditSrcItem::cMenuEditSrcItem(const char *Name, int *Value)
-:cMenuEditIntItem(Name, Value, 0)
-{
-  source = Sources.Get(*Value);
-  Set();
-}
-
-void cMenuEditSrcItem::Set(void)
-{
-  if (source)
-     SetValue(cString::sprintf("%s - %s", *cSource::ToString(source->Code()), source->Description()));
-  else
-     cMenuEditIntItem::Set();
-}
-
-eOSState cMenuEditSrcItem::ProcessKey(eKeys Key)
-{
-  eOSState state = cMenuEditItem::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     bool IsRepeat = Key & k_Repeat;
-     Key = NORMALKEY(Key);
-     if (Key == kLeft) { // TODO might want to increase the delta if repeated quickly?
-        if (source) {
-           if (source->Prev())
-              source = (cSource *)source->Prev();
-           else if (!IsRepeat)
-              source = Sources.Last();
-           *value = source->Code();
-           }
-        }
-     else if (Key == kRight) {
-        if (source) {
-           if (source->Next())
-              source = (cSource *)source->Next();
-           else if (!IsRepeat)
-              source = Sources.First();
-           }
-        else
-           source = Sources.First();
-        if (source)
-           *value = source->Code();
-        }
-     else
-        return state; // we don't call cMenuEditIntItem::ProcessKey(Key) here since we don't accept numerical input
-     Set();
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cMenuEditChannel ------------------------------------------------------
-
-class cMenuEditChannel : public cOsdMenu {
-private:
-  cChannel *channel;
-  cChannel data;
-  cSourceParam *sourceParam;
-  char name[256];
-  void Setup(void);
-public:
-  cMenuEditChannel(cChannel *Channel, bool New = false);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuEditChannel"; }
-  };
-
-cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
-:cOsdMenu(tr("Edit channel"), 16)
-{
-  SetMenuCategory(mcChannelEdit);
-  channel = Channel;
-  sourceParam = NULL;
-  *name = 0;
-  if (channel) {
-     data = *channel;
-     strn0cpy(name, data.name, sizeof(name));
-     if (New) {
-        channel = NULL;
-        data.nid = 0;
-        data.tid = 0;
-        data.rid = 0;
-        }
-     }
-  Setup();
-}
-
-void cMenuEditChannel::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  // Parameters for all types of sources:
-  Add(new cMenuEditStrItem( tr("Name"),          name, sizeof(name)));
-  Add(new cMenuEditSrcItem( tr("Source"),       &data.source));
-  Add(new cMenuEditIntItem( tr("Frequency"),    &data.frequency));
-  Add(new cMenuEditIntItem( tr("Vpid"),         &data.vpid,  0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Ppid"),         &data.ppid,  0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Apid1"),        &data.apids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Apid2"),        &data.apids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Dpid1"),        &data.dpids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Dpid2"),        &data.dpids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Spid1"),        &data.spids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Spid2"),        &data.spids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Tpid"),         &data.tpid,  0, 0x1FFF));
-  Add(new cMenuEditCaItem(  tr("CA"),           &data.caids[0]));
-  Add(new cMenuEditIntItem( tr("Sid"),          &data.sid, 1, 0xFFFF));
-  /* XXX not yet used
-  Add(new cMenuEditIntItem( tr("Nid"),          &data.nid, 0));
-  Add(new cMenuEditIntItem( tr("Tid"),          &data.tid, 0));
-  Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0));
-  XXX*/
-  // Parameters for specific types of sources:
-  sourceParam = SourceParams.Get(**cSource::ToString(data.source));
-  if (sourceParam) {
-     sourceParam->SetData(&data);
-     cOsdItem *Item;
-     while ((Item = sourceParam->GetOsdItem()) != NULL)
-           Add(Item);
-     }
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuEditChannel::ProcessKey(eKeys Key)
-{
-  int oldSource = data.source;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     if (Key == kOk) {
-        if (sourceParam)
-           sourceParam->GetData(&data);
-        if (Channels.HasUniqueChannelID(&data, channel)) {
-           data.name = strcpyrealloc(data.name, name);
-           if (channel) {
-              *channel = data;
-              isyslog("edited channel %d %s", channel->Number(), *data.ToText());
-              state = osBack;
-              }
-           else {
-              channel = new cChannel;
-              *channel = data;
-              Channels.Add(channel);
-              Channels.ReNumber();
-              isyslog("added channel %d %s", channel->Number(), *data.ToText());
-              state = osUser1;
-              }
-           Channels.SetModified(true);
-           }
-        else {
-           Skins.Message(mtError, tr("Channel settings are not unique!"));
-           state = osContinue;
-           }
-        }
-     }
-  if (Key != kNone && (data.source & cSource::st_Mask) != (oldSource & cSource::st_Mask)) {
-     if (sourceParam)
-        sourceParam->GetData(&data);
-     Setup();
-     }
-  return state;
-}
-
-// --- cMenuChannelItem ------------------------------------------------------
-
-class cMenuChannelItem : public cOsdItem {
-public:
-  enum eChannelSortMode { csmNumber, csmName, csmProvider };
-private:
-  static eChannelSortMode sortMode;
-  cChannel *channel;
-public:
-  cMenuChannelItem(cChannel *Channel);
-  static void SetSortMode(eChannelSortMode SortMode) { sortMode = SortMode; }
-  static void IncSortMode(void) { sortMode = eChannelSortMode((sortMode == csmProvider) ? csmNumber : sortMode + 1); }
-  static eChannelSortMode SortMode(void) { return sortMode; }
-  virtual int Compare(const cListObject &ListObject) const;
-  virtual void Set(void);
-  cChannel *Channel(void) { return channel; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuChannelItem::eChannelSortMode cMenuChannelItem::sortMode = csmNumber;
-
-cMenuChannelItem::cMenuChannelItem(cChannel *Channel)
-{
-  channel = Channel;
-  if (channel->GroupSep())
-     SetSelectable(false);
-  Set();
-}
-
-int cMenuChannelItem::Compare(const cListObject &ListObject) const
-{
-  cMenuChannelItem *p = (cMenuChannelItem *)&ListObject;
-  int r = -1;
-  if (sortMode == csmProvider)
-     r = strcoll(channel->Provider(), p->channel->Provider());
-  if (sortMode == csmName || r == 0)
-     r = strcoll(channel->Name(), p->channel->Name());
-  if (sortMode == csmNumber || r == 0)
-     r = channel->Number() - p->channel->Number();
-  return r;
-}
-
-void cMenuChannelItem::Set(void)
-{
-  cString buffer;
-  if (!channel->GroupSep()) {
-     if (sortMode == csmProvider)
-        buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
-        else if (Setup.WarEagleIcons) {
-           if (channel->Vpid() == 1 || channel->Vpid() == 0)
-              buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_RADIO_UTF8 : ICON_RADIO, channel->Name());
-           else if (channel->Ca() == 0)
-              buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_UTF8 : ICON_TV, channel->Name());
-        else
-           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_CRYPTED_UTF8 : ICON_TV_CRYPTED, channel->Name());
-        }
-     else
-        buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
-     }
-  else
-     buffer = cString::sprintf("---\t%s ----------------------------------------------------------------", channel->Name());
-  SetText(buffer);
-}
-
-void cMenuChannelItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemChannel(channel, Index, Current, Selectable, sortMode == csmProvider))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuChannels ---------------------------------------------------------
-
-#define CHANNELNUMBERTIMEOUT 1000 //ms
-
-class cMenuChannels : public cOsdMenu {
-private:
-  int number;
-  cTimeMs numberTimer;
-  void Setup(void);
-  cChannel *GetChannel(int Index);
-  void Propagate(void);
-protected:
-  eOSState Number(eKeys Key);
-  eOSState Switch(void);
-  eOSState Edit(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  virtual void Move(int From, int To);
-public:
-  cMenuChannels(void);
-  ~cMenuChannels();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuChannels"; }
-  };
-
-cMenuChannels::cMenuChannels(void)
-:cOsdMenu(tr("Channels"), CHNUMWIDTH)
-{
-  SetMenuCategory(mcChannel);
-  number = 0;
-  Setup();
-  Channels.IncBeingEdited();
-}
-
-cMenuChannels::~cMenuChannels()
-{
-  Channels.DecBeingEdited();
-}
-
-void cMenuChannels::Setup(void)
-{
-  cChannel *currentChannel = GetChannel(Current());
-  if (!currentChannel)
-     currentChannel = Channels.GetByNumber(cDevice::CurrentChannel());
-  cMenuChannelItem *currentItem = NULL;
-  Clear();
-  for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
-      if (!channel->GroupSep() || cMenuChannelItem::SortMode() == cMenuChannelItem::csmNumber && *channel->Name()) {
-         cMenuChannelItem *item = new cMenuChannelItem(channel);
-         Add(item);
-         if (channel == currentChannel)
-            currentItem = item;
-         }
-      }
-  if (cMenuChannelItem::SortMode() != cMenuChannelItem::csmNumber)
-     Sort();
-  SetCurrent(currentItem);
-  SetHelp(tr("Button$Edit"), tr("Button$New"), tr("Button$Delete"), tr("Button$Mark"));
-  Display();
-}
-
-cChannel *cMenuChannels::GetChannel(int Index)
-{
-  cMenuChannelItem *p = (cMenuChannelItem *)Get(Index);
-  return p ? (cChannel *)p->Channel() : NULL;
-}
-
-void cMenuChannels::Propagate(void)
-{
-  Channels.ReNumber();
-  for (cMenuChannelItem *ci = (cMenuChannelItem *)First(); ci; ci = (cMenuChannelItem *)ci->Next())
-      ci->Set();
-  Display();
-  Channels.SetModified(true);
-}
-
-eOSState cMenuChannels::Number(eKeys Key)
-{
-  if (HasSubMenu())
-     return osContinue;
-  if (numberTimer.TimedOut())
-     number = 0;
-  if (!number && Key == k0) {
-     cMenuChannelItem::IncSortMode();
-     Setup();
-     }
-  else {
-     number = number * 10 + Key - k0;
-     for (cMenuChannelItem *ci = (cMenuChannelItem *)First(); ci; ci = (cMenuChannelItem *)ci->Next()) {
-         if (!ci->Channel()->GroupSep() && ci->Channel()->Number() == number) {
-            SetCurrent(ci);
-            Display();
-            break;
-            }
-         }
-     numberTimer.Set(CHANNELNUMBERTIMEOUT);
-     }
-  return osContinue;
-}
-
-eOSState cMenuChannels::Switch(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  cChannel *ch = GetChannel(Current());
-  if (ch)
-     return cDevice::PrimaryDevice()->SwitchChannel(ch, true) ? osEnd : osContinue;
-  return osEnd;
-}
-
-eOSState cMenuChannels::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cChannel *ch = GetChannel(Current());
-  if (ch)
-     return AddSubMenu(new cMenuEditChannel(ch));
-  return osContinue;
-}
-
-eOSState cMenuChannels::New(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  return AddSubMenu(new cMenuEditChannel(GetChannel(Current()), true));
-}
-
-eOSState cMenuChannels::Delete(void)
-{
-  if (!HasSubMenu() && Count() > 0) {
-     int CurrentChannelNr = cDevice::CurrentChannel();
-     cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-     int Index = Current();
-     cChannel *channel = GetChannel(Current());
-     int DeletedChannel = channel->Number();
-     // Check if there is a timer using this channel:
-     if (channel->HasTimer()) {
-        Skins.Message(mtError, tr("Channel is being used by a timer!"));
-        return osContinue;
-        }
-     if (Interface->Confirm(tr("Delete channel?"))) {
-        if (CurrentChannel && channel == CurrentChannel) {
-           int n = Channels.GetNextNormal(CurrentChannel->Index());
-           if (n < 0)
-              n = Channels.GetPrevNormal(CurrentChannel->Index());
-           CurrentChannel = Channels.Get(n);
-           CurrentChannelNr = 0; // triggers channel switch below
-           }
-        Channels.Del(channel);
-        cOsdMenu::Del(Index);
-        Propagate();
-        Channels.SetModified(true);
-        isyslog("channel %d deleted", DeletedChannel);
-        if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-           if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-              Channels.SwitchTo(CurrentChannel->Number());
-           else
-              cDevice::SetCurrentChannel(CurrentChannel);
-           }
-        }
-     }
-  return osContinue;
-}
-
-void cMenuChannels::Move(int From, int To)
-{
-  int CurrentChannelNr = cDevice::CurrentChannel();
-  cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-  cChannel *FromChannel = GetChannel(From);
-  cChannel *ToChannel = GetChannel(To);
-  if (FromChannel && ToChannel) {
-     int FromNumber = FromChannel->Number();
-     int ToNumber = ToChannel->Number();
-     Channels.Move(FromChannel, ToChannel);
-     cOsdMenu::Move(From, To);
-     Propagate();
-     Channels.SetModified(true);
-     isyslog("channel %d moved to %d", FromNumber, ToNumber);
-     if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-        if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-           Channels.SwitchTo(CurrentChannel->Number());
-        else
-           cDevice::SetCurrentChannel(CurrentChannel);
-        }
-     }
-}
-
-eOSState cMenuChannels::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  switch (state) {
-    case osUser1: {
-         cChannel *channel = Channels.Last();
-         if (channel) {
-            Add(new cMenuChannelItem(channel), true);
-            return CloseSubMenu();
-            }
-         }
-         break;
-    default:
-         if (state == osUnknown) {
-            switch (Key) {
-              case k0 ... k9:
-                            return Number(Key);
-              case kOk:     return Switch();
-              case kRed:    return Edit();
-              case kGreen:  return New();
-              case kYellow: return Delete();
-              case kBlue:   if (!HasSubMenu())
-                               Mark();
-                            break;
-              default: break;
-              }
-            }
-    }
-  return state;
-}
-
-// --- cMenuText -------------------------------------------------------------
-
-cMenuText::cMenuText(const char *Title, const char *Text, eDvbFont Font)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcText);
-  text = NULL;
-  font = Font;
-  SetText(Text);
-}
-
-cMenuText::~cMenuText()
-{
-  free(text);
-}
-
-void cMenuText::SetText(const char *Text)
-{
-  free(text);
-  text = Text ? strdup(Text) : NULL;
-}
-
-void cMenuText::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetText(text, font == fontFix); //XXX define control character in text to choose the font???
-  if (text)
-     cStatus::MsgOsdTextItem(text);
-}
-
-eOSState cMenuText::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk: return osBack;
-       default:  state = osContinue;
-       }
-     }
-  return state;
-}
-
-// --- cMenuFolderItem -------------------------------------------------------
-
-class cMenuFolderItem : public cOsdItem {
-private:
-  cNestedItem *folder;
-public:
-  cMenuFolderItem(cNestedItem *Folder);
-  cNestedItem *Folder(void) { return folder; }
-  };
-
-cMenuFolderItem::cMenuFolderItem(cNestedItem *Folder)
-:cOsdItem(Folder->Text())
-{
-  folder = Folder;
-  if (folder->SubItems())
-     SetText(cString::sprintf("%s...", folder->Text()));
-}
-
-// --- cMenuEditFolder -------------------------------------------------------
-
-class cMenuEditFolder : public cOsdMenu {
-private:
-  cList<cNestedItem> *list;
-  cNestedItem *folder;
-  char name[PATH_MAX];
-  int subFolder;
-  eOSState Confirm(void);
-public:
-  cMenuEditFolder(const char *Dir, cList<cNestedItem> *List, cNestedItem *Folder = NULL);
-  cString GetFolder(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditFolder::cMenuEditFolder(const char *Dir, cList<cNestedItem> *List, cNestedItem *Folder)
-:cOsdMenu(Folder ? tr("Edit folder") : tr("New folder"), 12)
-{
-  SetMenuCategory(mcFolder);
-  list = List;
-  folder = Folder;
-  if (folder) {
-     strn0cpy(name, folder->Text(), sizeof(name));
-     subFolder = folder->SubItems() != NULL;
-     }
-  else {
-     *name = 0;
-     subFolder = 0;
-     cRemote::Put(kRight, true); // go right into string editing mode
-     }
-  if (!isempty(Dir)) {
-     cOsdItem *DirItem = new cOsdItem(Dir);
-     DirItem->SetSelectable(false);
-     Add(DirItem);
-     }
-  Add(new cMenuEditStrItem( tr("Name"), name, sizeof(name)));
-  Add(new cMenuEditBoolItem(tr("Sub folder"), &subFolder));
-}
-
-cString cMenuEditFolder::GetFolder(void)
-{
-  return folder ? folder->Text() : "";
-}
-
-eOSState cMenuEditFolder::Confirm(void)
-{
-  if (!folder || strcmp(folder->Text(), name) != 0) {
-     // each name may occur only once in a folder list
-     for (cNestedItem *Folder = list->First(); Folder; Folder = list->Next(Folder)) {
-         if (strcmp(Folder->Text(), name) == 0) {
-            Skins.Message(mtError, tr("Folder name already exists!"));
-            return osContinue;
-            }
-         }
-     char *p = strpbrk(name, "\\{}#~"); // FOLDERDELIMCHAR
-     if (p) {
-        Skins.Message(mtError, cString::sprintf(tr("Folder name must not contain '%c'!"), *p));
-        return osContinue;
-        }
-     }
-  if (folder) {
-     folder->SetText(name);
-     folder->SetSubItems(subFolder);
-     }
-  else
-     list->Add(folder = new cNestedItem(name, subFolder));
-  return osEnd;
-}
-
-eOSState cMenuEditFolder::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     return Confirm();
-       case kRed:
-       case kGreen:
-       case kYellow:
-       case kBlue:   return osContinue;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuFolder -----------------------------------------------------------
-
-cMenuFolder::cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcFolder);
-  list = nestedItemList = NestedItemList;
-  firstFolder = NULL;
-  editing = false;
-  Set();
-  SetHelpKeys();
-  DescendPath(Path);
-}
-
-cMenuFolder::cMenuFolder(const char *Title, cList<cNestedItem> *List, cNestedItemList *NestedItemList, const char *Dir, const char *Path)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcFolder);
-  list = List;
-  nestedItemList = NestedItemList;
-  dir = Dir;
-  firstFolder = NULL;
-  editing = false;
-  Set();
-  SetHelpKeys();
-  DescendPath(Path);
-}
-
-void cMenuFolder::SetHelpKeys(void)
-{
-  SetHelp(firstFolder ? tr("Button$Select") : NULL, tr("Button$New"), firstFolder ? tr("Button$Delete") : NULL, firstFolder ? tr("Button$Edit") : NULL);
-}
-
-void cMenuFolder::Set(const char *CurrentFolder)
-{
-  firstFolder = NULL;
-  Clear();
-  if (!isempty(dir)) {
-     cOsdItem *DirItem = new cOsdItem(dir);
-     DirItem->SetSelectable(false);
-     Add(DirItem);
-     }
-  list->Sort();
-  for (cNestedItem *Folder = list->First(); Folder; Folder = list->Next(Folder)) {
-      cOsdItem *FolderItem = new cMenuFolderItem(Folder);
-      Add(FolderItem, CurrentFolder ? strcmp(Folder->Text(), CurrentFolder) == 0 : false);
-      if (!firstFolder)
-         firstFolder = FolderItem;
-      }
-}
-
-void cMenuFolder::DescendPath(const char *Path)
-{
-  if (Path) {
-     const char *p = strchr(Path, FOLDERDELIMCHAR);
-     if (p) {
-        for (cMenuFolderItem *Folder = (cMenuFolderItem *)firstFolder; Folder; Folder = (cMenuFolderItem *)Next(Folder)) {
-            if (strncmp(Folder->Folder()->Text(), Path, p - Path) == 0) {
-               SetCurrent(Folder);
-               if (Folder->Folder()->SubItems())
-                  AddSubMenu(new cMenuFolder(Title(), Folder->Folder()->SubItems(), nestedItemList, !isempty(dir) ? *cString::sprintf("%s%c%s", *dir, FOLDERDELIMCHAR, Folder->Folder()->Text()) : Folder->Folder()->Text(), p + 1));
-               break;
-               }
-            }
-        }
-    }
-}
-
-eOSState cMenuFolder::Select(void)
-{
-  if (firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        if (Folder->Folder()->SubItems())
-           return AddSubMenu(new cMenuFolder(Title(), Folder->Folder()->SubItems(), nestedItemList, !isempty(dir) ? *cString::sprintf("%s%c%s", *dir, FOLDERDELIMCHAR, Folder->Folder()->Text()) : Folder->Folder()->Text()));
-        else
-           return osEnd;
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::New(void)
-{
-  editing = true;
-  return AddSubMenu(new cMenuEditFolder(dir, list));
-}
-
-eOSState cMenuFolder::Delete(void)
-{
-  if (!HasSubMenu() && firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder && Interface->Confirm(Folder->Folder()->SubItems() ? tr("Delete folder and all sub folders?") : tr("Delete folder?"))) {
-        list->Del(Folder->Folder());
-        Del(Folder->Index());
-        firstFolder = Get(isempty(dir) ? 0 : 1);
-        Display();
-        SetHelpKeys();
-        nestedItemList->Save();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::Edit(void)
-{
-  if (!HasSubMenu() && firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        editing = true;
-        return AddSubMenu(new cMenuEditFolder(dir, list, Folder->Folder()));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::SetFolder(void)
-{
-  cMenuEditFolder *mef = (cMenuEditFolder *)SubMenu();
-  if (mef) {
-     Set(mef->GetFolder());
-     SetHelpKeys();
-     Display();
-     nestedItemList->Save();
-     }
-  return CloseSubMenu();
-}
-
-cString cMenuFolder::GetFolder(void)
-{
-  if (firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        cMenuFolder *mf = (cMenuFolder *)SubMenu();
-        if (mf)
-           return cString::sprintf("%s%c%s", Folder->Folder()->Text(), FOLDERDELIMCHAR, *mf->GetFolder());
-        return Folder->Folder()->Text();
-        }
-     }
-  return "";
-}
-
-eOSState cMenuFolder::ProcessKey(eKeys Key)
-{
-  if (!HasSubMenu())
-     editing = false;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:
-       case kRed:    return Select();
-       case kGreen:  return New();
-       case kYellow: return Delete();
-       case kBlue:   return Edit();
-       default:      state = osContinue;
-       }
-     }
-  else if (state == osEnd && HasSubMenu() && editing)
-     state = SetFolder();
-  return state;
-}
-
-// --- cMenuEditTimer --------------------------------------------------------
-
-cMenuEditTimer::cMenuEditTimer(cTimer *Timer, bool New)
-:cOsdMenu(tr("Edit timer"), 12)
-{
-  SetMenuCategory(mcTimerEdit);
-  file = NULL;
-  day = firstday = NULL;
-  timer = Timer;
-  addIfConfirmed = New;
-  if (timer) {
-     data = *timer;
-     if (New)
-        data.SetFlags(tfActive);
-     channel = data.Channel()->Number();
-     Add(new cMenuEditBitItem( tr("Active"),       &data.flags, tfActive));
-     Add(new cMenuEditChanItem(tr("Channel"),      &channel));
-     Add(day = new cMenuEditDateItem(tr("Day"),    &data.day, &data.weekdays));
-     Add(new cMenuEditTimeItem(tr("Start"),        &data.start));
-     Add(new cMenuEditTimeItem(tr("Stop"),         &data.stop));
-     Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
-     Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
-     Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
-     Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
-     SetFirstDayItem();
-     }
-  SetHelpKeys();
-  Timers.IncBeingEdited();
-}
-
-cMenuEditTimer::~cMenuEditTimer()
-{
-  if (timer && addIfConfirmed)
-     delete timer; // apparently it wasn't confirmed
-  Timers.DecBeingEdited();
-}
-
-void cMenuEditTimer::SetHelpKeys(void)
-{
-  SetHelp(tr("Button$Folder"), data.weekdays ? tr("Button$Single") : tr("Button$Repeating"));
-}
-
-void cMenuEditTimer::SetFirstDayItem(void)
-{
-  if (!firstday && !data.IsSingleEvent()) {
-     Add(firstday = new cMenuEditDateItem(tr("First day"), &data.day));
-     Display();
-     }
-  else if (firstday && data.IsSingleEvent()) {
-     Del(firstday->Index());
-     firstday = NULL;
-     Display();
-     }
-}
-
-eOSState cMenuEditTimer::SetFolder(void)
-{
-  cMenuFolder *mf = (cMenuFolder *)SubMenu();
-  if (mf) {
-     cString Folder = mf->GetFolder();
-     char *p = strrchr(data.file, FOLDERDELIMCHAR);
-     if (p)
-        p++;
-     else
-        p = data.file;
-     if (!isempty(*Folder))
-        strn0cpy(data.file, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(data.file));
-     else if (p != data.file)
-        memmove(data.file, p, strlen(p) + 1);
-     SetCurrent(file);
-     Display();
-     }
-  return CloseSubMenu();
-}
-
-eOSState cMenuEditTimer::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     {
-                       cChannel *ch = Channels.GetByNumber(channel);
-                       if (ch)
-                          data.channel = ch;
-                       else {
-                          Skins.Message(mtError, tr("*** Invalid Channel ***"));
-                          break;
-                          }
-                       if (!*data.file)
-                          strcpy(data.file, data.Channel()->ShortName(true));
-                       if (timer) {
-                          if (memcmp(timer, &data, sizeof(data)) != 0)
-                             *timer = data;
-                          if (addIfConfirmed)
-                             Timers.Add(timer);
-                          timer->SetEventFromSchedule();
-                          timer->Matches();
-                          Timers.SetModified();
-                          isyslog("timer %s %s (%s)", *timer->ToDescr(), addIfConfirmed ? "added" : "modified", timer->HasFlags(tfActive) ? "active" : "inactive");
-                          addIfConfirmed = false;
-                          }
-                     }
-                     return osBack;
-       case kRed:    return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, data.file));
-       case kGreen:  if (day) {
-                        day->ToggleRepeating();
-                        SetCurrent(day);
-                        SetFirstDayItem();
-                        SetHelpKeys();
-                        Display();
-                        }
-                     return osContinue;
-       case kYellow:
-       case kBlue:   return osContinue;
-       default: break;
-       }
-     }
-  else if (state == osEnd && HasSubMenu())
-     state = SetFolder();
-  if (Key != kNone)
-     SetFirstDayItem();
-  return state;
-}
-
-// --- cMenuTimerItem --------------------------------------------------------
-
-class cMenuTimerItem : public cOsdItem {
-private:
-  cTimer *timer;
-public:
-  cMenuTimerItem(cTimer *Timer);
-  virtual int Compare(const cListObject &ListObject) const;
-  virtual void Set(void);
-  cTimer *Timer(void) { return timer; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuTimerItem::cMenuTimerItem(cTimer *Timer)
-{
-  timer = Timer;
-  Set();
-}
-
-int cMenuTimerItem::Compare(const cListObject &ListObject) const
-{
-  return timer->Compare(*((cMenuTimerItem *)&ListObject)->timer);
-}
-
-void cMenuTimerItem::Set(void)
-{
-  cString day, name("");
-  if (timer->WeekDays())
-     day = timer->PrintDay(0, timer->WeekDays(), false);
-  else if (timer->Day() - time(NULL) < 28 * SECSINDAY) {
-     day = itoa(timer->GetMDay(timer->Day()));
-     name = WeekDayName(timer->Day());
-     }
-  else {
-     struct tm tm_r;
-     time_t Day = timer->Day();
-     localtime_r(&Day, &tm_r);
-     char buffer[16];
-     strftime(buffer, sizeof(buffer), "%Y%m%d", &tm_r);
-     day = buffer;
-     }
-  const char *File = Setup.FoldersInTimerMenu ? NULL : strrchr(timer->File(), FOLDERDELIMCHAR);
-  if (File && strcmp(File + 1, TIMERMACRO_TITLE) && strcmp(File + 1, TIMERMACRO_EPISODE))
-     File++;
-  else
-     File = timer->File();
-  SetText(cString::sprintf("%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
-		    !(timer->HasFlags(tfActive)) ? " " : timer->FirstDay() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_ARROW_UTF8 : ICON_ARROW : "!" : timer->Recording() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_REC_UTF8 : ICON_REC : "#" : Setup.WarEagleIcons ? IsLangUtf8() ? ICON_CLOCK_UTF8 : ICON_CLOCK : ">",
-                    timer->Channel()->Number(),
-                    *name,
-                    *name && **name ? " " : "",
-                    *day,
-                    timer->Start() / 100,
-                    timer->Start() % 100,
-                    timer->Stop() / 100,
-                    timer->Stop() % 100,
-                    File));
-}
-
-void cMenuTimerItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemTimer(timer, Index, Current, Selectable))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuTimers -----------------------------------------------------------
-
-class cMenuTimers : public cOsdMenu {
-private:
-  int helpKeys;
-  eOSState Edit(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  eOSState OnOff(void);
-  eOSState Info(void);
-  cTimer *CurrentTimer(void);
-  void SetHelpKeys(void);
-public:
-  cMenuTimers(void);
-  virtual ~cMenuTimers();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuTimers"; }
-  };
-
-cMenuTimers::cMenuTimers(void)
-:cOsdMenu(tr("Timers"), 2, CHNUMWIDTH, 10, 6, 6)
-{
-  SetMenuCategory(mcTimer);
-  helpKeys = -1;
-  for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
-      timer->SetEventFromSchedule(); // make sure the event is current
-      Add(new cMenuTimerItem(timer));
-      }
-  Sort();
-  SetCurrent(First());
-  SetHelpKeys();
-  Timers.IncBeingEdited();
-}
-
-cMenuTimers::~cMenuTimers()
-{
-  Timers.DecBeingEdited();
-}
-
-cTimer *cMenuTimers::CurrentTimer(void)
-{
-  cMenuTimerItem *item = (cMenuTimerItem *)Get(Current());
-  return item ? item->Timer() : NULL;
-}
-
-void cMenuTimers::SetHelpKeys(void)
-{
-  int NewHelpKeys = 0;
-  cTimer *timer = CurrentTimer();
-  if (timer) {
-     if (timer->Event())
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     helpKeys = NewHelpKeys;
-     SetHelp(helpKeys > 0 ? tr("Button$On/Off") : NULL, tr("Button$New"), helpKeys > 0 ? tr("Button$Delete") : NULL, helpKeys == 2 ? tr("Button$Info") : NULL);
-     }
-}
-
-eOSState cMenuTimers::OnOff(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  cTimer *timer = CurrentTimer();
-  if (timer) {
-     timer->OnOff();
-     timer->SetEventFromSchedule();
-     RefreshCurrent();
-     DisplayCurrent(true);
-     if (timer->FirstDay())
-        isyslog("timer %s first day set to %s", *timer->ToDescr(), *timer->PrintFirstDay());
-     else
-        isyslog("timer %s %sactivated", *timer->ToDescr(), timer->HasFlags(tfActive) ? "" : "de");
-     Timers.SetModified();
-     }
-  return osContinue;
-}
-
-eOSState cMenuTimers::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  isyslog("editing timer %s", *CurrentTimer()->ToDescr());
-  return AddSubMenu(new cMenuEditTimer(CurrentTimer()));
-}
-
-eOSState cMenuTimers::New(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  return AddSubMenu(new cMenuEditTimer(new cTimer, true));
-}
-
-eOSState cMenuTimers::Delete(void)
-{
-  // Check if this timer is active:
-  cTimer *ti = CurrentTimer();
-  if (ti) {
-     if (Interface->Confirm(tr("Delete timer?"))) {
-        if (ti->Recording()) {
-           if (Interface->Confirm(tr("Timer still recording - really delete?"))) {
-              ti->Skip();
-              cRecordControls::Process(time(NULL));
-              }
-           else
-              return osContinue;
-           }
-        isyslog("deleting timer %s", *ti->ToDescr());
-        Timers.Del(ti);
-        cOsdMenu::Del(Current());
-        Timers.SetModified();
-        Display();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuTimers::Info(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cTimer *ti = CurrentTimer();
-  if (ti && ti->Event())
-     return AddSubMenu(new cMenuEvent(ti->Event()));
-  return osContinue;
-}
-
-eOSState cMenuTimers::ProcessKey(eKeys Key)
-{
-  int TimerNumber = HasSubMenu() ? Count() : -1;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     return Edit();
-       case kRed:    state = OnOff(); break; // must go through SetHelpKeys()!
-       case kGreen:  return New();
-       case kYellow: state = Delete(); break;
-       case kInfo:
-       case kBlue:   return Info();
-                     break;
-       default: break;
-       }
-     }
-  if (TimerNumber >= 0 && !HasSubMenu() && Timers.Get(TimerNumber)) {
-     // a newly created timer was confirmed with Ok
-     Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
-     Display();
-     }
-  if (Key != kNone)
-     SetHelpKeys();
-  return state;
-}
-
-// --- cMenuEvent ------------------------------------------------------------
-
-cMenuEvent::cMenuEvent(const cEvent *Event, bool CanSwitch, bool Buttons)
-:cOsdMenu(tr("Event"))
-{
-  SetMenuCategory(mcEvent);
-  event = Event;
-  if (event) {
-     cChannel *channel = Channels.GetByChannelID(event->ChannelID(), true);
-     if (channel) {
-        SetTitle(channel->Name());
-        eTimerMatch TimerMatch = tmNone;
-        Timers.GetMatch(event, &TimerMatch);
-        if (Buttons)
-           SetHelp(TimerMatch == tmFull ? tr("Button$Timer") : tr("Button$Record"), NULL, NULL, CanSwitch ? tr("Button$Switch") : NULL);
-        }
-     }
-}
-
-void cMenuEvent::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetEvent(event);
-  cStatus::MsgOsdSetEvent(event);
-  if (event->Description())
-     cStatus::MsgOsdTextItem(event->Description());
-}
-
-eOSState cMenuEvent::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    case kInfo:   return osBack;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kGreen:
-       case kYellow: return osContinue;
-       case kOk:     return osBack;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuScheduleItem -----------------------------------------------------
-
-class cMenuScheduleItem : public cOsdItem {
-public:
-  enum eScheduleSortMode { ssmAllThis, ssmThisThis, ssmThisAll, ssmAllAll }; // "which event(s) on which channel(s)"
-private:
-  static eScheduleSortMode sortMode;
-public:
-  const cEvent *event;
-  const cChannel *channel;
-  bool withDate;
-  eTimerMatch timerMatch;
-  cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false);
-  static void SetSortMode(eScheduleSortMode SortMode) { sortMode = SortMode; }
-  static void IncSortMode(void) { sortMode = eScheduleSortMode((sortMode == ssmAllAll) ? ssmAllThis : sortMode + 1); }
-  static eScheduleSortMode SortMode(void) { return sortMode; }
-  virtual int Compare(const cListObject &ListObject) const;
-  bool Update(bool Force = false);
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuScheduleItem::eScheduleSortMode cMenuScheduleItem::sortMode = ssmAllThis;
-
-cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate)
-{
-  event = Event;
-  channel = Channel;
-  withDate = WithDate;
-  timerMatch = tmNone;
-  Update(true);
-}
-
-int cMenuScheduleItem::Compare(const cListObject &ListObject) const
-{
-  cMenuScheduleItem *p = (cMenuScheduleItem *)&ListObject;
-  int r = -1;
-  if (sortMode != ssmAllThis)
-     r = strcoll(event->Title(), p->event->Title());
-  if (sortMode == ssmAllThis || r == 0)
-     r = event->StartTime() - p->event->StartTime();
-  return r;
-}
-
-static const char *TimerMatchChars[9] =
-{
-  " ", "t", "T",
-  ICON_BLANK, ICON_CLOCK_UH, ICON_CLOCK,
-  ICON_BLANK_UTF8, ICON_CLOCK_UH_UTF8, ICON_CLOCK_UTF8
-};
-
-bool cMenuScheduleItem::Update(bool Force)
-{
-  bool result = false;
-  eTimerMatch OldTimerMatch = timerMatch;
-  Timers.GetMatch(event, &timerMatch);
-  if (Force || timerMatch != OldTimerMatch) {
-     cString buffer;
-     const char *t = Setup.WarEagleIcons ? IsLangUtf8() ? TimerMatchChars[timerMatch+6] : TimerMatchChars[timerMatch+3] : TimerMatchChars[timerMatch];
-     const char *v = event->Vps() && (event->Vps() - event->StartTime()) ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_VPS_UTF8 : ICON_VPS : "V" : " ";
-     const char *r = event->SeenWithin(30) && event->IsRunning() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_RUNNING_UTF8 : ICON_RUNNING : "*" : " ";
-     const char *csn = channel ? channel->ShortName(true) : NULL;
-     cString eds = event->GetDateString();
-     if (channel && withDate)
-        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-     else if (channel)
-        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
-     else
-        buffer = cString::sprintf("%.*s\t%s\t%s%s%s\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-     SetText(buffer);
-     result = true;
-     }
-  return result;
-}
-
-void cMenuScheduleItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemEvent(event, Index, Current, Selectable, channel, withDate, timerMatch))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuWhatsOn ----------------------------------------------------------
-
-class cMenuWhatsOn : public cOsdMenu {
-private:
-  bool now;
-  int helpKeys;
-  int timerState;
-  eOSState Record(void);
-  eOSState Switch(void);
-  static int currentChannel;
-  static const cEvent *scheduleEvent;
-  bool Update(void);
-  void SetHelpKeys(void);
-public:
-  cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr);
-  static int CurrentChannel(void) { return currentChannel; }
-  static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
-  static const cEvent *ScheduleEvent(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
-  virtual void Display(void);
-  };
-
-int cMenuWhatsOn::currentChannel = 0;
-const cEvent *cMenuWhatsOn::scheduleEvent = NULL;
-
-cMenuWhatsOn::cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr)
-:cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, CHNAMWIDTH, 6, 4)
-{
-  SetMenuCategory(Now ? mcScheduleNow : mcScheduleNext);
-  now = Now;
-  helpKeys = -1;
-  timerState = 0;
-  Timers.Modified(timerState);
-  for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-      if (!Channel->GroupSep()) {
-         const cSchedule *Schedule = Schedules->GetSchedule(Channel);
-         if (Schedule) {
-            const cEvent *Event = Now ? Schedule->GetPresentEvent() : Schedule->GetFollowingEvent();
-            if (Event)
-               Add(new cMenuScheduleItem(Event, Channel), Channel->Number() == CurrentChannelNr);
-            }
-         }
-      }
-  currentChannel = CurrentChannelNr;
-  Display();
-  SetHelpKeys();
-}
-
-void cMenuWhatsOn::Display(void)
-{
-   cOsdMenu::Display();
-
-   if (Count() > 0) {
-      int ni = 0;
-      for (cOsdItem *item = First(); item; item = Next(item)) {
-         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
-      }
-   }
-}
-
-bool cMenuWhatsOn::Update(void)
-{
-  bool result = false;
-  if (Timers.Modified(timerState)) {
-     for (cOsdItem *item = First(); item; item = Next(item)) {
-         if (((cMenuScheduleItem *)item)->Update())
-            result = true;
-         }
-     }
-  return result;
-}
-
-void cMenuWhatsOn::SetHelpKeys(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (item) {
-     if (item->timerMatch == tmFull)
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     const char *Red[] = { NULL, tr("Button$Record"), tr("Button$Timer") };
-     SetHelp(Red[NewHelpKeys], now ? tr("Button$Next") : tr("Button$Now"), tr("Button$Schedule"), tr("Button$Switch"));
-     helpKeys = NewHelpKeys;
-     }
-}
-
-const cEvent *cMenuWhatsOn::ScheduleEvent(void)
-{
-  const cEvent *ei = scheduleEvent;
-  scheduleEvent = NULL;
-  return ei;
-}
-
-eOSState cMenuWhatsOn::Switch(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     cChannel *channel = Channels.GetByChannelID(item->event->ChannelID(), true);
-     if (channel && cDevice::PrimaryDevice()->SwitchChannel(channel, true))
-        return osEnd;
-     }
-  Skins.Message(mtError, tr("Can't switch channel!"));
-  return osContinue;
-}
-
-eOSState cMenuWhatsOn::Record(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     if (item->timerMatch == tmFull) {
-        eTimerMatch tm = tmNone;
-        cTimer *timer = Timers.GetMatch(item->event, &tm);
-        if (timer)
-           return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     cTimer *timer = new cTimer(item->event);
-     cTimer *t = Timers.GetTimer(timer);
-     if (t) {
-        delete timer;
-        timer = t;
-        return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     else {
-        Timers.Add(timer);
-        Timers.SetModified();
-        isyslog("timer %s added (active)", *timer->ToDescr());
-        if (timer->Matches(0, false, NEWTIMERLIMIT))
-           return AddSubMenu(new cMenuEditTimer(timer));
-        if (HasSubMenu())
-           CloseSubMenu();
-        if (Update())
-           Display();
-        SetHelpKeys();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuWhatsOn::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRecord:
-       case kRed:    return Record();
-       case kYellow: state = osBack;
-                     // continue with kGreen
-       case kGreen:  {
-                       cMenuScheduleItem *mi = (cMenuScheduleItem *)Get(Current());
-                       if (mi) {
-                          scheduleEvent = mi->event;
-                          currentChannel = mi->channel->Number();
-                          }
-                     }
-                     break;
-       case kBlue:   return Switch();
-       case kInfo:
-       case kOk:     if (Count())
-                        return AddSubMenu(new cMenuEvent(((cMenuScheduleItem *)Get(Current()))->event, true, true));
-                     break;
-       default:      break;
-       }
-     }
-  else if (!HasSubMenu()) {
-     if (HadSubMenu && Update())
-        Display();
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuSchedule ---------------------------------------------------------
-
-class cMenuSchedule : public cOsdMenu {
-private:
-  cSchedulesLock schedulesLock;
-  const cSchedules *schedules;
-  bool now, next;
-  int otherChannel;
-  int helpKeys;
-  int timerState;
-  eOSState Number(void);
-  eOSState Record(void);
-  eOSState Switch(void);
-  void PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleThisThis(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleThisAll(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleAllAll(const cEvent *Event, const cChannel *Channel);
-  bool Update(void);
-  void SetHelpKeys(void);
-public:
-  cMenuSchedule(void);
-  virtual ~cMenuSchedule();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSchedule"; }
-  virtual void Display(void);
-  };
-
-cMenuSchedule::cMenuSchedule(void)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcSchedule);
-  now = next = false;
-  otherChannel = 0;
-  helpKeys = -1;
-  timerState = 0;
-  Timers.Modified(timerState);
-  cMenuScheduleItem::SetSortMode(cMenuScheduleItem::ssmAllThis);
-  cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  if (channel) {
-     cMenuWhatsOn::SetCurrentChannel(channel->Number());
-     schedules = cSchedules::Schedules(schedulesLock);
-     PrepareScheduleAllThis(NULL, channel);
-     SetHelpKeys();
-     }
-}
-
-cMenuSchedule::~cMenuSchedule()
-{
-  cMenuWhatsOn::ScheduleEvent(); // makes sure any posted data is cleared
-}
-
-void cMenuSchedule::Display(void)
-{
-   cOsdMenu::Display();
-
-   if (Count() > 0) {
-      int ni = 0;
-      for (cOsdItem *item = First(); item; item = Next(item)) {
-         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
-      }
-   }
-}
-
-void cMenuSchedule::PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(7, 6, 4);
-  SetTitle(cString::sprintf(tr("Schedule - %s"), Channel->Name()));
-  if (schedules && Channel) {
-     const cSchedule *Schedule = schedules->GetSchedule(Channel);
-     if (Schedule) {
-        const cEvent *PresentEvent = Event ? Event : Schedule->GetPresentEvent();
-        time_t now = time(NULL) - Setup.EPGLinger * 60;
-        for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-            if (ev->EndTime() > now || ev == PresentEvent)
-               Add(new cMenuScheduleItem(ev), ev == PresentEvent);
-            }
-        }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleThisThis(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(7, 6, 4);
-  SetTitle(cString::sprintf(tr("This event - %s"), Channel->Name()));
-  if (schedules && Channel && Event) {
-     const cSchedule *Schedule = schedules->GetSchedule(Channel);
-     if (Schedule) {
-        time_t now = time(NULL) - Setup.EPGLinger * 60;
-        for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-            if ((ev->EndTime() > now || ev == Event) && !strcmp(ev->Title(), Event->Title()))
-               Add(new cMenuScheduleItem(ev), ev == Event);
-            }
-        }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleThisAll(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(CHNUMWIDTH, CHNAMWIDTH, 7, 6, 4);
-  SetTitle(tr("This event - all channels"));
-  if (schedules && Event) {
-     for (cChannel *ch = Channels.First(); ch; ch = Channels.Next(ch)) {
-         const cSchedule *Schedule = schedules->GetSchedule(ch);
-         if (Schedule) {
-            time_t now = time(NULL) - Setup.EPGLinger * 60;
-            for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-                if ((ev->EndTime() > now || ev == Event) && !strcmp(ev->Title(), Event->Title()))
-                   Add(new cMenuScheduleItem(ev, ch, true), ev == Event && ch == Channel);
-                }
-            }
-         }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleAllAll(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(CHNUMWIDTH, CHNAMWIDTH, 7, 6, 4);
-  SetTitle(tr("All events - all channels"));
-  if (schedules) {
-     for (cChannel *ch = Channels.First(); ch; ch = Channels.Next(ch)) {
-         const cSchedule *Schedule = schedules->GetSchedule(ch);
-         if (Schedule) {
-            time_t now = time(NULL) - Setup.EPGLinger * 60;
-            for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-                if (ev->EndTime() > now || ev == Event)
-                   Add(new cMenuScheduleItem(ev, ch, true), ev == Event && ch == Channel);
-                }
-            }
-         }
-     }
-}
-
-bool cMenuSchedule::Update(void)
-{
-  bool result = false;
-  if (Timers.Modified(timerState)) {
-     for (cOsdItem *item = First(); item; item = Next(item)) {
-         if (((cMenuScheduleItem *)item)->Update())
-            result = true;
-         }
-     }
-  return result;
-}
-
-void cMenuSchedule::SetHelpKeys(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (item) {
-     if (item->timerMatch == tmFull)
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     const char *Red[] = { NULL, tr("Button$Record"), tr("Button$Timer") };
-     SetHelp(Red[NewHelpKeys], tr("Button$Now"), tr("Button$Next"));
-     helpKeys = NewHelpKeys;
-     }
-}
-
-eOSState cMenuSchedule::Number(void)
-{
-  cMenuScheduleItem::IncSortMode();
-  cMenuScheduleItem *CurrentItem = (cMenuScheduleItem *)Get(Current());
-  const cChannel *Channel = NULL;
-  const cEvent *Event = NULL;
-  if (CurrentItem) {
-     Event = CurrentItem->event;
-     Channel = Channels.GetByChannelID(Event->ChannelID(), true);
-     }
-  else
-     Channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  switch (cMenuScheduleItem::SortMode()) {
-    case cMenuScheduleItem::ssmAllThis:  PrepareScheduleAllThis(Event, Channel); break;
-    case cMenuScheduleItem::ssmThisThis: PrepareScheduleThisThis(Event, Channel); break;
-    case cMenuScheduleItem::ssmThisAll:  PrepareScheduleThisAll(Event, Channel); break;
-    case cMenuScheduleItem::ssmAllAll:   PrepareScheduleAllAll(Event, Channel); break;
-    default: esyslog("ERROR: unknown SortMode %d (%s %d)", cMenuScheduleItem::SortMode(), __FUNCTION__, __LINE__);
-    }
-  CurrentItem = (cMenuScheduleItem *)Get(Current());
-  Sort();
-  SetCurrent(CurrentItem);
-  Display();
-  return osContinue;
-}
-
-eOSState cMenuSchedule::Record(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     if (item->timerMatch == tmFull) {
-        eTimerMatch tm = tmNone;
-        cTimer *timer = Timers.GetMatch(item->event, &tm);
-        if (timer)
-           return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     cTimer *timer = new cTimer(item->event);
-     cTimer *t = Timers.GetTimer(timer);
-     if (t) {
-        delete timer;
-        timer = t;
-        return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     else {
-        Timers.Add(timer);
-        Timers.SetModified();
-        isyslog("timer %s added (active)", *timer->ToDescr());
-        if (timer->Matches(0, false, NEWTIMERLIMIT))
-           return AddSubMenu(new cMenuEditTimer(timer));
-        if (HasSubMenu())
-           CloseSubMenu();
-        if (Update())
-           Display();
-        SetHelpKeys();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuSchedule::Switch(void)
-{
-  if (otherChannel) {
-     if (Channels.SwitchTo(otherChannel))
-        return osEnd;
-     }
-  Skins.Message(mtError, tr("Can't switch channel!"));
-  return osContinue;
-}
-
-eOSState cMenuSchedule::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case k0:      return Number();
-       case kRecord:
-       case kRed:    return Record();
-       case kGreen:  if (schedules) {
-                        if (!now && !next) {
-                           int ChannelNr = 0;
-                           if (Count()) {
-                              cChannel *channel = Channels.GetByChannelID(((cMenuScheduleItem *)Get(Current()))->event->ChannelID(), true);
-                              if (channel)
-                                 ChannelNr = channel->Number();
-                              }
-                           now = true;
-                           return AddSubMenu(new cMenuWhatsOn(schedules, true, ChannelNr));
-                           }
-                        now = !now;
-                        next = !next;
-                        return AddSubMenu(new cMenuWhatsOn(schedules, now, cMenuWhatsOn::CurrentChannel()));
-                        }
-       case kYellow: if (schedules)
-                        return AddSubMenu(new cMenuWhatsOn(schedules, false, cMenuWhatsOn::CurrentChannel()));
-                     break;
-       case kBlue:   if (Count() && otherChannel)
-                        return Switch();
-                     break;
-       case kInfo:
-       case kOk:     if (Count())
-                        return AddSubMenu(new cMenuEvent(((cMenuScheduleItem *)Get(Current()))->event, otherChannel, true));
-                     break;
-       default:      break;
-       }
-     }
-  else if (!HasSubMenu()) {
-     now = next = false;
-     const cEvent *ei = cMenuWhatsOn::ScheduleEvent();
-     if (ei) {
-        cChannel *channel = Channels.GetByChannelID(ei->ChannelID(), true);
-        if (channel) {
-           cMenuScheduleItem::SetSortMode(cMenuScheduleItem::ssmAllThis);
-           PrepareScheduleAllThis(NULL, channel);
-           if (channel->Number() != cDevice::CurrentChannel()) {
-              otherChannel = channel->Number();
-              SetHelp(Count() ? tr("Button$Record") : NULL, tr("Button$Now"), tr("Button$Next"), tr("Button$Switch"));
-              }
-           Display();
-           }
-        }
-     else if (HadSubMenu && Update())
-        Display();
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuCommands ---------------------------------------------------------
-
-cMenuCommands::cMenuCommands(const char *Title, cList<cNestedItem> *Commands, const char *Parameters)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcCommand);
-  result = NULL;
-  SetHasHotkeys();
-  commands = Commands;
-  parameters = Parameters;
-  for (cNestedItem *Command = commands->First(); Command; Command = commands->Next(Command)) {
-      const char *s = Command->Text();
-      if (Command->SubItems())
-         Add(new cOsdItem(hk(cString::sprintf("%s...", s))));
-      else if (Parse(s))
-         Add(new cOsdItem(hk(title)));
-      }
-}
-
-cMenuCommands::~cMenuCommands()
-{
-  free(result);
-}
-
-bool cMenuCommands::Parse(const char *s)
-{
-  const char *p = strchr(s, ':');
-  if (p) {
-     int l = p - s;
-     if (l > 0) {
-        char t[l + 1];
-        stripspace(strn0cpy(t, s, l + 1));
-        l = strlen(t);
-        if (l > 1 && t[l - 1] == '?') {
-           t[l - 1] = 0;
-           confirm = true;
-           }
-        else
-           confirm = false;
-        title = t;
-        command = skipspace(p + 1);
-        return true;
-        }
-     }
-  return false;
-}
-
-eOSState cMenuCommands::Execute(void)
-{
-  cNestedItem *Command = commands->Get(Current());
-  if (Command) {
-     if (Command->SubItems())
-        return AddSubMenu(new cMenuCommands(Title(), Command->SubItems(), parameters));
-     if (Parse(Command->Text())) {
-        if (!confirm || Interface->Confirm(cString::sprintf("%s?", *title))) {
-           Skins.Message(mtStatus, cString::sprintf("%s...", *title));
-           free(result);
-           result = NULL;
-           cString cmdbuf;
-           if (!isempty(parameters))
-              cmdbuf = cString::sprintf("%s %s", *command, *parameters);
-           const char *cmd = *cmdbuf ? *cmdbuf : *command;
-           dsyslog("executing command '%s'", cmd);
-           cPipe p;
-           if (p.Open(cmd, "r")) {
-              int l = 0;
-              int c;
-              while ((c = fgetc(p)) != EOF) {
-                    if (l % 20 == 0) {
-                       if (char *NewBuffer = (char *)realloc(result, l + 21))
-                          result = NewBuffer;
-                       else {
-                          esyslog("ERROR: out of memory");
-                          break;
-                          }
-                       }
-                    result[l++] = char(c);
-                    }
-              if (result)
-                 result[l] = 0;
-              p.Close();
-              }
-           else
-              esyslog("ERROR: can't open pipe for command '%s'", cmd);
-           Skins.Message(mtStatus, NULL);
-           if (result)
-              return AddSubMenu(new cMenuText(title, result, fontFix));
-           return osEnd;
-           }
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuCommands::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:
-       case kGreen:
-       case kYellow:
-       case kBlue:   return osContinue;
-       case kOk:     return Execute();
-       default:      break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuCam --------------------------------------------------------------
-
-static bool CamMenuIsOpen = false;
-
-class cMenuCam : public cOsdMenu {
-private:
-  cCamSlot *camSlot;
-  cCiMenu *ciMenu;
-  cCiEnquiry *ciEnquiry;
-  char *input;
-  int offset;
-  time_t lastCamExchange;
-  void GenerateTitle(const char *s = NULL);
-  void QueryCam(void);
-  void AddMultiLineItem(const char *s);
-  void Set(void);
-  eOSState Select(void);
-public:
-  cMenuCam(cCamSlot *CamSlot);
-  virtual ~cMenuCam();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuCam"; }
-  };
-
-cMenuCam::cMenuCam(cCamSlot *CamSlot)
-:cOsdMenu("", 1) // tab necessary for enquiry!
-{
-  SetMenuCategory(mcCam);
-  camSlot = CamSlot;
-  ciMenu = NULL;
-  ciEnquiry = NULL;
-  input = NULL;
-  offset = 0;
-  lastCamExchange = time(NULL);
-  SetNeedsFastResponse(true);
-  QueryCam();
-  CamMenuIsOpen = true;
-}
-
-cMenuCam::~cMenuCam()
-{
-  if (ciMenu)
-     ciMenu->Abort();
-  delete ciMenu;
-  if (ciEnquiry)
-     ciEnquiry->Abort();
-  delete ciEnquiry;
-  free(input);
-  CamMenuIsOpen = false;
-}
-
-void cMenuCam::GenerateTitle(const char *s)
-{
-  SetTitle(cString::sprintf("CAM %d - %s", camSlot->SlotNumber(), (s && *s) ? s : camSlot->GetCamName()));
-}
-
-void cMenuCam::QueryCam(void)
-{
-  delete ciMenu;
-  ciMenu = NULL;
-  delete ciEnquiry;
-  ciEnquiry = NULL;
-  if (camSlot->HasUserIO()) {
-     ciMenu = camSlot->GetMenu();
-     ciEnquiry = camSlot->GetEnquiry();
-     }
-  Set();
-}
-
-void cMenuCam::Set(void)
-{
-  if (ciMenu) {
-     Clear();
-     free(input);
-     input = NULL;
-     dsyslog("CAM %d: Menu ------------------", camSlot->SlotNumber());
-     offset = 0;
-     SetHasHotkeys(ciMenu->Selectable());
-     GenerateTitle(ciMenu->TitleText());
-     dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->TitleText());
-     if (*ciMenu->SubTitleText()) {
-        dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->SubTitleText());
-        AddMultiLineItem(ciMenu->SubTitleText());
-        offset = Count();
-        }
-     for (int i = 0; i < ciMenu->NumEntries(); i++) {
-         Add(new cOsdItem(hk(ciMenu->Entry(i)), osUnknown, ciMenu->Selectable()));
-         dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->Entry(i));
-         }
-     if (*ciMenu->BottomText()) {
-        AddMultiLineItem(ciMenu->BottomText());
-        dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->BottomText());
-        }
-     cRemote::TriggerLastActivity();
-     }
-  else if (ciEnquiry) {
-     Clear();
-     int Length = ciEnquiry->ExpectedLength();
-     free(input);
-     input = MALLOC(char, Length + 1);
-     *input = 0;
-     GenerateTitle();
-     Add(new cOsdItem(ciEnquiry->Text(), osUnknown, false));
-     Add(new cOsdItem("", osUnknown, false));
-     Add(new cMenuEditNumItem("", input, Length, ciEnquiry->Blind()));
-     }
-  Display();
-}
-
-void cMenuCam::AddMultiLineItem(const char *s)
-{
-  while (s && *s) {
-        const char *p = strchr(s, '\n');
-        int l = p ? p - s : strlen(s);
-        cOsdItem *item = new cOsdItem;
-        item->SetSelectable(false);
-        item->SetText(strndup(s, l), false);
-        Add(item);
-        s = p ? p + 1 : p;
-        }
-}
-
-eOSState cMenuCam::Select(void)
-{
-  if (ciMenu) {
-     if (ciMenu->Selectable()) {
-        ciMenu->Select(Current() - offset);
-        dsyslog("CAM %d: select %d", camSlot->SlotNumber(), Current() - offset);
-        }
-     else
-        ciMenu->Cancel();
-     }
-  else if (ciEnquiry) {
-     if (ciEnquiry->ExpectedLength() < 0xFF && int(strlen(input)) != ciEnquiry->ExpectedLength()) {
-        char buffer[64];
-        snprintf(buffer, sizeof(buffer), tr("Please enter %d digits!"), ciEnquiry->ExpectedLength());
-        Skins.Message(mtError, buffer);
-        return osContinue;
-        }
-     ciEnquiry->Reply(input);
-     dsyslog("CAM %d: entered '%s'", camSlot->SlotNumber(), ciEnquiry->Blind() ? "****" : input);
-     }
-  QueryCam();
-  return osContinue;
-}
-
-eOSState cMenuCam::ProcessKey(eKeys Key)
-{
-  if (!camSlot->HasMMI())
-     return osBack;
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (ciMenu || ciEnquiry) {
-     lastCamExchange = time(NULL);
-     if (state == osUnknown) {
-        switch (Key) {
-          case kOk: return Select();
-          default: break;
-          }
-        }
-     else if (state == osBack) {
-        if (ciMenu)
-           ciMenu->Cancel();
-        if (ciEnquiry)
-           ciEnquiry->Cancel();
-        QueryCam();
-        return osContinue;
-        }
-     if (ciMenu && ciMenu->HasUpdate()) {
-        QueryCam();
-        return osContinue;
-        }
-     }
-  else if (time(NULL) - lastCamExchange < CAMRESPONSETIMEOUT)
-     QueryCam();
-  else {
-     Skins.Message(mtError, tr("CAM not responding!"));
-     return osBack;
-     }
-  return state;
-}
-
-// --- CamControl ------------------------------------------------------------
-
-cOsdObject *CamControl(void)
-{
-  for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
-      if (CamSlot->HasUserIO())
-         return new cMenuCam(CamSlot);
-      }
-  return NULL;
-}
-
-bool CamMenuActive(void)
-{
-  return CamMenuIsOpen;
-}
-
-// --- cMenuRecording --------------------------------------------------------
-
-class cMenuRecording : public cOsdMenu {
-private:
-  const cRecording *recording;
-  bool withButtons;
-public:
-  cMenuRecording(const cRecording *Recording, bool WithButtons = false);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuRecording"; }
-};
-
-cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
-:cOsdMenu(tr("Recording info"))
-{
-  SetMenuCategory(mcRecordingInfo);
-  recording = Recording;
-  withButtons = WithButtons;
-  if (withButtons)
-     SetHelp(tr("Button$Play"), tr("Button$Rewind"));
-}
-
-void cMenuRecording::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetRecording(recording);
-  cStatus::MsgOsdSetRecording(recording);
-  if (recording->Info()->Description())
-     cStatus::MsgOsdTextItem(recording->Info()->Description());
-}
-
-eOSState cMenuRecording::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    case kInfo:   return osBack;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:    if (withButtons)
-                        Key = kOk; // will play the recording, even if recording commands are defined
-       case kGreen:  if (!withButtons)
-                        break;
-                     cRemote::Put(Key, true);
-                     // continue with osBack to close the info menu and process the key
-       case kOk:     return osBack;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuRecordingItem ----------------------------------------------------
-
-class cMenuRecordingItem : public cOsdItem {
-private:
-  cRecording *recording;
-  int level;
-  char *name;
-  int totalEntries, newEntries;
-public:
-  cMenuRecordingItem(cRecording *Recording, int Level);
-  ~cMenuRecordingItem();
-  void IncrementCounter(bool New);
-  const char *Name(void) { return name; }
-  cRecording *Recording(void) { return recording; }
-  bool IsDirectory(void) { return name != NULL; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuRecordingItem::cMenuRecordingItem(cRecording *Recording, int Level)
-{
-  recording = Recording;
-  level = Level;
-  name = NULL;
-  totalEntries = newEntries = 0;
-  SetText(Recording->Title('\t', true, Level));
-  if (*Text() == '\t')
-     name = strdup(Text() + 2); // 'Text() + 2' to skip the two '\t'
-}
-
-cMenuRecordingItem::~cMenuRecordingItem()
-{
-  free(name);
-}
-
-void cMenuRecordingItem::IncrementCounter(bool New)
-{
-  totalEntries++;
-  if (New)
-     newEntries++;
-  SetText(cString::sprintf("%d\t\t%d\t%s", totalEntries, newEntries, name));
-}
-
-void cMenuRecordingItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemRecording(recording, Index, Current, Selectable, level, totalEntries, newEntries))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuEditRecording ----------------------------------------------------
-
-class cMenuEditRecording : public cOsdMenu {
-private:
-  char name[MaxFileName];
-  cMenuEditStrItem *file;
-  cOsdItem *marksItem, *resumeItem;
-  bool isResume, isMarks;
-  cRecording *recording;
-  void SetHelpKeys(void);
-  eOSState SetFolder(void);
-public:
-  cMenuEditRecording(cRecording *Recording);
-  virtual eOSState ProcessKey(eKeys Key);
-};
-
-cMenuEditRecording::cMenuEditRecording(cRecording *Recording)
-:cOsdMenu(tr("Edit recording"), 14)
-{
-  cMarks marks;
-
-  file = NULL;
-  recording = Recording;
-
-  if (recording) {
-     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
-     Add(file = new cMenuEditStrItem(tr("File"), name, sizeof(name)));
-
-     Add(new cOsdItem("", osUnknown, false));
-
-     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->Start())), osUnknown, false));
-
-     cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
-     if (channel)
-        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
-
-     int recLen = recording->LengthInSeconds();
-     if (recLen >= 0)
-        Add(new cOsdItem(cString::sprintf("%s:\t%d:%02d:%02d", tr("Length"), recLen / 3600, recLen / 60 % 60, recLen % 60), osUnknown, false));
-     else
-        recLen = 0;
-
-     int dirSize = DirSizeMB(recording->FileName());
-     cString bitRate = recLen ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / recLen) : cString("");
-     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Format"), recording->IsPesRecording() ? tr("PES") : tr("TS")), osUnknown, false));
-     Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
-
-     Add(new cOsdItem("", osUnknown, false));
-
-     isMarks = marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && marks.Count();
-     marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
-     Add(marksItem);
-
-     cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
-     isResume = (ResumeFile.Read() != -1);
-     resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
-     Add(resumeItem);
-     }
-
-  SetHelpKeys();
-}
-
-void cMenuEditRecording::SetHelpKeys(void)
-{
-  SetHelp(tr("Button$Folder"), tr("Button$Cut"), tr("Button$Copy"), tr("Button$Rename/Move"));
-}
-
-eOSState cMenuEditRecording::SetFolder(void)
-{
-  cMenuFolder *mf = (cMenuFolder *)SubMenu();
-  if (mf) {
-     cString Folder = mf->GetFolder();
-     char *p = strrchr(name, FOLDERDELIMCHAR);
-     if (p)
-        p++;
-     else
-        p = name;
-     if (!isempty(*Folder))
-        strn0cpy(name, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(name));
-     else if (p != name)
-        memmove(name, p, strlen(p) + 1);
-     SetCurrent(file);
-     Display();
-     }
-  return CloseSubMenu();
-}
-
-eOSState cMenuEditRecording::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:
-            return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, name));
-            break;
-       case kGreen:
-            if (!cCutter::Active()) {
-               if (!isMarks)
-                  Skins.Message(mtError, tr("No editing marks defined!"));
-               else if (!cCutter::Start(recording->FileName(), strcmp(recording->Name(), name) ? *NewVideoFileName(recording->FileName(), name) : NULL, false))
-                  Skins.Message(mtError, tr("Can't start editing process!"));
-               else
-                  Skins.Message(mtInfo, tr("Editing process started"));
-               }
-            else
-               Skins.Message(mtError, tr("Editing process already active!"));
-            return osContinue;
-       case kYellow:
-       case kBlue:
-            if (strcmp(recording->Name(), name)) {
-               if (!cFileTransfer::Active()) {
-                  if (cFileTransfer::Start(recording, name, (Key == kYellow)))
-                     Skins.Message(mtInfo, tr("File transfer started"));
-                  else
-                     Skins.Message(mtError, tr("Can't start file transfer!"));
-                  }
-               else
-                  Skins.Message(mtError, tr("File transfer already active!"));
-               }
-            return osRecordings;
-       default:
-            break;
-       }
-     return osContinue;
-     }
-  else if (state == osEnd && HasSubMenu())
-     state = SetFolder();
-  else if (state == osUser1) {
-     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
-        cMarks marks;
-        marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording());
-        cMark *mark = marks.First();
-        while (mark) {
-              cMark *nextmark = marks.Next(mark);
-              marks.Del(mark);
-              mark = nextmark;
-              }
-        marks.Save();
-        isMarks = false;
-        marksItem->SetSelectable(isMarks);
-        SetCurrent(First());
-        Display();
-        }
-     return osContinue;
-     }
-  else if (state == osUser2) {
-     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
-        cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
-        ResumeFile.Delete();
-        isResume = false;
-        resumeItem->SetSelectable(isResume);
-        SetCurrent(First());
-        Display();
-        }
-     return osContinue;
-     }
-
-  return state;
-}
-
-// --- cMenuRecordings -------------------------------------------------------
-
-cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
-:cOsdMenu(Base ? Base : tr("Recordings"), 9, 6, 6)
-{
-  SetMenuCategory(mcRecording);
-  base = Base ? strdup(Base) : NULL;
-  level = Setup.RecordingDirs ? Level : -1;
-  Recordings.StateChanged(recordingsState); // just to get the current state
-  helpKeys = -1;
-  Display(); // this keeps the higher level menus from showing up briefly when pressing 'Back' during replay
-  Set();
-  if (Current() < 0)
-     SetCurrent(First());
-  else if (OpenSubMenus && cReplayControl::LastReplayed() && Open(true))
-     return;
-  Display();
-  SetHelpKeys();
-}
-
-cMenuRecordings::~cMenuRecordings()
-{
-  helpKeys = -1;
-  free(base);
-}
-
-void cMenuRecordings::SetHelpKeys(void)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (ri) {
-     if (ri->IsDirectory())
-        NewHelpKeys = 1;
-     else {
-        NewHelpKeys = 2;
-        if (ri->Recording()->Info()->Title())
-           NewHelpKeys = 3;
-        }
-     }
-  if (NewHelpKeys != helpKeys) {
-     switch (NewHelpKeys) {
-       case 0: SetHelp(NULL); break;
-       case 1: SetHelp(tr("Button$Open")); break;
-       case 2:
-       case 3: SetHelp(RecordingCommands.Count() ? tr("Commands") : tr("Button$Play"), tr("Button$Rewind"), tr("Button$Delete"), NewHelpKeys == 3 ? tr("Button$Info") : NULL);
-       default: ;
-       }
-     helpKeys = NewHelpKeys;
-     }
-}
-
-void cMenuRecordings::Set(bool Refresh)
-{
-  const char *CurrentRecording = cReplayControl::LastReplayed();
-  cMenuRecordingItem *LastItem = NULL;
-  cThreadLock RecordingsLock(&Recordings);
-  if (Refresh) {
-     if (cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current()))
-        CurrentRecording = ri->Recording()->FileName();
-     }
-  Clear();
-  GetRecordingsSortMode(DirectoryName());
-  Recordings.Sort();
-  for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
-      if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == FOLDERDELIMCHAR)) {
-         cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
-         cMenuRecordingItem *LastDir = NULL;
-         if (Item->IsDirectory()) {
-            // Sorting may ignore non-alphanumeric characters, so we need to explicitly handle directories in case they only differ in such characters:
-            for (cMenuRecordingItem *p = LastItem; p; p = dynamic_cast<cMenuRecordingItem *>(p->Prev())) {
-                if (p->Name() && strcmp(p->Name(), Item->Name()) == 0) {
-                   LastDir = p;
-                   break;
-                   }
-                }
-            }
-         if (*Item->Text() && !LastDir) {
-            Add(Item);
-            LastItem = Item;
-            if (Item->IsDirectory())
-               LastDir = Item;
-            }
-         else
-            delete Item;
-         if (LastItem || LastDir) {
-            if (CurrentRecording && strcmp(CurrentRecording, recording->FileName()) == 0)
-               SetCurrent(LastDir ? LastDir : LastItem);
-            }
-         if (LastDir)
-            LastDir->IncrementCounter(recording->IsNew());
-         }
-      }
-  if (Refresh)
-     Display();
-}
-
-cString cMenuRecordings::DirectoryName(void)
-{
-  cString d(VideoDirectory);
-  if (base) {
-     char *s = ExchangeChars(strdup(base), true);
-     d = AddDirectory(d, s);
-     free(s);
-     if (!DirectoryOk(*d, false, true)) {
-        cString e;
-        if (LockExtraVideoDirectories(true)) {
-           for (int i = 0; i < ExtraVideoDirectories.Size(); i++) {
-               e = AddDirectory(ExtraVideoDirectories.At(i), s);
-               if (DirectoryOk(*e, false, true)) {
-                  UnlockExtraVideoDirectories();
-                  return e;
-                  }
-               }
-           UnlockExtraVideoDirectories();
-           }
-        }
-     }
-  return d;
-}
-
-bool cMenuRecordings::Open(bool OpenSubMenus)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && ri->IsDirectory()) {
-     const char *t = ri->Name();
-     cString buffer;
-     if (base) {
-        buffer = cString::sprintf("%s~%s", base, t);
-        t = buffer;
-        }
-     AddSubMenu(new cMenuRecordings(t, level + 1, OpenSubMenus));
-     return true;
-     }
-  return false;
-}
-
-eOSState cMenuRecordings::Play(void)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri) {
-     if (ri->IsDirectory())
-        Open();
-     else {
-        cReplayControl::SetRecording(ri->Recording()->FileName());
-        return osReplay;
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Rewind(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cDevice::PrimaryDevice()->StopReplay(); // must do this first to be able to rewind the currently replayed recording
-     cResumeFile ResumeFile(ri->Recording()->FileName(), ri->Recording()->IsPesRecording());
-     ResumeFile.Delete();
-     return Play();
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Delete(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     if (Interface->Confirm(tr("Delete recording?"))) {
-        cRecordControl *rc = cRecordControls::GetRecordControl(ri->Recording()->FileName());
-        if (rc) {
-           if (Interface->Confirm(tr("Timer still recording - really delete?"))) {
-              cTimer *timer = rc->Timer();
-              if (timer) {
-                 timer->Skip();
-                 cRecordControls::Process(time(NULL));
-                 if (timer->IsSingleEvent()) {
-                    isyslog("deleting timer %s", *timer->ToDescr());
-                    Timers.Del(timer);
-                    }
-                 Timers.SetModified();
-                 }
-              }
-           else
-              return osContinue;
-           }
-        cRecording *recording = ri->Recording();
-        cString FileName = recording->FileName();
-        if (cCutter::Active(ri->Recording()->FileName())) {
-           if (Interface->Confirm(tr("Recording is being edited - really delete?"))) {
-              cCutter::Stop();
-              recording = Recordings.GetByName(FileName); // cCutter::Stop() might have deleted it if it was the edited version
-              // we continue with the code below even if recording is NULL,
-              // in order to have the menu updated etc.
-              }
-           else
-              return osContinue;
-           }
-        if (cReplayControl::NowReplaying() && strcmp(cReplayControl::NowReplaying(), FileName) == 0)
-           cControl::Shutdown();
-        if (!recording || recording->Delete()) {
-           cReplayControl::ClearLastReplayed(FileName);
-           Recordings.DelByName(FileName);
-           cOsdMenu::Del(Current());
-           SetHelpKeys();
-           cVideoDiskUsage::ForceCheck();
-           Display();
-           if (!Count())
-              return osBack;
-           }
-        else
-           Skins.Message(mtError, tr("Error while deleting recording!"));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Info(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory() && ri->Recording()->Info()->Title())
-     return AddSubMenu(new cMenuRecording(ri->Recording(), true));
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Commands(eKeys Key)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cMenuCommands *menu;
-     eOSState state = AddSubMenu(menu = new cMenuCommands(tr("Recording commands"), &RecordingCommands, cString::sprintf("\"%s\"", *strescape(ri->Recording()->FileName(), "\\\"$"))));
-     if (Key != kNone)
-        state = menu->ProcessKey(Key);
-     return state;
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Sort(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  IncRecordingsSortMode(DirectoryName());
-  Set(true);
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory() && ri->Recording())
-     return AddSubMenu(new cMenuEditRecording(ri->Recording()));
-  return osContinue;
-}
-
-eOSState cMenuRecordings::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kPlayPause:
-       case kPlay:
-       case kOk:     return Play();
-       case kRed:    return (helpKeys > 1 && RecordingCommands.Count()) ? Commands() : Play();
-       case kGreen:  return Rewind();
-       case kYellow: return Delete();
-       case kInfo:   return Edit();
-       case kBlue:   return Info();
-       case k0:      return Sort();
-       case k1...k9: return Commands(Key);
-       case kNone:   if (Recordings.StateChanged(recordingsState))
-                        Set(true);
-                     break;
-       default: break;
-       }
-     }
-  if (Key == kYellow && HadSubMenu && !HasSubMenu()) {
-     // the last recording in a subdirectory was deleted, so let's go back up
-     cOsdMenu::Del(Current());
-     if (!Count())
-        return osBack;
-     Display();
-     }
-  if (!HasSubMenu()) {
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuSetupBase --------------------------------------------------------
-
-class cMenuSetupBase : public cMenuSetupPage {
-protected:
-  cSetup data;
-  virtual void Store(void);
-public:
-  cMenuSetupBase(void);
-  };
-
-cMenuSetupBase::cMenuSetupBase(void)
-{
-  data = Setup;
-}
-
-void cMenuSetupBase::Store(void)
-{
-  Setup = data;
-  cOsdProvider::UpdateOsdSize(true);
-  Setup.Save();
-}
-
-// --- cMenuSetupOSD ---------------------------------------------------------
-
-class cMenuSetupOSD : public cMenuSetupBase {
-private:
-  const char *useSmallFontTexts[3];
-  const char *keyColorTexts[4];
-  int osdLanguageIndex;
-  int numSkins;
-  int originalSkinIndex;
-  int skinIndex;
-  const char **skinDescriptions;
-  cThemes themes;
-  int originalThemeIndex;
-  int themeIndex;
-  cStringList fontOsdNames, fontSmlNames, fontFixNames;
-  int fontOsdIndex, fontSmlIndex, fontFixIndex;
-  virtual void Set(void);
-public:
-  cMenuSetupOSD(void);
-  virtual ~cMenuSetupOSD();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupOsd"; }
-  };
-
-cMenuSetupOSD::cMenuSetupOSD(void)
-{
-  SetMenuCategory(mcSetupOsd);
-  osdLanguageIndex = I18nCurrentLanguage();
-  numSkins = Skins.Count();
-  skinIndex = originalSkinIndex = Skins.Current()->Index();
-  skinDescriptions = new const char*[numSkins];
-  themes.Load(Skins.Current()->Name());
-  themeIndex = originalThemeIndex = Skins.Current()->Theme() ? themes.GetThemeIndex(Skins.Current()->Theme()->Description()) : 0;
-  cFont::GetAvailableFontNames(&fontOsdNames);
-  cFont::GetAvailableFontNames(&fontSmlNames);
-  cFont::GetAvailableFontNames(&fontFixNames, true);
-  fontOsdNames.Insert(strdup(DefaultFontOsd));
-  fontSmlNames.Insert(strdup(DefaultFontSml));
-  fontFixNames.Insert(strdup(DefaultFontFix));
-  fontOsdIndex = max(0, fontOsdNames.Find(Setup.FontOsd));
-  fontSmlIndex = max(0, fontSmlNames.Find(Setup.FontSml));
-  fontFixIndex = max(0, fontFixNames.Find(Setup.FontFix));
-  Set();
-}
-
-cMenuSetupOSD::~cMenuSetupOSD()
-{
-  delete[] skinDescriptions;
-}
-
-void cMenuSetupOSD::Set(void)
-{
-  int current = Current();
-  for (cSkin *Skin = Skins.First(); Skin; Skin = Skins.Next(Skin))
-      skinDescriptions[Skin->Index()] = Skin->Description();
-  useSmallFontTexts[0] = tr("never");
-  useSmallFontTexts[1] = tr("skin dependent");
-  useSmallFontTexts[2] = tr("always");
-  keyColorTexts[0] = tr("Key$Red");
-  keyColorTexts[1] = tr("Key$Green");
-  keyColorTexts[2] = tr("Key$Yellow");
-  keyColorTexts[3] = tr("Key$Blue");
-  Clear();
-  SetSection(tr("OSD"));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Language"),               &osdLanguageIndex, I18nNumLanguagesWithLocale(), &I18nLanguages()->At(0)));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
-  if (themes.NumThemes())
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Theme"),                  &themeIndex, themes.NumThemes(), themes.Descriptions()));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$WarEagle icons"),         &data.WarEagleIcons));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Left (%)"),               &data.OSDLeftP, 0.0, 0.5));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Top (%)"),                &data.OSDTopP, 0.0, 0.5));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Width (%)"),              &data.OSDWidthP, 0.5, 1.0));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Height (%)"),             &data.OSDHeightP, 0.5, 1.0));
-  Add(new cMenuEditIntItem( tr("Setup.OSD$Message time (s)"),       &data.OSDMessageTime, 1, 60));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Use small font"),         &data.UseSmallFont, 3, useSmallFontTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Anti-alias"),             &data.AntiAlias));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Default font"),           &fontOsdIndex, fontOsdNames.Size(), &fontOsdNames[0]));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Small font"),             &fontSmlIndex, fontSmlNames.Size(), &fontSmlNames[0]));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Fixed font"),             &fontFixIndex, fontFixNames.Size(), &fontFixNames[0]));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Default font size (%)"),  &data.FontOsdSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Small font size (%)"),    &data.FontSmlSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Fixed font size (%)"),    &data.FontFixSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Channel info position"),  &data.ChannelInfoPos, tr("bottom"), tr("top")));
-  Add(new cMenuEditIntItem( tr("Setup.OSD$Channel info time (s)"),  &data.ChannelInfoTime, 1, 60));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Info on channel switch"), &data.ShowInfoOnChSwitch));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Timeout requested channel info"), &data.TimeoutRequChInfo));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll pages"),           &data.MenuScrollPage));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll wraps"),           &data.MenuScrollWrap));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Menu key closes"),        &data.MenuKeyCloses));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Folders in timer menu"),  &data.FoldersInTimerMenu));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Always sort folders first"), &data.AlwaysSortFoldersFirst));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Number keys for characters"), &data.NumberKeysForChars));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 0"),            &data.ColorKey0, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 1"),            &data.ColorKey1, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 2"),            &data.ColorKey2, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 3"),            &data.ColorKey3, 4, keyColorTexts));
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupOSD::ProcessKey(eKeys Key)
-{
-  bool ModifiedAppearance = false;
-
-  if (Key == kOk) {
-     I18nSetLocale(data.OSDLanguage);
-     if (skinIndex != originalSkinIndex) {
-        cSkin *Skin = Skins.Get(skinIndex);
-        if (Skin) {
-           Utf8Strn0Cpy(data.OSDSkin, Skin->Name(), sizeof(data.OSDSkin));
-           Skins.SetCurrent(Skin->Name());
-           ModifiedAppearance = true;
-           }
-        }
-     if (themes.NumThemes() && Skins.Current()->Theme()) {
-        Skins.Current()->Theme()->Load(themes.FileName(themeIndex));
-        Utf8Strn0Cpy(data.OSDTheme, themes.Name(themeIndex), sizeof(data.OSDTheme));
-        ModifiedAppearance |= themeIndex != originalThemeIndex;
-        }
-     if (!(DoubleEqual(data.OSDLeftP, Setup.OSDLeftP) && DoubleEqual(data.OSDTopP, Setup.OSDTopP) && DoubleEqual(data.OSDWidthP, Setup.OSDWidthP) && DoubleEqual(data.OSDHeightP, Setup.OSDHeightP)))
-        ModifiedAppearance = true;
-     if (data.UseSmallFont != Setup.UseSmallFont || data.AntiAlias != Setup.AntiAlias)
-        ModifiedAppearance = true;
-     Utf8Strn0Cpy(data.FontOsd, fontOsdNames[fontOsdIndex], sizeof(data.FontOsd));
-     Utf8Strn0Cpy(data.FontSml, fontSmlNames[fontSmlIndex], sizeof(data.FontSml));
-     Utf8Strn0Cpy(data.FontFix, fontFixNames[fontFixIndex], sizeof(data.FontFix));
-     if (strcmp(data.FontOsd, Setup.FontOsd) || !DoubleEqual(data.FontOsdSizeP, Setup.FontOsdSizeP))
-        ModifiedAppearance = true;
-     if (strcmp(data.FontSml, Setup.FontSml) || !DoubleEqual(data.FontSmlSizeP, Setup.FontSmlSizeP))
-        ModifiedAppearance = true;
-     if (strcmp(data.FontFix, Setup.FontFix) || !DoubleEqual(data.FontFixSizeP, Setup.FontFixSizeP))
-        ModifiedAppearance = true;
-     if (data.AlwaysSortFoldersFirst != Setup.AlwaysSortFoldersFirst)
-        Recordings.ClearSortNames();
-     }
-
-  int oldSkinIndex = skinIndex;
-  int oldOsdLanguageIndex = osdLanguageIndex;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (ModifiedAppearance) {
-     cOsdProvider::UpdateOsdSize(true);
-     SetDisplayMenu();
-     }
-
-  if (osdLanguageIndex != oldOsdLanguageIndex || skinIndex != oldSkinIndex) {
-     strn0cpy(data.OSDLanguage, I18nLocale(osdLanguageIndex), sizeof(data.OSDLanguage));
-     int OriginalOSDLanguage = I18nCurrentLanguage();
-     I18nSetLanguage(osdLanguageIndex);
-
-     cSkin *Skin = Skins.Get(skinIndex);
-     if (Skin) {
-        char *d = themes.NumThemes() ? strdup(themes.Descriptions()[themeIndex]) : NULL;
-        themes.Load(Skin->Name());
-        if (skinIndex != oldSkinIndex)
-           themeIndex = d ? themes.GetThemeIndex(d) : 0;
-        free(d);
-        }
-
-     Set();
-     I18nSetLanguage(OriginalOSDLanguage);
-     }
-  return state;
-}
-
-// --- cMenuSetupEPG ---------------------------------------------------------
-
-class cMenuSetupEPG : public cMenuSetupBase {
-private:
-  int originalNumLanguages;
-  int numLanguages;
-  void Setup(void);
-public:
-  cMenuSetupEPG(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupEpg"; }
-  };
-
-cMenuSetupEPG::cMenuSetupEPG(void)
-{
-  SetMenuCategory(mcSetupEpg);
-  for (numLanguages = 0; numLanguages < I18nLanguages()->Size() && data.EPGLanguages[numLanguages] >= 0; numLanguages++)
-      ;
-  originalNumLanguages = numLanguages;
-  SetSection(tr("EPG"));
-  SetHelp(tr("Button$Scan"));
-  Setup();
-}
-
-void cMenuSetupEPG::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG scan timeout (h)"),      &data.EPGScanTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG bugfix level"),          &data.EPGBugfixLevel, 0, MAXEPGBUGFIXLEVEL));
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG linger time (min)"),     &data.EPGLinger, 0));
-  Add(new cMenuEditBoolItem(tr("Setup.EPG$Set system time"),           &data.SetSystemTime));
-  if (data.SetSystemTime)
-     Add(new cMenuEditTranItem(tr("Setup.EPG$Use time from transponder"), &data.TimeTransponder, &data.TimeSource));
-  // TRANSLATORS: note the plural!
-  Add(new cMenuEditIntItem( tr("Setup.EPG$Preferred languages"),       &numLanguages, 0, I18nLanguages()->Size()));
-  for (int i = 0; i < numLanguages; i++)
-      // TRANSLATORS: note the singular!
-      Add(new cMenuEditStraItem(tr("Setup.EPG$Preferred language"),    &data.EPGLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupEPG::ProcessKey(eKeys Key)
-{
-  if (Key == kOk) {
-     bool Modified = numLanguages != originalNumLanguages;
-     if (!Modified) {
-        for (int i = 0; i < numLanguages; i++) {
-            if (data.EPGLanguages[i] != ::Setup.EPGLanguages[i]) {
-               Modified = true;
-               break;
-               }
-            }
-        }
-     if (Modified)
-        cSchedules::ResetVersions();
-     }
-
-  int oldnumLanguages = numLanguages;
-  int oldSetSystemTime = data.SetSystemTime;
-
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-  if (Key != kNone) {
-     if (numLanguages != oldnumLanguages || data.SetSystemTime != oldSetSystemTime) {
-        for (int i = oldnumLanguages; i < numLanguages; i++) {
-            data.EPGLanguages[i] = 0;
-            for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                int k;
-                for (k = 0; k < oldnumLanguages; k++) {
-                    if (data.EPGLanguages[k] == l)
-                       break;
-                    }
-                if (k >= oldnumLanguages) {
-                   data.EPGLanguages[i] = l;
-                   break;
-                   }
-                }
-            }
-        data.EPGLanguages[numLanguages] = -1;
-        Setup();
-        }
-     if (Key == kRed) {
-        EITScanner.ForceScan();
-        return osEnd;
-        }
-     }
-  return state;
-}
-
-// --- cMenuSetupDVB ---------------------------------------------------------
-
-class cMenuSetupDVB : public cMenuSetupBase {
-private:
-  int originalNumAudioLanguages;
-  int numAudioLanguages;
-  int originalNumSubtitleLanguages;
-  int numSubtitleLanguages;
-  void Setup(void);
-  const char *videoDisplayFormatTexts[3];
-  const char *updateChannelsTexts[6];
-  const char *standardComplianceTexts[2];
-public:
-  cMenuSetupDVB(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupDvb"; }
-  };
-
-cMenuSetupDVB::cMenuSetupDVB(void)
-{
-  SetMenuCategory(mcSetupDvb);
-  for (numAudioLanguages = 0; numAudioLanguages < I18nLanguages()->Size() && data.AudioLanguages[numAudioLanguages] >= 0; numAudioLanguages++)
-      ;
-  for (numSubtitleLanguages = 0; numSubtitleLanguages < I18nLanguages()->Size() && data.SubtitleLanguages[numSubtitleLanguages] >= 0; numSubtitleLanguages++)
-      ;
-  originalNumAudioLanguages = numAudioLanguages;
-  originalNumSubtitleLanguages = numSubtitleLanguages;
-  videoDisplayFormatTexts[0] = tr("pan&scan");
-  videoDisplayFormatTexts[1] = tr("letterbox");
-  videoDisplayFormatTexts[2] = tr("center cut out");
-  updateChannelsTexts[0] = tr("no");
-  updateChannelsTexts[1] = tr("names only");
-  updateChannelsTexts[2] = tr("PIDs only");
-  updateChannelsTexts[3] = tr("names and PIDs");
-  updateChannelsTexts[4] = tr("add new channels");
-  updateChannelsTexts[5] = tr("add new transponders");
-  standardComplianceTexts[0] = "DVB";
-  standardComplianceTexts[1] = "ANSI/SCTE";
-
-  SetSection(tr("DVB"));
-  SetHelp(NULL, tr("Button$Audio"), tr("Button$Subtitles"), NULL);
-  Setup();
-}
-
-void cMenuSetupDVB::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditIntItem( tr("Setup.DVB$Primary DVB interface"), &data.PrimaryDVB, 1, cDevice::NumDevices()));
-  Add(new cMenuEditStraItem(tr("Setup.DVB$Standard compliance"),   &data.StandardCompliance, 2, standardComplianceTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Video format"),          &data.VideoFormat, "4:3", "16:9"));
-  if (data.VideoFormat == 0)
-     Add(new cMenuEditStraItem(tr("Setup.DVB$Video display format"), &data.VideoDisplayFormat, 3, videoDisplayFormatTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Dolby Digital"),     &data.UseDolbyDigital));
-  Add(new cMenuEditStraItem(tr("Setup.DVB$Update channels"),       &data.UpdateChannels, 6, updateChannelsTexts));
-  Add(new cMenuEditIntItem( tr("Setup.DVB$Audio languages"),       &numAudioLanguages, 0, I18nLanguages()->Size()));
-  for (int i = 0; i < numAudioLanguages; i++)
-      Add(new cMenuEditStraItem(tr("Setup.DVB$Audio language"),    &data.AudioLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Display subtitles"),     &data.DisplaySubtitles));
-  if (data.DisplaySubtitles) {
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle languages"),    &numSubtitleLanguages, 0, I18nLanguages()->Size()));
-     for (int i = 0; i < numSubtitleLanguages; i++)
-         Add(new cMenuEditStraItem(tr("Setup.DVB$Subtitle language"), &data.SubtitleLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle offset"),                  &data.SubtitleOffset,      -100, 100));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
-     }
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Enable teletext support"), &data.SupportTeletext));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Channel Blocker"), &data.ChannelBlocker));
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupDVB::ProcessKey(eKeys Key)
-{
-  int oldPrimaryDVB = ::Setup.PrimaryDVB;
-  int oldVideoDisplayFormat = ::Setup.VideoDisplayFormat;
-  bool oldVideoFormat = ::Setup.VideoFormat;
-  bool newVideoFormat = data.VideoFormat;
-  bool oldDisplaySubtitles = ::Setup.DisplaySubtitles;
-  bool newDisplaySubtitles = data.DisplaySubtitles;
-  int oldnumAudioLanguages = numAudioLanguages;
-  int oldnumSubtitleLanguages = numSubtitleLanguages;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone) {
-     switch (Key) {
-       case kGreen:  cRemote::Put(kAudio, true);
-                     state = osEnd;
-                     break;
-       case kYellow: cRemote::Put(kSubtitles, true);
-                     state = osEnd;
-                     break;
-       default: {
-            bool DoSetup = data.VideoFormat != newVideoFormat;
-            DoSetup |= data.DisplaySubtitles != newDisplaySubtitles;
-            if (numAudioLanguages != oldnumAudioLanguages) {
-               for (int i = oldnumAudioLanguages; i < numAudioLanguages; i++) {
-                   data.AudioLanguages[i] = 0;
-                   for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                       int k;
-                       for (k = 0; k < oldnumAudioLanguages; k++) {
-                           if (data.AudioLanguages[k] == l)
-                              break;
-                           }
-                       if (k >= oldnumAudioLanguages) {
-                          data.AudioLanguages[i] = l;
-                          break;
-                          }
-                       }
-                   }
-               data.AudioLanguages[numAudioLanguages] = -1;
-               DoSetup = true;
-               }
-            if (numSubtitleLanguages != oldnumSubtitleLanguages) {
-               for (int i = oldnumSubtitleLanguages; i < numSubtitleLanguages; i++) {
-                   data.SubtitleLanguages[i] = 0;
-                   for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                       int k;
-                       for (k = 0; k < oldnumSubtitleLanguages; k++) {
-                           if (data.SubtitleLanguages[k] == l)
-                              break;
-                           }
-                       if (k >= oldnumSubtitleLanguages) {
-                          data.SubtitleLanguages[i] = l;
-                          break;
-                          }
-                       }
-                   }
-               data.SubtitleLanguages[numSubtitleLanguages] = -1;
-               DoSetup = true;
-               }
-            if (DoSetup)
-               Setup();
-            }
-       }
-     }
-  if (state == osBack && Key == kOk) {
-     if (::Setup.PrimaryDVB != oldPrimaryDVB)
-        state = osSwitchDvb;
-     if (::Setup.VideoDisplayFormat != oldVideoDisplayFormat)
-        cDevice::PrimaryDevice()->SetVideoDisplayFormat(eVideoDisplayFormat(::Setup.VideoDisplayFormat));
-     if (::Setup.VideoFormat != oldVideoFormat)
-        cDevice::PrimaryDevice()->SetVideoFormat(::Setup.VideoFormat);
-     if (::Setup.DisplaySubtitles != oldDisplaySubtitles)
-        cDevice::PrimaryDevice()->EnsureSubtitleTrack();
-     cDvbSubtitleConverter::SetupChanged();
-     }
-  return state;
-}
-
-// --- cMenuSetupLNB ---------------------------------------------------------
-
-class cMenuSetupLNB : public cMenuSetupBase {
-private:
-  cSatCableNumbers satCableNumbers;
-  void Setup(void);
-public:
-  cMenuSetupLNB(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupLnb"; }
-  };
-
-cMenuSetupLNB::cMenuSetupLNB(void)
-:satCableNumbers(MAXDEVICES)
-{
-  SetMenuCategory(mcSetupLnb);
-  satCableNumbers.FromString(data.DeviceBondings);
-  SetSection(tr("LNB"));
-  Setup();
-}
-
-void cMenuSetupLNB::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditBoolItem(tr("Setup.LNB$Use DiSEqC"),               &data.DiSEqC));
-  if (!data.DiSEqC) {
-     Add(new cMenuEditIntItem( tr("Setup.LNB$SLOF (MHz)"),               &data.LnbSLOF));
-     Add(new cMenuEditIntItem( tr("Setup.LNB$Low LNB frequency (MHz)"),  &data.LnbFrequLo));
-     Add(new cMenuEditIntItem( tr("Setup.LNB$High LNB frequency (MHz)"), &data.LnbFrequHi));
-     }
-
-  int NumSatDevices = 0;
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat))
-         NumSatDevices++;
-      }
-  if (NumSatDevices > 1) {
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat))
-            Add(new cMenuEditIntItem(cString::sprintf(tr("Setup.LNB$Device %d connected to sat cable"), i + 1), &satCableNumbers.Array()[i], 0, NumSatDevices, tr("Setup.LNB$own")));
-         else
-            satCableNumbers.Array()[i] = 0;
-         }
-     }
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupLNB::ProcessKey(eKeys Key)
-{
-  int oldDiSEqC = data.DiSEqC;
-  bool DeviceBondingsChanged = false;
-  if (Key == kOk) {
-     cString NewDeviceBondings = satCableNumbers.ToString();
-     DeviceBondingsChanged = strcmp(data.DeviceBondings, NewDeviceBondings) != 0;
-     data.DeviceBondings = NewDeviceBondings;
-     }
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone && data.DiSEqC != oldDiSEqC)
-     Setup();
-  else if (DeviceBondingsChanged)
-     cDvbDevice::BondDevices(data.DeviceBondings);
-  return state;
-}
-
-// --- cMenuSetupCAM ---------------------------------------------------------
-
-class cMenuSetupCAMItem : public cOsdItem {
-private:
-  cCamSlot *camSlot;
-public:
-  cMenuSetupCAMItem(cCamSlot *CamSlot);
-  cCamSlot *CamSlot(void) { return camSlot; }
-  bool Changed(void);
-  };
-
-cMenuSetupCAMItem::cMenuSetupCAMItem(cCamSlot *CamSlot)
-{
-  camSlot = CamSlot;
-  SetText("");
-  Changed();
-}
-
-bool cMenuSetupCAMItem::Changed(void)
-{
-  char buffer[32];
-  const char *CamName = camSlot->GetCamName();
-  if (!CamName) {
-     switch (camSlot->ModuleStatus()) {
-       case msReset:   CamName = tr("CAM reset"); break;
-       case msPresent: CamName = tr("CAM present"); break;
-       case msReady:   CamName = tr("CAM ready"); break;
-       default:        CamName = "-"; break;
-       }
-     }
-  snprintf(buffer, sizeof(buffer), " %d %s", camSlot->SlotNumber(), CamName);
-  if (strcmp(buffer, Text()) != 0) {
-     SetText(buffer);
-     return true;
-     }
-  return false;
-}
-
-class cMenuSetupCAM : public cMenuSetupBase {
-private:
-  eOSState Menu(void);
-  eOSState Reset(void);
-public:
-  cMenuSetupCAM(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupCam"; }
-  };
-
-cMenuSetupCAM::cMenuSetupCAM(void)
-{
-  SetMenuCategory(mcSetupCam);
-  SetSection(tr("CAM"));
-  SetCols(15);
-  SetHasHotkeys();
-  for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot))
-      Add(new cMenuSetupCAMItem(CamSlot));
-  SetHelp(tr("Button$Menu"), tr("Button$Reset"));
-}
-
-eOSState cMenuSetupCAM::Menu(void)
-{
-  cMenuSetupCAMItem *item = (cMenuSetupCAMItem *)Get(Current());
-  if (item) {
-     if (item->CamSlot()->EnterMenu()) {
-        Skins.Message(mtStatus, tr("Opening CAM menu..."));
-        time_t t0 = time(NULL);
-        time_t t1 = t0;
-        while (time(NULL) - t0 <= MAXWAITFORCAMMENU) {
-              if (item->CamSlot()->HasUserIO())
-                 break;
-              if (time(NULL) - t1 >= CAMMENURETYTIMEOUT) {
-                 dsyslog("CAM %d: retrying to enter CAM menu...", item->CamSlot()->SlotNumber());
-                 item->CamSlot()->EnterMenu();
-                 t1 = time(NULL);
-                 }
-              cCondWait::SleepMs(100);
-              }
-        Skins.Message(mtStatus, NULL);
-        if (item->CamSlot()->HasUserIO())
-           return AddSubMenu(new cMenuCam(item->CamSlot()));
-        }
-     Skins.Message(mtError, tr("Can't open CAM menu!"));
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetupCAM::Reset(void)
-{
-  cMenuSetupCAMItem *item = (cMenuSetupCAMItem *)Get(Current());
-  if (item) {
-     if (!item->CamSlot()->Device() || Interface->Confirm(tr("CAM is in use - really reset?"))) {
-        if (!item->CamSlot()->Reset())
-           Skins.Message(mtError, tr("Can't reset CAM!"));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetupCAM::ProcessKey(eKeys Key)
-{
-  eOSState state = HasSubMenu() ? cMenuSetupBase::ProcessKey(Key) : cOsdMenu::ProcessKey(Key);
-
-  if (!HasSubMenu()) {
-     switch (Key) {
-       case kOk:
-       case kRed:    return Menu();
-       case kGreen:  state = Reset(); break;
-       default: break;
-       }
-     for (cMenuSetupCAMItem *ci = (cMenuSetupCAMItem *)First(); ci; ci = (cMenuSetupCAMItem *)ci->Next()) {
-         if (ci->Changed())
-            DisplayItem(ci);
-         }
-     }
-  return state;
-}
-
-// --- cMenuSetupRecord ------------------------------------------------------
-
-class cMenuSetupRecord : public cMenuSetupBase {
-private:
-  const char *pauseKeyHandlingTexts[3];
-  const char *delTimeshiftRecTexts[3];
-public:
-  cMenuSetupRecord(void);
-  };
-
-cMenuSetupRecord::cMenuSetupRecord(void)
-{
-  SetMenuCategory(mcSetupRecord);
-  pauseKeyHandlingTexts[0] = tr("do not pause live video");
-  pauseKeyHandlingTexts[1] = tr("confirm pause live video");
-  pauseKeyHandlingTexts[2] = tr("pause live video");
-  delTimeshiftRecTexts[0] = tr("no");
-  delTimeshiftRecTexts[1] = tr("confirm");
-  delTimeshiftRecTexts[2] = tr("yes");
-  SetSection(tr("Recording"));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at start (min)"),     &data.MarginStart));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at stop (min)"),      &data.MarginStop));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Default priority"),          &data.DefaultPriority, 0, MAXPRIORITY));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Default lifetime (d)"),      &data.DefaultLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Use VPS"),                   &data.UseVps));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$VPS margin (s)"),            &data.VpsMargin, 0));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Mark instant recording"),    &data.MarkInstantRecord));
-  Add(new cMenuEditStrItem( tr("Setup.Recording$Name instant recording"),     data.NameInstantRecord, sizeof(data.NameInstantRecord)));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 0, MAXINSTANTRECTIME, tr("Setup.Recording$present event")));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZETS));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"),&data.DelTimeshiftRec, 3, delTimeshiftRecTexts));
-}
-
-// --- cMenuSetupReplay ------------------------------------------------------
-
-class cMenuSetupReplay : public cMenuSetupBase {
-protected:
-  virtual void Store(void);
-public:
-  cMenuSetupReplay(void);
-  };
-
-cMenuSetupReplay::cMenuSetupReplay(void)
-{
-  SetMenuCategory(mcSetupReplay);
-  SetSection(tr("Replay"));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Multi speed mode"), &data.MultiSpeedMode));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Show replay mode"), &data.ShowReplayMode));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Show remaining time"), &data.ShowRemainingTime));
-  Add(new cMenuEditIntItem( tr("Setup.Replay$Progress display time (s)"), &data.ProgressDisplayTime, 0, 60));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause replay when setting mark"), &data.PauseOnMarkSet));
-  Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"), &data.JumpPlay));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"), &data.PlayJump));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds"), &data.JumpSeconds));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds Slow"), &data.JumpSecondsSlow));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds (Repeat)"), &data.JumpSecondsRepeat));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
-}
-
-void cMenuSetupReplay::Store(void)
-{
-  if (Setup.ResumeID != data.ResumeID)
-     Recordings.ResetResume();
-  cMenuSetupBase::Store();
-}
-
-// --- cMenuSetupMisc --------------------------------------------------------
-
-class cMenuSetupMisc : public cMenuSetupBase {
-public:
-  cMenuSetupMisc(void);
-  };
-
-cMenuSetupMisc::cMenuSetupMisc(void)
-{
-  SetMenuCategory(mcSetupMisc);
-  SetSection(tr("Miscellaneous"));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. event timeout (min)"),   &data.MinEventTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. user inactivity (min)"), &data.MinUserInactivity));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$SVDRP timeout (s)"),          &data.SVDRPTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Zap timeout (s)"),            &data.ZapTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Channel entry timeout (ms)"), &data.ChannelEntryTimeout, 0));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Remote control repeat delay (ms)"), &data.RcRepeatDelay, 0));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Remote control repeat delta (ms)"), &data.RcRepeatDelta, 0));
-  Add(new cMenuEditChanItem(tr("Setup.Miscellaneous$Initial channel"),            &data.InitialChannel, tr("Setup.Miscellaneous$as before")));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Initial volume"),             &data.InitialVolume, -1, 255, tr("Setup.Miscellaneous$as before")));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Volume steps"),               &data.VolumeSteps, 5, 255));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Volume linearize"),           &data.VolumeLinearize, -20, 20));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Channels wrap"),              &data.ChannelsWrap));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Show channel names with source"), &data.ShowChannelNamesWithSource));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Emergency exit"),             &data.EmergencyExit));
-}
-
-// --- cMenuSetupPluginItem --------------------------------------------------
-
-class cMenuSetupPluginItem : public cOsdItem {
-private:
-  int pluginIndex;
-public:
-  cMenuSetupPluginItem(const char *Name, int Index);
-  int PluginIndex(void) { return pluginIndex; }
-  };
-
-cMenuSetupPluginItem::cMenuSetupPluginItem(const char *Name, int Index)
-:cOsdItem(Name)
-{
-  pluginIndex = Index;
-}
-
-// --- cMenuSetupPlugins -----------------------------------------------------
-
-class cMenuSetupPlugins : public cMenuSetupBase {
-public:
-  cMenuSetupPlugins(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
-  };
-
-cMenuSetupPlugins::cMenuSetupPlugins(void)
-{
-  SetMenuCategory(mcSetupPlugins);
-  SetSection(tr("Plugins"));
-  SetHasHotkeys();
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p)
-         Add(new cMenuSetupPluginItem(hk(cString::sprintf("%s (%s) - %s", p->Name(), p->Version(), p->Description())), i));
-      else
-         break;
-      }
-}
-
-eOSState cMenuSetupPlugins::ProcessKey(eKeys Key)
-{
-  eOSState state = HasSubMenu() ? cMenuSetupBase::ProcessKey(Key) : cOsdMenu::ProcessKey(Key);
-
-  if (Key == kOk) {
-     if (state == osUnknown) {
-        cMenuSetupPluginItem *item = (cMenuSetupPluginItem *)Get(Current());
-        if (item) {
-           cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
-           if (p) {
-              cMenuSetupPage *menu = p->SetupMenu();
-              if (menu) {
-                 menu->SetPlugin(p);
-                 return AddSubMenu(menu);
-                 }
-              Skins.Message(mtInfo, tr("This plugin has no setup parameters!"));
-              }
-           }
-        }
-     else if (state == osContinue) {
-        Store();
-        // Reinitialize OSD and skin, in case any plugin setup change has an influence on these:
-        cOsdProvider::UpdateOsdSize(true);
-        SetDisplayMenu();
-        Display();
-        }
-     }
-  return state;
-}
-
-// --- cMenuSetup ------------------------------------------------------------
-
-class cMenuSetup : public cOsdMenu {
-private:
-  virtual void Set(void);
-  eOSState Restart(void);
-public:
-  cMenuSetup(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetup"; }
-  };
-
-cMenuSetup::cMenuSetup(void)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcSetup);
-  Set();
-}
-
-void cMenuSetup::Set(void)
-{
-  Clear();
-  char buffer[64];
-  snprintf(buffer, sizeof(buffer), "%s - VDR %s", tr("Setup"), VDRVERSION);
-  SetTitle(buffer);
-  SetHasHotkeys();
-  Add(new cOsdItem(hk(tr("OSD")),           osUser1));
-  Add(new cOsdItem(hk(tr("EPG")),           osUser2));
-  Add(new cOsdItem(hk(tr("DVB")),           osUser3));
-  Add(new cOsdItem(hk(tr("LNB")),           osUser4));
-  Add(new cOsdItem(hk(tr("CAM")),           osUser5));
-  Add(new cOsdItem(hk(tr("Recording")),     osUser6));
-  Add(new cOsdItem(hk(tr("Replay")),        osUser7));
-  Add(new cOsdItem(hk(tr("Miscellaneous")), osUser8));
-  if (cPluginManager::HasPlugins())
-  Add(new cOsdItem(hk(tr("Plugins")),       osUser9));
-  Add(new cOsdItem(hk(tr("Restart")),       osUser10));
-}
-
-eOSState cMenuSetup::Restart(void)
-{
-  if (Interface->Confirm(tr("Really restart?")) && ShutdownHandler.ConfirmRestart(true)) {
-     ShutdownHandler.Exit(1);
-     return osEnd;
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetup::ProcessKey(eKeys Key)
-{
-  int osdLanguage = I18nCurrentLanguage();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  switch (state) {
-    case osUser1: return AddSubMenu(new cMenuSetupOSD);
-    case osUser2: return AddSubMenu(new cMenuSetupEPG);
-    case osUser3: return AddSubMenu(new cMenuSetupDVB);
-    case osUser4: return AddSubMenu(new cMenuSetupLNB);
-    case osUser5: return AddSubMenu(new cMenuSetupCAM);
-    case osUser6: return AddSubMenu(new cMenuSetupRecord);
-    case osUser7: return AddSubMenu(new cMenuSetupReplay);
-    case osUser8: return AddSubMenu(new cMenuSetupMisc);
-    case osUser9: return AddSubMenu(new cMenuSetupPlugins);
-    case osUser10: return Restart();
-    default: ;
-    }
-  if (I18nCurrentLanguage() != osdLanguage) {
-     Set();
-     if (!HasSubMenu())
-        Display();
-     }
-  return state;
-}
-
-// --- cMenuPluginItem -------------------------------------------------------
-
-class cMenuPluginItem : public cOsdItem {
-private:
-  int pluginIndex;
-public:
-  cMenuPluginItem(const char *Name, int Index);
-  int PluginIndex(void) { return pluginIndex; }
-  };
-
-cMenuPluginItem::cMenuPluginItem(const char *Name, int Index)
-:cOsdItem(Name, osPlugin)
-{
-  pluginIndex = Index;
-}
-
-// --- cMenuMain -------------------------------------------------------------
-
-// TRANSLATORS: note the leading and trailing blanks!
-#define STOP_RECORDING trNOOP(" Stop recording ")
-
-cOsdObject *cMenuMain::pluginOsdObject = NULL;
-
-cMenuMain::cMenuMain(eOSState State, bool OpenSubMenus)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcMain);
-  replaying = false;
-  stopReplayItem = NULL;
-  cancelEditingItem = NULL;
-  cancelFileTransferItem = NULL;
-  stopRecordingItem = NULL;
-  recordControlsState = 0;
-
-  MenuOrgPatch::EnterRootMenu();
-
-  Set();
-
-  // Initial submenus:
-
-  cOsdObject *menu = NULL;
-  switch (State) {
-    case osSchedule:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
-            menu = new cMenuSchedule;
-        break;
-    case osChannels:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
-            menu = new cMenuChannels;
-        break;
-    case osTimers:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
-            menu = new cMenuTimers;
-        break;
-    case osRecordings:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
-            menu = new cMenuRecordings(NULL, 0, true);
-        break;
-    case osSetup:      menu = new cMenuSetup; break;
-    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
-    default: break;
-    }
-  if (menu)
-     if (menu->IsMenu())
-        AddSubMenu((cOsdMenu *) menu);
-}
-
-cOsdObject *cMenuMain::PluginOsdObject(void)
-{
-  cOsdObject *o = pluginOsdObject;
-  pluginOsdObject = NULL;
-  return o;
-}
-
-void cMenuMain::Set(void)
-{
-  Clear();
-  SetTitle("VDR");
-  SetHasHotkeys();
-
-  if (MenuOrgPatch::IsCustomMenuAvailable()) {
-     MenuItemDefinitions* menuItems = MenuOrgPatch::MainMenuItems();
-     for (MenuItemDefinitions::iterator i = menuItems->begin(); i != menuItems->end(); i++) {
-         cOsdItem* osdItem = NULL;
-         if ((*i)->IsCustomOsdItem()) {
-            osdItem = (*i)->CustomOsdItem();
-            if (osdItem &&  !(*i)->IsSeparatorItem())
-                   osdItem->SetText(hk(osdItem->Text()));
-            }
-         else if ((*i)->IsPluginItem()) {
-            const char *item = (*i)->PluginMenuEntry();
-            if (item)
-              osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
-            }
-         if (osdItem) {
-            Add(osdItem);
-            if ((*i)->IsSelected())
-               SetCurrent(osdItem);
-            }
-         }
-     }
-  else {
-
-  // Basic menu items:
-
-  Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  Add(new cOsdItem(hk(tr("Timers")),     osTimers));
-  Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
-
-  // Plugins:
-
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p) {
-         const char *item = p->MainMenuEntry();
-         if (item)
-            Add(new cMenuPluginItem(hk(item), i));
-         }
-      else
-         break;
-      }
-
-  // More basic menu items:
-
-  Add(new cOsdItem(hk(tr("Setup")),      osSetup));
-  if (Commands.Count())
-     Add(new cOsdItem(hk(tr("Commands")),  osCommands));
-
-  }
-
-  Update(true);
-
-  Display();
-}
-
-bool cMenuMain::Update(bool Force)
-{
-  bool result = false;
-
-  bool NewReplaying = cControl::Control() != NULL;
-  if (Force || NewReplaying != replaying) {
-     replaying = NewReplaying;
-     // Replay control:
-     if (replaying && !stopReplayItem)
-        // TRANSLATORS: note the leading blank!
-        Add(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay));
-     else if (stopReplayItem && !replaying) {
-        Del(stopReplayItem->Index());
-        stopReplayItem = NULL;
-        }
-     // Color buttons:
-     SetHelp(!replaying ? tr("Button$Record") : NULL, tr("Button$Audio"), replaying || !Setup.PauseKeyHandling ? NULL : tr("Button$Pause"), replaying ? tr("Button$Stop") : cReplayControl::LastReplayed() ? tr("Button$Resume") : tr("Button$Play"));
-     result = true;
-     }
-
-  // Editing control:
-  bool CutterActive = cCutter::Active();
-  if (CutterActive && !cancelEditingItem) {
-     // TRANSLATORS: note the leading blank!
-     Add(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit));
-     result = true;
-     }
-  else if (cancelEditingItem && !CutterActive) {
-     Del(cancelEditingItem->Index());
-     cancelEditingItem = NULL;
-     result = true;
-     }
-
-  // File transfer control:
-  bool FileTransferActive = cFileTransfer::Active();
-  if (FileTransferActive && !cancelFileTransferItem) {
-     // TRANSLATORS: note the leading blank!
-     Add(cancelFileTransferItem = new cOsdItem(tr(" Cancel file transfer"), osCancelTransfer));
-     result = true;
-     }
-  else if (cancelFileTransferItem && !FileTransferActive) {
-     Del(cancelFileTransferItem->Index());
-     cancelFileTransferItem = NULL;
-     result = true;
-     }
-
-  // Record control:
-  if (cRecordControls::StateChanged(recordControlsState)) {
-     while (stopRecordingItem) {
-           cOsdItem *it = Next(stopRecordingItem);
-           Del(stopRecordingItem->Index());
-           stopRecordingItem = it;
-           }
-     const char *s = NULL;
-     while ((s = cRecordControls::GetInstantId(s)) != NULL) {
-           cOsdItem *item = new cOsdItem(osStopRecord);
-           item->SetText(cString::sprintf("%s%s", tr(STOP_RECORDING), s));
-           Add(item);
-           if (!stopRecordingItem)
-              stopRecordingItem = item;
-           }
-     result = true;
-     }
-
-  return result;
-}
-
-eOSState cMenuMain::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  int osdLanguage = I18nCurrentLanguage();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-  HadSubMenu |= HasSubMenu();
-
-  cOsdObject *menu = NULL;
-  switch (state) {
-    case osSchedule:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
-            menu = new cMenuSchedule;
-        else
-            state = osContinue;
-        break;
-    case osChannels:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
-            menu = new cMenuChannels;
-        else
-            state = osContinue;
-        break;
-    case osTimers:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
-            menu = new cMenuTimers;
-        else
-            state = osContinue;
-        break;
-    case osRecordings:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
-            menu = new cMenuRecordings;
-        else
-            state = osContinue;
-        break;
-    case osSetup:      menu = new cMenuSetup; break;
-    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
-    case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
-                          cOsdItem *item = Get(Current());
-                          if (item) {
-                             cRecordControls::Stop(item->Text() + strlen(tr(STOP_RECORDING)));
-                             return osEnd;
-                             }
-                          }
-                       break;
-    case osCancelEdit: if (Interface->Confirm(tr("Cancel editing?"))) {
-                          cCutter::Stop();
-                          return osEnd;
-                          }
-                       break;
-    case osCancelTransfer:
-                       if (Interface->Confirm(tr("Cancel file transfer?"))) {
-                          cFileTransfer::Stop();
-                          return osEnd;
-                          }
-                       break;
-    case osPlugin:     {
-                         cMenuPluginItem *item = (cMenuPluginItem *)Get(Current());
-                         if (item) {
-                            cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
-                            if (p) {
-                               cOsdObject *menu = p->MainMenuAction();
-                               if (menu) {
-                                  if (menu->IsMenu())
-                                     return AddSubMenu((cOsdMenu *)menu);
-                                  else {
-                                     pluginOsdObject = menu;
-                                     return osPlugin;
-                                     }
-                                  }
-                               }
-                            }
-                         state = osEnd;
-                       }
-                       break;
-    case osBack:       {
-                          if (MenuOrgPatch::IsCustomMenuAvailable())
-                          {
-                            bool leavingMenuSucceeded = MenuOrgPatch::LeaveSubMenu();
-                            Set();
-                            stopReplayItem = NULL;
-                            cancelEditingItem = NULL;
-                            stopRecordingItem = NULL;
-                            recordControlsState = 0;
-                            Update(true);
-                            Display();
-                            if (leavingMenuSucceeded)
-                              return osContinue;
-                            else
-                              return osEnd;
-                          }
-                       }
-                       break;
-    case osUser1:      {
-                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
-                            MenuOrgPatch::EnterSubMenu(Get(Current()));
-                            Set();
-                            return osContinue;
-                          }
-                       }
-                       break;
-    case osUser2:      {
-                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
-                            cOsdMenu* osdMenu = MenuOrgPatch::Execute(Get(Current()));
-                            if (osdMenu)
-                              return AddSubMenu(osdMenu);
-                            return osEnd;
-                          }
-                       }
-                       break;
-    default: switch (Key) {
-               case kRecord:
-               case kRed:    if (!HadSubMenu)
-                                state = replaying ? osContinue : osRecord;
-                             break;
-               case kGreen:  if (!HadSubMenu) {
-                                cRemote::Put(kAudio, true);
-                                state = osEnd;
-                                }
-                             break;
-               case kYellow: if (!HadSubMenu)
-                                state = replaying || !Setup.PauseKeyHandling ? osContinue : osPause;
-                             break;
-               case kBlue:   if (!HadSubMenu)
-                                state = replaying ? osStopReplay : cReplayControl::LastReplayed() ? osReplay : osRecordings;
-                             break;
-               default:      break;
-               }
-    }
-  if (menu) {
-     if (menu->IsMenu())
-        return AddSubMenu((cOsdMenu *) menu);
-     pluginOsdObject = menu;
-     return osPlugin;
-  }
-  if (!HasSubMenu() && Update(HadSubMenu))
-     Display();
-  if (Key != kNone) {
-     if (I18nCurrentLanguage() != osdLanguage) {
-        Set();
-        if (!HasSubMenu())
-           Display();
-        }
-     }
-  return state;
-}
-
-// --- SetTrackDescriptions --------------------------------------------------
-
-static void SetTrackDescriptions(int LiveChannel)
-{
-  cDevice::PrimaryDevice()->ClrAvailableTracks(true);
-  const cComponents *Components = NULL;
-  cSchedulesLock SchedulesLock;
-  if (LiveChannel) {
-     cChannel *Channel = Channels.GetByNumber(LiveChannel);
-     if (Channel) {
-        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-        if (Schedules) {
-           const cSchedule *Schedule = Schedules->GetSchedule(Channel);
-           if (Schedule) {
-              const cEvent *Present = Schedule->GetPresentEvent();
-              if (Present)
-                 Components = Present->Components();
-              }
-           }
-        }
-     }
-  else if (cReplayControl::NowReplaying()) {
-     cThreadLock RecordingsLock(&Recordings);
-     cRecording *Recording = Recordings.GetByName(cReplayControl::NowReplaying());
-     if (Recording)
-        Components = Recording->Info()->Components();
-     }
-  if (Components) {
-     int indexAudio = 0;
-     int indexDolby = 0;
-     int indexSubtitle = 0;
-     for (int i = 0; i < Components->NumComponents(); i++) {
-         const tComponent *p = Components->Component(i);
-         switch (p->stream) {
-           case 2: if (p->type == 0x05)
-                      cDevice::PrimaryDevice()->SetAvailableTrack(ttDolby, indexDolby++, 0, LiveChannel ? NULL : p->language, p->description);
-                   else
-                      cDevice::PrimaryDevice()->SetAvailableTrack(ttAudio, indexAudio++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           case 3: cDevice::PrimaryDevice()->SetAvailableTrack(ttSubtitle, indexSubtitle++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           case 4: cDevice::PrimaryDevice()->SetAvailableTrack(ttDolby, indexDolby++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           default: ;
-           }
-         }
-     }
-}
-
-// --- cDisplayChannel -------------------------------------------------------
-
-cDisplayChannel *cDisplayChannel::currentDisplayChannel = NULL;
-
-cDisplayChannel::cDisplayChannel(int Number, bool Switched)
-:cOsdObject(true)
-{
-  currentDisplayChannel = this;
-  group = -1;
-  withInfo = !Switched || Setup.ShowInfoOnChSwitch;
-  displayChannel = Skins.Current()->DisplayChannel(withInfo);
-  number = 0;
-  timeout = Switched || Setup.TimeoutRequChInfo;
-  channel = Channels.GetByNumber(Number);
-  lastPresent = lastFollowing = NULL;
-  if (channel) {
-     DisplayChannel();
-     DisplayInfo();
-     displayChannel->Flush();
-     }
-  lastTime.Set();
-}
-
-cDisplayChannel::cDisplayChannel(eKeys FirstKey)
-:cOsdObject(true)
-{
-  currentDisplayChannel = this;
-  group = -1;
-  number = 0;
-  timeout = true;
-  lastPresent = lastFollowing = NULL;
-  lastTime.Set();
-  withInfo = Setup.ShowInfoOnChSwitch;
-  displayChannel = Skins.Current()->DisplayChannel(withInfo);
-  channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  ProcessKey(FirstKey);
-}
-
-cDisplayChannel::~cDisplayChannel()
-{
-  delete displayChannel;
-  cStatus::MsgOsdClear();
-  currentDisplayChannel = NULL;
-}
-
-void cDisplayChannel::DisplayChannel(void)
-{
-  displayChannel->SetChannel(channel, number);
-  cStatus::MsgOsdChannel(ChannelString(channel, number));
-  lastPresent = lastFollowing = NULL;
-}
-
-void cDisplayChannel::DisplayInfo(void)
-{
-  if (withInfo && channel) {
-     cSchedulesLock SchedulesLock;
-     const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-     if (Schedules) {
-        const cSchedule *Schedule = Schedules->GetSchedule(channel);
-        if (Schedule) {
-           const cEvent *Present = Schedule->GetPresentEvent();
-           const cEvent *Following = Schedule->GetFollowingEvent();
-           if (Present != lastPresent || Following != lastFollowing) {
-              SetTrackDescriptions(channel->Number());
-              displayChannel->SetEvents(Present, Following);
-              cStatus::MsgOsdProgramme(Present ? Present->StartTime() : 0, Present ? Present->Title() : NULL, Present ? Present->ShortText() : NULL, Following ? Following->StartTime() : 0, Following ? Following->Title() : NULL, Following ? Following->ShortText() : NULL);
-              lastPresent = Present;
-              lastFollowing = Following;
-              }
-           }
-        }
-     }
-}
-
-void cDisplayChannel::Refresh(void)
-{
-  DisplayChannel();
-  displayChannel->SetEvents(NULL, NULL);
-}
-
-cChannel *cDisplayChannel::NextAvailableChannel(cChannel *Channel, int Direction)
-{
-  if (Direction) {
-     while (Channel) {
-           Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
-           if (!Channel && Setup.ChannelsWrap)
-              Channel = Direction > 0 ? Channels.First() : Channels.Last();
-           if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, LIVEPRIORITY, true, true))
-              return Channel;
-           }
-     }
-  return NULL;
-}
-
-eOSState cDisplayChannel::ProcessKey(eKeys Key)
-{
-  cChannel *NewChannel = NULL;
-  if (Key != kNone)
-     lastTime.Set();
-  switch (int(Key)) {
-    case k0:
-         if (number == 0) {
-            // keep the "Toggle channels" function working
-            cRemote::Put(Key);
-            return osEnd;
-            }
-    case k1 ... k9:
-         group = -1;
-         if (number >= 0) {
-            if (number > Channels.MaxNumber())
-               number = Key - k0;
-            else
-               number = number * 10 + Key - k0;
-            channel = Channels.GetByNumber(number);
-            Refresh();
-            withInfo = false;
-            // Lets see if there can be any useful further input:
-            int n = channel ? number * 10 : 0;
-            int m = 10;
-            cChannel *ch = channel;
-            while (ch && (ch = Channels.Next(ch)) != NULL) {
-                  if (!ch->GroupSep()) {
-                     if (n <= ch->Number() && ch->Number() < n + m) {
-                        n = 0;
-                        break;
-                        }
-                     if (ch->Number() > n) {
-                        n *= 10;
-                        m *= 10;
-                        }
-                     }
-                  }
-            if (n > 0) {
-               // This channel is the only one that fits the input, so let's take it right away:
-               NewChannel = channel;
-               withInfo = true;
-               number = 0;
-               Refresh();
-               }
-            }
-         break;
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-    case kNext|k_Repeat:
-    case kNext:
-    case kPrev|k_Repeat:
-    case kPrev:
-         withInfo = false;
-         number = 0;
-         if (group < 0) {
-            cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-            if (channel)
-               group = channel->Index();
-            }
-         if (group >= 0) {
-            int SaveGroup = group;
-            if (NORMALKEY(Key) == kRight || NORMALKEY(Key) == kNext)
-               group = Channels.GetNextGroup(group) ;
-            else
-               group = Channels.GetPrevGroup(group < 1 ? 1 : group);
-            if (group < 0)
-               group = SaveGroup;
-            channel = Channels.Get(group);
-            if (channel) {
-               Refresh();
-               if (!channel->GroupSep())
-                  group = -1;
-               }
-            }
-         break;
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kChanUp|k_Repeat:
-    case kChanUp:
-    case kChanDn|k_Repeat:
-    case kChanDn: {
-         eKeys k = NORMALKEY(Key);
-         cChannel *ch = NextAvailableChannel(channel, (k == kUp || k == kChanUp) ? 1 : -1);
-         if (ch)
-            channel = ch;
-         else if (channel && channel->Number() != cDevice::CurrentChannel())
-            Key = k; // immediately switches channel when hitting the beginning/end of the channel list with k_Repeat
-         }
-         // no break here
-    case kUp|k_Release:
-    case kDown|k_Release:
-    case kChanUp|k_Release:
-    case kChanDn|k_Release:
-    case kNext|k_Release:
-    case kPrev|k_Release:
-         if (!(Key & k_Repeat) && channel && channel->Number() != cDevice::CurrentChannel())
-            NewChannel = channel;
-         withInfo = true;
-         group = -1;
-         number = 0;
-         Refresh();
-         break;
-    case kNone:
-         if (number && Setup.ChannelEntryTimeout && int(lastTime.Elapsed()) > Setup.ChannelEntryTimeout) {
-            channel = Channels.GetByNumber(number);
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            number = 0;
-            Refresh();
-            lastTime.Set();
-            }
-         break;
-    //TODO
-    //XXX case kGreen:  return osEventNow;
-    //XXX case kYellow: return osEventNext;
-    case kOk:
-         if (group >= 0) {
-            channel = Channels.Get(Channels.GetNextNormal(group));
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            group = -1;
-            Refresh();
-            }
-         else if (number > 0) {
-            channel = Channels.GetByNumber(number);
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            number = 0;
-            Refresh();
-            }
-         else
-            return osEnd;
-         break;
-    default:
-         if ((Key & (k_Repeat | k_Release)) == 0) {
-            cRemote::Put(Key);
-            return osEnd;
-            }
-    };
-  if (!timeout || lastTime.Elapsed() < (uint64_t)(Setup.ChannelInfoTime * 1000)) {
-     if (Key == kNone && !number && group < 0 && !NewChannel && channel && channel->Number() != cDevice::CurrentChannel()) {
-        // makes sure a channel switch through the SVDRP CHAN command is displayed
-        channel = Channels.GetByNumber(cDevice::CurrentChannel());
-        Refresh();
-        lastTime.Set();
-        }
-     DisplayInfo();
-     displayChannel->Flush();
-     if (NewChannel) {
-        SetTrackDescriptions(NewChannel->Number()); // to make them immediately visible in the channel display
-        Channels.SwitchTo(NewChannel->Number());
-        SetTrackDescriptions(NewChannel->Number()); // switching the channel has cleared them
-        channel = NewChannel;
-        }
-     return osContinue;
-     }
-  return osEnd;
-}
-
-// --- cDisplayVolume --------------------------------------------------------
-
-#define VOLUMETIMEOUT 1000 //ms
-#define MUTETIMEOUT   5000 //ms
-
-cDisplayVolume *cDisplayVolume::currentDisplayVolume = NULL;
-
-cDisplayVolume::cDisplayVolume(void)
-:cOsdObject(true)
-{
-  currentDisplayVolume = this;
-  timeout.Set(cDevice::PrimaryDevice()->IsMute() ? MUTETIMEOUT : VOLUMETIMEOUT);
-  displayVolume = Skins.Current()->DisplayVolume();
-  Show();
-}
-
-cDisplayVolume::~cDisplayVolume()
-{
-  delete displayVolume;
-  currentDisplayVolume = NULL;
-}
-
-void cDisplayVolume::Show(void)
-{
-  displayVolume->SetVolume(cDevice::CurrentVolume(), MAXVOLUME, cDevice::PrimaryDevice()->IsMute());
-}
-
-cDisplayVolume *cDisplayVolume::Create(void)
-{
-  if (!currentDisplayVolume)
-     new cDisplayVolume;
-  return currentDisplayVolume;
-}
-
-void cDisplayVolume::Process(eKeys Key)
-{
-  if (currentDisplayVolume)
-     currentDisplayVolume->ProcessKey(Key);
-}
-
-eOSState cDisplayVolume::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kVolUp|k_Repeat:
-    case kVolUp:
-    case kVolDn|k_Repeat:
-    case kVolDn:
-         Show();
-         timeout.Set(VOLUMETIMEOUT);
-         break;
-    case kMute:
-         if (cDevice::PrimaryDevice()->IsMute()) {
-            Show();
-            timeout.Set(MUTETIMEOUT);
-            }
-         else
-            timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0) {
-                cRemote::Put(Key);
-                return osEnd;
-                }
-    }
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cDisplayTracks --------------------------------------------------------
-
-#define TRACKTIMEOUT 5000 //ms
-
-cDisplayTracks *cDisplayTracks::currentDisplayTracks = NULL;
-
-cDisplayTracks::cDisplayTracks(void)
-:cOsdObject(true)
-{
-  cDevice::PrimaryDevice()->EnsureAudioTrack();
-  SetTrackDescriptions(!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring() ? cDevice::CurrentChannel() : 0);
-  currentDisplayTracks = this;
-  numTracks = track = 0;
-  audioChannel = cDevice::PrimaryDevice()->GetAudioChannel();
-  eTrackType CurrentAudioTrack = cDevice::PrimaryDevice()->GetCurrentAudioTrack();
-  for (int i = ttAudioFirst; i <= ttDolbyLast; i++) {
-      const tTrackId *TrackId = cDevice::PrimaryDevice()->GetTrack(eTrackType(i));
-      if (TrackId && TrackId->id) {
-         types[numTracks] = eTrackType(i);
-         descriptions[numTracks] = strdup(*TrackId->description ? TrackId->description : *TrackId->language ? TrackId->language : *itoa(i));
-         if (i == CurrentAudioTrack)
-            track = numTracks;
-         numTracks++;
-         }
-      }
-  descriptions[numTracks] = NULL;
-  timeout.Set(TRACKTIMEOUT);
-  displayTracks = Skins.Current()->DisplayTracks(tr("Button$Audio"), numTracks, descriptions);
-  Show();
-}
-
-cDisplayTracks::~cDisplayTracks()
-{
-  delete displayTracks;
-  currentDisplayTracks = NULL;
-  for (int i = 0; i < numTracks; i++)
-      free(descriptions[i]);
-  cStatus::MsgOsdClear();
-}
-
-void cDisplayTracks::Show(void)
-{
-  int ac = IS_AUDIO_TRACK(types[track]) ? audioChannel : -1;
-  displayTracks->SetTrack(track, descriptions);
-  displayTracks->SetAudioChannel(ac);
-  displayTracks->Flush();
-  cStatus::MsgSetAudioTrack(track, descriptions);
-  cStatus::MsgSetAudioChannel(ac);
-}
-
-cDisplayTracks *cDisplayTracks::Create(void)
-{
-  if (cDevice::PrimaryDevice()->NumAudioTracks() > 0) {
-     if (!currentDisplayTracks)
-        new cDisplayTracks;
-     return currentDisplayTracks;
-     }
-  Skins.Message(mtWarning, tr("No audio available!"));
-  return NULL;
-}
-
-void cDisplayTracks::Process(eKeys Key)
-{
-  if (currentDisplayTracks)
-     currentDisplayTracks->ProcessKey(Key);
-}
-
-eOSState cDisplayTracks::ProcessKey(eKeys Key)
-{
-  int oldTrack = track;
-  int oldAudioChannel = audioChannel;
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-         if (NORMALKEY(Key) == kUp && track > 0)
-            track--;
-         else if (NORMALKEY(Key) == kDown && track < numTracks - 1)
-            track++;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight: if (IS_AUDIO_TRACK(types[track])) {
-                    static int ac[] = { 1, 0, 2 };
-                    audioChannel = ac[cDevice::PrimaryDevice()->GetAudioChannel()];
-                    if (NORMALKEY(Key) == kLeft && audioChannel > 0)
-                       audioChannel--;
-                    else if (NORMALKEY(Key) == kRight && audioChannel < 2)
-                       audioChannel++;
-                    audioChannel = ac[audioChannel];
-                    timeout.Set(TRACKTIMEOUT);
-                    }
-         break;
-    case kAudio|k_Repeat:
-    case kAudio:
-         if (++track >= numTracks)
-            track = 0;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kOk:
-         if (types[track] != cDevice::PrimaryDevice()->GetCurrentAudioTrack())
-            oldTrack = -1; // make sure we explicitly switch to that track
-         timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0)
-                return osEnd;
-    }
-  if (track != oldTrack || audioChannel != oldAudioChannel)
-     Show();
-  if (track != oldTrack) {
-     cDevice::PrimaryDevice()->SetCurrentAudioTrack(types[track]);
-     Setup.CurrentDolby = IS_DOLBY_TRACK(types[track]);
-     }
-  if (audioChannel != oldAudioChannel)
-     cDevice::PrimaryDevice()->SetAudioChannel(audioChannel);
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cDisplaySubtitleTracks ------------------------------------------------
-
-cDisplaySubtitleTracks *cDisplaySubtitleTracks::currentDisplayTracks = NULL;
-
-cDisplaySubtitleTracks::cDisplaySubtitleTracks(void)
-:cOsdObject(true)
-{
-  SetTrackDescriptions(!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring() ? cDevice::CurrentChannel() : 0);
-  currentDisplayTracks = this;
-  numTracks = track = 0;
-  types[numTracks] = ttNone;
-  descriptions[numTracks] = strdup(tr("No subtitles"));
-  numTracks++;
-  eTrackType CurrentSubtitleTrack = cDevice::PrimaryDevice()->GetCurrentSubtitleTrack();
-  for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
-      const tTrackId *TrackId = cDevice::PrimaryDevice()->GetTrack(eTrackType(i));
-      if (TrackId && TrackId->id) {
-         types[numTracks] = eTrackType(i);
-         descriptions[numTracks] = strdup(*TrackId->description ? TrackId->description : *TrackId->language ? TrackId->language : *itoa(i));
-         if (i == CurrentSubtitleTrack)
-            track = numTracks;
-         numTracks++;
-         }
-      }
-  descriptions[numTracks] = NULL;
-  timeout.Set(TRACKTIMEOUT);
-  displayTracks = Skins.Current()->DisplayTracks(tr("Button$Subtitles"), numTracks, descriptions);
-  Show();
-}
-
-cDisplaySubtitleTracks::~cDisplaySubtitleTracks()
-{
-  delete displayTracks;
-  currentDisplayTracks = NULL;
-  for (int i = 0; i < numTracks; i++)
-      free(descriptions[i]);
-  cStatus::MsgOsdClear();
-}
-
-void cDisplaySubtitleTracks::Show(void)
-{
-  displayTracks->SetTrack(track, descriptions);
-  displayTracks->Flush();
-  cStatus::MsgSetSubtitleTrack(track, descriptions);
-}
-
-cDisplaySubtitleTracks *cDisplaySubtitleTracks::Create(void)
-{
-  if (cDevice::PrimaryDevice()->NumSubtitleTracks() > 0) {
-     if (!currentDisplayTracks)
-        new cDisplaySubtitleTracks;
-     return currentDisplayTracks;
-     }
-  Skins.Message(mtWarning, tr("No subtitles available!"));
-  return NULL;
-}
-
-void cDisplaySubtitleTracks::Process(eKeys Key)
-{
-  if (currentDisplayTracks)
-     currentDisplayTracks->ProcessKey(Key);
-}
-
-eOSState cDisplaySubtitleTracks::ProcessKey(eKeys Key)
-{
-  int oldTrack = track;
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-         if (NORMALKEY(Key) == kUp && track > 0)
-            track--;
-         else if (NORMALKEY(Key) == kDown && track < numTracks - 1)
-            track++;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kSubtitles|k_Repeat:
-    case kSubtitles:
-         if (++track >= numTracks)
-            track = 0;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kOk:
-         if (types[track] != cDevice::PrimaryDevice()->GetCurrentSubtitleTrack())
-            oldTrack = -1; // make sure we explicitly switch to that track
-         timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0)
-                return osEnd;
-    }
-  if (track != oldTrack) {
-     Show();
-     cDevice::PrimaryDevice()->SetCurrentSubtitleTrack(types[track], true);
-     }
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cRecordControl --------------------------------------------------------
-
-cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
-{
-  // Whatever happens here, the timers will be modified in some way...
-  Timers.SetModified();
-  // We're going to manipulate an event here, so we need to prevent
-  // others from modifying any EPG data:
-  cSchedulesLock SchedulesLock;
-  cSchedules::Schedules(SchedulesLock);
-
-  event = NULL;
-  fileName = NULL;
-  recorder = NULL;
-  device = Device;
-  if (!device) device = cDevice::PrimaryDevice();//XXX
-  timer = Timer;
-  if (!timer) {
-     timer = new cTimer(true, Pause);
-     Timers.Add(timer);
-     instantId = cString::sprintf(cDevice::NumDevices() > 1 ? "%s - %d" : "%s", timer->Channel()->Name(), device->CardIndex() + 1);
-     }
-  timer->SetPending(true);
-  timer->SetRecording(true);
-  event = timer->Event();
-
-  if (event || GetEvent())
-     dsyslog("Title: '%s' Subtitle: '%s'", event->Title(), event->ShortText());
-  cRecording Recording(timer, event);
-  fileName = strdup(Recording.FileName());
-
-  // crude attempt to avoid duplicate recordings:
-  if (cRecordControls::GetRecordControl(fileName)) {
-     isyslog("already recording: '%s'", fileName);
-     if (Timer) {
-        timer->SetPending(false);
-        timer->SetRecording(false);
-        timer->OnOff();
-        }
-     else {
-        Timers.Del(timer);
-        if (!cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
-           cReplayControl::SetRecording(fileName);
-        }
-     timer = NULL;
-     return;
-     }
-
-  cRecordingUserCommand::InvokeCommand(RUC_BEFORERECORDING, fileName);
-  isyslog("record %s", fileName);
-  if (MakeDirs(fileName, true)) {
-     const cChannel *ch = timer->Channel();
-     recorder = new cRecorder(fileName, ch, timer->Priority());
-     if (device->AttachReceiver(recorder)) {
-        Recording.WriteInfo();
-        cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
-        if (!Timer && !cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
-           cReplayControl::SetRecording(fileName);
-        Recordings.AddByName(fileName);
-        if (Timer && !Timer->IsSingleEvent()) {
-           char *Directory = strdup(fileName);
-           // going up two directory levels to get the series folder
-           if (char *p = strrchr(Directory, '/')) {
-              while (p > Directory && *--p != '/')
-                    ;
-              *p = 0;
-              if (!HasRecordingsSortMode(Directory)) {
-                 dsyslog("setting %s to be sorted by time", Directory);
-                 SetRecordingsSortMode(Directory, rsmTime);
-                 }
-              }
-           free(Directory);
-           }
-        return;
-        }
-     else
-        DELETENULL(recorder);
-     }
-  else
-     timer->SetDeferred(DEFERTIMER);
-  if (!Timer) {
-     Timers.Del(timer);
-     timer = NULL;
-     }
-}
-
-cRecordControl::~cRecordControl()
-{
-  Stop();
-  free(fileName);
-}
-
-#define INSTANT_REC_EPG_LOOKAHEAD 300 // seconds to look into the EPG data for an instant recording
-
-bool cRecordControl::GetEvent(void)
-{
-  const cChannel *channel = timer->Channel();
-  time_t Time = timer->HasFlags(tfInstant) ? timer->StartTime() + INSTANT_REC_EPG_LOOKAHEAD : timer->StartTime() + (timer->StopTime() - timer->StartTime()) / 2;
-  for (int seconds = 0; seconds <= MAXWAIT4EPGINFO; seconds++) {
-      {
-        cSchedulesLock SchedulesLock;
-        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-        if (Schedules) {
-           const cSchedule *Schedule = Schedules->GetSchedule(channel);
-           if (Schedule) {
-              event = Schedule->GetEventAround(Time);
-              if (event) {
-                 if (seconds > 0)
-                    dsyslog("got EPG info after %d seconds", seconds);
-                 return true;
-                 }
-              }
-           }
-      }
-      if (seconds == 0)
-         dsyslog("waiting for EPG info...");
-      cCondWait::SleepMs(1000);
-      }
-  dsyslog("no EPG info available");
-  return false;
-}
-
-void cRecordControl::Stop(bool ExecuteUserCommand)
-{
-  if (timer) {
-     DELETENULL(recorder);
-     timer->SetRecording(false);
-     timer = NULL;
-     cStatus::MsgRecording(device, NULL, fileName, false);
-     if (ExecuteUserCommand)
-        cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName);
-     Timers.SetModified();
-     }
-}
-
-bool cRecordControl::Process(time_t t)
-{
-  if (!recorder || !recorder->IsAttached() || !timer || !timer->Matches(t)) {
-     if (timer)
-        timer->SetPending(false);
-     return false;
-     }
-  AssertFreeDiskSpace(timer->Priority());
-  return true;
-}
-
-// --- cRecordControls -------------------------------------------------------
-
-cRecordControl *cRecordControls::RecordControls[MAXRECORDCONTROLS] = { NULL };
-int cRecordControls::state = 0;
-
-bool cRecordControls::Start(cTimer *Timer, bool Pause, bool* reused)
-{
-  if (!Timer) {
-     cTimer *t = new cTimer(true, Pause);
-
-     //get event
-     cSchedulesLock SchedulesLock;
-     const cEvent *event = NULL;;
-     const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-     if (Schedules) {
-        const cSchedule *Schedule = Schedules->GetSchedule(t->Channel());
-        if (Schedule) {
-           event = Schedule->GetEventAround(t->StartTime() + INSTANT_REC_EPG_LOOKAHEAD);
-        }
-     }
-
-     if (cPluginManager::GetPlugin("timersync")) {
-        // sets the file name
-        cRecording recording(t, event);
-        Timers.Add(t);
-        Timers.SetModified();
-        if (!cReplayControl::LastReplayed())
-           cReplayControl::SetRecording(recording.FileName());
-        return true;
-     }
-     else {
-        RemoteTimers_InstantRecording_v1_0 ir;
-        ir.timer = t;
-        ir.pause = Pause;
-        ir.event = event;
-        ir.name = NULL;
-        ir.fileName = NULL;
-
-        if (cPluginManager::CallFirstService("RemoteTimers::InstantRecording-v1.0", &ir)) {
-           if (!cReplayControl::LastReplayed())
-              cReplayControl::SetRecording(ir.fileName);
- 	  delete t;
- 	  // empty names indicate an error
- 	  return *ir.fileName && *ir.name;
-        }
-        // service disabled or an error occured and the user confirmed local recording
-        // fall through to local instant recording
-     }
-     delete t;
-  }
-
-  static time_t LastNoDiskSpaceMessage = 0;
-  int FreeMB = 0;
-  if (Timer) {
-     AssertFreeDiskSpace(Timer->Priority(), !Timer->Pending());
-     Timer->SetPending(true);
-     }
-  VideoDiskSpace(&FreeMB);
-  if (FreeMB < MINFREEDISK) {
-     if (!Timer || time(NULL) - LastNoDiskSpaceMessage > NODISKSPACEDELTA) {
-        isyslog("not enough disk space to start recording%s%s", Timer ? " timer " : "", Timer ? *Timer->ToDescr() : "");
-        Skins.Message(mtWarning, tr("Not enough disk space to start recording!"));
-        LastNoDiskSpaceMessage = time(NULL);
-        }
-     return false;
-     }
-  LastNoDiskSpaceMessage = 0;
-
-  if (Timer == NULL) {
-    if (TryReuseRecording(Pause)) {
-      if (reused != NULL) *reused = true;
-      return true;
-      }
-    }
-  
-  ChangeState();
-  int ch = Timer ? Timer->Channel()->Number() : cDevice::CurrentChannel();
-  cChannel *channel = Channels.GetByNumber(ch);
-
-  if (channel) {
-     int Priority = Timer ? Timer->Priority() : Pause ? Setup.PausePriority : Setup.DefaultPriority;
-     cDevice *device = cDevice::GetDevice(channel, Priority, false);
-     if (device) {
-        dsyslog("switching device %d to channel %d", device->DeviceNumber() + 1, channel->Number());
-        if (!device->SwitchChannel(channel, false)) {
-           ShutdownHandler.RequestEmergencyExit();
-           return false;
-           }
-        if (!Timer || Timer->Matches()) {
-           for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-               if (!RecordControls[i]) {
-                  RecordControls[i] = new cRecordControl(device, Timer, Pause);
-                  return RecordControls[i]->Process(time(NULL));
-                  }
-               }
-           }
-        }
-     else if (!Timer || !Timer->Pending()) {
-        isyslog("no free DVB device to record channel %d!", ch);
-        Skins.Message(mtError, tr("No free DVB device to record!"));
-        }
-     }
-  else
-     esyslog("ERROR: channel %d not defined!", ch);
-  return false;
-}
-
-void cRecordControls::Stop(const char *InstantId)
-{
-  ChangeState();
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         const char *id = RecordControls[i]->InstantId();
-         if (id && strcmp(id, InstantId) == 0) {
-            cTimer *timer = RecordControls[i]->Timer();
-            RecordControls[i]->Stop();
-            if (timer) {
-               isyslog("deleting timer %s", *timer->ToDescr());
-               Timers.Del(timer);
-               Timers.SetModified();
-               }
-            break;
-            }
-         }
-      }
-}
-
-bool cRecordControls::TryReuseRecording(bool Pause)
-{
-  cRecordControl* runningRecording = cRecordControls::GetRecordControl(cDevice::CurrentChannel());
-  if (runningRecording != NULL && runningRecording->Timer() != NULL) {
-    cTimer *reuseTimer = runningRecording->Timer();
-    // calculate length from current time
-    time_t t = time(NULL);
-    struct tm *tmNow = localtime(&t);
-    int now = tmNow->tm_hour * 60 + tmNow->tm_min;
-    int stop = reuseTimer->Stop();
-    stop = stop / 100 * 60 + stop % 100;
-    int lengthFromNow = stop - now;
-    if (lengthFromNow < 0)
-      lengthFromNow += 24 * 60;
-    // Only use low priority recordings or, for pause, recordings which are long enough.
-    if (runningRecording->Timer()->Priority() <= LIVEPRIORITY || (Pause && lengthFromNow >= Setup.InstantRecordTime)) {
-      // always adapt recording time for instant recording, only raise stop time for pause
-      if (!Pause || lengthFromNow < Setup.InstantRecordTime) {
-        int stop = now + Setup.InstantRecordTime;
-        stop = (stop / 60) * 100 + (stop % 60);
-        if (stop >= 2400) stop -= 2400;
-        reuseTimer->SetStop(stop);
-        }
-      ChangeState();
-      // for pause, set replay to the recording
-      if (Pause) {
-        cReplayControl::SetRecording(runningRecording->FileName());
-        }
-      // for instant recording, raise priority and lifetime
-      else {
-        reuseTimer->SetPriority(max(Setup.DefaultPriority, reuseTimer->Priority()));
-        reuseTimer->SetLifetime(max(Setup.DefaultLifetime, reuseTimer->Lifetime()));
-        }
-      // We found a usable recording, don't create a new one.
-      return true;
-      }
-    }
-  return false;
-}
-
-bool cRecordControls::PauseLiveVideo(void)
-{
-  Skins.Message(mtStatus, tr("Pausing live video..."));
-  bool reused = false;
-  cReplayControl::SetRecording(NULL); // make sure the new cRecordControl will set cReplayControl::LastReplayed()
-  if (Start(NULL, true, &reused)) {
-     cReplayControl *rc = new cReplayControl(true, reused);
-     cControl::Launch(rc);
-     cControl::Attach();
-     Skins.Message(mtStatus, NULL);
-     return true;
-     }
-  Skins.Message(mtStatus, NULL);
-  return false;
-}
-
-const char *cRecordControls::GetInstantId(const char *LastInstantId)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (!LastInstantId && RecordControls[i]->InstantId())
-            return RecordControls[i]->InstantId();
-         if (LastInstantId && LastInstantId == RecordControls[i]->InstantId())
-            LastInstantId = NULL;
-         }
-      }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(const char *FileName)
-{
-  if (FileName) {
-     for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-         if (RecordControls[i] && strcmp(RecordControls[i]->FileName(), FileName) == 0)
-            return RecordControls[i];
-         }
-     }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(const cTimer *Timer)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i] && RecordControls[i]->Timer() == Timer)
-         return RecordControls[i];
-      }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(int channelNo)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-    if (RecordControls[i] != NULL) {
-      cTimer* existentTimer = RecordControls[i]->Timer();
-      if (existentTimer != NULL && existentTimer->Channel() != NULL) {
-        if (RecordControls[i]->Timer()->Channel()->Number() == channelNo) {
-          if (existentTimer->Recording()) {
-            return RecordControls[i];
-            }
-          }
-        }
-      }
-    }
-  return NULL;
-}
-
-void cRecordControls::Process(time_t t)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (!RecordControls[i]->Process(t)) {
-            DELETENULL(RecordControls[i]);
-            ChangeState();
-            }
-         }
-      }
-}
-
-void cRecordControls::ChannelDataModified(cChannel *Channel)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (RecordControls[i]->Timer() && RecordControls[i]->Timer()->Channel() == Channel) {
-            if (RecordControls[i]->Device()->ProvidesTransponder(Channel)) { // avoids retune on devices that don't really access the transponder
-               isyslog("stopping recording due to modification of channel %d", Channel->Number());
-               RecordControls[i]->Stop();
-               // This will restart the recording, maybe even from a different
-               // device in case conditional access has changed.
-               ChangeState();
-               }
-            }
-         }
-      }
-}
-
-bool cRecordControls::Active(int minimumPriority /* = MINPRIORITY */)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++)
-    if (RecordControls[i])
-      if (RecordControls[i]->Timer() == NULL || RecordControls[i]->Timer()->Priority() >= minimumPriority)
-         return true;
-
-  return false;
-}
-
-void cRecordControls::Shutdown(void)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++)
-      DELETENULL(RecordControls[i]);
-  ChangeState();
-}
-
-bool cRecordControls::StateChanged(int &State)
-{
-  int NewState = state;
-  bool Result = State != NewState;
-  State = state;
-  return Result;
-}
-
-// --- cReplayControl --------------------------------------------------------
-
-#define REPLAYCONTROLSKIPLIMIT   9    // s
-#define REPLAYCONTROLSKIPSECONDS 90   // s
-#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
-
-cReplayControl *cReplayControl::currentReplayControl = NULL;
-cString cReplayControl::fileName;
-
-cReplayControl::cReplayControl(bool PauseLive, bool ReusedPauseLive)
-:cDvbPlayerControl(fileName, PauseLive, ReusedPauseLive)
-{
-  cDevice::PrimaryDevice()->SetKeepTracks(PauseLive);
-  currentReplayControl = this;
-  displayReplay = NULL;
-  marksModified = false;
-  visible = modeOnly = shown = displayFrames = false;
-  lastCurrent = lastTotal = -1;
-  lastPlay = lastForward = false;
-  lastSpeed = -2; // an invalid value
-  lastSkipKey = kNone;
-  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-  lastSkipTimeout.Set(0);
-  timeoutShow = 0;
-  timeSearchActive = false;
-  cRecording Recording(fileName);
-  cStatus::MsgReplaying(this, Recording.Name(), Recording.FileName(), true);
-  marks.Load(fileName, Recording.FramesPerSecond(), Recording.IsPesRecording());
-  SetTrackDescriptions(false);
-  if (Setup.ProgressDisplayTime)
-     ShowTimed(Setup.ProgressDisplayTime);
-}
-
-cReplayControl::~cReplayControl()
-{
-  cDevice::PrimaryDevice()->SetKeepTracks(false);
-  Hide();
-  cStatus::MsgReplaying(this, NULL, fileName, false);
-  Stop();
-  if (currentReplayControl == this)
-     currentReplayControl = NULL;
-}
-
-void cReplayControl::Stop(void)
-{
-  if (Setup.DelTimeshiftRec && *fileName) {
-     cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
-     if (rc && rc->InstantId()) {
-        if (Active()) {
-           if (Setup.DelTimeshiftRec == 2 || Interface->Confirm(tr("Delete timeshift recording?"))) {
-              cTimer *timer = rc->Timer();
-              rc->Stop(false); // don't execute user command
-              if (timer) {
-                 isyslog("deleting timer %s", *timer->ToDescr());
-                 Timers.Del(timer);
-                 Timers.SetModified();
-                 }
-              cDvbPlayerControl::Stop();
-              cRecording *recording = Recordings.GetByName(fileName);
-              if (recording) {
-                 if (recording->Delete()) {
-                    Recordings.DelByName(fileName);
-                    ClearLastReplayed(fileName);
-                    }
-                 else
-                    Skins.Message(mtError, tr("Error while deleting recording!"));
-                 }
-              return;
-              }
-           }
-        }
-     }
-  cDvbPlayerControl::Stop();
-}
-
-void cReplayControl::SetRecording(const char *FileName)
-{
-  fileName = FileName;
-}
-
-const char *cReplayControl::NowReplaying(void)
-{
-  return currentReplayControl ? *fileName : NULL;
-}
-
-const char *cReplayControl::LastReplayed(void)
-{
-  if (!Recordings.GetByName(fileName))
-     fileName = NULL;
-  return fileName;
-}
-
-void cReplayControl::ClearLastReplayed(const char *FileName)
-{
-  if (*fileName && FileName && strcmp(fileName, FileName) == 0)
-     fileName = NULL;
-}
-
-void cReplayControl::ShowTimed(int Seconds)
-{
-  if (modeOnly)
-     Hide();
-  if (!visible) {
-     shown = ShowProgress(true);
-     timeoutShow = (shown && Seconds > 0) ? time(NULL) + Seconds : 0;
-     }
-  else if (timeoutShow && Seconds > 0)
-     timeoutShow = time(NULL) + Seconds;
-}
-
-void cReplayControl::Show(void)
-{
-  ShowTimed();
-}
-
-void cReplayControl::Hide(void)
-{
-  if (visible) {
-     delete displayReplay;
-     displayReplay = NULL;
-     SetNeedsFastResponse(false);
-     visible = false;
-     modeOnly = false;
-     lastPlay = lastForward = false;
-     lastSpeed = -2; // an invalid value
-     timeSearchActive = false;
-     timeoutShow = 0;
-     }
-  if (marksModified) {
-     marks.Save();
-     marksModified = false;
-     }
-}
-
-void cReplayControl::ShowMode(void)
-{
-  if (visible || Setup.ShowReplayMode && !cOsd::IsOpen()) {
-     bool Play, Forward;
-     int Speed;
-     if (GetReplayMode(Play, Forward, Speed) && (!visible || Play != lastPlay || Forward != lastForward || Speed != lastSpeed)) {
-        bool NormalPlay = (Play && Speed == -1);
-
-        if (!visible) {
-           if (NormalPlay)
-              return; // no need to do indicate ">" unless there was a different mode displayed before
-           visible = modeOnly = true;
-           displayReplay = Skins.Current()->DisplayReplay(modeOnly);
-           }
-
-        if (modeOnly && !timeoutShow && NormalPlay)
-           timeoutShow = time(NULL) + MODETIMEOUT;
-        displayReplay->SetMode(Play, Forward, Speed);
-        lastPlay = Play;
-        lastForward = Forward;
-        lastSpeed = Speed;
-        }
-     }
-}
-
-bool cReplayControl::ShowProgress(bool Initial)
-{
-  int Current, Total;
-
-  if (GetIndex(Current, Total) && Total > 0) {
-     if (!visible) {
-        displayReplay = Skins.Current()->DisplayReplay(modeOnly);
-        displayReplay->SetMarks(&marks);
-        SetNeedsFastResponse(true);
-        visible = true;
-        }
-     if (Initial) {
-        if (*fileName) {
-           if (cRecording *Recording = Recordings.GetByName(fileName))
-              displayReplay->SetRecording(Recording);
-           }
-        lastCurrent = lastTotal = -1;
-        }
-     if (Current != lastCurrent || Total != lastTotal) {
-        if (Setup.ShowRemainingTime || Total != lastTotal) {
-           int Index = Total;
-           if (Setup.ShowRemainingTime)
-              Index = Current - Index;
-           displayReplay->SetTotal(IndexToHMSF(Index, false, FramesPerSecond()));
-           if (!Initial)
-              displayReplay->Flush();
-           }
-        displayReplay->SetProgress(Current, Total);
-        if (!Initial)
-           displayReplay->Flush();
-        displayReplay->SetCurrent(IndexToHMSF(Current, displayFrames, FramesPerSecond()));
-        displayReplay->Flush();
-        lastCurrent = Current;
-        }
-     lastTotal = Total;
-     ShowMode();
-     return true;
-     }
-  return false;
-}
-
-void cReplayControl::TimeSearchDisplay(void)
-{
-  char buf[64];
-  // TRANSLATORS: note the trailing blank!
-  strcpy(buf, tr("Jump: "));
-  int len = strlen(buf);
-  char h10 = '0' + (timeSearchTime >> 24);
-  char h1  = '0' + ((timeSearchTime & 0x00FF0000) >> 16);
-  char m10 = '0' + ((timeSearchTime & 0x0000FF00) >> 8);
-  char m1  = '0' + (timeSearchTime & 0x000000FF);
-  char ch10 = timeSearchPos > 3 ? h10 : '-';
-  char ch1  = timeSearchPos > 2 ? h1  : '-';
-  char cm10 = timeSearchPos > 1 ? m10 : '-';
-  char cm1  = timeSearchPos > 0 ? m1  : '-';
-  sprintf(buf + len, "%c%c:%c%c", ch10, ch1, cm10, cm1);
-  displayReplay->SetJump(buf);
-}
-
-void cReplayControl::TimeSearchProcess(eKeys Key)
-{
-#define STAY_SECONDS_OFF_END 10
-  int Seconds = (timeSearchTime >> 24) * 36000 + ((timeSearchTime & 0x00FF0000) >> 16) * 3600 + ((timeSearchTime & 0x0000FF00) >> 8) * 600 + (timeSearchTime & 0x000000FF) * 60;
-  int Current = int(round(lastCurrent / FramesPerSecond()));
-  int Total = int(round(lastTotal / FramesPerSecond()));
-  switch (Key) {
-    case k0 ... k9:
-         if (timeSearchPos < 4) {
-            timeSearchTime <<= 8;
-            timeSearchTime |= Key - k0;
-            timeSearchPos++;
-            TimeSearchDisplay();
-            }
-         break;
-    case kFastRew:
-    case kLeft:
-    case kFastFwd:
-    case kRight: {
-         int dir = ((Key == kRight || Key == kFastFwd) ? 1 : -1);
-         if (dir > 0)
-            Seconds = min(Total - Current - STAY_SECONDS_OFF_END, Seconds);
-         SkipSeconds(Seconds * dir);
-         timeSearchActive = false;
-         }
-         break;
-    case kPlayPause:
-    case kPlay:
-    case kUp:
-    case kPause:
-    case kDown:
-    case kOk:
-         if (timeSearchPos > 0) {
-            Seconds = min(Total - STAY_SECONDS_OFF_END, Seconds);
-            Goto(SecondsToFrames(Seconds, FramesPerSecond()), Key == kDown || Key == kPause || Key == kOk);
-            }
-         timeSearchActive = false;
-         break;
-    default:
-         if (!(Key & k_Flags)) // ignore repeat/release keys
-            timeSearchActive = false;
-         break;
-    }
-
-  if (!timeSearchActive) {
-     if (timeSearchHide)
-        Hide();
-     else
-        displayReplay->SetJump(NULL);
-     ShowMode();
-     }
-}
-
-void cReplayControl::TimeSearch(void)
-{
-  timeSearchTime = timeSearchPos = 0;
-  timeSearchHide = false;
-  if (modeOnly)
-     Hide();
-  if (!visible) {
-     Show();
-     if (visible)
-        timeSearchHide = true;
-     else
-        return;
-     }
-  timeoutShow = 0;
-  TimeSearchDisplay();
-  timeSearchActive = true;
-}
-
-void cReplayControl::MarkToggle(void)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total, true)) {
-     lastCurrent = -1; // triggers redisplay
-     if (cMark *m = marks.Get(Current))
-        marks.Del(m);
-     else {
-        marks.Add(Current);
-        bool Play, Forward;
-        int Speed;
-        if (Setup.PauseOnMarkSet || GetReplayMode(Play, Forward, Speed) && !Play) {
-           Goto(Current, true);
-           displayFrames = true;
-           }
-        }
-     ShowTimed(2);
-     marksModified = true;
-     }
-}
-
-void cReplayControl::MarkJump(bool Forward)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     if (marks.Count()) {
-        if (cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current)) {
-           bool Play2, Forward2;
-           int Speed;
-           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
-               Play2 && Forward && m->Position() < Total - SecondsToFrames(3, FramesPerSecond())) {
-              Goto(m->Position());
-              Play();
-              }
-           else {
-              Goto(m->Position(), true);
-              displayFrames = true;
-              }
-           return;
-           }
-        }
-     // There are either no marks at all, or we already were at the first or last one,
-     // so jump to the very beginning or end:
-     Goto(Forward ? Total : 0, true);
-     }
-}
-
-void cReplayControl::MarkMove(bool Forward)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     if (cMark *m = marks.Get(Current)) {
-        displayFrames = true;
-        int p = SkipFrames(Forward ? 1 : -1);
-        cMark *m2;
-        if (Forward) {
-           while ((m2 = marks.Next(m)) != NULL && m2->Position() == m->Position())
-                 m = m2;
-           }
-        else {
-           while ((m2 = marks.Prev(m)) != NULL && m2->Position() == m->Position())
-                 m = m2;
-           }
-        m->SetPosition(p);
-        Goto(m->Position(), true);
-        marksModified = true;
-        }
-     }
-}
-
-void cReplayControl::EditCut(void)
-{
-  if (*fileName) {
-     Hide();
-     if (!cCutter::Active()) {
-        if (!marks.Count())
-           Skins.Message(mtError, tr("No editing marks defined!"));
-        else if (!marks.GetNumSequences())
-           Skins.Message(mtError, tr("No editing sequences defined!"));
-        else if (!cCutter::Start(fileName, NULL, false))
-           Skins.Message(mtError, tr("Can't start editing process!"));
-        else
-           Skins.Message(mtInfo, tr("Editing process started"));
-        }
-     else
-        Skins.Message(mtError, tr("Editing process already active!"));
-     ShowMode();
-     }
-}
-
-void cReplayControl::EditTest(void)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     cMark *m = marks.Get(Current);
-     if (!m)
-        m = marks.GetNext(Current);
-     if (m) {
-        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
-           m = marks.Next(m);
-        if (m) {
-           Goto(m->Position() - SecondsToFrames(3, FramesPerSecond()));
-           Play();
-           }
-        }
-     }
-}
-
-cOsdObject *cReplayControl::GetInfo(void)
-{
-  cRecording *Recording = Recordings.GetByName(cReplayControl::LastReplayed());
-  if (Recording)
-     return new cMenuRecording(Recording, false);
-  return NULL;
-}
-
-const cRecording *cReplayControl::GetRecording(void)
-{
-  if (const cRecording *Recording = Recordings.GetByName(LastReplayed()))
-     return Recording;
-  return NULL;
-}
-
-eOSState cReplayControl::ProcessKey(eKeys Key)
-{
-  if (!Active())
-     return osEnd;
-  if (Key == kNone && !marksModified)
-     marks.Update();
-  if (visible) {
-     if (timeoutShow && time(NULL) > timeoutShow) {
-        Hide();
-        ShowMode();
-        timeoutShow = 0;
-        }
-     else if (modeOnly)
-        ShowMode();
-     else
-        shown = ShowProgress(!shown) || shown;
-     }
-  bool DisplayedFrames = displayFrames;
-  displayFrames = false;
-  if (timeSearchActive && Key != kNone) {
-     TimeSearchProcess(Key);
-     return osContinue;
-     }
-  if (Key == kPlayPause) {
-     bool Play, Forward;
-     int Speed;
-     GetReplayMode(Play, Forward, Speed);
-     if (Speed >= 0)
-        Key = Play ? kPlay : kPause;
-     else
-        Key = Play ? kPause : kPlay;
-     }
-  bool DoShowMode = true;
-  switch (int(Key)) {
-    // Positioning:
-    case kPlay:
-    case kUp:      Play(); break;
-    case kPause:
-    case kDown:    Pause(); break;
-    case kFastRew|k_Release:
-    case kLeft|k_Release:
-                   if (Setup.MultiSpeedMode) break;
-    case kFastRew:
-    case kLeft:    Backward(); break;
-    case kFastFwd|k_Release:
-    case kRight|k_Release:
-                   if (Setup.MultiSpeedMode) break;
-    case kFastFwd:
-    case kRight:   Forward(); break;
-    case kRed:     TimeSearch(); break;
-    case kGreen|k_Repeat:
-                   SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
-    case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
-    case kYellow|k_Repeat:
-                   SkipSeconds(Setup.JumpSecondsRepeat); break;
-    case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
-    case kPrev|k_Repeat:
-    case kPrev:    if (lastSkipTimeout.TimedOut()) {
-                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-                      lastSkipKey = kPrev;
-                   }
-                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
-                      lastSkipSeconds /= 2;
-                      lastSkipKey = kNone;
-                   }
-                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
-                   SkipSeconds(-lastSkipSeconds); break;
-    case kNext|k_Repeat:
-    case kNext:    if (lastSkipTimeout.TimedOut()) {
-                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-                      lastSkipKey = kNext;	
-                   }
-                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
-                      lastSkipSeconds /= 2;
-                      lastSkipKey = kNone;
-                   }
-                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
-                   SkipSeconds(lastSkipSeconds); break;
-    case kStop:
-    case kBlue:    Hide();
-                   Stop();
-                   return osEnd;
-    default: {
-      bool play, forward;
-      int speed;
-      int Current, Total;
-      cMark *m;
-
-      DoShowMode = false;
-      switch (int(Key)) {
-        // Editing:
-        case k1|k_Repeat:
-        case k1:               if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
-                                  displayFrames = true;
-                                  int p = SkipFrames(-SecondsToFrames(5, FramesPerSecond()));
-                                  cMark *m2;
-                                  if ((m2 = marks.Prev(m)) != NULL && m2->Position() >= p)
-                                     break;
-                                  m->SetPosition(p); Goto(p, true);
-                                  marks.Save();
-                                  }
-                               else
-                                  SkipSeconds(-Setup.JumpSecondsSlow);
-                               break;
-        case k3|k_Repeat:
-        case k3:               if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
-                                  displayFrames = true;
-                                  int p = SkipFrames(SecondsToFrames(5, FramesPerSecond()));
-                                  cMark *m2;
-                                  if ((m2 = marks.Next(m)) != NULL && m2->Position() <= p)
-                                     break;
-                                  m->SetPosition(p); Goto(p, true);
-                                  marks.Save();
-                                  }
-                               else
-                                  SkipSeconds(Setup.JumpSecondsSlow);
-                               break;
-        case kMarkToggle:      if (GetReplayMode(play, forward, speed) && play) {
-                                  displayFrames = true;
-                                  Pause();
-                                  }
-                               MarkToggle();
-                               break;
-        case kMarkJumpBack|k_Repeat:
-        case kMarkJumpBack:    MarkJump(false); break;
-        case kMarkJumpForward|k_Repeat:
-        case kMarkJumpForward: MarkJump(true); break;
-        case kMarkMoveBack|k_Repeat:
-        case kMarkMoveBack:    MarkMove(false); break;
-        case kMarkMoveForward|k_Repeat:
-        case kMarkMoveForward: MarkMove(true); break;
-        case kEditCut:         EditCut(); break;
-        case kEditTest:        EditTest(); break;
-        default: {
-          displayFrames = DisplayedFrames;
-          switch (Key) {
-            // Menu control:
-            case kOk:      if (visible && !modeOnly) {
-                              Hide();
-                              DoShowMode = true;
-                              }
-                           else
-                              Show();
-                           break;
-            case kBack:    Hide();
-                           Stop();
-                           return osRecordings;
-            default:       return osUnknown;
-            }
-          }
-        }
-      }
-    }
-  if (DoShowMode)
-     ShowMode();
-  return osContinue;
-}
diff -urN vdr-2.0.4-org/menu.h vdr-2.0.4/menu.h
--- vdr-2.0.4-org/menu.h	2013-10-25 09:44:22.452680545 +0200
+++ vdr-2.0.4/menu.h	2013-10-25 10:07:11.964704054 +0200
@@ -18,6 +18,7 @@
 #include "menuitems.h"
 #include "recorder.h"
 #include "skins.h"
+#include "livebuffer.h"
 
 class cMenuEditSrcItem : public cMenuEditIntItem {
 private:
@@ -276,10 +277,14 @@
   static bool TryReuseRecording(bool Pause);
          ///< Tries to reuse an existing recording instead of creating a second one in parallel.
          ///< Returns true if successful.
+protected:
+  friend class cRecordControl;
+  static cLiveRecorder *liveRecorder;
 public:
   static bool Start(cTimer *Timer = NULL, bool Pause = false, bool* reused = NULL);
   static void Stop(const char *InstantId);
   static bool PauseLiveVideo(void);
+  static bool StartLiveBuffer(eKeys Key);
   static const char *GetInstantId(const char *LastInstantId);
   static cRecordControl *GetRecordControl(const char *FileName);
   static cRecordControl *GetRecordControl(const cTimer *Timer);
@@ -296,6 +301,12 @@
   static void Shutdown(void);
   static void ChangeState(void) { state++; }
   static bool StateChanged(int &State);
+  static void SetLiveChannel(cDevice *Device, const cChannel *Channel);
+  static bool CanSetLiveChannel(const cChannel *Channel);
+  static bool IsWritingBuffer();
+  static void CancelWritingBuffer();
+  static cIndex *GetLiveBuffer(cTimer *Timer);
+  static cIndex *GetLiveIndex(const char *FileName);
   };
 
 class cReplayControl : public cDvbPlayerControl {
diff -urN vdr-2.0.4-org/menu.h.orig vdr-2.0.4/menu.h.orig
--- vdr-2.0.4-org/menu.h.orig	2013-10-25 09:44:22.404680544 +0200
+++ vdr-2.0.4/menu.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,312 +0,0 @@
-/*
- * menu.h: The actual menu implementations
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: menu.h 2.13.1.1 2013/10/16 09:46:15 kls Exp $
- */
-
-#ifndef __MENU_H
-#define __MENU_H
-
-#include "ci.h"
-#include "device.h"
-#include "epg.h"
-#include "osdbase.h"
-#include "dvbplayer.h"
-#include "menuitems.h"
-#include "recorder.h"
-#include "skins.h"
-
-class cMenuText : public cOsdMenu {
-private:
-  char *text;
-  eDvbFont font;
-public:
-  cMenuText(const char *Title, const char *Text, eDvbFont Font = fontOsd);
-  virtual ~cMenuText();
-  void SetText(const char *Text);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuFolder : public cOsdMenu {
-private:
-  cNestedItemList *nestedItemList;
-  cList<cNestedItem> *list;
-  cString dir;
-  cOsdItem *firstFolder;
-  bool editing;
-  void SetHelpKeys(void);
-  void Set(const char *CurrentFolder = NULL);
-  void DescendPath(const char *Path);
-  eOSState SetFolder(void);
-  eOSState Select(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  eOSState Edit(void);
-  cMenuFolder(const char *Title, cList<cNestedItem> *List, cNestedItemList *NestedItemList, const char *Dir, const char *Path = NULL);
-public:
-  cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path = NULL);
-  cString GetFolder(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuCommands : public cOsdMenu {
-private:
-  cList<cNestedItem> *commands;
-  cString parameters;
-  cString title;
-  cString command;
-  bool confirm;
-  char *result;
-  bool Parse(const char *s);
-  eOSState Execute(void);
-public:
-  cMenuCommands(const char *Title, cList<cNestedItem> *Commands, const char *Parameters = NULL);
-  virtual ~cMenuCommands();
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuEditTimer : public cOsdMenu {
-private:
-  cTimer *timer;
-  cTimer data;
-  int channel;
-  bool addIfConfirmed;
-  cMenuEditStrItem *file;
-  cMenuEditDateItem *day;
-  cMenuEditDateItem *firstday;
-  eOSState SetFolder(void);
-  void SetFirstDayItem(void);
-  void SetHelpKeys(void);
-public:
-  cMenuEditTimer(cTimer *Timer, bool New = false);
-  virtual ~cMenuEditTimer();
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuEvent : public cOsdMenu {
-private:
-  const cEvent *event;
-public:
-  cMenuEvent(const cEvent *Event, bool CanSwitch = false, bool Buttons = false);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuMain : public cOsdMenu {
-private:
-  bool replaying;
-  cOsdItem *stopReplayItem;
-  cOsdItem *cancelEditingItem;
-  cOsdItem *cancelFileTransferItem;
-  cOsdItem *stopRecordingItem;
-  int recordControlsState;
-  static cOsdObject *pluginOsdObject;
-  void Set(void);
-  bool Update(bool Force = false);
-public:
-  cMenuMain(eOSState State = osUnknown, bool OpenSubMenus = false);
-  virtual eOSState ProcessKey(eKeys Key);
-  static cOsdObject *PluginOsdObject(void);
-  };
-
-class cDisplayChannel : public cOsdObject {
-private:
-  cSkinDisplayChannel *displayChannel;
-  int group;
-  bool withInfo;
-  cTimeMs lastTime;
-  int number;
-  bool timeout;
-  cChannel *channel;
-  const cEvent *lastPresent;
-  const cEvent *lastFollowing;
-  static cDisplayChannel *currentDisplayChannel;
-  void DisplayChannel(void);
-  void DisplayInfo(void);
-  void Refresh(void);
-  cChannel *NextAvailableChannel(cChannel *Channel, int Direction);
-public:
-  cDisplayChannel(int Number, bool Switched);
-  cDisplayChannel(eKeys FirstKey);
-  virtual ~cDisplayChannel();
-  virtual eOSState ProcessKey(eKeys Key);
-  static bool IsOpen(void) { return currentDisplayChannel != NULL; }
-  };
-
-class cDisplayVolume : public cOsdObject {
-private:
-  cSkinDisplayVolume *displayVolume;
-  cTimeMs timeout;
-  static cDisplayVolume *currentDisplayVolume;
-  virtual void Show(void);
-  cDisplayVolume(void);
-public:
-  virtual ~cDisplayVolume();
-  static cDisplayVolume *Create(void);
-  static void Process(eKeys Key);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-class cDisplayTracks : public cOsdObject {
-private:
-  cSkinDisplayTracks *displayTracks;
-  cTimeMs timeout;
-  eTrackType types[ttMaxTrackTypes];
-  char *descriptions[ttMaxTrackTypes + 1]; // list is NULL terminated
-  int numTracks, track, audioChannel;
-  static cDisplayTracks *currentDisplayTracks;
-  virtual void Show(void);
-  cDisplayTracks(void);
-public:
-  virtual ~cDisplayTracks();
-  static bool IsOpen(void) { return currentDisplayTracks != NULL; }
-  static cDisplayTracks *Create(void);
-  static void Process(eKeys Key);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-class cDisplaySubtitleTracks : public cOsdObject {
-private:
-  cSkinDisplayTracks *displayTracks;
-  cTimeMs timeout;
-  eTrackType types[ttMaxTrackTypes];
-  char *descriptions[ttMaxTrackTypes + 1]; // list is NULL terminated
-  int numTracks, track;
-  static cDisplaySubtitleTracks *currentDisplayTracks;
-  virtual void Show(void);
-  cDisplaySubtitleTracks(void);
-public:
-  virtual ~cDisplaySubtitleTracks();
-  static bool IsOpen(void) { return currentDisplayTracks != NULL; }
-  static cDisplaySubtitleTracks *Create(void);
-  static void Process(eKeys Key);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cOsdObject *CamControl(void);
-bool CamMenuActive(void);
-
-class cMenuRecordingItem;
-
-class cMenuRecordings : public cOsdMenu {
-private:
-  char *base;
-  int level;
-  int recordingsState;
-  int helpKeys;
-  void SetHelpKeys(void);
-  void Set(bool Refresh = false);
-  bool Open(bool OpenSubMenus = false);
-  eOSState Play(void);
-  eOSState Rewind(void);
-  eOSState Delete(void);
-  eOSState Info(void);
-  eOSState Sort(void);
-  eOSState Commands(eKeys Key = kNone);
-  eOSState Edit(void);
-protected:
-  cString DirectoryName(void);
-public:
-  cMenuRecordings(const char *Base = NULL, int Level = 0, bool OpenSubMenus = false);
-  ~cMenuRecordings();
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cRecordControl {
-private:
-  cDevice *device;
-  cTimer *timer;
-  cRecorder *recorder;
-  const cEvent *event;
-  cString instantId;
-  char *fileName;
-  bool GetEvent(void);
-public:
-  cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false);
-  virtual ~cRecordControl();
-  bool Process(time_t t);
-  cDevice *Device(void) { return device; }
-  void Stop(bool ExecuteUserCommand = true);
-  const char *InstantId(void) { return instantId; }
-  const char *FileName(void) { return fileName; }
-  cTimer *Timer(void) { return timer; }
-  };
-
-class cRecordControls {
-private:
-  static cRecordControl *RecordControls[];
-  static int state;
-  static bool TryReuseRecording(bool Pause);
-         ///< Tries to reuse an existing recording instead of creating a second one in parallel.
-         ///< Returns true if successful.
-public:
-  static bool Start(cTimer *Timer = NULL, bool Pause = false, bool* reused = NULL);
-  static void Stop(const char *InstantId);
-  static bool PauseLiveVideo(void);
-  static const char *GetInstantId(const char *LastInstantId);
-  static cRecordControl *GetRecordControl(const char *FileName);
-  static cRecordControl *GetRecordControl(const cTimer *Timer);
-         ///< Returns the cRecordControl for the given Timer.
-         ///< If there is no cRecordControl for Timer, NULL is returned.
-  static cRecordControl *GetRecordControl(int channelNo);
-         ///< Returns the cRecordControl for the given channel number.
-         ///< If there is no cRecordControl, NULL is returned.
-  static void Process(time_t t);
-  static void ChannelDataModified(cChannel *Channel);
-  static bool Active(int minimumPriority = MINPRIORITY);
-         ///< Only recordings with at least minimumPriority are considered active.
-         ///< Default value of parameter considers every recording as "activity".
-  static void Shutdown(void);
-  static void ChangeState(void) { state++; }
-  static bool StateChanged(int &State);
-  };
-
-class cReplayControl : public cDvbPlayerControl {
-private:
-  cSkinDisplayReplay *displayReplay;
-  cMarks marks;
-  bool marksModified;
-  bool visible, modeOnly, shown, displayFrames;
-  int lastCurrent, lastTotal;
-  bool lastPlay, lastForward;
-  int lastSpeed;
-  int lastSkipSeconds;
-  eKeys lastSkipKey;
-  cTimeMs lastSkipTimeout;
-  time_t timeoutShow;
-  bool timeSearchActive, timeSearchHide;
-  int timeSearchTime, timeSearchPos;
-  void TimeSearchDisplay(void);
-  void TimeSearchProcess(eKeys Key);
-  void TimeSearch(void);
-  void ShowTimed(int Seconds = 0);
-  static cReplayControl *currentReplayControl;
-  static cString fileName;
-  void ShowMode(void);
-  bool ShowProgress(bool Initial);
-  void MarkToggle(void);
-  void MarkJump(bool Forward);
-  void MarkMove(bool Forward);
-  void EditCut(void);
-  void EditTest(void);
-public:
-  cReplayControl(bool PauseLive = false, bool ReusedPauseLive = false);
-  virtual ~cReplayControl();
-  void Stop(void);
-  virtual cOsdObject *GetInfo(void);
-  virtual const cRecording *GetRecording(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual void Show(void);
-  virtual void Hide(void);
-  bool Visible(void) { return visible; }
-  static void SetRecording(const char *FileName);
-  static const char *NowReplaying(void);
-  static const char *LastReplayed(void);
-  static void ClearLastReplayed(const char *FileName);
-  };
-
-#endif //__MENU_H
diff -urN vdr-2.0.4-org/osdbase.h vdr-2.0.4/osdbase.h
--- vdr-2.0.4-org/osdbase.h	2013-10-25 09:44:22.452680545 +0200
+++ vdr-2.0.4/osdbase.h	2013-10-25 10:07:11.964704054 +0200
@@ -38,6 +38,7 @@
                 osActiveBouquet,
                 osFavourites,
                 osAddFavourite,
+                osSwitchChannel,
                 os_User, // the following values can be used locally
                 osUser1,
                 osUser2,
diff -urN vdr-2.0.4-org/player.c vdr-2.0.4/player.c
--- vdr-2.0.4-org/player.c	2013-10-25 09:44:22.456680545 +0200
+++ vdr-2.0.4/player.c	2013-10-25 10:07:11.964704054 +0200
@@ -10,6 +10,9 @@
 #include "player.h"
 #include "i18n.h"
 
+#include "menu.h"
+#include "transfer.h"
+
 // --- cPlayer ---------------------------------------------------------------
 
 cPlayer::cPlayer(ePlayMode PlayMode)
@@ -78,6 +81,10 @@
 
 void cControl::Launch(cControl *Control)
 {
+  if(!dynamic_cast<cTransferControl *>(Control)) {
+     if(!dynamic_cast<cReplayControl *>(Control) || strcmp(cLiveRecorder::FileName(), cReplayControl::NowReplaying()))
+        cRecordControls::SetLiveChannel(NULL, NULL);
+  } // if
   cMutexLock MutexLock(&mutex);
   cControl *c = control; // keeps control from pointing to uninitialized memory
   control = Control;
diff -urN vdr-2.0.4-org/po/de_DE.po vdr-2.0.4/po/de_DE.po
--- vdr-2.0.4-org/po/de_DE.po	2013-10-25 09:44:22.500680545 +0200
+++ vdr-2.0.4/po/de_DE.po	2013-10-25 10:07:11.964704054 +0200
@@ -25,6 +25,9 @@
 msgid "Can't start Transfer Mode!"
 msgstr "Transfer-Mode kann nicht gestartet werden!"
 
+msgid "Still writing timeshift data to recording. Abort?"
+msgstr "Timeshift-Daten werden noch in Aufnahme kopiert. Abbrechen?"
+
 msgid "off"
 msgstr "aus"
 
diff -urN vdr-2.0.4-org/recorder.c vdr-2.0.4/recorder.c
--- vdr-2.0.4-org/recorder.c	2013-10-25 09:44:22.500680545 +0200
+++ vdr-2.0.4/recorder.c	2013-10-25 10:25:03.476722447 +0200
@@ -24,6 +24,7 @@
 cRecorder::cRecorder(const char *FileName, const cChannel *Channel, int Priority)
 :cReceiver(Channel, Priority)
 ,cThread("recording")
+,handleError(true)
 {
   recordingName = strdup(FileName);
 
@@ -141,6 +142,7 @@
                     InfoWritten = true;
                     }
                  if (FirstIframeSeen || frameDetector->IndependentFrame()) {
+                    if(!FirstIframeSeen) FillInitialData(b, r);
                     FirstIframeSeen = true; // start recording with the first I-frame
                     if (!NextFile())
                        break;
@@ -166,7 +168,8 @@
               ringBuffer->Del(Count);
               }
            }
-        if (t.TimedOut()) {
+        //if (t.TimedOut()) {
+	if (handleError && (t.TimedOut())) {
            esyslog("ERROR: video data stream broken");
            ShutdownHandler.RequestEmergencyExit();
            t.Set(MAXBROKENTIMEOUT);
diff -urN vdr-2.0.4-org/recorder.h vdr-2.0.4/recorder.h
--- vdr-2.0.4-org/recorder.h	2013-10-25 09:44:22.468680545 +0200
+++ vdr-2.0.4/recorder.h	2013-10-25 10:07:11.964704054 +0200
@@ -17,18 +17,20 @@
 #include "thread.h"
 
 class cRecorder : public cReceiver, cThread {
-private:
+protected:
   cRingBufferLinear *ringBuffer;
   cFrameDetector *frameDetector;
   cPatPmtGenerator patPmtGenerator;
   cFileName *fileName;
-  cIndexFile *index;
+  cIndex *index;
+  bool handleError;
   cUnbufferedFile *recordFile;
   char *recordingName;
   off_t fileSize;
   time_t lastDiskSpaceCheck;
-  bool RunningLowOnDiskSpace(void);
-  bool NextFile(void);
+  virtual bool RunningLowOnDiskSpace(void);
+  virtual bool NextFile(void);
+  virtual void FillInitialData(uchar *Data, int Size) {};
 protected:
   virtual void Activate(bool On);
   virtual void Receive(uchar *Data, int Length);
diff -urN vdr-2.0.4-org/recording.c vdr-2.0.4/recording.c
--- vdr-2.0.4-org/recording.c	2013-10-25 09:44:22.520680546 +0200
+++ vdr-2.0.4/recording.c	2013-10-25 10:07:11.964704054 +0200
@@ -1212,8 +1212,10 @@
 {
   if (numFrames < 0) {
      int nf = cIndexFile::GetLength(FileName(), IsPesRecording());
-     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
-        return nf; // check again later for ongoing recordings
+//     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
+//        return nf; // check again later for ongoing recordings
+     if (time(NULL) - LastModifiedTime(FileName()) < MININDEXAGE)
+     return nf; // check again later for ongoing recordings
      numFrames = nf;
      }
   return numFrames;
@@ -1231,8 +1233,10 @@
 {
   if (fileSizeMB < 0) {
      int fs = DirSizeMB(FileName());
-     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
-        return fs; // check again later for ongoing recordings
+//     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
+//        return fs; // check again later for ongoing recordings
+     if (time(NULL) - LastModifiedTime(FileName()) < MININDEXAGE)
+     return fs; // check again later for ongoing recordings
      fileSizeMB = fs;
      }
   return fileSizeMB;
diff -urN vdr-2.0.4-org/recording.c.orig vdr-2.0.4/recording.c.orig
--- vdr-2.0.4-org/recording.c.orig	2013-10-25 09:44:22.076680538 +0200
+++ vdr-2.0.4/recording.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,2446 +0,0 @@
-/*
- * recording.c: Recording file handling
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: recording.c 2.91.1.2 2013/08/21 13:58:35 kls Exp $
- */
-
-#include "recording.h"
-#include "iconpatch.h"
-#include <ctype.h>
-#include <dirent.h>
-#include <errno.h>
-#include <fcntl.h>
-#define __STDC_FORMAT_MACROS // Required for format specifiers
-#include <inttypes.h>
-#include <math.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include "channels.h"
-#include "i18n.h"
-#include "interface.h"
-#include "remux.h"
-#include "ringbuffer.h"
-#include "skins.h"
-#include "tools.h"
-#include "videodir.h"
-
-#define SUMMARYFALLBACK
-
-#define RECEXT       ".rec"
-#define DELEXT       ".del"
-/* This was the original code, which works fine in a Linux only environment.
-   Unfortunately, because of Windows and its brain dead file system, we have
-   to use a more complicated approach, in order to allow users who have enabled
-   the --vfat command line option to see their recordings even if they forget to
-   enable --vfat when restarting VDR... Gee, do I hate Windows.
-   (kls 2002-07-27)
-#define DATAFORMAT   "%4d-%02d-%02d.%02d:%02d.%02d.%02d" RECEXT
-#define NAMEFORMAT   "%s/%s/" DATAFORMAT
-*/
-#define DATAFORMATPES   "%4d-%02d-%02d.%02d%*c%02d.%02d.%02d" RECEXT
-#define NAMEFORMATPES   "%s/%s/" "%4d-%02d-%02d.%02d.%02d.%02d.%02d" RECEXT
-#define DATAFORMATTS    "%4d-%02d-%02d.%02d.%02d.%d-%d" RECEXT
-#define NAMEFORMATTS    "%s/%s/" DATAFORMATTS
-
-#define RESUMEFILESUFFIX  "/resume%s%s"
-#ifdef SUMMARYFALLBACK
-#define SUMMARYFILESUFFIX "/summary.vdr"
-#endif
-#define INFOFILESUFFIX    "/info"
-#define MARKSFILESUFFIX   "/marks"
-
-#define SORTMODEFILE      ".sort"
-
-#define MINDISKSPACE 1024 // MB
-
-#define REMOVECHECKDELTA   60 // seconds between checks for removing deleted files
-#define DELETEDLIFETIME   300 // seconds after which a deleted recording will be actually removed
-#define DISKCHECKDELTA    100 // seconds between checks for free disk space
-#define REMOVELATENCY      10 // seconds to wait until next check after removing a file
-#define MARKSUPDATEDELTA   10 // seconds between checks for updating editing marks
-#define MININDEXAGE      3600 // seconds before an index file is considered no longer to be written
-
-#define MAX_LINK_LEVEL  6
-
-int DirectoryPathMax = PATH_MAX - 1;
-int DirectoryNameMax = NAME_MAX;
-bool DirectoryEncoding = false;
-int InstanceId = 0;
-
-cRecordings DeletedRecordings(true);
-
-// --- cRemoveDeletedRecordingsThread ----------------------------------------
-
-class cRemoveDeletedRecordingsThread : public cThread {
-protected:
-  virtual void Action(void);
-public:
-  cRemoveDeletedRecordingsThread(void);
-  };
-
-cRemoveDeletedRecordingsThread::cRemoveDeletedRecordingsThread(void)
-:cThread("remove deleted recordings", true)
-{
-}
-
-void cRemoveDeletedRecordingsThread::Action(void)
-{
-  // Make sure only one instance of VDR does this:
-  cLockFile LockFile(VideoDirectory);
-  if (LockFile.Lock()) {
-     bool deleted = false;
-     cThreadLock DeletedRecordingsLock(&DeletedRecordings);
-     for (cRecording *r = DeletedRecordings.First(); r; ) {
-         if (cIoThrottle::Engaged())
-            return;
-         if (r->Deleted() && time(NULL) - r->Deleted() > DELETEDLIFETIME) {
-            cRecording *next = DeletedRecordings.Next(r);
-            r->Remove();
-            DeletedRecordings.Del(r);
-            r = next;
-            deleted = true;
-            continue;
-            }
-         r = DeletedRecordings.Next(r);
-         }
-     if (deleted) {
-        const char *IgnoreFiles[] = { SORTMODEFILE, NULL };
-        RemoveEmptyVideoDirectories(IgnoreFiles);
-        }
-     }
-}
-
-static cRemoveDeletedRecordingsThread RemoveDeletedRecordingsThread;
-
-// ---
-
-void RemoveDeletedRecordings(void)
-{
-  static time_t LastRemoveCheck = 0;
-  if (time(NULL) - LastRemoveCheck > REMOVECHECKDELTA) {
-     if (!RemoveDeletedRecordingsThread.Active()) {
-        cThreadLock DeletedRecordingsLock(&DeletedRecordings);
-        for (cRecording *r = DeletedRecordings.First(); r; r = DeletedRecordings.Next(r)) {
-            if (r->Deleted() && time(NULL) - r->Deleted() > DELETEDLIFETIME) {
-               RemoveDeletedRecordingsThread.Start();
-               break;
-               }
-            }
-        }
-     LastRemoveCheck = time(NULL);
-     }
-}
-
-void AssertFreeDiskSpace(int Priority, bool Force)
-{
-  static cMutex Mutex;
-  cMutexLock MutexLock(&Mutex);
-  // With every call to this function we try to actually remove
-  // a file, or mark a file for removal ("delete" it), so that
-  // it will get removed during the next call.
-  static time_t LastFreeDiskCheck = 0;
-  int Factor = (Priority == -1) ? 10 : 1;
-  if (Force || time(NULL) - LastFreeDiskCheck > DISKCHECKDELTA / Factor) {
-     if (!VideoFileSpaceAvailable(MINDISKSPACE)) {
-        // Make sure only one instance of VDR does this:
-        cLockFile LockFile(VideoDirectory);
-        if (!LockFile.Lock())
-           return;
-        // Remove the oldest file that has been "deleted":
-        isyslog("low disk space while recording, trying to remove a deleted recording...");
-        cThreadLock DeletedRecordingsLock(&DeletedRecordings);
-        if (DeletedRecordings.Count()) {
-           cRecording *r = DeletedRecordings.First();
-           cRecording *r0 = NULL;
-           while (r) {
-                 if (r->IsOnVideoDirectoryFileSystem()) { // only remove recordings that will actually increase the free video disk space
-                    if (!r0 || r->Start() < r0->Start())
-                       r0 = r;
-                    }
-                 r = DeletedRecordings.Next(r);
-                 }
-           if (r0) {
-              if (r0->Remove())
-                 LastFreeDiskCheck += REMOVELATENCY / Factor;
-              DeletedRecordings.Del(r0);
-              return;
-              }
-           }
-        else {
-           // DeletedRecordings was empty, so to be absolutely sure there are no
-           // deleted recordings we need to double check:
-           DeletedRecordings.Update(true);
-           if (DeletedRecordings.Count())
-              return; // the next call will actually remove it
-           }
-        // No "deleted" files to remove, so let's see if we can delete a recording:
-        if (Priority > 0) {
-           isyslog("...no deleted recording found, trying to delete an old recording...");
-           cThreadLock RecordingsLock(&Recordings);
-           if (Recordings.Count()) {
-              cRecording *r = Recordings.First();
-              cRecording *r0 = NULL;
-              while (r) {
-                    if (r->IsOnVideoDirectoryFileSystem()) { // only delete recordings that will actually increase the free video disk space
-                       if (!r->IsEdited() && r->Lifetime() < MAXLIFETIME) { // edited recordings and recordings with MAXLIFETIME live forever
-                          if ((r->Lifetime() == 0 && Priority > r->Priority()) || // the recording has no guaranteed lifetime and the new recording has higher priority
-                              (r->Lifetime() > 0 && (time(NULL) - r->Start()) / SECSINDAY >= r->Lifetime())) { // the recording's guaranteed lifetime has expired
-                             if (r0) {
-                                if (r->Priority() < r0->Priority() || (r->Priority() == r0->Priority() && r->Start() < r0->Start()))
-                                   r0 = r; // in any case we delete the one with the lowest priority (or the older one in case of equal priorities)
-                                }
-                             else
-                                r0 = r;
-                             }
-                          }
-                       }
-                    r = Recordings.Next(r);
-                    }
-              if (r0 && r0->Delete()) {
-                 Recordings.Del(r0);
-                 return;
-                 }
-              }
-           // Unable to free disk space, but there's nothing we can do about that...
-           isyslog("...no old recording found, giving up");
-           }
-        else
-           isyslog("...no deleted recording found, priority %d too low to trigger deleting an old recording", Priority);
-        Skins.QueueMessage(mtWarning, tr("Low disk space!"), 5, -1);
-        }
-     LastFreeDiskCheck = time(NULL);
-     }
-}
-
-// --- cResumeFile -----------------------------------------------------------
-
-cResumeFile::cResumeFile(const char *FileName, bool IsPesRecording)
-{
-  isPesRecording = IsPesRecording;
-  const char *Suffix = isPesRecording ? RESUMEFILESUFFIX ".vdr" : RESUMEFILESUFFIX;
-  fileName = MALLOC(char, strlen(FileName) + strlen(Suffix) + 1);
-  if (fileName) {
-     strcpy(fileName, FileName);
-     sprintf(fileName + strlen(fileName), Suffix, Setup.ResumeID ? "." : "", Setup.ResumeID ? *itoa(Setup.ResumeID) : "");
-     }
-  else
-     esyslog("ERROR: can't allocate memory for resume file name");
-}
-
-cResumeFile::~cResumeFile()
-{
-  free(fileName);
-}
-
-int cResumeFile::Read(void)
-{
-  int resume = -1;
-  if (fileName) {
-     struct stat st;
-     if (stat(fileName, &st) == 0) {
-        if ((st.st_mode & S_IWUSR) == 0) // no write access, assume no resume
-           return -1;
-        }
-     if (isPesRecording) {
-        int f = open(fileName, O_RDONLY);
-        if (f >= 0) {
-           if (safe_read(f, &resume, sizeof(resume)) != sizeof(resume)) {
-              resume = -1;
-              LOG_ERROR_STR(fileName);
-              }
-           close(f);
-           }
-        else if (errno != ENOENT)
-           LOG_ERROR_STR(fileName);
-        }
-     else {
-        FILE *f = fopen(fileName, "r");
-        if (f) {
-           cReadLine ReadLine;
-           char *s;
-           int line = 0;
-           while ((s = ReadLine.Read(f)) != NULL) {
-                 ++line;
-                 char *t = skipspace(s + 1);
-                 switch (*s) {
-                   case 'I': resume = atoi(t);
-                             break;
-                   default: ;
-                   }
-                 }
-           fclose(f);
-           }
-        else if (errno != ENOENT)
-           LOG_ERROR_STR(fileName);
-        }
-     }
-  return resume;
-}
-
-bool cResumeFile::Save(int Index)
-{
-  if (fileName) {
-     if (isPesRecording) {
-        int f = open(fileName, O_WRONLY | O_CREAT | O_TRUNC, DEFFILEMODE);
-        if (f >= 0) {
-           if (safe_write(f, &Index, sizeof(Index)) < 0)
-              LOG_ERROR_STR(fileName);
-           close(f);
-           Recordings.ResetResume(fileName);
-           return true;
-           }
-        }
-     else {
-        FILE *f = fopen(fileName, "w");
-        if (f) {
-           fprintf(f, "I %d\n", Index);
-           fclose(f);
-           Recordings.ResetResume(fileName);
-           }
-        else
-           LOG_ERROR_STR(fileName);
-        return true;
-        }
-     }
-  return false;
-}
-
-void cResumeFile::Delete(void)
-{
-  if (fileName) {
-     if (remove(fileName) == 0)
-        Recordings.ResetResume(fileName);
-     else if (errno != ENOENT)
-        LOG_ERROR_STR(fileName);
-     }
-}
-
-// --- cRecordingInfo --------------------------------------------------------
-
-cRecordingInfo::cRecordingInfo(const cChannel *Channel, const cEvent *Event)
-{
-  channelID = Channel ? Channel->GetChannelID() : tChannelID::InvalidID;
-  channelName = Channel ? strdup(Channel->Name()) : NULL;
-  ownEvent = Event ? NULL : new cEvent(0);
-  event = ownEvent ? ownEvent : Event;
-  aux = NULL;
-  framesPerSecond = DEFAULTFRAMESPERSECOND;
-  priority = MAXPRIORITY;
-  lifetime = MAXLIFETIME;
-  fileName = NULL;
-  if (Channel) {
-     // Since the EPG data's component records can carry only a single
-     // language code, let's see whether the channel's PID data has
-     // more information:
-     cComponents *Components = (cComponents *)event->Components();
-     if (!Components)
-        Components = new cComponents;
-     for (int i = 0; i < MAXAPIDS; i++) {
-         const char *s = Channel->Alang(i);
-         if (*s) {
-            tComponent *Component = Components->GetComponent(i, 2, 3);
-            if (!Component)
-               Components->SetComponent(Components->NumComponents(), 2, 3, s, NULL);
-            else if (strlen(s) > strlen(Component->language))
-               strn0cpy(Component->language, s, sizeof(Component->language));
-            }
-         }
-     // There's no "multiple languages" for Dolby Digital tracks, but
-     // we do the same procedure here, too, in case there is no component
-     // information at all:
-     for (int i = 0; i < MAXDPIDS; i++) {
-         const char *s = Channel->Dlang(i);
-         if (*s) {
-            tComponent *Component = Components->GetComponent(i, 4, 0); // AC3 component according to the DVB standard
-            if (!Component)
-               Component = Components->GetComponent(i, 2, 5); // fallback "Dolby" component according to the "Premiere pseudo standard"
-            if (!Component)
-               Components->SetComponent(Components->NumComponents(), 2, 5, s, NULL);
-            else if (strlen(s) > strlen(Component->language))
-               strn0cpy(Component->language, s, sizeof(Component->language));
-            }
-         }
-     // The same applies to subtitles:
-     for (int i = 0; i < MAXSPIDS; i++) {
-         const char *s = Channel->Slang(i);
-         if (*s) {
-            tComponent *Component = Components->GetComponent(i, 3, 3);
-            if (!Component)
-               Components->SetComponent(Components->NumComponents(), 3, 3, s, NULL);
-            else if (strlen(s) > strlen(Component->language))
-               strn0cpy(Component->language, s, sizeof(Component->language));
-            }
-         }
-     if (Components != event->Components())
-        ((cEvent *)event)->SetComponents(Components);
-     }
-}
-
-cRecordingInfo::cRecordingInfo(const char *FileName)
-{
-  channelID = tChannelID::InvalidID;
-  channelName = NULL;
-  ownEvent = new cEvent(0);
-  event = ownEvent;
-  aux = NULL;
-  framesPerSecond = DEFAULTFRAMESPERSECOND;
-  priority = MAXPRIORITY;
-  lifetime = MAXLIFETIME;
-  fileName = strdup(cString::sprintf("%s%s", FileName, INFOFILESUFFIX));
-}
-
-cRecordingInfo::~cRecordingInfo()
-{
-  delete ownEvent;
-  free(aux);
-  free(channelName);
-  free(fileName);
-}
-
-void cRecordingInfo::SetData(const char *Title, const char *ShortText, const char *Description)
-{
-  if (!isempty(Title))
-     ((cEvent *)event)->SetTitle(Title);
-  if (!isempty(ShortText))
-     ((cEvent *)event)->SetShortText(ShortText);
-  if (!isempty(Description))
-     ((cEvent *)event)->SetDescription(Description);
-}
-
-void cRecordingInfo::SetAux(const char *Aux)
-{
-  free(aux);
-  aux = Aux ? strdup(Aux) : NULL;
-}
-
-void cRecordingInfo::SetFramesPerSecond(double FramesPerSecond)
-{
-  framesPerSecond = FramesPerSecond;
-}
-
-bool cRecordingInfo::Read(FILE *f)
-{
-  if (ownEvent) {
-     cReadLine ReadLine;
-     char *s;
-     int line = 0;
-     while ((s = ReadLine.Read(f)) != NULL) {
-           ++line;
-           char *t = skipspace(s + 1);
-           switch (*s) {
-             case 'C': {
-                         char *p = strchr(t, ' ');
-                         if (p) {
-                            free(channelName);
-                            channelName = strdup(compactspace(p));
-                            *p = 0; // strips optional channel name
-                            }
-                         if (*t)
-                            channelID = tChannelID::FromString(t);
-                       }
-                       break;
-             case 'E': {
-                         unsigned int EventID;
-                         time_t StartTime;
-                         int Duration;
-                         unsigned int TableID = 0;
-                         unsigned int Version = 0xFF;
-                         int n = sscanf(t, "%u %ld %d %X %X", &EventID, &StartTime, &Duration, &TableID, &Version);
-                         if (n >= 3 && n <= 5) {
-                            ownEvent->SetEventID(EventID);
-                            ownEvent->SetStartTime(StartTime);
-                            ownEvent->SetDuration(Duration);
-                            ownEvent->SetTableID(uchar(TableID));
-                            ownEvent->SetVersion(uchar(Version));
-                            }
-                       }
-                       break;
-             case 'F': framesPerSecond = atod(t);
-                       break;
-             case 'L': lifetime = atoi(t);
-                       break;
-             case 'P': priority = atoi(t);
-                       break;
-             case '@': free(aux);
-                       aux = strdup(t);
-                       break;
-             case '#': break; // comments are ignored
-             default: if (!ownEvent->Parse(s)) {
-                         esyslog("ERROR: EPG data problem in line %d", line);
-                         return false;
-                         }
-                      break;
-             }
-           }
-     return true;
-     }
-  return false;
-}
-
-bool cRecordingInfo::Write(FILE *f, const char *Prefix) const
-{
-  if (channelID.Valid())
-     fprintf(f, "%sC %s%s%s\n", Prefix, *channelID.ToString(), channelName ? " " : "", channelName ? channelName : "");
-  event->Dump(f, Prefix, true);
-  fprintf(f, "%sF %s\n", Prefix, *dtoa(framesPerSecond, "%.10g"));
-  fprintf(f, "%sP %d\n", Prefix, priority);
-  fprintf(f, "%sL %d\n", Prefix, lifetime);
-  if (aux)
-     fprintf(f, "%s@ %s\n", Prefix, aux);
-  return true;
-}
-
-bool cRecordingInfo::Read(void)
-{
-  bool Result = false;
-  if (fileName) {
-     FILE *f = fopen(fileName, "r");
-     if (f) {
-        if (Read(f))
-           Result = true;
-        else
-           esyslog("ERROR: EPG data problem in file %s", fileName);
-        fclose(f);
-        }
-     else if (errno != ENOENT)
-        LOG_ERROR_STR(fileName);
-     }
-  return Result;
-}
-
-bool cRecordingInfo::Write(void) const
-{
-  bool Result = false;
-  if (fileName) {
-     cSafeFile f(fileName);
-     if (f.Open()) {
-        if (Write(f))
-           Result = true;
-        f.Close();
-        }
-     else
-        LOG_ERROR_STR(fileName);
-     }
-  return Result;
-}
-
-// --- cRecording ------------------------------------------------------------
-
-#define RESUME_NOT_INITIALIZED (-2)
-
-struct tCharExchange { char a; char b; };
-tCharExchange CharExchange[] = {
-  { FOLDERDELIMCHAR,  '/' },
-  { '/',  FOLDERDELIMCHAR },
-  { ' ',  '_'    },
-  // backwards compatibility:
-  { '\'', '\''   },
-  { '\'', '\x01' },
-  { '/',  '\x02' },
-  { 0, 0 }
-  };
-
-const char *InvalidChars = "\"\\/:*?|<>#";
-
-bool NeedsConversion(const char *p)
-{
-  return DirectoryEncoding &&
-         (strchr(InvalidChars, *p) // characters that can't be part of a Windows file/directory name
-          || *p == '.' && (!*(p + 1) || *(p + 1) == FOLDERDELIMCHAR)); // Windows can't handle '.' at the end of file/directory names
-}
-
-char *ExchangeChars(char *s, bool ToFileSystem)
-{
-  char *p = s;
-  while (*p) {
-        if (DirectoryEncoding) {
-           // Some file systems can't handle all characters, so we
-           // have to take extra efforts to encode/decode them:
-           if (ToFileSystem) {
-              switch (*p) {
-                     // characters that can be mapped to other characters:
-                     case ' ': *p = '_'; break;
-                     case FOLDERDELIMCHAR: *p = '/'; break;
-                     case '/': *p = FOLDERDELIMCHAR; break;
-                     // characters that have to be encoded:
-                     default:
-                       if (NeedsConversion(p)) {
-                          int l = p - s;
-                          if (char *NewBuffer = (char *)realloc(s, strlen(s) + 10)) {
-                             s = NewBuffer;
-                             p = s + l;
-                             char buf[4];
-                             sprintf(buf, "#%02X", (unsigned char)*p);
-                             memmove(p + 2, p, strlen(p) + 1);
-                             strncpy(p, buf, 3);
-                             p += 2;
-                             }
-                          else
-                             esyslog("ERROR: out of memory");
-                          }
-                     }
-              }
-           else {
-              switch (*p) {
-                // mapped characters:
-                case '_': *p = ' '; break;
-                case FOLDERDELIMCHAR: *p = '/'; break;
-                case '/': *p = FOLDERDELIMCHAR; break;
-                // encoded characters:
-                case '#': {
-                     if (strlen(p) > 2 && isxdigit(*(p + 1)) && isxdigit(*(p + 2))) {
-                        char buf[3];
-                        sprintf(buf, "%c%c", *(p + 1), *(p + 2));
-                        uchar c = uchar(strtol(buf, NULL, 16));
-                        if (c) {
-                           *p = c;
-                           memmove(p + 1, p + 3, strlen(p) - 2);
-                           }
-                        }
-                     }
-                     break;
-                // backwards compatibility:
-                case '\x01': *p = '\''; break;
-                case '\x02': *p = '/';  break;
-                case '\x03': *p = ':';  break;
-                default: ;
-                }
-              }
-           }
-        else {
-           for (struct tCharExchange *ce = CharExchange; ce->a && ce->b; ce++) {
-               if (*p == (ToFileSystem ? ce->a : ce->b)) {
-                  *p = ToFileSystem ? ce->b : ce->a;
-                  break;
-                  }
-               }
-           }
-        p++;
-        }
-  return s;
-}
-
-char *LimitNameLengths(char *s, int PathMax, int NameMax)
-{
-  // Limits the total length of the directory path in 's' to PathMax, and each
-  // individual directory name to NameMax. The lengths of characters that need
-  // conversion when using 's' as a file name are taken into account accordingly.
-  // If a directory name exceeds NameMax, it will be truncated. If the whole
-  // directory path exceeds PathMax, individual directory names will be shortened
-  // (from right to left) until the limit is met, or until the currently handled
-  // directory name consists of only a single character. All operations are performed
-  // directly on the given 's', which may become shorter (but never longer) than
-  // the original value.
-  // Returns a pointer to 's'.
-  int Length = strlen(s);
-  int PathLength = 0;
-  // Collect the resulting lengths of each character:
-  bool NameTooLong = false;
-  int8_t a[Length];
-  int n = 0;
-  int NameLength = 0;
-  for (char *p = s; *p; p++) {
-      if (*p == FOLDERDELIMCHAR) {
-         a[n] = -1; // FOLDERDELIMCHAR is a single character, neg. sign marks it
-         NameTooLong |= NameLength > NameMax;
-         NameLength = 0;
-         PathLength += 1;
-         }
-      else if (NeedsConversion(p)) {
-         a[n] = 3; // "#xx"
-         NameLength += 3;
-         PathLength += 3;
-         }
-      else {
-         int8_t l = Utf8CharLen(p);
-         a[n] = l;
-         NameLength += l;
-         PathLength += l;
-         while (l-- > 1) {
-               a[++n] = 0;
-               p++;
-               }
-         }
-      n++;
-      }
-  NameTooLong |= NameLength > NameMax;
-  // Limit names to NameMax:
-  if (NameTooLong) {
-     while (n > 0) {
-           // Calculate the length of the current name:
-           int NameLength = 0;
-           int i = n;
-           int b = i;
-           while (i-- > 0 && a[i] >= 0) {
-                 NameLength += a[i];
-                 b = i;
-                 }
-           // Shorten the name if necessary:
-           if (NameLength > NameMax) {
-              int l = 0;
-              i = n;
-              while (i-- > 0 && a[i] >= 0) {
-                    l += a[i];
-                    if (NameLength - l <= NameMax) {
-                       memmove(s + i, s + n, Length - n + 1);
-                       memmove(a + i, a + n, Length - n + 1);
-                       Length -= n - i;
-                       PathLength -= l;
-                       break;
-                       }
-                    }
-              }
-           // Switch to the next name:
-           n = b - 1;
-           }
-     }
-  // Limit path to PathMax:
-  n = Length;
-  while (PathLength > PathMax && n > 0) {
-        // Calculate how much to cut off the current name:
-        int i = n;
-        int b = i;
-        int l = 0;
-        while (--i > 0 && a[i - 1] >= 0) {
-              if (a[i] > 0) {
-                 l += a[i];
-                 b = i;
-                 if (PathLength - l <= PathMax)
-                    break;
-                 }
-              }
-        // Shorten the name if necessary:
-        if (l > 0) {
-           memmove(s + b, s + n, Length - n + 1);
-           Length -= n - b;
-           PathLength -= l;
-           }
-        // Switch to the next name:
-        n = i - 1;
-        }
-  return s;
-}
-
-cRecording::cRecording(cTimer *Timer, const cEvent *Event)
-{
-  resume = RESUME_NOT_INITIALIZED;
-  titleBuffer = NULL;
-  sortBufferName = sortBufferTime = NULL;
-  fileName = NULL;
-  name = NULL;
-  fileSizeMB = -1; // unknown
-  channel = Timer->Channel()->Number();
-  instanceId = InstanceId;
-  isPesRecording = false;
-  isOnVideoDirectoryFileSystem = -1; // unknown
-  framesPerSecond = DEFAULTFRAMESPERSECOND;
-  numFrames = -1;
-  deleted = 0;
-  // set up the actual name:
-  const char *Title = Event ? Event->Title() : NULL;
-  const char *Subtitle = Event ? Event->ShortText() : NULL;
-  if (isempty(Title))
-     Title = Timer->Channel()->Name();
-  if (isempty(Subtitle))
-     Subtitle = " ";
-  const char *macroTITLE   = strstr(Timer->File(), TIMERMACRO_TITLE);
-  const char *macroEPISODE = strstr(Timer->File(), TIMERMACRO_EPISODE);
-  if (macroTITLE || macroEPISODE) {
-     name = strdup(Timer->File());
-     name = strreplace(name, TIMERMACRO_TITLE, Title);
-     name = strreplace(name, TIMERMACRO_EPISODE, Subtitle);
-     // avoid blanks at the end:
-     int l = strlen(name);
-     while (l-- > 2) {
-           if (name[l] == ' ' && name[l - 1] != FOLDERDELIMCHAR)
-              name[l] = 0;
-           else
-              break;
-           }
-     if (Timer->IsSingleEvent()) {
-        Timer->SetFile(name); // this was an instant recording, so let's set the actual data
-        Timers.SetModified();
-        }
-     }
-  else if (Timer->IsSingleEvent() || !Setup.UseSubtitle)
-     name = strdup(Timer->File());
-  else
-     name = strdup(cString::sprintf("%s~%s", Timer->File(), Subtitle));
-  // substitute characters that would cause problems in file names:
-  strreplace(name, '\n', ' ');
-  start = Timer->StartTime();
-  priority = Timer->Priority();
-  lifetime = Timer->Lifetime();
-  // handle info:
-  info = new cRecordingInfo(Timer->Channel(), Event);
-  info->SetAux(Timer->Aux());
-  info->priority = priority;
-  info->lifetime = lifetime;
-}
-
-cRecording::cRecording(const char *FileName)
-{
-  resume = RESUME_NOT_INITIALIZED;
-  fileSizeMB = -1; // unknown
-  channel = -1;
-  instanceId = -1;
-  priority = MAXPRIORITY; // assume maximum in case there is no info file
-  lifetime = MAXLIFETIME;
-  isPesRecording = false;
-  isOnVideoDirectoryFileSystem = -1; // unknown
-  framesPerSecond = DEFAULTFRAMESPERSECOND;
-  numFrames = -1;
-  deleted = 0;
-  titleBuffer = NULL;
-  sortBufferName = sortBufferTime = NULL;
-  FileName = fileName = strdup(FileName);
-  if (*(fileName + strlen(fileName) - 1) == '/')
-     *(fileName + strlen(fileName) - 1) = 0;
-  if (strstr(FileName, VideoDirectory) == FileName)
-     FileName += strlen(VideoDirectory) + 1;
-  const char *p = strrchr(FileName, '/');
-
-  name = NULL;
-  info = new cRecordingInfo(fileName);
-  if (p) {
-     time_t now = time(NULL);
-     struct tm tm_r;
-     struct tm t = *localtime_r(&now, &tm_r); // this initializes the time zone in 't'
-     t.tm_isdst = -1; // makes sure mktime() will determine the correct DST setting
-     if (7 == sscanf(p + 1, DATAFORMATTS, &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &channel, &instanceId)
-      || 7 == sscanf(p + 1, DATAFORMATPES, &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &priority, &lifetime)) {
-        t.tm_year -= 1900;
-        t.tm_mon--;
-        t.tm_sec = 0;
-        start = mktime(&t);
-        name = MALLOC(char, p - FileName + 1);
-        strncpy(name, FileName, p - FileName);
-        name[p - FileName] = 0;
-        name = ExchangeChars(name, false);
-        isPesRecording = instanceId < 0;
-        }
-     else
-        return;
-     GetResume();
-     // read an optional info file:
-     cString InfoFileName = cString::sprintf("%s%s", fileName, isPesRecording ? INFOFILESUFFIX ".vdr" : INFOFILESUFFIX);
-     FILE *f = fopen(InfoFileName, "r");
-     if (f) {
-        if (!info->Read(f))
-           esyslog("ERROR: EPG data problem in file %s", *InfoFileName);
-        else if (!isPesRecording) {
-           priority = info->priority;
-           lifetime = info->lifetime;
-           framesPerSecond = info->framesPerSecond;
-           }
-        fclose(f);
-        }
-     else if (errno == ENOENT)
-        info->ownEvent->SetTitle(name);
-     else
-        LOG_ERROR_STR(*InfoFileName);
-#ifdef SUMMARYFALLBACK
-     // fall back to the old 'summary.vdr' if there was no 'info.vdr':
-     if (isempty(info->Title())) {
-        cString SummaryFileName = cString::sprintf("%s%s", fileName, SUMMARYFILESUFFIX);
-        FILE *f = fopen(SummaryFileName, "r");
-        if (f) {
-           int line = 0;
-           char *data[3] = { NULL };
-           cReadLine ReadLine;
-           char *s;
-           while ((s = ReadLine.Read(f)) != NULL) {
-                 if (*s || line > 1) {
-                    if (data[line]) {
-                       int len = strlen(s);
-                       len += strlen(data[line]) + 1;
-                       if (char *NewBuffer = (char *)realloc(data[line], len + 1)) {
-                          data[line] = NewBuffer;
-                          strcat(data[line], "\n");
-                          strcat(data[line], s);
-                          }
-                       else
-                          esyslog("ERROR: out of memory");
-                       }
-                    else
-                       data[line] = strdup(s);
-                    }
-                 else
-                    line++;
-                 }
-           fclose(f);
-           if (!data[2]) {
-              data[2] = data[1];
-              data[1] = NULL;
-              }
-           else if (data[1] && data[2]) {
-              // if line 1 is too long, it can't be the short text,
-              // so assume the short text is missing and concatenate
-              // line 1 and line 2 to be the long text:
-              int len = strlen(data[1]);
-              if (len > 80) {
-                 if (char *NewBuffer = (char *)realloc(data[1], len + 1 + strlen(data[2]) + 1)) {
-                    data[1] = NewBuffer;
-                    strcat(data[1], "\n");
-                    strcat(data[1], data[2]);
-                    free(data[2]);
-                    data[2] = data[1];
-                    data[1] = NULL;
-                    }
-                 else
-                    esyslog("ERROR: out of memory");
-                 }
-              }
-           info->SetData(data[0], data[1], data[2]);
-           for (int i = 0; i < 3; i ++)
-               free(data[i]);
-           }
-        else if (errno != ENOENT)
-           LOG_ERROR_STR(*SummaryFileName);
-        }
-#endif
-     }
-}
-
-cRecording::~cRecording()
-{
-  free(titleBuffer);
-  free(sortBufferName);
-  free(sortBufferTime);
-  free(fileName);
-  free(name);
-  delete info;
-}
-
-char *cRecording::StripEpisodeName(char *s, bool Strip)
-{
-  char *t = s, *s1 = NULL, *s2 = NULL;
-  while (*t) {
-        if (*t == '/') {
-           if (s1) {
-              if (s2)
-                 s1 = s2;
-              s2 = t;
-              }
-           else
-              s1 = t;
-           }
-        t++;
-        }
-  if (s1 && s2) {
-     // To have folders sorted before plain recordings, the '/' s1 points to
-     // is replaced by the character '1'. All other slashes will be replaced
-     // by '0' in SortName() (see below), which will result in the desired
-     // sequence:
-     *s1 = '1';
-     if (Strip) {
-        s1++;
-        memmove(s1, s2, t - s2 + 1);
-        }
-     }
-  return s;
-}
-
-char *cRecording::SortName(void) const
-{
-  char **sb = (RecordingsSortMode == rsmName) ? &sortBufferName : &sortBufferTime;
-  if (!*sb) {
-     char *s = strdup(FileName() + strlen(VideoDirectory));
-     if (RecordingsSortMode != rsmName || Setup.AlwaysSortFoldersFirst)
-        s = StripEpisodeName(s, RecordingsSortMode != rsmName);
-     strreplace(s, '/', '0'); // some locales ignore '/' when sorting
-     int l = strxfrm(NULL, s, 0) + 1;
-     *sb = MALLOC(char, l);
-     strxfrm(*sb, s, l);
-     free(s);
-     }
-  return *sb;
-}
-
-void cRecording::ClearSortName(void)
-{
-  DELETENULL(sortBufferName);
-  DELETENULL(sortBufferTime);
-}
-
-int cRecording::GetResume(void) const
-{
-  if (resume == RESUME_NOT_INITIALIZED) {
-     cResumeFile ResumeFile(FileName(), isPesRecording);
-     resume = ResumeFile.Read();
-     }
-  return resume;
-}
-
-int cRecording::Compare(const cListObject &ListObject) const
-{
-  cRecording *r = (cRecording *)&ListObject;
-  return strcasecmp(SortName(), r->SortName());
-}
-
-const char *cRecording::FileName(void) const
-{
-  if (!fileName) {
-     struct tm tm_r;
-     struct tm *t = localtime_r(&start, &tm_r);
-     const char *fmt = isPesRecording ? NAMEFORMATPES : NAMEFORMATTS;
-     int ch = isPesRecording ? priority : channel;
-     int ri = isPesRecording ? lifetime : instanceId;
-     char *Name = LimitNameLengths(strdup(name), DirectoryPathMax - strlen(VideoDirectory) - 1 - 42, DirectoryNameMax); // 42 = length of an actual recording directory name (generated with DATAFORMATTS) plus some reserve
-     if (strcmp(Name, name) != 0)
-        dsyslog("recording file name '%s' truncated to '%s'", name, Name);
-     Name = ExchangeChars(Name, true);
-     fileName = strdup(cString::sprintf(fmt, VideoDirectory, Name, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch, ri));
-     free(Name);
-     }
-  return fileName;
-}
-
-const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level) const
-{
-  const char *New = NewIndicator && IsNew() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_NEW_UTF8 : ICON_NEW : "*" : " ";
-  free(titleBuffer);
-  titleBuffer = NULL;
-  if (Level < 0 || Level == HierarchyLevels()) {
-     struct tm tm_r;
-     struct tm *t = localtime_r(&start, &tm_r);
-     char *s;
-     if (Level > 0 && (s = strrchr(name, FOLDERDELIMCHAR)) != NULL)
-        s++;
-     else
-        s = name;
-     cString Length("");
-     if (NewIndicator) {
-        int Minutes = max(0, (LengthInSeconds() + 30) / 60);
-        Length = cString::sprintf("%c%d:%02d",
-                   Delimiter,
-                   Minutes / 60,
-                   Minutes % 60
-                   );
-        }
-     titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%s%s%c%s",
-                            t->tm_mday,
-                            t->tm_mon + 1,
-                            t->tm_year % 100,
-                            Delimiter,
-                            t->tm_hour,
-                            t->tm_min,
-                            *Length,
-                            New,
-                            Delimiter,
-                            s));
-     // let's not display a trailing FOLDERDELIMCHAR:
-     if (!NewIndicator)
-        stripspace(titleBuffer);
-     s = &titleBuffer[strlen(titleBuffer) - 1];
-     if (*s == FOLDERDELIMCHAR)
-        *s = 0;
-     }
-  else if (Level < HierarchyLevels()) {
-     const char *s = name;
-     const char *p = s;
-     while (*++s) {
-           if (*s == FOLDERDELIMCHAR) {
-              if (Level--)
-                 p = s + 1;
-              else
-                 break;
-              }
-           }
-     titleBuffer = MALLOC(char, s - p + 3);
-     *titleBuffer = Delimiter;
-     *(titleBuffer + 1) = Delimiter;
-     strn0cpy(titleBuffer + 2, p, s - p + 1);
-     }
-  else
-     return "";
-  return titleBuffer;
-}
-
-const char *cRecording::PrefixFileName(char Prefix)
-{
-  cString p = PrefixVideoFileName(FileName(), Prefix);
-  if (*p) {
-     free(fileName);
-     fileName = strdup(p);
-     return fileName;
-     }
-  return NULL;
-}
-
-const char *cRecording::UpdateFileName(const char *FileName)
-{
-  if (FileName && *FileName) {
-     free(fileName);
-     fileName = strdup(FileName);
-     return fileName;
-     }
-  return NULL;
-}
-
-int cRecording::HierarchyLevels(void) const
-{
-  const char *s = name;
-  int level = 0;
-  while (*++s) {
-        if (*s == FOLDERDELIMCHAR)
-           level++;
-        }
-  return level;
-}
-
-bool cRecording::IsEdited(void) const
-{
-  const char *s = strrchr(name, FOLDERDELIMCHAR);
-  s = !s ? name : s + 1;
-  return *s == '%';
-}
-
-bool cRecording::IsOnVideoDirectoryFileSystem(void) const
-{
-  if (isOnVideoDirectoryFileSystem < 0)
-     isOnVideoDirectoryFileSystem = ::IsOnVideoDirectoryFileSystem(FileName());
-  return isOnVideoDirectoryFileSystem;
-}
-
-void cRecording::ReadInfo(void)
-{
-  info->Read();
-  priority = info->priority;
-  lifetime = info->lifetime;
-  framesPerSecond = info->framesPerSecond;
-}
-
-bool cRecording::WriteInfo(void)
-{
-  cString InfoFileName = cString::sprintf("%s%s", fileName, isPesRecording ? INFOFILESUFFIX ".vdr" : INFOFILESUFFIX);
-  FILE *f = fopen(InfoFileName, "w");
-  if (f) {
-     info->Write(f);
-     fclose(f);
-     }
-  else
-     LOG_ERROR_STR(*InfoFileName);
-  return true;
-}
-
-void cRecording::SetStartTime(time_t Start)
-{
-  start = Start;
-  free(fileName);
-  fileName = NULL;
-}
-
-bool cRecording::Delete(void)
-{
-  bool result = true;
-  char *NewName = strdup(FileName());
-  char *ext = strrchr(NewName, '.');
-  if (ext && strcmp(ext, RECEXT) == 0) {
-     strncpy(ext, DELEXT, strlen(ext));
-     if (access(NewName, F_OK) == 0) {
-        // the new name already exists, so let's remove that one first:
-        isyslog("removing recording '%s'", NewName);
-        RemoveVideoFile(NewName);
-        }
-     isyslog("deleting recording '%s'", FileName());
-     if (access(FileName(), F_OK) == 0) {
-        result = RenameVideoFile(FileName(), NewName);
-        cRecordingUserCommand::InvokeCommand(RUC_DELETERECORDING, NewName);
-        }
-     else {
-        isyslog("recording '%s' vanished", FileName());
-        result = true; // well, we were going to delete it, anyway
-        }
-     }
-  free(NewName);
-  return result;
-}
-
-bool cRecording::Remove(void)
-{
-  // let's do a final safety check here:
-  if (!endswith(FileName(), DELEXT)) {
-     esyslog("attempt to remove recording %s", FileName());
-     return false;
-     }
-  isyslog("removing recording %s", FileName());
-  return RemoveVideoFile(FileName());
-}
-
-bool cRecording::Undelete(void)
-{
-  bool result = true;
-  char *NewName = strdup(FileName());
-  char *ext = strrchr(NewName, '.');
-  if (ext && strcmp(ext, DELEXT) == 0) {
-     strncpy(ext, RECEXT, strlen(ext));
-     if (access(NewName, F_OK) == 0) {
-        // the new name already exists, so let's not remove that one:
-        esyslog("ERROR: attempt to undelete '%s', while recording '%s' exists", FileName(), NewName);
-        result = false;
-        }
-     else {
-        isyslog("undeleting recording '%s'", FileName());
-        if (access(FileName(), F_OK) == 0)
-           result = RenameVideoFile(FileName(), NewName);
-        else {
-           isyslog("deleted recording '%s' vanished", FileName());
-           result = false;
-           }
-        }
-     }
-  free(NewName);
-  return result;
-}
-
-void cRecording::ResetResume(void) const
-{
-  resume = RESUME_NOT_INITIALIZED;
-}
-
-int cRecording::NumFrames(void) const
-{
-  if (numFrames < 0) {
-     int nf = cIndexFile::GetLength(FileName(), IsPesRecording());
-     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
-        return nf; // check again later for ongoing recordings
-     numFrames = nf;
-     }
-  return numFrames;
-}
-
-int cRecording::LengthInSeconds(void) const
-{
-  int nf = NumFrames();
-  if (nf >= 0)
-     return int(nf / FramesPerSecond());
-  return -1;
-}
-
-int cRecording::FileSizeMB(void) const
-{
-  if (fileSizeMB < 0) {
-     int fs = DirSizeMB(FileName());
-     if (time(NULL) - LastModifiedTime(cIndexFile::IndexFileName(FileName(), IsPesRecording())) < MININDEXAGE)
-        return fs; // check again later for ongoing recordings
-     fileSizeMB = fs;
-     }
-  return fileSizeMB;
-}
-
-// --- cRecordings -----------------------------------------------------------
-
-cRecordings Recordings;
-
-char *cRecordings::updateFileName = NULL;
-
-cRecordings::cRecordings(bool Deleted)
-:cThread("video directory scanner")
-{
-  deleted = Deleted;
-  lastUpdate = 0;
-  state = 0;
-}
-
-cRecordings::~cRecordings()
-{
-  Cancel(3);
-}
-
-void cRecordings::Action(void)
-{
-  Refresh();
-}
-
-const char *cRecordings::UpdateFileName(void)
-{
-  if (!updateFileName)
-     updateFileName = strdup(AddDirectory(VideoDirectory, ".update"));
-  return updateFileName;
-}
-
-void cRecordings::Refresh(bool Foreground)
-{
-  lastUpdate = time(NULL); // doing this first to make sure we don't miss anything
-  Lock();
-  Clear();
-  ChangeState();
-  Unlock();
-  ScanVideoDir(VideoDirectory, Foreground);
-}
-
-void cRecordings::ScanVideoDir(const char *DirName, bool Foreground, int LinkLevel)
-{
-  cReadDir d(DirName);
-  struct dirent *e;
-  while ((Foreground || Running()) && (e = d.Next()) != NULL) {
-        cString buffer = AddDirectory(DirName, e->d_name);
-        struct stat st;
-        if (lstat(buffer, &st) == 0) {
-           int Link = 0;
-           if (S_ISLNK(st.st_mode)) {
-              if (LinkLevel > MAX_LINK_LEVEL) {
-                 isyslog("max link level exceeded - not scanning %s", *buffer);
-                 continue;
-                 }
-              Link = 1;
-              if (stat(buffer, &st) != 0)
-                 continue;
-              }
-           if (S_ISDIR(st.st_mode)) {
-              if (endswith(buffer, deleted ? DELEXT : RECEXT)) {
-                 cRecording *r = new cRecording(buffer);
-                 if (r->Name()) {
-                    r->NumFrames(); // initializes the numFrames member
-                    r->FileSizeMB(); // initializes the fileSizeMB member
-                    if (deleted)
-                       r->deleted = time(NULL);
-                    Lock();
-                    Add(r);
-                    ChangeState();
-                    Unlock();
-                    }
-                 else
-                    delete r;
-                 }
-              else
-                 ScanVideoDir(buffer, Foreground, LinkLevel + Link);
-              }
-           }
-        }
-}
-
-bool cRecordings::StateChanged(int &State)
-{
-  int NewState = state;
-  bool Result = State != NewState;
-  State = state;
-  return Result;
-}
-
-void cRecordings::TouchUpdate(void)
-{
-  bool needsUpdate = NeedsUpdate();
-  TouchFile(UpdateFileName());
-  if (!needsUpdate)
-     lastUpdate = time(NULL); // make sure we don't trigger ourselves
-}
-
-bool cRecordings::NeedsUpdate(void)
-{
-  time_t lastModified = LastModifiedTime(UpdateFileName());
-  if (lastModified > time(NULL))
-     return false; // somebody's clock isn't running correctly
-  return lastUpdate < lastModified;
-}
-
-bool cRecordings::Update(bool Wait)
-{
-  if (Wait) {
-     Refresh(true);
-     return Count() > 0;
-     }
-  else
-     Start();
-  return false;
-}
-
-cRecording *cRecordings::GetByName(const char *FileName)
-{
-  if (FileName) {
-     for (cRecording *recording = First(); recording; recording = Next(recording)) {
-         if (strcmp(recording->FileName(), FileName) == 0)
-            return recording;
-         }
-     }
-  return NULL;
-}
-
-void cRecordings::AddByName(const char *FileName, bool TriggerUpdate)
-{
-  LOCK_THREAD;
-  cRecording *recording = GetByName(FileName);
-  if (!recording) {
-     recording = new cRecording(FileName);
-     Add(recording);
-     ChangeState();
-     if (TriggerUpdate)
-        TouchUpdate();
-     }
-}
-
-void cRecordings::DelByName(const char *FileName, bool RemoveRecording)
-{
-  LOCK_THREAD;
-  cRecording *recording = GetByName(FileName);
-  if (recording) {
-     cThreadLock DeletedRecordingsLock(&DeletedRecordings);
-     Del(recording, false);
-     char *ext = strrchr(recording->fileName, '.');
-     if (ext && RemoveRecording) {
-        strncpy(ext, DELEXT, strlen(ext));
-        if (access(recording->FileName(), F_OK) == 0) {
-           recording->deleted = time(NULL);
-           DeletedRecordings.Add(recording);
-           recording = NULL; // to prevent it from being deleted below
-           }
-        }
-     delete recording;
-     ChangeState();
-     TouchUpdate();
-     }
-}
-
-void cRecordings::UpdateByName(const char *FileName)
-{
-  LOCK_THREAD;
-  cRecording *recording = GetByName(FileName);
-  if (recording)
-     recording->ReadInfo();
-}
-
-int cRecordings::TotalFileSizeMB(void)
-{
-  int size = 0;
-  LOCK_THREAD;
-  for (cRecording *recording = First(); recording; recording = Next(recording)) {
-      int FileSizeMB = recording->FileSizeMB();
-      if (FileSizeMB > 0 && recording->IsOnVideoDirectoryFileSystem())
-         size += FileSizeMB;
-      }
-  return size;
-}
-
-double cRecordings::MBperMinute(void)
-{
-  int size = 0;
-  int length = 0;
-  LOCK_THREAD;
-  for (cRecording *recording = First(); recording; recording = Next(recording)) {
-      if (recording->IsOnVideoDirectoryFileSystem()) {
-         int FileSizeMB = recording->FileSizeMB();
-         if (FileSizeMB > 0) {
-            int LengthInSeconds = recording->LengthInSeconds();
-            if (LengthInSeconds > 0) {
-               size += FileSizeMB;
-               length += LengthInSeconds;
-               }
-            }
-         }
-      }
-  return (size && length) ? double(size) * 60 / length : -1;
-}
-
-void cRecordings::ResetResume(const char *ResumeFileName)
-{
-  LOCK_THREAD;
-  for (cRecording *recording = First(); recording; recording = Next(recording)) {
-      if (!ResumeFileName || strncmp(ResumeFileName, recording->FileName(), strlen(recording->FileName())) == 0)
-         recording->ResetResume();
-      }
-  ChangeState();
-}
-
-void cRecordings::ClearSortNames(void)
-{
-  LOCK_THREAD;
-  for (cRecording *recording = First(); recording; recording = Next(recording))
-      recording->ClearSortName();
-}
-
-// --- cMark -----------------------------------------------------------------
-
-double MarkFramesPerSecond = DEFAULTFRAMESPERSECOND;
-cMutex MutexMarkFramesPerSecond;
-
-cMark::cMark(int Position, const char *Comment, double FramesPerSecond)
-{
-  position = Position;
-  comment = Comment;
-  framesPerSecond = FramesPerSecond;
-}
-
-cMark::~cMark()
-{
-}
-
-cString cMark::ToText(void)
-{
-  return cString::sprintf("%s%s%s\n", *IndexToHMSF(position, true, framesPerSecond), Comment() ? " " : "", Comment() ? Comment() : "");
-}
-
-bool cMark::Parse(const char *s)
-{
-  comment = NULL;
-  framesPerSecond = MarkFramesPerSecond;
-  position = HMSFToIndex(s, framesPerSecond);
-  const char *p = strchr(s, ' ');
-  if (p) {
-     p = skipspace(p);
-     if (*p)
-        comment = strdup(p);
-     }
-  return true;
-}
-
-bool cMark::Save(FILE *f)
-{
-  return fprintf(f, "%s", *ToText()) > 0;
-}
-
-// --- cMarks ----------------------------------------------------------------
-
-bool cMarks::Load(const char *RecordingFileName, double FramesPerSecond, bool IsPesRecording)
-{
-  recordingFileName = RecordingFileName;
-  fileName = AddDirectory(RecordingFileName, IsPesRecording ? MARKSFILESUFFIX ".vdr" : MARKSFILESUFFIX);
-  framesPerSecond = FramesPerSecond;
-  isPesRecording = IsPesRecording;
-  nextUpdate = 0;
-  lastFileTime = -1; // the first call to Load() must take place!
-  lastChange = 0;
-  return Update();
-}
-
-bool cMarks::Update(void)
-{
-  time_t t = time(NULL);
-  if (t > nextUpdate) {
-     time_t LastModified = LastModifiedTime(fileName);
-     if (LastModified != lastFileTime) // change detected, or first run
-        lastChange = LastModified > 0 ? LastModified : t;
-     int d = t - lastChange;
-     if (d < 60)
-        d = 1; // check frequently if the file has just been modified
-     else if (d < 3600)
-        d = 10; // older files are checked less frequently
-     else
-        d /= 360; // phase out checking for very old files
-     nextUpdate = t + d;
-     if (LastModified != lastFileTime) { // change detected, or first run
-        lastFileTime = LastModified;
-        if (lastFileTime == t)
-           lastFileTime--; // make sure we don't miss updates in the remaining second
-        cMutexLock MutexLock(&MutexMarkFramesPerSecond);
-        MarkFramesPerSecond = framesPerSecond;
-        if (cConfig<cMark>::Load(fileName)) {
-           Align();
-           Sort();
-           return true;
-           }
-        }
-     }
-  return false;
-}
-
-bool cMarks::Save(void)
-{
-  if (cConfig<cMark>::Save()) {
-     lastFileTime = LastModifiedTime(fileName);
-     return true;
-     }
-  return false;
-}
-
-void cMarks::Align(void)
-{
-  cIndexFile IndexFile(recordingFileName, false, isPesRecording);
-  for (cMark *m = First(); m; m = Next(m)) {
-      int p = IndexFile.GetClosestIFrame(m->Position());
-      if (int d = m->Position() - p) {
-         isyslog("aligned editing mark %s to %s (off by %d frame%s)", *IndexToHMSF(m->Position(), true, framesPerSecond), *IndexToHMSF(p, true, framesPerSecond), d, abs(d) > 1 ? "s" : "");
-         m->SetPosition(p);
-         }
-      }
-}
-
-void cMarks::Sort(void)
-{
-  for (cMark *m1 = First(); m1; m1 = Next(m1)) {
-      for (cMark *m2 = Next(m1); m2; m2 = Next(m2)) {
-          if (m2->Position() < m1->Position()) {
-             swap(m1->position, m2->position);
-             swap(m1->comment, m2->comment);
-             }
-          }
-      }
-}
-
-void cMarks::Add(int Position)
-{
-  cConfig<cMark>::Add(new cMark(Position, NULL, framesPerSecond));
-  Sort();
-}
-
-cMark *cMarks::Get(int Position)
-{
-  for (cMark *mi = First(); mi; mi = Next(mi)) {
-      if (mi->Position() == Position)
-         return mi;
-      }
-  return NULL;
-}
-
-cMark *cMarks::GetPrev(int Position)
-{
-  for (cMark *mi = Last(); mi; mi = Prev(mi)) {
-      if (mi->Position() < Position)
-         return mi;
-      }
-  return NULL;
-}
-
-cMark *cMarks::GetNext(int Position)
-{
-  for (cMark *mi = First(); mi; mi = Next(mi)) {
-      if (mi->Position() > Position)
-         return mi;
-      }
-  return NULL;
-}
-
-cMark *cMarks::GetNextBegin(cMark *EndMark)
-{
-  cMark *BeginMark = EndMark ? Next(EndMark) : First();
-  if (BeginMark) {
-     while (cMark *NextMark = Next(BeginMark)) {
-           if (BeginMark->Position() == NextMark->Position()) { // skip Begin/End at the same position
-              if (!(BeginMark = Next(NextMark)))
-                 break;
-              }
-           else
-              break;
-           }
-     }
-  return BeginMark;
-}
-
-cMark *cMarks::GetNextEnd(cMark *BeginMark)
-{
-  if (!BeginMark)
-     return NULL;
-  cMark *EndMark = Next(BeginMark);
-  if (EndMark) {
-     while (cMark *NextMark = Next(EndMark)) {
-           if (EndMark->Position() == NextMark->Position()) { // skip End/Begin at the same position
-              if (!(EndMark = Next(NextMark)))
-                 break;
-              }
-           else
-              break;
-           }
-     }
-  return EndMark;
-}
-
-int cMarks::GetNumSequences(void)
-{
-  int NumSequences = 0;
-  if (cMark *BeginMark = GetNextBegin()) {
-     while (cMark *EndMark = GetNextEnd(BeginMark)) {
-           NumSequences++;
-           BeginMark = GetNextBegin(EndMark);
-           }
-     if (BeginMark) {
-        NumSequences++; // the last sequence had no actual "end" mark
-        if (NumSequences == 1 && BeginMark->Position() == 0)
-           NumSequences = 0; // there is only one actual "begin" mark at offset zero, and no actual "end" mark
-        }
-     }
-  return NumSequences;
-}
-
-// --- cRecordingUserCommand -------------------------------------------------
-
-const char *cRecordingUserCommand::command = NULL;
-
-void cRecordingUserCommand::InvokeCommand(const char *State, const char *RecordingFileName, const char *SourceFileName)
-{
-  if (command) {
-    cString cmd;
-    if (SourceFileName)
-       cmd = cString::sprintf("%s %s \"%s\" \"%s\"", command, State, *strescape(RecordingFileName, "\\\"$"), *strescape(SourceFileName, "\\\"$"));
-    else
-       cmd = cString::sprintf("%s %s \"%s\"", command, State, *strescape(RecordingFileName, "\\\"$"));
-    isyslog("executing '%s'", *cmd);
-    SystemExec(cmd);
-  }
-}
-
-// --- cIndexFileGenerator ---------------------------------------------------
-
-#define IFG_BUFFER_SIZE KILOBYTE(100)
-
-class cIndexFileGenerator : public cThread {
-private:
-  cString recordingName;
-protected:
-  virtual void Action(void);
-public:
-  cIndexFileGenerator(const char *RecordingName);
-  ~cIndexFileGenerator();
-  };
-
-cIndexFileGenerator::cIndexFileGenerator(const char *RecordingName)
-:cThread("index file generator")
-,recordingName(RecordingName)
-{
-  Start();
-}
-
-cIndexFileGenerator::~cIndexFileGenerator()
-{
-  Cancel(3);
-}
-
-void cIndexFileGenerator::Action(void)
-{
-  bool IndexFileComplete = false;
-  bool IndexFileWritten = false;
-  bool Rewind = false;
-  cFileName FileName(recordingName, false);
-  cUnbufferedFile *ReplayFile = FileName.Open();
-  cRingBufferLinear Buffer(IFG_BUFFER_SIZE, MIN_TS_PACKETS_FOR_FRAME_DETECTOR * TS_SIZE);
-  cPatPmtParser PatPmtParser;
-  cFrameDetector FrameDetector;
-  cIndexFile IndexFile(recordingName, true);
-  int BufferChunks = KILOBYTE(1); // no need to read a lot at the beginning when parsing PAT/PMT
-  off_t FileSize = 0;
-  off_t FrameOffset = -1;
-  Skins.QueueMessage(mtInfo, tr("Regenerating index file"));
-  while (Running()) {
-        // Rewind input file:
-        if (Rewind) {
-           ReplayFile = FileName.SetOffset(1);
-           Buffer.Clear();
-           Rewind = false;
-           }
-        // Process data:
-        int Length;
-        uchar *Data = Buffer.Get(Length);
-        if (Data) {
-           if (FrameDetector.Synced()) {
-              // Step 3 - generate the index:
-              if (TsPid(Data) == PATPID)
-                 FrameOffset = FileSize; // the PAT/PMT is at the beginning of an I-frame
-              int Processed = FrameDetector.Analyze(Data, Length);
-              if (Processed > 0) {
-                 if (FrameDetector.NewFrame()) {
-                    IndexFile.Write(FrameDetector.IndependentFrame(), FileName.Number(), FrameOffset >= 0 ? FrameOffset : FileSize);
-                    FrameOffset = -1;
-                    IndexFileWritten = true;
-                    }
-                 FileSize += Processed;
-                 Buffer.Del(Processed);
-                 }
-              }
-           else if (PatPmtParser.Vpid()) {
-              // Step 2 - sync FrameDetector:
-              int Processed = FrameDetector.Analyze(Data, Length);
-              if (Processed > 0) {
-                 if (FrameDetector.Synced()) {
-                    // Synced FrameDetector, so rewind for actual processing:
-                    Rewind = true;
-                    }
-                 Buffer.Del(Processed);
-                 }
-              }
-           else {
-              // Step 1 - parse PAT/PMT:
-              uchar *p = Data;
-              while (Length >= TS_SIZE) {
-                    int Pid = TsPid(p);
-                    if (Pid == PATPID)
-                       PatPmtParser.ParsePat(p, TS_SIZE);
-                    else if (PatPmtParser.IsPmtPid(Pid))
-                       PatPmtParser.ParsePmt(p, TS_SIZE);
-                    Length -= TS_SIZE;
-                    p += TS_SIZE;
-                    if (PatPmtParser.Vpid()) {
-                       // Found Vpid, so rewind to sync FrameDetector:
-                       FrameDetector.SetPid(PatPmtParser.Vpid(), PatPmtParser.Vtype());
-                       BufferChunks = IFG_BUFFER_SIZE;
-                       Rewind = true;
-                       break;
-                       }
-                    }
-              Buffer.Del(p - Data);
-              }
-           }
-        // Read data:
-        else if (ReplayFile) {
-           int Result = Buffer.Read(ReplayFile, BufferChunks);
-           if (Result == 0) { // EOF
-              ReplayFile = FileName.NextFile();
-              FileSize = 0;
-              FrameOffset = -1;
-              Buffer.Clear();
-              }
-           }
-        // Recording has been processed:
-        else {
-           IndexFileComplete = true;
-           break;
-           }
-        }
-  if (IndexFileComplete) {
-     if (IndexFileWritten) {
-        cRecordingInfo RecordingInfo(recordingName);
-        if (RecordingInfo.Read()) {
-           if (FrameDetector.FramesPerSecond() > 0 && !DoubleEqual(RecordingInfo.FramesPerSecond(), FrameDetector.FramesPerSecond())) {
-              RecordingInfo.SetFramesPerSecond(FrameDetector.FramesPerSecond());
-              RecordingInfo.Write();
-              Recordings.UpdateByName(recordingName);
-              }
-           }
-        Skins.QueueMessage(mtInfo, tr("Index file regeneration complete"));
-        return;
-        }
-     else
-        Skins.QueueMessage(mtError, tr("Index file regeneration failed!"));
-     }
-  // Delete the index file if the recording has not been processed entirely:
-  IndexFile.Delete();
-}
-
-// --- cIndexFile ------------------------------------------------------------
-
-#define INDEXFILESUFFIX     "/index"
-
-// The maximum time to wait before giving up while catching up on an index file:
-#define MAXINDEXCATCHUP    8 // number of retries
-#define INDEXCATCHUPWAIT 100 // milliseconds
-
-struct tIndexPes {
-  uint32_t offset;
-  uchar type;
-  uchar number;
-  uint16_t reserved;
-  };
-
-struct tIndexTs {
-  uint64_t offset:40; // up to 1TB per file (not using off_t here - must definitely be exactly 64 bit!)
-  int reserved:7;     // reserved for future use
-  int independent:1;  // marks frames that can be displayed by themselves (for trick modes)
-  uint16_t number:16; // up to 64K files per recording
-  tIndexTs(off_t Offset, bool Independent, uint16_t Number)
-  {
-    offset = Offset;
-    reserved = 0;
-    independent = Independent;
-    number = Number;
-  }
-  };
-
-#define MAXWAITFORINDEXFILE     10 // max. time to wait for the regenerated index file (seconds)
-#define INDEXFILECHECKINTERVAL 500 // ms between checks for existence of the regenerated index file
-#define INDEXFILETESTINTERVAL   10 // ms between tests for the size of the index file in case of pausing live video
-
-cIndexFile::cIndexFile(const char *FileName, bool Record, bool IsPesRecording, bool PauseLive)
-:resumeFile(FileName, IsPesRecording)
-{
-  f = -1;
-  size = 0;
-  last = -1;
-  index = NULL;
-  isPesRecording = IsPesRecording;
-  indexFileGenerator = NULL;
-  if (FileName) {
-     fileName = IndexFileName(FileName, isPesRecording);
-     if (!Record && PauseLive) {
-        // Wait until the index file contains at least two frames:
-        time_t tmax = time(NULL) + MAXWAITFORINDEXFILE;
-        while (time(NULL) < tmax && FileSize(fileName) < off_t(2 * sizeof(tIndexTs)))
-              cCondWait::SleepMs(INDEXFILETESTINTERVAL);
-        }
-     int delta = 0;
-     if (!Record && access(fileName, R_OK) != 0) {
-        // Index file doesn't exist, so try to regenerate it:
-        if (!isPesRecording) { // sorry, can only do this for TS recordings
-           resumeFile.Delete(); // just in case
-           indexFileGenerator = new cIndexFileGenerator(FileName);
-           // Wait until the index file exists:
-           time_t tmax = time(NULL) + MAXWAITFORINDEXFILE;
-           do {
-              cCondWait::SleepMs(INDEXFILECHECKINTERVAL); // start with a sleep, to give it a head start
-              } while (access(fileName, R_OK) != 0 && time(NULL) < tmax);
-           }
-        }
-     if (access(fileName, R_OK) == 0) {
-        struct stat buf;
-        if (stat(fileName, &buf) == 0) {
-           delta = int(buf.st_size % sizeof(tIndexTs));
-           if (delta) {
-              delta = sizeof(tIndexTs) - delta;
-              esyslog("ERROR: invalid file size (%"PRId64") in '%s'", buf.st_size, *fileName);
-              }
-           last = int((buf.st_size + delta) / sizeof(tIndexTs) - 1);
-           if (!Record && last >= 0) {
-              size = last + 1;
-              index = MALLOC(tIndexTs, size);
-              if (index) {
-                 f = open(fileName, O_RDONLY);
-                 if (f >= 0) {
-                    if (safe_read(f, index, size_t(buf.st_size)) != buf.st_size) {
-                       esyslog("ERROR: can't read from file '%s'", *fileName);
-                       free(index);
-                       index = NULL;
-                       }
-                    else if (isPesRecording)
-                       ConvertFromPes(index, size);
-                    if (!index || time(NULL) - buf.st_mtime >= MININDEXAGE) {
-                       close(f);
-                       f = -1;
-                       }
-                    // otherwise we don't close f here, see CatchUp()!
-                    }
-                 else
-                    LOG_ERROR_STR(*fileName);
-                 }
-              else
-                 esyslog("ERROR: can't allocate %zd bytes for index '%s'", size * sizeof(tIndexTs), *fileName);
-              }
-           }
-        else
-           LOG_ERROR;
-        }
-     else if (!Record)
-        isyslog("missing index file %s", *fileName);
-     if (Record) {
-        if ((f = open(fileName, O_WRONLY | O_CREAT | O_APPEND, DEFFILEMODE)) >= 0) {
-           if (delta) {
-              esyslog("ERROR: padding index file with %d '0' bytes", delta);
-              while (delta--)
-                    writechar(f, 0);
-              }
-           }
-        else
-           LOG_ERROR_STR(*fileName);
-        }
-     }
-}
-
-cIndexFile::~cIndexFile()
-{
-  if (f >= 0)
-     close(f);
-  free(index);
-  delete indexFileGenerator;
-}
-
-cString cIndexFile::IndexFileName(const char *FileName, bool IsPesRecording)
-{
-  return cString::sprintf("%s%s", FileName, IsPesRecording ? INDEXFILESUFFIX ".vdr" : INDEXFILESUFFIX);
-}
-
-void cIndexFile::ConvertFromPes(tIndexTs *IndexTs, int Count)
-{
-  tIndexPes IndexPes;
-  while (Count-- > 0) {
-        memcpy(&IndexPes, IndexTs, sizeof(IndexPes));
-        IndexTs->offset = IndexPes.offset;
-        IndexTs->independent = IndexPes.type == 1; // I_FRAME
-        IndexTs->number = IndexPes.number;
-        IndexTs++;
-        }
-}
-
-void cIndexFile::ConvertToPes(tIndexTs *IndexTs, int Count)
-{
-  tIndexPes IndexPes;
-  while (Count-- > 0) {
-        IndexPes.offset = uint32_t(IndexTs->offset);
-        IndexPes.type = uchar(IndexTs->independent ? 1 : 2); // I_FRAME : "not I_FRAME" (exact frame type doesn't matter)
-        IndexPes.number = uchar(IndexTs->number);
-        IndexPes.reserved = 0;
-        memcpy(IndexTs, &IndexPes, sizeof(*IndexTs));
-        IndexTs++;
-        }
-}
-
-bool cIndexFile::CatchUp(int Index)
-{
-  // returns true unless something really goes wrong, so that 'index' becomes NULL
-  if (index && f >= 0) {
-     cMutexLock MutexLock(&mutex);
-     // Note that CatchUp() is triggered even if Index is 'last' (and thus valid).
-     // This is done to make absolutely sure we don't miss any data at the very end.
-     for (int i = 0; i <= MAXINDEXCATCHUP && (Index < 0 || Index >= last); i++) {
-         struct stat buf;
-         if (fstat(f, &buf) == 0) {
-            int newLast = int(buf.st_size / sizeof(tIndexTs) - 1);
-            if (newLast > last) {
-               int NewSize = size;
-               if (NewSize <= newLast) {
-                  NewSize *= 2;
-                  if (NewSize <= newLast)
-                     NewSize = newLast + 1;
-                  }
-               if (tIndexTs *NewBuffer = (tIndexTs *)realloc(index, NewSize * sizeof(tIndexTs))) {
-                  size = NewSize;
-                  index = NewBuffer;
-                  int offset = (last + 1) * sizeof(tIndexTs);
-                  int delta = (newLast - last) * sizeof(tIndexTs);
-                  if (lseek(f, offset, SEEK_SET) == offset) {
-                     if (safe_read(f, &index[last + 1], delta) != delta) {
-                        esyslog("ERROR: can't read from index");
-                        free(index);
-                        index = NULL;
-                        close(f);
-                        f = -1;
-                        break;
-                        }
-                     if (isPesRecording)
-                        ConvertFromPes(&index[last + 1], newLast - last);
-                     last = newLast;
-                     }
-                  else
-                     LOG_ERROR_STR(*fileName);
-                  }
-               else {
-                  esyslog("ERROR: can't realloc() index");
-                  break;
-                  }
-               }
-            }
-         else
-            LOG_ERROR_STR(*fileName);
-         if (Index < last)
-            break;
-         cCondVar CondVar;
-         CondVar.TimedWait(mutex, INDEXCATCHUPWAIT);
-         }
-     }
-  return index != NULL;
-}
-
-bool cIndexFile::Write(bool Independent, uint16_t FileNumber, off_t FileOffset)
-{
-  if (f >= 0) {
-     tIndexTs i(FileOffset, Independent, FileNumber);
-     if (isPesRecording)
-        ConvertToPes(&i, 1);
-     if (safe_write(f, &i, sizeof(i)) < 0) {
-        LOG_ERROR_STR(*fileName);
-        close(f);
-        f = -1;
-        return false;
-        }
-     last++;
-     }
-  return f >= 0;
-}
-
-bool cIndexFile::Get(int Index, uint16_t *FileNumber, off_t *FileOffset, bool *Independent, int *Length)
-{
-  if (CatchUp(Index)) {
-     if (Index >= 0 && Index <= last) {
-        *FileNumber = index[Index].number;
-        *FileOffset = index[Index].offset;
-        if (Independent)
-           *Independent = index[Index].independent;
-        if (Length) {
-           if (Index < last) {
-              uint16_t fn = index[Index + 1].number;
-              off_t fo = index[Index + 1].offset;
-              if (fn == *FileNumber)
-                 *Length = int(fo - *FileOffset);
-              else
-                 *Length = -1; // this means "everything up to EOF" (the buffer's Read function will act accordingly)
-              }
-           else
-              *Length = -1;
-           }
-        return true;
-        }
-     }
-  return false;
-}
-
-int cIndexFile::GetNextIFrame(int Index, bool Forward, uint16_t *FileNumber, off_t *FileOffset, int *Length)
-{
-  if (CatchUp()) {
-     int d = Forward ? 1 : -1;
-     for (;;) {
-         Index += d;
-         if (Index >= 0 && Index <= last) {
-            if (index[Index].independent) {
-               uint16_t fn;
-               if (!FileNumber)
-                  FileNumber = &fn;
-               off_t fo;
-               if (!FileOffset)
-                  FileOffset = &fo;
-               *FileNumber = index[Index].number;
-               *FileOffset = index[Index].offset;
-               if (Length) {
-                  if (Index < last) {
-                     uint16_t fn = index[Index + 1].number;
-                     off_t fo = index[Index + 1].offset;
-                     if (fn == *FileNumber)
-                        *Length = int(fo - *FileOffset);
-                     else
-                        *Length = -1; // this means "everything up to EOF" (the buffer's Read function will act accordingly)
-                     }
-                  else
-                     *Length = -1;
-                  }
-               return Index;
-               }
-            }
-         else
-            break;
-         }
-     }
-  return -1;
-}
-
-int cIndexFile::GetClosestIFrame(int Index)
-{
-  if (last > 0) {
-     Index = constrain(Index, 0, last);
-     if (index[Index].independent)
-        return Index;
-     int il = Index - 1;
-     int ih = Index + 1;
-     for (;;) {
-         if (il >= 0) {
-            if (index[il].independent)
-               return il;
-            il--;
-            }
-         else if (ih > last)
-            break;
-         if (ih <= last) {
-            if (index[ih].independent)
-               return ih;
-            ih++;
-            }
-         else if (il < 0)
-            break;
-         }
-     }
-  return 0;
-}
-
-int cIndexFile::Get(uint16_t FileNumber, off_t FileOffset)
-{
-  if (CatchUp()) {
-     //TODO implement binary search!
-     int i;
-     for (i = 0; i <= last; i++) {
-         if (index[i].number > FileNumber || (index[i].number == FileNumber) && off_t(index[i].offset) >= FileOffset)
-            break;
-         }
-     return i;
-     }
-  return -1;
-}
-
-bool cIndexFile::IsStillRecording()
-{
-  return f >= 0;
-}
-
-void cIndexFile::Delete(void)
-{
-  if (*fileName) {
-     dsyslog("deleting index file '%s'", *fileName);
-     if (f >= 0) {
-        close(f);
-        f = -1;
-        }
-     unlink(fileName);
-     }
-}
-
-int cIndexFile::GetLength(const char *FileName, bool IsPesRecording)
-{
-  struct stat buf;
-  cString s = IndexFileName(FileName, IsPesRecording);
-  if (*s && stat(s, &buf) == 0)
-     return buf.st_size / (IsPesRecording ? sizeof(tIndexTs) : sizeof(tIndexPes));
-  return -1;
-}
-
-bool GenerateIndex(const char *FileName)
-{
-  if (DirectoryOk(FileName)) {
-     cRecording Recording(FileName);
-     if (Recording.Name()) {
-        if (!Recording.IsPesRecording()) {
-           cString IndexFileName = AddDirectory(FileName, INDEXFILESUFFIX);
-           unlink(IndexFileName);
-           cIndexFileGenerator *IndexFileGenerator = new cIndexFileGenerator(FileName);
-           while (IndexFileGenerator->Active())
-                 cCondWait::SleepMs(INDEXFILECHECKINTERVAL);
-           if (access(IndexFileName, R_OK) == 0)
-              return true;
-           else
-              fprintf(stderr, "cannot create '%s'\n", *IndexFileName);
-           }
-        else
-           fprintf(stderr, "'%s' is not a TS recording\n", FileName);
-        }
-     else
-        fprintf(stderr, "'%s' is not a recording\n", FileName);
-     }
-  else
-     fprintf(stderr, "'%s' is not a directory\n", FileName);
-  return false;
-}
-
-// --- cFileName -------------------------------------------------------------
-
-#define MAXFILESPERRECORDINGPES 255
-#define RECORDFILESUFFIXPES     "/%03d.vdr"
-#define MAXFILESPERRECORDINGTS  65535
-#define RECORDFILESUFFIXTS      "/%05d.ts"
-#define RECORDFILESUFFIXLEN 20 // some additional bytes for safety...
-
-cFileName::cFileName(const char *FileName, bool Record, bool Blocking, bool IsPesRecording)
-{
-  file = NULL;
-  fileNumber = 0;
-  record = Record;
-  blocking = Blocking;
-  isPesRecording = IsPesRecording;
-  // Prepare the file name:
-  fileName = MALLOC(char, strlen(FileName) + RECORDFILESUFFIXLEN);
-  if (!fileName) {
-     esyslog("ERROR: can't copy file name '%s'", fileName);
-     return;
-     }
-  strcpy(fileName, FileName);
-  pFileNumber = fileName + strlen(fileName);
-  SetOffset(1);
-}
-
-cFileName::~cFileName()
-{
-  Close();
-  free(fileName);
-}
-
-bool cFileName::GetLastPatPmtVersions(int &PatVersion, int &PmtVersion)
-{
-  if (fileName && !isPesRecording) {
-     // Find the last recording file:
-     int Number = 1;
-     for (; Number <= MAXFILESPERRECORDINGTS + 1; Number++) { // +1 to correctly set Number in case there actually are that many files
-         sprintf(pFileNumber, RECORDFILESUFFIXTS, Number);
-         if (access(fileName, F_OK) != 0) { // file doesn't exist
-            Number--;
-            break;
-            }
-         }
-     for (; Number > 0; Number--) {
-         // Search for a PAT packet from the end of the file:
-         cPatPmtParser PatPmtParser;
-         sprintf(pFileNumber, RECORDFILESUFFIXTS, Number);
-         int fd = open(fileName, O_RDONLY | O_LARGEFILE, DEFFILEMODE);
-         if (fd >= 0) {
-            off_t pos = lseek(fd, -TS_SIZE, SEEK_END);
-            while (pos >= 0) {
-                  // Read and parse the PAT/PMT:
-                  uchar buf[TS_SIZE];
-                  while (read(fd, buf, sizeof(buf)) == sizeof(buf)) {
-                        if (buf[0] == TS_SYNC_BYTE) {
-                           int Pid = TsPid(buf);
-                           if (Pid == PATPID)
-                              PatPmtParser.ParsePat(buf, sizeof(buf));
-                           else if (PatPmtParser.IsPmtPid(Pid)) {
-                              PatPmtParser.ParsePmt(buf, sizeof(buf));
-                              if (PatPmtParser.GetVersions(PatVersion, PmtVersion)) {
-                                 close(fd);
-                                 return true;
-                                 }
-                              }
-                           else
-                              break; // PAT/PMT is always in one sequence
-                           }
-                        else
-                           return false;
-                        }
-                  pos = lseek(fd, pos - TS_SIZE, SEEK_SET);
-                  }
-            close(fd);
-            }
-         else
-            break;
-         }
-     }
-  return false;
-}
-
-cUnbufferedFile *cFileName::Open(void)
-{
-  if (!file) {
-     int BlockingFlag = blocking ? 0 : O_NONBLOCK;
-     if (record) {
-        dsyslog("recording to '%s'", fileName);
-        file = OpenVideoFile(fileName, O_RDWR | O_CREAT | O_LARGEFILE | BlockingFlag);
-        if (!file)
-           LOG_ERROR_STR(fileName);
-        }
-     else {
-        if (access(fileName, R_OK) == 0) {
-           dsyslog("playing '%s'", fileName);
-           file = cUnbufferedFile::Create(fileName, O_RDONLY | O_LARGEFILE | BlockingFlag);
-           if (!file)
-              LOG_ERROR_STR(fileName);
-           }
-        else if (errno != ENOENT)
-           LOG_ERROR_STR(fileName);
-        }
-     }
-  return file;
-}
-
-void cFileName::Close(void)
-{
-  if (file) {
-     if (CloseVideoFile(file) < 0)
-        LOG_ERROR_STR(fileName);
-     file = NULL;
-     }
-}
-
-cUnbufferedFile *cFileName::SetOffset(int Number, off_t Offset)
-{
-  if (fileNumber != Number)
-     Close();
-  int MaxFilesPerRecording = isPesRecording ? MAXFILESPERRECORDINGPES : MAXFILESPERRECORDINGTS;
-  if (0 < Number && Number <= MaxFilesPerRecording) {
-     fileNumber = uint16_t(Number);
-     sprintf(pFileNumber, isPesRecording ? RECORDFILESUFFIXPES : RECORDFILESUFFIXTS, fileNumber);
-     if (record) {
-        if (access(fileName, F_OK) == 0) {
-           // file exists, check if it has non-zero size
-           struct stat buf;
-           if (stat(fileName, &buf) == 0) {
-              if (buf.st_size != 0)
-                 return SetOffset(Number + 1); // file exists and has non zero size, let's try next suffix
-              else {
-                 // zero size file, remove it
-                 dsyslog("cFileName::SetOffset: removing zero-sized file %s", fileName);
-                 unlink(fileName);
-                 }
-              }
-           else
-              return SetOffset(Number + 1); // error with fstat - should not happen, just to be on the safe side
-           }
-        else if (errno != ENOENT) { // something serious has happened
-           LOG_ERROR_STR(fileName);
-           return NULL;
-           }
-        // found a non existing file suffix
-        }
-     if (Open() >= 0) {
-        if (!record && Offset >= 0 && file && file->Seek(Offset, SEEK_SET) != Offset) {
-           LOG_ERROR_STR(fileName);
-           return NULL;
-           }
-        }
-     return file;
-     }
-  esyslog("ERROR: max number of files (%d) exceeded", MaxFilesPerRecording);
-  return NULL;
-}
-
-cUnbufferedFile *cFileName::NextFile(void)
-{
-  return SetOffset(fileNumber + 1);
-}
-
-// --- Index stuff -----------------------------------------------------------
-
-cString IndexToHMSF(int Index, bool WithFrame, double FramesPerSecond)
-{
-  const char *Sign = "";
-  if (Index < 0) {
-     Index = -Index;
-     Sign = "-";
-     }
-  double Seconds;
-  int f = int(modf((Index + 0.5) / FramesPerSecond, &Seconds) * FramesPerSecond + 1);
-  int s = int(Seconds);
-  int m = s / 60 % 60;
-  int h = s / 3600;
-  s %= 60;
-  return cString::sprintf(WithFrame ? "%s%d:%02d:%02d.%02d" : "%s%d:%02d:%02d", Sign, h, m, s, f);
-}
-
-int HMSFToIndex(const char *HMSF, double FramesPerSecond)
-{
-  int h, m, s, f = 1;
-  int n = sscanf(HMSF, "%d:%d:%d.%d", &h, &m, &s, &f);
-  if (n == 1)
-     return h - 1; // plain frame number
-  if (n >= 3)
-     return int(round((h * 3600 + m * 60 + s) * FramesPerSecond)) + f - 1;
-  return 0;
-}
-
-int SecondsToFrames(int Seconds, double FramesPerSecond)
-{
-  return int(round(Seconds * FramesPerSecond));
-}
-
-// --- ReadFrame -------------------------------------------------------------
-
-int ReadFrame(cUnbufferedFile *f, uchar *b, int Length, int Max)
-{
-  if (Length == -1)
-     Length = Max; // this means we read up to EOF (see cIndex)
-  else if (Length > Max) {
-     esyslog("ERROR: frame larger than buffer (%d > %d)", Length, Max);
-     Length = Max;
-     }
-  int r = f->Read(b, Length);
-  if (r < 0)
-     LOG_ERROR;
-  return r;
-}
-
-// --- Recordings Sort Mode --------------------------------------------------
-
-eRecordingsSortMode RecordingsSortMode = rsmName;
-
-bool HasRecordingsSortMode(const char *Directory)
-{
-  return access(AddDirectory(Directory, SORTMODEFILE), R_OK) == 0;
-}
-
-void GetRecordingsSortMode(const char *Directory)
-{
-  if (FILE *f = fopen(AddDirectory(Directory, SORTMODEFILE), "r")) {
-     char buf[8];
-     if (fgets(buf, sizeof(buf), f))
-        RecordingsSortMode = eRecordingsSortMode(constrain(atoi(buf), 0, int(rsmTime)));
-     fclose(f);
-     }
-}
-
-void SetRecordingsSortMode(const char *Directory, eRecordingsSortMode SortMode)
-{
-  if (FILE *f = fopen(AddDirectory(Directory, SORTMODEFILE), "w")) {
-     fputs(cString::sprintf("%d\n", SortMode), f);
-     fclose(f);
-     }
-}
-
-void IncRecordingsSortMode(const char *Directory)
-{
-  GetRecordingsSortMode(Directory);
-  RecordingsSortMode = eRecordingsSortMode(int(RecordingsSortMode) + 1);
-  if (RecordingsSortMode > rsmTime)
-     RecordingsSortMode = eRecordingsSortMode(0);
-  SetRecordingsSortMode(Directory, RecordingsSortMode);
-}
diff -urN vdr-2.0.4-org/recording.h vdr-2.0.4/recording.h
--- vdr-2.0.4-org/recording.h	2013-10-25 09:44:22.452680545 +0200
+++ vdr-2.0.4/recording.h	2013-10-25 10:07:11.964704054 +0200
@@ -288,7 +288,22 @@
 struct tIndexTs;
 class cIndexFileGenerator;
 
-class cIndexFile {
+class cIndex {
+public:
+  virtual bool Ok(void) =0;
+  virtual bool Write(bool Independent, uint16_t FileNumber, off_t FileOffset) =0;
+  virtual bool Get(int Index, uint16_t *FileNumber, off_t *FileOffset, bool *Independent = NULL, int *Length = NULL) =0;
+  virtual int GetNextIFrame(int Index, bool Forward, uint16_t *FileNumber = NULL, off_t *FileOffset = NULL, int *Length = NULL) =0;
+  virtual int Get(uint16_t FileNumber, off_t FileOffset) =0;
+  virtual int First(void) {return 0;};
+  virtual int Last(void) =0;
+  virtual int GetResume(void) =0;
+  virtual bool StoreResume(int Index) =0;
+  virtual bool IsStillRecording(void) =0;
+  virtual void Delete(void) =0;
+  };
+
+class cIndexFile : public cIndex {
 private:
   int f;
   cString fileName;
diff -urN vdr-2.0.4-org/remux.c vdr-2.0.4/remux.c
--- vdr-2.0.4-org/remux.c	2013-10-25 09:44:22.500680545 +0200
+++ vdr-2.0.4/remux.c	2013-10-25 10:07:11.964704054 +0200
@@ -152,6 +152,43 @@
         }
   return -1;
 }
+void TsExtendAdaptionField(unsigned char *Packet, int ToLength)
+{
+    // Hint: ExtenAdaptionField(p, TsPayloadOffset(p) - 4) is a null operation
+
+    int Offset = TsPayloadOffset(Packet); // First byte after existing adaption field
+
+    if (ToLength <= 0)
+    {
+        // Remove adaption field
+        Packet[3] = Packet[3] & ~TS_ADAPT_FIELD_EXISTS;
+        return;
+    }
+
+    // Set adaption field present
+    Packet[3] = Packet[3] | TS_ADAPT_FIELD_EXISTS;
+
+    // Set new length of adaption field:
+    Packet[4] = ToLength <= TS_SIZE-4 ? ToLength-1 : TS_SIZE-4-1;
+
+    if (Packet[4] == TS_SIZE-4-1)
+
+    if (Packet[4] == TS_SIZE-4-1)
+    {
+        // No more payload, remove payload flag
+        Packet[3] = Packet[3] & ~TS_PAYLOAD_EXISTS;
+    }
+
+    int NewPayload = TsPayloadOffset(Packet); // First byte after new adaption field
+
+    // Fill new adaption field
+    if (Offset == 4 && Offset < NewPayload)
+        Offset++; // skip adaptation_field_length
+    if (Offset == 5 && Offset < NewPayload)
+        Packet[Offset++] = 0; // various flags set to 0
+    while (Offset < NewPayload)
+        Packet[Offset++] = 0xff; // stuffing byte
+}
 
 int64_t TsGetDts(const uchar *p, int l)
 {
diff -urN vdr-2.0.4-org/remux.h vdr-2.0.4/remux.h
--- vdr-2.0.4-org/remux.h	2013-10-25 09:44:22.504680546 +0200
+++ vdr-2.0.4/remux.h	2013-10-25 10:07:11.964704054 +0200
@@ -140,6 +140,7 @@
 // The following functions all take a pointer to a sequence of complete TS packets.
 
 int64_t TsGetPts(const uchar *p, int l);
+void TsExtendAdaptionField(unsigned char *Packet, int ToLength);
 int64_t TsGetDts(const uchar *p, int l);
 void TsSetPts(uchar *p, int l, int64_t Pts);
 void TsSetDts(uchar *p, int l, int64_t Dts);
diff -urN vdr-2.0.4-org/timers.c vdr-2.0.4/timers.c
--- vdr-2.0.4-org/timers.c	2013-10-25 09:44:22.472680545 +0200
+++ vdr-2.0.4/timers.c	2013-10-25 10:07:11.968704054 +0200
@@ -23,7 +23,7 @@
 
 // --- cTimer ----------------------------------------------------------------
 
-cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel)
+cTimer::cTimer(bool Instant, bool Pause, cChannel *Channel, int Forerun)
 {
   startTime = stopTime = 0;
   lastSetEvent = 0;
@@ -36,7 +36,7 @@
   if (Instant)
      SetFlags(tfActive | tfInstant);
   channel = Channel ? Channel : Channels.GetByNumber(cDevice::CurrentChannel());
-  time_t t = time(NULL);
+  time_t t = time(NULL) - Forerun;
   struct tm tm_r;
   struct tm *now = localtime_r(&t, &tm_r);
   day = SetTime(t, 0);
diff -urN vdr-2.0.4-org/timers.h vdr-2.0.4/timers.h
--- vdr-2.0.4-org/timers.h	2013-10-25 09:44:22.456680545 +0200
+++ vdr-2.0.4/timers.h	2013-10-25 10:07:11.968704054 +0200
@@ -43,7 +43,7 @@
   char *aux;
   const cEvent *event;
 public:
-  cTimer(bool Instant = false, bool Pause = false, cChannel *Channel = NULL);
+  cTimer(bool Instant = false, bool Pause = false, cChannel *Channel = NULL, int Forerun = 0);
   cTimer(const cEvent *Event);
   cTimer(const cTimer &Timer);
   virtual ~cTimer();
diff -urN vdr-2.0.4-org/vdr.c vdr-2.0.4/vdr.c
--- vdr-2.0.4-org/vdr.c	2013-10-25 09:44:22.504680546 +0200
+++ vdr-2.0.4/vdr.c	2013-10-25 10:07:11.968704054 +0200
@@ -229,6 +229,7 @@
 
   static struct option long_options[] = {
       { "audio",    required_argument, NULL, 'a' },
+      { "buffer",   required_argument, NULL, 'b' },
       { "cachedir", required_argument, NULL, 'c' | 0x100 },
       { "config",   required_argument, NULL, 'c' },
       { "daemon",   no_argument,       NULL, 'd' },
@@ -265,10 +266,14 @@
     };
 
   int c;
-  while ((c = getopt_long(argc, argv, "a:c:dD:e:E:g:hi:l:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
+  while ((c = getopt_long(argc, argv, "a:b:c:dD:e:E:g:hi:kl:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
         switch (c) {
           case 'a': AudioCommand = optarg;
                     break;
+          case 'b': BufferDirectory = optarg;
+                    if(optarg && *optarg && optarg[strlen(optarg)-1] == '/')
+                       optarg[strlen(optarg)-1] = 0;
+                    break;
           case 'c' | 0x100:
                     CacheDirectory = optarg;
                     break;
@@ -492,6 +497,7 @@
         printf("Usage: vdr [OPTIONS]\n\n"          // for easier orientation, this is column 80|
                "  -a CMD,   --audio=CMD    send Dolby Digital audio to stdin of command CMD\n"
                "            --cachedir=DIR save cache files in DIR (default: %s)\n"
+               "  -b DIR,   --buffer=DIR   use DIR as LiveBuffer directory\n"
                "  -c DIR,   --config=DIR   read config files from DIR (default: %s)\n"
                "  -d,       --daemon       run in daemon mode\n"
                "  -D NUM,   --device=NUM   use only the given DVB device (NUM = 0, 1, 2...)\n"
@@ -674,6 +680,8 @@
 
   // Directories:
 
+  if (!BufferDirectory)
+     BufferDirectory = VideoDirectory;
   SetVideoDirectory(VideoDirectory);
   if (!ConfigDirectory)
      ConfigDirectory = DEFAULTCONFDIR;
@@ -1189,6 +1197,13 @@
                   cDisplaySubtitleTracks::Process(key);
                key = kNone;
                break;
+          case kFastRew:
+               if (!Interact) {
+                  DELETE_MENU;
+                  if(cRecordControls::StartLiveBuffer(key))
+                     key = kNone;
+               } // if
+               break;
           // Pausing live video:
           case kPlayPause:
           case kPause:
@@ -1295,6 +1310,26 @@
                             else
                                cControl::Shutdown();
                             break;
+             case osSwitchChannel:
+                            switch (key) {
+                                // Toggle channels:
+                                case kChanPrev:
+                                case k0: {
+                                    if (PreviousChannel[PreviousChannelIndex ^ 1] == LastChannel
+                                        || (LastChannel != PreviousChannel[0] && LastChannel != PreviousChannel[1]))
+                                        PreviousChannelIndex ^= 1;
+                                    Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
+                                    break;
+                                }
+                                case k1 ... k9:
+                                    DELETE_MENU;
+                                    cControl::Shutdown();
+                                    Menu = new cDisplayChannel(NORMALKEY(key));
+                                    break;
+                                default:
+                                    break;
+                            } // switch
+                            break;
              default:       ;
              }
            }
diff -urN vdr-2.0.4-org/vdr.c.orig vdr-2.0.4/vdr.c.orig
--- vdr-2.0.4-org/vdr.c.orig	2013-10-25 09:44:22.448680545 +0200
+++ vdr-2.0.4/vdr.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1437 +0,0 @@
-/*
- * vdr.c: Video Disk Recorder main program
- *
- * Copyright (C) 2000, 2003, 2006, 2008, 2013 Klaus Schmidinger
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
- *
- * The author can be reached at vdr@tvdr.de
- *
- * The project's page is at http://www.tvdr.de
- *
- * $Id: vdr.c 2.57.1.1 2013/10/16 09:46:36 kls Exp $
- */
-
-#include <getopt.h>
-#include <grp.h>
-#include <langinfo.h>
-#include <locale.h>
-#include <pwd.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <sys/capability.h>
-#include <sys/prctl.h>
-#include <termios.h>
-#include <unistd.h>
-#include "audio.h"
-#include "channels.h"
-#include "config.h"
-#include "cutter.h"
-#include "device.h"
-#include "diseqc.h"
-#include "dvbdevice.h"
-#include "eitscan.h"
-#include "epg.h"
-#include "filetransfer.h"
-#include "i18n.h"
-#include "interface.h"
-#include "keys.h"
-#include "libsi/si.h"
-#include "lirc.h"
-#include "menu.h"
-#include "osdbase.h"
-#include "plugin.h"
-#include "recording.h"
-#include "shutdown.h"
-#include "skinclassic.h"
-#include "skinlcars.h"
-#include "skinsttng.h"
-#include "sourceparams.h"
-#include "sources.h"
-#include "themes.h"
-#include "timers.h"
-#include "tools.h"
-#include "transfer.h"
-#include "videodir.h"
-
-#define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
-#define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
-#define SHUTDOWNWAIT         300 // seconds to wait in user prompt before automatic shutdown
-#define SHUTDOWNRETRY        360 // seconds before trying again to shut down
-#define SHUTDOWNFORCEPROMPT    5 // seconds to wait in user prompt to allow forcing shutdown
-#define SHUTDOWNCANCELPROMPT   5 // seconds to wait in user prompt to allow canceling shutdown
-#define RESTARTCANCELPROMPT    5 // seconds to wait in user prompt before restarting on SIGHUP
-#define MANUALSTART          600 // seconds the next timer must be in the future to assume manual start
-#define CHANNELSAVEDELTA     600 // seconds before saving channels.conf after automatic modifications
-#define DEVICEREADYTIMEOUT    30 // seconds to wait until all devices are ready
-#define MENUTIMEOUT          120 // seconds of user inactivity after which an OSD display is closed
-#define TIMERCHECKDELTA       10 // seconds between checks for timers that need to see their channel
-#define TIMERDEVICETIMEOUT     8 // seconds before a device used for timer check may be reused
-#define TIMERLOOKAHEADTIME    60 // seconds before a non-VPS timer starts and the channel is switched if possible
-#define VPSLOOKAHEADTIME      24 // hours within which VPS timers will make sure their events are up to date
-#define VPSUPTODATETIME     3600 // seconds before the event or schedule of a VPS timer needs to be refreshed
-
-#define EXIT(v) { ShutdownHandler.Exit(v); goto Exit; }
-
-static int LastSignal = 0;
-
-static bool SetUser(const char *UserName, bool UserDump)
-{
-  if (UserName) {
-     struct passwd *user = getpwnam(UserName);
-     if (!user) {
-        fprintf(stderr, "vdr: unknown user: '%s'\n", UserName);
-        return false;
-        }
-     if (setgid(user->pw_gid) < 0) {
-        fprintf(stderr, "vdr: cannot set group id %u: %s\n", (unsigned int)user->pw_gid, strerror(errno));
-        return false;
-        }
-     if (initgroups(user->pw_name, user->pw_gid) < 0) {
-        fprintf(stderr, "vdr: cannot set supplemental group ids for user %s: %s\n", user->pw_name, strerror(errno));
-        return false;
-        }
-     if (setuid(user->pw_uid) < 0) {
-        fprintf(stderr, "vdr: cannot set user id %u: %s\n", (unsigned int)user->pw_uid, strerror(errno));
-        return false;
-        }
-     if (UserDump && prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)
-        fprintf(stderr, "vdr: warning - cannot set dumpable: %s\n", strerror(errno));
-     setenv("HOME", user->pw_dir, 1);
-     setenv("USER", user->pw_name, 1);
-     setenv("LOGNAME", user->pw_name, 1);
-     setenv("SHELL", user->pw_shell, 1);
-     }
-  return true;
-}
-
-static bool DropCaps(void)
-{
-  // drop all capabilities except selected ones
-  cap_t caps = cap_from_text("= cap_sys_nice,cap_sys_time,cap_net_raw=ep");
-  if (!caps) {
-     fprintf(stderr, "vdr: cap_from_text failed: %s\n", strerror(errno));
-     return false;
-     }
-  if (cap_set_proc(caps) == -1) {
-     fprintf(stderr, "vdr: cap_set_proc failed: %s\n", strerror(errno));
-     cap_free(caps);
-     return false;
-     }
-  cap_free(caps);
-  return true;
-}
-
-static bool SetKeepCaps(bool On)
-{
-  // set keeping capabilities during setuid() on/off
-  if (prctl(PR_SET_KEEPCAPS, On ? 1 : 0, 0, 0, 0) != 0) {
-     fprintf(stderr, "vdr: prctl failed\n");
-     return false;
-     }
-  return true;
-}
-
-static void SignalHandler(int signum)
-{
-  switch (signum) {
-    case SIGPIPE:
-         break;
-    case SIGHUP:
-         LastSignal = signum;
-         break;
-    default:
-         LastSignal = signum;
-         Interface->Interrupt();
-         ShutdownHandler.Exit(0);
-    }
-  signal(signum, SignalHandler);
-}
-
-static void Watchdog(int signum)
-{
-  // Something terrible must have happened that prevented the 'alarm()' from
-  // being called in time, so let's get out of here:
-  esyslog("PANIC: watchdog timer expired - exiting!");
-  exit(1);
-}
-
-int main(int argc, char *argv[])
-{
-  // Save terminal settings:
-
-  struct termios savedTm;
-  bool HasStdin = (tcgetpgrp(STDIN_FILENO) == getpid() || getppid() != (pid_t)1) && tcgetattr(STDIN_FILENO, &savedTm) == 0;
-
-  // Initiate locale:
-
-  setlocale(LC_ALL, "");
-
-  // Command line options:
-
-#define dd(a, b) (*a ? a : b)
-#define DEFAULTSVDRPPORT 6419
-#define DEFAULTWATCHDOG     0 // seconds
-#define DEFAULTVIDEODIR VIDEODIR
-#define DEFAULTCONFDIR dd(CONFDIR, VideoDirectory)
-#define DEFAULTCACHEDIR dd(CACHEDIR, VideoDirectory)
-#define DEFAULTRESDIR dd(RESDIR, ConfigDirectory)
-#define DEFAULTPLUGINDIR PLUGINDIR
-#define DEFAULTLOCDIR LOCDIR
-#define DEFAULTEPGDATAFILENAME "epg.data"
-
-  bool StartedAsRoot = false;
-  const char *VdrUser = NULL;
-  bool UserDump = false;
-  int SVDRPport = DEFAULTSVDRPPORT;
-  const char *AudioCommand = NULL;
-  const char *VideoDirectory = DEFAULTVIDEODIR;
-  const char *ExtraVideoDirectory = NULL;
-  const char *ConfigDirectory = NULL;
-  const char *CacheDirectory = NULL;
-  const char *ResourceDirectory = NULL;
-  const char *LocaleDirectory = DEFAULTLOCDIR;
-  const char *EpgDataFileName = DEFAULTEPGDATAFILENAME;
-  bool DisplayHelp = false;
-  bool DisplayVersion = false;
-  bool DaemonMode = false;
-  int SysLogTarget = LOG_USER;
-  bool MuteAudio = false;
-  int WatchdogTimeout = DEFAULTWATCHDOG;
-  const char *Terminal = NULL;
-
-  bool UseKbd = true;
-  const char *LircDevice = NULL;
-#if !defined(REMOTE_KBD)
-  UseKbd = false;
-#endif
-#if defined(REMOTE_LIRC)
-  LircDevice = LIRC_DEVICE;
-#endif
-#if defined(VDR_USER)
-  VdrUser = VDR_USER;
-#endif
-
-  cPluginManager PluginManager(DEFAULTPLUGINDIR);
-
-  static struct option long_options[] = {
-      { "audio",    required_argument, NULL, 'a' },
-      { "cachedir", required_argument, NULL, 'c' | 0x100 },
-      { "config",   required_argument, NULL, 'c' },
-      { "daemon",   no_argument,       NULL, 'd' },
-      { "device",   required_argument, NULL, 'D' },
-      { "dirnames", required_argument, NULL, 'd' | 0x100 },
-      { "edit",     required_argument, NULL, 'e' | 0x100 },
-      { "epgfile",  required_argument, NULL, 'E' },
-      { "filesize", required_argument, NULL, 'f' | 0x100 },
-      { "genindex", required_argument, NULL, 'g' | 0x100 },
-      { "grab",     required_argument, NULL, 'g' },
-      { "help",     no_argument,       NULL, 'h' },
-      { "instance", required_argument, NULL, 'i' },
-      { "lib",      required_argument, NULL, 'L' },
-      { "lirc",     optional_argument, NULL, 'l' | 0x100 },
-      { "localedir",required_argument, NULL, 'l' | 0x200 },
-      { "log",      required_argument, NULL, 'l' },
-      { "mute",     no_argument,       NULL, 'm' },
-      { "no-kbd",   no_argument,       NULL, 'n' | 0x100 },
-      { "plugin",   required_argument, NULL, 'P' },
-      { "port",     required_argument, NULL, 'p' },
-      { "record",   required_argument, NULL, 'r' },
-      { "resdir",   required_argument, NULL, 'r' | 0x100 },
-      { "shutdown", required_argument, NULL, 's' },
-      { "split",    no_argument,       NULL, 's' | 0x100 },
-      { "terminal", required_argument, NULL, 't' },
-      { "user",     required_argument, NULL, 'u' },
-      { "userdump", no_argument,       NULL, 'u' | 0x100 },
-      { "version",  no_argument,       NULL, 'V' },
-      { "vfat",     no_argument,       NULL, 'v' | 0x100 },
-      { "video",    required_argument, NULL, 'v' },
-      { "extravideo", required_argument, NULL, 'v' | 0x200 },
-      { "watchdog", required_argument, NULL, 'w' },
-      { NULL,       no_argument,       NULL,  0  }
-    };
-
-  int c;
-  while ((c = getopt_long(argc, argv, "a:c:dD:e:E:g:hi:l:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
-        switch (c) {
-          case 'a': AudioCommand = optarg;
-                    break;
-          case 'c' | 0x100:
-                    CacheDirectory = optarg;
-                    break;
-          case 'c': ConfigDirectory = optarg;
-                    break;
-          case 'd': DaemonMode = true;
-                    break;
-          case 'D': if (isnumber(optarg)) {
-                       int n = atoi(optarg);
-                       if (0 <= n && n < MAXDEVICES) {
-                          cDevice::SetUseDevice(n);
-                          break;
-                          }
-                       }
-                    fprintf(stderr, "vdr: invalid DVB device number: %s\n", optarg);
-                    return 2;
-          case 'd' | 0x100: {
-                    char *s = optarg;
-                    if (*s != ',') {
-                       int n = strtol(s, &s, 10);
-                       if (n <= 0 || n >= PATH_MAX) { // PATH_MAX includes the terminating 0
-                          fprintf(stderr, "vdr: invalid directory path length: %s\n", optarg);
-                          return 2;
-                          }
-                       DirectoryPathMax = n;
-                       if (!*s)
-                          break;
-                       if (*s != ',') {
-                          fprintf(stderr, "vdr: invalid delimiter: %s\n", optarg);
-                          return 2;
-                          }
-                       }
-                    s++;
-                    if (!*s)
-                       break;
-                    if (*s != ',') {
-                       int n = strtol(s, &s, 10);
-                       if (n <= 0 || n > NAME_MAX) { // NAME_MAX excludes the terminating 0
-                          fprintf(stderr, "vdr: invalid directory name length: %s\n", optarg);
-                          return 2;
-                          }
-                       DirectoryNameMax = n;
-                       if (!*s)
-                          break;
-                       if (*s != ',') {
-                          fprintf(stderr, "vdr: invalid delimiter: %s\n", optarg);
-                          return 2;
-                          }
-                       }
-                    s++;
-                    if (!*s)
-                       break;
-                    int n = strtol(s, &s, 10);
-                    if (n != 0 && n != 1) {
-                       fprintf(stderr, "vdr: invalid directory encoding: %s\n", optarg);
-                       return 2;
-                       }
-                    DirectoryEncoding = n;
-                    if (*s) {
-                       fprintf(stderr, "vdr: unexpected data: %s\n", optarg);
-                       return 2;
-                       }
-                    }
-                    break;
-          case 'e' | 0x100:
-                    return CutRecording(optarg) ? 0 : 2;
-          case 'E': EpgDataFileName = (*optarg != '-' ? optarg : NULL);
-                    break;
-          case 'f' | 0x100:
-                    Setup.MaxVideoFileSize = StrToNum(optarg) / MEGABYTE(1);
-                    if (Setup.MaxVideoFileSize < MINVIDEOFILESIZE)
-                       Setup.MaxVideoFileSize = MINVIDEOFILESIZE;
-                    if (Setup.MaxVideoFileSize > MAXVIDEOFILESIZETS)
-                       Setup.MaxVideoFileSize = MAXVIDEOFILESIZETS;
-                    break;
-          case 'g' | 0x100:
-                    return GenerateIndex(optarg) ? 0 : 2;
-          case 'g': cSVDRP::SetGrabImageDir(*optarg != '-' ? optarg : NULL);
-                    break;
-          case 'h': DisplayHelp = true;
-                    break;
-          case 'i': if (isnumber(optarg)) {
-                       InstanceId = atoi(optarg);
-                       if (InstanceId >= 0)
-                          break;
-                       }
-                    fprintf(stderr, "vdr: invalid instance id: %s\n", optarg);
-                    return 2;
-          case 'l': {
-                    char *p = strchr(optarg, '.');
-                    if (p)
-                       *p = 0;
-                    if (isnumber(optarg)) {
-                       int l = atoi(optarg);
-                       if (0 <= l && l <= 3) {
-                          SysLogLevel = l;
-                          if (!p)
-                             break;
-                          if (isnumber(p + 1)) {
-                             int l = atoi(p + 1);
-                             if (0 <= l && l <= 7) {
-                                int targets[] = { LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7 };
-                                SysLogTarget = targets[l];
-                                break;
-                                }
-                             }
-                          }
-                       }
-                    if (p)
-                       *p = '.';
-                    fprintf(stderr, "vdr: invalid log level: %s\n", optarg);
-                    return 2;
-                    }
-          case 'L': if (access(optarg, R_OK | X_OK) == 0)
-                       PluginManager.SetDirectory(optarg);
-                    else {
-                       fprintf(stderr, "vdr: can't access plugin directory: %s\n", optarg);
-                       return 2;
-                       }
-                    break;
-          case 'l' | 0x100:
-                    LircDevice = optarg ? optarg : LIRC_DEVICE;
-                    break;
-          case 'l' | 0x200:
-                    if (access(optarg, R_OK | X_OK) == 0)
-                       LocaleDirectory = optarg;
-                    else {
-                       fprintf(stderr, "vdr: can't access locale directory: %s\n", optarg);
-                       return 2;
-                       }
-                    break;
-          case 'm': MuteAudio = true;
-                    break;
-          case 'n' | 0x100:
-                    UseKbd = false;
-                    break;
-          case 'p': if (isnumber(optarg))
-                       SVDRPport = atoi(optarg);
-                    else {
-                       fprintf(stderr, "vdr: invalid port number: %s\n", optarg);
-                       return 2;
-                       }
-                    break;
-          case 'P': PluginManager.AddPlugin(optarg);
-                    break;
-          case 'r': cRecordingUserCommand::SetCommand(optarg);
-                    break;
-          case 'r' | 0x100:
-                    ResourceDirectory = optarg;
-                    break;
-          case 's': ShutdownHandler.SetShutdownCommand(optarg);
-                    break;
-          case 's' | 0x100:
-                    Setup.SplitEditedFiles = 1;
-                    break;
-          case 't': Terminal = optarg;
-                    if (access(Terminal, R_OK | W_OK) < 0) {
-                       fprintf(stderr, "vdr: can't access terminal: %s\n", Terminal);
-                       return 2;
-                       }
-                    break;
-          case 'u': if (*optarg)
-                       VdrUser = optarg;
-                    break;
-          case 'u' | 0x100:
-                    UserDump = true;
-                    break;
-          case 'V': DisplayVersion = true;
-                    break;
-          case 'v' | 0x100:
-                    DirectoryPathMax = 250;
-                    DirectoryNameMax = 40;
-                    DirectoryEncoding = true;
-                    break;
-          case 'v': VideoDirectory = optarg;
-                    while (optarg && *optarg && optarg[strlen(optarg) - 1] == '/')
-                          optarg[strlen(optarg) - 1] = 0;
-                    break;
-          case 'v' | 0x200:
-                    ExtraVideoDirectory = optarg;
-                    while (optarg && *optarg && optarg[strlen(optarg) - 1] == '/')
-                          optarg[strlen(optarg) - 1] = 0;
-                    AddExtraVideoDirectory(ExtraVideoDirectory);
-                    break;
-          case 'w': if (isnumber(optarg)) {
-                       int t = atoi(optarg);
-                       if (t >= 0) {
-                          WatchdogTimeout = t;
-                          break;
-                          }
-                       }
-                    fprintf(stderr, "vdr: invalid watchdog timeout: %s\n", optarg);
-                    return 2;
-          default:  return 2;
-          }
-        }
-
-  // Set user id in case we were started as root:
-
-  if (VdrUser && geteuid() == 0) {
-     StartedAsRoot = true;
-     if (strcmp(VdrUser, "root")) {
-        if (!SetKeepCaps(true))
-           return 2;
-        if (!SetUser(VdrUser, UserDump))
-           return 2;
-        if (!SetKeepCaps(false))
-           return 2;
-        if (!DropCaps())
-           return 2;
-        }
-     }
-
-  // Help and version info:
-
-  if (DisplayHelp || DisplayVersion) {
-     if (!PluginManager.HasPlugins())
-        PluginManager.AddPlugin("*"); // adds all available plugins
-     PluginManager.LoadPlugins();
-     if (DisplayHelp) {
-        printf("Usage: vdr [OPTIONS]\n\n"          // for easier orientation, this is column 80|
-               "  -a CMD,   --audio=CMD    send Dolby Digital audio to stdin of command CMD\n"
-               "            --cachedir=DIR save cache files in DIR (default: %s)\n"
-               "  -c DIR,   --config=DIR   read config files from DIR (default: %s)\n"
-               "  -d,       --daemon       run in daemon mode\n"
-               "  -D NUM,   --device=NUM   use only the given DVB device (NUM = 0, 1, 2...)\n"
-               "                           there may be several -D options (default: all DVB\n"
-               "                           devices will be used)\n"
-               "            --dirnames=PATH[,NAME[,ENC]]\n"
-               "                           set the maximum directory path length to PATH\n"
-               "                           (default: %d); if NAME is also given, it defines\n"
-               "                           the maximum directory name length (default: %d);\n"
-               "                           the optional ENC can be 0 or 1, and controls whether\n"
-               "                           special characters in directory names are encoded as\n"
-               "                           hex values (default: 0); if PATH or NAME are left\n"
-               "                           empty (as in \",,1\" to only set ENC), the defaults\n"
-               "                           apply\n"
-               "            --edit=REC     cut recording REC and exit\n"
-               "  -E FILE,  --epgfile=FILE write the EPG data into the given FILE (default is\n"
-               "                           '%s' in the cache directory)\n"
-               "                           '-E-' disables this\n"
-               "                           if FILE is a directory, the default EPG file will be\n"
-               "                           created in that directory\n"
-               "            --filesize=SIZE limit video files to SIZE bytes (default is %dM)\n"
-               "                           only useful in conjunction with --edit\n"
-               "            --genindex=REC generate index for recording REC and exit\n"
-               "  -g DIR,   --grab=DIR     write images from the SVDRP command GRAB into the\n"
-               "                           given DIR; DIR must be the full path name of an\n"
-               "                           existing directory, without any \"..\", double '/'\n"
-               "                           or symlinks (default: none, same as -g-)\n"
-               "  -h,       --help         print this help and exit\n"
-               "  -i ID,    --instance=ID  use ID as the id of this VDR instance (default: 0)\n"
-               "  -l LEVEL, --log=LEVEL    set log level (default: 3)\n"
-               "                           0 = no logging, 1 = errors only,\n"
-               "                           2 = errors and info, 3 = errors, info and debug\n"
-               "                           if logging should be done to LOG_LOCALn instead of\n"
-               "                           LOG_USER, add '.n' to LEVEL, as in 3.7 (n=0..7)\n"
-               "  -L DIR,   --lib=DIR      search for plugins in DIR (default is %s)\n"
-               "            --lirc[=PATH]  use a LIRC remote control device, attached to PATH\n"
-               "                           (default: %s)\n"
-               "            --localedir=DIR search for locale files in DIR (default is\n"
-               "                           %s)\n"
-               "  -m,       --mute         mute audio of the primary DVB device at startup\n"
-               "            --no-kbd       don't use the keyboard as an input device\n"
-               "  -p PORT,  --port=PORT    use PORT for SVDRP (default: %d)\n"
-               "                           0 turns off SVDRP\n"
-               "  -P OPT,   --plugin=OPT   load a plugin defined by the given options\n"
-               "  -r CMD,   --record=CMD   call CMD before and after a recording, and after\n"
-               "                           a recording has been edited or deleted\n"
-               "            --resdir=DIR   read resource files from DIR (default: %s)\n"
-               "  -s CMD,   --shutdown=CMD call CMD to shutdown the computer\n"
-               "            --split        split edited files at the editing marks (only\n"
-               "                           useful in conjunction with --edit)\n"
-               "  -t TTY,   --terminal=TTY controlling tty\n"
-               "  -u USER,  --user=USER    run as user USER; only applicable if started as\n"
-               "                           root\n"
-               "            --userdump     allow coredumps if -u is given (debugging)\n"
-               "  -v DIR,   --video=DIR    use DIR as video directory (default: %s)\n"
-               "            --extravideo=DIR use DIR as an additional readonly video directory\n"
-               "                           can be used multiple times\n"
-               "  -V,       --version      print version information and exit\n"
-               "            --vfat         for backwards compatibility (same as\n"
-               "                           --dirnames=250,40,1\n"
-               "  -w SEC,   --watchdog=SEC activate the watchdog timer with a timeout of SEC\n"
-               "                           seconds (default: %d); '0' disables the watchdog\n"
-               "\n",
-               DEFAULTCACHEDIR,
-               DEFAULTCONFDIR,
-               PATH_MAX - 1,
-               NAME_MAX,
-               DEFAULTEPGDATAFILENAME,
-               MAXVIDEOFILESIZEDEFAULT,
-               DEFAULTPLUGINDIR,
-               LIRC_DEVICE,
-               DEFAULTLOCDIR,
-               DEFAULTSVDRPPORT,
-               DEFAULTRESDIR,
-               DEFAULTVIDEODIR,
-               DEFAULTWATCHDOG
-               );
-        }
-     if (DisplayVersion)
-        printf("vdr (%s/%s) - The Video Disk Recorder\n", VDRVERSION, APIVERSION);
-     if (PluginManager.HasPlugins()) {
-        if (DisplayHelp)
-           printf("Plugins: vdr -P\"name [OPTIONS]\"\n\n");
-        for (int i = 0; ; i++) {
-            cPlugin *p = PluginManager.GetPlugin(i);
-            if (p) {
-               const char *help = p->CommandLineHelp();
-               printf("%s (%s) - %s\n", p->Name(), p->Version(), p->Description());
-               if (DisplayHelp && help) {
-                  printf("\n");
-                  puts(help);
-                  }
-               }
-            else
-               break;
-            }
-        }
-     return 0;
-     }
-
-  // Log file:
-
-  if (SysLogLevel > 0)
-     openlog("vdr", LOG_CONS, SysLogTarget); // LOG_PID doesn't work as expected under NPTL
-
-  // Check the video directory:
-
-  if (!DirectoryOk(VideoDirectory, true)) {
-     fprintf(stderr, "vdr: can't access video directory %s\n", VideoDirectory);
-     return 2;
-     }
-
-  // Daemon mode:
-
-  if (DaemonMode) {
-     if (daemon(1, 0) == -1) {
-        fprintf(stderr, "vdr: %m\n");
-        esyslog("ERROR: %m");
-        return 2;
-        }
-     }
-  else if (Terminal) {
-     // Claim new controlling terminal
-     stdin  = freopen(Terminal, "r", stdin);
-     stdout = freopen(Terminal, "w", stdout);
-     stderr = freopen(Terminal, "w", stderr);
-     HasStdin = true;
-     tcgetattr(STDIN_FILENO, &savedTm);
-     }
-
-  isyslog("VDR version %s started", VDRVERSION);
-  if (StartedAsRoot && VdrUser)
-     isyslog("switched to user '%s'", VdrUser);
-  if (DaemonMode)
-     dsyslog("running as daemon (tid=%d)", cThread::ThreadId());
-  cThread::SetMainThreadId();
-
-  // Set the system character table:
-
-  char *CodeSet = NULL;
-  if (setlocale(LC_CTYPE, ""))
-     CodeSet = nl_langinfo(CODESET);
-  else {
-     char *LangEnv = getenv("LANG"); // last resort in case locale stuff isn't installed
-     if (LangEnv) {
-        CodeSet = strchr(LangEnv, '.');
-        if (CodeSet)
-           CodeSet++; // skip the dot
-        }
-     }
-  if (CodeSet) {
-     bool known = SI::SetSystemCharacterTable(CodeSet);
-     isyslog("codeset is '%s' - %s", CodeSet, known ? "known" : "unknown");
-     cCharSetConv::SetSystemCharacterTable(CodeSet);
-     }
-
-  // Initialize internationalization:
-
-  I18nInitialize(LocaleDirectory);
-
-  // Main program loop variables - need to be here to have them initialized before any EXIT():
-
-  cEpgDataReader EpgDataReader;
-  cOsdObject *Menu = NULL;
-  int LastChannel = 0;
-  int LastTimerChannel = -1;
-  int PreviousChannel[2] = { 1, 1 };
-  int PreviousChannelIndex = 0;
-  time_t LastChannelChanged = time(NULL);
-  time_t LastInteract = 0;
-  int MaxLatencyTime = 0;
-  bool InhibitEpgScan = false;
-  bool IsInfoMenu = false;
-  cSkin *CurrentSkin = NULL;
-
-  // Load plugins:
-
-  if (!PluginManager.LoadPlugins(true))
-     EXIT(2);
-
-  // Directories:
-
-  SetVideoDirectory(VideoDirectory);
-  if (!ConfigDirectory)
-     ConfigDirectory = DEFAULTCONFDIR;
-  cPlugin::SetConfigDirectory(ConfigDirectory);
-  if (!CacheDirectory)
-     CacheDirectory = DEFAULTCACHEDIR;
-  cPlugin::SetCacheDirectory(CacheDirectory);
-  if (!ResourceDirectory)
-     ResourceDirectory = DEFAULTRESDIR;
-  cPlugin::SetResourceDirectory(ResourceDirectory);
-  cThemes::SetThemesDirectory(AddDirectory(ConfigDirectory, "themes"));
-
-  // Configuration data:
-
-  Setup.Load(AddDirectory(ConfigDirectory, "setup.conf"));
-  Sources.Load(AddDirectory(ConfigDirectory, "sources.conf"), true, true);
-  Diseqcs.Load(AddDirectory(ConfigDirectory, "diseqc.conf"), true, Setup.DiSEqC);
-  Scrs.Load(AddDirectory(ConfigDirectory, "scr.conf"), true);
-  Channels.Load(AddDirectory(ConfigDirectory, "channels.conf"), false, true);
-  Timers.Load(AddDirectory(ConfigDirectory, "timers.conf"));
-  Commands.Load(AddDirectory(ConfigDirectory, "commands.conf"));
-  RecordingCommands.Load(AddDirectory(ConfigDirectory, "reccmds.conf"));
-  SVDRPhosts.Load(AddDirectory(ConfigDirectory, "svdrphosts.conf"), true);
-  Keys.Load(AddDirectory(ConfigDirectory, "remote.conf"));
-  KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true);
-  Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
-
-  if (!*cFont::GetFontFileName(Setup.FontOsd)) {
-     const char *msg = "no fonts available - OSD will not show any text!";
-     fprintf(stderr, "vdr: %s\n", msg);
-     esyslog("ERROR: %s", msg);
-     }
-
-  // Recordings:
-
-  Recordings.Update();
-  DeletedRecordings.Update();
-
-  // EPG data:
-
-  if (EpgDataFileName) {
-     const char *EpgDirectory = NULL;
-     if (DirectoryOk(EpgDataFileName)) {
-        EpgDirectory = EpgDataFileName;
-        EpgDataFileName = DEFAULTEPGDATAFILENAME;
-        }
-     else if (*EpgDataFileName != '/' && *EpgDataFileName != '.')
-        EpgDirectory = CacheDirectory;
-     if (EpgDirectory)
-        cSchedules::SetEpgDataFileName(AddDirectory(EpgDirectory, EpgDataFileName));
-     else
-        cSchedules::SetEpgDataFileName(EpgDataFileName);
-     EpgDataReader.Start();
-     }
-
-  // DVB interfaces:
-
-  cDvbDevice::Initialize();
-  cDvbDevice::BondDevices(Setup.DeviceBondings);
-
-  // Initialize plugins:
-
-  if (!PluginManager.InitializePlugins())
-     EXIT(2);
-
-  // Primary device:
-
-  cDevice::SetPrimaryDevice(Setup.PrimaryDVB);
-  if (!cDevice::PrimaryDevice() || !cDevice::PrimaryDevice()->HasDecoder()) {
-     if (cDevice::PrimaryDevice() && !cDevice::PrimaryDevice()->HasDecoder())
-        isyslog("device %d has no MPEG decoder", cDevice::PrimaryDevice()->DeviceNumber() + 1);
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         cDevice *d = cDevice::GetDevice(i);
-         if (d && d->HasDecoder()) {
-            isyslog("trying device number %d instead", i + 1);
-            if (cDevice::SetPrimaryDevice(i + 1)) {
-               Setup.PrimaryDVB = i + 1;
-               break;
-               }
-            }
-         }
-     if (!cDevice::PrimaryDevice()) {
-        const char *msg = "no primary device found - using first device!";
-        fprintf(stderr, "vdr: %s\n", msg);
-        esyslog("ERROR: %s", msg);
-        if (!cDevice::SetPrimaryDevice(1))
-           EXIT(2);
-        if (!cDevice::PrimaryDevice()) {
-           const char *msg = "no primary device found - giving up!";
-           fprintf(stderr, "vdr: %s\n", msg);
-           esyslog("ERROR: %s", msg);
-           EXIT(2);
-           }
-        }
-     }
-
-  // Check for timers in automatic start time window:
-
-  ShutdownHandler.CheckManualStart(MANUALSTART);
-
-  // User interface:
-
-  Interface = new cInterface(SVDRPport);
-
-  // Default skins:
-
-  new cSkinLCARS;
-  new cSkinSTTNG;
-  new cSkinClassic;
-  Skins.SetCurrent(Setup.OSDSkin);
-  cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
-  CurrentSkin = Skins.Current();
-
-  // Start plugins:
-
-  if (!PluginManager.StartPlugins())
-     EXIT(2);
-
-  // Set skin and theme in case they're implemented by a plugin:
-
-  if (!CurrentSkin || CurrentSkin == Skins.Current() && strcmp(Skins.Current()->Name(), Setup.OSDSkin) != 0) {
-     Skins.SetCurrent(Setup.OSDSkin);
-     cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
-     }
-
-  // Remote Controls:
-  if (LircDevice)
-     new cLircRemote(LircDevice);
-  if (!DaemonMode && HasStdin && UseKbd)
-     new cKbdRemote;
-  Interface->LearnKeys();
-
-  // External audio:
-
-  if (AudioCommand)
-     new cExternalAudio(AudioCommand);
-
-  // Channel:
-
-  if (!cDevice::WaitForAllDevicesReady(DEVICEREADYTIMEOUT))
-     dsyslog("not all devices ready after %d seconds", DEVICEREADYTIMEOUT);
-  if (*Setup.InitialChannel) {
-     if (isnumber(Setup.InitialChannel)) { // for compatibility with old setup.conf files
-        if (cChannel *Channel = Channels.GetByNumber(atoi(Setup.InitialChannel)))
-           Setup.InitialChannel = Channel->GetChannelID().ToString();
-        }
-     if (cChannel *Channel = Channels.GetByChannelID(tChannelID::FromString(Setup.InitialChannel)))
-        Setup.CurrentChannel = Channel->Number();
-     }
-  if (Setup.InitialVolume >= 0)
-     Setup.CurrentVolume = Setup.InitialVolume;
-  Channels.SwitchTo(Setup.CurrentChannel);
-  if (MuteAudio)
-     cDevice::PrimaryDevice()->ToggleMute();
-  else
-     cDevice::PrimaryDevice()->SetVolume(Setup.CurrentVolume, true);
-
-  // Signal handlers:
-
-  if (signal(SIGHUP,  SignalHandler) == SIG_IGN) signal(SIGHUP,  SIG_IGN);
-  if (signal(SIGINT,  SignalHandler) == SIG_IGN) signal(SIGINT,  SIG_IGN);
-  if (signal(SIGTERM, SignalHandler) == SIG_IGN) signal(SIGTERM, SIG_IGN);
-  if (signal(SIGPIPE, SignalHandler) == SIG_IGN) signal(SIGPIPE, SIG_IGN);
-  if (WatchdogTimeout > 0)
-     if (signal(SIGALRM, Watchdog)   == SIG_IGN) signal(SIGALRM, SIG_IGN);
-
-  // Watchdog:
-
-  if (WatchdogTimeout > 0) {
-     dsyslog("setting watchdog timer to %d seconds", WatchdogTimeout);
-     alarm(WatchdogTimeout); // Initial watchdog timer start
-     }
-
-  // Main program loop:
-
-#define DELETE_MENU ((IsInfoMenu &= (Menu == NULL)), delete Menu, Menu = NULL)
-
-  while (!ShutdownHandler.DoExit()) {
-#ifdef DEBUGRINGBUFFERS
-        cRingBufferLinear::PrintDebugRBL();
-#endif
-        // Attach launched player control:
-        cControl::Attach();
-
-        time_t Now = time(NULL);
-
-        // Make sure we have a visible programme in case device usage has changed:
-        if (!EITScanner.Active() && cDevice::PrimaryDevice()->HasDecoder()) {
-           static time_t lastTime = 0;
-           if (!cDevice::PrimaryDevice()->HasProgramme()) {
-              if (!CamMenuActive() && Now - lastTime > MINCHANNELWAIT) { // !CamMenuActive() to avoid interfering with the CAM if a CAM menu is open
-                 cChannel *Channel = Channels.GetByNumber(cDevice::CurrentChannel());
-                 if (Channel && (Channel->Vpid() || Channel->Apid(0) || Channel->Dpid(0))) {
-                    if (cDevice::GetDeviceForTransponder(Channel, LIVEPRIORITY) && Channels.SwitchTo(Channel->Number())) // try to switch to the original channel...
-                       ;
-                    else if (LastTimerChannel > 0) {
-                       Channel = Channels.GetByNumber(LastTimerChannel);
-                       if (Channel && cDevice::GetDeviceForTransponder(Channel, LIVEPRIORITY) && Channels.SwitchTo(LastTimerChannel)) // ...or the one used by the last timer
-                          ;
-                       }
-                    }
-                 lastTime = Now; // don't do this too often
-                 LastTimerChannel = -1;
-                 }
-              }
-           else
-              lastTime = 0; // makes sure we immediately try again next time
-           }
-        // Update the OSD size:
-        {
-          static time_t lastOsdSizeUpdate = 0;
-          if (Now != lastOsdSizeUpdate) { // once per second
-             cOsdProvider::UpdateOsdSize();
-             lastOsdSizeUpdate = Now;
-             }
-        }
-        // Restart the Watchdog timer:
-        if (WatchdogTimeout > 0) {
-           int LatencyTime = WatchdogTimeout - alarm(WatchdogTimeout);
-           if (LatencyTime > MaxLatencyTime) {
-              MaxLatencyTime = LatencyTime;
-              dsyslog("max. latency time %d seconds", MaxLatencyTime);
-              }
-           }
-        // Handle channel and timer modifications:
-        if (!Channels.BeingEdited() && !Timers.BeingEdited()) {
-           int modified = Channels.Modified();
-           static time_t ChannelSaveTimeout = 0;
-           static int TimerState = 0;
-           // Channels and timers need to be stored in a consistent manner,
-           // therefore if one of them is changed, we save both.
-           if (modified == CHANNELSMOD_USER || Timers.Modified(TimerState))
-              ChannelSaveTimeout = 1; // triggers an immediate save
-           else if (modified && !ChannelSaveTimeout)
-              ChannelSaveTimeout = Now + CHANNELSAVEDELTA;
-           bool timeout = ChannelSaveTimeout == 1 || ChannelSaveTimeout && Now > ChannelSaveTimeout && !cRecordControls::Active();
-           if ((modified || timeout) && Channels.Lock(false, 100)) {
-              if (timeout) {
-                 Channels.Save();
-                 Timers.Save();
-                 ChannelSaveTimeout = 0;
-                 }
-              for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-                  if (Channel->Modification(CHANNELMOD_RETUNE)) {
-                     cRecordControls::ChannelDataModified(Channel);
-                     if (Channel->Number() == cDevice::CurrentChannel()) {
-                        if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring()) {
-                           if (cDevice::ActualDevice()->ProvidesTransponder(Channel)) { // avoids retune on devices that don't really access the transponder
-                              isyslog("retuning due to modification of channel %d", Channel->Number());
-                              Channels.SwitchTo(Channel->Number());
-                              }
-                           }
-                        }
-                     }
-                  }
-              Channels.Unlock();
-              }
-           }
-        // Channel display:
-        if (!EITScanner.Active() && cDevice::CurrentChannel() != LastChannel) {
-           if (!Menu)
-              Menu = new cDisplayChannel(cDevice::CurrentChannel(), LastChannel >= 0);
-           LastChannel = cDevice::CurrentChannel();
-           LastChannelChanged = Now;
-           }
-        if (Now - LastChannelChanged >= Setup.ZapTimeout && LastChannel != PreviousChannel[PreviousChannelIndex])
-           PreviousChannel[PreviousChannelIndex ^= 1] = LastChannel;
-        // Timers and Recordings:
-        if (!Timers.BeingEdited()) {
-           // Assign events to timers:
-           Timers.SetEvents();
-           // Must do all following calls with the exact same time!
-           // Process ongoing recordings:
-           cRecordControls::Process(Now);
-           // Start new recordings:
-           cTimer *Timer = Timers.GetMatch(Now);
-           if (Timer) {
-              if (!cRecordControls::Start(Timer))
-                 Timer->SetPending(true);
-              else
-                 LastTimerChannel = Timer->Channel()->Number();
-              }
-           // Make sure timers "see" their channel early enough:
-           static time_t LastTimerCheck = 0;
-           if (Now - LastTimerCheck > TIMERCHECKDELTA) { // don't do this too often
-              InhibitEpgScan = false;
-              for (cTimer *Timer = Timers.First(); Timer; Timer = Timers.Next(Timer)) {
-                  bool InVpsMargin = false;
-                  bool NeedsTransponder = false;
-                  if (Timer->HasFlags(tfActive) && !Timer->Recording()) {
-                     if (Timer->HasFlags(tfVps)) {
-                        if (Timer->Matches(Now, true, Setup.VpsMargin)) {
-                           InVpsMargin = true;
-                           Timer->SetInVpsMargin(InVpsMargin);
-                           }
-                        else if (Timer->Event()) {
-                           InVpsMargin = Timer->Event()->StartTime() <= Now && Now < Timer->Event()->EndTime();
-                           NeedsTransponder = Timer->Event()->StartTime() - Now < VPSLOOKAHEADTIME * 3600 && !Timer->Event()->SeenWithin(VPSUPTODATETIME);
-                           }
-                        else {
-                           cSchedulesLock SchedulesLock;
-                           const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-                           if (Schedules) {
-                              const cSchedule *Schedule = Schedules->GetSchedule(Timer->Channel());
-                              InVpsMargin = !Schedule; // we must make sure we have the schedule
-                              NeedsTransponder = Schedule && !Schedule->PresentSeenWithin(VPSUPTODATETIME);
-                              }
-                           }
-                        InhibitEpgScan |= InVpsMargin | NeedsTransponder;
-                        }
-                     else
-                        NeedsTransponder = Timer->Matches(Now, true, TIMERLOOKAHEADTIME);
-                     }
-                  if (NeedsTransponder || InVpsMargin) {
-                     // Find a device that provides the required transponder:
-                     cDevice *Device = cDevice::GetDeviceForTransponder(Timer->Channel(), MINPRIORITY);
-                     if (!Device && InVpsMargin)
-                        Device = cDevice::GetDeviceForTransponder(Timer->Channel(), LIVEPRIORITY);
-                     // Switch the device to the transponder:
-                     if (Device) {
-                        bool HadProgramme = cDevice::PrimaryDevice()->HasProgramme();
-                        if (!Device->IsTunedToTransponder(Timer->Channel())) {
-                           if (Device == cDevice::ActualDevice() && !Device->IsPrimaryDevice())
-                              cDevice::PrimaryDevice()->StopReplay(); // stop transfer mode
-                           dsyslog("switching device %d to channel %d", Device->DeviceNumber() + 1, Timer->Channel()->Number());
-                           if (Device->SwitchChannel(Timer->Channel(), false))
-                              Device->SetOccupied(TIMERDEVICETIMEOUT);
-                           }
-                        if (cDevice::PrimaryDevice()->HasDecoder() && HadProgramme && !cDevice::PrimaryDevice()->HasProgramme())
-                           Skins.QueueMessage(mtInfo, tr("Upcoming recording!")); // the previous SwitchChannel() has switched away the current live channel
-                        }
-                     }
-                  }
-              LastTimerCheck = Now;
-              }
-           // Delete expired timers:
-           Timers.DeleteExpired();
-           }
-        if (!Menu && Recordings.NeedsUpdate()) {
-           Recordings.Update();
-           DeletedRecordings.Update();
-           }
-        // CAM control:
-        if (!Menu && !cOsd::IsOpen())
-           Menu = CamControl();
-        // Queued messages:
-        if (!Skins.IsOpen())
-           Skins.ProcessQueuedMessages();
-        // User Input:
-        cOsdObject *Interact = Menu ? Menu : cControl::Control();
-        eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
-        if (ISREALKEY(key)) {
-           EITScanner.Activity();
-           // Cancel shutdown countdown:
-           if (ShutdownHandler.countdown)
-              ShutdownHandler.countdown.Cancel();
-           // Set user active for MinUserInactivity time in the future:
-           ShutdownHandler.SetUserInactiveTimeout();
-           }
-        // Keys that must work independent of any interactive mode:
-        switch (int(key)) {
-          // Menu control:
-          case kMenu: {
-               key = kNone; // nobody else needs to see this key
-               bool WasOpen = Interact != NULL;
-               bool WasMenu = Interact && Interact->IsMenu();
-               if (Menu)
-                  DELETE_MENU;
-               else if (cControl::Control()) {
-                  if (cOsd::IsOpen())
-                     cControl::Control()->Hide();
-                  else
-                     WasOpen = false;
-                  }
-               if (!WasOpen || !WasMenu && !Setup.MenuKeyCloses)
-                  Menu = new cMenuMain;
-               }
-               break;
-          // Info:
-          case kInfo: {
-               if (IsInfoMenu) {
-                  key = kNone; // nobody else needs to see this key
-                  DELETE_MENU;
-                  }
-               else if (!Menu) {
-                  IsInfoMenu = true;
-                  if (cControl::Control()) {
-                     cControl::Control()->Hide();
-                     Menu = cControl::Control()->GetInfo();
-                     if (Menu)
-                        Menu->Show();
-                     else
-                        IsInfoMenu = false;
-                     }
-                  else {
-                     cRemote::Put(kOk, true);
-                     cRemote::Put(kSchedule, true);
-                     }
-                  key = kNone; // nobody else needs to see this key
-                  }
-               }
-               break;
-          // Direct main menu functions:
-          #define DirectMainFunction(function)\
-            { DELETE_MENU;\
-            if (cControl::Control())\
-               cControl::Control()->Hide();\
-            Menu = new cMenuMain(function);\
-            key = kNone; } // nobody else needs to see this key
-          case kSchedule:   DirectMainFunction(osSchedule); break;
-          case kChannels:   DirectMainFunction(osChannels); break;
-          case kTimers:     DirectMainFunction(osTimers); break;
-          case kRecordings: DirectMainFunction(osRecordings); break;
-          case kSetup:      DirectMainFunction(osSetup); break;
-          case kCommands:   DirectMainFunction(osCommands); break;
-          case kUser0 ... kUser9: cRemote::PutMacro(key); key = kNone; break;
-          case k_Plugin: {
-               const char *PluginName = cRemote::GetPlugin();
-               if (PluginName) {
-                  DELETE_MENU;
-                  if (cControl::Control())
-                     cControl::Control()->Hide();
-                  cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
-                  if (plugin) {
-                     Menu = plugin->MainMenuAction();
-                     if (Menu)
-                        Menu->Show();
-                     }
-                  else
-                     esyslog("ERROR: unknown plugin '%s'", PluginName);
-                  }
-               key = kNone; // nobody else needs to see these keys
-               }
-               break;
-          // Channel up/down:
-          case kChanUp|k_Repeat:
-          case kChanUp:
-          case kChanDn|k_Repeat:
-          case kChanDn:
-               if (!Interact)
-                  Menu = new cDisplayChannel(NORMALKEY(key));
-               else if (cDisplayChannel::IsOpen() || cControl::Control()) {
-                  Interact->ProcessKey(key);
-                  continue;
-                  }
-               else
-                  cDevice::SwitchChannel(NORMALKEY(key) == kChanUp ? 1 : -1);
-               key = kNone; // nobody else needs to see these keys
-               break;
-          // Volume control:
-          case kVolUp|k_Repeat:
-          case kVolUp:
-          case kVolDn|k_Repeat:
-          case kVolDn:
-          case kMute:
-               if (key == kMute) {
-                  if (!cDevice::PrimaryDevice()->ToggleMute() && !Menu) {
-                     key = kNone; // nobody else needs to see these keys
-                     break; // no need to display "mute off"
-                     }
-                  }
-               else
-                  cDevice::PrimaryDevice()->SetVolume(NORMALKEY(key) == kVolDn ? -VOLUMEDELTA : VOLUMEDELTA);
-               if (!Menu && !cOsd::IsOpen())
-                  Menu = cDisplayVolume::Create();
-               cDisplayVolume::Process(key);
-               key = kNone; // nobody else needs to see these keys
-               break;
-          // Audio track control:
-          case kAudio:
-               if (cControl::Control())
-                  cControl::Control()->Hide();
-               if (!cDisplayTracks::IsOpen()) {
-                  DELETE_MENU;
-                  Menu = cDisplayTracks::Create();
-                  }
-               else
-                  cDisplayTracks::Process(key);
-               key = kNone;
-               break;
-          // Subtitle track control:
-          case kSubtitles:
-               if (cControl::Control())
-                  cControl::Control()->Hide();
-               if (!cDisplaySubtitleTracks::IsOpen()) {
-                  DELETE_MENU;
-                  Menu = cDisplaySubtitleTracks::Create();
-                  }
-               else
-                  cDisplaySubtitleTracks::Process(key);
-               key = kNone;
-               break;
-          // Pausing live video:
-          case kPlayPause:
-          case kPause:
-               if (!cControl::Control()) {
-                  DELETE_MENU;
-                  if (Setup.PauseKeyHandling) {
-                     if (Setup.PauseKeyHandling > 1 || Interface->Confirm(tr("Pause live video?"))) {
-                        if (!cRecordControls::PauseLiveVideo())
-                           Skins.QueueMessage(mtError, tr("No free DVB device to record!"));
-                        }
-                     }
-                  key = kNone; // nobody else needs to see this key
-                  }
-               break;
-          // Instant recording:
-          case kRecord:
-               if (!cControl::Control()) {
-                  if (cRecordControls::Start())
-                     Skins.QueueMessage(mtInfo, tr("Recording started"));
-                  key = kNone; // nobody else needs to see this key
-                  }
-               break;
-          // Power off:
-          case kPower:
-               isyslog("Power button pressed");
-               DELETE_MENU;
-               // Check for activity, request power button again if active:
-               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
-                  // Not pressed power - set VDR to be non-interactive and power down later:
-                  ShutdownHandler.SetUserInactive();
-                  break;
-                  }
-               // No activity or power button pressed twice - ask for confirmation:
-               if (!ShutdownHandler.ConfirmShutdown(true)) {
-                  // Non-confirmed background activity - set VDR to be non-interactive and power down later:
-                  ShutdownHandler.SetUserInactive();
-                  break;
-                  }
-               // Ask the final question:
-               if (!Interface->Confirm(tr("Press any key to cancel shutdown"), SHUTDOWNCANCELPROMPT, true))
-                  // If final question was canceled, continue to be active:
-                  break;
-               // Ok, now call the shutdown script:
-               ShutdownHandler.DoShutdown(true);
-               // Set VDR to be non-interactive and power down again later:
-               ShutdownHandler.SetUserInactive();
-               // Do not attempt to automatically shut down for a while:
-               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
-               break;
-          default: break;
-          }
-        Interact = Menu ? Menu : cControl::Control(); // might have been closed in the mean time
-        if (Interact) {
-           LastInteract = Now;
-           eOSState state = Interact->ProcessKey(key);
-           if (state == osUnknown && Interact != cControl::Control()) {
-              if (ISMODELESSKEY(key) && cControl::Control()) {
-                 state = cControl::Control()->ProcessKey(key);
-                 if (state == osEnd) {
-                    // let's not close a menu when replay ends:
-                    cControl::Shutdown();
-                    continue;
-                    }
-                 }
-              else if (Now - cRemote::LastActivity() > MENUTIMEOUT)
-                 state = osEnd;
-              }
-           switch (state) {
-             case osPause:  DELETE_MENU;
-                            if (!cRecordControls::PauseLiveVideo())
-                               Skins.QueueMessage(mtError, tr("No free DVB device to record!"));
-                            break;
-             case osRecord: DELETE_MENU;
-                            if (cRecordControls::Start())
-                               Skins.QueueMessage(mtInfo, tr("Recording started"));
-                            break;
-             case osRecordings:
-                            DELETE_MENU;
-                            cControl::Shutdown();
-                            Menu = new cMenuMain(osRecordings, true);
-                            break;
-             case osReplay: DELETE_MENU;
-                            cControl::Shutdown();
-                            cControl::Launch(new cReplayControl);
-                            break;
-             case osStopReplay:
-                            DELETE_MENU;
-                            cControl::Shutdown();
-                            break;
-             case osSwitchDvb:
-                            DELETE_MENU;
-                            cControl::Shutdown();
-                            Skins.QueueMessage(mtInfo, tr("Switching primary DVB..."));
-                            cDevice::SetPrimaryDevice(Setup.PrimaryDVB);
-                            break;
-             case osPlugin: DELETE_MENU;
-                            Menu = cMenuMain::PluginOsdObject();
-                            if (Menu)
-                               Menu->Show();
-                            break;
-             case osBack:
-             case osEnd:    if (Interact == Menu)
-                               DELETE_MENU;
-                            else
-                               cControl::Shutdown();
-                            break;
-             default:       ;
-             }
-           }
-        else {
-           // Key functions in "normal" viewing mode:
-           if (key != kNone && KeyMacros.Get(key)) {
-              cRemote::PutMacro(key);
-              key = kNone;
-              }
-           switch (int(key)) {
-             // Toggle channels:
-             case kChanPrev:
-             case k0: {
-                  if (PreviousChannel[PreviousChannelIndex ^ 1] == LastChannel || LastChannel != PreviousChannel[0] && LastChannel != PreviousChannel[1])
-                     PreviousChannelIndex ^= 1;
-                  Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
-                  break;
-                  }
-             // Direct Channel Select:
-             case k1 ... k9:
-             // Left/Right rotates through channel groups:
-             case kLeft|k_Repeat:
-             case kLeft:
-             case kRight|k_Repeat:
-             case kRight:
-             // Previous/Next rotates through channel groups:
-             case kPrev|k_Repeat:
-             case kPrev:
-             case kNext|k_Repeat:
-             case kNext:
-             // Up/Down Channel Select:
-             case kUp|k_Repeat:
-             case kUp:
-             case kDown|k_Repeat:
-             case kDown:
-                  Menu = new cDisplayChannel(NORMALKEY(key));
-                  break;
-             // Viewing Control:
-             case kOk:   LastChannel = -1; break; // forces channel display
-             // Instant resume of the last viewed recording:
-             case kPlay:
-                  if (cReplayControl::LastReplayed()) {
-                     cControl::Shutdown();
-                     cControl::Launch(new cReplayControl);
-                     }
-                  else
-                     DirectMainFunction(osRecordings); // no last viewed recording, so enter the Recordings menu
-                  break;
-             default:    break;
-             }
-           }
-        if (!Menu) {
-           if (!InhibitEpgScan)
-              EITScanner.Process();
-           if (!cCutter::Active() && cCutter::Ended()) {
-              if (cCutter::Error())
-                 Skins.Message(mtError, tr("Editing process failed!"));
-              else
-                 Skins.Message(mtInfo, tr("Editing process finished"));
-              }
-           if (!cFileTransfer::Active() && cFileTransfer::Ended()) {
-              if (cFileTransfer::Error())
-                 Skins.Message(mtError, tr("File transfer failed!"));
-              else
-                 Skins.Message(mtInfo, tr("File transfer finished"));
-              }
-           }
-
-        // SIGHUP shall cause a restart:
-        if (LastSignal == SIGHUP) {
-           if (ShutdownHandler.ConfirmRestart(true) && Interface->Confirm(tr("Press any key to cancel restart"), RESTARTCANCELPROMPT, true))
-              EXIT(1);
-           LastSignal = 0;
-           }
-
-        // Update the shutdown countdown:
-        if (ShutdownHandler.countdown && ShutdownHandler.countdown.Update()) {
-           if (!ShutdownHandler.ConfirmShutdown(false))
-              ShutdownHandler.countdown.Cancel();
-           }
-
-        if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !cFileTransfer::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
-           // Handle housekeeping tasks
-
-           // Shutdown:
-           // Check whether VDR will be ready for shutdown in SHUTDOWNWAIT seconds:
-           time_t Soon = Now + SHUTDOWNWAIT;
-           if (ShutdownHandler.IsUserInactive(Soon) && ShutdownHandler.Retry(Soon) && !ShutdownHandler.countdown) {
-              if (ShutdownHandler.ConfirmShutdown(false))
-                 // Time to shut down - start final countdown:
-                 ShutdownHandler.countdown.Start(tr("VDR will shut down in %s minutes"), SHUTDOWNWAIT); // the placeholder is really %s!
-              // Dont try to shut down again for a while:
-              ShutdownHandler.SetRetry(SHUTDOWNRETRY);
-              }
-           // Countdown run down to 0?
-           if (ShutdownHandler.countdown.Done()) {
-              // Timed out, now do a final check:
-              if (ShutdownHandler.IsUserInactive() && ShutdownHandler.ConfirmShutdown(false))
-                 ShutdownHandler.DoShutdown(false);
-              // Do this again a bit later:
-              ShutdownHandler.SetRetry(SHUTDOWNRETRY);
-              }
-
-           // Disk housekeeping:
-           RemoveDeletedRecordings();
-           cSchedules::Cleanup();
-           // Plugins housekeeping:
-           PluginManager.Housekeeping();
-           }
-
-        ReportEpgBugFixStats();
-
-        // Main thread hooks of plugins:
-        PluginManager.MainThreadHook();
-        }
-
-  if (ShutdownHandler.EmergencyExitRequested())
-     esyslog("emergency exit requested - shutting down");
-
-Exit:
-
-  // Reset all signal handlers to default before Interface gets deleted:
-  signal(SIGHUP,  SIG_DFL);
-  signal(SIGINT,  SIG_DFL);
-  signal(SIGTERM, SIG_DFL);
-  signal(SIGPIPE, SIG_DFL);
-  signal(SIGALRM, SIG_DFL);
-
-  PluginManager.StopPlugins();
-  cRecordControls::Shutdown();
-  cFileTransfer::Stop();
-  cCutter::Stop();
-  delete Menu;
-  cControl::Shutdown();
-  delete Interface;
-  cOsdProvider::Shutdown();
-  Remotes.Clear();
-  Audios.Clear();
-  Skins.Clear();
-  SourceParams.Clear();
-  if (ShutdownHandler.GetExitCode() != 2) {
-     Setup.CurrentChannel = cDevice::CurrentChannel();
-     Setup.CurrentVolume  = cDevice::CurrentVolume();
-     Setup.Save();
-     }
-  cDevice::Shutdown();
-  EpgHandlers.Clear();
-  PluginManager.Shutdown(true);
-  cSchedules::Cleanup(true);
-  ReportEpgBugFixStats(true);
-  if (WatchdogTimeout > 0)
-     dsyslog("max. latency time %d seconds", MaxLatencyTime);
-  if (LastSignal)
-     isyslog("caught signal %d", LastSignal);
-  if (ShutdownHandler.EmergencyExitRequested())
-     esyslog("emergency exit!");
-  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
-  if (SysLogLevel > 0)
-     closelog();
-  if (HasStdin)
-     tcsetattr(STDIN_FILENO, TCSANOW, &savedTm);
-  return ShutdownHandler.GetExitCode();
-}
diff -urN vdr-2.0.4-org/videodir.c vdr-2.0.4/videodir.c
--- vdr-2.0.4-org/videodir.c	2013-10-25 09:44:22.468680545 +0200
+++ vdr-2.0.4/videodir.c	2013-10-25 10:07:11.968704054 +0200
@@ -57,6 +57,7 @@
 }
 
 const char *VideoDirectory = VIDEODIR;
+const char *BufferDirectory = NULL;
 
 void SetVideoDirectory(const char *Directory)
 {
@@ -148,17 +149,22 @@
 cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags)
 {
   const char *ActualFileName = FileName;
+  bool SepBufferDir = false;
 
   // Incoming name must be in base video directory:
-  if (strstr(FileName, VideoDirectory) != FileName) {
+   if (strstr(FileName, VideoDirectory) != FileName) {
+     if (strstr(FileName, BufferDirectory) == FileName)
+        SepBufferDir = true;
+     else {
      esyslog("ERROR: %s not in %s", FileName, VideoDirectory);
      errno = ENOENT; // must set 'errno' - any ideas for a better value?
      return NULL;
      }
+     }
   // Are we going to create a new file?
   if ((Flags & O_CREAT) != 0) {
      cVideoDirectory Dir;
-     if (Dir.IsDistributed()) {
+     if (Dir.IsDistributed() && !SepBufferDir) {
         // Find the directory with the most free space:
         int MaxFree = Dir.FreeMB();
         while (Dir.Next()) {
diff -urN vdr-2.0.4-org/videodir.h vdr-2.0.4/videodir.h
--- vdr-2.0.4-org/videodir.h	2013-10-25 09:44:22.520680546 +0200
+++ vdr-2.0.4/videodir.h	2013-10-25 10:07:11.968704054 +0200
@@ -23,6 +23,7 @@
 void DelExtraVideoDirectory(const char *Directory);
 
 extern const char *VideoDirectory;
+extern const char *BufferDirectory;
 
 void SetVideoDirectory(const char *Directory);
 cUnbufferedFile *OpenVideoFile(const char *FileName, int Flags);
