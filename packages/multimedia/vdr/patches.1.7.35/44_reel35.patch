diff -urN vdr-1.7.35.org/channels.h vdr-1.7.35/channels.h
--- vdr-1.7.35.org/channels.h	2013-01-04 17:05:25.552805609 +0100
+++ vdr-1.7.35/channels.h	2013-01-04 17:05:38.836805213 +0100
@@ -14,6 +14,7 @@
 #include "sources.h"
 #include "thread.h"
 #include "tools.h"
+#include <vector>
 
 #define ISTRANSPONDER(f1, f2)  (abs((f1) - (f2)) < 4) //XXX
 
@@ -104,6 +105,9 @@
   friend class cSchedules;
   friend class cMenuEditChannel;
   friend class cDvbSourceParam;
+  friend class cMenuMyEditChannel;
+  friend class cMenuMyBouquets;
+  friend class cMenuEditBouquet;
 private:
   static cString ToText(const cChannel *Channel);
   char *name;
@@ -204,6 +208,7 @@
   int Number(void) const { return number; }
   void SetNumber(int Number) { number = Number; }
   bool GroupSep(void) const { return groupSep; }
+  void SetGroupSep(bool GroupSep) { groupSep=GroupSep; }
   const char *Parameters(void) const { return parameters; }
   const cLinkChannels* LinkChannels(void) const { return linkChannels; }
   const cChannel *RefChannel(void) const { return refChannel; }
@@ -246,6 +251,7 @@
 public:
   cChannels(void);
   bool Load(const char *FileName, bool AllowComments = false, bool MustExist = false);
+  bool Reload(const char *FileName, bool AllowComments = false, bool MustExist = false);
 #ifdef USE_ALTERNATECHANNEL
   bool LoadAlternativeChannels(const char *FileName);
 #endif /* ALTERNATECHANNEL */
diff -urN vdr-1.7.35.org/config.c vdr-1.7.35/config.c
--- vdr-1.7.35.org/config.c	2013-01-04 17:05:25.552805609 +0100
+++ vdr-1.7.35/config.c	2013-01-04 17:05:38.840805215 +0100
@@ -498,6 +498,16 @@
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+  ExpertOptions  = 0;
+  AddNewChannels = 0;
+  UseBouquetList = 1;
+  OnlyRadioChannels = 0;
+  OnlyEncryptedChannels = 0;
+  OnlyHDChannels = 0;
+  ExpertNavi     = 0;
+  WantChListOnOk = 1;
+  ChannelUpDownKeyMode = 0; // 0 Normal, kChanUp and kChanDn jumps channel
+                            // 1 opens bouquet / channellist
 #ifdef USE_JUMPINGSECONDS
   JumpSeconds = 60;
   JumpSecondsSlow = 10;
@@ -623,6 +633,15 @@
 bool cSetup::Parse(const char *Name, const char *Value)
 {
   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
+  else if (!strcasecmp(Name, "ExpertOptions"))       ExpertOptions      = atoi(Value);
+  else if (!strcasecmp(Name, "AddNewChannels"))      AddNewChannels     = atoi(Value);
+  else if (!strcasecmp(Name, "UseBouquetList"))      UseBouquetList     = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyRadioChannels"))   OnlyRadioChannels  = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyEncryptedChannels"))OnlyEncryptedChannels = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyHDChannels"))      OnlyHDChannels       = atoi(Value);
+  else if (!strcasecmp(Name, "ExpertNavi"))          ExpertNavi         = atoi(Value);
+  else if (!strcasecmp(Name, "WantChListOnOk"))      WantChListOnOk     = atoi(Value);
+  else if (!strcasecmp(Name, "ChannelUpDownKeyMode"))  ChannelUpDownKeyMode = atoi(Value);
   else if (!strcasecmp(Name, "OSDSkin"))             Utf8Strn0Cpy(OSDSkin, Value, MaxSkinName);
   else if (!strcasecmp(Name, "OSDTheme"))            Utf8Strn0Cpy(OSDTheme, Value, MaxThemeName);
 #ifdef USE_WAREAGLEICON
@@ -919,6 +938,15 @@
   Store("ChannelsWrap",       ChannelsWrap);
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
+  Store("ExpertOptions",      ExpertOptions);
+  Store("AddNewChannels",     AddNewChannels);
+  Store("UseBouquetList",     UseBouquetList);
+  Store("OnlyRadioChannels",  OnlyRadioChannels);
+  Store("OnlyEncryptedChannels", OnlyEncryptedChannels);
+  Store("OnlyHDChannels", OnlyHDChannels);
+  Store("ExpertNavi",         ExpertNavi);
+  Store("WantChListOnOk",     WantChListOnOk);
+  Store("ChannelUpDownKeyMode", ChannelUpDownKeyMode);
 #ifdef USE_JUMPINGSECONDS
   Store("JumpSeconds",        JumpSeconds);
   Store("JumpSecondsSlow",    JumpSecondsSlow);
diff -urN vdr-1.7.35.org/config.h vdr-1.7.35/config.h
--- vdr-1.7.35.org/config.h	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/config.h	2013-01-04 17:05:38.840805215 +0100
@@ -14,6 +14,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <string>
 #include <time.h>
 #include <unistd.h>
 #include "i18n.h"
@@ -385,6 +386,17 @@
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+  int ExpertOptions;
+  int AddNewChannels;
+  int UseBouquetList;
+  int OnlyRadioChannels;
+  int OnlyEncryptedChannels;
+  int OnlyHDChannels;
+  int ExpertNavi;
+  int WantChListOnOk;
+  int ChannelUpDownKeyMode; // 0 Normal, jumps to next or previous channel
+                            // 1 opens bouquet / channel list
+  bool UseZonedChannelList;
 #ifdef USE_JUMPINGSECONDS
   int JumpSeconds;
   int JumpSecondsSlow;
diff -urN vdr-1.7.35.org/debug.h vdr-1.7.35/debug.h
--- vdr-1.7.35.org/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.35/debug.h	2013-01-04 17:05:38.840805215 +0100
@@ -0,0 +1,44 @@
++
++#ifndef DEBUG_H
++#define DEBUG_H
++#include <assert.h>
++
++#ifdef DBG
++  #undef DBG
++  #undef DERR
++  #undef DLOG
++  #undef PRINTF
++#endif
++
++
++#if defined DEBUG
++    #ifdef PLUGIN_NAME_I18N
++        #define CONTEXT PLUGIN_NAME_I18N
++    #else
++        #define CONTEXT "VDR"
++    #endif
++
++    // standard debug macro
++    #define DDD(x...) { printf("["CONTEXT": %s +%d, %s()]: ",__FILE__, __LINE__, __FUNCTION__); \
++                         printf(x); printf("\n"); }
++
++    // standard error macro (red background)
++    #define DERR(x...) { printf("\033[0;37m\033[1;41m["CONTEXT"]: "x); printf("\033[0m\n"); }
++
++    // special macro: logs to syslog AND console
++    #define DLOG(x...) { printf("["CONTEXT"]: "x); printf("\n"); dsyslog("["CONTEXT"]: "x); }
++
++    // for automatic conversion of printf's - i.e. use sed s/" printf"/" PRINTF"/
++    #define PRINTF(x...) printf("["CONTEXT"]: "x)
++#else
++    #define DDD(x...)
++    #define DERR(x...)
++    #define DLOG(x...)
++    #define PRINTF(x...)
++#endif
++
++//only here for compatibility reasons, don't use any more
++#define ERR "Error"
++#define DBG(x...)
++
++#endif /* DEBUG_H */
diff -urN vdr-1.7.35.org/keys.c vdr-1.7.35/keys.c
--- vdr-1.7.35.org/keys.c	2013-01-04 17:05:25.568805611 +0100
+++ vdr-1.7.35/keys.c	2013-01-04 17:05:46.160804995 +0100
@@ -57,6 +57,9 @@
                     { kRecordings,    trNOOP("Key$Recordings")  },
                     { kSetup,         trNOOP("Key$Setup")       },
                     { kCommands,      trNOOP("Key$Commands")    },
+                    { kGreater,       trNOOP("Key$Greater")     },
+                    { kLess,          trNOOP("Key$Less")        },
+                    { k2digit,        trNOOP("Key$2digit")      },
                     { kUser0,         trNOOP("Key$User0")       },
                     { kUser1,         trNOOP("Key$User1")       },
                     { kUser2,         trNOOP("Key$User2")       },
diff -urN vdr-1.7.35.org/keys.h vdr-1.7.35/keys.h
--- vdr-1.7.35.org/keys.h	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/keys.h	2013-01-04 17:05:46.160804995 +0100
@@ -51,6 +51,7 @@
              kRecordings,
              kSetup,
              kCommands,
+             kGreater, kLess, k2digit,
              kUser0, kUser1, kUser2, kUser3, kUser4, kUser5, kUser6, kUser7, kUser8, kUser9,
              kNone,
              kKbd,
diff -urN vdr-1.7.35.org/Make.common vdr-1.7.35/Make.common
--- vdr-1.7.35.org/Make.common	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.35/Make.common	2013-01-04 17:05:46.160804995 +0100
@@ -0,0 +1,156 @@
+
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+APIVERSION = $(shell grep 'define APIVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+APIVERSNUM = $(shell grep 'define APIVERSNUM ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g' )
+
+VDRLOCALE = $(shell grep '^LOCALEDIR' $(VDRDIR)/Makefile)
+
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include -I$(DVBDIR)/include
+DEFINES  += -D_GNU_SOURCE -D_LARGEFILE_SOURCE
+DEFINES  += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -DAPIVERSNUM=$(APIVERSNUM)
+
+#ifdef DEBUG
+#  DEFINES += -DDEBUG
+#  CXXFLAGS += -g
+#endif
+
+#ifdef RBLITE
+#  DEFINES += -DRBLITE
+#endif
+
+#ifdef RBMINI
+#  DEFINES += -DRBMINI
+#endif
+
+#ifdef REELVDR
+#  DEFINES += -DREELVDR
+#endif
+
+### Targets:
+
+plug: libvdr-$(PLUGIN).so
+
+all: libvdr-$(PLUGIN).so i18n
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DPLUGIN_NAME='"$(PLUGIN)"' -DPLUGIN_NAME_I18N='"$(PLUGIN)"' $(INCLUDES) -o $@ $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c)   > $@
+
+-include $(DEPFILE)
+
+
+### Internationalization (I18N):
+ifneq ($(strip $(VDRLOCALE)),)
+### do gettext based i18n stuff
+
+PODIR     = po
+LOCALEDIR = $(VDRDIR)/locale
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, \
+		$(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/$(PLUGIN).pot
+
+#%.mo: %.po
+#	msgfmt -c -o $@ $<
+
+.PHONY: $(I18Npot)-rule
+$(I18Npot): $(wildcard *.c $(PLUGIN).h $(EXTRA_I18N))
+	@echo "making: $@"
+	@#echo $(I18Nmsgs)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --from-code=utf-8 --msgid-bugs-address='<reelbox-devel@mailings.reelbox.org>' $^ -o $(I18Npot)
+
+%.po:
+#%.po: $(I18Npot)
+	@echo "making: $@"
+	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
+	@touch $@
+
+$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.po
+	@echo "making: $@"
+	@mkdir -p $(dir $@)
+	msgfmt -c -o $@ $<
+
+.PHONY: i18n
+i18n: $(I18Npot) i18n-pofiles $(I18Nmsgs)
+
+i18n-pofiles: $(I18Npot)
+	@echo "making: $@"
+	@for i in $(I18Npo) ; do \
+		echo msgmerge -U --no-wrap --no-location --backup=none -q $$i $(I18Npot) ;\
+		msgmerge -U -N --no-wrap --no-location --backup=none -q $$i $(I18Npot) ;\
+	done
+
+i18n-dist: $(I18Nmsgs)
+
+#i18n-dist:
+#	@echo "making: $@"
+#	for i in `ls po/*.po` ; do \
+#		odir=`echo $$i | cut -b4-8` ;\
+#		msgfmt -c -o $(LOCALEDIR)/$$odir/LC_MESSAGES/vdr-$(PLUGIN).mo $$i ;\
+#	done
+
+else ### do i18n.c based i18n stuff
+
+i18n:
+	@### nothing to do
+
+#i18n compatibility generator:
+i18n.c: i18n-template.c po2i18n.pl $(I18Npo)
+	./po2i18n.pl < i18n-template.c > i18n.c
+
+endif
+
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LDFLAGS) $(LIBS) -o $@
+	@cp $@ $(LIBDIR)/$@.$(APIVERSION)
+
+dist: distclean
+	@rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.filelist
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.pcs
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevses
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Examples/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Patch/CVS
+	@ln -s $(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE) $(PLUGIN)
+	@rm -rf $(TMPDIR)/$(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(PODIR)/*.mo
+	@-rm -f $(OBJS) $(MAIN) $(DEPFILE) *.so *.tgz core* *~
+	@-rm -f $(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION)
+
+distclean: clean
+	@-rm -f $(PODIR)/*.pot
+
+MAKECOMMON_IS_SOURCED = 1
diff -urN vdr-1.7.35.org/Makefile.orig vdr-1.7.35/Makefile.orig
--- vdr-1.7.35.org/Makefile.orig	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,316 +0,0 @@
-#
-# Makefile for the Video Disk Recorder
-#
-# See the main source file 'vdr.c' for copyright information and
-# how to reach the author.
-#
-# $Id: Makefile 2.47 2012/12/30 11:18:18 kls Exp $
-
-.DELETE_ON_ERROR:
-
-# Compiler flags:
-
-CC       ?= gcc
-CFLAGS   ?= -g -O3 -Wall
-
-CXX      ?= g++
-CXXFLAGS ?= $(CFLAGS) -Werror=overloaded-virtual -Wno-parentheses
-
-CFLAGS   += -fPIC
-
-CDEFINES  = -D_GNU_SOURCE
-CDEFINES += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
-
-# Directories:
-
-CWD      = .
-LSIDIR   = ./libsi
-DESTDIR ?=
-PREFIX  ?= /usr/local
-MANDIR  ?= $(PREFIX)/share/man
-BINDIR  ?= $(PREFIX)/bin
-INCDIR  ?= $(CWD)/include
-LOCDIR  ?= $(CWD)/locale
-LIBS     = -ljpeg -lpthread -ldl -lcap -lrt $(shell pkg-config --libs freetype2 fontconfig)
-INCLUDES ?= $(shell pkg-config --cflags freetype2 fontconfig)
-
-PLUGINDIR= $(CWD)/PLUGINS
-LIBDIR   = $(PLUGINDIR)/lib
-
-# By default VDR requires only one single directory to operate:
-VIDEODIR     = /video
-# See Make.config.template if you want to build VDR according to the FHS ("File system Hierarchy Standard")
-
-DOXYGEN ?= /usr/bin/doxygen
-DOXYFILE = Doxyfile
-
-PCDIR   ?= $(firstword $(subst :, , ${PKG_CONFIG_PATH}:$(shell pkg-config --variable=pc_path pkg-config):$(PREFIX)/lib/pkgconfig))
-
--include Make.config
-
-ifdef DVBDIR
-CFLAGS += -I$(DVBDIR)
-endif
-
-UP3 = $(if $(findstring "$(LIBDIR)-$(LOCDIR)","$(CWD)/PLUGINS/lib-$(CWD)/locale"),../../../,)
-
-SILIB    = $(LSIDIR)/libsi.a
-
-OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbci.o\
-       dvbplayer.o dvbspu.o dvbsubtitle.o eit.o eitscan.o epg.o filter.o font.o i18n.o interface.o keys.o\
-       lirc.o menu.o menuitems.o nit.o osdbase.o osd.o pat.o player.o plugin.o\
-       receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sdt.o sections.o shutdown.o\
-       skinclassic.o skinlcars.o skins.o skinsttng.o sourceparams.o sources.o spu.o status.o svdrp.o themes.o thread.o\
-       timers.o tools.o transfer.o vdr.o videodir.o
-
-DEFINES += $(CDEFINES)
-
-ifdef VASARAJANAULOJA
-OBJS += filetransfer.o
-endif
-
-ifdef SETUP
-OBJS += submenu.o
-LIBS += -ltinyxml
-endif
-
-ifdef WAREAGLEICON
-OBJS += iconpatch.o
-endif
-
-ifdef TTXTSUBS
-OBJS += vdrttxtsubshooks.o
-endif
-
-ifndef NO_KBD
-DEFINES += -DREMOTE_KBD
-endif
-ifdef REMOTE
-DEFINES += -DREMOTE_$(REMOTE)
-endif
-ifdef VDR_USER
-DEFINES += -DVDR_USER=\"$(VDR_USER)\"
-endif
-ifdef BIDI
-INCLUDES += $(shell pkg-config --cflags fribidi)
-DEFINES += -DBIDI
-LIBS += $(shell pkg-config --libs fribidi)
-endif
-
-LIRC_DEVICE ?= /var/run/lirc/lircd
-
-DEFINES += -DLIRC_DEVICE=\"$(LIRC_DEVICE)\"
-DEFINES += -DVIDEODIR=\"$(VIDEODIR)\"
-DEFINES += -DCONFDIR=\"$(CONFDIR)\"
-DEFINES += -DCACHEDIR=\"$(CACHEDIR)\"
-DEFINES += -DRESDIR=\"$(RESDIR)\"
-DEFINES += -DPLUGINDIR=\"$(LIBDIR)\"
-DEFINES += -DLOCDIR=\"$(LOCDIR)\"
-
-# Default values for directories:
-
-CONFDIRDEF  = $(firstword $(CONFDIR)  $(VIDEODIR))
-CACHEDIRDEF = $(firstword $(CACHEDIR) $(VIDEODIR))
-RESDIRDEF   = $(firstword $(RESDIR)   $(CONFDIRDEF))
-
-# The version numbers of VDR and the plugin API (taken from VDR's "config.h"):
-
-VDRVERSION = $(shell sed -ne '/define VDRVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
-APIVERSION = $(shell sed -ne '/define APIVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
-
-all: vdr i18n plugins
-
-# Implicit rules:
-
-%.o: %.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
-
-# Dependencies:
-
-MAKEDEP = $(CXX) -MM -MG
-DEPFILE = .dependencies
-$(DEPFILE): Makefile
-	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
-
--include $(DEPFILE)
-
-# The main program:
-
-vdr: $(OBJS) $(SILIB)
-	$(CXX) $(CXXFLAGS) -rdynamic $(LDFLAGS) $(OBJS) $(LIBS) $(SILIB) -o vdr
-
-# The libsi library:
-
-$(SILIB):
-	$(MAKE) --no-print-directory -C $(LSIDIR) CXXFLAGS="$(CXXFLAGS)" DEFINES="$(CDEFINES)" all
-
-# pkg-config file:
-
-.PHONY: vdr.pc
-vdr.pc:
-	@echo "bindir=$(BINDIR)" > $@
-	@echo "mandir=$(MANDIR)" >> $@
-	@echo "configdir=$(CONFDIRDEF)" >> $@
-	@echo "videodir=$(VIDEODIR)" >> $@
-	@echo "cachedir=$(CACHEDIRDEF)" >> $@
-	@echo "resdir=$(RESDIRDEF)" >> $@
-	@echo "libdir=$(UP3)$(LIBDIR)" >> $@
-	@echo "locdir=$(UP3)$(LOCDIR)" >> $@
-	@echo "plgcfg=$(PLGCFG)" >> $@
-	@echo "apiversion=$(APIVERSION)" >> $@
-	@echo "cflags=$(CFLAGS) $(CDEFINES) -I$(UP3)$(INCDIR)" >> $@
-	@echo "cxxflags=$(CXXFLAGS) $(CDEFINES) -I$(UP3)$(INCDIR)" >> $@
-	@echo "" >> $@
-	@echo "Name: VDR" >> $@
-	@echo "Description: Video Disk Recorder" >> $@
-	@echo "URL: http://www.tvdr.de/" >> $@
-	@echo "Version: $(VDRVERSION)" >> $@
-	@echo "Cflags: \$${cflags}" >> $@
-
-# Internationalization (I18N):
-
-PODIR     = po
-LOCALEDIR = locale
-I18Npo    = $(wildcard $(PODIR)/*.po)
-I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr.mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
-I18Npot   = $(PODIR)/vdr.pot
-
-%.mo: %.po
-	msgfmt -c -o $@ $<
-
-$(I18Npot): $(wildcard *.c)
-	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=VDR --package-version=$(VDRVERSION) --msgid-bugs-address='<vdr-bugs@tvdr.de>' -o $@ `ls $^`
-
-%.po: $(I18Npot)
-	msgmerge -U --no-wrap --no-location --backup=none -q -N $@ $<
-	@touch $@
-
-$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr.mo: $(PODIR)/%.mo
-	@mkdir -p $(dir $@)
-	cp $< $@
-
-.PHONY: i18n
-i18n: $(I18Nmsgs) $(I18Npot)
-
-install-i18n:
-	@mkdir -p $(DESTDIR)$(LOCDIR)
-	@(cd $(LOCALEDIR); cp -r --parents * $(DESTDIR)$(LOCDIR))
-
-# The 'include' directory (for plugins):
-
-include-dir:
-	@mkdir -p include/vdr
-	@(cd include/vdr; for i in ../../*.h; do ln -fs $$i .; done)
-	@mkdir -p include/libsi
-	@(cd include/libsi; for i in ../../libsi/*.h; do ln -fs $$i .; done)
-
-# Plugins:
-
-plugins: include-dir vdr.pc
-	@failed="";\
-	noapiv="";\
-	for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do\
-	    echo "*** Plugin $$i:";\
-	    if ! grep -q "\$$(LIBDIR)/.*\$$(APIVERSION)" "$(PLUGINDIR)/src/$$i/Makefile" ; then\
-	       echo "ERROR: plugin $$i doesn't honor APIVERSION - not compiled!";\
-	       noapiv="$$noapiv $$i";\
-	       continue;\
-	       fi;\
-	    newmakefile=`grep "PKGCFG" "$(PLUGINDIR)/src/$$i/Makefile"`;\
-	    if [ -z "$$newmakefile" ]; then\
-	       echo "********************************************************************";\
-	       echo "* Your plugin \"$$i\" is using an old Makefile!";\
-	       echo "* While this currently still works, it is strongly recommended";\
-	       echo "* that you convert that Makefile to the new style used since";\
-	       echo "* VDR version 1.7.35. Support for old style Makefiles may be dropped";\
-	       echo "* in future versions of VDR.";\
-	       echo "********************************************************************";\
-	       $(MAKE) --no-print-directory -C "$(PLUGINDIR)/src/$$i" CXXFLAGS="$(CXXFLAGS)" VDRDIR=$(UP3) LIBDIR=../../lib all || failed="$$failed $$i";\
-	    else\
-               target=all;\
-	       if [ "$(LIBDIR)" = "$(CWD)/PLUGINS/lib" ] && [ "$(LOCDIR)" = "$(CWD)/locale" ]; then\
-	          target="install";\
-	          fi;\
-	       includes=;\
-	       if [ "$(INCDIR)" != "$(CWD)/include" ]; then\
-	          includes="INCLUDES=-I$(UP3)/include";\
-	          fi;\
-	       $(MAKE) --no-print-directory -C "$(PLUGINDIR)/src/$$i" VDRDIR=$(UP3) $$includes $$target || failed="$$failed $$i";\
-	       fi;\
-	    done;\
-	if [ -n "$$noapiv" ] ; then echo; echo "*** plugins without APIVERSION:$$noapiv"; echo; fi;\
-	if [ -n "$$failed" ] ; then echo; echo "*** failed plugins:$$failed"; echo; exit 1; fi
-
-clean-plugins:
-	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) --no-print-directory -C "$(PLUGINDIR)/src/$$i" clean; done
-	@-rm -f $(PLUGINDIR)/lib/lib*-*.so.$(APIVERSION)
-
-# Install the files:
-
-install: install-bin install-dirs install-conf install-doc install-plugins install-i18n install-includes install-pc
-
-# VDR binary:
-
-install-bin: vdr
-	@mkdir -p $(DESTDIR)$(BINDIR)
-	@cp --remove-destination vdr svdrpsend $(DESTDIR)$(BINDIR)
-
-# Configuration files:
-
-install-dirs:
-	@mkdir -p $(DESTDIR)$(VIDEODIR)
-	@mkdir -p $(DESTDIR)$(CONFDIRDEF)
-	@mkdir -p $(DESTDIR)$(CACHEDIRDEF)
-	@mkdir -p $(DESTDIR)$(RESDIRDEF)
-
-install-conf:
-	@cp -n *.conf $(DESTDIR)$(CONFDIRDEF)
-
-
-# Documentation:
-
-install-doc:
-	@mkdir -p $(DESTDIR)$(MANDIR)/man1
-	@mkdir -p $(DESTDIR)$(MANDIR)/man5
-	@gzip -c vdr.1 > $(DESTDIR)$(MANDIR)/man1/vdr.1.gz
-	@gzip -c vdr.5 > $(DESTDIR)$(MANDIR)/man5/vdr.5.gz
-
-# Plugins:
-
-install-plugins: plugins
-	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do\
-	     $(MAKE) --no-print-directory -C "$(PLUGINDIR)/src/$$i" VDRDIR=$(UP3) DESTDIR=$(DESTDIR) install;\
-	     done
-
-# Includes:
-
-install-includes: include-dir
-	@mkdir -p $(DESTDIR)$(INCDIR)
-	@cp -pLR include/vdr include/libsi $(DESTDIR)$(INCDIR)
-
-# pkg-config file:
-
-install-pc: vdr.pc
-	if [ -n "$(PCDIR)" ] ; then \
-	    mkdir -p $(DESTDIR)$(PCDIR) ; \
-	    cp vdr.pc $(DESTDIR)$(PCDIR) ; \
-	    fi
-
-# Source documentation:
-
-srcdoc:
-	@cp $(DOXYFILE) $(DOXYFILE).tmp
-	@echo PROJECT_NUMBER = $(VDRVERSION) >> $(DOXYFILE).tmp
-	$(DOXYGEN) $(DOXYFILE).tmp
-	@rm $(DOXYFILE).tmp
-
-# Housekeeping:
-
-clean:
-	@$(MAKE) --no-print-directory -C $(LSIDIR) clean
-	@-rm -f $(OBJS) $(DEPFILE) vdr vdr.pc core* *~
-	@-rm -rf $(LOCALEDIR) $(PODIR)/*.mo $(PODIR)/*.pot
-	@-rm -rf include
-	@-rm -rf srcdoc
-CLEAN: clean
-distclean: clean-plugins clean
diff -urN vdr-1.7.35.org/Makefile.rej vdr-1.7.35/Makefile.rej
--- vdr-1.7.35.org/Makefile.rej	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/Makefile.rej	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- Makefile	2012-09-10 22:16:58.000000000 +0200
-+++ Makefile	2012-09-10 22:17:43.000000000 +0200
-@@ -199,7 +199,7 @@
- 	@failed="";\
- 	noapiv="";\
- 	for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do\
--	    echo "Plugin $$i:";\
-+	    true echo "Plugin $$i:";\
- 	    if ! grep -q "\$$(LIBDIR)/.*\$$(APIVERSION)" "$(PLUGINDIR)/src/$$i/Makefile" ; then\
- 	       echo "ERROR: plugin $$i doesn't honor APIVERSION - not compiled!";\
- 	       noapiv="$$noapiv $$i";\
diff -urN vdr-1.7.35.org/menu.c vdr-1.7.35/menu.c
--- vdr-1.7.35.org/menu.c	2013-01-04 17:05:25.556805611 +0100
+++ vdr-1.7.35/menu.c	2013-01-04 17:05:47.492804957 +0100
@@ -105,16 +105,6 @@
 
 // --- cMenuEditSrcItem ------------------------------------------------------
 
-class cMenuEditSrcItem : public cMenuEditIntItem {
-private:
-  const cSource *source;
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditSrcItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
 cMenuEditSrcItem::cMenuEditSrcItem(const char *Name, int *Value)
 :cMenuEditIntItem(Name, Value, 0)
 {
@@ -4670,6 +4660,7 @@
          else
             return osEnd;
          break;
+    case kInfo: return osEnd; break;
     default:
          if ((Key & (k_Repeat | k_Release)) == 0) {
             cRemote::Put(Key);
diff -urN vdr-1.7.35.org/menu.c.orig vdr-1.7.35/menu.c.orig
--- vdr-1.7.35.org/menu.c.orig	2013-01-04 17:05:25.552805609 +0100
+++ vdr-1.7.35/menu.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,5952 +0,0 @@
-/*
- * menu.c: The actual menu implementations
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: menu.c 2.72 2012/12/21 11:11:14 kls Exp $
- */
-
-#include "menu.h"
-#ifdef USE_WAREAGLEICON
-#include "iconpatch.h"
-#endif /* WAREAGLEICON */
-#include <ctype.h>
-#include <limits.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "channels.h"
-#include "config.h"
-#include "cutter.h"
-#include "eitscan.h"
-#ifdef USE_VASARAJANAULOJA
-#include "filetransfer.h"
-#endif /* VASARAJANAULOJA */
-#include "i18n.h"
-#include "interface.h"
-#include "plugin.h"
-#include "recording.h"
-#include "remote.h"
-#include "shutdown.h"
-#include "sourceparams.h"
-#include "sources.h"
-#include "status.h"
-#include "themes.h"
-#include "timers.h"
-#include "transfer.h"
-#include "videodir.h"
-#ifdef USE_MENUORG
-#include "menuorgpatch.h"
-#endif /* MENUORG */
-
-#define MAXWAIT4EPGINFO   3 // seconds
-#define MODETIMEOUT       3 // seconds
-#define NEWTIMERLIMIT   120 // seconds until the start time of a new timer created from the Schedule menu,
-                            // within which it will go directly into the "Edit timer" menu to allow
-                            // further parameter settings
-#define DEFERTIMER       60 // seconds by which a timer is deferred in case of problems
-
-#define MAXRECORDCONTROLS (MAXDEVICES * MAXRECEIVERS)
-#define MAXINSTANTRECTIME (24 * 60 - 1) // 23:59 hours
-#define MAXWAITFORCAMMENU  10 // seconds to wait for the CAM menu to open
-#define CAMMENURETYTIMEOUT  3 // seconds after which opening the CAM menu is retried
-#define CAMRESPONSETIMEOUT  5 // seconds to wait for a response from a CAM
-#define MINFREEDISK       300 // minimum free disk space (in MB) required to start recording
-#define NODISKSPACEDELTA  300 // seconds between "Not enough disk space to start recording!" messages
-#define MAXCHNAMWIDTH      16 // maximum number of characters of channels' short names shown in schedules menus
-
-#define CHNUMWIDTH  (numdigits(Channels.MaxNumber()) + 1)
-#define CHNAMWIDTH  (min(MAXCHNAMWIDTH, Channels.MaxShortChannelNameLength() + 1))
-
-// --- cMenuEditCaItem -------------------------------------------------------
-
-class cMenuEditCaItem : public cMenuEditIntItem {
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditCaItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditCaItem::cMenuEditCaItem(const char *Name, int *Value)
-:cMenuEditIntItem(Name, Value, 0)
-{
-  Set();
-}
-
-void cMenuEditCaItem::Set(void)
-{
-  if (*value == CA_FTA)
-     SetValue(tr("Free To Air"));
-  else if (*value >= CA_ENCRYPTED_MIN)
-     SetValue(tr("encrypted"));
-  else
-     cMenuEditIntItem::Set();
-}
-
-eOSState cMenuEditCaItem::ProcessKey(eKeys Key)
-{
-  eOSState state = cMenuEditItem::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     if (NORMALKEY(Key) == kLeft && *value >= CA_ENCRYPTED_MIN)
-        *value = CA_FTA;
-     else
-        return cMenuEditIntItem::ProcessKey(Key);
-     Set();
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cMenuEditSrcItem ------------------------------------------------------
-
-class cMenuEditSrcItem : public cMenuEditIntItem {
-private:
-  const cSource *source;
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditSrcItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditSrcItem::cMenuEditSrcItem(const char *Name, int *Value)
-:cMenuEditIntItem(Name, Value, 0)
-{
-  source = Sources.Get(*Value);
-  Set();
-}
-
-void cMenuEditSrcItem::Set(void)
-{
-  if (source)
-     SetValue(cString::sprintf("%s - %s", *cSource::ToString(source->Code()), source->Description()));
-  else
-     cMenuEditIntItem::Set();
-}
-
-eOSState cMenuEditSrcItem::ProcessKey(eKeys Key)
-{
-  eOSState state = cMenuEditItem::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     bool IsRepeat = Key & k_Repeat;
-     Key = NORMALKEY(Key);
-     if (Key == kLeft) { // TODO might want to increase the delta if repeated quickly?
-        if (source) {
-           if (source->Prev())
-              source = (cSource *)source->Prev();
-           else if (!IsRepeat)
-              source = Sources.Last();
-           *value = source->Code();
-           }
-        }
-     else if (Key == kRight) {
-        if (source) {
-           if (source->Next())
-              source = (cSource *)source->Next();
-           else if (!IsRepeat)
-              source = Sources.First();
-           }
-        else
-           source = Sources.First();
-        if (source)
-           *value = source->Code();
-        }
-     else
-        return state; // we don't call cMenuEditIntItem::ProcessKey(Key) here since we don't accept numerical input
-     Set();
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cMenuEditChannel ------------------------------------------------------
-
-class cMenuEditChannel : public cOsdMenu {
-private:
-  cChannel *channel;
-  cChannel data;
-  cSourceParam *sourceParam;
-  char name[256];
-  void Setup(void);
-public:
-  cMenuEditChannel(cChannel *Channel, bool New = false);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuEditChannel"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
-:cOsdMenu(tr("Edit channel"), 16)
-{
-  SetMenuCategory(mcChannelEdit);
-  channel = Channel;
-  sourceParam = NULL;
-  *name = 0;
-  if (channel) {
-     data = *channel;
-     strn0cpy(name, data.name, sizeof(name));
-     if (New) {
-        channel = NULL;
-        data.nid = 0;
-        data.tid = 0;
-        data.rid = 0;
-        }
-     }
-  Setup();
-}
-
-void cMenuEditChannel::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  // Parameters for all types of sources:
-  Add(new cMenuEditStrItem( tr("Name"),          name, sizeof(name)));
-  Add(new cMenuEditSrcItem( tr("Source"),       &data.source));
-  Add(new cMenuEditIntItem( tr("Frequency"),    &data.frequency));
-  Add(new cMenuEditIntItem( tr("Vpid"),         &data.vpid,  0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Ppid"),         &data.ppid,  0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Apid1"),        &data.apids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Apid2"),        &data.apids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Dpid1"),        &data.dpids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Dpid2"),        &data.dpids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Spid1"),        &data.spids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Spid2"),        &data.spids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Tpid"),         &data.tpid,  0, 0x1FFF));
-  Add(new cMenuEditCaItem(  tr("CA"),           &data.caids[0]));
-  Add(new cMenuEditIntItem( tr("Sid"),          &data.sid, 1, 0xFFFF));
-  /* XXX not yet used
-  Add(new cMenuEditIntItem( tr("Nid"),          &data.nid, 0));
-  Add(new cMenuEditIntItem( tr("Tid"),          &data.tid, 0));
-  Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0));
-  XXX*/
-#ifdef USE_CHANNELBIND
-  Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0)); // channel binding patch
-#endif /* CHANNELBIND */
-  // Parameters for specific types of sources:
-  sourceParam = SourceParams.Get(**cSource::ToString(data.source));
-  if (sourceParam) {
-     sourceParam->SetData(&data);
-     cOsdItem *Item;
-     while ((Item = sourceParam->GetOsdItem()) != NULL)
-           Add(Item);
-     }
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuEditChannel::ProcessKey(eKeys Key)
-{
-  int oldSource = data.source;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     if (Key == kOk) {
-        if (sourceParam)
-           sourceParam->GetData(&data);
-        if (Channels.HasUniqueChannelID(&data, channel)) {
-           data.name = strcpyrealloc(data.name, name);
-           if (channel) {
-              *channel = data;
-              isyslog("edited channel %d %s", channel->Number(), *data.ToText());
-              state = osBack;
-              }
-           else {
-              channel = new cChannel;
-              *channel = data;
-              Channels.Add(channel);
-              Channels.ReNumber();
-              isyslog("added channel %d %s", channel->Number(), *data.ToText());
-              state = osUser1;
-              }
-           Channels.SetModified(true);
-           }
-        else {
-           Skins.Message(mtError, tr("Channel settings are not unique!"));
-           state = osContinue;
-           }
-        }
-     }
-  if (Key != kNone && (data.source & cSource::st_Mask) != (oldSource & cSource::st_Mask)) {
-     if (sourceParam)
-        sourceParam->GetData(&data);
-     Setup();
-     }
-  return state;
-}
-
-// --- cMenuChannelItem ------------------------------------------------------
-
-class cMenuChannelItem : public cOsdItem {
-public:
-  enum eChannelSortMode { csmNumber, csmName, csmProvider };
-private:
-  static eChannelSortMode sortMode;
-  cChannel *channel;
-public:
-  cMenuChannelItem(cChannel *Channel);
-  static void SetSortMode(eChannelSortMode SortMode) { sortMode = SortMode; }
-  static void IncSortMode(void) { sortMode = eChannelSortMode((sortMode == csmProvider) ? csmNumber : sortMode + 1); }
-  static eChannelSortMode SortMode(void) { return sortMode; }
-  virtual int Compare(const cListObject &ListObject) const;
-  virtual void Set(void);
-  cChannel *Channel(void) { return channel; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuChannelItem::eChannelSortMode cMenuChannelItem::sortMode = csmNumber;
-
-cMenuChannelItem::cMenuChannelItem(cChannel *Channel)
-{
-  channel = Channel;
-  if (channel->GroupSep())
-     SetSelectable(false);
-  Set();
-}
-
-int cMenuChannelItem::Compare(const cListObject &ListObject) const
-{
-  cMenuChannelItem *p = (cMenuChannelItem *)&ListObject;
-  int r = -1;
-  if (sortMode == csmProvider)
-     r = strcoll(channel->Provider(), p->channel->Provider());
-  if (sortMode == csmName || r == 0)
-     r = strcoll(channel->Name(), p->channel->Name());
-  if (sortMode == csmNumber || r == 0)
-     r = channel->Number() - p->channel->Number();
-  return r;
-}
-
-void cMenuChannelItem::Set(void)
-{
-  cString buffer;
-  if (!channel->GroupSep()) {
-     if (sortMode == csmProvider)
-        buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
-#ifdef USE_WAREAGLEICON
-     else if (Setup.WarEagleIcons) {
-        if (channel->Vpid() == 1 || channel->Vpid() == 0)
-           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_RADIO_UTF8 : ICON_RADIO, channel->Name());
-        else if (channel->Ca() == 0)
-           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_UTF8 : ICON_TV, channel->Name());
-        else
-           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_CRYPTED_UTF8 : ICON_TV_CRYPTED, channel->Name());
-        }
-#endif /* WAREAGLEICON */
-     else
-        buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
-     }
-  else
-     buffer = cString::sprintf("---\t%s ----------------------------------------------------------------", channel->Name());
-  SetText(buffer);
-}
-
-void cMenuChannelItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemChannel(channel, Index, Current, Selectable, sortMode == csmProvider))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuChannels ---------------------------------------------------------
-
-#define CHANNELNUMBERTIMEOUT 1000 //ms
-
-class cMenuChannels : public cOsdMenu {
-private:
-  int number;
-  cTimeMs numberTimer;
-  void Setup(void);
-  cChannel *GetChannel(int Index);
-  void Propagate(void);
-protected:
-  eOSState Number(eKeys Key);
-  eOSState Switch(void);
-  eOSState Edit(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  virtual void Move(int From, int To);
-public:
-  cMenuChannels(void);
-  ~cMenuChannels();
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuChannels"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuChannels::cMenuChannels(void)
-:cOsdMenu(tr("Channels"), CHNUMWIDTH)
-{
-  SetMenuCategory(mcChannel);
-  number = 0;
-  Setup();
-  Channels.IncBeingEdited();
-}
-
-cMenuChannels::~cMenuChannels()
-{
-  Channels.DecBeingEdited();
-}
-
-void cMenuChannels::Setup(void)
-{
-  cChannel *currentChannel = GetChannel(Current());
-  if (!currentChannel)
-     currentChannel = Channels.GetByNumber(cDevice::CurrentChannel());
-  cMenuChannelItem *currentItem = NULL;
-  Clear();
-  for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
-      if (!channel->GroupSep() || cMenuChannelItem::SortMode() == cMenuChannelItem::csmNumber && *channel->Name()) {
-         cMenuChannelItem *item = new cMenuChannelItem(channel);
-         Add(item);
-         if (channel == currentChannel)
-            currentItem = item;
-         }
-      }
-  if (cMenuChannelItem::SortMode() != cMenuChannelItem::csmNumber)
-     Sort();
-  SetCurrent(currentItem);
-  SetHelp(tr("Button$Edit"), tr("Button$New"), tr("Button$Delete"), tr("Button$Mark"));
-  Display();
-}
-
-cChannel *cMenuChannels::GetChannel(int Index)
-{
-  cMenuChannelItem *p = (cMenuChannelItem *)Get(Index);
-  return p ? (cChannel *)p->Channel() : NULL;
-}
-
-void cMenuChannels::Propagate(void)
-{
-  Channels.ReNumber();
-  for (cMenuChannelItem *ci = (cMenuChannelItem *)First(); ci; ci = (cMenuChannelItem *)ci->Next())
-      ci->Set();
-  Display();
-  Channels.SetModified(true);
-}
-
-eOSState cMenuChannels::Number(eKeys Key)
-{
-  if (HasSubMenu())
-     return osContinue;
-  if (numberTimer.TimedOut())
-     number = 0;
-  if (!number && Key == k0) {
-     cMenuChannelItem::IncSortMode();
-     Setup();
-     }
-  else {
-     number = number * 10 + Key - k0;
-     for (cMenuChannelItem *ci = (cMenuChannelItem *)First(); ci; ci = (cMenuChannelItem *)ci->Next()) {
-         if (!ci->Channel()->GroupSep() && ci->Channel()->Number() == number) {
-            SetCurrent(ci);
-            Display();
-            break;
-            }
-         }
-     numberTimer.Set(CHANNELNUMBERTIMEOUT);
-     }
-  return osContinue;
-}
-
-eOSState cMenuChannels::Switch(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  cChannel *ch = GetChannel(Current());
-  if (ch)
-     return cDevice::PrimaryDevice()->SwitchChannel(ch, true) ? osEnd : osContinue;
-  return osEnd;
-}
-
-eOSState cMenuChannels::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cChannel *ch = GetChannel(Current());
-  if (ch)
-     return AddSubMenu(new cMenuEditChannel(ch));
-  return osContinue;
-}
-
-eOSState cMenuChannels::New(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  return AddSubMenu(new cMenuEditChannel(GetChannel(Current()), true));
-}
-
-eOSState cMenuChannels::Delete(void)
-{
-  if (!HasSubMenu() && Count() > 0) {
-     int CurrentChannelNr = cDevice::CurrentChannel();
-     cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-     int Index = Current();
-     cChannel *channel = GetChannel(Current());
-     int DeletedChannel = channel->Number();
-     // Check if there is a timer using this channel:
-     if (channel->HasTimer()) {
-        Skins.Message(mtError, tr("Channel is being used by a timer!"));
-        return osContinue;
-        }
-     if (Interface->Confirm(tr("Delete channel?"))) {
-        if (CurrentChannel && channel == CurrentChannel) {
-           int n = Channels.GetNextNormal(CurrentChannel->Index());
-           if (n < 0)
-              n = Channels.GetPrevNormal(CurrentChannel->Index());
-           CurrentChannel = Channels.Get(n);
-           CurrentChannelNr = 0; // triggers channel switch below
-           }
-        Channels.Del(channel);
-        cOsdMenu::Del(Index);
-        Propagate();
-        Channels.SetModified(true);
-        isyslog("channel %d deleted", DeletedChannel);
-        if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-           if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-              Channels.SwitchTo(CurrentChannel->Number());
-           else
-              cDevice::SetCurrentChannel(CurrentChannel);
-           }
-        }
-     }
-  return osContinue;
-}
-
-void cMenuChannels::Move(int From, int To)
-{
-  int CurrentChannelNr = cDevice::CurrentChannel();
-  cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-  cChannel *FromChannel = GetChannel(From);
-  cChannel *ToChannel = GetChannel(To);
-  if (FromChannel && ToChannel) {
-     int FromNumber = FromChannel->Number();
-     int ToNumber = ToChannel->Number();
-     Channels.Move(FromChannel, ToChannel);
-     cOsdMenu::Move(From, To);
-     Propagate();
-     Channels.SetModified(true);
-     isyslog("channel %d moved to %d", FromNumber, ToNumber);
-     if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-        if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-           Channels.SwitchTo(CurrentChannel->Number());
-        else
-           cDevice::SetCurrentChannel(CurrentChannel);
-        }
-     }
-}
-
-eOSState cMenuChannels::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  switch (state) {
-    case osUser1: {
-         cChannel *channel = Channels.Last();
-         if (channel) {
-            Add(new cMenuChannelItem(channel), true);
-            return CloseSubMenu();
-            }
-         }
-         break;
-    default:
-         if (state == osUnknown) {
-            switch (Key) {
-              case k0 ... k9:
-                            return Number(Key);
-              case kOk:     return Switch();
-              case kRed:    return Edit();
-              case kGreen:  return New();
-              case kYellow: return Delete();
-              case kBlue:   if (!HasSubMenu())
-                               Mark();
-                            break;
-              default: break;
-              }
-            }
-    }
-  return state;
-}
-
-// --- cMenuText -------------------------------------------------------------
-
-cMenuText::cMenuText(const char *Title, const char *Text, eDvbFont Font)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcText);
-  text = NULL;
-  font = Font;
-  SetText(Text);
-}
-
-cMenuText::~cMenuText()
-{
-  free(text);
-}
-
-void cMenuText::SetText(const char *Text)
-{
-  free(text);
-  text = Text ? strdup(Text) : NULL;
-}
-
-void cMenuText::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetText(text, font == fontFix); //XXX define control character in text to choose the font???
-  if (text)
-     cStatus::MsgOsdTextItem(text);
-}
-
-eOSState cMenuText::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk: return osBack;
-       default:  state = osContinue;
-       }
-     }
-  return state;
-}
-
-// --- cMenuFolderItem -------------------------------------------------------
-
-class cMenuFolderItem : public cOsdItem {
-private:
-  cNestedItem *folder;
-public:
-  cMenuFolderItem(cNestedItem *Folder);
-  cNestedItem *Folder(void) { return folder; }
-  };
-
-cMenuFolderItem::cMenuFolderItem(cNestedItem *Folder)
-:cOsdItem(Folder->Text())
-{
-  folder = Folder;
-  if (folder->SubItems())
-     SetText(cString::sprintf("%s...", folder->Text()));
-}
-
-// --- cMenuEditFolder -------------------------------------------------------
-
-class cMenuEditFolder : public cOsdMenu {
-private:
-  cList<cNestedItem> *list;
-  cNestedItem *folder;
-  char name[PATH_MAX];
-  int subFolder;
-  eOSState Confirm(void);
-public:
-  cMenuEditFolder(const char *Dir, cList<cNestedItem> *List, cNestedItem *Folder = NULL);
-  cString GetFolder(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditFolder::cMenuEditFolder(const char *Dir, cList<cNestedItem> *List, cNestedItem *Folder)
-:cOsdMenu(Folder ? tr("Edit folder") : tr("New folder"), 12)
-{
-  SetMenuCategory(mcFolder);
-  list = List;
-  folder = Folder;
-  if (folder) {
-     strn0cpy(name, folder->Text(), sizeof(name));
-     subFolder = folder->SubItems() != NULL;
-     }
-  else {
-     *name = 0;
-     subFolder = 0;
-     cRemote::Put(kRight, true); // go right into string editing mode
-     }
-  if (!isempty(Dir)) {
-     cOsdItem *DirItem = new cOsdItem(Dir);
-     DirItem->SetSelectable(false);
-     Add(DirItem);
-     }
-  Add(new cMenuEditStrItem( tr("Name"), name, sizeof(name)));
-  Add(new cMenuEditBoolItem(tr("Sub folder"), &subFolder));
-}
-
-cString cMenuEditFolder::GetFolder(void)
-{
-  return folder ? folder->Text() : "";
-}
-
-eOSState cMenuEditFolder::Confirm(void)
-{
-  if (!folder || strcmp(folder->Text(), name) != 0) {
-     // each name may occur only once in a folder list
-     for (cNestedItem *Folder = list->First(); Folder; Folder = list->Next(Folder)) {
-         if (strcmp(Folder->Text(), name) == 0) {
-            Skins.Message(mtError, tr("Folder name already exists!"));
-            return osContinue;
-            }
-         }
-     char *p = strpbrk(name, "\\{}#~"); // FOLDERDELIMCHAR
-     if (p) {
-        Skins.Message(mtError, cString::sprintf(tr("Folder name must not contain '%c'!"), *p));
-        return osContinue;
-        }
-     }
-  if (folder) {
-     folder->SetText(name);
-     folder->SetSubItems(subFolder);
-     }
-  else
-     list->Add(folder = new cNestedItem(name, subFolder));
-  return osEnd;
-}
-
-eOSState cMenuEditFolder::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     return Confirm();
-       case kRed:
-       case kGreen:
-       case kYellow:
-       case kBlue:   return osContinue;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuFolder -----------------------------------------------------------
-
-cMenuFolder::cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcFolder);
-  list = nestedItemList = NestedItemList;
-  firstFolder = NULL;
-  editing = false;
-  Set();
-  SetHelpKeys();
-  DescendPath(Path);
-}
-
-cMenuFolder::cMenuFolder(const char *Title, cList<cNestedItem> *List, cNestedItemList *NestedItemList, const char *Dir, const char *Path)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcFolder);
-  list = List;
-  nestedItemList = NestedItemList;
-  dir = Dir;
-  firstFolder = NULL;
-  editing = false;
-  Set();
-  SetHelpKeys();
-  DescendPath(Path);
-}
-
-void cMenuFolder::SetHelpKeys(void)
-{
-  SetHelp(firstFolder ? tr("Button$Select") : NULL, tr("Button$New"), firstFolder ? tr("Button$Delete") : NULL, firstFolder ? tr("Button$Edit") : NULL);
-}
-
-void cMenuFolder::Set(const char *CurrentFolder)
-{
-  firstFolder = NULL;
-  Clear();
-  if (!isempty(dir)) {
-     cOsdItem *DirItem = new cOsdItem(dir);
-     DirItem->SetSelectable(false);
-     Add(DirItem);
-     }
-  list->Sort();
-  for (cNestedItem *Folder = list->First(); Folder; Folder = list->Next(Folder)) {
-      cOsdItem *FolderItem = new cMenuFolderItem(Folder);
-      Add(FolderItem, CurrentFolder ? strcmp(Folder->Text(), CurrentFolder) == 0 : false);
-      if (!firstFolder)
-         firstFolder = FolderItem;
-      }
-}
-
-void cMenuFolder::DescendPath(const char *Path)
-{
-  if (Path) {
-     const char *p = strchr(Path, FOLDERDELIMCHAR);
-     if (p) {
-        for (cMenuFolderItem *Folder = (cMenuFolderItem *)firstFolder; Folder; Folder = (cMenuFolderItem *)Next(Folder)) {
-            if (strncmp(Folder->Folder()->Text(), Path, p - Path) == 0) {
-               SetCurrent(Folder);
-               if (Folder->Folder()->SubItems())
-                  AddSubMenu(new cMenuFolder(Title(), Folder->Folder()->SubItems(), nestedItemList, !isempty(dir) ? *cString::sprintf("%s%c%s", *dir, FOLDERDELIMCHAR, Folder->Folder()->Text()) : Folder->Folder()->Text(), p + 1));
-               break;
-               }
-            }
-        }
-    }
-}
-
-eOSState cMenuFolder::Select(void)
-{
-  if (firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        if (Folder->Folder()->SubItems())
-           return AddSubMenu(new cMenuFolder(Title(), Folder->Folder()->SubItems(), nestedItemList, !isempty(dir) ? *cString::sprintf("%s%c%s", *dir, FOLDERDELIMCHAR, Folder->Folder()->Text()) : Folder->Folder()->Text()));
-        else
-           return osEnd;
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::New(void)
-{
-  editing = true;
-  return AddSubMenu(new cMenuEditFolder(dir, list));
-}
-
-eOSState cMenuFolder::Delete(void)
-{
-  if (!HasSubMenu() && firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder && Interface->Confirm(Folder->Folder()->SubItems() ? tr("Delete folder and all sub folders?") : tr("Delete folder?"))) {
-        list->Del(Folder->Folder());
-        Del(Folder->Index());
-        firstFolder = Get(isempty(dir) ? 0 : 1);
-        Display();
-        SetHelpKeys();
-        nestedItemList->Save();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::Edit(void)
-{
-  if (!HasSubMenu() && firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        editing = true;
-        return AddSubMenu(new cMenuEditFolder(dir, list, Folder->Folder()));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::SetFolder(void)
-{
-  cMenuEditFolder *mef = (cMenuEditFolder *)SubMenu();
-  if (mef) {
-     Set(mef->GetFolder());
-     SetHelpKeys();
-     Display();
-     nestedItemList->Save();
-     }
-  return CloseSubMenu();
-}
-
-cString cMenuFolder::GetFolder(void)
-{
-  if (firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        cMenuFolder *mf = (cMenuFolder *)SubMenu();
-        if (mf)
-           return cString::sprintf("%s%c%s", Folder->Folder()->Text(), FOLDERDELIMCHAR, *mf->GetFolder());
-        return Folder->Folder()->Text();
-        }
-     }
-  return "";
-}
-
-eOSState cMenuFolder::ProcessKey(eKeys Key)
-{
-  if (!HasSubMenu())
-     editing = false;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:
-       case kRed:    return Select();
-       case kGreen:  return New();
-       case kYellow: return Delete();
-       case kBlue:   return Edit();
-       default:      state = osContinue;
-       }
-     }
-  else if (state == osEnd && HasSubMenu() && editing)
-     state = SetFolder();
-  return state;
-}
-
-// --- cMenuEditTimer --------------------------------------------------------
-
-cMenuEditTimer::cMenuEditTimer(cTimer *Timer, bool New)
-:cOsdMenu(tr("Edit timer"), 12)
-{
-  SetMenuCategory(mcTimerEdit);
-  file = NULL;
-  day = firstday = NULL;
-  timer = Timer;
-  addIfConfirmed = New;
-  if (timer) {
-     data = *timer;
-     if (New)
-        data.SetFlags(tfActive);
-     channel = data.Channel()->Number();
-     Add(new cMenuEditBitItem( tr("Active"),       &data.flags, tfActive));
-     Add(new cMenuEditChanItem(tr("Channel"),      &channel));
-     Add(day = new cMenuEditDateItem(tr("Day"),    &data.day, &data.weekdays));
-     Add(new cMenuEditTimeItem(tr("Start"),        &data.start));
-     Add(new cMenuEditTimeItem(tr("Stop"),         &data.stop));
-     Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
-     Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
-     Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
-#ifdef USE_PINPLUGIN
-     if (cOsd::pinValid || !data.fskProtection) Add(new cMenuEditBoolItem(tr("Childlock"),&data.fskProtection));
-     else {
-        char* buf = 0;
-        if (asprintf(&buf, "%s\t%s", tr("Childlock"), data.fskProtection ? tr("yes") : tr("no")) > 0) {
-           Add(new cOsdItem(buf));
-           free(buf);
-           }
-        }
-
-#endif /* PINPLUGIN */
-     Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
-     SetFirstDayItem();
-     }
-  SetHelpKeys();
-  Timers.IncBeingEdited();
-}
-
-cMenuEditTimer::~cMenuEditTimer()
-{
-  if (timer && addIfConfirmed)
-     delete timer; // apparently it wasn't confirmed
-  Timers.DecBeingEdited();
-}
-
-void cMenuEditTimer::SetHelpKeys(void)
-{
-  SetHelp(tr("Button$Folder"), data.weekdays ? tr("Button$Single") : tr("Button$Repeating"));
-}
-
-void cMenuEditTimer::SetFirstDayItem(void)
-{
-  if (!firstday && !data.IsSingleEvent()) {
-     Add(firstday = new cMenuEditDateItem(tr("First day"), &data.day));
-     Display();
-     }
-  else if (firstday && data.IsSingleEvent()) {
-     Del(firstday->Index());
-     firstday = NULL;
-     Display();
-     }
-}
-
-eOSState cMenuEditTimer::SetFolder(void)
-{
-  cMenuFolder *mf = (cMenuFolder *)SubMenu();
-  if (mf) {
-     cString Folder = mf->GetFolder();
-     char *p = strrchr(data.file, FOLDERDELIMCHAR);
-     if (p)
-        p++;
-     else
-        p = data.file;
-     if (!isempty(*Folder))
-        strn0cpy(data.file, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(data.file));
-     else if (p != data.file)
-        memmove(data.file, p, strlen(p) + 1);
-     SetCurrent(file);
-     Display();
-     }
-  return CloseSubMenu();
-}
-
-eOSState cMenuEditTimer::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     {
-                       cChannel *ch = Channels.GetByNumber(channel);
-                       if (ch)
-                          data.channel = ch;
-                       else {
-                          Skins.Message(mtError, tr("*** Invalid Channel ***"));
-                          break;
-                          }
-                       if (!*data.file)
-                          strcpy(data.file, data.Channel()->ShortName(true));
-                       if (timer) {
-                          if (memcmp(timer, &data, sizeof(data)) != 0)
-                             *timer = data;
-                          if (addIfConfirmed)
-                             Timers.Add(timer);
-                          timer->SetEventFromSchedule();
-                          timer->Matches();
-                          Timers.SetModified();
-                          isyslog("timer %s %s (%s)", *timer->ToDescr(), addIfConfirmed ? "added" : "modified", timer->HasFlags(tfActive) ? "active" : "inactive");
-                          addIfConfirmed = false;
-                          }
-                     }
-                     return osBack;
-       case kRed:    return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, data.file));
-       case kGreen:  if (day) {
-                        day->ToggleRepeating();
-                        SetCurrent(day);
-                        SetFirstDayItem();
-                        SetHelpKeys();
-                        Display();
-                        }
-                     return osContinue;
-       case kYellow:
-       case kBlue:   return osContinue;
-       default: break;
-       }
-     }
-  else if (state == osEnd && HasSubMenu())
-     state = SetFolder();
-  if (Key != kNone)
-     SetFirstDayItem();
-  return state;
-}
-
-// --- cMenuTimerItem --------------------------------------------------------
-
-class cMenuTimerItem : public cOsdItem {
-private:
-  cTimer *timer;
-public:
-  cMenuTimerItem(cTimer *Timer);
-  virtual int Compare(const cListObject &ListObject) const;
-  virtual void Set(void);
-  cTimer *Timer(void) { return timer; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuTimerItem::cMenuTimerItem(cTimer *Timer)
-{
-  timer = Timer;
-  Set();
-}
-
-int cMenuTimerItem::Compare(const cListObject &ListObject) const
-{
-  return timer->Compare(*((cMenuTimerItem *)&ListObject)->timer);
-}
-
-void cMenuTimerItem::Set(void)
-{
-  cString day, name("");
-  if (timer->WeekDays())
-     day = timer->PrintDay(0, timer->WeekDays(), false);
-  else if (timer->Day() - time(NULL) < 28 * SECSINDAY) {
-     day = itoa(timer->GetMDay(timer->Day()));
-     name = WeekDayName(timer->Day());
-     }
-  else {
-     struct tm tm_r;
-     time_t Day = timer->Day();
-     localtime_r(&Day, &tm_r);
-     char buffer[16];
-     strftime(buffer, sizeof(buffer), "%Y%m%d", &tm_r);
-     day = buffer;
-     }
-  const char *File = Setup.FoldersInTimerMenu ? NULL : strrchr(timer->File(), FOLDERDELIMCHAR);
-  if (File && strcmp(File + 1, TIMERMACRO_TITLE) && strcmp(File + 1, TIMERMACRO_EPISODE))
-     File++;
-  else
-     File = timer->File();
-  SetText(cString::sprintf("%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
-#ifdef USE_WAREAGLEICON
-                    !(timer->HasFlags(tfActive)) ? " " : timer->FirstDay() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_ARROW_UTF8 : ICON_ARROW : "!" : timer->Recording() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_REC_UTF8 : ICON_REC : "#" : Setup.WarEagleIcons ? IsLangUtf8() ? ICON_CLOCK_UTF8 : ICON_CLOCK : ">",
-#else
-                    !(timer->HasFlags(tfActive)) ? ' ' : timer->FirstDay() ? '!' : timer->Recording() ? '#' : '>',
-#endif /* WAREAGLEICON */
-                    timer->Channel()->Number(),
-                    *name,
-                    *name && **name ? " " : "",
-                    *day,
-                    timer->Start() / 100,
-                    timer->Start() % 100,
-                    timer->Stop() / 100,
-                    timer->Stop() % 100,
-                    File));
-}
-
-void cMenuTimerItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemTimer(timer, Index, Current, Selectable))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuTimers -----------------------------------------------------------
-
-class cMenuTimers : public cOsdMenu {
-private:
-  int helpKeys;
-  eOSState Edit(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  eOSState OnOff(void);
-  eOSState Info(void);
-  cTimer *CurrentTimer(void);
-  void SetHelpKeys(void);
-public:
-  cMenuTimers(void);
-  virtual ~cMenuTimers();
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuTimers::cMenuTimers(void)
-:cOsdMenu(tr("Timers"), 2, CHNUMWIDTH, 10, 6, 6)
-{
-  SetMenuCategory(mcTimer);
-  helpKeys = -1;
-  for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
-      timer->SetEventFromSchedule(); // make sure the event is current
-      Add(new cMenuTimerItem(timer));
-      }
-  Sort();
-  SetCurrent(First());
-  SetHelpKeys();
-  Timers.IncBeingEdited();
-}
-
-cMenuTimers::~cMenuTimers()
-{
-  Timers.DecBeingEdited();
-}
-
-cTimer *cMenuTimers::CurrentTimer(void)
-{
-  cMenuTimerItem *item = (cMenuTimerItem *)Get(Current());
-  return item ? item->Timer() : NULL;
-}
-
-void cMenuTimers::SetHelpKeys(void)
-{
-  int NewHelpKeys = 0;
-  cTimer *timer = CurrentTimer();
-  if (timer) {
-     if (timer->Event())
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     helpKeys = NewHelpKeys;
-     SetHelp(helpKeys > 0 ? tr("Button$On/Off") : NULL, tr("Button$New"), helpKeys > 0 ? tr("Button$Delete") : NULL, helpKeys == 2 ? tr("Button$Info") : NULL);
-     }
-}
-
-eOSState cMenuTimers::OnOff(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  cTimer *timer = CurrentTimer();
-  if (timer) {
-     timer->OnOff();
-     timer->SetEventFromSchedule();
-     RefreshCurrent();
-     DisplayCurrent(true);
-     if (timer->FirstDay())
-        isyslog("timer %s first day set to %s", *timer->ToDescr(), *timer->PrintFirstDay());
-     else
-        isyslog("timer %s %sactivated", *timer->ToDescr(), timer->HasFlags(tfActive) ? "" : "de");
-     Timers.SetModified();
-     }
-  return osContinue;
-}
-
-eOSState cMenuTimers::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  isyslog("editing timer %s", *CurrentTimer()->ToDescr());
-  return AddSubMenu(new cMenuEditTimer(CurrentTimer()));
-}
-
-eOSState cMenuTimers::New(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  return AddSubMenu(new cMenuEditTimer(new cTimer, true));
-}
-
-eOSState cMenuTimers::Delete(void)
-{
-  // Check if this timer is active:
-  cTimer *ti = CurrentTimer();
-  if (ti) {
-     if (Interface->Confirm(tr("Delete timer?"))) {
-        if (ti->Recording()) {
-           if (Interface->Confirm(tr("Timer still recording - really delete?"))) {
-              ti->Skip();
-              cRecordControls::Process(time(NULL));
-              }
-           else
-              return osContinue;
-           }
-        isyslog("deleting timer %s", *ti->ToDescr());
-        Timers.Del(ti);
-        cOsdMenu::Del(Current());
-        Timers.SetModified();
-        Display();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuTimers::Info(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cTimer *ti = CurrentTimer();
-  if (ti && ti->Event())
-     return AddSubMenu(new cMenuEvent(ti->Event()));
-  return osContinue;
-}
-
-eOSState cMenuTimers::ProcessKey(eKeys Key)
-{
-  int TimerNumber = HasSubMenu() ? Count() : -1;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     return Edit();
-       case kRed:    state = OnOff(); break; // must go through SetHelpKeys()!
-       case kGreen:  return New();
-       case kYellow: state = Delete(); break;
-       case kInfo:
-       case kBlue:   return Info();
-                     break;
-       default: break;
-       }
-     }
-  if (TimerNumber >= 0 && !HasSubMenu() && Timers.Get(TimerNumber)) {
-     // a newly created timer was confirmed with Ok
-     Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
-     Display();
-     }
-  if (Key != kNone)
-     SetHelpKeys();
-  return state;
-}
-
-// --- cMenuEvent ------------------------------------------------------------
-
-cMenuEvent::cMenuEvent(const cEvent *Event, bool CanSwitch, bool Buttons)
-:cOsdMenu(tr("Event"))
-{
-  SetMenuCategory(mcEvent);
-  event = Event;
-  if (event) {
-     cChannel *channel = Channels.GetByChannelID(event->ChannelID(), true);
-     if (channel) {
-        SetTitle(channel->Name());
-        eTimerMatch TimerMatch = tmNone;
-        Timers.GetMatch(event, &TimerMatch);
-        if (Buttons)
-           SetHelp(TimerMatch == tmFull ? tr("Button$Timer") : tr("Button$Record"), NULL, NULL, CanSwitch ? tr("Button$Switch") : NULL);
-        }
-     }
-}
-
-void cMenuEvent::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetEvent(event);
-#ifdef USE_GRAPHTFT
-  cStatus::MsgOsdSetEvent(event);
-#endif /* GRAPHTFT */
-  if (event->Description())
-     cStatus::MsgOsdTextItem(event->Description());
-}
-
-eOSState cMenuEvent::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    case kInfo:   return osBack;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kGreen:
-       case kYellow: return osContinue;
-       case kOk:     return osBack;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuScheduleItem -----------------------------------------------------
-
-class cMenuScheduleItem : public cOsdItem {
-public:
-  enum eScheduleSortMode { ssmAllThis, ssmThisThis, ssmThisAll, ssmAllAll }; // "which event(s) on which channel(s)"
-private:
-  static eScheduleSortMode sortMode;
-public:
-  const cEvent *event;
-  const cChannel *channel;
-  bool withDate;
-  eTimerMatch timerMatch;
-  cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false);
-  static void SetSortMode(eScheduleSortMode SortMode) { sortMode = SortMode; }
-  static void IncSortMode(void) { sortMode = eScheduleSortMode((sortMode == ssmAllAll) ? ssmAllThis : sortMode + 1); }
-  static eScheduleSortMode SortMode(void) { return sortMode; }
-  virtual int Compare(const cListObject &ListObject) const;
-  bool Update(bool Force = false);
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuScheduleItem::eScheduleSortMode cMenuScheduleItem::sortMode = ssmAllThis;
-
-cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate)
-{
-  event = Event;
-  channel = Channel;
-  withDate = WithDate;
-  timerMatch = tmNone;
-  Update(true);
-}
-
-int cMenuScheduleItem::Compare(const cListObject &ListObject) const
-{
-  cMenuScheduleItem *p = (cMenuScheduleItem *)&ListObject;
-  int r = -1;
-  if (sortMode != ssmAllThis)
-     r = strcoll(event->Title(), p->event->Title());
-  if (sortMode == ssmAllThis || r == 0)
-     r = event->StartTime() - p->event->StartTime();
-  return r;
-}
-
-#ifdef USE_WAREAGLEICON
-static const char *TimerMatchChars[9] =
-{
-  " ", "t", "T",
-  ICON_BLANK, ICON_CLOCK_UH, ICON_CLOCK,
-  ICON_BLANK_UTF8, ICON_CLOCK_UH_UTF8, ICON_CLOCK_UTF8
-};
-#else
-static const char *TimerMatchChars = " tT";
-#endif /* WAREAGLEICON */
-
-bool cMenuScheduleItem::Update(bool Force)
-{
-  bool result = false;
-  eTimerMatch OldTimerMatch = timerMatch;
-  Timers.GetMatch(event, &timerMatch);
-  if (Force || timerMatch != OldTimerMatch) {
-     cString buffer;
-#ifdef USE_WAREAGLEICON
-     const char *t = Setup.WarEagleIcons ? IsLangUtf8() ? TimerMatchChars[timerMatch+6] : TimerMatchChars[timerMatch+3] : TimerMatchChars[timerMatch];
-     const char *v = event->Vps() && (event->Vps() - event->StartTime()) ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_VPS_UTF8 : ICON_VPS : "V" : " ";
-     const char *r = event->SeenWithin(30) && event->IsRunning() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_RUNNING_UTF8 : ICON_RUNNING : "*" : " ";
-#else
-     char t = TimerMatchChars[timerMatch];
-     char v = event->Vps() && (event->Vps() - event->StartTime()) ? 'V' : ' ';
-     char r = event->SeenWithin(30) && event->IsRunning() ? '*' : ' ';
-#endif /* WAREAGLEICON */
-     const char *csn = channel ? channel->ShortName(true) : NULL;
-     cString eds = event->GetDateString();
-     if (channel && withDate)
-#ifdef USE_WAREAGLEICON
-        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-#else
-        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-#endif /* WAREAGLEICON */
-     else if (channel)
-#ifdef USE_WAREAGLEICON
-        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
-#else
-        buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
-#endif /* WAREAGLEICON */
-     else
-#ifdef USE_WAREAGLEICON
-        buffer = cString::sprintf("%.*s\t%s\t%s%s%s\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-#else
-        buffer = cString::sprintf("%.*s\t%s\t%c%c%c\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-#endif /* WAREAGLEICON */
-     SetText(buffer);
-     result = true;
-     }
-  return result;
-}
-
-void cMenuScheduleItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemEvent(event, Index, Current, Selectable, channel, withDate, timerMatch))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuWhatsOn ----------------------------------------------------------
-
-class cMenuWhatsOn : public cOsdMenu {
-private:
-  bool now;
-  int helpKeys;
-  int timerState;
-  eOSState Record(void);
-  eOSState Switch(void);
-  static int currentChannel;
-  static const cEvent *scheduleEvent;
-  bool Update(void);
-  void SetHelpKeys(void);
-public:
-  cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr);
-  static int CurrentChannel(void) { return currentChannel; }
-  static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
-  static const cEvent *ScheduleEvent(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
-  virtual void Display(void);
-#endif /* GRAPHTFT */
-  };
-
-int cMenuWhatsOn::currentChannel = 0;
-const cEvent *cMenuWhatsOn::scheduleEvent = NULL;
-
-cMenuWhatsOn::cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr)
-:cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, CHNAMWIDTH, 6, 4)
-{
-  SetMenuCategory(Now ? mcScheduleNow : mcScheduleNext);
-  now = Now;
-  helpKeys = -1;
-  timerState = 0;
-  Timers.Modified(timerState);
-  for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-      if (!Channel->GroupSep()) {
-         const cSchedule *Schedule = Schedules->GetSchedule(Channel);
-         if (Schedule) {
-            const cEvent *Event = Now ? Schedule->GetPresentEvent() : Schedule->GetFollowingEvent();
-            if (Event)
-               Add(new cMenuScheduleItem(Event, Channel), Channel->Number() == CurrentChannelNr);
-            }
-         }
-      }
-  currentChannel = CurrentChannelNr;
-  Display();
-  SetHelpKeys();
-}
-
-#ifdef USE_GRAPHTFT
-void cMenuWhatsOn::Display(void)
-{
-   cOsdMenu::Display();
-
-   if (Count() > 0) {
-      int ni = 0;
-      for (cOsdItem *item = First(); item; item = Next(item)) {
-         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
-      }
-   }
-}
-#endif /* GRAPHTFT */
-
-bool cMenuWhatsOn::Update(void)
-{
-  bool result = false;
-  if (Timers.Modified(timerState)) {
-     for (cOsdItem *item = First(); item; item = Next(item)) {
-         if (((cMenuScheduleItem *)item)->Update())
-            result = true;
-         }
-     }
-  return result;
-}
-
-void cMenuWhatsOn::SetHelpKeys(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (item) {
-     if (item->timerMatch == tmFull)
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     const char *Red[] = { NULL, tr("Button$Record"), tr("Button$Timer") };
-     SetHelp(Red[NewHelpKeys], now ? tr("Button$Next") : tr("Button$Now"), tr("Button$Schedule"), tr("Button$Switch"));
-     helpKeys = NewHelpKeys;
-     }
-}
-
-const cEvent *cMenuWhatsOn::ScheduleEvent(void)
-{
-  const cEvent *ei = scheduleEvent;
-  scheduleEvent = NULL;
-  return ei;
-}
-
-eOSState cMenuWhatsOn::Switch(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     cChannel *channel = Channels.GetByChannelID(item->event->ChannelID(), true);
-     if (channel && cDevice::PrimaryDevice()->SwitchChannel(channel, true))
-        return osEnd;
-     }
-  Skins.Message(mtError, tr("Can't switch channel!"));
-  return osContinue;
-}
-
-eOSState cMenuWhatsOn::Record(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     if (item->timerMatch == tmFull) {
-        eTimerMatch tm = tmNone;
-        cTimer *timer = Timers.GetMatch(item->event, &tm);
-        if (timer)
-           return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     cTimer *timer = new cTimer(item->event);
-     cTimer *t = Timers.GetTimer(timer);
-     if (t) {
-        delete timer;
-        timer = t;
-        return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     else {
-        Timers.Add(timer);
-        Timers.SetModified();
-        isyslog("timer %s added (active)", *timer->ToDescr());
-        if (timer->Matches(0, false, NEWTIMERLIMIT))
-           return AddSubMenu(new cMenuEditTimer(timer));
-        if (HasSubMenu())
-           CloseSubMenu();
-        if (Update())
-           Display();
-        SetHelpKeys();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuWhatsOn::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRecord:
-       case kRed:    return Record();
-       case kYellow: state = osBack;
-                     // continue with kGreen
-       case kGreen:  {
-                       cMenuScheduleItem *mi = (cMenuScheduleItem *)Get(Current());
-                       if (mi) {
-                          scheduleEvent = mi->event;
-                          currentChannel = mi->channel->Number();
-                          }
-                     }
-                     break;
-       case kBlue:   return Switch();
-       case kInfo:
-       case kOk:     if (Count())
-                        return AddSubMenu(new cMenuEvent(((cMenuScheduleItem *)Get(Current()))->event, true, true));
-                     break;
-       default:      break;
-       }
-     }
-  else if (!HasSubMenu()) {
-     if (HadSubMenu && Update())
-        Display();
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuSchedule ---------------------------------------------------------
-
-class cMenuSchedule : public cOsdMenu {
-private:
-  cSchedulesLock schedulesLock;
-  const cSchedules *schedules;
-  bool now, next;
-  int otherChannel;
-  int helpKeys;
-  int timerState;
-  eOSState Number(void);
-  eOSState Record(void);
-  eOSState Switch(void);
-  void PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleThisThis(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleThisAll(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleAllAll(const cEvent *Event, const cChannel *Channel);
-  bool Update(void);
-  void SetHelpKeys(void);
-public:
-  cMenuSchedule(void);
-  virtual ~cMenuSchedule();
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSchedule"; }
-  virtual void Display(void);
-#endif /* GRAPHTFT */
-  };
-
-cMenuSchedule::cMenuSchedule(void)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcSchedule);
-  now = next = false;
-  otherChannel = 0;
-  helpKeys = -1;
-  timerState = 0;
-  Timers.Modified(timerState);
-  cMenuScheduleItem::SetSortMode(cMenuScheduleItem::ssmAllThis);
-  cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  if (channel) {
-     cMenuWhatsOn::SetCurrentChannel(channel->Number());
-     schedules = cSchedules::Schedules(schedulesLock);
-     PrepareScheduleAllThis(NULL, channel);
-     SetHelpKeys();
-     }
-}
-
-cMenuSchedule::~cMenuSchedule()
-{
-  cMenuWhatsOn::ScheduleEvent(); // makes sure any posted data is cleared
-}
-
-#ifdef USE_GRAPHTFT
-void cMenuSchedule::Display(void)
-{
-   cOsdMenu::Display();
-
-   if (Count() > 0) {
-      int ni = 0;
-      for (cOsdItem *item = First(); item; item = Next(item)) {
-         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
-      }
-   }
-}
-#endif /* GRAPHTFT */
-
-void cMenuSchedule::PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(7, 6, 4);
-  SetTitle(cString::sprintf(tr("Schedule - %s"), Channel->Name()));
-  if (schedules && Channel) {
-     const cSchedule *Schedule = schedules->GetSchedule(Channel);
-     if (Schedule) {
-        const cEvent *PresentEvent = Event ? Event : Schedule->GetPresentEvent();
-        time_t now = time(NULL) - Setup.EPGLinger * 60;
-        for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-            if (ev->EndTime() > now || ev == PresentEvent)
-               Add(new cMenuScheduleItem(ev), ev == PresentEvent);
-            }
-        }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleThisThis(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(7, 6, 4);
-  SetTitle(cString::sprintf(tr("This event - %s"), Channel->Name()));
-  if (schedules && Channel && Event) {
-     const cSchedule *Schedule = schedules->GetSchedule(Channel);
-     if (Schedule) {
-        time_t now = time(NULL) - Setup.EPGLinger * 60;
-        for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-            if ((ev->EndTime() > now || ev == Event) && !strcmp(ev->Title(), Event->Title()))
-               Add(new cMenuScheduleItem(ev), ev == Event);
-            }
-        }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleThisAll(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(CHNUMWIDTH, CHNAMWIDTH, 7, 6, 4);
-  SetTitle(tr("This event - all channels"));
-  if (schedules && Event) {
-     for (cChannel *ch = Channels.First(); ch; ch = Channels.Next(ch)) {
-         const cSchedule *Schedule = schedules->GetSchedule(ch);
-         if (Schedule) {
-            time_t now = time(NULL) - Setup.EPGLinger * 60;
-            for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-                if ((ev->EndTime() > now || ev == Event) && !strcmp(ev->Title(), Event->Title()))
-                   Add(new cMenuScheduleItem(ev, ch, true), ev == Event && ch == Channel);
-                }
-            }
-         }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleAllAll(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(CHNUMWIDTH, CHNAMWIDTH, 7, 6, 4);
-  SetTitle(tr("All events - all channels"));
-  if (schedules) {
-     for (cChannel *ch = Channels.First(); ch; ch = Channels.Next(ch)) {
-         const cSchedule *Schedule = schedules->GetSchedule(ch);
-         if (Schedule) {
-            time_t now = time(NULL) - Setup.EPGLinger * 60;
-            for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-                if (ev->EndTime() > now || ev == Event)
-                   Add(new cMenuScheduleItem(ev, ch, true), ev == Event && ch == Channel);
-                }
-            }
-         }
-     }
-}
-
-bool cMenuSchedule::Update(void)
-{
-  bool result = false;
-  if (Timers.Modified(timerState)) {
-     for (cOsdItem *item = First(); item; item = Next(item)) {
-         if (((cMenuScheduleItem *)item)->Update())
-            result = true;
-         }
-     }
-  return result;
-}
-
-void cMenuSchedule::SetHelpKeys(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (item) {
-     if (item->timerMatch == tmFull)
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     const char *Red[] = { NULL, tr("Button$Record"), tr("Button$Timer") };
-     SetHelp(Red[NewHelpKeys], tr("Button$Now"), tr("Button$Next"));
-     helpKeys = NewHelpKeys;
-     }
-}
-
-eOSState cMenuSchedule::Number(void)
-{
-  cMenuScheduleItem::IncSortMode();
-  cMenuScheduleItem *CurrentItem = (cMenuScheduleItem *)Get(Current());
-  const cChannel *Channel = NULL;
-  const cEvent *Event = NULL;
-  if (CurrentItem) {
-     Event = CurrentItem->event;
-     Channel = Channels.GetByChannelID(Event->ChannelID(), true);
-     }
-  else
-     Channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  switch (cMenuScheduleItem::SortMode()) {
-    case cMenuScheduleItem::ssmAllThis:  PrepareScheduleAllThis(Event, Channel); break;
-    case cMenuScheduleItem::ssmThisThis: PrepareScheduleThisThis(Event, Channel); break;
-    case cMenuScheduleItem::ssmThisAll:  PrepareScheduleThisAll(Event, Channel); break;
-    case cMenuScheduleItem::ssmAllAll:   PrepareScheduleAllAll(Event, Channel); break;
-    default: esyslog("ERROR: unknown SortMode %d (%s %d)", cMenuScheduleItem::SortMode(), __FUNCTION__, __LINE__);
-    }
-  CurrentItem = (cMenuScheduleItem *)Get(Current());
-  Sort();
-  SetCurrent(CurrentItem);
-  Display();
-  return osContinue;
-}
-
-eOSState cMenuSchedule::Record(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     if (item->timerMatch == tmFull) {
-        eTimerMatch tm = tmNone;
-        cTimer *timer = Timers.GetMatch(item->event, &tm);
-        if (timer)
-           return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     cTimer *timer = new cTimer(item->event);
-     cTimer *t = Timers.GetTimer(timer);
-     if (t) {
-        delete timer;
-        timer = t;
-        return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     else {
-        Timers.Add(timer);
-        Timers.SetModified();
-        isyslog("timer %s added (active)", *timer->ToDescr());
-        if (timer->Matches(0, false, NEWTIMERLIMIT))
-           return AddSubMenu(new cMenuEditTimer(timer));
-        if (HasSubMenu())
-           CloseSubMenu();
-        if (Update())
-           Display();
-        SetHelpKeys();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuSchedule::Switch(void)
-{
-  if (otherChannel) {
-     if (Channels.SwitchTo(otherChannel))
-        return osEnd;
-     }
-  Skins.Message(mtError, tr("Can't switch channel!"));
-  return osContinue;
-}
-
-eOSState cMenuSchedule::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case k0:      return Number();
-       case kRecord:
-       case kRed:    return Record();
-       case kGreen:  if (schedules) {
-                        if (!now && !next) {
-                           int ChannelNr = 0;
-                           if (Count()) {
-                              cChannel *channel = Channels.GetByChannelID(((cMenuScheduleItem *)Get(Current()))->event->ChannelID(), true);
-                              if (channel)
-                                 ChannelNr = channel->Number();
-                              }
-                           now = true;
-                           return AddSubMenu(new cMenuWhatsOn(schedules, true, ChannelNr));
-                           }
-                        now = !now;
-                        next = !next;
-                        return AddSubMenu(new cMenuWhatsOn(schedules, now, cMenuWhatsOn::CurrentChannel()));
-                        }
-       case kYellow: if (schedules)
-                        return AddSubMenu(new cMenuWhatsOn(schedules, false, cMenuWhatsOn::CurrentChannel()));
-                     break;
-       case kBlue:   if (Count() && otherChannel)
-                        return Switch();
-                     break;
-       case kInfo:
-       case kOk:     if (Count())
-                        return AddSubMenu(new cMenuEvent(((cMenuScheduleItem *)Get(Current()))->event, otherChannel, true));
-                     break;
-       default:      break;
-       }
-     }
-  else if (!HasSubMenu()) {
-     now = next = false;
-     const cEvent *ei = cMenuWhatsOn::ScheduleEvent();
-     if (ei) {
-        cChannel *channel = Channels.GetByChannelID(ei->ChannelID(), true);
-        if (channel) {
-           cMenuScheduleItem::SetSortMode(cMenuScheduleItem::ssmAllThis);
-           PrepareScheduleAllThis(NULL, channel);
-           if (channel->Number() != cDevice::CurrentChannel()) {
-              otherChannel = channel->Number();
-              SetHelp(Count() ? tr("Button$Record") : NULL, tr("Button$Now"), tr("Button$Next"), tr("Button$Switch"));
-              }
-           Display();
-           }
-        }
-     else if (HadSubMenu && Update())
-        Display();
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuCommands ---------------------------------------------------------
-
-cMenuCommands::cMenuCommands(const char *Title, cList<cNestedItem> *Commands, const char *Parameters)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcCommand);
-  result = NULL;
-  SetHasHotkeys();
-  commands = Commands;
-  parameters = Parameters;
-  for (cNestedItem *Command = commands->First(); Command; Command = commands->Next(Command)) {
-      const char *s = Command->Text();
-      if (Command->SubItems())
-         Add(new cOsdItem(hk(cString::sprintf("%s...", s))));
-      else if (Parse(s))
-         Add(new cOsdItem(hk(title)));
-      }
-}
-
-cMenuCommands::~cMenuCommands()
-{
-  free(result);
-}
-
-bool cMenuCommands::Parse(const char *s)
-{
-  const char *p = strchr(s, ':');
-  if (p) {
-     int l = p - s;
-     if (l > 0) {
-        char t[l + 1];
-        stripspace(strn0cpy(t, s, l + 1));
-        l = strlen(t);
-        if (l > 1 && t[l - 1] == '?') {
-           t[l - 1] = 0;
-           confirm = true;
-           }
-        else
-           confirm = false;
-        title = t;
-        command = skipspace(p + 1);
-        return true;
-        }
-     }
-  return false;
-}
-
-eOSState cMenuCommands::Execute(void)
-{
-  cNestedItem *Command = commands->Get(Current());
-  if (Command) {
-     if (Command->SubItems())
-        return AddSubMenu(new cMenuCommands(Title(), Command->SubItems(), parameters));
-     if (Parse(Command->Text())) {
-        if (!confirm || Interface->Confirm(cString::sprintf("%s?", *title))) {
-           Skins.Message(mtStatus, cString::sprintf("%s...", *title));
-           free(result);
-           result = NULL;
-           cString cmdbuf;
-           if (!isempty(parameters))
-              cmdbuf = cString::sprintf("%s %s", *command, *parameters);
-           const char *cmd = *cmdbuf ? *cmdbuf : *command;
-           dsyslog("executing command '%s'", cmd);
-           cPipe p;
-           if (p.Open(cmd, "r")) {
-              int l = 0;
-              int c;
-              while ((c = fgetc(p)) != EOF) {
-                    if (l % 20 == 0) {
-                       if (char *NewBuffer = (char *)realloc(result, l + 21))
-                          result = NewBuffer;
-                       else {
-                          esyslog("ERROR: out of memory");
-                          break;
-                          }
-                       }
-                    result[l++] = char(c);
-                    }
-              if (result)
-                 result[l] = 0;
-              p.Close();
-              }
-           else
-              esyslog("ERROR: can't open pipe for command '%s'", cmd);
-           Skins.Message(mtStatus, NULL);
-           if (result)
-              return AddSubMenu(new cMenuText(title, result, fontFix));
-           return osEnd;
-           }
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuCommands::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:
-       case kGreen:
-       case kYellow:
-       case kBlue:   return osContinue;
-       case kOk:     return Execute();
-       default:      break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuCam --------------------------------------------------------------
-
-static bool CamMenuIsOpen = false;
-
-class cMenuCam : public cOsdMenu {
-private:
-  cCamSlot *camSlot;
-  cCiMenu *ciMenu;
-  cCiEnquiry *ciEnquiry;
-  char *input;
-  int offset;
-  time_t lastCamExchange;
-  void GenerateTitle(const char *s = NULL);
-  void QueryCam(void);
-  void AddMultiLineItem(const char *s);
-  void Set(void);
-  eOSState Select(void);
-public:
-  cMenuCam(cCamSlot *CamSlot);
-  virtual ~cMenuCam();
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuCam"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuCam::cMenuCam(cCamSlot *CamSlot)
-:cOsdMenu("", 1) // tab necessary for enquiry!
-{
-  SetMenuCategory(mcCam);
-  camSlot = CamSlot;
-  ciMenu = NULL;
-  ciEnquiry = NULL;
-  input = NULL;
-  offset = 0;
-  lastCamExchange = time(NULL);
-  SetNeedsFastResponse(true);
-  QueryCam();
-  CamMenuIsOpen = true;
-}
-
-cMenuCam::~cMenuCam()
-{
-  if (ciMenu)
-     ciMenu->Abort();
-  delete ciMenu;
-  if (ciEnquiry)
-     ciEnquiry->Abort();
-  delete ciEnquiry;
-  free(input);
-  CamMenuIsOpen = false;
-}
-
-void cMenuCam::GenerateTitle(const char *s)
-{
-  SetTitle(cString::sprintf("CAM %d - %s", camSlot->SlotNumber(), (s && *s) ? s : camSlot->GetCamName()));
-}
-
-void cMenuCam::QueryCam(void)
-{
-  delete ciMenu;
-  ciMenu = NULL;
-  delete ciEnquiry;
-  ciEnquiry = NULL;
-  if (camSlot->HasUserIO()) {
-     ciMenu = camSlot->GetMenu();
-     ciEnquiry = camSlot->GetEnquiry();
-     }
-  Set();
-}
-
-void cMenuCam::Set(void)
-{
-  if (ciMenu) {
-     Clear();
-     free(input);
-     input = NULL;
-     dsyslog("CAM %d: Menu ------------------", camSlot->SlotNumber());
-     offset = 0;
-     SetHasHotkeys(ciMenu->Selectable());
-     GenerateTitle(ciMenu->TitleText());
-     dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->TitleText());
-     if (*ciMenu->SubTitleText()) {
-        dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->SubTitleText());
-        AddMultiLineItem(ciMenu->SubTitleText());
-        offset = Count();
-        }
-     for (int i = 0; i < ciMenu->NumEntries(); i++) {
-         Add(new cOsdItem(hk(ciMenu->Entry(i)), osUnknown, ciMenu->Selectable()));
-         dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->Entry(i));
-         }
-     if (*ciMenu->BottomText()) {
-        AddMultiLineItem(ciMenu->BottomText());
-        dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->BottomText());
-        }
-     cRemote::TriggerLastActivity();
-     }
-  else if (ciEnquiry) {
-     Clear();
-     int Length = ciEnquiry->ExpectedLength();
-     free(input);
-     input = MALLOC(char, Length + 1);
-     *input = 0;
-     GenerateTitle();
-     Add(new cOsdItem(ciEnquiry->Text(), osUnknown, false));
-     Add(new cOsdItem("", osUnknown, false));
-     Add(new cMenuEditNumItem("", input, Length, ciEnquiry->Blind()));
-     }
-  Display();
-}
-
-void cMenuCam::AddMultiLineItem(const char *s)
-{
-  while (s && *s) {
-        const char *p = strchr(s, '\n');
-        int l = p ? p - s : strlen(s);
-        cOsdItem *item = new cOsdItem;
-        item->SetSelectable(false);
-        item->SetText(strndup(s, l), false);
-        Add(item);
-        s = p ? p + 1 : p;
-        }
-}
-
-eOSState cMenuCam::Select(void)
-{
-  if (ciMenu) {
-     if (ciMenu->Selectable()) {
-        ciMenu->Select(Current() - offset);
-        dsyslog("CAM %d: select %d", camSlot->SlotNumber(), Current() - offset);
-        }
-     else
-        ciMenu->Cancel();
-     }
-  else if (ciEnquiry) {
-     if (ciEnquiry->ExpectedLength() < 0xFF && int(strlen(input)) != ciEnquiry->ExpectedLength()) {
-        char buffer[64];
-        snprintf(buffer, sizeof(buffer), tr("Please enter %d digits!"), ciEnquiry->ExpectedLength());
-        Skins.Message(mtError, buffer);
-        return osContinue;
-        }
-     ciEnquiry->Reply(input);
-     dsyslog("CAM %d: entered '%s'", camSlot->SlotNumber(), ciEnquiry->Blind() ? "****" : input);
-     }
-  QueryCam();
-  return osContinue;
-}
-
-eOSState cMenuCam::ProcessKey(eKeys Key)
-{
-  if (!camSlot->HasMMI())
-     return osBack;
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (ciMenu || ciEnquiry) {
-     lastCamExchange = time(NULL);
-     if (state == osUnknown) {
-        switch (Key) {
-          case kOk: return Select();
-          default: break;
-          }
-        }
-     else if (state == osBack) {
-        if (ciMenu)
-           ciMenu->Cancel();
-        if (ciEnquiry)
-           ciEnquiry->Cancel();
-        QueryCam();
-        return osContinue;
-        }
-     if (ciMenu && ciMenu->HasUpdate()) {
-        QueryCam();
-        return osContinue;
-        }
-     }
-  else if (time(NULL) - lastCamExchange < CAMRESPONSETIMEOUT)
-     QueryCam();
-  else {
-     Skins.Message(mtError, tr("CAM not responding!"));
-     return osBack;
-     }
-  return state;
-}
-
-// --- CamControl ------------------------------------------------------------
-
-cOsdObject *CamControl(void)
-{
-  for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
-      if (CamSlot->HasUserIO())
-         return new cMenuCam(CamSlot);
-      }
-  return NULL;
-}
-
-bool CamMenuActive(void)
-{
-  return CamMenuIsOpen;
-}
-
-// --- cMenuRecording --------------------------------------------------------
-
-class cMenuRecording : public cOsdMenu {
-private:
-  const cRecording *recording;
-  bool withButtons;
-public:
-  cMenuRecording(const cRecording *Recording, bool WithButtons = false);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuRecording"; }
-#endif /* GRAPHTFT */
-};
-
-cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
-:cOsdMenu(tr("Recording info"))
-{
-  SetMenuCategory(mcRecordingInfo);
-  recording = Recording;
-  withButtons = WithButtons;
-  if (withButtons)
-     SetHelp(tr("Button$Play"), tr("Button$Rewind"));
-}
-
-void cMenuRecording::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetRecording(recording);
-#ifdef USE_GRAPHTFT
-  cStatus::MsgOsdSetRecording(recording);
-#endif /* GRAPHTFT */
-  if (recording->Info()->Description())
-     cStatus::MsgOsdTextItem(recording->Info()->Description());
-}
-
-eOSState cMenuRecording::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    case kInfo:   return osBack;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:    if (withButtons)
-                        Key = kOk; // will play the recording, even if recording commands are defined
-       case kGreen:  if (!withButtons)
-                        break;
-                     cRemote::Put(Key, true);
-                     // continue with osBack to close the info menu and process the key
-       case kOk:     return osBack;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuRecordingItem ----------------------------------------------------
-
-class cMenuRecordingItem : public cOsdItem {
-private:
-  cRecording *recording;
-  int level;
-  char *name;
-  int totalEntries, newEntries;
-public:
-  cMenuRecordingItem(cRecording *Recording, int Level);
-  ~cMenuRecordingItem();
-  void IncrementCounter(bool New);
-  const char *Name(void) { return name; }
-  cRecording *Recording(void) { return recording; }
-  bool IsDirectory(void) { return name != NULL; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuRecordingItem::cMenuRecordingItem(cRecording *Recording, int Level)
-{
-  recording = Recording;
-  level = Level;
-  name = NULL;
-  totalEntries = newEntries = 0;
-  SetText(Recording->Title('\t', true, Level));
-  if (*Text() == '\t')
-     name = strdup(Text() + 2); // 'Text() + 2' to skip the two '\t'
-}
-
-cMenuRecordingItem::~cMenuRecordingItem()
-{
-  free(name);
-}
-
-void cMenuRecordingItem::IncrementCounter(bool New)
-{
-  totalEntries++;
-  if (New)
-     newEntries++;
-  SetText(cString::sprintf("%d\t\t%d\t%s", totalEntries, newEntries, name));
-}
-
-void cMenuRecordingItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemRecording(recording, Index, Current, Selectable, level, totalEntries, newEntries))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-#ifdef USE_VASARAJANAULOJA
-// --- cMenuEditRecording ----------------------------------------------------
-
-class cMenuEditRecording : public cOsdMenu {
-private:
-  char name[MaxFileName];
-  cMenuEditStrItem *file;
-  cOsdItem *marksItem, *resumeItem;
-  bool isResume, isMarks;
-  cRecording *recording;
-  void SetHelpKeys(void);
-  eOSState SetFolder(void);
-public:
-  cMenuEditRecording(cRecording *Recording);
-  virtual eOSState ProcessKey(eKeys Key);
-};
-
-cMenuEditRecording::cMenuEditRecording(cRecording *Recording)
-:cOsdMenu(tr("Edit recording"), 14)
-{
-  cMarks marks;
-
-  file = NULL;
-  recording = Recording;
-
-  if (recording) {
-     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
-     Add(file = new cMenuEditStrItem(tr("File"), name, sizeof(name)));
-
-     Add(new cOsdItem("", osUnknown, false));
-
-     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->Start())), osUnknown, false));
-
-     cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
-     if (channel)
-        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
-
-     int recLen = recording->LengthInSeconds();
-     if (recLen >= 0)
-        Add(new cOsdItem(cString::sprintf("%s:\t%d:%02d:%02d", tr("Length"), recLen / 3600, recLen / 60 % 60, recLen % 60), osUnknown, false));
-     else
-        recLen = 0;
-
-     int dirSize = DirSizeMB(recording->FileName());
-     cString bitRate = recLen ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / recLen) : cString("");
-     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Format"), recording->IsPesRecording() ? tr("PES") : tr("TS")), osUnknown, false));
-     Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
-
-     Add(new cOsdItem("", osUnknown, false));
-
-     isMarks = marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && marks.Count();
-     marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
-     Add(marksItem);
-
-     cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
-     isResume = (ResumeFile.Read() != -1);
-     resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
-     Add(resumeItem);
-     }
-
-  SetHelpKeys();
-}
-
-void cMenuEditRecording::SetHelpKeys(void)
-{
-  SetHelp(tr("Button$Folder"), tr("Button$Cut"), tr("Button$Copy"), tr("Button$Rename/Move"));
-}
-
-eOSState cMenuEditRecording::SetFolder(void)
-{
-  cMenuFolder *mf = (cMenuFolder *)SubMenu();
-  if (mf) {
-     cString Folder = mf->GetFolder();
-     char *p = strrchr(name, FOLDERDELIMCHAR);
-     if (p)
-        p++;
-     else
-        p = name;
-     if (!isempty(*Folder))
-        strn0cpy(name, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(name));
-     else if (p != name)
-        memmove(name, p, strlen(p) + 1);
-     SetCurrent(file);
-     Display();
-     }
-  return CloseSubMenu();
-}
-
-eOSState cMenuEditRecording::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:
-            return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, name));
-            break;
-       case kGreen:
-            if (!cCutter::Active()) {
-               if (!isMarks)
-                  Skins.Message(mtError, tr("No editing marks defined!"));
-               else if (!cCutter::Start(recording->FileName(), strcmp(recording->Name(), name) ? *NewVideoFileName(recording->FileName(), name) : NULL, false))
-                  Skins.Message(mtError, tr("Can't start editing process!"));
-               else
-                  Skins.Message(mtInfo, tr("Editing process started"));
-               }
-            else
-               Skins.Message(mtError, tr("Editing process already active!"));
-            return osContinue;
-       case kYellow:
-       case kBlue:
-            if (strcmp(recording->Name(), name)) {
-               if (!cFileTransfer::Active()) {
-                  if (cFileTransfer::Start(recording, name, (Key == kYellow)))
-                     Skins.Message(mtInfo, tr("File transfer started"));
-                  else
-                     Skins.Message(mtError, tr("Can't start file transfer!"));
-                  }
-               else
-                  Skins.Message(mtError, tr("File transfer already active!"));
-               }
-            return osRecordings;
-       default:
-            break;
-       }
-     return osContinue;
-     }
-  else if (state == osEnd && HasSubMenu())
-     state = SetFolder();
-  else if (state == osUser1) {
-     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
-        cMarks marks;
-        marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording());
-        cMark *mark = marks.First();
-        while (mark) {
-              cMark *nextmark = marks.Next(mark);
-              marks.Del(mark);
-              mark = nextmark;
-              }
-        marks.Save();
-        isMarks = false;
-        marksItem->SetSelectable(isMarks);
-        SetCurrent(First());
-        Display();
-        }
-     return osContinue;
-     }
-  else if (state == osUser2) {
-     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
-        cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
-        ResumeFile.Delete();
-        isResume = false;
-        resumeItem->SetSelectable(isResume);
-        SetCurrent(First());
-        Display();
-        }
-     return osContinue;
-     }
-
-  return state;
-}
-#endif /* VASARAJANAULOJA */
-
-// --- cMenuRecordings -------------------------------------------------------
-
-cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
-:cOsdMenu(Base ? Base : tr("Recordings"), 9, 6, 6)
-{
-  SetMenuCategory(mcRecording);
-  base = Base ? strdup(Base) : NULL;
-  level = Setup.RecordingDirs ? Level : -1;
-  Recordings.StateChanged(recordingsState); // just to get the current state
-  helpKeys = -1;
-  Display(); // this keeps the higher level menus from showing up briefly when pressing 'Back' during replay
-  Set();
-  if (Current() < 0)
-     SetCurrent(First());
-  else if (OpenSubMenus && cReplayControl::LastReplayed() && Open(true))
-     return;
-  Display();
-  SetHelpKeys();
-}
-
-cMenuRecordings::~cMenuRecordings()
-{
-  helpKeys = -1;
-  free(base);
-}
-
-void cMenuRecordings::SetHelpKeys(void)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (ri) {
-     if (ri->IsDirectory())
-        NewHelpKeys = 1;
-     else {
-        NewHelpKeys = 2;
-        if (ri->Recording()->Info()->Title())
-           NewHelpKeys = 3;
-        }
-     }
-  if (NewHelpKeys != helpKeys) {
-     switch (NewHelpKeys) {
-       case 0: SetHelp(NULL); break;
-       case 1: SetHelp(tr("Button$Open")); break;
-       case 2:
-       case 3: SetHelp(RecordingCommands.Count() ? tr("Commands") : tr("Button$Play"), tr("Button$Rewind"), tr("Button$Delete"), NewHelpKeys == 3 ? tr("Button$Info") : NULL);
-       default: ;
-       }
-     helpKeys = NewHelpKeys;
-     }
-}
-
-void cMenuRecordings::Set(bool Refresh)
-{
-  const char *CurrentRecording = cReplayControl::LastReplayed();
-  cMenuRecordingItem *LastItem = NULL;
-  char *LastItemText = NULL;
-  cThreadLock RecordingsLock(&Recordings);
-  if (Refresh) {
-     if (cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current()))
-        CurrentRecording = ri->Recording()->FileName();
-     }
-  Clear();
-  GetRecordingsSortMode(DirectoryName());
-  Recordings.Sort();
-  for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
-      if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == FOLDERDELIMCHAR)) {
-         cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
-#ifdef USE_PINPLUGIN
-         if ((*Item->Text() && (!Item->IsDirectory() || (!LastItem || !LastItem->IsDirectory() || strcmp(Item->Text(), LastItemText) != 0)))
-            && (!cStatus::MsgReplayProtected(Item->Recording(), Item->Name(), base,
-                                             Item->IsDirectory(), true))) {
-#else
-         if (*Item->Text() && (!Item->IsDirectory() || (!LastItem || !LastItem->IsDirectory() || strcmp(Item->Text(), LastItemText) != 0))) {
-#endif /* PINPLUGIN */
-            Add(Item);
-            LastItem = Item;
-            free(LastItemText);
-            LastItemText = strdup(LastItem->Text()); // must use a copy because of the counters!
-            }
-         else
-            delete Item;
-         if (LastItem) {
-            if (CurrentRecording && strcmp(CurrentRecording, recording->FileName()) == 0)
-               SetCurrent(LastItem);
-            if (LastItem->IsDirectory())
-               LastItem->IncrementCounter(recording->IsNew());
-            }
-         }
-      }
-  free(LastItemText);
-  if (Refresh)
-     Display();
-}
-
-cString cMenuRecordings::DirectoryName(void)
-{
-  cString d(VideoDirectory);
-  if (base) {
-     char *s = ExchangeChars(strdup(base), true);
-     d = AddDirectory(d, s);
-     free(s);
-     }
-  return d;
-}
-
-bool cMenuRecordings::Open(bool OpenSubMenus)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && ri->IsDirectory()) {
-     const char *t = ri->Name();
-     cString buffer;
-     if (base) {
-        buffer = cString::sprintf("%s~%s", base, t);
-        t = buffer;
-        }
-     AddSubMenu(new cMenuRecordings(t, level + 1, OpenSubMenus));
-     return true;
-     }
-  return false;
-}
-
-eOSState cMenuRecordings::Play(void)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri) {
-#ifdef USE_PINPLUGIN
-     if (cStatus::MsgReplayProtected(ri->Recording(), ri->Name(), base,
-                                     ri->IsDirectory()) == true)
-        return osContinue;
-#endif /* PINPLUGIN */
-     if (ri->IsDirectory())
-        Open();
-     else {
-        cReplayControl::SetRecording(ri->Recording()->FileName());
-        return osReplay;
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Rewind(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cDevice::PrimaryDevice()->StopReplay(); // must do this first to be able to rewind the currently replayed recording
-     cResumeFile ResumeFile(ri->Recording()->FileName(), ri->Recording()->IsPesRecording());
-     ResumeFile.Delete();
-     return Play();
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Delete(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     if (Interface->Confirm(tr("Delete recording?"))) {
-        cRecordControl *rc = cRecordControls::GetRecordControl(ri->Recording()->FileName());
-        if (rc) {
-           if (Interface->Confirm(tr("Timer still recording - really delete?"))) {
-              cTimer *timer = rc->Timer();
-              if (timer) {
-                 timer->Skip();
-                 cRecordControls::Process(time(NULL));
-                 if (timer->IsSingleEvent()) {
-                    isyslog("deleting timer %s", *timer->ToDescr());
-                    Timers.Del(timer);
-                    }
-                 Timers.SetModified();
-                 }
-              }
-           else
-              return osContinue;
-           }
-        cRecording *recording = ri->Recording();
-        cString FileName = recording->FileName();
-        if (cCutter::Active(ri->Recording()->FileName())) {
-           if (Interface->Confirm(tr("Recording is being edited - really delete?"))) {
-              cCutter::Stop();
-              recording = Recordings.GetByName(FileName); // cCutter::Stop() might have deleted it if it was the edited version
-              // we continue with the code below even if recording is NULL,
-              // in order to have the menu updated etc.
-              }
-           else
-              return osContinue;
-           }
-        if (cReplayControl::NowReplaying() && strcmp(cReplayControl::NowReplaying(), FileName) == 0)
-           cControl::Shutdown();
-        if (!recording || recording->Delete()) {
-           cReplayControl::ClearLastReplayed(FileName);
-           Recordings.DelByName(FileName);
-           cOsdMenu::Del(Current());
-           SetHelpKeys();
-           cVideoDiskUsage::ForceCheck();
-           Display();
-           if (!Count())
-              return osBack;
-           }
-        else
-           Skins.Message(mtError, tr("Error while deleting recording!"));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Info(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory() && ri->Recording()->Info()->Title())
-     return AddSubMenu(new cMenuRecording(ri->Recording(), true));
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Commands(eKeys Key)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cMenuCommands *menu;
-     eOSState state = AddSubMenu(menu = new cMenuCommands(tr("Recording commands"), &RecordingCommands, cString::sprintf("\"%s\"", *strescape(ri->Recording()->FileName(), "\\\"$"))));
-     if (Key != kNone)
-        state = menu->ProcessKey(Key);
-     return state;
-     }
-  return osContinue;
-}
-
-#ifdef USE_VASARAJANAULOJA
-eOSState cMenuRecordings::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cRecording *recording = (ri->Recording());
-     if (recording)
-        return AddSubMenu(new cMenuEditRecording(recording));
-     }
-  return osContinue;
-}
-#endif /* VASARAJANAULOJA */
-
-eOSState cMenuRecordings::Sort(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  IncRecordingsSortMode(DirectoryName());
-  Set(true);
-  return osContinue;
-}
-
-eOSState cMenuRecordings::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kPlayPause:
-       case kPlay:
-       case kOk:     return Play();
-       case kRed:    return (helpKeys > 1 && RecordingCommands.Count()) ? Commands() : Play();
-       case kGreen:  return Rewind();
-       case kYellow: return Delete();
-       case kInfo:
-       case kBlue:   return Info();
-       case k0:      return Sort();
-#ifdef USE_VASARAJANAULOJA
-       case k1:      return Edit();
-       case k2...k9: return Commands(Key);
-#else
-       case k1...k9: return Commands(Key);
-#endif /* VASARAJANAULOJA */
-       case kNone:   if (Recordings.StateChanged(recordingsState))
-                        Set(true);
-                     break;
-       default: break;
-       }
-     }
-  if (Key == kYellow && HadSubMenu && !HasSubMenu()) {
-     // the last recording in a subdirectory was deleted, so let's go back up
-     cOsdMenu::Del(Current());
-     if (!Count())
-        return osBack;
-     Display();
-     }
-  if (!HasSubMenu()) {
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuSetupBase --------------------------------------------------------
-
-class cMenuSetupBase : public cMenuSetupPage {
-protected:
-  cSetup data;
-  virtual void Store(void);
-public:
-  cMenuSetupBase(void);
-  };
-
-cMenuSetupBase::cMenuSetupBase(void)
-{
-  data = Setup;
-}
-
-void cMenuSetupBase::Store(void)
-{
-  Setup = data;
-  cOsdProvider::UpdateOsdSize(true);
-  Setup.Save();
-}
-
-// --- cMenuSetupOSD ---------------------------------------------------------
-
-class cMenuSetupOSD : public cMenuSetupBase {
-private:
-  const char *useSmallFontTexts[3];
-  const char *keyColorTexts[4];
-  int osdLanguageIndex;
-  int numSkins;
-  int originalSkinIndex;
-  int skinIndex;
-  const char **skinDescriptions;
-  cThemes themes;
-  int originalThemeIndex;
-  int themeIndex;
-  cStringList fontOsdNames, fontSmlNames, fontFixNames;
-  int fontOsdIndex, fontSmlIndex, fontFixIndex;
-  virtual void Set(void);
-public:
-  cMenuSetupOSD(void);
-  virtual ~cMenuSetupOSD();
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetupOsd"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetupOSD::cMenuSetupOSD(void)
-{
-  SetMenuCategory(mcSetupOsd);
-  osdLanguageIndex = I18nCurrentLanguage();
-  numSkins = Skins.Count();
-  skinIndex = originalSkinIndex = Skins.Current()->Index();
-  skinDescriptions = new const char*[numSkins];
-  themes.Load(Skins.Current()->Name());
-  themeIndex = originalThemeIndex = Skins.Current()->Theme() ? themes.GetThemeIndex(Skins.Current()->Theme()->Description()) : 0;
-  cFont::GetAvailableFontNames(&fontOsdNames);
-  cFont::GetAvailableFontNames(&fontSmlNames);
-  cFont::GetAvailableFontNames(&fontFixNames, true);
-  fontOsdNames.Insert(strdup(DefaultFontOsd));
-  fontSmlNames.Insert(strdup(DefaultFontSml));
-  fontFixNames.Insert(strdup(DefaultFontFix));
-  fontOsdIndex = max(0, fontOsdNames.Find(Setup.FontOsd));
-  fontSmlIndex = max(0, fontSmlNames.Find(Setup.FontSml));
-  fontFixIndex = max(0, fontFixNames.Find(Setup.FontFix));
-  Set();
-}
-
-cMenuSetupOSD::~cMenuSetupOSD()
-{
-  delete[] skinDescriptions;
-}
-
-void cMenuSetupOSD::Set(void)
-{
-  int current = Current();
-  for (cSkin *Skin = Skins.First(); Skin; Skin = Skins.Next(Skin))
-      skinDescriptions[Skin->Index()] = Skin->Description();
-  useSmallFontTexts[0] = tr("never");
-  useSmallFontTexts[1] = tr("skin dependent");
-  useSmallFontTexts[2] = tr("always");
-  keyColorTexts[0] = tr("Key$Red");
-  keyColorTexts[1] = tr("Key$Green");
-  keyColorTexts[2] = tr("Key$Yellow");
-  keyColorTexts[3] = tr("Key$Blue");
-  Clear();
-  SetSection(tr("OSD"));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Language"),               &osdLanguageIndex, I18nNumLanguagesWithLocale(), &I18nLanguages()->At(0)));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
-  if (themes.NumThemes())
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Theme"),                  &themeIndex, themes.NumThemes(), themes.Descriptions()));
-#ifdef USE_WAREAGLEICON
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$WarEagle icons"),         &data.WarEagleIcons));
-#endif /* WAREAGLEICON */
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Left (%)"),               &data.OSDLeftP, 0.0, 0.5));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Top (%)"),                &data.OSDTopP, 0.0, 0.5));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Width (%)"),              &data.OSDWidthP, 0.5, 1.0));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Height (%)"),             &data.OSDHeightP, 0.5, 1.0));
-  Add(new cMenuEditIntItem( tr("Setup.OSD$Message time (s)"),       &data.OSDMessageTime, 1, 60));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Use small font"),         &data.UseSmallFont, 3, useSmallFontTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Anti-alias"),             &data.AntiAlias));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Default font"),           &fontOsdIndex, fontOsdNames.Size(), &fontOsdNames[0]));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Small font"),             &fontSmlIndex, fontSmlNames.Size(), &fontSmlNames[0]));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Fixed font"),             &fontFixIndex, fontFixNames.Size(), &fontFixNames[0]));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Default font size (%)"),  &data.FontOsdSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Small font size (%)"),    &data.FontSmlSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Fixed font size (%)"),    &data.FontFixSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Channel info position"),  &data.ChannelInfoPos, tr("bottom"), tr("top")));
-  Add(new cMenuEditIntItem( tr("Setup.OSD$Channel info time (s)"),  &data.ChannelInfoTime, 1, 60));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Info on channel switch"), &data.ShowInfoOnChSwitch));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Timeout requested channel info"), &data.TimeoutRequChInfo));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll pages"),           &data.MenuScrollPage));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll wraps"),           &data.MenuScrollWrap));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Menu key closes"),        &data.MenuKeyCloses));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Folders in timer menu"),  &data.FoldersInTimerMenu));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Number keys for characters"), &data.NumberKeysForChars));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 0"),            &data.ColorKey0, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 1"),            &data.ColorKey1, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 2"),            &data.ColorKey2, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 3"),            &data.ColorKey3, 4, keyColorTexts));
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupOSD::ProcessKey(eKeys Key)
-{
-  bool ModifiedAppearance = false;
-
-  if (Key == kOk) {
-     I18nSetLocale(data.OSDLanguage);
-     if (skinIndex != originalSkinIndex) {
-        cSkin *Skin = Skins.Get(skinIndex);
-        if (Skin) {
-           Utf8Strn0Cpy(data.OSDSkin, Skin->Name(), sizeof(data.OSDSkin));
-           Skins.SetCurrent(Skin->Name());
-           ModifiedAppearance = true;
-           }
-        }
-     if (themes.NumThemes() && Skins.Current()->Theme()) {
-        Skins.Current()->Theme()->Load(themes.FileName(themeIndex));
-        Utf8Strn0Cpy(data.OSDTheme, themes.Name(themeIndex), sizeof(data.OSDTheme));
-        ModifiedAppearance |= themeIndex != originalThemeIndex;
-        }
-     if (!(DoubleEqual(data.OSDLeftP, Setup.OSDLeftP) && DoubleEqual(data.OSDTopP, Setup.OSDTopP) && DoubleEqual(data.OSDWidthP, Setup.OSDWidthP) && DoubleEqual(data.OSDHeightP, Setup.OSDHeightP)))
-        ModifiedAppearance = true;
-     if (data.UseSmallFont != Setup.UseSmallFont || data.AntiAlias != Setup.AntiAlias)
-        ModifiedAppearance = true;
-     Utf8Strn0Cpy(data.FontOsd, fontOsdNames[fontOsdIndex], sizeof(data.FontOsd));
-     Utf8Strn0Cpy(data.FontSml, fontSmlNames[fontSmlIndex], sizeof(data.FontSml));
-     Utf8Strn0Cpy(data.FontFix, fontFixNames[fontFixIndex], sizeof(data.FontFix));
-     if (strcmp(data.FontOsd, Setup.FontOsd) || !DoubleEqual(data.FontOsdSizeP, Setup.FontOsdSizeP))
-        ModifiedAppearance = true;
-     if (strcmp(data.FontSml, Setup.FontSml) || !DoubleEqual(data.FontSmlSizeP, Setup.FontSmlSizeP))
-        ModifiedAppearance = true;
-     if (strcmp(data.FontFix, Setup.FontFix) || !DoubleEqual(data.FontFixSizeP, Setup.FontFixSizeP))
-        ModifiedAppearance = true;
-     }
-
-  int oldSkinIndex = skinIndex;
-  int oldOsdLanguageIndex = osdLanguageIndex;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (ModifiedAppearance) {
-     cOsdProvider::UpdateOsdSize(true);
-     SetDisplayMenu();
-     }
-
-  if (osdLanguageIndex != oldOsdLanguageIndex || skinIndex != oldSkinIndex) {
-     strn0cpy(data.OSDLanguage, I18nLocale(osdLanguageIndex), sizeof(data.OSDLanguage));
-     int OriginalOSDLanguage = I18nCurrentLanguage();
-     I18nSetLanguage(osdLanguageIndex);
-
-     cSkin *Skin = Skins.Get(skinIndex);
-     if (Skin) {
-        char *d = themes.NumThemes() ? strdup(themes.Descriptions()[themeIndex]) : NULL;
-        themes.Load(Skin->Name());
-        if (skinIndex != oldSkinIndex)
-           themeIndex = d ? themes.GetThemeIndex(d) : 0;
-        free(d);
-        }
-
-     Set();
-     I18nSetLanguage(OriginalOSDLanguage);
-     }
-  return state;
-}
-
-// --- cMenuSetupEPG ---------------------------------------------------------
-
-class cMenuSetupEPG : public cMenuSetupBase {
-private:
-  int originalNumLanguages;
-  int numLanguages;
-  void Setup(void);
-public:
-  cMenuSetupEPG(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetupEpg"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetupEPG::cMenuSetupEPG(void)
-{
-  SetMenuCategory(mcSetupEpg);
-  for (numLanguages = 0; numLanguages < I18nLanguages()->Size() && data.EPGLanguages[numLanguages] >= 0; numLanguages++)
-      ;
-  originalNumLanguages = numLanguages;
-  SetSection(tr("EPG"));
-  SetHelp(tr("Button$Scan"));
-  Setup();
-}
-
-void cMenuSetupEPG::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG scan timeout (h)"),      &data.EPGScanTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG bugfix level"),          &data.EPGBugfixLevel, 0, MAXEPGBUGFIXLEVEL));
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG linger time (min)"),     &data.EPGLinger, 0));
-  Add(new cMenuEditBoolItem(tr("Setup.EPG$Set system time"),           &data.SetSystemTime));
-  if (data.SetSystemTime)
-     Add(new cMenuEditTranItem(tr("Setup.EPG$Use time from transponder"), &data.TimeTransponder, &data.TimeSource));
-  // TRANSLATORS: note the plural!
-  Add(new cMenuEditIntItem( tr("Setup.EPG$Preferred languages"),       &numLanguages, 0, I18nLanguages()->Size()));
-  for (int i = 0; i < numLanguages; i++)
-      // TRANSLATORS: note the singular!
-      Add(new cMenuEditStraItem(tr("Setup.EPG$Preferred language"),    &data.EPGLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-#ifdef USE_DDEPGENTRY
-  Add(new cMenuEditIntItem(tr("Setup.EPG$Period for double EPG search(min)"), &data.DoubleEpgTimeDelta));
-  Add(new cMenuEditBoolItem(tr("Setup.EPG$extern double Epg entry"),   &data.DoubleEpgAction, "adjust", "delete"));
-  Add(new cMenuEditBoolItem(tr("Setup.EPG$Mix intern and extern EPG"), &data.MixEpgAction));
-  Add(new cMenuEditBoolItem(tr("Setup.EPG$Disable running VPS event"), &data.DisableVPS));
-#endif /* DDEPGENTRY */
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupEPG::ProcessKey(eKeys Key)
-{
-  if (Key == kOk) {
-     bool Modified = numLanguages != originalNumLanguages;
-     if (!Modified) {
-        for (int i = 0; i < numLanguages; i++) {
-            if (data.EPGLanguages[i] != ::Setup.EPGLanguages[i]) {
-               Modified = true;
-               break;
-               }
-            }
-        }
-     if (Modified)
-        cSchedules::ResetVersions();
-     }
-
-  int oldnumLanguages = numLanguages;
-  int oldSetSystemTime = data.SetSystemTime;
-
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-  if (Key != kNone) {
-     if (numLanguages != oldnumLanguages || data.SetSystemTime != oldSetSystemTime) {
-        for (int i = oldnumLanguages; i < numLanguages; i++) {
-            data.EPGLanguages[i] = 0;
-            for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                int k;
-                for (k = 0; k < oldnumLanguages; k++) {
-                    if (data.EPGLanguages[k] == l)
-                       break;
-                    }
-                if (k >= oldnumLanguages) {
-                   data.EPGLanguages[i] = l;
-                   break;
-                   }
-                }
-            }
-        data.EPGLanguages[numLanguages] = -1;
-        Setup();
-        }
-     if (Key == kRed) {
-        EITScanner.ForceScan();
-        return osEnd;
-        }
-     }
-  return state;
-}
-
-// --- cMenuSetupDVB ---------------------------------------------------------
-
-class cMenuSetupDVB : public cMenuSetupBase {
-private:
-  int originalNumAudioLanguages;
-  int numAudioLanguages;
-  int originalNumSubtitleLanguages;
-  int numSubtitleLanguages;
-  void Setup(void);
-  const char *videoDisplayFormatTexts[3];
-  const char *updateChannelsTexts[6];
-  const char *standardComplianceTexts[2];
-public:
-  cMenuSetupDVB(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetupDvb"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetupDVB::cMenuSetupDVB(void)
-{
-  SetMenuCategory(mcSetupDvb);
-  for (numAudioLanguages = 0; numAudioLanguages < I18nLanguages()->Size() && data.AudioLanguages[numAudioLanguages] >= 0; numAudioLanguages++)
-      ;
-  for (numSubtitleLanguages = 0; numSubtitleLanguages < I18nLanguages()->Size() && data.SubtitleLanguages[numSubtitleLanguages] >= 0; numSubtitleLanguages++)
-      ;
-  originalNumAudioLanguages = numAudioLanguages;
-  originalNumSubtitleLanguages = numSubtitleLanguages;
-  videoDisplayFormatTexts[0] = tr("pan&scan");
-  videoDisplayFormatTexts[1] = tr("letterbox");
-  videoDisplayFormatTexts[2] = tr("center cut out");
-  updateChannelsTexts[0] = tr("no");
-  updateChannelsTexts[1] = tr("names only");
-  updateChannelsTexts[2] = tr("PIDs only");
-  updateChannelsTexts[3] = tr("names and PIDs");
-  updateChannelsTexts[4] = tr("add new channels");
-  updateChannelsTexts[5] = tr("add new transponders");
-  standardComplianceTexts[0] = "DVB";
-  standardComplianceTexts[1] = "ANSI/SCTE";
-
-  SetSection(tr("DVB"));
-  SetHelp(NULL, tr("Button$Audio"), tr("Button$Subtitles"), NULL); 
-  Setup();
-}
-
-void cMenuSetupDVB::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditIntItem( tr("Setup.DVB$Primary DVB interface"), &data.PrimaryDVB, 1, cDevice::NumDevices()));
-  Add(new cMenuEditStraItem(tr("Setup.DVB$Standard compliance"),   &data.StandardCompliance, 2, standardComplianceTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Video format"),          &data.VideoFormat, "4:3", "16:9"));
-  if (data.VideoFormat == 0)
-     Add(new cMenuEditStraItem(tr("Setup.DVB$Video display format"), &data.VideoDisplayFormat, 3, videoDisplayFormatTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Dolby Digital"),     &data.UseDolbyDigital));
-  Add(new cMenuEditStraItem(tr("Setup.DVB$Update channels"),       &data.UpdateChannels, 6, updateChannelsTexts));
-#ifdef USE_CHANNELBIND
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$channel binding by Rid"),&data.ChannelBindingByRid));
-#endif /* CHANNELBIND */
-  Add(new cMenuEditIntItem( tr("Setup.DVB$Audio languages"),       &numAudioLanguages, 0, I18nLanguages()->Size()));
-  for (int i = 0; i < numAudioLanguages; i++)
-      Add(new cMenuEditStraItem(tr("Setup.DVB$Audio language"),    &data.AudioLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Display subtitles"),     &data.DisplaySubtitles));
-  if (data.DisplaySubtitles) {
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle languages"),    &numSubtitleLanguages, 0, I18nLanguages()->Size()));
-     for (int i = 0; i < numSubtitleLanguages; i++)
-         Add(new cMenuEditStraItem(tr("Setup.DVB$Subtitle language"), &data.SubtitleLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle offset"),                  &data.SubtitleOffset,      -100, 100));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
-     }
-#ifdef USE_TTXTSUBS
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Enable teletext support"), &data.SupportTeletext));
-#endif /* USE_TTXTSUBS */
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupDVB::ProcessKey(eKeys Key)
-{
-  int oldPrimaryDVB = ::Setup.PrimaryDVB;
-  int oldVideoDisplayFormat = ::Setup.VideoDisplayFormat;
-  bool oldVideoFormat = ::Setup.VideoFormat;
-  bool newVideoFormat = data.VideoFormat;
-  bool oldDisplaySubtitles = ::Setup.DisplaySubtitles;
-  bool newDisplaySubtitles = data.DisplaySubtitles;
-  int oldnumAudioLanguages = numAudioLanguages;
-  int oldnumSubtitleLanguages = numSubtitleLanguages;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone) {
-     switch (Key) {
-       case kGreen:  cRemote::Put(kAudio, true);
-                     state = osEnd;
-                     break;
-       case kYellow: cRemote::Put(kSubtitles, true);
-                     state = osEnd;
-                     break;
-       default: { 
-            bool DoSetup = data.VideoFormat != newVideoFormat;
-            DoSetup |= data.DisplaySubtitles != newDisplaySubtitles;
-            if (numAudioLanguages != oldnumAudioLanguages) {
-               for (int i = oldnumAudioLanguages; i < numAudioLanguages; i++) {
-                   data.AudioLanguages[i] = 0;
-                   for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                       int k;
-                       for (k = 0; k < oldnumAudioLanguages; k++) {
-                           if (data.AudioLanguages[k] == l)
-                              break;
-                           }
-                       if (k >= oldnumAudioLanguages) {
-                          data.AudioLanguages[i] = l;
-                          break;
-                          }
-                       }
-                   }
-               data.AudioLanguages[numAudioLanguages] = -1;
-               DoSetup = true;
-               }
-            if (numSubtitleLanguages != oldnumSubtitleLanguages) {
-               for (int i = oldnumSubtitleLanguages; i < numSubtitleLanguages; i++) {
-                   data.SubtitleLanguages[i] = 0;
-                   for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                       int k;
-                       for (k = 0; k < oldnumSubtitleLanguages; k++) {
-                           if (data.SubtitleLanguages[k] == l)
-                              break;
-                           }
-                       if (k >= oldnumSubtitleLanguages) {
-                          data.SubtitleLanguages[i] = l;
-                          break;
-                          }
-                       }
-                   }
-               data.SubtitleLanguages[numSubtitleLanguages] = -1;
-               DoSetup = true;
-               }
-            if (DoSetup)
-               Setup();
-            }
-       }
-     }
-  if (state == osBack && Key == kOk) {
-     if (::Setup.PrimaryDVB != oldPrimaryDVB)
-        state = osSwitchDvb;
-     if (::Setup.VideoDisplayFormat != oldVideoDisplayFormat)
-        cDevice::PrimaryDevice()->SetVideoDisplayFormat(eVideoDisplayFormat(::Setup.VideoDisplayFormat));
-     if (::Setup.VideoFormat != oldVideoFormat)
-        cDevice::PrimaryDevice()->SetVideoFormat(::Setup.VideoFormat);
-     if (::Setup.DisplaySubtitles != oldDisplaySubtitles)
-        cDevice::PrimaryDevice()->EnsureSubtitleTrack();
-     cDvbSubtitleConverter::SetupChanged();
-     }
-  return state;
-}
-
-// --- cMenuSetupLNB ---------------------------------------------------------
-
-class cMenuSetupLNB : public cMenuSetupBase {
-private:
-  cSatCableNumbers satCableNumbers;
-  void Setup(void);
-public:
-  cMenuSetupLNB(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetupLnb"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetupLNB::cMenuSetupLNB(void)
-:satCableNumbers(MAXDEVICES)
-{
-  SetMenuCategory(mcSetupLnb);
-  satCableNumbers.FromString(data.DeviceBondings);
-  SetSection(tr("LNB"));
-  Setup();
-}
-
-void cMenuSetupLNB::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditBoolItem(tr("Setup.LNB$Use DiSEqC"),               &data.DiSEqC));
-  if (!data.DiSEqC) {
-     Add(new cMenuEditIntItem( tr("Setup.LNB$SLOF (MHz)"),               &data.LnbSLOF));
-     Add(new cMenuEditIntItem( tr("Setup.LNB$Low LNB frequency (MHz)"),  &data.LnbFrequLo));
-     Add(new cMenuEditIntItem( tr("Setup.LNB$High LNB frequency (MHz)"), &data.LnbFrequHi));
-     }
-
-  int NumSatDevices = 0;
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat))
-         NumSatDevices++;
-      }
-  if (NumSatDevices > 1) {
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat))
-            Add(new cMenuEditIntItem(cString::sprintf(tr("Setup.LNB$Device %d connected to sat cable"), i + 1), &satCableNumbers.Array()[i], 0, NumSatDevices, tr("Setup.LNB$own")));
-         }
-     }
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupLNB::ProcessKey(eKeys Key)
-{
-  int oldDiSEqC = data.DiSEqC;
-  bool DeviceBondingsChanged = false;
-  if (Key == kOk) {
-     cString NewDeviceBondings = satCableNumbers.ToString();
-     DeviceBondingsChanged = strcmp(data.DeviceBondings, NewDeviceBondings) != 0;
-     data.DeviceBondings = NewDeviceBondings;
-     }
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone && data.DiSEqC != oldDiSEqC)
-     Setup();
-  else if (DeviceBondingsChanged)
-     cDvbDevice::BondDevices(data.DeviceBondings);
-  return state;
-}
-
-// --- cMenuSetupCAM ---------------------------------------------------------
-
-class cMenuSetupCAMItem : public cOsdItem {
-private:
-  cCamSlot *camSlot;
-public:
-  cMenuSetupCAMItem(cCamSlot *CamSlot);
-  cCamSlot *CamSlot(void) { return camSlot; }
-  bool Changed(void);
-  };
-
-cMenuSetupCAMItem::cMenuSetupCAMItem(cCamSlot *CamSlot)
-{
-  camSlot = CamSlot;
-  SetText("");
-  Changed();
-}
-
-bool cMenuSetupCAMItem::Changed(void)
-{
-  char buffer[32];
-  const char *CamName = camSlot->GetCamName();
-  if (!CamName) {
-     switch (camSlot->ModuleStatus()) {
-       case msReset:   CamName = tr("CAM reset"); break;
-       case msPresent: CamName = tr("CAM present"); break;
-       case msReady:   CamName = tr("CAM ready"); break;
-       default:        CamName = "-"; break;
-       }
-     }
-  snprintf(buffer, sizeof(buffer), " %d %s", camSlot->SlotNumber(), CamName);
-  if (strcmp(buffer, Text()) != 0) {
-     SetText(buffer);
-     return true;
-     }
-  return false;
-}
-
-class cMenuSetupCAM : public cMenuSetupBase {
-private:
-  eOSState Menu(void);
-  eOSState Reset(void);
-public:
-  cMenuSetupCAM(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetupCam"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetupCAM::cMenuSetupCAM(void)
-{
-  SetMenuCategory(mcSetupCam);
-  SetSection(tr("CAM"));
-  SetCols(15);
-  SetHasHotkeys();
-  for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot))
-      Add(new cMenuSetupCAMItem(CamSlot));
-  SetHelp(tr("Button$Menu"), tr("Button$Reset"));
-}
-
-eOSState cMenuSetupCAM::Menu(void)
-{
-  cMenuSetupCAMItem *item = (cMenuSetupCAMItem *)Get(Current());
-  if (item) {
-     if (item->CamSlot()->EnterMenu()) {
-        Skins.Message(mtStatus, tr("Opening CAM menu..."));
-        time_t t0 = time(NULL);
-        time_t t1 = t0;
-        while (time(NULL) - t0 <= MAXWAITFORCAMMENU) {
-              if (item->CamSlot()->HasUserIO())
-                 break;
-              if (time(NULL) - t1 >= CAMMENURETYTIMEOUT) {
-                 dsyslog("CAM %d: retrying to enter CAM menu...", item->CamSlot()->SlotNumber());
-                 item->CamSlot()->EnterMenu();
-                 t1 = time(NULL);
-                 }
-              cCondWait::SleepMs(100);
-              }
-        Skins.Message(mtStatus, NULL);
-        if (item->CamSlot()->HasUserIO())
-           return AddSubMenu(new cMenuCam(item->CamSlot()));
-        }
-     Skins.Message(mtError, tr("Can't open CAM menu!"));
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetupCAM::Reset(void)
-{
-  cMenuSetupCAMItem *item = (cMenuSetupCAMItem *)Get(Current());
-  if (item) {
-     if (!item->CamSlot()->Device() || Interface->Confirm(tr("CAM is in use - really reset?"))) {
-        if (!item->CamSlot()->Reset())
-           Skins.Message(mtError, tr("Can't reset CAM!"));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetupCAM::ProcessKey(eKeys Key)
-{
-  eOSState state = HasSubMenu() ? cMenuSetupBase::ProcessKey(Key) : cOsdMenu::ProcessKey(Key);
-
-  if (!HasSubMenu()) {
-     switch (Key) {
-       case kOk:
-       case kRed:    return Menu();
-       case kGreen:  state = Reset(); break;
-       default: break;
-       }
-     for (cMenuSetupCAMItem *ci = (cMenuSetupCAMItem *)First(); ci; ci = (cMenuSetupCAMItem *)ci->Next()) {
-         if (ci->Changed())
-            DisplayItem(ci);
-         }
-     }
-  return state;
-}
-
-// --- cMenuSetupRecord ------------------------------------------------------
-
-class cMenuSetupRecord : public cMenuSetupBase {
-private:
-  const char *pauseKeyHandlingTexts[3];
-  const char *delTimeshiftRecTexts[3];
-#ifdef USE_DVLVIDPREFER
-  void Set(void);
-  int tmpNVidPrefer,
-      tmpUseVidPrefer;
-#endif /* DVLVIDPREFER */
-public:
-  cMenuSetupRecord(void);
-#ifdef USE_DVLVIDPREFER
-  eOSState ProcessKey(eKeys key);
-#endif /* DVLVIDPREFER */
-  };
-
-cMenuSetupRecord::cMenuSetupRecord(void)
-{
-#ifdef USE_DVLVIDPREFER
-  Set();
-}
-
-eOSState cMenuSetupRecord::ProcessKey(eKeys key)
-{
-  eOSState s = cMenuSetupBase::ProcessKey(key);;
-
-  if (key != kNone) {
-    if (tmpNVidPrefer != data.nVidPrefer || tmpUseVidPrefer != data.UseVidPrefer) {
-      int cur = Current();
-
-      tmpNVidPrefer = data.nVidPrefer;
-      tmpUseVidPrefer = data.UseVidPrefer;
-
-      Clear();
-      Set();
-      SetCurrent(Get(cur));
-      Display();
-      cMenuSetupBase::ProcessKey(kNone);
-      return osContinue;
-      }
-   }
-   return s;
-}
-
-void cMenuSetupRecord::Set(void)
-{
-#endif /* DVLVIDPREFER */
-  SetMenuCategory(mcSetupRecord);
-  pauseKeyHandlingTexts[0] = tr("do not pause live video");
-  pauseKeyHandlingTexts[1] = tr("confirm pause live video");
-  pauseKeyHandlingTexts[2] = tr("pause live video");
-  delTimeshiftRecTexts[0] = tr("no");
-  delTimeshiftRecTexts[1] = tr("confirm");
-  delTimeshiftRecTexts[2] = tr("yes");
-  SetSection(tr("Recording"));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at start (min)"),     &data.MarginStart));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at stop (min)"),      &data.MarginStop));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Default priority"),          &data.DefaultPriority, 0, MAXPRIORITY));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Default lifetime (d)"),      &data.DefaultLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
-#ifdef USE_DVLVIDPREFER
-  tmpNVidPrefer = data.nVidPrefer;
-  tmpUseVidPrefer = data.UseVidPrefer;
-
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Video directory policy"),    &data.UseVidPrefer));
-  if (data.UseVidPrefer != 0) {
-     char tmp[ 64 ];
-     Add(new cMenuEditIntItem(tr("Setup.Recording$Number of video directories"), &data.nVidPrefer, 1, DVLVIDPREFER_MAX));
-     for (int zz = 0; zz < data.nVidPrefer; zz++) {
-         sprintf(tmp, tr("Setup.Recording$Video %d priority"), zz);
-         Add(new cMenuEditIntItem(tmp, &data.VidPreferPrio[ zz ], 0, 99));
-         sprintf(tmp, tr("Setup.Recording$Video %d min. free MB"), zz);
-         Add(new cMenuEditIntItem(tmp, &data.VidPreferSize[ zz ], -1, 99999));
-         }
-     }
-#endif /* DVLVIDPREFER */
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Use VPS"),                   &data.UseVps));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$VPS margin (s)"),            &data.VpsMargin, 0));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Mark instant recording"),    &data.MarkInstantRecord));
-  Add(new cMenuEditStrItem( tr("Setup.Recording$Name instant recording"),     data.NameInstantRecord, sizeof(data.NameInstantRecord)));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 0, MAXINSTANTRECTIME, tr("Setup.Recording$present event")));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZETS));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"),&data.DelTimeshiftRec, 3, delTimeshiftRecTexts));
-#ifdef USE_NALUDUMP
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Dump NALU Fill data"),       &data.DumpNaluFill));
-#endif /* USE_NALUDUMP */
-}
-
-// --- cMenuSetupReplay ------------------------------------------------------
-
-class cMenuSetupReplay : public cMenuSetupBase {
-protected:
-  virtual void Store(void);
-public:
-  cMenuSetupReplay(void);
-  };
-
-cMenuSetupReplay::cMenuSetupReplay(void)
-{
-  SetMenuCategory(mcSetupReplay);
-  SetSection(tr("Replay"));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Multi speed mode"), &data.MultiSpeedMode));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Show replay mode"), &data.ShowReplayMode));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Show remaining time"), &data.ShowRemainingTime));
-  Add(new cMenuEditIntItem( tr("Setup.Replay$Progress display time (s)"), &data.ProgressDisplayTime, 0, 60));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause replay when setting mark"), &data.PauseOnMarkSet));
-  Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
-#ifdef USE_JUMPPLAY
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"),          &data.JumpPlay));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"),          &data.PlayJump));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
-#endif /* JUMPPLAY */
-#ifdef USE_JUMPINGSECONDS
-  Add(new cMenuEditIntItem(tr("Setup.Replay$Jump Seconds"),             &data.JumpSeconds));
-  Add(new cMenuEditIntItem(tr("Setup.Replay$Jump Seconds Slow"),        &data.JumpSecondsSlow));
-  Add(new cMenuEditIntItem(tr("Setup.Recording$Jump Seconds (Repeat)"), &data.JumpSecondsRepeat));
-#endif /* USE_JUMPINGSECONDS */
-}
-
-void cMenuSetupReplay::Store(void)
-{
-  if (Setup.ResumeID != data.ResumeID)
-     Recordings.ResetResume();
-  cMenuSetupBase::Store();
-}
-
-// --- cMenuSetupMisc --------------------------------------------------------
-
-class cMenuSetupMisc : public cMenuSetupBase {
-#ifdef USE_VOLCTRL
-private:
-  const char *lrChannelGroupsTexts[3];
-  const char *lrForwardRewindTexts[3];
-  void Setup(void);
-#endif /* USE_VOLCTRL */
-public:
-  cMenuSetupMisc(void);
-#ifdef USE_VOLCTRL
-  virtual eOSState ProcessKey(eKeys Key);
-#endif /* USE_VOLCTRL */
-  };
-
-cMenuSetupMisc::cMenuSetupMisc(void)
-{
-#ifdef USE_VOLCTRL
-  lrChannelGroupsTexts[0] = tr("no");
-  lrChannelGroupsTexts[1] = tr("Setup.Miscellaneous$only in channelinfo");
-  lrChannelGroupsTexts[2] = tr("yes");
-  lrForwardRewindTexts[0] = tr("no");
-  lrForwardRewindTexts[1] = tr("Setup.Miscellaneous$only in progress display");
-  lrForwardRewindTexts[2] = tr("yes");
-#endif /* USE_VOLCTRL */
-  SetMenuCategory(mcSetupMisc);
-  SetSection(tr("Miscellaneous"));
-#ifdef USE_VOLCTRL
-  Setup();
-}
-
-eOSState cMenuSetupMisc::ProcessKey(eKeys Key)
-{
-  int newLRVolumeControl = data.LRVolumeControl;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone && data.LRVolumeControl != newLRVolumeControl)
-     Setup();
-  return state;
-}
-
-void cMenuSetupMisc::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-#endif /* USE_VOLCTRL */
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. event timeout (min)"),   &data.MinEventTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. user inactivity (min)"), &data.MinUserInactivity));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$SVDRP timeout (s)"),          &data.SVDRPTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Zap timeout (s)"),            &data.ZapTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Channel entry timeout (ms)"), &data.ChannelEntryTimeout, 0));
-  Add(new cMenuEditChanItem(tr("Setup.Miscellaneous$Initial channel"),            &data.InitialChannel, tr("Setup.Miscellaneous$as before")));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Initial volume"),             &data.InitialVolume, -1, 255, tr("Setup.Miscellaneous$as before")));
-#ifdef USE_VOLCTRL
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Volume ctrl with left/right"),     &data.LRVolumeControl));
-  if (data.LRVolumeControl) {
-     Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Channelgroups with left/right"),   &data.LRChannelGroups, 3, lrChannelGroupsTexts));
-     Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Search fwd/back with left/right"), &data.LRForwardRewind, 3, lrForwardRewindTexts));
-  }
-#endif /* USE_VOLCTRL */
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Channels wrap"),              &data.ChannelsWrap));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Show channel names with source"), &data.ShowChannelNamesWithSource));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Emergency exit"),             &data.EmergencyExit));
-#ifdef USE_LIRCSETTINGS
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat delay"),          &data.LircRepeatDelay, 0, 1000));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat freq"),           &data.LircRepeatFreq, 0, 1000));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat timeout"),        &data.LircRepeatTimeout, 0, 5000));
-#endif /* LIRCSETTINGS */
-#ifdef USE_VOLCTRL
-  SetCurrent(Get(current));
-  Display();
-#endif /* USE_VOLCTRL */
-}
-
-// --- cMenuSetupPluginItem --------------------------------------------------
-
-class cMenuSetupPluginItem : public cOsdItem {
-private:
-  int pluginIndex;
-public:
-  cMenuSetupPluginItem(const char *Name, int Index);
-  int PluginIndex(void) { return pluginIndex; }
-  };
-
-cMenuSetupPluginItem::cMenuSetupPluginItem(const char *Name, int Index)
-:cOsdItem(Name)
-{
-  pluginIndex = Index;
-}
-
-// --- cMenuSetupPlugins -----------------------------------------------------
-
-class cMenuSetupPlugins : public cMenuSetupBase {
-public:
-  cMenuSetupPlugins(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetupPlugins::cMenuSetupPlugins(void)
-{
-  SetMenuCategory(mcSetupPlugins);
-  SetSection(tr("Plugins"));
-  SetHasHotkeys();
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p)
-         Add(new cMenuSetupPluginItem(hk(cString::sprintf("%s (%s) - %s", p->Name(), p->Version(), p->Description())), i));
-      else
-         break;
-      }
-}
-
-eOSState cMenuSetupPlugins::ProcessKey(eKeys Key)
-{
-  eOSState state = HasSubMenu() ? cMenuSetupBase::ProcessKey(Key) : cOsdMenu::ProcessKey(Key);
-
-  if (Key == kOk) {
-     if (state == osUnknown) {
-        cMenuSetupPluginItem *item = (cMenuSetupPluginItem *)Get(Current());
-        if (item) {
-           cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
-           if (p) {
-              cMenuSetupPage *menu = p->SetupMenu();
-              if (menu) {
-                 menu->SetPlugin(p);
-                 return AddSubMenu(menu);
-                 }
-              Skins.Message(mtInfo, tr("This plugin has no setup parameters!"));
-              }
-           }
-        }
-     else if (state == osContinue) {
-        Store();
-        // Reinitialize OSD and skin, in case any plugin setup change has an influence on these:
-        cOsdProvider::UpdateOsdSize(true);
-        SetDisplayMenu();
-        Display();
-        }
-     }
-  return state;
-}
-
-// --- cMenuSetup ------------------------------------------------------------
-
-class cMenuSetup : public cOsdMenu {
-private:
-  virtual void Set(void);
-  eOSState Restart(void);
-public:
-  cMenuSetup(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuSetup"; }
-#endif /* GRAPHTFT */
-  };
-
-cMenuSetup::cMenuSetup(void)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcSetup);
-  Set();
-}
-
-void cMenuSetup::Set(void)
-{
-  Clear();
-  char buffer[64];
-  snprintf(buffer, sizeof(buffer), "%s - VDR %s", tr("VDR Setup"), VDRVERSION);
-  SetTitle(buffer);
-  SetHasHotkeys();
-  Add(new cOsdItem(hk(tr("OSD")),           osUser1));
-  Add(new cOsdItem(hk(tr("EPG")),           osUser2));
-  Add(new cOsdItem(hk(tr("DVB")),           osUser3));
-  Add(new cOsdItem(hk(tr("LNB")),           osUser4));
-  Add(new cOsdItem(hk(tr("CAM")),           osUser5));
-  Add(new cOsdItem(hk(tr("Recording")),     osUser6));
-  Add(new cOsdItem(hk(tr("Replay")),        osUser7));
-  Add(new cOsdItem(hk(tr("Miscellaneous")), osUser8));
-  if (cPluginManager::HasPlugins())
-  Add(new cOsdItem(hk(tr("Plugins")),       osUser9));
-  Add(new cOsdItem(hk(tr("Restart")),       osUser10));
-}
-
-eOSState cMenuSetup::Restart(void)
-{
-  if (Interface->Confirm(tr("Really restart?")) && ShutdownHandler.ConfirmRestart(true)) {
-     ShutdownHandler.Exit(1);
-     return osEnd;
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetup::ProcessKey(eKeys Key)
-{
-  int osdLanguage = I18nCurrentLanguage();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  switch (state) {
-    case osUser1: return AddSubMenu(new cMenuSetupOSD);
-    case osUser2: return AddSubMenu(new cMenuSetupEPG);
-    case osUser3: return AddSubMenu(new cMenuSetupDVB);
-    case osUser4: return AddSubMenu(new cMenuSetupLNB);
-    case osUser5: return AddSubMenu(new cMenuSetupCAM);
-    case osUser6: return AddSubMenu(new cMenuSetupRecord);
-    case osUser7: return AddSubMenu(new cMenuSetupReplay);
-    case osUser8: return AddSubMenu(new cMenuSetupMisc);
-    case osUser9: return AddSubMenu(new cMenuSetupPlugins);
-    case osUser10: return Restart();
-    default: ;
-    }
-  if (I18nCurrentLanguage() != osdLanguage) {
-     Set();
-     if (!HasSubMenu())
-        Display();
-     }
-  return state;
-}
-
-// --- cMenuPluginItem -------------------------------------------------------
-
-class cMenuPluginItem : public cOsdItem {
-private:
-  int pluginIndex;
-public:
-  cMenuPluginItem(const char *Name, int Index);
-  int PluginIndex(void) { return pluginIndex; }
-  };
-
-cMenuPluginItem::cMenuPluginItem(const char *Name, int Index)
-:cOsdItem(Name, osPlugin)
-{
-  pluginIndex = Index;
-}
-
-// --- cMenuMain -------------------------------------------------------------
-
-// TRANSLATORS: note the leading and trailing blanks!
-#define STOP_RECORDING trNOOP(" Stop recording ")
-
-cOsdObject *cMenuMain::pluginOsdObject = NULL;
-
-cMenuMain::cMenuMain(eOSState State)
-:cOsdMenu("")
-{
-#ifdef USE_SETUP
-  // Load Menu Configuration
-  cString menuXML = cString::sprintf("%s/../menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
-  if (access(menuXML, 04) == -1)
-     menuXML = cString::sprintf("%s/../menu.xml", cPlugin::ConfigDirectory());
-  subMenu.LoadXml(menuXML);
-  nrDynamicMenuEntries = 0;
-#endif /* SETUP */
-
-  SetMenuCategory(mcMain);
-  replaying = false;
-  stopReplayItem = NULL;
-  cancelEditingItem = NULL;
-#ifdef USE_VASARAJANAULOJA
-  cancelFileTransferItem = NULL;
-#endif /* VASARAJANAULOJA */
-  stopRecordingItem = NULL;
-  recordControlsState = 0;
-
-#ifdef USE_MENUORG
-  MenuOrgPatch::EnterRootMenu();
-#endif /* MENUORG */
-  Set();
-
-  // Initial submenus:
-
-#ifdef USE_MAINMENUHOOKS
-  cOsdObject *menu = NULL;
-#endif /* MAINMENUHOOKS */
-  switch (State) {
-#ifdef USE_MAINMENUHOOKS
-    case osSchedule:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
-            menu = new cMenuSchedule;
-        break;
-    case osChannels:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
-            menu = new cMenuChannels;
-        break;
-    case osTimers:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
-            menu = new cMenuTimers;
-        break;
-    case osRecordings:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
-            menu = new cMenuRecordings(NULL, 0, true);
-        break;
-    case osSetup:      menu = new cMenuSetup; break;
-    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
-#else
-    case osSchedule:   AddSubMenu(new cMenuSchedule); break;
-    case osChannels:   AddSubMenu(new cMenuChannels); break;
-    case osTimers:     AddSubMenu(new cMenuTimers); break;
-    case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
-    case osSetup:      AddSubMenu(new cMenuSetup); break;
-    case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
-#endif /* MAINMENUHOOKS */
-    default: break;
-    }
-#ifdef USE_MAINMENUHOOKS
-  if (menu)
-     if (menu->IsMenu())
-        AddSubMenu((cOsdMenu *) menu);
-#endif /* MAINMENUHOOKS */
-}
-
-cOsdObject *cMenuMain::PluginOsdObject(void)
-{
-  cOsdObject *o = pluginOsdObject;
-  pluginOsdObject = NULL;
-  return o;
-}
-
-#ifdef USE_SETUP
-void cMenuMain::Set(int current)
-#else
-void cMenuMain::Set(void)
-#endif /* SETUP */
-{
-  Clear();
-  SetTitle("VDR");
-  SetHasHotkeys();
-
-#ifdef USE_MENUORG
-  if (MenuOrgPatch::IsCustomMenuAvailable()) {
-     MenuItemDefinitions* menuItems = MenuOrgPatch::MainMenuItems();
-     for (MenuItemDefinitions::iterator i = menuItems->begin(); i != menuItems->end(); i++) {
-        cOsdItem* osdItem = NULL;
-        if ((*i)->IsCustomOsdItem()) {
-           osdItem = (*i)->CustomOsdItem();
-           if (osdItem &&  !(*i)->IsSeparatorItem())
-              osdItem->SetText(hk(osdItem->Text()));
-           }
-        else if ((*i)->IsPluginItem()) {
-           const char *item = (*i)->PluginMenuEntry();
-           if (item)
-              osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
-           }
-        if (osdItem) {
-           Add(osdItem);
-           if ((*i)->IsSelected())
-              SetCurrent(osdItem);
-           }
-        }
-     }
-  else {
-#endif /* MENUORG */
-#ifdef USE_SETUP
-  stopReplayItem = NULL;
-  cancelEditingItem = NULL;
-  stopRecordingItem = NULL;
-
-  // remember initial dynamic MenuEntries added
-  nrDynamicMenuEntries = Count();
-  for (cSubMenuNode *node = subMenu.GetMenuTree()->First(); node; node = subMenu.GetMenuTree()->Next(node)) {
-      cSubMenuNode::Type type = node->GetType();
-      if (type==cSubMenuNode::PLUGIN) {
-         const char *item = node->GetPluginMainMenuEntry();
-#ifdef USE_PINPLUGIN
-         if (item && !cStatus::MsgPluginProtected(cPluginManager::GetPlugin(node->GetPluginIndex()), true))
-#else
-         if (item)
-#endif /* PINPLUGIN */
-            Add(new cMenuPluginItem(hk(item), node->GetPluginIndex()));
-         }
-      else if (type==cSubMenuNode::MENU) {
-         cString item = cString::sprintf("%s%s", node->GetName(), *subMenu.GetMenuSuffix());
-#ifdef USE_PINPLUGIN
-         if (!cStatus::MsgMenuItemProtected(item, true))
-            Add(new cOsdItem(hk(item), osUnknown, node));
-#else
-            Add(new cOsdItem(hk(item)));
-#endif /* PINPLUGIN */
-         }
-      else if ((type==cSubMenuNode::COMMAND) || (type==cSubMenuNode::THREAD)) {
-#ifdef USE_PINPLUGIN
-         if (!cStatus::MsgMenuItemProtected(node->GetName(), true))
-            Add(new cOsdItem(hk(node->GetName()), osUnknown, node));
-#else
-            Add(new cOsdItem(hk(node->GetName())));
-#endif /* PINPLUGIN */
-         }
-      else if (type==cSubMenuNode::SYSTEM) {
-         const char *item = node->GetName();
-#ifdef USE_PINPLUGIN
-         if (cStatus::MsgMenuItemProtected(item, true))
-            ; // nothing to do ;)
-         else
-#endif /* PINPLUGIN */
-         if (strcmp(item, "Schedule") == 0)
-            Add(new cOsdItem(hk(tr("Schedule")), osSchedule));
-         else if (strcmp(item, "Channels") == 0)
-            Add(new cOsdItem(hk(tr("Channels")), osChannels));
-         else if (strcmp(item, "Timers") == 0)
-            Add(new cOsdItem(hk(tr("Timers")), osTimers));
-         else if (strcmp(item, "Recordings") == 0)
-            Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
-         else if (strcmp(item, "Setup") == 0) {
-            cString itemSetup = cString::sprintf("%s%s", tr("VDR Setup"), *subMenu.GetMenuSuffix());
-            Add(new cOsdItem(hk(itemSetup), osSetup));
-            }
-         else if (strcmp(item, "Commands") == 0 && Commands.Count() > 0) {
-            cString itemCommands = cString::sprintf("%s%s", tr("Commands"), *subMenu.GetMenuSuffix());
-            Add(new cOsdItem(hk(itemCommands), osCommands));
-            }
-         }
-     }
-  if (current >=0 && current<Count()) {
-     SetCurrent(Get(current));
-     }
-
-#else /* NO SETUP */
-
-  // Basic menu items:
-
-#ifdef USE_PINPLUGIN
-  if (!cStatus::MsgMenuItemProtected("Schedule", true))   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  if (!cStatus::MsgMenuItemProtected("Channels", true))   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  if (!cStatus::MsgMenuItemProtected("Timers", true))     Add(new cOsdItem(hk(tr("Timers")),     osTimers));
-  if (!cStatus::MsgMenuItemProtected("Recordings", true)) Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
-#else
-  Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  Add(new cOsdItem(hk(tr("Timers")),     osTimers));
-  Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
-#endif /* PINPLUGIN */
-
-  // Plugins:
-
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p) {
-#ifdef USE_PINPLUGIN
-         if (!cStatus::MsgPluginProtected(p, true)) {
-#endif /* PINPLUGIN */
-         const char *item = p->MainMenuEntry();
-         if (item)
-            Add(new cMenuPluginItem(hk(item), i));
-         }
-#ifdef USE_PINPLUGIN
-         }
-#endif /* PINPLUGIN */
-      else
-         break;
-      }
-
-  // More basic menu items:
-
-#ifdef USE_PINPLUGIN
-  if (!cStatus::MsgMenuItemProtected("Setup", true)) Add(new cOsdItem(hk(tr("VDR Setup")), osSetup));
-#else
-  Add(new cOsdItem(hk(tr("VDR Setup")),      osSetup));
-#endif /* PINPLUGIN */
-  if (Commands.Count())
-#ifdef USE_PINPLUGIN
-     if (!cStatus::MsgMenuItemProtected("Commands", true))
-#endif /* PINPLUGIN */
-     Add(new cOsdItem(hk(tr("Commands")),  osCommands));
-#endif /* SETUP */
-
-#ifdef USE_MENUORG
-  }
-#endif /* MENUORG */
-
-  Update(true);
-
-  Display();
-}
-
-bool cMenuMain::Update(bool Force)
-{
-  bool result = false;
-
-#ifdef USE_SETUP
-  cOsdItem *fMenu = NULL;
-  if (Force && subMenu.isTopMenu()) {
-     fMenu = First();
-     nrDynamicMenuEntries = 0;
-     }
-
-  if (!subMenu.isTopMenu()) {
-     SetTitle(cString::sprintf("%s  -  %s", tr("VDR"), subMenu.GetParentMenuTitel()));
-     result = true;
-     }
-#endif /* SETUP */
-
-  bool NewReplaying = cControl::Control() != NULL;
-  if (Force || NewReplaying != replaying) {
-     replaying = NewReplaying;
-     // Replay control:
-     if (replaying && !stopReplayItem)
-        // TRANSLATORS: note the leading blank!
-        Add(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay));
-     else if (stopReplayItem && !replaying) {
-        Del(stopReplayItem->Index());
-        stopReplayItem = NULL;
-        }
-     // Color buttons:
-     SetHelp(!replaying ? tr("Button$Record") : NULL, tr("Button$Audio"), replaying ? NULL : tr("Button$Pause"), replaying ? tr("Button$Stop") : cReplayControl::LastReplayed() ? tr("Button$Resume") : tr("Button$Play"));
-     result = true;
-     }
-
-  // Editing control:
-  bool CutterActive = cCutter::Active();
-  if (CutterActive && !cancelEditingItem) {
-     // TRANSLATORS: note the leading blank!
-     Add(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit));
-     result = true;
-     }
-  else if (cancelEditingItem && !CutterActive) {
-     Del(cancelEditingItem->Index());
-     cancelEditingItem = NULL;
-     result = true;
-     }
-
-#ifdef USE_VASARAJANAULOJA
-  // File transfer control:
-  bool FileTransferActive = cFileTransfer::Active();
-  if (FileTransferActive && !cancelFileTransferItem) {
-	  // TRANSLATORS: note the leading blank!
-	  Add(cancelFileTransferItem = new cOsdItem(tr(" Cancel file transfer"), osCancelTransfer));
-	  result = true;
-  }
-  else if (cancelFileTransferItem && !FileTransferActive) {
-	  Del(cancelFileTransferItem->Index());
-	  cancelFileTransferItem = NULL;
-	  result = true;
-  }
-#endif /* VASARAJANAULOJA */
-
-  // Record control:
-  if (cRecordControls::StateChanged(recordControlsState)) {
-     while (stopRecordingItem) {
-           cOsdItem *it = Next(stopRecordingItem);
-           Del(stopRecordingItem->Index());
-           stopRecordingItem = it;
-           }
-     const char *s = NULL;
-     while ((s = cRecordControls::GetInstantId(s)) != NULL) {
-           cOsdItem *item = new cOsdItem(osStopRecord);
-           item->SetText(cString::sprintf("%s%s", tr(STOP_RECORDING), s));
-           Add(item);
-           if (!stopRecordingItem)
-              stopRecordingItem = item;
-           }
-     result = true;
-     }
-
-#ifdef USE_SETUP
-  // adjust nrDynamicMenuEntries
-  if (fMenu != NULL)
-     nrDynamicMenuEntries = fMenu->Index();
-#endif /* SETUP */
-
-  return result;
-}
-
-eOSState cMenuMain::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  int osdLanguage = I18nCurrentLanguage();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-  HadSubMenu |= HasSubMenu();
-
-#ifdef USE_PINPLUGIN
-  cOsdItem* item = Get(Current());
-
-  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
-     if (cStatus::MsgMenuItemProtected(item->Text()))
-        return osContinue;
-#endif /* PINPLUGIN */
-
-#ifdef USE_MAINMENUHOOKS
-  cOsdObject *menu = NULL;
-#endif /* MAINMENUHOOKS */
-  switch (state) {
-#ifdef USE_MAINMENUHOOKS
-    case osSchedule:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
-            menu = new cMenuSchedule;
-        else
-            state = osContinue;
-        break;
-    case osChannels:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
-            menu = new cMenuChannels;
-        else
-            state = osContinue;
-        break;
-    case osTimers:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
-            menu = new cMenuTimers;
-        else
-            state = osContinue;
-        break;
-    case osRecordings:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
-            menu = new cMenuRecordings;
-        else
-            state = osContinue;
-        break;
-    case osSetup:      menu = new cMenuSetup; break;
-    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
-#else
-    case osSchedule:   return AddSubMenu(new cMenuSchedule);
-    case osChannels:   return AddSubMenu(new cMenuChannels);
-    case osTimers:     return AddSubMenu(new cMenuTimers);
-    case osRecordings: return AddSubMenu(new cMenuRecordings);
-    case osSetup:      return AddSubMenu(new cMenuSetup);
-    case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
-#endif /* MAINMENUHOOKS */
-    case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
-                          cOsdItem *item = Get(Current());
-                          if (item) {
-                             cRecordControls::Stop(item->Text() + strlen(tr(STOP_RECORDING)));
-                             return osEnd;
-                             }
-                          }
-                       break;
-    case osCancelEdit: if (Interface->Confirm(tr("Cancel editing?"))) {
-                          cCutter::Stop();
-                          return osEnd;
-                          }
-                       break;
-#ifdef USE_VASARAJANAULOJA
-    case osCancelTransfer:
-                       if (Interface->Confirm(tr("Cancel file transfer?"))) {
-                          cFileTransfer::Stop();
-                          return osEnd;
-                          }
-                       break;
-#endif
-    case osPlugin:     {
-                         cMenuPluginItem *item = (cMenuPluginItem *)Get(Current());
-                         if (item) {
-                            cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
-                            if (p) {
-#ifdef USE_PINPLUGIN
-                               if (!cStatus::MsgPluginProtected(p)) {
-#endif /* PINPLUGIN */
-                               cOsdObject *menu = p->MainMenuAction();
-                               if (menu) {
-                                  if (menu->IsMenu())
-                                     return AddSubMenu((cOsdMenu *)menu);
-                                  else {
-                                     pluginOsdObject = menu;
-                                     return osPlugin;
-                                     }
-                                  }
-#ifdef USE_PINPLUGIN
-                               }
-#endif /* PINPLUGIN */
-                               }
-                            }
-                         state = osEnd;
-                       }
-                       break;
-#ifdef USE_MENUORG
-    case osBack:       {
-                          if (MenuOrgPatch::IsCustomMenuAvailable())
-                          {
-                              bool leavingMenuSucceeded = MenuOrgPatch::LeaveSubMenu();
-                              Set();
-                              stopReplayItem = NULL;
-                              cancelEditingItem = NULL;
-                              stopRecordingItem = NULL;
-                              recordControlsState = 0;
-                              Update(true);
-                              Display();
-                              if (leavingMenuSucceeded)
-                                 return osContinue;
-                              else
-                                 return osEnd;
-                          }
-                       }
-                       break;
-    case osUser1:      {
-                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
-                             MenuOrgPatch::EnterSubMenu(Get(Current()));
-                             Set();
-                             return osContinue;
-                          }
-                       }
-                       break;
-    case osUser2:      {
-                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
-                             cOsdMenu* osdMenu = MenuOrgPatch::Execute(Get(Current()));
-                             if (osdMenu)
-                                return AddSubMenu(osdMenu);
-                             return osEnd;
-                          }
-                       }
-                       break;
-#endif /* MENUORG */
-#ifdef USE_SETUP
-    case osBack:       {
-                         int newCurrent = 0;
-                         if (subMenu.Up(&newCurrent)) {
-                            Set(newCurrent);
-                            return osContinue;
-                            }
-                         else
-                            return osEnd;
-                       }
-                       break;
-#endif /* SETUP */
-    default: switch (Key) {
-               case kRecord:
-               case kRed:    if (!HadSubMenu)
-                                state = replaying ? osContinue : osRecord;
-                             break;
-               case kGreen:  if (!HadSubMenu) {
-                                cRemote::Put(kAudio, true);
-                                state = osEnd;
-                                }
-                             break;
-               case kYellow: if (!HadSubMenu)
-                                state = replaying ? osContinue : osPause;
-                             break;
-               case kBlue:   if (!HadSubMenu)
-                                state = replaying ? osStopReplay : cReplayControl::LastReplayed() ? osReplay : osRecordings;
-                             break;
-#ifdef USE_SETUP
-               case kOk:     if (state == osUnknown) {
-                                cString buffer;
-                                int index = Current()-nrDynamicMenuEntries;
-                                cSubMenuNode *node = subMenu.GetNode(index);
-
-                                if (node != NULL) {
-                                   if (node->GetType() == cSubMenuNode::MENU) {
-#ifdef USE_PINPLUGIN
-                                      subMenu.Down(node, Current());
-#else
-                                      subMenu.Down(index);
-#endif /* PINPLUGIN */
-                                      }
-                                   else if (node->GetType() == cSubMenuNode::COMMAND) {
-                                      bool confirmed = true;
-                                      if (node->CommandConfirm()) {
-                                         buffer = cString::sprintf("%s?", node->GetName());
-                                         confirmed = Interface->Confirm(buffer);
-                                         }
-                                      if (confirmed) {
-                                         const char *Result = subMenu.ExecuteCommand(node->GetCommand());
-                                         if (Result)
-                                            return AddSubMenu(new cMenuText(node->GetName(), Result, fontFix));
-                                         return osEnd;
-                                         }
-                                      }
-                                   else if (node->GetType() == cSubMenuNode::THREAD) {
-                                      bool confirmed = true;
-                                      if (node->CommandConfirm()) {
-                                         buffer = cString::sprintf("%s?", node->GetName());
-                                         confirmed = Interface->Confirm(buffer);
-                                         }
-                                      if (confirmed) {
-                                         buffer = cString::sprintf("%s", node->GetCommand());
-                                         cExecCmdThread *execcmd = new cExecCmdThread(node->GetCommand());
-                                         if (execcmd->Start())
-                                            dsyslog("executing command '%s'", *buffer);
-                                         else
-                                            esyslog("ERROR: can't execute command '%s'", *buffer);
-                                         return osEnd;
-                                         }
-                                      }
-                                   }
-
-                                Set();
-                                return osContinue;
-                                }
-                             break;
-#endif /* SETUP */
-               default:      break;
-               }
-    }
-#ifdef USE_MAINMENUHOOKS
-  if (menu) {
-     if (menu->IsMenu())
-        return AddSubMenu((cOsdMenu *) menu);
-     pluginOsdObject = menu;
-     return osPlugin;
-  }
-#endif /* MAINMENUHOOKS */
-  if (!HasSubMenu() && Update(HadSubMenu))
-     Display();
-  if (Key != kNone) {
-     if (I18nCurrentLanguage() != osdLanguage) {
-        Set();
-        if (!HasSubMenu())
-           Display();
-        }
-     }
-  return state;
-}
-
-// --- SetTrackDescriptions --------------------------------------------------
-
-static void SetTrackDescriptions(int LiveChannel)
-{
-  cDevice::PrimaryDevice()->ClrAvailableTracks(true);
-  const cComponents *Components = NULL;
-  cSchedulesLock SchedulesLock;
-  if (LiveChannel) {
-     cChannel *Channel = Channels.GetByNumber(LiveChannel);
-     if (Channel) {
-        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-        if (Schedules) {
-           const cSchedule *Schedule = Schedules->GetSchedule(Channel);
-           if (Schedule) {
-              const cEvent *Present = Schedule->GetPresentEvent();
-              if (Present)
-                 Components = Present->Components();
-              }
-           }
-        }
-     }
-  else if (cReplayControl::NowReplaying()) {
-     cThreadLock RecordingsLock(&Recordings);
-     cRecording *Recording = Recordings.GetByName(cReplayControl::NowReplaying());
-     if (Recording)
-        Components = Recording->Info()->Components();
-     }
-  if (Components) {
-     int indexAudio = 0;
-     int indexDolby = 0;
-     int indexSubtitle = 0;
-     for (int i = 0; i < Components->NumComponents(); i++) {
-         const tComponent *p = Components->Component(i);
-         switch (p->stream) {
-           case 2: if (p->type == 0x05)
-                      cDevice::PrimaryDevice()->SetAvailableTrack(ttDolby, indexDolby++, 0, LiveChannel ? NULL : p->language, p->description);
-                   else
-                      cDevice::PrimaryDevice()->SetAvailableTrack(ttAudio, indexAudio++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           case 3: cDevice::PrimaryDevice()->SetAvailableTrack(ttSubtitle, indexSubtitle++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           case 4: cDevice::PrimaryDevice()->SetAvailableTrack(ttDolby, indexDolby++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           default: ;
-           }
-         }
-     }
-}
-
-// --- cDisplayChannel -------------------------------------------------------
-
-cDisplayChannel *cDisplayChannel::currentDisplayChannel = NULL;
-
-cDisplayChannel::cDisplayChannel(int Number, bool Switched)
-:cOsdObject(true)
-{
-  currentDisplayChannel = this;
-  group = -1;
-  withInfo = !Switched || Setup.ShowInfoOnChSwitch;
-  displayChannel = Skins.Current()->DisplayChannel(withInfo);
-  number = 0;
-  timeout = Switched || Setup.TimeoutRequChInfo;
-  channel = Channels.GetByNumber(Number);
-  lastPresent = lastFollowing = NULL;
-  if (channel) {
-     DisplayChannel();
-     DisplayInfo();
-     displayChannel->Flush();
-     }
-  lastTime.Set();
-}
-
-cDisplayChannel::cDisplayChannel(eKeys FirstKey)
-:cOsdObject(true)
-{
-  currentDisplayChannel = this;
-  group = -1;
-  number = 0;
-  timeout = true;
-  lastPresent = lastFollowing = NULL;
-  lastTime.Set();
-  withInfo = Setup.ShowInfoOnChSwitch;
-  displayChannel = Skins.Current()->DisplayChannel(withInfo);
-  channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  ProcessKey(FirstKey);
-}
-
-cDisplayChannel::~cDisplayChannel()
-{
-  delete displayChannel;
-  cStatus::MsgOsdClear();
-  currentDisplayChannel = NULL;
-}
-
-void cDisplayChannel::DisplayChannel(void)
-{
-  displayChannel->SetChannel(channel, number);
-  cStatus::MsgOsdChannel(ChannelString(channel, number));
-  lastPresent = lastFollowing = NULL;
-}
-
-void cDisplayChannel::DisplayInfo(void)
-{
-  if (withInfo && channel) {
-     cSchedulesLock SchedulesLock;
-     const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-     if (Schedules) {
-        const cSchedule *Schedule = Schedules->GetSchedule(channel);
-        if (Schedule) {
-           const cEvent *Present = Schedule->GetPresentEvent();
-           const cEvent *Following = Schedule->GetFollowingEvent();
-           if (Present != lastPresent || Following != lastFollowing) {
-              SetTrackDescriptions(channel->Number());
-              displayChannel->SetEvents(Present, Following);
-              cStatus::MsgOsdProgramme(Present ? Present->StartTime() : 0, Present ? Present->Title() : NULL, Present ? Present->ShortText() : NULL, Following ? Following->StartTime() : 0, Following ? Following->Title() : NULL, Following ? Following->ShortText() : NULL);
-              lastPresent = Present;
-              lastFollowing = Following;
-              }
-           }
-        }
-     }
-}
-
-void cDisplayChannel::Refresh(void)
-{
-  DisplayChannel();
-  displayChannel->SetEvents(NULL, NULL);
-}
-
-cChannel *cDisplayChannel::NextAvailableChannel(cChannel *Channel, int Direction)
-{
-  if (Direction) {
-     while (Channel) {
-           Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
-#ifdef USE_PINPLUGIN
-        if (cStatus::MsgChannelProtected(0, Channel) == false)
-#endif /* PINPLUGIN */
-           if (!Channel && Setup.ChannelsWrap)
-              Channel = Direction > 0 ? Channels.First() : Channels.Last();
-           if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, LIVEPRIORITY, true, true))
-              return Channel;
-           }
-     }
-  return NULL;
-}
-
-eOSState cDisplayChannel::ProcessKey(eKeys Key)
-{
-  cChannel *NewChannel = NULL;
-  if (Key != kNone)
-     lastTime.Set();
-  switch (int(Key)) {
-    case k0:
-         if (number == 0) {
-            // keep the "Toggle channels" function working
-            cRemote::Put(Key);
-            return osEnd;
-            }
-    case k1 ... k9:
-         group = -1;
-         if (number >= 0) {
-            if (number > Channels.MaxNumber())
-               number = Key - k0;
-            else
-               number = number * 10 + Key - k0;
-            channel = Channels.GetByNumber(number);
-            Refresh();
-            withInfo = false;
-            // Lets see if there can be any useful further input:
-            int n = channel ? number * 10 : 0;
-            int m = 10;
-            cChannel *ch = channel;
-            while (ch && (ch = Channels.Next(ch)) != NULL) {
-                  if (!ch->GroupSep()) {
-                     if (n <= ch->Number() && ch->Number() < n + m) {
-                        n = 0;
-                        break;
-                        }
-                     if (ch->Number() > n) {
-                        n *= 10;
-                        m *= 10;
-                        }
-                     }
-                  }
-            if (n > 0) {
-               // This channel is the only one that fits the input, so let's take it right away:
-               NewChannel = channel;
-               withInfo = true;
-               number = 0;
-               Refresh();
-               }
-            }
-         break;
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-#ifdef USE_VOLCTRL
-        if (Setup.LRVolumeControl && !Setup.LRChannelGroups) {
-          cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
-          break;
-           }
-        // else fall through
-#endif // USE_VOLCTRL
-    case kNext|k_Repeat:
-    case kNext:
-    case kPrev|k_Repeat:
-    case kPrev:
-         withInfo = false;
-         number = 0;
-         if (group < 0) {
-            cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-            if (channel)
-               group = channel->Index();
-            }
-         if (group >= 0) {
-            int SaveGroup = group;
-            if (NORMALKEY(Key) == kRight || NORMALKEY(Key) == kNext)
-               group = Channels.GetNextGroup(group) ;
-            else
-               group = Channels.GetPrevGroup(group < 1 ? 1 : group);
-            if (group < 0)
-               group = SaveGroup;
-            channel = Channels.Get(group);
-            if (channel) {
-               Refresh();
-               if (!channel->GroupSep())
-                  group = -1;
-               }
-            }
-         break;
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kChanUp|k_Repeat:
-    case kChanUp:
-    case kChanDn|k_Repeat:
-    case kChanDn: {
-         eKeys k = NORMALKEY(Key);
-         cChannel *ch = NextAvailableChannel(channel, (k == kUp || k == kChanUp) ? 1 : -1);
-         if (ch)
-            channel = ch;
-         else if (channel && channel->Number() != cDevice::CurrentChannel())
-            Key = k; // immediately switches channel when hitting the beginning/end of the channel list with k_Repeat
-         }
-         // no break here
-    case kUp|k_Release:
-    case kDown|k_Release:
-    case kChanUp|k_Release:
-    case kChanDn|k_Release:
-    case kNext|k_Release:
-    case kPrev|k_Release:
-         if (!(Key & k_Repeat) && channel && channel->Number() != cDevice::CurrentChannel())
-            NewChannel = channel;
-         withInfo = true;
-         group = -1;
-         number = 0;
-         Refresh();
-         break;
-    case kNone:
-         if (number && Setup.ChannelEntryTimeout && int(lastTime.Elapsed()) > Setup.ChannelEntryTimeout) {
-            channel = Channels.GetByNumber(number);
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            number = 0;
-            Refresh();
-            lastTime.Set();
-            }
-         break;
-    //TODO
-    //XXX case kGreen:  return osEventNow;
-    //XXX case kYellow: return osEventNext;
-    case kOk:
-         if (group >= 0) {
-            channel = Channels.Get(Channels.GetNextNormal(group));
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            group = -1;
-            Refresh();
-            }
-         else if (number > 0) {
-            channel = Channels.GetByNumber(number);
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            number = 0;
-            Refresh();
-            }
-         else
-            return osEnd;
-         break;
-    default:
-         if ((Key & (k_Repeat | k_Release)) == 0) {
-            cRemote::Put(Key);
-            return osEnd;
-            }
-    };
-  if (!timeout || lastTime.Elapsed() < (uint64_t)(Setup.ChannelInfoTime * 1000)) {
-     if (Key == kNone && !number && group < 0 && !NewChannel && channel && channel->Number() != cDevice::CurrentChannel()) {
-        // makes sure a channel switch through the SVDRP CHAN command is displayed
-        channel = Channels.GetByNumber(cDevice::CurrentChannel());
-        Refresh();
-        lastTime.Set();
-        }
-     DisplayInfo();
-     displayChannel->Flush();
-     if (NewChannel) {
-        SetTrackDescriptions(NewChannel->Number()); // to make them immediately visible in the channel display
-        Channels.SwitchTo(NewChannel->Number());
-        SetTrackDescriptions(NewChannel->Number()); // switching the channel has cleared them
-        channel = NewChannel;
-        }
-     return osContinue;
-     }
-  return osEnd;
-}
-
-// --- cDisplayVolume --------------------------------------------------------
-
-#define VOLUMETIMEOUT 1000 //ms
-#define MUTETIMEOUT   5000 //ms
-
-cDisplayVolume *cDisplayVolume::currentDisplayVolume = NULL;
-
-cDisplayVolume::cDisplayVolume(void)
-:cOsdObject(true)
-{
-  currentDisplayVolume = this;
-  timeout.Set(cDevice::PrimaryDevice()->IsMute() ? MUTETIMEOUT : VOLUMETIMEOUT);
-  displayVolume = Skins.Current()->DisplayVolume();
-  Show();
-}
-
-cDisplayVolume::~cDisplayVolume()
-{
-  delete displayVolume;
-  currentDisplayVolume = NULL;
-}
-
-void cDisplayVolume::Show(void)
-{
-  displayVolume->SetVolume(cDevice::CurrentVolume(), MAXVOLUME, cDevice::PrimaryDevice()->IsMute());
-}
-
-cDisplayVolume *cDisplayVolume::Create(void)
-{
-  if (!currentDisplayVolume)
-     new cDisplayVolume;
-  return currentDisplayVolume;
-}
-
-void cDisplayVolume::Process(eKeys Key)
-{
-  if (currentDisplayVolume)
-     currentDisplayVolume->ProcessKey(Key);
-}
-
-eOSState cDisplayVolume::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-#ifdef USE_VOLCTRL
-   case kLeft|k_Repeat:
-   case kLeft:
-   case kRight|k_Repeat:
-   case kRight:
-        if (Setup.LRVolumeControl) {
-          cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
-          break;
-           }
-        // else fall through
-#endif // USE_VOLCTRL
-    case kVolUp|k_Repeat:
-    case kVolUp:
-    case kVolDn|k_Repeat:
-    case kVolDn:
-         Show();
-         timeout.Set(VOLUMETIMEOUT);
-         break;
-    case kMute:
-         if (cDevice::PrimaryDevice()->IsMute()) {
-            Show();
-            timeout.Set(MUTETIMEOUT);
-            }
-         else
-            timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0) {
-                cRemote::Put(Key);
-                return osEnd;
-                }
-    }
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cDisplayTracks --------------------------------------------------------
-
-#define TRACKTIMEOUT 5000 //ms
-
-cDisplayTracks *cDisplayTracks::currentDisplayTracks = NULL;
-
-cDisplayTracks::cDisplayTracks(void)
-:cOsdObject(true)
-{
-  cDevice::PrimaryDevice()->EnsureAudioTrack();
-  SetTrackDescriptions(!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring() ? cDevice::CurrentChannel() : 0);
-  currentDisplayTracks = this;
-  numTracks = track = 0;
-  audioChannel = cDevice::PrimaryDevice()->GetAudioChannel();
-  eTrackType CurrentAudioTrack = cDevice::PrimaryDevice()->GetCurrentAudioTrack();
-  for (int i = ttAudioFirst; i <= ttDolbyLast; i++) {
-      const tTrackId *TrackId = cDevice::PrimaryDevice()->GetTrack(eTrackType(i));
-      if (TrackId && TrackId->id) {
-         types[numTracks] = eTrackType(i);
-         descriptions[numTracks] = strdup(*TrackId->description ? TrackId->description : *TrackId->language ? TrackId->language : *itoa(i));
-         if (i == CurrentAudioTrack)
-            track = numTracks;
-         numTracks++;
-         }
-      }
-  descriptions[numTracks] = NULL;
-  timeout.Set(TRACKTIMEOUT);
-  displayTracks = Skins.Current()->DisplayTracks(tr("Button$Audio"), numTracks, descriptions);
-  Show();
-}
-
-cDisplayTracks::~cDisplayTracks()
-{
-  delete displayTracks;
-  currentDisplayTracks = NULL;
-  for (int i = 0; i < numTracks; i++)
-      free(descriptions[i]);
-  cStatus::MsgOsdClear();
-}
-
-void cDisplayTracks::Show(void)
-{
-  int ac = IS_AUDIO_TRACK(types[track]) ? audioChannel : -1;
-  displayTracks->SetTrack(track, descriptions);
-  displayTracks->SetAudioChannel(ac);
-  displayTracks->Flush();
-  cStatus::MsgSetAudioTrack(track, descriptions);
-  cStatus::MsgSetAudioChannel(ac);
-}
-
-cDisplayTracks *cDisplayTracks::Create(void)
-{
-  if (cDevice::PrimaryDevice()->NumAudioTracks() > 0) {
-     if (!currentDisplayTracks)
-        new cDisplayTracks;
-     return currentDisplayTracks;
-     }
-  Skins.Message(mtWarning, tr("No audio available!"));
-  return NULL;
-}
-
-void cDisplayTracks::Process(eKeys Key)
-{
-  if (currentDisplayTracks)
-     currentDisplayTracks->ProcessKey(Key);
-}
-
-eOSState cDisplayTracks::ProcessKey(eKeys Key)
-{
-  int oldTrack = track;
-  int oldAudioChannel = audioChannel;
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-         if (NORMALKEY(Key) == kUp && track > 0)
-            track--;
-         else if (NORMALKEY(Key) == kDown && track < numTracks - 1)
-            track++;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight: if (IS_AUDIO_TRACK(types[track])) {
-                    static int ac[] = { 1, 0, 2 };
-                    audioChannel = ac[cDevice::PrimaryDevice()->GetAudioChannel()];
-                    if (NORMALKEY(Key) == kLeft && audioChannel > 0)
-                       audioChannel--;
-                    else if (NORMALKEY(Key) == kRight && audioChannel < 2)
-                       audioChannel++;
-                    audioChannel = ac[audioChannel];
-                    timeout.Set(TRACKTIMEOUT);
-                    }
-         break;
-    case kAudio|k_Repeat:
-    case kAudio:
-         if (++track >= numTracks)
-            track = 0;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kOk:
-         if (types[track] != cDevice::PrimaryDevice()->GetCurrentAudioTrack())
-            oldTrack = -1; // make sure we explicitly switch to that track
-         timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0)
-                return osEnd;
-    }
-  if (track != oldTrack || audioChannel != oldAudioChannel)
-     Show();
-  if (track != oldTrack) {
-     cDevice::PrimaryDevice()->SetCurrentAudioTrack(types[track]);
-     Setup.CurrentDolby = IS_DOLBY_TRACK(types[track]);
-     }
-  if (audioChannel != oldAudioChannel)
-     cDevice::PrimaryDevice()->SetAudioChannel(audioChannel);
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cDisplaySubtitleTracks ------------------------------------------------
-
-cDisplaySubtitleTracks *cDisplaySubtitleTracks::currentDisplayTracks = NULL;
-
-cDisplaySubtitleTracks::cDisplaySubtitleTracks(void)
-:cOsdObject(true)
-{
-  SetTrackDescriptions(!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring() ? cDevice::CurrentChannel() : 0);
-  currentDisplayTracks = this;
-  numTracks = track = 0;
-  types[numTracks] = ttNone;
-  descriptions[numTracks] = strdup(tr("No subtitles"));
-  numTracks++;
-  eTrackType CurrentSubtitleTrack = cDevice::PrimaryDevice()->GetCurrentSubtitleTrack();
-  for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
-      const tTrackId *TrackId = cDevice::PrimaryDevice()->GetTrack(eTrackType(i));
-      if (TrackId && TrackId->id) {
-         types[numTracks] = eTrackType(i);
-         descriptions[numTracks] = strdup(*TrackId->description ? TrackId->description : *TrackId->language ? TrackId->language : *itoa(i));
-         if (i == CurrentSubtitleTrack)
-            track = numTracks;
-         numTracks++;
-         }
-      }
-  descriptions[numTracks] = NULL;
-  timeout.Set(TRACKTIMEOUT);
-  displayTracks = Skins.Current()->DisplayTracks(tr("Button$Subtitles"), numTracks, descriptions);
-  Show();
-}
-
-cDisplaySubtitleTracks::~cDisplaySubtitleTracks()
-{
-  delete displayTracks;
-  currentDisplayTracks = NULL;
-  for (int i = 0; i < numTracks; i++)
-      free(descriptions[i]);
-  cStatus::MsgOsdClear();
-}
-
-void cDisplaySubtitleTracks::Show(void)
-{
-  displayTracks->SetTrack(track, descriptions);
-  displayTracks->Flush();
-  cStatus::MsgSetSubtitleTrack(track, descriptions);
-}
-
-cDisplaySubtitleTracks *cDisplaySubtitleTracks::Create(void)
-{
-  if (cDevice::PrimaryDevice()->NumSubtitleTracks() > 0) {
-     if (!currentDisplayTracks)
-        new cDisplaySubtitleTracks;
-     return currentDisplayTracks;
-     }
-  Skins.Message(mtWarning, tr("No subtitles available!"));
-  return NULL;
-}
-
-void cDisplaySubtitleTracks::Process(eKeys Key)
-{
-  if (currentDisplayTracks)
-     currentDisplayTracks->ProcessKey(Key);
-}
-
-eOSState cDisplaySubtitleTracks::ProcessKey(eKeys Key)
-{
-  int oldTrack = track;
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-         if (NORMALKEY(Key) == kUp && track > 0)
-            track--;
-         else if (NORMALKEY(Key) == kDown && track < numTracks - 1)
-            track++;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kSubtitles|k_Repeat:
-    case kSubtitles:
-         if (++track >= numTracks)
-            track = 0;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kOk:
-         if (types[track] != cDevice::PrimaryDevice()->GetCurrentSubtitleTrack())
-            oldTrack = -1; // make sure we explicitly switch to that track
-         timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0)
-                return osEnd;
-    }
-  if (track != oldTrack) {
-     Show();
-     cDevice::PrimaryDevice()->SetCurrentSubtitleTrack(types[track], true);
-     }
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cRecordControl --------------------------------------------------------
-
-#ifdef USE_ALTERNATECHANNEL
-cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause, cChannel *Channel)
-#else
-cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
-#endif /* ALTERNATECHANNEL */
-{
-  // Whatever happens here, the timers will be modified in some way...
-  Timers.SetModified();
-  // We're going to manipulate an event here, so we need to prevent
-  // others from modifying any EPG data:
-  cSchedulesLock SchedulesLock;
-  cSchedules::Schedules(SchedulesLock);
-
-  event = NULL;
-  fileName = NULL;
-  recorder = NULL;
-  device = Device;
-  if (!device) device = cDevice::PrimaryDevice();//XXX
-  timer = Timer;
-  if (!timer) {
-     timer = new cTimer(true, Pause);
-     Timers.Add(timer);
-     instantId = cString::sprintf(cDevice::NumDevices() > 1 ? "%s - %d" : "%s", timer->Channel()->Name(), device->CardIndex() + 1);
-     }
-  timer->SetPending(true);
-  timer->SetRecording(true);
-  event = timer->Event();
-
-  if (event || GetEvent())
-     dsyslog("Title: '%s' Subtitle: '%s'", event->Title(), event->ShortText());
-  cRecording Recording(timer, event);
-  fileName = strdup(Recording.FileName());
-
-  // crude attempt to avoid duplicate recordings:
-  if (cRecordControls::GetRecordControl(fileName)) {
-     isyslog("already recording: '%s'", fileName);
-     if (Timer) {
-        timer->SetPending(false);
-        timer->SetRecording(false);
-        timer->OnOff();
-        }
-     else {
-        Timers.Del(timer);
-        if (!cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
-           cReplayControl::SetRecording(fileName);
-        }
-     timer = NULL;
-     return;
-     }
-
-  cRecordingUserCommand::InvokeCommand(RUC_BEFORERECORDING, fileName);
-  isyslog("record %s", fileName);
-  if (MakeDirs(fileName, true)) {
-#ifdef USE_ALTERNATECHANNEL
-     const cChannel *ch = Channel ? Channel : timer->Channel();
-     if (ch)
-        recorder = new cRecorder(fileName, ch, timer->Priority());
-     if (ch && device->AttachReceiver(recorder)) {
-#else
-     const cChannel *ch = timer->Channel();
-     recorder = new cRecorder(fileName, ch, timer->Priority());
-     if (device->AttachReceiver(recorder)) {
-#endif /* ALTERNATECHANNEL */
-        Recording.WriteInfo();
-        cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
-        if (!Timer && !cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
-           cReplayControl::SetRecording(fileName);
-        Recordings.AddByName(fileName);
-        if (Timer && !Timer->IsSingleEvent()) {
-           char *Directory = strdup(fileName);
-           // going up two directory levels to get the series folder
-           if (char *p = strrchr(Directory, '/')) {
-              while (p > Directory && *--p != '/')
-                    ;
-              *p = 0;
-              if (!HasRecordingsSortMode(Directory)) {
-                 dsyslog("setting %s to be sorted by time", Directory);
-                 SetRecordingsSortMode(Directory, rsmTime);
-                 }
-              }
-           free(Directory);
-           }
-        return;
-        }
-     else
-#ifdef USE_ALTERNATECHANNEL
-        if (ch)
-        DELETENULL(recorder);
-#else
-        DELETENULL(recorder);
-#endif /* ALTERNATECHANNEL */
-     }
-  else
-     timer->SetDeferred(DEFERTIMER);
-  if (!Timer) {
-     Timers.Del(timer);
-     timer = NULL;
-     }
-}
-
-cRecordControl::~cRecordControl()
-{
-  Stop();
-  free(fileName);
-}
-
-#define INSTANT_REC_EPG_LOOKAHEAD 300 // seconds to look into the EPG data for an instant recording
-
-bool cRecordControl::GetEvent(void)
-{
-  const cChannel *channel = timer->Channel();
-  time_t Time = timer->HasFlags(tfInstant) ? timer->StartTime() + INSTANT_REC_EPG_LOOKAHEAD : timer->StartTime() + (timer->StopTime() - timer->StartTime()) / 2;
-  for (int seconds = 0; seconds <= MAXWAIT4EPGINFO; seconds++) {
-      {
-        cSchedulesLock SchedulesLock;
-        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-        if (Schedules) {
-           const cSchedule *Schedule = Schedules->GetSchedule(channel);
-           if (Schedule) {
-              event = Schedule->GetEventAround(Time);
-              if (event) {
-                 if (seconds > 0)
-                    dsyslog("got EPG info after %d seconds", seconds);
-                 return true;
-                 }
-              }
-           }
-      }
-      if (seconds == 0)
-         dsyslog("waiting for EPG info...");
-      cCondWait::SleepMs(1000);
-      }
-  dsyslog("no EPG info available");
-  return false;
-}
-
-void cRecordControl::Stop(bool ExecuteUserCommand)
-{
-  if (timer) {
-     DELETENULL(recorder);
-     timer->SetRecording(false);
-     timer = NULL;
-     cStatus::MsgRecording(device, NULL, fileName, false);
-     if (ExecuteUserCommand)
-        cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName);
-     Timers.SetModified();
-     }
-}
-
-bool cRecordControl::Process(time_t t)
-{
-  if (!recorder || !recorder->IsAttached() || !timer || !timer->Matches(t)) {
-     if (timer)
-        timer->SetPending(false);
-     return false;
-     }
-  AssertFreeDiskSpace(timer->Priority());
-  return true;
-}
-
-// --- cRecordControls -------------------------------------------------------
-
-cRecordControl *cRecordControls::RecordControls[MAXRECORDCONTROLS] = { NULL };
-int cRecordControls::state = 0;
-
-bool cRecordControls::Start(cTimer *Timer, bool Pause)
-{
-  static time_t LastNoDiskSpaceMessage = 0;
-  int FreeMB = 0;
-  if (Timer) {
-     AssertFreeDiskSpace(Timer->Priority(), !Timer->Pending());
-     Timer->SetPending(true);
-     }
-  VideoDiskSpace(&FreeMB);
-  if (FreeMB < MINFREEDISK) {
-     if (!Timer || time(NULL) - LastNoDiskSpaceMessage > NODISKSPACEDELTA) {
-        isyslog("not enough disk space to start recording%s%s", Timer ? " timer " : "", Timer ? *Timer->ToDescr() : "");
-        Skins.Message(mtWarning, tr("Not enough disk space to start recording!"));
-        LastNoDiskSpaceMessage = time(NULL);
-        }
-     return false;
-     }
-  LastNoDiskSpaceMessage = 0;
-
-  ChangeState();
-  int ch = Timer ? Timer->Channel()->Number() : cDevice::CurrentChannel();
-  cChannel *channel = Channels.GetByNumber(ch);
-
-  if (channel) {
-     int Priority = Timer ? Timer->Priority() : Pause ? Setup.PausePriority : Setup.DefaultPriority;
-     cDevice *device = cDevice::GetDevice(channel, Priority, false);
-
-#ifdef USE_ALTERNATECHANNEL
-     if (!device && channel->AlternativeChannelID().Valid()) {// check for alternatives
-        dsyslog("prepare to use alternative channel for channel %d", channel->Number());
-        channel = Channels.GetByChannelID(channel->AlternativeChannelID());
-        device = cDevice::GetDevice(channel, Priority, false);
-        if (device)
-            dsyslog("use of alternative channel %d successfully initiated", channel->Number());
-        }
-#endif /* ALTERNATECHANNEL */
-
-     if (device) {
-        dsyslog("switching device %d to channel %d", device->DeviceNumber() + 1, channel->Number());
-        if (!device->SwitchChannel(channel, false)) {
-           ShutdownHandler.RequestEmergencyExit();
-           return false;
-           }
-        if (!Timer || Timer->Matches()) {
-           for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-               if (!RecordControls[i]) {
-#ifdef USE_ALTERNATECHANNEL
-                  RecordControls[i] = new cRecordControl(device, Timer, Pause, channel);
-#else
-                  RecordControls[i] = new cRecordControl(device, Timer, Pause);
-#endif /* ALTERNATECHANNEL */
-#ifdef USE_PINPLUGIN
-                  cStatus::MsgRecordingFile(RecordControls[i]->FileName());
-#endif /* PINPLUGIN */
-                  return RecordControls[i]->Process(time(NULL));
-                  }
-               }
-           }
-        }
-     else if (!Timer || !Timer->Pending()) {
-        isyslog("no free DVB device to record channel %d!", ch);
-        Skins.Message(mtError, tr("No free DVB device to record!"));
-        }
-     }
-  else
-     esyslog("ERROR: channel %d not defined!", ch);
-  return false;
-}
-
-void cRecordControls::Stop(const char *InstantId)
-{
-  ChangeState();
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         const char *id = RecordControls[i]->InstantId();
-         if (id && strcmp(id, InstantId) == 0) {
-            cTimer *timer = RecordControls[i]->Timer();
-            RecordControls[i]->Stop();
-            if (timer) {
-               isyslog("deleting timer %s", *timer->ToDescr());
-               Timers.Del(timer);
-               Timers.SetModified();
-               }
-            break;
-            }
-         }
-      }
-}
-
-bool cRecordControls::PauseLiveVideo(void)
-{
-  Skins.Message(mtStatus, tr("Pausing live video..."));
-  cReplayControl::SetRecording(NULL); // make sure the new cRecordControl will set cReplayControl::LastReplayed()
-  if (Start(NULL, true)) {
-     cReplayControl *rc = new cReplayControl(true);
-     cControl::Launch(rc);
-     cControl::Attach();
-     Skins.Message(mtStatus, NULL);
-     return true;
-     }
-  Skins.Message(mtStatus, NULL);
-  return false;
-}
-
-const char *cRecordControls::GetInstantId(const char *LastInstantId)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (!LastInstantId && RecordControls[i]->InstantId())
-            return RecordControls[i]->InstantId();
-         if (LastInstantId && LastInstantId == RecordControls[i]->InstantId())
-            LastInstantId = NULL;
-         }
-      }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(const char *FileName)
-{
-  if (FileName) {
-     for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-         if (RecordControls[i] && strcmp(RecordControls[i]->FileName(), FileName) == 0)
-            return RecordControls[i];
-         }
-     }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(const cTimer *Timer)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i] && RecordControls[i]->Timer() == Timer)
-         return RecordControls[i];
-      }
-  return NULL;
-}
-
-void cRecordControls::Process(time_t t)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (!RecordControls[i]->Process(t)) {
-            DELETENULL(RecordControls[i]);
-            ChangeState();
-            }
-         }
-      }
-}
-
-void cRecordControls::ChannelDataModified(cChannel *Channel)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (RecordControls[i]->Timer() && RecordControls[i]->Timer()->Channel() == Channel) {
-            if (RecordControls[i]->Device()->ProvidesTransponder(Channel)) { // avoids retune on devices that don't really access the transponder
-               isyslog("stopping recording due to modification of channel %d", Channel->Number());
-               RecordControls[i]->Stop();
-               // This will restart the recording, maybe even from a different
-               // device in case conditional access has changed.
-               ChangeState();
-               }
-            }
-         }
-      }
-}
-
-bool cRecordControls::Active(void)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i])
-         return true;
-      }
-  return false;
-}
-
-void cRecordControls::Shutdown(void)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++)
-      DELETENULL(RecordControls[i]);
-  ChangeState();
-}
-
-bool cRecordControls::StateChanged(int &State)
-{
-  int NewState = state;
-  bool Result = State != NewState;
-  State = state;
-  return Result;
-}
-
-// --- cReplayControl --------------------------------------------------------
-
-#ifdef USE_VASARAJANAULOJA
-#define REPLAYCONTROLSKIPLIMIT   9    // s
-#define REPLAYCONTROLSKIPSECONDS 90   // s
-#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
-#endif /* VASARAJANAULOJA */
-
-cReplayControl *cReplayControl::currentReplayControl = NULL;
-cString cReplayControl::fileName;
-
-cReplayControl::cReplayControl(bool PauseLive)
-:cDvbPlayerControl(fileName, PauseLive)
-{
-  currentReplayControl = this;
-  displayReplay = NULL;
-  marksModified = false;
-  visible = modeOnly = shown = displayFrames = false;
-  lastCurrent = lastTotal = -1;
-  lastPlay = lastForward = false;
-  lastSpeed = -2; // an invalid value
-#ifdef USE_VASARAJANAULOJA
-  lastSkipKey = kNone;
-  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-  lastSkipTimeout.Set(0);
-#endif /* VASARAJANAULOJA */
-  timeoutShow = 0;
-  timeSearchActive = false;
-  cRecording Recording(fileName);
-  cStatus::MsgReplaying(this, Recording.Name(), Recording.FileName(), true);
-  marks.Load(fileName, Recording.FramesPerSecond(), Recording.IsPesRecording());
-  SetTrackDescriptions(false);
-  if (Setup.ProgressDisplayTime)
-     ShowTimed(Setup.ProgressDisplayTime);
-}
-
-cReplayControl::~cReplayControl()
-{
-  Hide();
-  cStatus::MsgReplaying(this, NULL, fileName, false);
-  Stop();
-  if (currentReplayControl == this)
-     currentReplayControl = NULL;
-}
-
-void cReplayControl::Stop(void)
-{
-  if (Setup.DelTimeshiftRec && *fileName) {
-     cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
-     if (rc && rc->InstantId()) {
-        if (Active()) {
-           if (Setup.DelTimeshiftRec == 2 || Interface->Confirm(tr("Delete timeshift recording?"))) {
-              cTimer *timer = rc->Timer();
-              rc->Stop(false); // don't execute user command
-              if (timer) {
-                 isyslog("deleting timer %s", *timer->ToDescr());
-                 Timers.Del(timer);
-                 Timers.SetModified();
-                 }
-              cDvbPlayerControl::Stop();
-              cRecording *recording = Recordings.GetByName(fileName);
-              if (recording) {
-                 if (recording->Delete()) {
-                    Recordings.DelByName(fileName);
-                    ClearLastReplayed(fileName);
-                    }
-                 else
-                    Skins.Message(mtError, tr("Error while deleting recording!"));
-                 }
-              return;
-              }
-           }
-        }
-     }
-  cDvbPlayerControl::Stop();
-}
-
-void cReplayControl::SetRecording(const char *FileName)
-{
-  fileName = FileName;
-}
-
-const char *cReplayControl::NowReplaying(void)
-{
-  return currentReplayControl ? *fileName : NULL;
-}
-
-const char *cReplayControl::LastReplayed(void)
-{
-  return fileName;
-}
-
-void cReplayControl::ClearLastReplayed(const char *FileName)
-{
-  if (*fileName && FileName && strcmp(fileName, FileName) == 0)
-     fileName = NULL;
-}
-
-void cReplayControl::ShowTimed(int Seconds)
-{
-  if (modeOnly)
-     Hide();
-  if (!visible) {
-     shown = ShowProgress(true);
-     timeoutShow = (shown && Seconds > 0) ? time(NULL) + Seconds : 0;
-     }
-  else if (timeoutShow && Seconds > 0)
-     timeoutShow = time(NULL) + Seconds;
-}
-
-void cReplayControl::Show(void)
-{
-  ShowTimed();
-}
-
-void cReplayControl::Hide(void)
-{
-  if (visible) {
-     delete displayReplay;
-     displayReplay = NULL;
-     SetNeedsFastResponse(false);
-     visible = false;
-     modeOnly = false;
-     lastPlay = lastForward = false;
-     lastSpeed = -2; // an invalid value
-     timeSearchActive = false;
-     timeoutShow = 0;
-     }
-  if (marksModified) {
-     marks.Save();
-     marksModified = false;
-     }
-}
-
-void cReplayControl::ShowMode(void)
-{
-  if (visible || Setup.ShowReplayMode && !cOsd::IsOpen()) {
-     bool Play, Forward;
-     int Speed;
-     if (GetReplayMode(Play, Forward, Speed) && (!visible || Play != lastPlay || Forward != lastForward || Speed != lastSpeed)) {
-        bool NormalPlay = (Play && Speed == -1);
-
-        if (!visible) {
-           if (NormalPlay)
-              return; // no need to do indicate ">" unless there was a different mode displayed before
-           visible = modeOnly = true;
-           displayReplay = Skins.Current()->DisplayReplay(modeOnly);
-           }
-
-        if (modeOnly && !timeoutShow && NormalPlay)
-           timeoutShow = time(NULL) + MODETIMEOUT;
-        displayReplay->SetMode(Play, Forward, Speed);
-        lastPlay = Play;
-        lastForward = Forward;
-        lastSpeed = Speed;
-        }
-     }
-}
-
-bool cReplayControl::ShowProgress(bool Initial)
-{
-  int Current, Total;
-
-  if (GetIndex(Current, Total) && Total > 0) {
-     if (!visible) {
-        displayReplay = Skins.Current()->DisplayReplay(modeOnly);
-        displayReplay->SetMarks(&marks);
-        SetNeedsFastResponse(true);
-        visible = true;
-        }
-     if (Initial) {
-        if (*fileName) {
-           if (cRecording *Recording = Recordings.GetByName(fileName))
-              displayReplay->SetRecording(Recording);
-           }
-        lastCurrent = lastTotal = -1;
-        }
-     if (Current != lastCurrent || Total != lastTotal) {
-        if (Setup.ShowRemainingTime || Total != lastTotal) {
-           int Index = Total;
-           if (Setup.ShowRemainingTime)
-              Index = Current - Index;
-           displayReplay->SetTotal(IndexToHMSF(Index, false, FramesPerSecond()));
-           if (!Initial)
-              displayReplay->Flush();
-           }
-        displayReplay->SetProgress(Current, Total);
-        if (!Initial)
-           displayReplay->Flush();
-        displayReplay->SetCurrent(IndexToHMSF(Current, displayFrames, FramesPerSecond()));
-        displayReplay->Flush();
-        lastCurrent = Current;
-        }
-     lastTotal = Total;
-     ShowMode();
-     return true;
-     }
-  return false;
-}
-
-void cReplayControl::TimeSearchDisplay(void)
-{
-  char buf[64];
-  // TRANSLATORS: note the trailing blank!
-  strcpy(buf, tr("Jump: "));
-  int len = strlen(buf);
-  char h10 = '0' + (timeSearchTime >> 24);
-  char h1  = '0' + ((timeSearchTime & 0x00FF0000) >> 16);
-  char m10 = '0' + ((timeSearchTime & 0x0000FF00) >> 8);
-  char m1  = '0' + (timeSearchTime & 0x000000FF);
-  char ch10 = timeSearchPos > 3 ? h10 : '-';
-  char ch1  = timeSearchPos > 2 ? h1  : '-';
-  char cm10 = timeSearchPos > 1 ? m10 : '-';
-  char cm1  = timeSearchPos > 0 ? m1  : '-';
-  sprintf(buf + len, "%c%c:%c%c", ch10, ch1, cm10, cm1);
-  displayReplay->SetJump(buf);
-}
-
-void cReplayControl::TimeSearchProcess(eKeys Key)
-{
-#define STAY_SECONDS_OFF_END 10
-  int Seconds = (timeSearchTime >> 24) * 36000 + ((timeSearchTime & 0x00FF0000) >> 16) * 3600 + ((timeSearchTime & 0x0000FF00) >> 8) * 600 + (timeSearchTime & 0x000000FF) * 60;
-  int Current = int(round(lastCurrent / FramesPerSecond()));
-  int Total = int(round(lastTotal / FramesPerSecond()));
-  switch (Key) {
-    case k0 ... k9:
-         if (timeSearchPos < 4) {
-            timeSearchTime <<= 8;
-            timeSearchTime |= Key - k0;
-            timeSearchPos++;
-            TimeSearchDisplay();
-            }
-         break;
-    case kFastRew:
-    case kLeft:
-    case kFastFwd:
-    case kRight: {
-         int dir = ((Key == kRight || Key == kFastFwd) ? 1 : -1);
-         if (dir > 0)
-            Seconds = min(Total - Current - STAY_SECONDS_OFF_END, Seconds);
-         SkipSeconds(Seconds * dir);
-         timeSearchActive = false;
-         }
-         break;
-    case kPlayPause:
-    case kPlay:
-    case kUp:
-    case kPause:
-    case kDown:
-    case kOk:
-         Seconds = min(Total - STAY_SECONDS_OFF_END, Seconds);
-         Goto(SecondsToFrames(Seconds, FramesPerSecond()), Key == kDown || Key == kPause || Key == kOk);
-         timeSearchActive = false;
-         break;
-    default:
-         if (!(Key & k_Flags)) // ignore repeat/release keys
-            timeSearchActive = false;
-         break;
-    }
-
-  if (!timeSearchActive) {
-     if (timeSearchHide)
-        Hide();
-     else
-        displayReplay->SetJump(NULL);
-     ShowMode();
-     }
-}
-
-void cReplayControl::TimeSearch(void)
-{
-  timeSearchTime = timeSearchPos = 0;
-  timeSearchHide = false;
-  if (modeOnly)
-     Hide();
-  if (!visible) {
-     Show();
-     if (visible)
-        timeSearchHide = true;
-     else
-        return;
-     }
-  timeoutShow = 0;
-  TimeSearchDisplay();
-  timeSearchActive = true;
-}
-
-void cReplayControl::MarkToggle(void)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total, true)) {
-     cMark *m = marks.Get(Current);
-     lastCurrent = -1; // triggers redisplay
-     if (m)
-        marks.Del(m);
-     else {
-        marks.Add(Current);
-        bool Play, Forward;
-        int Speed;
-#ifdef USE_JUMPPLAY
-        if (Setup.PauseOnMarkSet || GetReplayMode(Play, Forward, Speed) && !Play) {
-#else
-        if (Setup.PauseOnMarkSet || GetReplayMode(Play, Forward, Speed) && !Play)
-#endif /* JUMPPLAY */
-           Goto(Current, true);
-#ifdef USE_JUMPPLAY
-           }
-#endif /* JUMPPLAY */
-        }
-     ShowTimed(2);
-     marksModified = true;
-     }
-}
-
-void cReplayControl::MarkJump(bool Forward)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     if (marks.Count()) {
-        cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current);
-        if (m) {
-#ifdef USE_JUMPPLAY
-           bool Play2, Forward2;
-           int Speed;
-           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
-               Play2 && Forward && m->Position() < Total - SecondsToFrames(3, FramesPerSecond())) {
-              Goto(m->Position());
-              Play();
-              }
-           else {
-              Goto(m->Position(), true);
-              displayFrames = true;
-              return;
-              }
-#else
-           Goto(m->Position(), true);
-           displayFrames = true;
-           return;
-#endif /* JUMPPLAY */
-           }
-        }
-     // There are either no marks at all, or we already were at the first or last one,
-     // so jump to the very beginning or end:
-     Goto(Forward ? Total : 0, true);
-     }
-}
-
-void cReplayControl::MarkMove(bool Forward)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     cMark *m = marks.Get(Current);
-     if (m) {
-        displayFrames = true;
-        int p = SkipFrames(Forward ? 1 : -1);
-        cMark *m2;
-        if (Forward) {
-           while ((m2 = marks.Next(m)) != NULL && m2->Position() == m->Position())
-                 m = m2;
-           }
-        else {
-           while ((m2 = marks.Prev(m)) != NULL && m2->Position() == m->Position())
-                 m = m2;
-           }
-        m->SetPosition(p);
-        Goto(m->Position(), true);
-        marksModified = true;
-        }
-     }
-}
-
-void cReplayControl::EditCut(void)
-{
-  if (*fileName) {
-     Hide();
-     if (!cCutter::Active()) {
-        if (!marks.Count())
-           Skins.Message(mtError, tr("No editing marks defined!"));
-        else if (!marks.GetNumSequences())
-           Skins.Message(mtError, tr("No editing sequences defined!"));
-#ifdef USE_VASARAJANAULOJA
-		else if (!cCutter::Start(fileName, NULL, false))
-#else
-        else if (!cCutter::Start(fileName))
-#endif /* VASARAJANAULOJA */
-           Skins.Message(mtError, tr("Can't start editing process!"));
-        else
-           Skins.Message(mtInfo, tr("Editing process started"));
-        }
-     else
-        Skins.Message(mtError, tr("Editing process already active!"));
-     ShowMode();
-     }
-}
-
-void cReplayControl::EditTest(void)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     cMark *m = marks.Get(Current);
-     if (!m)
-        m = marks.GetNext(Current);
-     if (m) {
-#ifdef USE_JUMPPLAY
-        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
-#else
-        if ((m->Index() & 0x01) != 0)
-#endif /* JUMPPLAY */
-           m = marks.Next(m);
-        if (m) {
-           Goto(m->Position() - SecondsToFrames(3, FramesPerSecond()));
-           Play();
-           }
-        }
-     }
-}
-
-cOsdObject *cReplayControl::GetInfo(void)
-{
-  cRecording *Recording = Recordings.GetByName(cReplayControl::LastReplayed());
-  if (Recording)
-     return new cMenuRecording(Recording, false);
-  return NULL;
-}
-
-const cRecording *cReplayControl::GetRecording(void)
-{
-  if (const cRecording *Recording = Recordings.GetByName(LastReplayed()))
-     return Recording;
-  return NULL;
-}
-
-eOSState cReplayControl::ProcessKey(eKeys Key)
-{
-  if (!Active())
-     return osEnd;
-  if (Key == kNone)
-     marks.Update();
-  if (visible) {
-     if (timeoutShow && time(NULL) > timeoutShow) {
-        Hide();
-        ShowMode();
-        timeoutShow = 0;
-        }
-     else if (modeOnly)
-        ShowMode();
-     else
-        shown = ShowProgress(!shown) || shown;
-     }
-  bool DisplayedFrames = displayFrames;
-  displayFrames = false;
-  if (timeSearchActive && Key != kNone) {
-     TimeSearchProcess(Key);
-     return osContinue;
-     }
-  if (Key == kPlayPause) {
-     bool Play, Forward;
-     int Speed;
-     GetReplayMode(Play, Forward, Speed);
-     if (Speed >= 0)
-        Key = Play ? kPlay : kPause;
-     else
-        Key = Play ? kPause : kPlay;
-     }
-  bool DoShowMode = true;
-#ifdef USE_VOLCTRL
-  if (Setup.LRVolumeControl &&
-       (!Setup.LRForwardRewind ||
-      (Setup.LRForwardRewind == 1 && !visible))) {
-    switch (int(Key)) {
-      // Left/Right volume control
-      case kLeft|k_Repeat:
-      case kLeft:
-      case kRight|k_Repeat:
-      case kRight:
-        cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
-        return osContinue;
-        break;
-      default:
-        break;
-    }
-  }
-#endif // USE_VOLCTRL
-  switch (int(Key)) {
-    // Positioning:
-    case kPlay:
-    case kUp:      Play(); break;
-    case kPause:
-    case kDown:    Pause(); break;
-    case kFastRew|k_Release:
-    case kLeft|k_Release:
-                   if (Setup.MultiSpeedMode) break;
-    case kFastRew:
-    case kLeft:    Backward(); break;
-    case kFastFwd|k_Release:
-    case kRight|k_Release:
-                   if (Setup.MultiSpeedMode) break;
-    case kFastFwd:
-    case kRight:   Forward(); break;
-    case kRed:     TimeSearch(); break;
-#ifdef USE_JUMPINGSECONDS
-    case kGreen|k_Repeat:
-                   SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
-    case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
-    case k1|k_Repeat:
-    case k1:       SkipSeconds(-Setup.JumpSecondsSlow); break;
-    case k3|k_Repeat:
-    case k3:       SkipSeconds( Setup.JumpSecondsSlow); break;
-    case kYellow|k_Repeat:
-                   SkipSeconds(Setup.JumpSecondsRepeat); break;
-    case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
-#else
-    case kGreen|k_Repeat:
-    case kGreen:   SkipSeconds(-60); break;
-    case kYellow|k_Repeat:
-    case kYellow:  SkipSeconds( 60); break;
-#endif /* JUMPINGSECONDS */
-#ifdef USE_VASARAJANAULOJA
-#ifndef USE_JUMPINGSECONDS
-    case k1|k_Repeat:
-    case k1:       SkipSeconds(-20); break;
-    case k3|k_Repeat:
-    case k3:       SkipSeconds( 20); break;
-#endif /* JUMPINGSECONDS */
-    case kPrev|k_Repeat:
-    case kPrev:    if (lastSkipTimeout.TimedOut()) {
-                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-                      lastSkipKey = kPrev;
-                   }
-                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
-                      lastSkipSeconds /= 2;
-                      lastSkipKey = kNone;
-                   }
-                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
-                   SkipSeconds(-lastSkipSeconds); break;
-    case kNext|k_Repeat:
-    case kNext:    if (lastSkipTimeout.TimedOut()) {
-                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-                      lastSkipKey = kNext;
-                   }
-                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
-                      lastSkipSeconds /= 2;
-                      lastSkipKey = kNone;
-                   }
-                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
-                   SkipSeconds(lastSkipSeconds); break;
-#endif /* VASARAJANAULOJA */
-    case kStop:
-    case kBlue:    Hide();
-                   Stop();
-                   return osEnd;
-    default: {
-      DoShowMode = false;
-      switch (int(Key)) {
-        // Editing:
-        case kMarkToggle:      MarkToggle(); break;
-#ifndef USE_VASARAJANAULOJA
-        case kPrev|k_Repeat:
-        case kPrev:
-#endif /* VASARAJANAULOJA */
-        case kMarkJumpBack|k_Repeat:
-        case kMarkJumpBack:    MarkJump(false); break;
-#ifndef USE_VASARAJANAULOJA
-        case kNext|k_Repeat:
-        case kNext:
-#endif /* VASARAJANAULOJA */
-        case kMarkJumpForward|k_Repeat:
-        case kMarkJumpForward: MarkJump(true); break;
-        case kMarkMoveBack|k_Repeat:
-        case kMarkMoveBack:    MarkMove(false); break;
-        case kMarkMoveForward|k_Repeat:
-        case kMarkMoveForward: MarkMove(true); break;
-        case kEditCut:         EditCut(); break;
-        case kEditTest:        EditTest(); break;
-        default: {
-          displayFrames = DisplayedFrames;
-          switch (Key) {
-            // Menu control:
-            case kOk:      if (visible && !modeOnly) {
-                              Hide();
-                              DoShowMode = true;
-                              }
-                           else
-                              Show();
-                           break;
-            case kBack:    if (Setup.DelTimeshiftRec) { 
-                              cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
-                              return rc && rc->InstantId() ? osEnd : osRecordings;
-                              }
-                           return osRecordings;
-            default:       return osUnknown;
-            }
-          }
-        }
-      }
-    }
-  if (DoShowMode)
-     ShowMode();
-  return osContinue;
-}
diff -urN vdr-1.7.35.org/menu.h vdr-1.7.35/menu.h
--- vdr-1.7.35.org/menu.h	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/menu.h	2013-01-04 17:05:47.508804957 +0100
@@ -18,6 +18,18 @@
 #include "menuitems.h"
 #include "recorder.h"
 #include "skins.h"
+
+class cMenuEditSrcItem : public cMenuEditIntItem {
+private:
+  const cSource *source;
+protected:
+  virtual void Set(void);
+public:
+  cMenuEditSrcItem(const char *Name, int *Value);
+  eOSState ProcessKey(eKeys Key);
+  };
+
+
 #ifdef USE_SETUP
 #include "submenu.h"
 #endif /* SETUP */
@@ -108,7 +120,23 @@
 #endif /* GRAPHTFT */
   };
 
+struct MenuMainHook_Data_V1_0 {
+  eOSState  Function;    /*IN*/
+  cOsdMenu *pResultMenu; /*OUT*/
+};
+#define CREATE_MENU_MAIN(function,menu) {                              \
+  MenuMainHook_Data_V1_0 data;                                         \
+  memset(&data, 0, sizeof(data));                                      \
+  data.Function = function;                                            \
+  if (!cPluginManager::CallFirstService("MenuMainHook-V1.0", &data))   \
+    menu = new cMenuMain(function);                                    \
+  else                                                                 \
+    menu = data.pResultMenu;                                           \
+}
+
 class cMenuMain : public cOsdMenu {
+protected:
+  cMenuMain(const char *Title):cOsdMenu(Title){}; // Allow custom constructor
 private:
 #ifdef USE_SETUP
   int    nrDynamicMenuEntries;
diff -urN vdr-1.7.35.org/menu.h.orig vdr-1.7.35/menu.h.orig
--- vdr-1.7.35.org/menu.h.orig	2013-01-04 17:05:25.560805612 +0100
+++ vdr-1.7.35/menu.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,338 +0,0 @@
-/*
- * menu.h: The actual menu implementations
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: menu.h 2.13 2012/12/07 13:44:13 kls Exp $
- */
-
-#ifndef __MENU_H
-#define __MENU_H
-
-#include "ci.h"
-#include "device.h"
-#include "epg.h"
-#include "osdbase.h"
-#include "dvbplayer.h"
-#include "menuitems.h"
-#include "recorder.h"
-#include "skins.h"
-#ifdef USE_SETUP
-#include "submenu.h"
-#endif /* SETUP */
-
-class cMenuText : public cOsdMenu {
-private:
-  char *text;
-  eDvbFont font;
-public:
-  cMenuText(const char *Title, const char *Text, eDvbFont Font = fontOsd);
-  virtual ~cMenuText();
-  void SetText(const char *Text);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuFolder : public cOsdMenu {
-private:
-  cNestedItemList *nestedItemList;
-  cList<cNestedItem> *list;
-  cString dir;
-  cOsdItem *firstFolder;
-  bool editing;
-  void SetHelpKeys(void);
-  void Set(const char *CurrentFolder = NULL);
-  void DescendPath(const char *Path);
-  eOSState SetFolder(void);
-  eOSState Select(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  eOSState Edit(void);
-  cMenuFolder(const char *Title, cList<cNestedItem> *List, cNestedItemList *NestedItemList, const char *Dir, const char *Path = NULL);
-public:
-  cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path = NULL);
-  cString GetFolder(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuText"; }
-#endif /* GRAPHTFT */
-  };
-
-class cMenuCommands : public cOsdMenu {
-private:
-  cList<cNestedItem> *commands;
-  cString parameters;
-  cString title;
-  cString command;
-  bool confirm;
-  char *result;
-  bool Parse(const char *s);
-  eOSState Execute(void);
-public:
-  cMenuCommands(const char *Title, cList<cNestedItem> *Commands, const char *Parameters = NULL);
-  virtual ~cMenuCommands();
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cMenuEditTimer : public cOsdMenu {
-private:
-  cTimer *timer;
-  cTimer data;
-  int channel;
-  bool addIfConfirmed;
-  cMenuEditStrItem *file;
-  cMenuEditDateItem *day;
-  cMenuEditDateItem *firstday;
-  eOSState SetFolder(void);
-  void SetFirstDayItem(void);
-  void SetHelpKeys(void);
-public:
-  cMenuEditTimer(cTimer *Timer, bool New = false);
-  virtual ~cMenuEditTimer();
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuTimerEdit"; }
-#endif /* GRAPHTFT */
-  };
-
-class cMenuEvent : public cOsdMenu {
-private:
-  const cEvent *event;
-public:
-  cMenuEvent(const cEvent *Event, bool CanSwitch = false, bool Buttons = false);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuEvent"; }
-#endif /* GRAPHTFT */
-  };
-
-class cMenuMain : public cOsdMenu {
-private:
-#ifdef USE_SETUP
-  int    nrDynamicMenuEntries;
-#endif /* SETUP */
-  bool replaying;
-  cOsdItem *stopReplayItem;
-  cOsdItem *cancelEditingItem;
-#ifdef USE_VASARAJANAULOJA
-  cOsdItem *cancelFileTransferItem;
-#endif /* VASARAJANAULOJA */
-  cOsdItem *stopRecordingItem;
-  int recordControlsState;
-  static cOsdObject *pluginOsdObject;
-#ifdef USE_SETUP
-  void Set(int current=0);
-  bool Update(bool Force = false);
-  cSubMenu subMenu;
-#else
-  void Set(void);
-  bool Update(bool Force = false);
-#endif /* SETUP */
-public:
-  cMenuMain(eOSState State = osUnknown);
-  virtual eOSState ProcessKey(eKeys Key);
-  static cOsdObject *PluginOsdObject(void);
-#ifdef USE_GRAPHTFT
-  virtual const char* MenuKind() { return "MenuMain"; }
-#endif /* GRAPHTFT */
-  };
-
-class cDisplayChannel : public cOsdObject {
-private:
-  cSkinDisplayChannel *displayChannel;
-  int group;
-  bool withInfo;
-  cTimeMs lastTime;
-  int number;
-  bool timeout;
-  cChannel *channel;
-  const cEvent *lastPresent;
-  const cEvent *lastFollowing;
-  static cDisplayChannel *currentDisplayChannel;
-  void DisplayChannel(void);
-  void DisplayInfo(void);
-  void Refresh(void);
-  cChannel *NextAvailableChannel(cChannel *Channel, int Direction);
-public:
-  cDisplayChannel(int Number, bool Switched);
-  cDisplayChannel(eKeys FirstKey);
-  virtual ~cDisplayChannel();
-  virtual eOSState ProcessKey(eKeys Key);
-  static bool IsOpen(void) { return currentDisplayChannel != NULL; }
-  };
-
-class cDisplayVolume : public cOsdObject {
-private:
-  cSkinDisplayVolume *displayVolume;
-  cTimeMs timeout;
-  static cDisplayVolume *currentDisplayVolume;
-  virtual void Show(void);
-  cDisplayVolume(void);
-public:
-  virtual ~cDisplayVolume();
-  static cDisplayVolume *Create(void);
-  static void Process(eKeys Key);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-class cDisplayTracks : public cOsdObject {
-private:
-  cSkinDisplayTracks *displayTracks;
-  cTimeMs timeout;
-  eTrackType types[ttMaxTrackTypes];
-  char *descriptions[ttMaxTrackTypes + 1]; // list is NULL terminated
-  int numTracks, track, audioChannel;
-  static cDisplayTracks *currentDisplayTracks;
-  virtual void Show(void);
-  cDisplayTracks(void);
-public:
-  virtual ~cDisplayTracks();
-  static bool IsOpen(void) { return currentDisplayTracks != NULL; }
-  static cDisplayTracks *Create(void);
-  static void Process(eKeys Key);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-class cDisplaySubtitleTracks : public cOsdObject {
-private:
-  cSkinDisplayTracks *displayTracks;
-  cTimeMs timeout;
-  eTrackType types[ttMaxTrackTypes];
-  char *descriptions[ttMaxTrackTypes + 1]; // list is NULL terminated
-  int numTracks, track;
-  static cDisplaySubtitleTracks *currentDisplayTracks;
-  virtual void Show(void);
-  cDisplaySubtitleTracks(void);
-public:
-  virtual ~cDisplaySubtitleTracks();
-  static bool IsOpen(void) { return currentDisplayTracks != NULL; }
-  static cDisplaySubtitleTracks *Create(void);
-  static void Process(eKeys Key);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cOsdObject *CamControl(void);
-bool CamMenuActive(void);
-
-class cMenuRecordingItem;
-
-class cMenuRecordings : public cOsdMenu {
-private:
-  char *base;
-  int level;
-  int recordingsState;
-  int helpKeys;
-  void SetHelpKeys(void);
-  void Set(bool Refresh = false);
-  bool Open(bool OpenSubMenus = false);
-  eOSState Play(void);
-  eOSState Rewind(void);
-  eOSState Delete(void);
-  eOSState Info(void);
-  eOSState Sort(void);
-  eOSState Commands(eKeys Key = kNone);
-#ifdef USE_VASARAJANAULOJA
-  eOSState Edit(void);
-#endif /* VASARAJANAULOJA */
-protected:
-  cString DirectoryName(void);
-public:
-  cMenuRecordings(const char *Base = NULL, int Level = 0, bool OpenSubMenus = false);
-  ~cMenuRecordings();
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-class cRecordControl {
-private:
-  cDevice *device;
-  cTimer *timer;
-  cRecorder *recorder;
-  const cEvent *event;
-  cString instantId;
-  char *fileName;
-  bool GetEvent(void);
-public:
-#ifdef USE_ALTERNATECHANNEL
-  cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false, cChannel *Channel = NULL);
-#else
-  cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false);
-#endif /* ALTERNATECHANNEL */
-  virtual ~cRecordControl();
-  bool Process(time_t t);
-  cDevice *Device(void) { return device; }
-  void Stop(bool ExecuteUserCommand = true);
-  const char *InstantId(void) { return instantId; }
-  const char *FileName(void) { return fileName; }
-  cTimer *Timer(void) { return timer; }
-  };
-
-class cRecordControls {
-private:
-  static cRecordControl *RecordControls[];
-  static int state;
-public:
-  static bool Start(cTimer *Timer = NULL, bool Pause = false);
-  static void Stop(const char *InstantId);
-  static bool PauseLiveVideo(void);
-  static const char *GetInstantId(const char *LastInstantId);
-  static cRecordControl *GetRecordControl(const char *FileName);
-  static cRecordControl *GetRecordControl(const cTimer *Timer);
-         ///< Returns the cRecordControl for the given Timer.
-         ///< If there is no cRecordControl for Timer, NULL is returned.
-  static void Process(time_t t);
-  static void ChannelDataModified(cChannel *Channel);
-  static bool Active(void);
-  static void Shutdown(void);
-  static void ChangeState(void) { state++; }
-  static bool StateChanged(int &State);
-  };
-
-class cReplayControl : public cDvbPlayerControl {
-private:
-  cSkinDisplayReplay *displayReplay;
-  cMarks marks;
-  bool marksModified;
-  bool visible, modeOnly, shown, displayFrames;
-  int lastCurrent, lastTotal;
-  bool lastPlay, lastForward;
-  int lastSpeed;
-#ifdef USE_VASARAJANAULOJA
-  int lastSkipSeconds;
-  eKeys lastSkipKey;
-  cTimeMs lastSkipTimeout;
-#endif /* VASARAJANAULOJA */
-  time_t timeoutShow;
-  bool timeSearchActive, timeSearchHide;
-  int timeSearchTime, timeSearchPos;
-  void TimeSearchDisplay(void);
-  void TimeSearchProcess(eKeys Key);
-  void TimeSearch(void);
-  void ShowTimed(int Seconds = 0);
-  static cReplayControl *currentReplayControl;
-  static cString fileName;
-  void ShowMode(void);
-  bool ShowProgress(bool Initial);
-  void MarkToggle(void);
-  void MarkJump(bool Forward);
-  void MarkMove(bool Forward);
-  void EditCut(void);
-  void EditTest(void);
-public:
-  cReplayControl(bool PauseLive = false);
-  virtual ~cReplayControl();
-  void Stop(void);
-  virtual cOsdObject *GetInfo(void);
-  virtual const cRecording *GetRecording(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual void Show(void);
-  virtual void Hide(void);
-  bool Visible(void) { return visible; }
-  static void SetRecording(const char *FileName);
-  static const char *NowReplaying(void);
-  static const char *LastReplayed(void);
-  static void ClearLastReplayed(const char *FileName);
-  };
-
-#endif //__MENU_H
diff -urN vdr-1.7.35.org/osdbase.h vdr-1.7.35/osdbase.h
--- vdr-1.7.35.org/osdbase.h	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/osdbase.h	2013-01-04 17:05:47.508804957 +0100
@@ -40,6 +40,10 @@
                 osSwitchDvb,
                 osBack,
                 osEnd,
+                osBouquets,
+                osActiveBouquet,
+                osFavourites,
+                osAddFavourite,
                 os_User, // the following values can be used locally
                 osUser1,
                 osUser2,
diff -urN vdr-1.7.35.org/po/it_IT.po vdr-1.7.35/po/it_IT.po
--- vdr-1.7.35.org/po/it_IT.po	2013-01-04 17:05:25.564805612 +0100
+++ vdr-1.7.35/po/it_IT.po	2013-01-04 17:05:47.508804957 +0100
@@ -25,6 +25,9 @@
 
 msgid "*** Invalid Channel ***"
 msgstr "*** Canale NON valido ***"
+ 
+msgid "File already exists - overwrite?"
+msgstr ""
 
 msgid "Channel not available!"
 msgstr "Canale non disponibile!"
@@ -489,6 +492,15 @@
 msgid "Key$Commands"
 msgstr "Comandi"
 
+msgid "Key$Greater"
+msgstr ""
+
+msgid "Key$Less"
+msgstr ""
+
+msgid "Key$2digit"
+msgstr ""
+
 msgid "Key$User0"
 msgstr "Utente0"
 
@@ -751,6 +763,9 @@
 
 msgid "Button$Rewind"
 msgstr "Riavvolgi"
+ 
+msgid "Edit recording"
+msgstr ""
 
 msgid "Date"
 msgstr ""
@@ -1323,6 +1338,10 @@
 msgid " Cancel editing"
 msgstr " Annulla modifiche"
 
+#. TRANSLATORS: note the leading blank!
+msgid " Cancel file transfer"
+msgstr ""
+
 msgid "Stop recording?"
 msgstr "Fermare la registrazione?"
 
@@ -1411,6 +1430,9 @@
 msgid "Editing - shut down anyway?"
 msgstr "Modifica in corso - spegnere comunque?"
 
+msgid "Transfering file - shut down anyway?"
+msgstr ""
+
 msgid "Recording - shut down anyway?"
 msgstr "Registrazione in corso - spegnere comunque?"
 
@@ -1515,6 +1537,12 @@
 msgid "Editing process finished"
 msgstr "Processo di modifica terminato"
 
+msgid "File transfer failed!"
+msgstr ""
+
+msgid "File transfer finished"
+msgstr ""
+
 msgid "Press any key to cancel restart"
 msgstr "Premi un tasto per annullare il riavvio"
 
diff -urN vdr-1.7.35.org/svdrp.c.orig vdr-1.7.35/svdrp.c.orig
--- vdr-1.7.35.org/svdrp.c.orig	2013-01-04 17:05:25.568805611 +0100
+++ vdr-1.7.35/svdrp.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1819 +0,0 @@
-/*
- * svdrp.c: Simple Video Disk Recorder Protocol
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * The "Simple Video Disk Recorder Protocol" (SVDRP) was inspired
- * by the "Simple Mail Transfer Protocol" (SMTP) and is fully ASCII
- * text based. Therefore you can simply 'telnet' to your VDR port
- * and interact with the Video Disk Recorder - or write a full featured
- * graphical interface that sits on top of an SVDRP connection.
- *
- * $Id: svdrp.c 2.21 2012/12/04 12:08:36 kls Exp $
- */
-
-#include "svdrp.h"
-#include <arpa/inet.h>
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <netinet/in.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/socket.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include "channels.h"
-#include "config.h"
-#include "cutter.h"
-#include "device.h"
-#include "eitscan.h"
-#ifdef USE_VASARAJANAULOJA
-#include "filetransfer.h"
-#endif /* VASARAJANAULOJA */
-#include "keys.h"
-#include "menu.h"
-#include "plugin.h"
-#include "remote.h"
-#include "skins.h"
-#include "timers.h"
-#include "tools.h"
-#include "videodir.h"
-
-// --- cSocket ---------------------------------------------------------------
-
-cSocket::cSocket(int Port, int Queue)
-{
-  port = Port;
-  sock = -1;
-  queue = Queue;
-}
-
-cSocket::~cSocket()
-{
-  Close();
-}
-
-void cSocket::Close(void)
-{
-  if (sock >= 0) {
-     close(sock);
-     sock = -1;
-     }
-}
-
-bool cSocket::Open(void)
-{
-  if (sock < 0) {
-     // create socket:
-     sock = socket(PF_INET, SOCK_STREAM, 0);
-     if (sock < 0) {
-        LOG_ERROR;
-        port = 0;
-        return false;
-        }
-     // allow it to always reuse the same port:
-     int ReUseAddr = 1;
-     setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &ReUseAddr, sizeof(ReUseAddr));
-     //
-     struct sockaddr_in name;
-     name.sin_family = AF_INET;
-     name.sin_port = htons(port);
-     name.sin_addr.s_addr = SVDRPhosts.LocalhostOnly() ? htonl(INADDR_LOOPBACK) : htonl(INADDR_ANY);
-     if (bind(sock, (struct sockaddr *)&name, sizeof(name)) < 0) {
-        LOG_ERROR;
-        Close();
-        return false;
-        }
-     // make it non-blocking:
-     int oldflags = fcntl(sock, F_GETFL, 0);
-     if (oldflags < 0) {
-        LOG_ERROR;
-        return false;
-        }
-     oldflags |= O_NONBLOCK;
-     if (fcntl(sock, F_SETFL, oldflags) < 0) {
-        LOG_ERROR;
-        return false;
-        }
-     // listen to the socket:
-     if (listen(sock, queue) < 0) {
-        LOG_ERROR;
-        return false;
-        }
-     }
-  return true;
-}
-
-int cSocket::Accept(void)
-{
-  if (Open()) {
-     struct sockaddr_in clientname;
-     uint size = sizeof(clientname);
-     int newsock = accept(sock, (struct sockaddr *)&clientname, &size);
-     if (newsock > 0) {
-        bool accepted = SVDRPhosts.Acceptable(clientname.sin_addr.s_addr);
-        if (!accepted) {
-           const char *s = "Access denied!\n";
-           if (write(newsock, s, strlen(s)) < 0)
-              LOG_ERROR;
-           close(newsock);
-           newsock = -1;
-           }
-        isyslog("connect from %s, port %hu - %s", inet_ntoa(clientname.sin_addr), ntohs(clientname.sin_port), accepted ? "accepted" : "DENIED");
-        }
-     else if (errno != EINTR && errno != EAGAIN)
-        LOG_ERROR;
-     return newsock;
-     }
-  return -1;
-}
-
-// --- cPUTEhandler ----------------------------------------------------------
-
-cPUTEhandler::cPUTEhandler(void)
-{
-  if ((f = tmpfile()) != NULL) {
-     status = 354;
-     message = "Enter EPG data, end with \".\" on a line by itself";
-     }
-  else {
-     LOG_ERROR;
-     status = 554;
-     message = "Error while opening temporary file";
-     }
-}
-
-cPUTEhandler::~cPUTEhandler()
-{
-  if (f)
-     fclose(f);
-}
-
-bool cPUTEhandler::Process(const char *s)
-{
-  if (f) {
-     if (strcmp(s, ".") != 0) {
-        fputs(s, f);
-        fputc('\n', f);
-        return true;
-        }
-     else {
-        rewind(f);
-        if (cSchedules::Read(f)) {
-           cSchedules::Cleanup(true);
-           status = 250;
-           message = "EPG data processed";
-           }
-        else {
-           status = 451;
-           message = "Error while processing EPG data";
-           }
-        fclose(f);
-        f = NULL;
-        }
-     }
-  return false;
-}
-
-// --- cSVDRP ----------------------------------------------------------------
-
-#define MAXHELPTOPIC 10
-#define EITDISABLETIME 10 // seconds until EIT processing is enabled again after a CLRE command
-                          // adjust the help for CLRE accordingly if changing this!
-
-const char *HelpPages[] = {
-  "CHAN [ + | - | <number> | <name> | <id> ]\n"
-  "    Switch channel up, down or to the given channel number, name or id.\n"
-  "    Without option (or after successfully switching to the channel)\n"
-  "    it returns the current channel number and name.",
-  "CLRE [ <number> | <name> | <id> ]\n"
-  "    Clear the EPG list of the given channel number, name or id.\n"
-  "    Without option it clears the entire EPG list.\n"
-  "    After a CLRE command, no further EPG processing is done for 10\n"
-  "    seconds, so that data sent with subsequent PUTE commands doesn't\n"
-  "    interfere with data from the broadcasters.",
-#ifdef USE_VASARAJANAULOJA
-  "CPYR <number> <new name>\n"
-  "    Copy the recording with the given number. Before a recording can be\n"
-  "    copied, an LSTR command must have been executed in order to retrieve\n"
-  "    the recording numbers. The numbers don't change during subsequent CPYR\n"
-  "    commands.",
-#endif /* VASARAJANAULOJA */
-  "DELC <number>\n"
-  "    Delete channel.",
-  "DELR <number>\n"
-  "    Delete the recording with the given number. Before a recording can be\n"
-  "    deleted, an LSTR command must have been executed in order to retrieve\n"
-  "    the recording numbers. The numbers don't change during subsequent DELR\n"
-  "    commands. CAUTION: THERE IS NO CONFIRMATION PROMPT WHEN DELETING A\n"
-  "    RECORDING - BE SURE YOU KNOW WHAT YOU ARE DOING!",
-  "DELT <number>\n"
-  "    Delete timer.",
-  "EDIT <number>\n"
-  "    Edit the recording with the given number. Before a recording can be\n"
-  "    edited, an LSTR command must have been executed in order to retrieve\n"
-  "    the recording numbers.",
-  "GRAB <filename> [ <quality> [ <sizex> <sizey> ] ]\n"
-  "    Grab the current frame and save it to the given file. Images can\n"
-  "    be stored as JPEG or PNM, depending on the given file name extension.\n"
-  "    The quality of the grabbed image can be in the range 0..100, where 100\n"
-  "    (the default) means \"best\" (only applies to JPEG). The size parameters\n"
-  "    define the size of the resulting image (default is full screen).\n"
-  "    If the file name is just an extension (.jpg, .jpeg or .pnm) the image\n"
-  "    data will be sent to the SVDRP connection encoded in base64. The same\n"
-  "    happens if '-' (a minus sign) is given as file name, in which case the\n"
-  "    image format defaults to JPEG.",
-  "HELP [ <topic> ]\n"
-  "    The HELP command gives help info.",
-  "HITK [ <key> ... ]\n"
-  "    Hit the given remote control key. Without option a list of all\n"
-  "    valid key names is given. If more than one key is given, they are\n"
-  "    entered into the remote control queue in the given sequence. There\n"
-  "    can be up to 31 keys.",
-  "LSTC [ :groups | <number> | <name> | <id> ]\n"
-  "    List channels. Without option, all channels are listed. Otherwise\n"
-  "    only the given channel is listed. If a name is given, all channels\n"
-  "    containing the given string as part of their name are listed.\n"
-  "    If ':groups' is given, all channels are listed including group\n"
-  "    separators. The channel number of a group separator is always 0.",
-  "LSTE [ <channel> ] [ now | next | at <time> ]\n"
-  "    List EPG data. Without any parameters all data of all channels is\n"
-  "    listed. If a channel is given (either by number or by channel ID),\n"
-  "    only data for that channel is listed. 'now', 'next', or 'at <time>'\n"
-  "    restricts the returned data to present events, following events, or\n"
-  "    events at the given time (which must be in time_t form).",
-  "LSTR [ <number> ]\n"
-  "    List recordings. Without option, all recordings are listed. Otherwise\n"
-  "    the information for the given recording is listed.",
-  "LSTT [ <number> ] [ id ]\n"
-  "    List timers. Without option, all timers are listed. Otherwise\n"
-  "    only the given timer is listed. If the keyword 'id' is given, the\n"
-  "    channels will be listed with their unique channel ids instead of\n"
-  "    their numbers.",
-  "MESG <message>\n"
-  "    Displays the given message on the OSD. The message will be queued\n"
-  "    and displayed whenever this is suitable.\n",
-  "MODC <number> <settings>\n"
-  "    Modify a channel. Settings must be in the same format as returned\n"
-  "    by the LSTC command.",
-  "MODT <number> on | off | <settings>\n"
-  "    Modify a timer. Settings must be in the same format as returned\n"
-  "    by the LSTT command. The special keywords 'on' and 'off' can be\n"
-  "    used to easily activate or deactivate a timer.",
-  "MOVC <number> <to>\n"
-  "    Move a channel to a new position.",
-#ifdef USE_VASARAJANAULOJA
-  "MOVR <number> <new name>\n"
-  "    Move the recording with the given number. Before a recording can be\n"
-  "    moved, an LSTR command must have been executed in order to retrieve\n"
-  "    the recording numbers. The numbers don't change during subsequent MOVR\n"
-  "    commands.",
-#endif /* VASARAJANAULOJA */
-  "NEWC <settings>\n"
-  "    Create a new channel. Settings must be in the same format as returned\n"
-  "    by the LSTC command.",
-  "NEWT <settings>\n"
-  "    Create a new timer. Settings must be in the same format as returned\n"
-  "    by the LSTT command. It is an error if a timer with the same channel,\n"
-  "    day, start and stop time already exists.",
-  "NEXT [ abs | rel ]\n"
-  "    Show the next timer event. If no option is given, the output will be\n"
-  "    in human readable form. With option 'abs' the absolute time of the next\n"
-  "    event will be given as the number of seconds since the epoch (time_t\n"
-  "    format), while with option 'rel' the relative time will be given as the\n"
-  "    number of seconds from now until the event. If the absolute time given\n"
-  "    is smaller than the current time, or if the relative time is less than\n"
-  "    zero, this means that the timer is currently recording and has started\n"
-  "    at the given time. The first value in the resulting line is the number\n"
-  "    of the timer.",
-  "PLAY <number> [ begin | <position> ]\n"
-  "    Play the recording with the given number. Before a recording can be\n"
-  "    played, an LSTR command must have been executed in order to retrieve\n"
-  "    the recording numbers.\n"
-  "    The keyword 'begin' plays the recording from its very beginning, while\n"
-  "    a <position> (given as hh:mm:ss[.ff] or framenumber) starts at that\n"
-  "    position. If neither 'begin' nor a <position> are given, replay is resumed\n"
-  "    at the position where any previous replay was stopped, or from the beginning\n"
-  "    by default. To control or stop the replay session, use the usual remote\n"
-  "    control keypresses via the HITK command.",
-  "PLUG <name> [ help | main ] [ <command> [ <options> ]]\n"
-  "    Send a command to a plugin.\n"
-  "    The PLUG command without any parameters lists all plugins.\n"
-  "    If only a name is given, all commands known to that plugin are listed.\n"
-  "    If a command is given (optionally followed by parameters), that command\n"
-  "    is sent to the plugin, and the result will be displayed.\n"
-  "    The keyword 'help' lists all the SVDRP commands known to the named plugin.\n"
-  "    If 'help' is followed by a command, the detailed help for that command is\n"
-  "    given. The keyword 'main' initiates a call to the main menu function of the\n"
-  "    given plugin.\n",
-  "PUTE [ file ]\n"
-  "    Put data into the EPG list. The data entered has to strictly follow the\n"
-  "    format defined in vdr(5) for the 'epg.data' file.  A '.' on a line\n"
-  "    by itself terminates the input and starts processing of the data (all\n"
-  "    entered data is buffered until the terminating '.' is seen).\n"
-  "    If a file name is given, epg data will be read from this file (which\n"
-  "    must be accessible under the given name from the machine VDR is running\n"
-  "    on). In case of file input, no terminating '.' shall be given.\n",
-  "REMO [ on | off ]\n"
-  "    Turns the remote control on or off. Without a parameter, the current\n"
-  "    status of the remote control is reported.",
-  "SCAN\n"
-  "    Forces an EPG scan. If this is a single DVB device system, the scan\n"
-  "    will be done on the primary device unless it is currently recording.",
-  "STAT disk\n"
-  "    Return information about disk usage (total, free, percent).",
-  "UPDT <settings>\n"
-  "    Updates a timer. Settings must be in the same format as returned\n"
-  "    by the LSTT command. If a timer with the same channel, day, start\n"
-  "    and stop time does not yet exists, it will be created.",
-  "UPDR\n"
-  "    Initiates a re-read of the recordings directory, which is the SVDRP\n"
-  "    equivalent to 'touch .update'.",
-  "VOLU [ <number> | + | - | mute ]\n"
-  "    Set the audio volume to the given number (which is limited to the range\n"
-  "    0...255). If the special options '+' or '-' are given, the volume will\n"
-  "    be turned up or down, respectively. The option 'mute' will toggle the\n"
-  "    audio muting. If no option is given, the current audio volume level will\n"
-  "    be returned.",
-  "QUIT\n"
-  "    Exit vdr (SVDRP).\n"
-  "    You can also hit Ctrl-D to exit.",
-  NULL
-  };
-
-/* SVDRP Reply Codes:
-
- 214 Help message
- 215 EPG or recording data record
- 216 Image grab data (base 64)
- 220 VDR service ready
- 221 VDR service closing transmission channel
- 250 Requested VDR action okay, completed
- 354 Start sending EPG data
- 451 Requested action aborted: local error in processing
- 500 Syntax error, command unrecognized
- 501 Syntax error in parameters or arguments
- 502 Command not implemented
- 504 Command parameter not implemented
- 550 Requested action not taken
- 554 Transaction failed
- 900 Default plugin reply code
- 901..999 Plugin specific reply codes
-
-*/
-
-const char *GetHelpTopic(const char *HelpPage)
-{
-  static char topic[MAXHELPTOPIC];
-  const char *q = HelpPage;
-  while (*q) {
-        if (isspace(*q)) {
-           uint n = q - HelpPage;
-           if (n >= sizeof(topic))
-              n = sizeof(topic) - 1;
-           strncpy(topic, HelpPage, n);
-           topic[n] = 0;
-           return topic;
-           }
-        q++;
-        }
-  return NULL;
-}
-
-const char *GetHelpPage(const char *Cmd, const char **p)
-{
-  if (p) {
-     while (*p) {
-           const char *t = GetHelpTopic(*p);
-           if (strcasecmp(Cmd, t) == 0)
-              return *p;
-           p++;
-           }
-     }
-  return NULL;
-}
-
-char *cSVDRP::grabImageDir = NULL;
-
-cSVDRP::cSVDRP(int Port)
-:socket(Port)
-{
-  PUTEhandler = NULL;
-  numChars = 0;
-  length = BUFSIZ;
-  cmdLine = MALLOC(char, length);
-  lastActivity = 0;
-  isyslog("SVDRP listening on port %d", Port);
-}
-
-cSVDRP::~cSVDRP()
-{
-  Close(true);
-  free(cmdLine);
-}
-
-void cSVDRP::Close(bool SendReply, bool Timeout)
-{
-  if (file.IsOpen()) {
-     if (SendReply) {
-        //TODO how can we get the *full* hostname?
-        char buffer[BUFSIZ];
-        gethostname(buffer, sizeof(buffer));
-        Reply(221, "%s closing connection%s", buffer, Timeout ? " (timeout)" : "");
-        }
-     isyslog("closing SVDRP connection"); //TODO store IP#???
-     file.Close();
-     DELETENULL(PUTEhandler);
-     }
-}
-
-bool cSVDRP::Send(const char *s, int length)
-{
-  if (length < 0)
-     length = strlen(s);
-  if (safe_write(file, s, length) < 0) {
-     LOG_ERROR;
-     Close();
-     return false;
-     }
-  return true;
-}
-
-void cSVDRP::Reply(int Code, const char *fmt, ...)
-{
-  if (file.IsOpen()) {
-     if (Code != 0) {
-        va_list ap;
-        va_start(ap, fmt);
-        cString buffer = cString::vsprintf(fmt, ap);
-        va_end(ap);
-        const char *s = buffer;
-        while (s && *s) {
-              const char *n = strchr(s, '\n');
-              char cont = ' ';
-              if (Code < 0 || n && *(n + 1)) // trailing newlines don't count!
-                 cont = '-';
-              char number[16];
-              sprintf(number, "%03d%c", abs(Code), cont);
-              if (!(Send(number) && Send(s, n ? n - s : -1) && Send("\r\n")))
-                 break;
-              s = n ? n + 1 : NULL;
-              }
-        }
-     else {
-        Reply(451, "Zero return code - looks like a programming error!");
-        esyslog("SVDRP: zero return code!");
-        }
-     }
-}
-
-void cSVDRP::PrintHelpTopics(const char **hp)
-{
-  int NumPages = 0;
-  if (hp) {
-     while (*hp) {
-           NumPages++;
-           hp++;
-           }
-     hp -= NumPages;
-     }
-  const int TopicsPerLine = 5;
-  int x = 0;
-  for (int y = 0; (y * TopicsPerLine + x) < NumPages; y++) {
-      char buffer[TopicsPerLine * MAXHELPTOPIC + 5];
-      char *q = buffer;
-      q += sprintf(q, "    ");
-      for (x = 0; x < TopicsPerLine && (y * TopicsPerLine + x) < NumPages; x++) {
-          const char *topic = GetHelpTopic(hp[(y * TopicsPerLine + x)]);
-          if (topic)
-             q += sprintf(q, "%*s", -MAXHELPTOPIC, topic);
-          }
-      x = 0;
-      Reply(-214, "%s", buffer);
-      }
-}
-
-void cSVDRP::CmdCHAN(const char *Option)
-{
-  if (*Option) {
-     int n = -1;
-     int d = 0;
-     if (isnumber(Option)) {
-        int o = strtol(Option, NULL, 10);
-        if (o >= 1 && o <= Channels.MaxNumber())
-           n = o;
-        }
-     else if (strcmp(Option, "-") == 0) {
-        n = cDevice::CurrentChannel();
-        if (n > 1) {
-           n--;
-           d = -1;
-           }
-        }
-     else if (strcmp(Option, "+") == 0) {
-        n = cDevice::CurrentChannel();
-        if (n < Channels.MaxNumber()) {
-           n++;
-           d = 1;
-           }
-        }
-     else {
-        cChannel *channel = Channels.GetByChannelID(tChannelID::FromString(Option));
-        if (channel)
-           n = channel->Number();
-        else {
-           for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
-               if (!channel->GroupSep()) {
-                  if (strcasecmp(channel->Name(), Option) == 0) {
-                     n = channel->Number();
-                     break;
-                     }
-                  }
-               }
-           }
-        }
-     if (n < 0) {
-        Reply(501, "Undefined channel \"%s\"", Option);
-        return;
-        }
-     if (!d) {
-        cChannel *channel = Channels.GetByNumber(n);
-        if (channel) {
-           if (!cDevice::PrimaryDevice()->SwitchChannel(channel, true)) {
-              Reply(554, "Error switching to channel \"%d\"", channel->Number());
-              return;
-              }
-           }
-        else {
-           Reply(550, "Unable to find channel \"%s\"", Option);
-           return;
-           }
-        }
-     else
-        cDevice::SwitchChannel(d);
-     }
-  cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  if (channel)
-     Reply(250, "%d %s", channel->Number(), channel->Name());
-  else
-     Reply(550, "Unable to find channel \"%d\"", cDevice::CurrentChannel());
-}
-
-void cSVDRP::CmdCLRE(const char *Option)
-{
-  if (*Option) {
-     tChannelID ChannelID = tChannelID::InvalidID;
-     if (isnumber(Option)) {
-        int o = strtol(Option, NULL, 10);
-        if (o >= 1 && o <= Channels.MaxNumber())
-           ChannelID = Channels.GetByNumber(o)->GetChannelID();
-        }
-     else {
-        ChannelID = tChannelID::FromString(Option);
-        if (ChannelID == tChannelID::InvalidID) {
-           for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-               if (!Channel->GroupSep()) {
-                  if (strcasecmp(Channel->Name(), Option) == 0) {
-                     ChannelID = Channel->GetChannelID();
-                     break;
-                     }
-                  }
-               }
-           }
-        }
-     if (!(ChannelID == tChannelID::InvalidID)) {
-        cSchedulesLock SchedulesLock(true, 1000);
-        cSchedules *s = (cSchedules *)cSchedules::Schedules(SchedulesLock);
-        if (s) {
-           cSchedule *Schedule = NULL;
-           ChannelID.ClrRid();
-           for (cSchedule *p = s->First(); p; p = s->Next(p)) {
-               if (p->ChannelID() == ChannelID) {
-                  Schedule = p;
-                  break;
-                  }
-               }
-           if (Schedule) {
-              for (cTimer *Timer = Timers.First(); Timer; Timer = Timers.Next(Timer)) {
-                  if (ChannelID == Timer->Channel()->GetChannelID().ClrRid())
-                     Timer->SetEvent(NULL);
-                  }
-              Schedule->Cleanup(INT_MAX);
-              cEitFilter::SetDisableUntil(time(NULL) + EITDISABLETIME);
-              Reply(250, "EPG data of channel \"%s\" cleared", Option);
-              }
-           else {
-              Reply(550, "No EPG data found for channel \"%s\"", Option);
-              return;
-              }
-           }
-        else
-           Reply(451, "Can't get EPG data");
-        }
-     else
-        Reply(501, "Undefined channel \"%s\"", Option);
-     }
-  else {
-     cEitFilter::SetDisableUntil(time(NULL) + EITDISABLETIME);
-     if (cSchedules::ClearAll()) {
-        Reply(250, "EPG data cleared");
-        cEitFilter::SetDisableUntil(time(NULL) + EITDISABLETIME);
-        }
-     else
-        Reply(451, "Error while clearing EPG data");
-     }
-}
-
-#ifdef USE_VASARAJANAULOJA
-void cSVDRP::CmdCPYR(const char *Option)
-{
-  if (*Option) {
-     char *tail;
-     int n = strtol(Option, &tail, 10);
-     cRecording *recording = Recordings.Get(n - 1);
-     if (recording && tail && tail != Option) {
-        char *oldName = strdup(recording->Name());
-        tail = skipspace(tail);
-        if (!cFileTransfer::Active()) {
-           if (cFileTransfer::Start(recording, tail, true))
-              Reply(250, "Copying recording \"%s\" to \"%s\"", oldName, tail);
-           else
-              Reply(554, "Can't start file transfer");
-           }
-        else
-           Reply(554, "File transfer already active");
-        free(oldName);
-        }
-     else
-        Reply(550, "Recording \"%d\" not found%s", n, Recordings.Count() ? "" : " (use LSTR before copying)");
-     }
-  else
-     Reply(501, "Invalid Option \"%s\"", Option);
-}
-#endif /* VASARAJANAULOJA */
-
-void cSVDRP::CmdDELC(const char *Option)
-{
-  if (*Option) {
-     if (isnumber(Option)) {
-        if (!Channels.BeingEdited()) {
-           cChannel *channel = Channels.GetByNumber(strtol(Option, NULL, 10));
-           if (channel) {
-              for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
-                  if (timer->Channel() == channel) {
-                     Reply(550, "Channel \"%s\" is in use by timer %d", Option, timer->Index() + 1);
-                     return;
-                     }
-                  }
-              int CurrentChannelNr = cDevice::CurrentChannel();
-              cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-              if (CurrentChannel && channel == CurrentChannel) {
-                 int n = Channels.GetNextNormal(CurrentChannel->Index());
-                 if (n < 0)
-                    n = Channels.GetPrevNormal(CurrentChannel->Index());
-                 CurrentChannel = Channels.Get(n);
-                 CurrentChannelNr = 0; // triggers channel switch below
-                 }
-              Channels.Del(channel);
-              Channels.ReNumber();
-              Channels.SetModified(true);
-              isyslog("channel %s deleted", Option);
-              if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-                 if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-                    Channels.SwitchTo(CurrentChannel->Number());
-                 else
-                    cDevice::SetCurrentChannel(CurrentChannel);
-                 }
-              Reply(250, "Channel \"%s\" deleted", Option);
-              }
-           else
-              Reply(501, "Channel \"%s\" not defined", Option);
-           }
-        else
-           Reply(550, "Channels are being edited - try again later");
-        }
-     else
-        Reply(501, "Error in channel number \"%s\"", Option);
-     }
-  else
-     Reply(501, "Missing channel number");
-}
-
-void cSVDRP::CmdDELR(const char *Option)
-{
-  if (*Option) {
-     if (isnumber(Option)) {
-        cRecording *recording = recordings.Get(strtol(Option, NULL, 10) - 1);
-        if (recording) {
-           cRecordControl *rc = cRecordControls::GetRecordControl(recording->FileName());
-           if (!rc) {
-              if (!cCutter::Active(recording->FileName())) {
-                 if (recording->Delete()) {
-                    Reply(250, "Recording \"%s\" deleted", Option);
-                    Recordings.DelByName(recording->FileName());
-                    }
-                 else
-                    Reply(554, "Error while deleting recording!");
-                 }
-              else
-                 Reply(550, "Recording \"%s\" is being edited", Option);
-              }
-           else
-              Reply(550, "Recording \"%s\" is in use by timer %d", Option, rc->Timer()->Index() + 1);
-           }
-        else
-           Reply(550, "Recording \"%s\" not found%s", Option, recordings.Count() ? "" : " (use LSTR before deleting)");
-        }
-     else
-        Reply(501, "Error in recording number \"%s\"", Option);
-     }
-  else
-     Reply(501, "Missing recording number");
-}
-
-void cSVDRP::CmdDELT(const char *Option)
-{
-  if (*Option) {
-     if (isnumber(Option)) {
-        if (!Timers.BeingEdited()) {
-           cTimer *timer = Timers.Get(strtol(Option, NULL, 10) - 1);
-           if (timer) {
-              if (!timer->Recording()) {
-                 isyslog("deleting timer %s", *timer->ToDescr());
-                 Timers.Del(timer);
-                 Timers.SetModified();
-                 Reply(250, "Timer \"%s\" deleted", Option);
-                 }
-              else
-                 Reply(550, "Timer \"%s\" is recording", Option);
-              }
-           else
-              Reply(501, "Timer \"%s\" not defined", Option);
-           }
-        else
-           Reply(550, "Timers are being edited - try again later");
-        }
-     else
-        Reply(501, "Error in timer number \"%s\"", Option);
-     }
-  else
-     Reply(501, "Missing timer number");
-}
-
-void cSVDRP::CmdEDIT(const char *Option)
-{
-  if (*Option) {
-     if (isnumber(Option)) {
-        cRecording *recording = recordings.Get(strtol(Option, NULL, 10) - 1);
-        if (recording) {
-           cMarks Marks;
-           if (Marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && Marks.Count()) {
-              if (!cCutter::Active()) {
-                 if (cCutter::Start(recording->FileName()))
-                    Reply(250, "Editing recording \"%s\" [%s]", Option, recording->Title());
-                 else
-                    Reply(554, "Can't start editing process");
-                 }
-              else
-                 Reply(554, "Editing process already active");
-              }
-           else
-              Reply(554, "No editing marks defined");
-           }
-        else
-           Reply(550, "Recording \"%s\" not found%s", Option, recordings.Count() ? "" : " (use LSTR before editing)");
-        }
-     else
-        Reply(501, "Error in recording number \"%s\"", Option);
-     }
-  else
-     Reply(501, "Missing recording number");
-}
-
-void cSVDRP::CmdGRAB(const char *Option)
-{
-  const char *FileName = NULL;
-  bool Jpeg = true;
-  int Quality = -1, SizeX = -1, SizeY = -1;
-  if (*Option) {
-     char buf[strlen(Option) + 1];
-     char *p = strcpy(buf, Option);
-     const char *delim = " \t";
-     char *strtok_next;
-     FileName = strtok_r(p, delim, &strtok_next);
-     // image type:
-     const char *Extension = strrchr(FileName, '.');
-     if (Extension) {
-        if (strcasecmp(Extension, ".jpg") == 0 || strcasecmp(Extension, ".jpeg") == 0)
-           Jpeg = true;
-        else if (strcasecmp(Extension, ".pnm") == 0)
-           Jpeg = false;
-        else {
-           Reply(501, "Unknown image type \"%s\"", Extension + 1);
-           return;
-           }
-        if (Extension == FileName)
-           FileName = NULL;
-        }
-     else if (strcmp(FileName, "-") == 0)
-        FileName = NULL;
-     // image quality (and obsolete type):
-     if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
-        if (strcasecmp(p, "JPEG") == 0 || strcasecmp(p, "PNM") == 0) {
-           // tolerate for backward compatibility
-           p = strtok_r(NULL, delim, &strtok_next);
-           }
-        if (p) {
-           if (isnumber(p))
-              Quality = atoi(p);
-           else {
-              Reply(501, "Invalid quality \"%s\"", p);
-              return;
-              }
-           }
-        }
-     // image size:
-     if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
-        if (isnumber(p))
-           SizeX = atoi(p);
-        else {
-           Reply(501, "Invalid sizex \"%s\"", p);
-           return;
-           }
-        if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
-           if (isnumber(p))
-              SizeY = atoi(p);
-           else {
-              Reply(501, "Invalid sizey \"%s\"", p);
-              return;
-              }
-           }
-        else {
-           Reply(501, "Missing sizey");
-           return;
-           }
-        }
-     if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
-        Reply(501, "Unexpected parameter \"%s\"", p);
-        return;
-        }
-     // canonicalize the file name:
-     char RealFileName[PATH_MAX];
-     if (FileName) {
-        if (grabImageDir) {
-           cString s(FileName);
-           FileName = s;
-           const char *slash = strrchr(FileName, '/');
-           if (!slash) {
-              s = AddDirectory(grabImageDir, FileName);
-              FileName = s;
-              }
-           slash = strrchr(FileName, '/'); // there definitely is one
-           cString t(s);
-           t.Truncate(slash - FileName);
-           char *r = realpath(t, RealFileName);
-           if (!r) {
-              LOG_ERROR_STR(FileName);
-              Reply(501, "Invalid file name \"%s\"", FileName);
-              return;
-              }
-           strcat(RealFileName, slash);
-           FileName = RealFileName;
-           if (strncmp(FileName, grabImageDir, strlen(grabImageDir)) != 0) {
-              Reply(501, "Invalid file name \"%s\"", FileName);
-              return;
-              }
-           }
-        else {
-           Reply(550, "Grabbing to file not allowed (use \"GRAB -\" instead)");
-           return;
-           }
-        }
-     // actual grabbing:
-     int ImageSize;
-     uchar *Image = cDevice::PrimaryDevice()->GrabImage(ImageSize, Jpeg, Quality, SizeX, SizeY);
-     if (Image) {
-        if (FileName) {
-           int fd = open(FileName, O_WRONLY | O_CREAT | O_NOFOLLOW | O_TRUNC, DEFFILEMODE);
-           if (fd >= 0) {
-              if (safe_write(fd, Image, ImageSize) == ImageSize) {
-                 dsyslog("grabbed image to %s", FileName);
-                 Reply(250, "Grabbed image %s", Option);
-                 }
-              else {
-                 LOG_ERROR_STR(FileName);
-                 Reply(451, "Can't write to '%s'", FileName);
-                 }
-              close(fd);
-              }
-           else {
-              LOG_ERROR_STR(FileName);
-              Reply(451, "Can't open '%s'", FileName);
-              }
-           }
-        else {
-           cBase64Encoder Base64(Image, ImageSize);
-           const char *s;
-           while ((s = Base64.NextLine()) != NULL)
-                 Reply(-216, "%s", s);
-           Reply(216, "Grabbed image %s", Option);
-           }
-        free(Image);
-        }
-     else
-        Reply(451, "Grab image failed");
-     }
-  else
-     Reply(501, "Missing filename");
-}
-
-void cSVDRP::CmdHELP(const char *Option)
-{
-  if (*Option) {
-     const char *hp = GetHelpPage(Option, HelpPages);
-     if (hp)
-        Reply(-214, "%s", hp);
-     else {
-        Reply(504, "HELP topic \"%s\" unknown", Option);
-        return;
-        }
-     }
-  else {
-     Reply(-214, "This is VDR version %s", VDRVERSION);
-     Reply(-214, "Topics:");
-     PrintHelpTopics(HelpPages);
-     cPlugin *plugin;
-     for (int i = 0; (plugin = cPluginManager::GetPlugin(i)) != NULL; i++) {
-         const char **hp = plugin->SVDRPHelpPages();
-         if (hp)
-            Reply(-214, "Plugin %s v%s - %s", plugin->Name(), plugin->Version(), plugin->Description());
-         PrintHelpTopics(hp);
-         }
-     Reply(-214, "To report bugs in the implementation send email to");
-     Reply(-214, "    vdr-bugs@tvdr.de");
-     }
-  Reply(214, "End of HELP info");
-}
-
-void cSVDRP::CmdHITK(const char *Option)
-{
-  if (*Option) {
-     if (!cRemote::Enabled()) {
-        Reply(550, "Remote control currently disabled (key \"%s\" discarded)", Option);
-        return;
-        }
-     char buf[strlen(Option) + 1];
-     strcpy(buf, Option);
-     const char *delim = " \t";
-     char *strtok_next;
-     char *p = strtok_r(buf, delim, &strtok_next);
-     int NumKeys = 0;
-     while (p) {
-           eKeys k = cKey::FromString(p);
-           if (k != kNone) {
-              if (!cRemote::Put(k)) {
-                 Reply(451, "Too many keys in \"%s\" (only %d accepted)", Option, NumKeys);
-                 return;
-                 }
-              }
-           else {
-              Reply(504, "Unknown key: \"%s\"", p);
-              return;
-              }
-           NumKeys++;
-           p = strtok_r(NULL, delim, &strtok_next);
-           }
-     Reply(250, "Key%s \"%s\" accepted", NumKeys > 1 ? "s" : "", Option);
-     }
-  else {
-     Reply(-214, "Valid <key> names for the HITK command:");
-     for (int i = 0; i < kNone; i++) {
-         Reply(-214, "    %s", cKey::ToString(eKeys(i)));
-         }
-     Reply(214, "End of key list");
-     }
-}
-
-void cSVDRP::CmdLSTC(const char *Option)
-{
-  bool WithGroupSeps = strcasecmp(Option, ":groups") == 0;
-  if (*Option && !WithGroupSeps) {
-     if (isnumber(Option)) {
-        cChannel *channel = Channels.GetByNumber(strtol(Option, NULL, 10));
-        if (channel)
-           Reply(250, "%d %s", channel->Number(), *channel->ToText());
-        else
-           Reply(501, "Channel \"%s\" not defined", Option);
-        }
-     else {
-        cChannel *next = Channels.GetByChannelID(tChannelID::FromString(Option));
-        if (!next) {
-           for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
-              if (!channel->GroupSep()) {
-                 if (strcasestr(channel->Name(), Option)) {
-                    if (next)
-                       Reply(-250, "%d %s", next->Number(), *next->ToText());
-                    next = channel;
-                    }
-                 }
-              }
-           }
-        if (next)
-           Reply(250, "%d %s", next->Number(), *next->ToText());
-        else
-           Reply(501, "Channel \"%s\" not defined", Option);
-        }
-     }
-  else if (Channels.MaxNumber() >= 1) {
-     for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
-         if (WithGroupSeps)
-            Reply(channel->Next() ? -250: 250, "%d %s", channel->GroupSep() ? 0 : channel->Number(), *channel->ToText());
-         else if (!channel->GroupSep())
-            Reply(channel->Number() < Channels.MaxNumber() ? -250 : 250, "%d %s", channel->Number(), *channel->ToText());
-         }
-     }
-  else
-     Reply(550, "No channels defined");
-}
-
-void cSVDRP::CmdLSTE(const char *Option)
-{
-  cSchedulesLock SchedulesLock;
-  const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-  if (Schedules) {
-     const cSchedule* Schedule = NULL;
-     eDumpMode DumpMode = dmAll;
-     time_t AtTime = 0;
-     if (*Option) {
-        char buf[strlen(Option) + 1];
-        strcpy(buf, Option);
-        const char *delim = " \t";
-        char *strtok_next;
-        char *p = strtok_r(buf, delim, &strtok_next);
-        while (p && DumpMode == dmAll) {
-              if (strcasecmp(p, "NOW") == 0)
-                 DumpMode = dmPresent;
-              else if (strcasecmp(p, "NEXT") == 0)
-                 DumpMode = dmFollowing;
-              else if (strcasecmp(p, "AT") == 0) {
-                 DumpMode = dmAtTime;
-                 if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
-                    if (isnumber(p))
-                       AtTime = strtol(p, NULL, 10);
-                    else {
-                       Reply(501, "Invalid time");
-                       return;
-                       }
-                    }
-                 else {
-                    Reply(501, "Missing time");
-                    return;
-                    }
-                 }
-              else if (!Schedule) {
-                 cChannel* Channel = NULL;
-                 if (isnumber(p))
-                    Channel = Channels.GetByNumber(strtol(Option, NULL, 10));
-                 else
-                    Channel = Channels.GetByChannelID(tChannelID::FromString(Option));
-                 if (Channel) {
-                    Schedule = Schedules->GetSchedule(Channel);
-                    if (!Schedule) {
-                       Reply(550, "No schedule found");
-                       return;
-                       }
-                    }
-                 else {
-                    Reply(550, "Channel \"%s\" not defined", p);
-                    return;
-                    }
-                 }
-              else {
-                 Reply(501, "Unknown option: \"%s\"", p);
-                 return;
-                 }
-              p = strtok_r(NULL, delim, &strtok_next);
-              }
-        }
-     int fd = dup(file);
-     if (fd) {
-        FILE *f = fdopen(fd, "w");
-        if (f) {
-           if (Schedule)
-              Schedule->Dump(f, "215-", DumpMode, AtTime);
-           else
-              Schedules->Dump(f, "215-", DumpMode, AtTime);
-           fflush(f);
-           Reply(215, "End of EPG data");
-           fclose(f);
-           }
-        else {
-           Reply(451, "Can't open file connection");
-           close(fd);
-           }
-        }
-     else
-        Reply(451, "Can't dup stream descriptor");
-     }
-  else
-     Reply(451, "Can't get EPG data");
-}
-
-void cSVDRP::CmdLSTR(const char *Option)
-{
-  recordings.Update(true);
-  if (*Option) {
-     if (isnumber(Option)) {
-        cRecording *recording = recordings.Get(strtol(Option, NULL, 10) - 1);
-        if (recording) {
-           FILE *f = fdopen(file, "w");
-           if (f) {
-              recording->Info()->Write(f, "215-");
-              fflush(f);
-              Reply(215, "End of recording information");
-              // don't 'fclose(f)' here!
-              }
-           else
-              Reply(451, "Can't open file connection");
-           }
-        else
-           Reply(550, "Recording \"%s\" not found", Option);
-        }
-     else
-        Reply(501, "Error in recording number \"%s\"", Option);
-     }
-  else if (recordings.Count()) {
-     cRecording *recording = recordings.First();
-     while (recording) {
-           Reply(recording == recordings.Last() ? 250 : -250, "%d %s", recording->Index() + 1, recording->Title(' ', true));
-           recording = recordings.Next(recording);
-           }
-     }
-  else
-     Reply(550, "No recordings available");
-}
-
-void cSVDRP::CmdLSTT(const char *Option)
-{
-  int Number = 0;
-  bool Id = false;
-  if (*Option) {
-     char buf[strlen(Option) + 1];
-     strcpy(buf, Option);
-     const char *delim = " \t";
-     char *strtok_next;
-     char *p = strtok_r(buf, delim, &strtok_next);
-     while (p) {
-           if (isnumber(p))
-              Number = strtol(p, NULL, 10);
-           else if (strcasecmp(p, "ID") == 0)
-              Id = true;
-           else {
-              Reply(501, "Unknown option: \"%s\"", p);
-              return;
-              }
-           p = strtok_r(NULL, delim, &strtok_next);
-           }
-     }
-  if (Number) {
-     cTimer *timer = Timers.Get(Number - 1);
-     if (timer)
-        Reply(250, "%d %s", timer->Index() + 1, *timer->ToText(Id));
-     else
-        Reply(501, "Timer \"%s\" not defined", Option);
-     }
-  else if (Timers.Count()) {
-     for (int i = 0; i < Timers.Count(); i++) {
-         cTimer *timer = Timers.Get(i);
-        if (timer)
-           Reply(i < Timers.Count() - 1 ? -250 : 250, "%d %s", timer->Index() + 1, *timer->ToText(Id));
-        else
-           Reply(501, "Timer \"%d\" not found", i + 1);
-         }
-     }
-  else
-     Reply(550, "No timers defined");
-}
-
-void cSVDRP::CmdMESG(const char *Option)
-{
-  if (*Option) {
-     isyslog("SVDRP message: '%s'", Option);
-     Skins.QueueMessage(mtInfo, Option);
-     Reply(250, "Message queued");
-     }
-  else
-     Reply(501, "Missing message");
-}
-
-void cSVDRP::CmdMODC(const char *Option)
-{
-  if (*Option) {
-     char *tail;
-     int n = strtol(Option, &tail, 10);
-     if (tail && tail != Option) {
-        tail = skipspace(tail);
-        if (!Channels.BeingEdited()) {
-           cChannel *channel = Channels.GetByNumber(n);
-           if (channel) {
-              cChannel ch;
-              if (ch.Parse(tail)) {
-                 if (Channels.HasUniqueChannelID(&ch, channel)) {
-                    *channel = ch;
-                    Channels.ReNumber();
-                    Channels.SetModified(true);
-                    isyslog("modifed channel %d %s", channel->Number(), *channel->ToText());
-                    Reply(250, "%d %s", channel->Number(), *channel->ToText());
-                    }
-                 else
-                    Reply(501, "Channel settings are not unique");
-                 }
-              else
-                 Reply(501, "Error in channel settings");
-              }
-           else
-              Reply(501, "Channel \"%d\" not defined", n);
-           }
-        else
-           Reply(550, "Channels are being edited - try again later");
-        }
-     else
-        Reply(501, "Error in channel number");
-     }
-  else
-     Reply(501, "Missing channel settings");
-}
-
-void cSVDRP::CmdMODT(const char *Option)
-{
-  if (*Option) {
-     char *tail;
-     int n = strtol(Option, &tail, 10);
-     if (tail && tail != Option) {
-        tail = skipspace(tail);
-        if (!Timers.BeingEdited()) {
-           cTimer *timer = Timers.Get(n - 1);
-           if (timer) {
-              cTimer t = *timer;
-              if (strcasecmp(tail, "ON") == 0)
-                 t.SetFlags(tfActive);
-              else if (strcasecmp(tail, "OFF") == 0)
-                 t.ClrFlags(tfActive);
-              else if (!t.Parse(tail)) {
-                 Reply(501, "Error in timer settings");
-                 return;
-                 }
-              *timer = t;
-              Timers.SetModified();
-              isyslog("timer %s modified (%s)", *timer->ToDescr(), timer->HasFlags(tfActive) ? "active" : "inactive");
-              Reply(250, "%d %s", timer->Index() + 1, *timer->ToText());
-              }
-           else
-              Reply(501, "Timer \"%d\" not defined", n);
-           }
-        else
-           Reply(550, "Timers are being edited - try again later");
-        }
-     else
-        Reply(501, "Error in timer number");
-     }
-  else
-     Reply(501, "Missing timer settings");
-}
-
-void cSVDRP::CmdMOVC(const char *Option)
-{
-  if (*Option) {
-     if (!Channels.BeingEdited() && !Timers.BeingEdited()) {
-        char *tail;
-        int From = strtol(Option, &tail, 10);
-        if (tail && tail != Option) {
-           tail = skipspace(tail);
-           if (tail && tail != Option) {
-              int To = strtol(tail, NULL, 10);
-              int CurrentChannelNr = cDevice::CurrentChannel();
-              cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-              cChannel *FromChannel = Channels.GetByNumber(From);
-              if (FromChannel) {
-                 cChannel *ToChannel = Channels.GetByNumber(To);
-                 if (ToChannel) {
-                    int FromNumber = FromChannel->Number();
-                    int ToNumber = ToChannel->Number();
-                    if (FromNumber != ToNumber) {
-                       Channels.Move(FromChannel, ToChannel);
-                       Channels.ReNumber();
-                       Channels.SetModified(true);
-                       if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-                          if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-                             Channels.SwitchTo(CurrentChannel->Number());
-                          else
-                             cDevice::SetCurrentChannel(CurrentChannel);
-                          }
-                       isyslog("channel %d moved to %d", FromNumber, ToNumber);
-                       Reply(250,"Channel \"%d\" moved to \"%d\"", From, To);
-                       }
-                    else
-                       Reply(501, "Can't move channel to same position");
-                    }
-                 else
-                    Reply(501, "Channel \"%d\" not defined", To);
-                 }
-              else
-                 Reply(501, "Channel \"%d\" not defined", From);
-              }
-           else
-              Reply(501, "Error in channel number");
-           }
-        else
-           Reply(501, "Error in channel number");
-        }
-     else
-        Reply(550, "Channels or timers are being edited - try again later");
-     }
-  else
-     Reply(501, "Missing channel number");
-}
-
-#ifdef USE_VASARAJANAULOJA
-void cSVDRP::CmdMOVR(const char *Option)
-{
-  if (*Option) {
-     char *tail;
-     int n = strtol(Option, &tail, 10);
-     cRecording *recording = Recordings.Get(n - 1);
-     if (recording && tail && tail != Option) {
-        char *oldName = strdup(recording->Name());
-        tail = skipspace(tail);
-        if (!cFileTransfer::Active()) {
-           if (cFileTransfer::Start(recording, tail))
-              Reply(250, "Moving recording \"%s\" to \"%s\"", oldName, tail);
-           else
-              Reply(554, "Can't start file transfer");
-           }
-        else
-           Reply(554, "File transfer already active");
-        free(oldName);
-        }
-     else
-        Reply(550, "Recording \"%d\" not found%s", n, Recordings.Count() ? "" : " (use LSTR before moving)");
-     }
-  else
-     Reply(501, "Invalid Option \"%s\"", Option);
-}
-#endif /* VASARAJANAULOJA */
-
-void cSVDRP::CmdNEWC(const char *Option)
-{
-  if (*Option) {
-     cChannel ch;
-     if (ch.Parse(Option)) {
-        if (Channels.HasUniqueChannelID(&ch)) {
-           cChannel *channel = new cChannel;
-           *channel = ch;
-           Channels.Add(channel);
-           Channels.ReNumber();
-           Channels.SetModified(true);
-           isyslog("new channel %d %s", channel->Number(), *channel->ToText());
-           Reply(250, "%d %s", channel->Number(), *channel->ToText());
-           }
-        else
-           Reply(501, "Channel settings are not unique");
-        }
-     else
-        Reply(501, "Error in channel settings");
-     }
-  else
-     Reply(501, "Missing channel settings");
-}
-
-void cSVDRP::CmdNEWT(const char *Option)
-{
-  if (*Option) {
-     cTimer *timer = new cTimer;
-     if (timer->Parse(Option)) {
-        cTimer *t = Timers.GetTimer(timer);
-        if (!t) {
-           Timers.Add(timer);
-           Timers.SetModified();
-           isyslog("timer %s added", *timer->ToDescr());
-           Reply(250, "%d %s", timer->Index() + 1, *timer->ToText());
-           return;
-           }
-        else
-           Reply(550, "Timer already defined: %d %s", t->Index() + 1, *t->ToText());
-        }
-     else
-        Reply(501, "Error in timer settings");
-     delete timer;
-     }
-  else
-     Reply(501, "Missing timer settings");
-}
-
-void cSVDRP::CmdNEXT(const char *Option)
-{
-  cTimer *t = Timers.GetNextActiveTimer();
-  if (t) {
-     time_t Start = t->StartTime();
-     int Number = t->Index() + 1;
-     if (!*Option)
-        Reply(250, "%d %s", Number, *TimeToString(Start));
-     else if (strcasecmp(Option, "ABS") == 0)
-        Reply(250, "%d %ld", Number, Start);
-     else if (strcasecmp(Option, "REL") == 0)
-        Reply(250, "%d %ld", Number, Start - time(NULL));
-     else
-        Reply(501, "Unknown option: \"%s\"", Option);
-     }
-  else
-     Reply(550, "No active timers");
-}
-
-void cSVDRP::CmdPLAY(const char *Option)
-{
-  if (*Option) {
-     char *opt = strdup(Option);
-     char *num = skipspace(opt);
-     char *option = num;
-     while (*option && !isspace(*option))
-           option++;
-     char c = *option;
-     *option = 0;
-     if (isnumber(num)) {
-        cRecording *recording = recordings.Get(strtol(num, NULL, 10) - 1);
-        if (recording) {
-           if (c)
-              option = skipspace(++option);
-           cReplayControl::SetRecording(NULL);
-           cControl::Shutdown();
-           if (*option) {
-              int pos = 0;
-              if (strcasecmp(option, "BEGIN") != 0)
-                 pos = HMSFToIndex(option, recording->FramesPerSecond());
-              cResumeFile resume(recording->FileName(), recording->IsPesRecording());
-              if (pos <= 0)
-                 resume.Delete();
-              else
-                 resume.Save(pos);
-              }
-           cReplayControl::SetRecording(recording->FileName());
-           cControl::Launch(new cReplayControl);
-           cControl::Attach();
-           Reply(250, "Playing recording \"%s\" [%s]", num, recording->Title());
-           }
-        else
-           Reply(550, "Recording \"%s\" not found%s", num, recordings.Count() ? "" : " (use LSTR before playing)");
-        }
-     else
-        Reply(501, "Error in recording number \"%s\"", num);
-     free(opt);
-     }
-  else
-     Reply(501, "Missing recording number");
-}
-
-void cSVDRP::CmdPLUG(const char *Option)
-{
-  if (*Option) {
-     char *opt = strdup(Option);
-     char *name = skipspace(opt);
-     char *option = name;
-     while (*option && !isspace(*option))
-        option++;
-     char c = *option;
-     *option = 0;
-     cPlugin *plugin = cPluginManager::GetPlugin(name);
-     if (plugin) {
-        if (c)
-           option = skipspace(++option);
-        char *cmd = option;
-        while (*option && !isspace(*option))
-              option++;
-        if (*option) {
-           *option++ = 0;
-           option = skipspace(option);
-           }
-        if (!*cmd || strcasecmp(cmd, "HELP") == 0) {
-           if (*cmd && *option) {
-              const char *hp = GetHelpPage(option, plugin->SVDRPHelpPages());
-              if (hp) {
-                 Reply(-214, "%s", hp);
-                 Reply(214, "End of HELP info");
-                 }
-              else
-                 Reply(504, "HELP topic \"%s\" for plugin \"%s\" unknown", option, plugin->Name());
-              }
-           else {
-              Reply(-214, "Plugin %s v%s - %s", plugin->Name(), plugin->Version(), plugin->Description());
-              const char **hp = plugin->SVDRPHelpPages();
-              if (hp) {
-                 Reply(-214, "SVDRP commands:");
-                 PrintHelpTopics(hp);
-                 Reply(214, "End of HELP info");
-                 }
-              else
-                 Reply(214, "This plugin has no SVDRP commands");
-              }
-           }
-        else if (strcasecmp(cmd, "MAIN") == 0) {
-           if (cRemote::CallPlugin(plugin->Name()))
-              Reply(250, "Initiated call to main menu function of plugin \"%s\"", plugin->Name());
-           else
-              Reply(550, "A plugin call is already pending - please try again later");
-           }
-        else {
-           int ReplyCode = 900;
-           cString s = plugin->SVDRPCommand(cmd, option, ReplyCode);
-           if (*s)
-              Reply(abs(ReplyCode), "%s", *s);
-           else
-              Reply(500, "Command unrecognized: \"%s\"", cmd);
-           }
-        }
-     else
-        Reply(550, "Plugin \"%s\" not found (use PLUG for a list of plugins)", name);
-     free(opt);
-     }
-  else {
-     Reply(-214, "Available plugins:");
-     cPlugin *plugin;
-     for (int i = 0; (plugin = cPluginManager::GetPlugin(i)) != NULL; i++)
-         Reply(-214, "%s v%s - %s", plugin->Name(), plugin->Version(), plugin->Description());
-     Reply(214, "End of plugin list");
-     }
-}
-
-void cSVDRP::CmdPUTE(const char *Option)
-{
-  if (*Option) {
-     FILE *f = fopen(Option, "r");
-     if (f) {
-        if (cSchedules::Read(f)) {
-           cSchedules::Cleanup(true);
-           Reply(250, "EPG data processed from \"%s\"", Option);
-           }
-        else
-           Reply(451, "Error while processing EPG from \"%s\"", Option);
-        fclose(f);
-        }
-     else
-        Reply(501, "Cannot open file \"%s\"", Option);
-     }
-  else {     
-     delete PUTEhandler;
-     PUTEhandler = new cPUTEhandler;
-     Reply(PUTEhandler->Status(), "%s", PUTEhandler->Message());
-     if (PUTEhandler->Status() != 354)
-        DELETENULL(PUTEhandler);
-     }
-}
-
-void cSVDRP::CmdREMO(const char *Option)
-{
-  if (*Option) {
-     if (!strcasecmp(Option, "ON")) {
-        cRemote::SetEnabled(true);
-        Reply(250, "Remote control enabled");
-        }
-     else if (!strcasecmp(Option, "OFF")) {
-        cRemote::SetEnabled(false);
-        Reply(250, "Remote control disabled");
-        }
-     else
-        Reply(501, "Invalid Option \"%s\"", Option);
-     }
-  else
-     Reply(250, "Remote control is %s", cRemote::Enabled() ? "enabled" : "disabled");
-}
-
-void cSVDRP::CmdSCAN(const char *Option)
-{
-  EITScanner.ForceScan();
-  Reply(250, "EPG scan triggered");
-}
-
-void cSVDRP::CmdSTAT(const char *Option)
-{
-  if (*Option) {
-     if (strcasecmp(Option, "DISK") == 0) {
-        int FreeMB, UsedMB;
-        int Percent = VideoDiskSpace(&FreeMB, &UsedMB);
-        Reply(250, "%dMB %dMB %d%%", FreeMB + UsedMB, FreeMB, Percent);
-        }
-     else
-        Reply(501, "Invalid Option \"%s\"", Option);
-     }
-  else
-     Reply(501, "No option given");
-}
-
-void cSVDRP::CmdUPDT(const char *Option)
-{
-  if (*Option) {
-     cTimer *timer = new cTimer;
-     if (timer->Parse(Option)) {
-        if (!Timers.BeingEdited()) {
-           cTimer *t = Timers.GetTimer(timer);
-           if (t) {
-              t->Parse(Option);
-              delete timer;
-              timer = t;
-              isyslog("timer %s updated", *timer->ToDescr());
-              }
-           else {
-              Timers.Add(timer);
-              isyslog("timer %s added", *timer->ToDescr());
-              }
-           Timers.SetModified();
-           Reply(250, "%d %s", timer->Index() + 1, *timer->ToText());
-           return;
-           }
-        else
-           Reply(550, "Timers are being edited - try again later");
-        }
-     else
-        Reply(501, "Error in timer settings");
-     delete timer;
-     }
-  else
-     Reply(501, "Missing timer settings");
-}
-
-void cSVDRP::CmdUPDR(const char *Option)
-{
-  Recordings.Update(false);
-  Reply(250, "Re-read of recordings directory triggered");
-}
-
-void cSVDRP::CmdVOLU(const char *Option)
-{
-  if (*Option) {
-     if (isnumber(Option))
-        cDevice::PrimaryDevice()->SetVolume(strtol(Option, NULL, 10), true);
-     else if (strcmp(Option, "+") == 0)
-        cDevice::PrimaryDevice()->SetVolume(VOLUMEDELTA);
-     else if (strcmp(Option, "-") == 0)
-        cDevice::PrimaryDevice()->SetVolume(-VOLUMEDELTA);
-     else if (strcasecmp(Option, "MUTE") == 0)
-        cDevice::PrimaryDevice()->ToggleMute();
-     else {
-        Reply(501, "Unknown option: \"%s\"", Option);
-        return;
-        }
-     }
-  if (cDevice::PrimaryDevice()->IsMute())
-     Reply(250, "Audio is mute");
-  else
-     Reply(250, "Audio volume is %d", cDevice::CurrentVolume());
-}
-
-#define CMD(c) (strcasecmp(Cmd, c) == 0)
-
-void cSVDRP::Execute(char *Cmd)
-{
-  // handle PUTE data:
-  if (PUTEhandler) {
-     if (!PUTEhandler->Process(Cmd)) {
-        Reply(PUTEhandler->Status(), "%s", PUTEhandler->Message());
-        DELETENULL(PUTEhandler);
-        }
-     cEitFilter::SetDisableUntil(time(NULL) + EITDISABLETIME); // re-trigger the timeout, in case there is very much EPG data
-     return;
-     }
-  // skip leading whitespace:
-  Cmd = skipspace(Cmd);
-  // find the end of the command word:
-  char *s = Cmd;
-  while (*s && !isspace(*s))
-        s++;
-  if (*s)
-     *s++ = 0;
-  s = skipspace(s);
-  if      (CMD("CHAN"))  CmdCHAN(s);
-  else if (CMD("CLRE"))  CmdCLRE(s);
-#ifdef USE_VASARAJANAULOJA
-  else if (CMD("CPYR"))  CmdCPYR(s);
-#endif /* VASARAJANAULOJA */
-  else if (CMD("DELC"))  CmdDELC(s);
-  else if (CMD("DELR"))  CmdDELR(s);
-  else if (CMD("DELT"))  CmdDELT(s);
-  else if (CMD("EDIT"))  CmdEDIT(s);
-  else if (CMD("GRAB"))  CmdGRAB(s);
-  else if (CMD("HELP"))  CmdHELP(s);
-  else if (CMD("HITK"))  CmdHITK(s);
-  else if (CMD("LSTC"))  CmdLSTC(s);
-  else if (CMD("LSTE"))  CmdLSTE(s);
-  else if (CMD("LSTR"))  CmdLSTR(s);
-  else if (CMD("LSTT"))  CmdLSTT(s);
-  else if (CMD("MESG"))  CmdMESG(s);
-  else if (CMD("MODC"))  CmdMODC(s);
-  else if (CMD("MODT"))  CmdMODT(s);
-  else if (CMD("MOVC"))  CmdMOVC(s);
-#ifdef USE_VASARAJANAULOJA
-  else if (CMD("MOVR"))  CmdMOVR(s);
-#endif /* VASARAJANAULOJA */
-  else if (CMD("NEWC"))  CmdNEWC(s);
-  else if (CMD("NEWT"))  CmdNEWT(s);
-  else if (CMD("NEXT"))  CmdNEXT(s);
-  else if (CMD("PLAY"))  CmdPLAY(s);
-  else if (CMD("PLUG"))  CmdPLUG(s);
-  else if (CMD("PUTE"))  CmdPUTE(s);
-  else if (CMD("REMO"))  CmdREMO(s);
-  else if (CMD("SCAN"))  CmdSCAN(s);
-  else if (CMD("STAT"))  CmdSTAT(s);
-  else if (CMD("UPDR"))  CmdUPDR(s);
-  else if (CMD("UPDT"))  CmdUPDT(s);
-  else if (CMD("VOLU"))  CmdVOLU(s);
-  else if (CMD("QUIT"))  Close(true);
-  else                   Reply(500, "Command unrecognized: \"%s\"", Cmd);
-}
-
-bool cSVDRP::Process(void)
-{
-  bool NewConnection = !file.IsOpen();
-  bool SendGreeting = NewConnection;
-
-  if (file.IsOpen() || file.Open(socket.Accept())) {
-     if (SendGreeting) {
-        //TODO how can we get the *full* hostname?
-        char buffer[BUFSIZ];
-        gethostname(buffer, sizeof(buffer));
-        time_t now = time(NULL);
-        Reply(220, "%s SVDRP VideoDiskRecorder %s; %s; %s", buffer, VDRVERSION, *TimeToString(now), cCharSetConv::SystemCharacterTable() ? cCharSetConv::SystemCharacterTable() : "UTF-8");
-        }
-     if (NewConnection)
-        lastActivity = time(NULL);
-     while (file.Ready(false)) {
-           unsigned char c;
-           int r = safe_read(file, &c, 1);
-           if (r > 0) {
-              if (c == '\n' || c == 0x00) {
-                 // strip trailing whitespace:
-                 while (numChars > 0 && strchr(" \t\r\n", cmdLine[numChars - 1]))
-                       cmdLine[--numChars] = 0;
-                 // make sure the string is terminated:
-                 cmdLine[numChars] = 0;
-                 // showtime!
-                 Execute(cmdLine);
-                 numChars = 0;
-                 if (length > BUFSIZ) {
-                    free(cmdLine); // let's not tie up too much memory
-                    length = BUFSIZ;
-                    cmdLine = MALLOC(char, length);
-                    }
-                 }
-              else if (c == 0x04 && numChars == 0) {
-                 // end of file (only at beginning of line)
-                 Close(true);
-                 }
-              else if (c == 0x08 || c == 0x7F) {
-                 // backspace or delete (last character)
-                 if (numChars > 0)
-                    numChars--;
-                 }
-              else if (c <= 0x03 || c == 0x0D) {
-                 // ignore control characters
-                 }
-              else {
-                 if (numChars >= length - 1) {
-                    int NewLength = length + BUFSIZ;
-                    if (char *NewBuffer = (char *)realloc(cmdLine, NewLength)) {
-                       length = NewLength;
-                       cmdLine = NewBuffer;
-                       }
-                    else {
-                       esyslog("ERROR: out of memory");
-                       Close();
-                       break;
-                       }
-                    }
-                 cmdLine[numChars++] = c;
-                 cmdLine[numChars] = 0;
-                 }
-              lastActivity = time(NULL);
-              }
-           else if (r <= 0) {
-              isyslog("lost connection to SVDRP client");
-              Close();
-              }
-           }
-     if (Setup.SVDRPTimeout && time(NULL) - lastActivity > Setup.SVDRPTimeout) {
-        isyslog("timeout on SVDRP connection");
-        Close(true, true);
-        }
-     return true;
-     }
-  return false;
-}
-
-void cSVDRP::SetGrabImageDir(const char *GrabImageDir)
-{
-  free(grabImageDir);
-  grabImageDir = GrabImageDir ? strdup(GrabImageDir) : NULL;
-}
-
-//TODO more than one connection???
diff -urN vdr-1.7.35.org/vdr.c vdr-1.7.35/vdr.c
--- vdr-1.7.35.org/vdr.c	2013-01-04 17:05:25.568805611 +0100
+++ vdr-1.7.35/vdr.c	2013-01-04 17:05:47.508804957 +0100
@@ -1069,6 +1069,28 @@
           case kChanUp:
           case kChanDn|k_Repeat:
           case kChanDn:
+
+               if (Setup.ChannelUpDownKeyMode == 1 && (!Menu || cDisplayChannel::IsOpen()))
+               // only if a menu is not open
+               //  and user has opted for a different key behavior
+               {
+                   if (cDisplayChannel::IsOpen() || cControl::Control())
+                   {
+                       DELETE_MENU;
+                   }
+                   if (key == kChanDn)
+                   {
+                       DirectMainFunction(osBouquets);
+                   }
+                   else
+                   {
+                       DirectMainFunction(osActiveBouquet);
+                   }
+                   key = kNone; // nobody else sees these keys
+                   break;
+               }
+               else
+
                if (!Interact)
                   Menu = new cDisplayChannel(NORMALKEY(key));
                else if (cDisplayChannel::IsOpen() || cControl::Control()) {
@@ -1112,6 +1134,7 @@
                break;
           // Subtitle track control:
           case kSubtitles:
+         case kGreater:
                if (cControl::Control())
                   cControl::Control()->Hide();
                if (!cDisplaySubtitleTracks::IsOpen()) {
@@ -1279,7 +1302,20 @@
                   Menu = new cDisplayChannel(NORMALKEY(key));
                   break;
              // Viewing Control:
-             case kOk:   LastChannel = -1; break; // forces channel display
+
+             case kInfo:
+             case kOk:  if ((Setup.WantChListOnOk && (key == kOk)) 
+                            || (!Setup.WantChListOnOk && (key == kInfo)) )
+                        {
+                            DirectMainFunction(osChannels);
+                        }
+                        else 
+                        {
+                            LastChannel = -1;
+                        }
+                        break;
+
+
              // Instant resume of the last viewed recording:
              case kPlay:
                   if (cReplayControl::LastReplayed()) {
