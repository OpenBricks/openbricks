diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_command_ids.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_command_ids.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_command_ids.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_command_ids.h	2011-11-01 10:47:58.833608195 +0100
@@ -0,0 +1,33 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _A2_COMMAND_IDS_H
+#define _A2_COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+typedef enum {
+  GROUP_A2_SYSTEM = 1, /**< A2 System group */
+  GROUP_A2_FLASH = 2, /**< A2 Flash group */
+  GROUP_A2_CONTROL = 16, /**< Control message */
+} A2_GroupId_e;
+
+typedef enum {
+  COMMAND_A2_SYSTEM_SHUTDOWN = 1, /**< Shutdown */
+  COMMAND_A2_SYSTEM_LOADERVERSION = 2, /**< Loader Version */
+  COMMAND_A2_SYSTEM_LOADERONLOADER = 17, /**< Loader on Loader */
+  COMMAND_A2_SYSTEM_RESET = 19, /**< Reset */
+  COMMAND_A2_FLASH_VERIFYSIGNEDHEADER = 1, /**< Verify Signed Header */
+  COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS = 2, /**< Software Block Address */
+  COMMAND_A2_FLASH_PROGRAMFLASH = 3, /**< Program Flash */
+  COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH = 4, /**< Verify Software Flash */
+  COMMAND_A2_FLASH_ERASEFLASH = 7, /**< Erase Flash */
+  COMMAND_A2_FLASH_SPEEDFLASH = 10, /**< Speedflash */
+  COMMAND_A2_CONTROL_LOADERSTARTED = 1, /**< Loader Started */
+  COMMAND_A2_CONTROL_PING = 2, /**< Ping */
+  COMMAND_A2_CONTROL_PONG = 3, /**< Pong */
+  COMMAND_A2_CONTROL_MAXPACKETSIZE = 4, /**< Max Packet Size */
+  COMMAND_A2_CONTROL_LOADERNOTSTARTED = 5, /**< Loader Not Started */
+} A2_CommandId_e;
+
+
+#endif /* _A2_COMMAND_IDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_commands.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_commands.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_commands.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_commands.h	2011-11-01 10:47:58.885608918 +0100
@@ -0,0 +1,215 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _A2_COMMANDS_H_
+#define _A2_COMMANDS_H_
+
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "t_basicdefinitions.h"
+#include "CmdResult.h"
+//#include "error_codes.h"
+//#include "t_a2_protocol.h"
+//#include "a2_command_ids.h"
+
+class CLCDriverMethods;
+
+class A2LoaderRpcInterface
+{
+public:
+  A2LoaderRpcInterface(CLCDriverMethods* lcdMethods, CmdResult* cmdResult, LcmInterface* lcmInterface):
+    lcdMethods_(lcdMethods),
+    cmdResult_(cmdResult),
+    lcmInterface_(lcmInterface),
+    targetCpu_(0),
+    morePackets_(0)
+  {
+  }
+
+  virtual ~A2LoaderRpcInterface()
+  {
+  }
+
+  /*
+   * A2 System commands group (0x01)
+   */
+
+  /**
+   * The Loader shuts down in a controlled fashion and proceeds to shut down the ME itself.
+   * \see DoneRPC_A2_System_ShutdownImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_Shutdown(uint16 SessionOut);
+  
+  /**
+   * The Loader Version command is sent by the PC to request version information from the loader. The ME responds with a Loader Version information coded as ASCII characters in the data field.
+   * \see DoneRPC_A2_System_LoaderVersionImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_LoaderVersion(uint16 SessionOut);
+  
+  /**
+   * This command is used to transfer a new Loader to the ME. The data should hold either Header or Payload.
+   * \see DoneRPC_A2_System_LoaderOnLoaderImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] PayloadSize Application packet length
+   * @param [in] Payload 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_LoaderOnLoader(uint16 SessionOut, const uint32 PayloadSize, const void *Payload);
+  
+  /**
+   * The Reset command is used to instruct the Loader to reset the ME. Upon receiving this command, the Loader shuts down in a controlled fashion and restarts the ME.
+   * \see DoneRPC_A2_System_ResetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Timeout Timeout in ms.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_Reset(uint16 SessionOut, const uint32 Timeout);
+  
+  /*
+   * A2 Flash Commands group (0x02)
+   */
+
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_VerifySignedHeaderImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] PayloadSize Application packet length
+   * @param [in] VerifyHeaderIn 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_VerifySignedHeader(uint16 SessionOut, const uint32 PayloadSize, const void *VerifyHeaderIn);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_SoftwareBlockAddressImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] StartAddress Start address of the block.
+   * @param [in] BlockSize Size of the block.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_SoftwareBlockAddress(uint16 SessionOut, const uint32 StartAddress, const uint32 BlockSize);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_ProgramFlashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] PayloadSize Application packet length
+   * @param [in] Payload 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_ProgramFlash(uint16 SessionOut, const uint32 PayloadSize, const void *Payload);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_VerifySoftwareFlashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_VerifySoftwareFlash(uint16 SessionOut);
+  
+  /**
+   * The Erase flash command is used to erase the complete flash memory.
+   * \see DoneRPC_A2_Flash_EraseFlashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_EraseFlash(uint16 SessionOut);
+  
+  /**
+   * The Dump physical flash image command is used to read data from a physical flash location (physical addresses) and send it to the PC.
+   * \see DoneRPC_A2_Flash_SpeedflashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] StartAddress Start address of the block to be flashed
+   * @param [in] EndAddress End address of the block to be flashed
+   * @param [in] SubBlockSize Size of the single block to be transfered
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_Speedflash(uint16 SessionOut, const uint32 StartAddress, const uint32 EndAddress, const uint32 SubBlockSize);
+  
+  /*
+   * A2 Control message (0x10)
+   */
+
+  /**
+   * Response to \see DoRPC_A2_Control_LoaderStartedImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_LoaderStarted(uint16 Session);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_PingImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_Ping(uint16 SessionOut);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_PongImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_Pong(uint16 Session);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_MaxPacketSizeImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_MaxPacketSize(uint16 SessionOut);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_LoaderNotStartedImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_LoaderNotStarted(uint16 Session);
+  
+public:
+  void setTargetCpu(uint8 targetCpu) { targetCpu_ = targetCpu; }
+  void setMorePackets(uint8 morePackets) { morePackets_ = morePackets; }
+protected:
+  CLCDriverMethods* lcdMethods_;
+  CmdResult* cmdResult_;
+  LcmInterface* lcmInterface_;
+  uint8 targetCpu_;
+  uint8 morePackets_;
+};
+
+#endif /* _A2_COMMANDS_H_ */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_commands_impl.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_commands_impl.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_commands_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_commands_impl.h	2011-11-01 10:47:58.869609597 +0100
@@ -0,0 +1,197 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _A2_COMMANDS_IMPL_H_
+#define _A2_COMMANDS_IMPL_H_
+
+#include "a2_commands.h"
+#include "a2_command_ids.h"
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "error_codes.h"
+
+class CLCDriverMethods;
+
+class A2LoaderRpcInterfaceImpl : public A2LoaderRpcInterface 
+{
+public:
+	A2LoaderRpcInterfaceImpl(CLCDriverMethods* lcdMethods, CmdResult* cmdResult, LcmInterface* lcmInterface):
+    A2LoaderRpcInterface(lcdMethods, cmdResult, lcmInterface)
+  {
+  }
+
+	~A2LoaderRpcInterfaceImpl()
+  {
+  }
+
+	ErrorCode_e	Do_CEH_Callback(CommandData_t* pCmdData);
+
+  /*
+   * A2 System commands group (0x01)
+   */
+
+  /**
+   * Response to \see DoRPC_A2_System_Shutdown
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_ShutdownImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_System_LoaderVersion
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] LoaderVersionOut Loader version identifier
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_LoaderVersionImpl(uint16 Session, ErrorCode_e Status, int LoaderVersionOutPLSize, const void *LoaderVersionOut);
+  
+  /**
+   * Response to \see DoRPC_A2_System_LoaderOnLoader
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_LoaderOnLoaderImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_System_Reset
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_ResetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * A2 Flash Commands group (0x02)
+   */
+
+  /**
+   * Response to \see DoRPC_A2_Flash_VerifySignedHeader
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_VerifySignedHeaderImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_SoftwareBlockAddress
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_SoftwareBlockAddressImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_ProgramFlash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_ProgramFlashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_VerifySoftwareFlash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_VerifySoftwareFlashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_EraseFlash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_EraseFlashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_Speedflash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_SpeedflashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * A2 Control message (0x10)
+   */
+
+  /**
+   * 
+   * \see DoneRPC_A2_Control_LoaderStarted
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] MaxLoaderPacketSize 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_LoaderStartedImpl(uint16 Session, const uint32 MaxLoaderPacketSize);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_Ping
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_PingImpl(uint16 Session);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_Pong
+   * Call source: ME
+   * @param [in] Session Input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_PongImpl(uint16 Session);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_MaxPacketSize
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] MaxPacketSize 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_MaxPacketSizeImpl(uint16 Session, const uint16 MaxPacketSize);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_LoaderNotStarted
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] ErrorCode 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_LoaderNotStartedImpl(uint16 Session, const uint16 ErrorCode);
+  
+};
+
+#endif /* _A2_COMMANDS_IMPL_H_ */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_commands_marshal.cpp riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_commands_marshal.cpp
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/a2_commands_marshal.cpp	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/a2_commands_marshal.cpp	2011-11-01 10:47:58.973732872 +0100
@@ -0,0 +1,653 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "Serialization.h"
+#include "a2_commands_impl.h"
+#include "t_a2_protocol.h"
+//#include "a2_custom_commands.h" //when customer commands will be implemented
+#include "LCDriverMethods.h"
+
+#define A2_COMMAND(response, group, id) ((((int)(response)) << 30) | (((int)(group)) << 16) | ((int)(id))) 
+#define A2_COMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(A2_CommandData_t)); \
+  CmdData.Type             = TypeP; \
+  CmdData.ApplicationNr    = ApplicationP; \
+  CmdData.CommandNr        = CommandP; \
+  CmdData.SessionNr        = SessionP; \
+  CmdData.Payload.Size     = SizeP; \
+  CmdData.Payload.Data_p   = NULL; \
+  if(SizeP != 0)\
+  { \
+    CmdData.Payload.Data_p = (uint8*)malloc(sizeof(ErrorCode_e) + SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    }\
+  }
+
+#define A2_COMMANDDATAOUT(TypeP,ApplicationP,CommandP,SessionP,SizeP,TargetCPU) \
+  memset((uint8*)&CmdData, 0x00, sizeof(A2_CommandData_t)); \
+  CmdData.Type                    = TypeP; \
+  CmdData.ApplicationNr           = ApplicationP; \
+  CmdData.CommandNr               = CommandP; \
+  CmdData.SessionNr               = SessionP; \
+  CmdData.Payload.Size            = SizeP; \
+  CmdData.Payload.Data_p          = NULL; \
+  CmdData.DestAddress             = TargetCPU; \
+  if(SizeP != 0) \
+  { \
+    CmdData.Payload.Data_p = (uint8*)malloc(SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    } \
+  }
+
+ErrorCode_e A2LoaderRpcInterfaceImpl::Do_CEH_Callback(CommandData_t* pCmdData)
+{
+  A2_CommandData_t* CmdData_p = (A2_CommandData_t*)pCmdData;
+  ErrorCode_e ReturnValue = E_GENERAL_FATAL_ERROR;
+  ErrorCode_e ResponseStatus = E_GENERAL_FATAL_ERROR;
+  boolean response = FALSE;
+  const void *Data_p = CmdData_p->Payload.Data_p;
+  uint32 PayloadSize = CmdData_p->Payload.Size;
+  uint16 Session = CmdData_p->SessionNr;
+
+  if (A2_GENERAL_RESPONSE == CmdData_p->Type)
+  {
+    // skip fields already handled by LCM: command group, 0xFF, more packets and original command
+    Data_p = ((uint8*)Data_p) + 4;
+    PayloadSize -= 4;
+    response = TRUE;
+  }
+  else if (A2_COMMAND == CmdData_p->Type)
+  {
+    // skip fields already handled by LCM: command group, command and more packets fields
+    Data_p = ((uint8*)Data_p) + 3;
+    PayloadSize -= 3;
+    response = FALSE;
+  }
+  else if (A2_CONTROL_MESSAGE == CmdData_p->Type)
+  {
+    // skip control message ID
+    Data_p = ((uint8*)Data_p) + 1;
+    PayloadSize -= 1;
+    response = FALSE;
+  }
+  else if (A2_SPEEDFLASH_GR == CmdData_p->Type)
+  {
+    uint16 Status = Serialization::get_uint16_le(&Data_p);
+    lcdMethods_->AddEvent(new Event(EVENT_SPEEDFLASH, Status));
+    return E_SUCCESS;
+  }
+  else
+  {
+    return E_GENERAL_FATAL_ERROR;
+  }
+
+  switch(A2_COMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+  {
+
+  /*
+   * A2 System commands group (0x01)
+   */
+
+    /* Response to A2 System group / Shutdown (1 / 1) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_SHUTDOWN):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_System_ShutdownImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 System group / Loader Version (1 / 2) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERVERSION):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+      const void *LoaderVersionOut = NULL;
+      uint32 LoaderVersionOutPLSize = PayloadSize;
+      if (E_SUCCESS == ResponseStatus)
+      {
+        LoaderVersionOut = Data_p;
+        Serialization::skip_block(&Data_p, LoaderVersionOutPLSize);
+      }
+      ReturnValue = DoneRPC_A2_System_LoaderVersionImpl(Session, ResponseStatus, LoaderVersionOutPLSize, LoaderVersionOut);
+    }
+    break;
+  
+    /* Response to A2 System group / Loader on Loader (1 / 17) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERONLOADER):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_System_LoaderOnLoaderImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 System group / Reset (1 / 19) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_RESET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_System_ResetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * A2 Flash Commands group (0x02)
+   */
+
+    /* Response to A2 Flash group / Verify Signed Header (2 / 1) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSIGNEDHEADER):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_VerifySignedHeaderImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Software Block Address (2 / 2) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_SoftwareBlockAddressImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Program Flash (2 / 3) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_PROGRAMFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_ProgramFlashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Verify Software Flash (2 / 4) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_VerifySoftwareFlashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Erase Flash (2 / 7) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_ERASEFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_EraseFlashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Speedflash (2 / 10) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_SPEEDFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_SpeedflashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * A2 Control message (0x10)
+   */
+
+    /* Command Control message / Loader Started (16 / 1) */ 
+    case A2_COMMAND(FALSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERSTARTED):
+    {
+      uint32 MaxLoaderPacketSize = 0;
+      if (0 != PayloadSize)
+      {
+        MaxLoaderPacketSize = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoRPC_A2_Control_LoaderStartedImpl(Session, MaxLoaderPacketSize);
+    }
+    break;
+  
+    /* Response to Control message / Ping (16 / 2) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PING):
+    {
+
+
+      ReturnValue = DoneRPC_A2_Control_PingImpl(Session);
+    }
+    break;
+  
+    /* Command Control message / Pong (16 / 3) */ 
+    case A2_COMMAND(FALSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PONG):
+    {
+      ReturnValue = DoRPC_A2_Control_PongImpl(Session);
+    }
+    break;
+  
+    /* Response to Control message / Max Packet Size (16 / 4) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_MAXPACKETSIZE):
+    {
+
+      uint16 MaxPacketSize = 0;
+
+      {
+        MaxPacketSize = Serialization::get_uint16_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_A2_Control_MaxPacketSizeImpl(Session, MaxPacketSize);
+    }
+    break;
+  
+    /* Command Control message / Loader Not Started (16 / 5) */ 
+    case A2_COMMAND(FALSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERNOTSTARTED):
+    {
+      uint16 ErrorCode = 0;
+      if (0 != PayloadSize)
+      {
+        ErrorCode = Serialization::get_uint16_le(&Data_p);
+      }
+      ReturnValue = DoRPC_A2_Control_LoaderNotStartedImpl(Session, ErrorCode);
+    }
+    break;
+  
+  default:
+    {
+      return E_COMMAND_NO_ERROR; // Do_CustomCEH_Call(CmdData_p); // when customer commands will be implemented
+    }
+  }
+
+  if (response)
+  {
+    lcdMethods_->AddEvent(new Event(EVENT_GR_RECEIVED, ResponseStatus, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+  }
+  else
+  {
+    lcdMethods_->AddEvent(new Event(EVENT_CMD_RECEIVED, 0, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+  }
+
+  return ReturnValue;
+}
+
+/*
+ * A2 System commands group (0x01)
+ */
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_Shutdown(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_SHUTDOWN, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_SHUTDOWN);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_LoaderVersion(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERVERSION, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_LOADERVERSION);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_LoaderOnLoader(uint16 SessionOut, const uint32 PayloadSize, const void *Payload)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += PayloadSize;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERONLOADER, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_LOADERONLOADER);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_block(&Data_p, Payload, PayloadSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_Reset(uint16 SessionOut, const uint32 Timeout)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += sizeof(uint32);
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_RESET, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_RESET);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_uint32_le(&Data_p, Timeout);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+/*
+ * A2 Flash Commands group (0x02)
+ */
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_VerifySignedHeader(uint16 SessionOut, const uint32 PayloadSize, const void *VerifyHeaderIn)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += PayloadSize;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSIGNEDHEADER, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_VERIFYSIGNEDHEADER);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_block(&Data_p, VerifyHeaderIn, PayloadSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_SoftwareBlockAddress(uint16 SessionOut, const uint32 StartAddress, const uint32 BlockSize)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_uint32_le(&Data_p, StartAddress);
+  Serialization::put_uint32_le(&Data_p, BlockSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_ProgramFlash(uint16 SessionOut, const uint32 PayloadSize, const void *Payload)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += PayloadSize;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_PROGRAMFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_PROGRAMFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_block(&Data_p, Payload, PayloadSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_VerifySoftwareFlash(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_EraseFlash(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_ERASEFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_ERASEFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_Speedflash(uint16 SessionOut, const uint32 StartAddress, const uint32 EndAddress, const uint32 SubBlockSize)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_SPEEDFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_SPEEDFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_uint32_le(&Data_p, StartAddress);
+  Serialization::put_uint32_le(&Data_p, EndAddress);
+  Serialization::put_uint32_le(&Data_p, SubBlockSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+/*
+ * A2 Control message (0x10)
+ */
+
+ErrorCode_e A2LoaderRpcInterface::DoneRPC_A2_Control_LoaderStarted(uint16 Session)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  A2_COMMANDDATA(A2_GENERAL_RESPONSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERSTARTED, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Control_Ping(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PING, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_CONTROL);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_CONTROL_PING);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoneRPC_A2_Control_Pong(uint16 Session)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  A2_COMMANDDATA(A2_GENERAL_RESPONSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PONG, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Control_MaxPacketSize(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_MAXPACKETSIZE, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_CONTROL);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_CONTROL_MAXPACKETSIZE);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoneRPC_A2_Control_LoaderNotStarted(uint16 Session)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  A2_COMMANDDATA(A2_GENERAL_RESPONSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERNOTSTARTED, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/command_ids.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/command_ids.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/command_ids.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/command_ids.h	2011-11-01 10:47:59.013732228 +0100
@@ -0,0 +1,93 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMAND_IDS_H
+#define _COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+typedef enum {
+  GROUP_SYSTEM = 1, /**< System application */
+  GROUP_FLASH = 2, /**< Flash application */
+  GROUP_FILE_SYSTEM_OPERATIONS = 3, /**< File system operations */
+  GROUP_OTP = 4, /**< OTP */
+  GROUP_PARAMETERSTORAGE = 5, /**< Parameter Storage */
+  GROUP_SECURITY = 6, /**< Security */
+} GroupId_e;
+
+typedef enum {
+  COMMAND_SYSTEM_LOADERSTARTUPSTATUS = 1, /**< Loader Start-up Status */
+  COMMAND_SYSTEM_REBOOT = 3, /**< System Reboot */
+  COMMAND_SYSTEM_SHUTDOWN = 4, /**< System Shutdown */
+  COMMAND_SYSTEM_SUPPORTEDCOMMANDS = 5, /**< System Supported Command */
+  COMMAND_SYSTEM_EXECUTESOFTWARE = 6, /**< System Execute Software */
+  COMMAND_SYSTEM_AUTHENTICATE = 7, /**< System Authenticate */
+  COMMAND_SYSTEM_GETCONTROLKEYS = 8, /**< System Get Control Keys */
+  COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE = 9, /**< System Authentication Challenge */
+  COMMAND_SYSTEM_COLLECTDATA = 10, /**< System Collect Data */
+  COMMAND_SYSTEM_GETPROGRESSSTATUS = 11, /**< System Get Progress Status */
+  COMMAND_SYSTEM_SETSYSTEMTIME = 12, /**< Set System Time */
+  COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE = 13, /**< Switch Communication Device */
+  COMMAND_SYSTEM_GETCONTROLKEYSDATA = 14, /**< System Get Control Keys Data */
+  COMMAND_SYSTEM_STARTCOMMRELAY = 15, /**< System Start Communication Relay */
+  COMMAND_FLASH_PROCESSFILE = 1, /**< Process File */
+  COMMAND_FLASH_LISTDEVICES = 2, /**< List Devices */
+  COMMAND_FLASH_DUMPAREA = 3, /**< Dump Area */
+  COMMAND_FLASH_ERASEAREA = 4, /**< Erase Area */
+  COMMAND_FLASH_FLASHRAW = 5, /**< Flash RAW */
+  COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES = 2, /**< Volume Properties */
+  COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME = 3, /**< Format Volume */
+  COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY = 4, /**< List Directory */
+  COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE = 5, /**< Move File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE = 6, /**< Delete File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE = 7, /**< Copy File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY = 8, /**< Create Directory */
+  COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES = 9, /**< Properties (Stat) */
+  COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS = 10, /**< Change Access (Chmod) */
+  COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS = 11, /**< Read Load Modules Manifests */
+  COMMAND_OTP_READBITS = 1, /**< Read Bits */
+  COMMAND_OTP_SETBITS = 2, /**< Set Bits */
+  COMMAND_OTP_WRITEANDLOCK = 3, /**< Write and Lock OTP */
+  COMMAND_OTP_STORESECUREOBJECT = 4, /**< Store Secure Object */
+  COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT = 1, /**< Read Global Data Unit */
+  COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT = 2, /**< Write Global Data Unit */
+  COMMAND_PARAMETERSTORAGE_READGLOBALDATASET = 3, /**< Read Global Data Set */
+  COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET = 4, /**< Write Global Data Set */
+  COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET = 5, /**< Erase Global Data Set */
+  COMMAND_SECURITY_SETDOMAIN = 1, /**< Set Domain */
+  COMMAND_SECURITY_GETDOMAIN = 2, /**< Get Domain */
+  COMMAND_SECURITY_GETPROPERTIES = 3, /**< Get Properties */
+  COMMAND_SECURITY_SETPROPERTIES = 4, /**< Set Properties */
+  COMMAND_SECURITY_BINDPROPERTIES = 5, /**< Bind Properties */
+} CommandId_e;
+
+typedef struct SupportedCommand_s
+{
+  uint32 Group; /**< Application Group number */
+  uint32 Command; /**< Command number */
+  uint32 Permitted; /**< Permission value */
+}SupportedCommand_t;
+
+typedef struct ListDevice_s
+{
+  char Path_p[256]; /**< Absolute device path pointing of the described device */
+  char Type_p[256]; /**< Type of the device */
+  uint64 BlockSize; /**< Size of the smallest addressable unit in the device in bytes */
+  uint64 Start; /**< Offset in bytes of the start of the device relative to its parents offset 0 with a granularity of its parents block size */
+  uint64 Length; /**< Length of the device in bytes */
+}ListDevice_t;
+
+typedef struct DirEntry_s
+{
+  char *Name_p; /**< Name of file or directory */
+  uint64 Size; /**< Size of file or directory */
+  uint32 Mode; /**< Indicator if it is file or directory */
+  uint32 Time; /**< Time of last modification */
+}DirEntry_t;
+
+typedef struct Cipher_s
+{
+  char *Name_p; /**< supported ciphers */
+}Cipher_t;
+
+
+#endif /* _COMMAND_IDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/commands.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/commands.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/commands.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/commands.h	2011-11-01 10:47:58.989732688 +0100
@@ -0,0 +1,588 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_H_
+#define _COMMANDS_H_
+
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "t_basicdefinitions.h"
+#include "CmdResult.h"
+
+class CLCDriverMethods;
+
+class LoaderRpcInterface
+{
+public:
+  LoaderRpcInterface(CLCDriverMethods* lcdMethods, CmdResult* cmdResult, LcmInterface* lcmInterface):
+    cmdResult_(cmdResult),
+    lcmInterface_(lcmInterface),
+    lcdMethods_(lcdMethods)
+  {
+  }
+
+  virtual ~LoaderRpcInterface()
+  {
+  }
+
+  /*
+   * System commands group (0x01)
+   */
+
+  /**
+   * Response to \see DoRPC_System_LoaderStartUpStatusImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_LoaderStartUpStatus(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * The Reboot command is used to instruct the Loader to reset the ME. Upon receiving this command, the Loader shuts down in a controlled fashion and restarts the ME. The Mode parameter is used to select the mode of reset.
+   * \see DoneRPC_System_RebootImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Mode 0 = normal restart, 1 = restart in service mode, 2 = restart with JTAG debugging enabled, 3 = restart in service mode and with JTAG debugging enabled
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_Reboot(uint16 SessionOut, const uint32 Mode);
+  
+  /**
+   * The Loader shuts down in a controlled fashion and proceeds to shut down the ME itself.
+   * \see DoneRPC_System_ShutDownImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_ShutDown(uint16 SessionOut);
+  
+  /**
+   * The Loader returns a list of implemented commands and whether they are permitted to execute in the current Loader state. Further fine-grained permission controls might also deny execution of a specific command.
+   * \see DoneRPC_System_SupportedCommandsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_SupportedCommands(uint16 SessionOut);
+  
+  /**
+   * Receive, verify and execute software, which can be a signed Loader. After having sent this command, the ME will attempt to read the software payload data from the host using the Bulk protocol or from the flash file system depending on the selected path.
+   * \see DoneRPC_System_ExecuteSoftwareImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] ExecuteMode Execute mode: 1 = execution from specified address, 2 = first load the software then execute.
+   * @param [in] SourcePath_p File system or Bulk id path
+   * @param [in] Length Total length of the execute software file
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_ExecuteSoftware(uint16 SessionOut, const uint32 ExecuteMode, const char *SourcePath_p, const uint64 Length);
+  
+  /**
+   * This command is used to escalate the privileges of the operator. Two modes of authentication are available by default; Control Key authentication and Certificate based authentication. The authentication command sets the loader in a specific authentication context when it takes control over the command flow. After receiving the authentication command, the Loader will send the appropriate request for information to the PC.
+   * \see DoneRPC_System_AuthenticateImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Type Authentication type: 0 = Control Key authentication, 1 = Certificate authentication.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_Authenticate(uint16 SessionOut, const uint32 Type);
+  
+  /**
+   * Response to \see DoRPC_System_GetControlKeysImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] NLCKLock_p 
+   * @param [in] NSLCKLock_p 
+   * @param [in] SPLCKLock_p 
+   * @param [in] CLCKLock_p 
+   * @param [in] PCKLock_p 
+   * @param [in] ESLCKLock_p 
+   * @param [in] NLCKUnlock_p 
+   * @param [in] NSLCKUnlock_p 
+   * @param [in] SPLCKUnlock_p 
+   * @param [in] CLCKUnlock_p 
+   * @param [in] PCKUnlock_p 
+   * @param [in] ESLCKUnlock_p 
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_GetControlKeys(uint16 Session, ErrorCode_e Status, const char *NLCKLock_p, const char *NSLCKLock_p, const char *SPLCKLock_p, const char *CLCKLock_p, const char *PCKLock_p, const char *ESLCKLock_p, const char *NLCKUnlock_p, const char *NSLCKUnlock_p, const char *SPLCKUnlock_p, const char *CLCKUnlock_p, const char *PCKUnlock_p, const char *ESLCKUnlock_p);
+  
+  /**
+   * Response to \see DoRPC_System_AuthenticationChallengeImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] ResponseBlockLength Updated authentication challenge buffer length
+   * @param [in] ResponseBlock_p Signed authentication challenge together with the requested permissions.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_AuthenticationChallenge(uint16 Session, ErrorCode_e Status, const uint32 ResponseBlockLength, const void *ResponseBlock_p);
+  
+  /**
+   * This command is used to collect printouts (debug data) and measurements results.
+   * \see DoneRPC_System_CollectDataImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Type Type of requested data.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_CollectData(uint16 SessionOut, const uint32 Type);
+  
+  /**
+   * This command is used by the Loader to get the minimal progress status from all running commands.
+   * \see DoneRPC_System_GetProgressStatusImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_GetProgressStatus(uint16 SessionOut);
+  
+  /**
+   * The Set System Time command is used to instruct the Loader to use real world time and date during its run time. Upon receiving this command, the Loader sets internal Real Time Clock. This command can be issued more then once by PC tool.
+   * \see DoneRPC_System_SetSystemTimeImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] EpochTime Number of seconds since January 1, 1970 (midnight UTC/GMT).
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_SetSystemTime(uint16 SessionOut, const uint32 EpochTime);
+  
+  /**
+   * This command is used to instruct the Loader to switch to a new communication device.
+   * \see DoneRPC_System_SwitchCommunicationDeviceImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Device Communication device number to switch to.
+   * @param [in] DeviceParam Communication device parameters.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_SwitchCommunicationDevice(uint16 SessionOut, const uint32 Device, const uint32 DeviceParam);
+  
+  /**
+   * Response to \see DoRPC_System_GetControlKeysDataImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] iDataSize Length of output buffer.
+   * @param [in] SIMLockKeysData_p Data buffer with all SIMLock keys.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_GetControlKeysData(uint16 Session, ErrorCode_e Status, const uint32 iDataSize, const void *SIMLockKeysData_p);
+  
+  /**
+   * The Loader shuts down the global communication and enters in a Relay working mode.
+   * \see DoneRPC_System_StartCommRelayImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] HostDeviceId Communication device number of the relay input (host device).
+   * @param [in] TargetDeviceId Communication device number of the relay ouptut (target device).
+   * @param [in] ControlDeviceId Communication device number for the loader commands (control device).
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_StartCommRelay(uint16 SessionOut, const uint32 HostDeviceId, const uint32 TargetDeviceId, const uint32 ControlDeviceId);
+  
+  /*
+   * Flash Commands group (0x02)
+   */
+
+  /**
+   * This command is used to initiate a flashing session. The Type argument is used to select the type of file to process and Length parameter defines the total size of the file.
+   * \see DoneRPC_Flash_ProcessFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Length Total length of the opened file
+   * @param [in] Type_p Type of the opened file. Currently the only supported type is    x-empflash/flasharchive   
+   * @param [in] SourcePath_p File system or Bulk id path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_ProcessFile(uint16 SessionOut, const uint64 Length, const char *Type_p, const char *SourcePath_p);
+  
+  /**
+   * The Loader returns a list of detected block devices. A block device can be a physical device ( flash0 , mmc0 , usb0 ), a logical device ( cabs0 , mbbs0 ) or a file system volume ( boot , sys ). Together they form paths on the form /flash0/mbbs0 or /flash1/cabs1/vfat .
+   * \see DoneRPC_Flash_ListDevicesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_ListDevices(uint16 SessionOut);
+  
+  /**
+   * This command is used to initiate a Dump session.
+   * \see DoneRPC_Flash_DumpAreaImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p Path to the device to dump.
+   * @param [in] Start Start of the dump relative to the start of the device indicated by Path in bytes. Actual start is determined by the Mode parameter.
+   * @param [in] Length Length of the dump in bytes. Actual length is determined by the Mode parameter.
+   * @param [in] TargetPath_p File system or bulk id path.
+   * @param [in] RedundantArea If set to 0 dump flash including redundant area, if set to 1 dump flash without redundant area.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_DumpArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length, const char *TargetPath_p, const uint32 RedundantArea);
+  
+  /**
+   * This command is used to erase a flash device or part of a flash device.
+   * \see DoneRPC_Flash_EraseAreaImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p Path to the device to erase.
+   * @param [in] Start Start of the dump relative to the start of the device indicated by Path in bytes. This must be a multiple of the block size of the device.
+   * @param [in] Length Length of the dump in bytes. This must be a multiple of the block size of the device.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_EraseArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length);
+  
+  /**
+   * This command is used to flash raw flash image.
+   * \see DoneRPC_Flash_FlashRawImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Start Address where RAW image should be written. This must be a multiple of the block size of the device.
+   * @param [in] Length Length of RAW data in bytes
+   * @param [in] Device Target flash device.[0,1]
+   * @param [in] SourcePath_p Bulk id path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_FlashRaw(uint16 SessionOut, const uint64 Start, const uint64 Length, const uint32 Device, const char *SourcePath_p);
+  
+  /*
+   * File System Commands Group (0x03)
+   */
+
+  /**
+   * Retrieve properties of the specified file system volume
+   * \see DoneRPC_File_System_Operations_VolumePropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p Path of file system volume
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_VolumeProperties(uint16 SessionOut, const char *DevicePath_p);
+  
+  /**
+   * Formats an unmounted file system volume. This operation fails if the volume is currently in use.
+   * \see DoneRPC_File_System_Operations_FormatVolumeImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p Device path of the file system volume
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_FormatVolume(uint16 SessionOut, const char *DevicePath_p);
+  
+  /**
+   * List files and directories residing in a specified path
+   * \see DoneRPC_File_System_Operations_ListDirectoryImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_ListDirectory(uint16 SessionOut, const char *Path_p);
+  
+  /**
+   * Moves or renames a file.
+   * \see DoneRPC_File_System_Operations_MoveFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] SourcePath_p File system path (source)
+   * @param [in] DestinationPath_p File system path (destination)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_MoveFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p);
+  
+  /**
+   * Deletes the specified file or directory. The Loader will only delete empty directories.
+   * \see DoneRPC_File_System_Operations_DeleteFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_DeleteFile(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Copies a file from the PC to the ME, between two directories or file systems on the ME or from the ME to the PC.
+   * \see DoneRPC_File_System_Operations_CopyFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] SourcePath_p File system or bulk id path (source)
+   * @param [in] DestinationPath_p File system or bulk id path (destination)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_CopyFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p);
+  
+  /**
+   * Creates a directory
+   * \see DoneRPC_File_System_Operations_CreateDirectoryImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_CreateDirectory(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_PropertiesImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] Mode File Type and Access restrictions descriptor (see 5.1)
+   * @param [in] Size File size in bytes
+   * @param [in] MTime Last modification time stamp
+   * @param [in] ATime Last access time stamp
+   * @param [in] CTime Creation time stamp
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_Properties(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime);
+  
+  /**
+   * Retrieves the properties of a file or directory
+   * \see DoneRPC_File_System_Operations_PropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_Properties(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Changes the access permissions of a path
+   * \see DoneRPC_File_System_Operations_ChangeAccessImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * @param [in] Access New access permissions
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_ChangeAccess(uint16 SessionOut, const char *TargetPath_p, const uint32 Access);
+  
+  /**
+   * Read all manifests in elf files and send it to PC
+   * \see DoneRPC_File_System_Operations_ReadLoadModulesManifestsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_ReadLoadModulesManifests(uint16 SessionOut, const char *TargetPath_p);
+  
+  /*
+   * OTP handling commands Group (0x04)
+   */
+
+  /**
+   * Reads the specified bits from the OTP
+   * \see DoneRPC_OTP_ReadBitsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] OTP_id Indicates which OTP memory is to be read
+   * @param [in] Start Starting offset in bits
+   * @param [in] Length Length of read in bits
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_ReadBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 Length);
+  
+  /**
+   * Writes and locks the specified bits in the OTP
+   * \see DoneRPC_OTP_SetBitsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] OTP_id Indicates which OTP memory is to be read
+   * @param [in] Start Starting offset in bits
+   * @param [in] BitsLength Length of write in bits
+   * @param [in] DataBitsLength Length of DataBits buffer
+   * @param [in] DataBits_p Left-adjusted byte buffer containing the data to be written. Only Length bits will be written.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_SetBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 BitsLength, const uint32 DataBitsLength, const void *DataBits_p);
+  
+  /**
+   * Writes and locks the specified bits in the OTP
+   * \see DoneRPC_OTP_WriteAndLockImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] OTP_id Indicates which OTP memory is to be written and locked
+   * @param [in] ForceWrite If = 0 - Write only complete lockable areas. If != 0 Write complete lockable areas even if not all bit are received in cache. 
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_WriteAndLock(uint16 SessionOut, const uint32 OTP_id, const uint32 ForceWrite);
+  
+  /**
+   * Installs Secure objects into OTP or Flash
+   * \see DoneRPC_OTP_StoreSecureObjectImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] SourcePath File system or bulk id path
+   * @param [in] SecureObjectDestination Secure Object destination address
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_StoreSecureObject(uint16 SessionOut, const char *SourcePath, const uint32 SecureObjectDestination);
+  
+  /*
+   * Parameter Storage Commands Group (0x05)
+   */
+
+  /**
+   * Reads the specified unit from Global Data area
+   * \see DoneRPC_ParameterStorage_ReadGlobalDataUnitImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to read from (gdfs, trim area)
+   * @param [in] Unit_id Unit id to read
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_ReadGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id);
+  
+  /**
+   * Writes the specified unit to Global Data area
+   * \see DoneRPC_ParameterStorage_WriteGlobalDataUnitImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to write to (gdfs, trim area)
+   * @param [in] Unit_id Unit id to write
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The data to write
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_WriteGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Reads a complete Global Data area
+   * \see DoneRPC_ParameterStorage_ReadGlobalDataSetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to read (gdfs, trim area)
+   * @param [in] TargetPath_p File system or bulk id path indicating the destination of the read operation
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_ReadGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const char *TargetPath_p);
+  
+  /**
+   * Writes a complete Global Data area
+   * \see DoneRPC_ParameterStorage_WriteGlobalDataSetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to write (gdfs, trim area)
+   * @param [in] DataLength Data Length when is used bulk transfer 
+   * @param [in] SourcePath_p File system or bulk id path indicating the source of the write operation
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_WriteGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const uint64 DataLength, const char *SourcePath_p);
+  
+  /**
+   * Erases a complete Global Data area
+   * \see DoneRPC_ParameterStorage_EraseGlobalDataSetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to erase (gdfs, trim area)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_EraseGlobalDataSet(uint16 SessionOut, const char *DevicePath_p);
+  
+  /*
+   * Security settings Commands Group (0x06)
+   */
+
+  /**
+   * Set the ME domain
+   * \see DoneRPC_Security_SetDomainImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Domain Target domain
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_SetDomain(uint16 SessionOut, const uint32 Domain);
+  
+  /**
+   * Get the ME domain
+   * \see DoneRPC_Security_GetDomainImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_GetDomain(uint16 SessionOut);
+  
+  /**
+   * Reads a security data unit (such as a secure static or dynamic data unit)
+   * \see DoneRPC_Security_GetPropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Unit_id Unit id to read
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_GetProperties(uint16 SessionOut, const uint32 Unit_id);
+  
+  /**
+   * Writes a security data unit (such as a secure static or dynamic data unit)
+   * \see DoneRPC_Security_SetPropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Unit_id Unit id to write
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The data to write
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_SetProperties(uint16 SessionOut, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Associates all security data units with the current ME
+   * \see DoneRPC_Security_BindPropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_BindProperties(uint16 SessionOut);
+  
+protected:
+  CmdResult* cmdResult_;
+  LcmInterface* lcmInterface_;
+  CLCDriverMethods* lcdMethods_;
+};
+
+#endif /* _COMMANDS_H_ */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/commands_impl.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/commands_impl.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/commands_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/commands_impl.h	2011-11-01 10:47:58.993732773 +0100
@@ -0,0 +1,522 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_IMPL_H_
+#define _COMMANDS_IMPL_H_
+
+#include "commands.h"
+#include "command_ids.h"
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "error_codes.h"
+
+class LoaderRpcInterfaceImpl : public LoaderRpcInterface 
+{
+public:
+	LoaderRpcInterfaceImpl(CLCDriverMethods* lcdMethods, CmdResult* CmdResult, LcmInterface* LcmInterface):
+    LoaderRpcInterface(lcdMethods, CmdResult, LcmInterface) {}
+	~LoaderRpcInterfaceImpl() {}
+
+	ErrorCode_e	Do_CEH_Callback(CommandData_t * pCmdData);
+
+  /*
+   * System commands group (0x01)
+   */
+
+  /**
+   * The Loader Start-up Status command is sent by the ME to notify the host that it has started. The Status parameter indicates in what mode the Loader started.
+   * \see DoneRPC_System_LoaderStartUpStatus
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] Status 0 = started successfully, 1 = failed to start (lack of permissions), 2 = software module failed to initialize
+   * @param [in] LoaderVersion_p Loader version identifier
+   * @param [in] ProtocolVersion_p Protocol version identifier
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_LoaderStartUpStatusImpl(uint16 Session, const uint32 Status, const char *LoaderVersion_p, const char *ProtocolVersion_p);
+  
+  /**
+   * Response to \see DoRPC_System_Reboot
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_RebootImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_ShutDown
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_ShutDownImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_SupportedCommands
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] CommandCount Number of implemented commands
+   * @param [in] Commands An array of command identifiers. The Permitted field indicates whether the command can be executed at the current time (non-zero value means allowed)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_SupportedCommandsImpl(uint16 Session, ErrorCode_e Status, const uint32 CommandCount, SupportedCommand_t *Commands);
+  
+  /**
+   * Response to \see DoRPC_System_ExecuteSoftware
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_ExecuteSoftwareImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_Authenticate
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_AuthenticateImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * This command is used by the Loader to retrieve the SimLock Control Keys from the host in order to authenticate a user. The command is used in authentication context.
+   * \see DoneRPC_System_GetControlKeys
+   * Call source: ME
+   * @param [in] Session Input session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_GetControlKeysImpl(uint16 Session);
+  
+  /**
+   * This command is used by the Loader to perform a certificate authentication. The command is only used in authentication context.
+   * \see DoneRPC_System_AuthenticationChallenge
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] ChallengeBlockLength Authentication Challenge buffer length
+   * @param [in] ChallengeBlock_p Authentication Challenge that must be signed using the correct certificate and returned to the Loader
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_AuthenticationChallengeImpl(uint16 Session, const uint32 ChallengeBlockLength, const void *ChallengeBlock_p);
+  
+  /**
+   * Response to \see DoRPC_System_CollectData
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DataLenght Length of output buffer.
+   * @param [in] CollectedData_p Output data buffer. Contain debug data (printouts) or measurement data.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_CollectDataImpl(uint16 Session, ErrorCode_e Status, const uint32 DataLenght, const void *CollectedData_p);
+  
+  /**
+   * Response to \see DoRPC_System_GetProgressStatus
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] ProgressStatus Command progress status presented in percent.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_GetProgressStatusImpl(uint16 Session, ErrorCode_e Status, const uint32 ProgressStatus);
+  
+  /**
+   * Response to \see DoRPC_System_SetSystemTime
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_SetSystemTimeImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_SwitchCommunicationDevice
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_SwitchCommunicationDeviceImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * This command is used by the Loader to retrieve the SimLock Control Keys data buffer from the host in order to authenticate a user. The command is used in authentication context.
+   * \see DoneRPC_System_GetControlKeysData
+   * Call source: ME
+   * @param [in] Session Input session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_GetControlKeysDataImpl(uint16 Session);
+  
+  /**
+   * Response to \see DoRPC_System_StartCommRelay
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_StartCommRelayImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * Flash Commands group (0x02)
+   */
+
+  /**
+   * Response to \see DoRPC_Flash_ProcessFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_ProcessFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_ListDevices
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DeviceCount Indicates the number of returned devices
+   * @param [in] Devices Absolute device path, Type of the device, Block Size, Start address of the device, Length of the device
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_ListDevicesImpl(uint16 Session, ErrorCode_e Status, const uint32 DeviceCount, ListDevice_t *Devices);
+  
+  /**
+   * Response to \see DoRPC_Flash_DumpArea
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_DumpAreaImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_EraseArea
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_EraseAreaImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_FlashRaw
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_FlashRawImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * File System Commands Group (0x03)
+   */
+
+  /**
+   * Response to \see DoRPC_File_System_Operations_VolumeProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] FS_Type_p File system type
+   * @param [in] Size Total size of the file system (in bytes)
+   * @param [in] Free Available space (in bytes)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_VolumePropertiesImpl(uint16 Session, ErrorCode_e Status, const char *FS_Type_p, const uint64 Size, const uint64 Free);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_FormatVolume
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_FormatVolumeImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_ListDirectory
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] EntriesCount Number of directory entries
+   * @param [in] Entries Name and Size of file or directory, Mode as indicator if it is file or directory, Time of last modification
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_ListDirectoryImpl(uint16 Session, ErrorCode_e Status, const uint32 EntriesCount, DirEntry_t *Entries);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_MoveFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_MoveFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_DeleteFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_DeleteFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_CopyFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_CopyFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_CreateDirectory
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_CreateDirectoryImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_Properties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] Mode File Type and Access restrictions descriptor (see 5.1)
+   * @param [in] Size File size in bytes
+   * @param [in] MTime Last modification time stamp
+   * @param [in] ATime Last access time stamp
+   * @param [in] CTime Creation time stamp
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_PropertiesImpl(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime);
+  
+  /**
+   * Retrieves the properties of a file or directory
+   * \see DoneRPC_File_System_Operations_Properties
+   * Call source: ME
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_PropertiesImpl(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_ChangeAccess
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_ChangeAccessImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_ReadLoadModulesManifests
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_ReadLoadModulesManifestsImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * OTP handling commands Group (0x04)
+   */
+
+  /**
+   * Response to \see DoRPC_OTP_ReadBits
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] BitsLength Length of read bits
+   * @param [in] DataBitsLength Length of the DataBits buffer
+   * @param [in] DataBits_p A left-adjusted buffer of the read data. Padded with zeroes. Length of returned value (in bytes), equal to floor((Length + 7) / 8). 
+   * @param [in] LockStatusBitsLength Length of the LockStatus of read bits
+   * @param [in] LockStatusLength Length of the LockStatus buffer
+   * @param [in] LockStatus_p A left-adjusted buffer of the lock status of each read bit. Padded with zeroes. Length of returned value (in bytes), equal to floor((Length + 7) / 8). 
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_ReadBitsImpl(uint16 Session, ErrorCode_e Status, const uint32 BitsLength, const uint32 DataBitsLength, const void *DataBits_p, const uint32 LockStatusBitsLength, const uint32 LockStatusLength, const void *LockStatus_p);
+  
+  /**
+   * Response to \see DoRPC_OTP_SetBits
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_SetBitsImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_OTP_WriteAndLock
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_WriteAndLockImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_OTP_StoreSecureObject
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_StoreSecureObjectImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * Parameter Storage Commands Group (0x05)
+   */
+
+  /**
+   * Response to \see DoRPC_ParameterStorage_ReadGlobalDataUnit
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The read data
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_ReadGlobalDataUnitImpl(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_WriteGlobalDataUnit
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_WriteGlobalDataUnitImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_ReadGlobalDataSet
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_ReadGlobalDataSetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_WriteGlobalDataSet
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_WriteGlobalDataSetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_EraseGlobalDataSet
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_EraseGlobalDataSetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * Security settings Commands Group (0x06)
+   */
+
+  /**
+   * Response to \see DoRPC_Security_SetDomain
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_SetDomainImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Security_GetDomain
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] CurrentDomain The ME Domain
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_GetDomainImpl(uint16 Session, ErrorCode_e Status, const uint32 CurrentDomain);
+  
+  /**
+   * Response to \see DoRPC_Security_GetProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The unit data
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_GetPropertiesImpl(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Response to \see DoRPC_Security_SetProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_SetPropertiesImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Security_BindProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_BindPropertiesImpl(uint16 Session, ErrorCode_e Status);
+  
+};
+
+#endif /* _COMMANDS_IMPL_H_ */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/commands_marshal.cpp riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/commands_marshal.cpp
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/commands_marshal.cpp	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/commands_marshal.cpp	2011-11-01 10:47:59.265645434 +0100
@@ -0,0 +1,1697 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "t_command_protocol.h"
+#include "commands.h"
+//#include "custom_commands.h" // when customer commands will be implemented
+#include "command_ids.h"
+#include "commands_impl.h"
+#include "error_codes.h"
+#include "Serialization.h"
+#include "t_r15_network_layer.h"
+#include "Event.h"
+#include "LCDriverMethods.h"
+
+#define COMMAND(response, group, id) ((((int)(response)) << 30) | (((int)(group)) << 16) | ((int)(id))) 
+#define COMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t)); \
+  CmdData.Type             = TypeP; \
+  CmdData.ApplicationNr    = ApplicationP; \
+  CmdData.CommandNr        = CommandP; \
+  CmdData.SessionNr        = SessionP; \
+  CmdData.Payload.Size     = SizeP; \
+  CmdData.Payload.Data_p   = NULL; \
+  if(SizeP != 0)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc(sizeof(ErrorCode_e)+SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    }\
+  }
+
+#define COMMANDDATAOUT(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t)); \
+  CmdData.Type                    = TypeP; \
+  CmdData.ApplicationNr           = ApplicationP; \
+  CmdData.CommandNr               = CommandP; \
+  CmdData.SessionNr               = SessionP; \
+  CmdData.Payload.Size            = SizeP; \
+  CmdData.Payload.Data_p          = NULL; \
+  if(SizeP != 0)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc( SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    }\
+  }
+
+  ErrorCode_e LoaderRpcInterfaceImpl::Do_CEH_Callback(CommandData_t *CmdData_p)
+  {
+    ErrorCode_e ReturnValue = E_GENERAL_FATAL_ERROR;
+    ErrorCode_e ResponseStatus = E_GENERAL_FATAL_ERROR;
+    boolean response = FALSE;
+    const void *Data_p = CmdData_p->Payload.Data_p;
+    uint16 Session = CmdData_p->SessionNr;
+  
+    if (CmdData_p->Type == GENERAL_RESPONSE_PACKAGE)
+    {
+      response = TRUE;
+    }
+    else
+    {
+      response = FALSE;
+    }
+
+    Session = CmdData_p->SessionNr;
+
+    switch(COMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+    {
+
+  /*
+   * System commands group (0x01)
+   */
+
+    /* Command System application / Loader Start-up Status (1 / 1) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_LOADERSTARTUPSTATUS):
+    {
+      uint32 Status = 0;
+      const char *LoaderVersion_p = NULL;
+      const char *ProtocolVersion_p = NULL;
+        Status = Serialization::get_uint32_le(&Data_p);
+        LoaderVersion_p = Serialization::skip_str(&Data_p);
+        ProtocolVersion_p = Serialization::skip_str(&Data_p);
+      ReturnValue = DoRPC_System_LoaderStartUpStatusImpl(Session, Status, LoaderVersion_p, ProtocolVersion_p);
+    }
+    break;
+  
+    /* Response to System application / System Reboot (1 / 3) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_REBOOT):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_RebootImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Shutdown (1 / 4) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SHUTDOWN):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_ShutDownImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Supported Command (1 / 5) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SUPPORTEDCOMMANDS):
+    {
+      uint32 CommandCount = 0;
+      SupportedCommand_t *Commands = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        CommandCount = Serialization::get_uint32_le(&Data_p);
+        Commands = Serialization::get_supportedcommands(&Data_p, CommandCount);
+      }
+      ReturnValue = DoneRPC_System_SupportedCommandsImpl(Session, ResponseStatus, CommandCount, Commands);
+    }
+    break;
+  
+    /* Response to System application / System Execute Software (1 / 6) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_EXECUTESOFTWARE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_ExecuteSoftwareImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Authenticate (1 / 7) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_AuthenticateImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Command System application / System Get Control Keys (1 / 8) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYS):
+    {
+      ReturnValue = DoRPC_System_GetControlKeysImpl(Session);
+    }
+    break;
+  
+    /* Command System application / System Authentication Challenge (1 / 9) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE):
+    {
+      uint32 ChallengeBlockLength = 0;
+      const void *ChallengeBlock_p = NULL;
+        ChallengeBlockLength = Serialization::get_uint32_le(&Data_p);
+        ChallengeBlock_p = Data_p;
+        Serialization::skip_block(&Data_p, ChallengeBlockLength);
+      ReturnValue = DoRPC_System_AuthenticationChallengeImpl(Session, ChallengeBlockLength, ChallengeBlock_p);
+    }
+    break;
+  
+    /* Response to System application / System Collect Data (1 / 10) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_COLLECTDATA):
+    {
+      uint32 DataLenght = 0;
+      const void *CollectedData_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DataLenght = Serialization::get_uint32_le(&Data_p);
+        CollectedData_p = Data_p;
+        Serialization::skip_block(&Data_p, DataLenght);
+      }
+      ReturnValue = DoneRPC_System_CollectDataImpl(Session, ResponseStatus, DataLenght, CollectedData_p);
+    }
+    break;
+  
+    /* Response to System application / System Get Progress Status (1 / 11) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_GETPROGRESSSTATUS):
+    {
+      uint32 ProgressStatus = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        ProgressStatus = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_System_GetProgressStatusImpl(Session, ResponseStatus, ProgressStatus);
+    }
+    break;
+  
+    /* Response to System application / Set System Time (1 / 12) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SETSYSTEMTIME):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_SetSystemTimeImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / Switch Communication Device (1 / 13) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_SwitchCommunicationDeviceImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Command System application / System Get Control Keys Data (1 / 14) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYSDATA):
+    {
+      ReturnValue = DoRPC_System_GetControlKeysDataImpl(Session);
+    }
+    break;
+  
+    /* Response to System application / System Start Communication Relay (1 / 15) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_STARTCOMMRELAY):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_StartCommRelayImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * Flash Commands group (0x02)
+   */
+
+    /* Response to Flash application / Process File (2 / 1) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_PROCESSFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_ProcessFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / List Devices (2 / 2) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_LISTDEVICES):
+    {
+      uint32 DeviceCount = 0;
+      ListDevice_t *Devices = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DeviceCount = Serialization::get_uint32_le(&Data_p);
+        Devices = Serialization::get_devices(&Data_p, DeviceCount);
+      }
+      ReturnValue = DoneRPC_Flash_ListDevicesImpl(Session, ResponseStatus, DeviceCount, Devices);
+    }
+    break;
+  
+    /* Response to Flash application / Dump Area (2 / 3) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_DUMPAREA):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_DumpAreaImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / Erase Area (2 / 4) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_ERASEAREA):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_EraseAreaImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / Flash RAW (2 / 5) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_FLASHRAW):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_FlashRawImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * File System Commands Group (0x03)
+   */
+
+    /* Response to File system operations / Volume Properties (3 / 2) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES):
+    {
+      const char *FS_Type_p = NULL;
+      uint64 Size = 0;
+      uint64 Free = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        FS_Type_p = Serialization::skip_str(&Data_p);
+        Size = Serialization::get_uint64_le(&Data_p);
+        Free = Serialization::get_uint64_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_File_System_Operations_VolumePropertiesImpl(Session, ResponseStatus, FS_Type_p, Size, Free);
+    }
+    break;
+  
+    /* Response to File system operations / Format Volume (3 / 3) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_FormatVolumeImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / List Directory (3 / 4) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY):
+    {
+      uint32 EntriesCount = 0;
+      DirEntry_t *Entries = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        EntriesCount = Serialization::get_uint32_le(&Data_p);
+        Entries = Serialization::get_direntries(&Data_p, EntriesCount);
+      }
+      ReturnValue = DoneRPC_File_System_Operations_ListDirectoryImpl(Session, ResponseStatus, EntriesCount, Entries);
+    }
+    break;
+  
+    /* Response to File system operations / Move File (3 / 5) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_MoveFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Delete File (3 / 6) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_DeleteFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Copy File (3 / 7) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_CopyFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Create Directory (3 / 8) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_CreateDirectoryImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Properties (Stat) (3 / 9) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES):
+    {
+      uint32 Mode = 0;
+      uint64 Size = 0;
+      uint32 MTime = 0;
+      uint32 ATime = 0;
+      uint32 CTime = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        Mode = Serialization::get_uint32_le(&Data_p);
+        Size = Serialization::get_uint64_le(&Data_p);
+        MTime = Serialization::get_uint32_le(&Data_p);
+        ATime = Serialization::get_uint32_le(&Data_p);
+        CTime = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_File_System_Operations_PropertiesImpl(Session, ResponseStatus, Mode, Size, MTime, ATime, CTime);
+    }
+    break;
+  
+    /* Command File system operations / Properties (Stat) (3 / 9) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES):
+    {
+      const char *TargetPath_p = NULL;
+        TargetPath_p = Serialization::skip_str(&Data_p);
+      ReturnValue = DoRPC_File_System_Operations_PropertiesImpl(Session, TargetPath_p);
+    }
+    break;
+  
+    /* Response to File system operations / Change Access (Chmod) (3 / 10) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_ChangeAccessImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Read Load Modules Manifests (3 / 11) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_ReadLoadModulesManifestsImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * OTP handling commands Group (0x04)
+   */
+
+    /* Response to OTP / Read Bits (4 / 1) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_READBITS):
+    {
+      uint32 BitsLength = 0;
+      uint32 DataBitsLength = 0;
+      const void *DataBits_p = NULL;
+      uint32 LockStatusBitsLength = 0;
+      uint32 LockStatusLength = 0;
+      const void *LockStatus_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        BitsLength = Serialization::get_uint32_le(&Data_p);
+        DataBitsLength = Serialization::get_uint32_le(&Data_p);
+        DataBits_p = Data_p;
+        Serialization::skip_block(&Data_p, DataBitsLength);
+        LockStatusBitsLength = Serialization::get_uint32_le(&Data_p);
+        LockStatusLength = Serialization::get_uint32_le(&Data_p);
+        LockStatus_p = Data_p;
+        Serialization::skip_block(&Data_p, LockStatusLength);
+      }
+      ReturnValue = DoneRPC_OTP_ReadBitsImpl(Session, ResponseStatus, BitsLength, DataBitsLength, DataBits_p, LockStatusBitsLength, LockStatusLength, LockStatus_p);
+    }
+    break;
+  
+    /* Response to OTP / Set Bits (4 / 2) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_SETBITS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_OTP_SetBitsImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to OTP / Write and Lock OTP (4 / 3) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_WRITEANDLOCK):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_OTP_WriteAndLockImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to OTP / Store Secure Object (4 / 4) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_STORESECUREOBJECT):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_OTP_StoreSecureObjectImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * Parameter Storage Commands Group (0x05)
+   */
+
+    /* Response to Parameter Storage / Read Global Data Unit (5 / 1) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT):
+    {
+      uint32 DataBuffLength = 0;
+      const void *DataBuff_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DataBuffLength = Serialization::get_uint32_le(&Data_p);
+        DataBuff_p = Data_p;
+        Serialization::skip_block(&Data_p, DataBuffLength);
+      }
+      ReturnValue = DoneRPC_ParameterStorage_ReadGlobalDataUnitImpl(Session, ResponseStatus, DataBuffLength, DataBuff_p);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Write Global Data Unit (5 / 2) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_WriteGlobalDataUnitImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Read Global Data Set (5 / 3) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATASET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_ReadGlobalDataSetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Write Global Data Set (5 / 4) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_WriteGlobalDataSetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Erase Global Data Set (5 / 5) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_EraseGlobalDataSetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * Security settings Commands Group (0x06)
+   */
+
+    /* Response to Security / Set Domain (6 / 1) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_SETDOMAIN):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_SetDomainImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Security / Get Domain (6 / 2) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_GETDOMAIN):
+    {
+      uint32 CurrentDomain = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        CurrentDomain = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_Security_GetDomainImpl(Session, ResponseStatus, CurrentDomain);
+    }
+    break;
+  
+    /* Response to Security / Get Properties (6 / 3) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_GETPROPERTIES):
+    {
+      uint32 DataBuffLength = 0;
+      const void *DataBuff_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DataBuffLength = Serialization::get_uint32_le(&Data_p);
+        DataBuff_p = Data_p;
+        Serialization::skip_block(&Data_p, DataBuffLength);
+      }
+      ReturnValue = DoneRPC_Security_GetPropertiesImpl(Session, ResponseStatus, DataBuffLength, DataBuff_p);
+    }
+    break;
+  
+    /* Response to Security / Set Properties (6 / 4) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_SETPROPERTIES):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_SetPropertiesImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Security / Bind Properties (6 / 5) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_BINDPROPERTIES):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_BindPropertiesImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    default:
+      {
+        return E_COMMAND_NO_ERROR; // Do_CustomCEH_Call(CmdData_p); // when customer commands will be implemented
+      }
+    }
+
+    if (response)
+    {
+      lcdMethods_->AddEvent(new Event(EVENT_GR_RECEIVED, ResponseStatus, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+    }
+    else
+    {
+      lcdMethods_->AddEvent(new Event(EVENT_CMD_RECEIVED, 0, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+    }
+
+    return ReturnValue;
+  }
+
+/*
+ * System commands group (0x01)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_LoaderStartUpStatus(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_LOADERSTARTUPSTATUS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_Reboot(uint16 SessionOut, const uint32 Mode)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_REBOOT, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Mode);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_ShutDown(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SHUTDOWN, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_SupportedCommands(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SUPPORTEDCOMMANDS, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_ExecuteSoftware(uint16 SessionOut, const uint32 ExecuteMode, const char *SourcePath_p, const uint64 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+  PLSize += sizeof(uint64);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_EXECUTESOFTWARE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, ExecuteMode);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+  Serialization::put_uint64_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_Authenticate(uint16 SessionOut, const uint32 Type)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Type);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_GetControlKeys(uint16 Session, ErrorCode_e Status, const char *NLCKLock_p, const char *NSLCKLock_p, const char *SPLCKLock_p, const char *CLCKLock_p, const char *PCKLock_p, const char *ESLCKLock_p, const char *NLCKUnlock_p, const char *NSLCKUnlock_p, const char *SPLCKUnlock_p, const char *CLCKUnlock_p, const char *PCKUnlock_p, const char *ESLCKUnlock_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeNLCKLock_p = 0;
+  uint32 PLSizeNSLCKLock_p = 0;
+  uint32 PLSizeSPLCKLock_p = 0;
+  uint32 PLSizeCLCKLock_p = 0;
+  uint32 PLSizePCKLock_p = 0;
+  uint32 PLSizeESLCKLock_p = 0;
+  uint32 PLSizeNLCKUnlock_p = 0;
+  uint32 PLSizeNSLCKUnlock_p = 0;
+  uint32 PLSizeSPLCKUnlock_p = 0;
+  uint32 PLSizeCLCKUnlock_p = 0;
+  uint32 PLSizePCKUnlock_p = 0;
+  uint32 PLSizeESLCKUnlock_p = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSizeNLCKLock_p = strlen(NLCKLock_p);
+  PLSize += PLSizeNLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeNSLCKLock_p = strlen(NSLCKLock_p);
+  PLSize += PLSizeNSLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeSPLCKLock_p = strlen(SPLCKLock_p);
+  PLSize += PLSizeSPLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeCLCKLock_p = strlen(CLCKLock_p);
+  PLSize += PLSizeCLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizePCKLock_p = strlen(PCKLock_p);
+  PLSize += PLSizePCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeESLCKLock_p = strlen(ESLCKLock_p);
+  PLSize += PLSizeESLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeNLCKUnlock_p = strlen(NLCKUnlock_p);
+  PLSize += PLSizeNLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeNSLCKUnlock_p = strlen(NSLCKUnlock_p);
+  PLSize += PLSizeNSLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeSPLCKUnlock_p = strlen(SPLCKUnlock_p);
+  PLSize += PLSizeSPLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeCLCKUnlock_p = strlen(CLCKUnlock_p);
+  PLSize += PLSizeCLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizePCKUnlock_p = strlen(PCKUnlock_p);
+  PLSize += PLSizePCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeESLCKUnlock_p = strlen(ESLCKUnlock_p);
+  PLSize += PLSizeESLCKUnlock_p;
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, PLSizeNLCKLock_p);
+  Serialization::put_block(&Data_p, NLCKLock_p, PLSizeNLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeNSLCKLock_p);
+  Serialization::put_block(&Data_p, NSLCKLock_p, PLSizeNSLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeSPLCKLock_p);
+  Serialization::put_block(&Data_p, SPLCKLock_p, PLSizeSPLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeCLCKLock_p);
+  Serialization::put_block(&Data_p, CLCKLock_p, PLSizeCLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizePCKLock_p);
+  Serialization::put_block(&Data_p, PCKLock_p, PLSizePCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeESLCKLock_p);
+  Serialization::put_block(&Data_p, ESLCKLock_p, PLSizeESLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeNLCKUnlock_p);
+  Serialization::put_block(&Data_p, NLCKUnlock_p, PLSizeNLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeNSLCKUnlock_p);
+  Serialization::put_block(&Data_p, NSLCKUnlock_p, PLSizeNSLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeSPLCKUnlock_p);
+  Serialization::put_block(&Data_p, SPLCKUnlock_p, PLSizeSPLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeCLCKUnlock_p);
+  Serialization::put_block(&Data_p, CLCKUnlock_p, PLSizeCLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizePCKUnlock_p);
+  Serialization::put_block(&Data_p, PCKUnlock_p, PLSizePCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeESLCKUnlock_p);
+  Serialization::put_block(&Data_p, ESLCKUnlock_p, PLSizeESLCKUnlock_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_AuthenticationChallenge(uint16 Session, ErrorCode_e Status, const uint32 ResponseBlockLength, const void *ResponseBlock_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += ResponseBlockLength;
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, ResponseBlockLength);
+  Serialization::put_block(&Data_p, ResponseBlock_p, ResponseBlockLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_CollectData(uint16 SessionOut, const uint32 Type)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_COLLECTDATA, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Type);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_GetProgressStatus(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_GETPROGRESSSTATUS, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_SetSystemTime(uint16 SessionOut, const uint32 EpochTime)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SETSYSTEMTIME, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, EpochTime);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_SwitchCommunicationDevice(uint16 SessionOut, const uint32 Device, const uint32 DeviceParam)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Device);
+  Serialization::put_uint32_le(&Data_p, DeviceParam);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_GetControlKeysData(uint16 Session, ErrorCode_e Status, const uint32 iDataSize, const void *SIMLockKeysData_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += iDataSize;
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYSDATA, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, iDataSize);
+  Serialization::put_block(&Data_p, SIMLockKeysData_p, iDataSize);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_StartCommRelay(uint16 SessionOut, const uint32 HostDeviceId, const uint32 TargetDeviceId, const uint32 ControlDeviceId)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_STARTCOMMRELAY, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, HostDeviceId);
+  Serialization::put_uint32_le(&Data_p, TargetDeviceId);
+  Serialization::put_uint32_le(&Data_p, ControlDeviceId);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * Flash Commands group (0x02)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_ProcessFile(uint16 SessionOut, const uint64 Length, const char *Type_p, const char *SourcePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeType_p = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSizeType_p = strlen(Type_p);
+  PLSize += PLSizeType_p;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_PROCESSFILE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint64_le(&Data_p, Length);
+  Serialization::put_uint32_le(&Data_p, PLSizeType_p);
+  Serialization::put_block(&Data_p, Type_p, PLSizeType_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_ListDevices(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_LISTDEVICES, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_DumpArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length, const char *TargetPath_p, const uint32 RedundantArea)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_DUMPAREA, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+  Serialization::put_uint32_le(&Data_p, RedundantArea);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_EraseArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_ERASEAREA, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_FlashRaw(uint16 SessionOut, const uint64 Start, const uint64 Length, const uint32 Device, const char *SourcePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_FLASHRAW, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+  Serialization::put_uint32_le(&Data_p, Device);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * File System Commands Group (0x03)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_VolumeProperties(uint16 SessionOut, const char *DevicePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_FormatVolume(uint16 SessionOut, const char *DevicePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_ListDirectory(uint16 SessionOut, const char *Path_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_MoveFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  uint32 PLSizeDestinationPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+  PLSize += sizeof(uint32);
+  PLSizeDestinationPath_p = strlen(DestinationPath_p);
+  PLSize += PLSizeDestinationPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeDestinationPath_p);
+  Serialization::put_block(&Data_p, DestinationPath_p, PLSizeDestinationPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_DeleteFile(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_CopyFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  uint32 PLSizeDestinationPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+  PLSize += sizeof(uint32);
+  PLSizeDestinationPath_p = strlen(DestinationPath_p);
+  PLSize += PLSizeDestinationPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeDestinationPath_p);
+  Serialization::put_block(&Data_p, DestinationPath_p, PLSizeDestinationPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_CreateDirectory(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_Properties(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_File_System_Operations_Properties(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, Mode);
+  Serialization::put_uint64_le(&Data_p, Size);
+  Serialization::put_uint32_le(&Data_p, MTime);
+  Serialization::put_uint32_le(&Data_p, ATime);
+  Serialization::put_uint32_le(&Data_p, CTime);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_ChangeAccess(uint16 SessionOut, const char *TargetPath_p, const uint32 Access)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+  Serialization::put_uint32_le(&Data_p, Access);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_ReadLoadModulesManifests(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * OTP handling commands Group (0x04)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_ReadBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_READBITS, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, OTP_id);
+  Serialization::put_uint32_le(&Data_p, Start);
+  Serialization::put_uint32_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_SetBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 BitsLength, const uint32 DataBitsLength, const void *DataBits_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBitsLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_SETBITS, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, OTP_id);
+  Serialization::put_uint32_le(&Data_p, Start);
+  Serialization::put_uint32_le(&Data_p, BitsLength);
+  Serialization::put_uint32_le(&Data_p, DataBitsLength);
+  Serialization::put_block(&Data_p, DataBits_p, DataBitsLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_WriteAndLock(uint16 SessionOut, const uint32 OTP_id, const uint32 ForceWrite)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_WRITEANDLOCK, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, OTP_id);
+  Serialization::put_uint32_le(&Data_p, ForceWrite);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_StoreSecureObject(uint16 SessionOut, const char *SourcePath, const uint32 SecureObjectDestination)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath = 0;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath = strlen(SourcePath);
+  PLSize += PLSizeSourcePath;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_STORESECUREOBJECT, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath);
+  Serialization::put_block(&Data_p, SourcePath, PLSizeSourcePath);
+  Serialization::put_uint32_le(&Data_p, SecureObjectDestination);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * Parameter Storage Commands Group (0x05)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_ReadGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_WriteGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBuffLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+  Serialization::put_uint32_le(&Data_p, DataBuffLength);
+  Serialization::put_block(&Data_p, DataBuff_p, DataBuffLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_ReadGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATASET, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_WriteGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const uint64 DataLength, const char *SourcePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint64_le(&Data_p, DataLength);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_EraseGlobalDataSet(uint16 SessionOut, const char *DevicePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * Security settings Commands Group (0x06)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_SetDomain(uint16 SessionOut, const uint32 Domain)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_SETDOMAIN, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Domain);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_GetDomain(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_GETDOMAIN, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_GetProperties(uint16 SessionOut, const uint32 Unit_id)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_GETPROPERTIES, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_SetProperties(uint16 SessionOut, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBuffLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_SETPROPERTIES, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+  Serialization::put_uint32_le(&Data_p, DataBuffLength);
+  Serialization::put_block(&Data_p, DataBuff_p, DataBuffLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_BindProperties(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_BINDPROPERTIES, SessionOut, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lcdriver_error_codes.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lcdriver_error_codes.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lcdriver_error_codes.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lcdriver_error_codes.h	2011-11-01 10:47:58.985732953 +0100
@@ -0,0 +1,97 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _LCDRIVERERRORCODE_H
+#define _LCDRIVERERRORCODE_H
+
+/**
+ *  Error codes for LCDriver.
+ */
+
+/**
+ * Table for Error groups range
+ *
+ * General Fatal 10001-10025
+ * General Non-Fatal 10026-10050
+ *
+ * Interface Fatal 10051-10075
+ * Interface Non-Fatal 10076-10100
+ *
+ * System Thread Fatal 10101-10125
+ * System Thread Non-Fatal 10126-10150
+ *
+ * Bulk Fatal 10151-10175
+ * Bulk Non-Fatal 10176-10200
+ *
+ * Hardware Fatal 10201-10225
+ * Hardware Non-Fatal 10226-10250
+ *
+ * Loader Command Execution Fatal 10251-10275
+ * Loader Command Execution Non-Fatal 10276-10300
+ *
+ * Buffers Fatal 10301-10325
+ * Buffers Non-Fatal 10326-10350
+ *
+ * IO File Fatal 10351-10375
+ * IO File Non-Fatal 10376-10400
+ *
+ * LCM DLL Fatal 10401-10425
+ * LCM DLL Non-Fatal 10426-10450
+ *
+ * Exceptions Fatal 10451-10475
+ * Exceptions Non-Fatal 10476-10500
+ *
+ * LCDriver Thread Fatal 10501-10525
+ * LCDriver Thread Non-Fatal 10526-10550
+ *
+ */
+
+typedef enum {
+  TIMEOUT = 10001,  /** Timeout event occured. */
+  INVALID_INPUT_PARAMETERS = 10002,  /** Invalid parameter during Context initialization. */
+  INTERFACE_COULD_NOT_ADD_OBJECT_TO_LIST = 10051,  /** Failed to create context for connected device. */
+  INTERFACE_COULD_NOT_CREATE_OBJECT = 10052,  /** Failed to create loader interface. */
+  INTERFACE_UNKNOWN_EXECPTION_WHILE_ADDING_OBJECT = 10053,  /** Failed to create context for connected device. */
+  INTERFACE_COULD_NOT_CREATE_IFC_OBJECT = 10054,  /** Failed to create context for connected device. */
+  INTERFACE_OBJECT_POINTER_TO_POINTER_NULL = 10055,  /** Invalid pointer to interface. */
+  INTERFACE_OBJECT_POINTER_NULL = 10056,  /** Invalid pointer to LCDriver context. */
+  INTERFACE_OBJECT_ALREADY_EXISTS = 10076,  /** LCDriver interface for the device already exists. */
+  INTERFACE_LC_METHODS_OBJECT_NULL = 10077,  /** Interface for loader methods is not created. */
+  INTERFACE_INTERFACEID_POINTER_NULL = 10078,  /** Failed to create LCDriver context. */
+  INTERFACE_CONTEXT_NOT_STARTED = 10079,  /** LCDriver context is not started. */
+  LCDRIVER_THREAD_UNKNOWN_EXCEPTION = 10126,  /** Unexpexted exit of LCDriver thread. */
+  BULK_VECTOR_ID_ERROR = 10176,  /** Failed to start bulk session. */
+  BULK_ALREADY_IN_PROGRESS = 10177,  /** Bulk transfer is already in progress. */
+  PROTROM_STATUS_NOT_OK = 10201,  /** ROM Code Failure. */
+  TIMEOUT_NO_CHIP_ID_DETECTED = 10226,  /** Failed to initialize HW. */
+  TIMEOUT_NO_Z_DETECTED = 10227,  /** Failed to start HW initialization. */
+  PARALLEL_COMMAND_EXECUTION_NOT_SUPPORTED = 10276,  /** Command execution failed. */
+  CALLBACKS_NOT_CONFIGURED_CORRECTLY = 10277,  /** Communication driver configuration failure. */
+  GENERAL_RESPONSE_COMMAND_NUMBER_ERROR = 10278,  /** Failure during command execution. */
+  COMMAND_NUMBER_ERROR = 10279,  /** Failure during command execution. */
+  CANCEL_EVENT_RECEIVED = 10280,  /** Operation execution is canceled. */
+  UNEXPECTED_EVENT_RECEIVED = 10281,  /** Unexpected event during execution. */
+  INVALID_EXECUTION_MODE = 10282,  /** Invalid execution mode. */
+  BUFFER_BULK_FILE_NOT_ALOCATED = 10326,  /** Bulk transfer failed. */
+  FILE_OPENING_ERROR = 10376,  /** Failed to open file. */
+  FILE_CREATE_MAPPING_ERROR = 10377,  /** Failed to load the file in RAM. */
+  FILE_MAPPING_VIEW_ERROR = 10378,  /** Reading of file failed. */
+  FILE_FAILED_TO_GET_SIZE = 10379,  /** Failed to load the file in RAM. */
+  FILE_READ_INVALID_OFFSET = 10379,  /** Invalid data offset requested. */
+  FILE_READ_ERROR = 10380,  /** Failed to read from file. */
+  LCM_DLL_LOAD_LOADLIBRARY_ERROR = 10401,  /** Failed to load LCM library. */
+  LCM_DLL_LOAD_FUNCTION_NOT_FOUND = 10402,  /** Failed to import LCM functionality. */
+  UNKNOWN_EXCEPTION = 10451,  /** Unknown error has stopped the operation. */
+  UNKNOWN_WAIT_RETURN_VALUE = 10476,  /** Operation execution failed. */
+  UNKNOWN_BULK_TRANSFER_EXCEPTION = 10477,  /** Bulk transfer failed. */
+  UNKNOWN_INTERFACE_EXCEPTION = 10478,  /** LCDriver context operation failed. */
+  LCDRIVER_THREAD_KILLED = 10526,  /** LCDriver thread stopped. */
+  LCDRIVER_THREAD_KILLED_WITH_CANCEL = 10527,  /** LCDriver thread stopped. */
+  LCDRIVER_THREAD_KILLED_WITH_SIGNAL_DEATH = 10528,  /** LCDriver thread stopped. */
+  LCDRIVER_THREAD_NOT_STARTED = 10529,  /** Failed to start LCDriver thread. */
+  LCDRIVER_THREAD_STOPPED_AFTER_LCM_ERROR = 10530,  /** LCDriver thread stopped after receiving LCM error. */
+  LCM_RETRANSMISSION_ERROR = 10551,  /** LCM failed to send packet. */
+  LCM_DEVICE_WRITE_ERROR = 10552  /** LCM failed to write data on communication device. */
+} InternalErrorCodes_e;
+
+#endif /* _LCDRIVERERRORCODE_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/command_ids.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/command_ids.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/command_ids.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/command_ids.h	2011-11-01 10:47:46.506106681 +0100
@@ -0,0 +1,104 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMAND_IDS_H
+#define _COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+TYPEDEF_ENUM {
+  GROUP_SYSTEM = 1, /**< System application */
+  GROUP_FLASH = 2, /**< Flash application */
+  GROUP_FILE_SYSTEM_OPERATIONS = 3, /**< File system operations */
+  GROUP_OTP = 4, /**< OTP */
+  GROUP_PARAMETERSTORAGE = 5, /**< Parameter Storage */
+  GROUP_SECURITY = 6, /**< Security */
+  GROUP_ADBG = 8  /**< ADbg application */
+} ENUM8(GroupId_e);
+
+typedef enum {
+  COMMAND_SYSTEM_LOADERSTARTUPSTATUS = 1, /**< Loader Start-up Status */
+  COMMAND_SYSTEM_REBOOT = 3, /**< System Reboot */
+  COMMAND_SYSTEM_SHUTDOWN = 4, /**< System Shutdown */
+  COMMAND_SYSTEM_SUPPORTEDCOMMANDS = 5, /**< System Supported Command */
+  COMMAND_SYSTEM_EXECUTESOFTWARE = 6, /**< System Execute Software */
+  COMMAND_SYSTEM_AUTHENTICATE = 7, /**< System Authenticate */
+  COMMAND_SYSTEM_GETCONTROLKEYS = 8, /**< System Get Control Keys */
+  COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE = 9, /**< System Authentication Challenge */
+  COMMAND_SYSTEM_COLLECTDATA = 10, /**< System Collect Data */
+  COMMAND_SYSTEM_GETPROGRESSSTATUS = 11, /**< System Get Progress Status */
+  COMMAND_SYSTEM_SETSYSTEMTIME = 12, /**< Set System Time */
+  COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE = 13, /**< Switch Communication Device */
+  COMMAND_SYSTEM_GETCONTROLKEYSDATA = 14, /**< System Get Control Keys Data */
+  COMMAND_SYSTEM_STARTCOMMRELAY = 15, /**< System Start Communication Relay */
+  COMMAND_FLASH_PROCESSFILE = 1, /**< Process File */
+  COMMAND_FLASH_LISTDEVICES = 2, /**< List Devices */
+  COMMAND_FLASH_DUMPAREA = 3, /**< Dump Area */
+  COMMAND_FLASH_ERASEAREA = 4, /**< Erase Area */
+  COMMAND_FLASH_FLASHRAW = 5, /**< Flash RAW */
+  COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES = 2, /**< Volume Properties */
+  COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME = 3, /**< Format Volume */
+  COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY = 4, /**< List Directory */
+  COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE = 5, /**< Move File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE = 6, /**< Delete File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE = 7, /**< Copy File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY = 8, /**< Create Directory */
+  COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES = 9, /**< Properties (Stat) */
+  COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS = 10, /**< Change Access (Chmod) */
+  COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS = 11, /**< Read Load Modules Manifests */
+  COMMAND_OTP_READBITS = 1, /**< Read Bits */
+  COMMAND_OTP_SETBITS = 2, /**< Set Bits */
+  COMMAND_OTP_WRITEANDLOCK = 3, /**< Write and Lock OTP */
+  COMMAND_OTP_STORESECUREOBJECT = 4, /**< Store Secure Object */
+  COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT = 1, /**< Read Global Data Unit */
+  COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT = 2, /**< Write Global Data Unit */
+  COMMAND_PARAMETERSTORAGE_READGLOBALDATASET = 3, /**< Read Global Data Set */
+  COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET = 4, /**< Write Global Data Set */
+  COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET = 5, /**< Erase Global Data Set */
+  COMMAND_SECURITY_SETDOMAIN = 1, /**< Set Domain */
+  COMMAND_SECURITY_GETDOMAIN = 2, /**< Get Domain */
+  COMMAND_SECURITY_GETPROPERTIES = 3, /**< Get Properties */
+  COMMAND_SECURITY_SETPROPERTIES = 4, /**< Set Properties */
+  COMMAND_SECURITY_BINDPROPERTIES = 5, /**< Bind Properties */
+  COMMAND_ADBG_LISTCASE = 1, /**< List all modules, test cases and its parameters  */
+  COMMAND_ADBG_LISTINTERFACE = 2, /**< List all modules, interface groups, interface functions and its parameters  */
+  COMMAND_ADBG_SETPRECONDITION = 3, /**< Set test case precondition  */
+  COMMAND_ADBG_RECOVERYCONDITION = 4, /**< Recovery test case condition  */
+  COMMAND_ADBG_RUN = 5, /**< Run test case  */
+  COMMAND_ADBG_PROTOCOLTEST = 6  /**< Protocol test case  */
+} CommandId_e;
+
+
+typedef struct SupportedCommand_s
+{
+  uint32  Group; /**< Application Group number */
+    uint32  Command; /**< Command number */
+    uint32  Permitted; /**< Permission value */
+  }SupportedCommand_t;
+
+typedef struct ListDevice_s
+{
+  
+  char *  Path_p; /**< Absolute device path pointing of the described device */
+    
+  char *  Type_p; /**< Type of the device */
+    uint64  BlockSize; /**< Size of the smallest addressable unit in the device in bytes */
+    uint64  Start; /**< Offset in bytes of the start of the device relative to its parents offset 0 with a granularity of its parents block size */
+    uint64  Length; /**< Length of the device in bytes */
+  }ListDevice_t;
+
+typedef struct DirEntry_s
+{
+  
+  char *  Name_p; /**< Name of file or directory */
+    uint64  Size; /**< Size of file or directory */
+    uint32  Mode; /**< Indicator if it is file or directory */
+    uint32  Time; /**< Time of last modification */
+  }DirEntry_t;
+
+typedef struct Cipher_s
+{
+  
+  char *  Name_p; /**< supported ciphers */
+  }Cipher_t;
+
+#endif /* _COMMAND_IDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/command_marshal.c riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/command_marshal.c
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/command_marshal.c	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/command_marshal.c	2011-11-01 10:47:47.837988825 +0100
@@ -0,0 +1,2374 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "t_command_protocol.h"
+#include "r_debug.h"
+#include "r_communication_service.h"
+#include "commands.h"
+#include "custom_commands.h"
+#include "command_ids.h"
+#include "commands_impl.h"
+#include "error_codes.h"
+#include "r_serialization.h"
+#include "r_command_protocol.h"
+#ifdef CFG_ENABLE_ADBG_LOADER
+#include "r_adbg_applications.h"
+#endif
+
+#ifdef CFG_ENABLE_AUDIT_CMD 
+#include "audit.h"
+#endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+#include "r_adbg_command.h"
+#endif
+
+#define COMMAND(response, group, id) ((((int)(response)) << 30) | (((int)(group)) << 16) | ((int)(id))) 
+#define COMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP)\
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t));\
+  CmdData.Type           = TypeP;\
+  CmdData.ApplicationNr  = ApplicationP;\
+  CmdData.CommandNr      = CommandP;\
+  CmdData.SessionNr      = SessionP;\
+  CmdData.Payload.Size   = SizeP;\
+  CmdData.Payload.Data_p = NULL;\
+  CmdData.Payload.Data_p = (uint8*)malloc(SizeP);\
+  if (NULL == CmdData.Payload.Data_p)\
+  {\
+    A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);)\
+    return E_ALLOCATE_FAILED;\
+  }\
+
+#define COMMANDDATAOUT(TypeP,ApplicationP,CommandP,SizeP)\
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t));\
+  CmdData.Type           = TypeP;\
+  CmdData.ApplicationNr  = ApplicationP;\
+  CmdData.CommandNr      = CommandP;\
+  CmdData.SessionNr      = 0;\
+  CmdData.Payload.Size   = SizeP;\
+  CmdData.Payload.Data_p = NULL;\
+  if (0 != SizeP)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc( SizeP);\
+    if (NULL == CmdData.Payload.Data_p)\
+    {\
+      A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);)\
+      return E_ALLOCATE_FAILED;\
+    }\
+  }
+
+//static uint16 Session;
+
+void disable_interrupt(void)
+{
+#ifndef WIN32
+/* todo implement this */
+//#warning This is disable_interrupt
+#endif
+}
+void enable_interrupt(void)
+{
+#ifndef WIN32
+/* todo implement this */
+//#warning This is enable_interrupt  
+#endif
+}
+
+ErrorCode_e Do_CEH_Call(void *Object_p, CommandData_t *CmdData_p)
+{
+  ErrorCode_e Status = E_GENERAL_FATAL_ERROR;
+//  uint32 PL_GRSize = 0;
+  ErrorCode_e ResponseStatus = E_GENERAL_FATAL_ERROR;
+  boolean response = FALSE;
+//  CommandPermissionList_t* CmdPermission_p;
+  void *Data_p = CmdData_p->Payload.Data_p;
+  uint16 Session = CmdData_p->SessionNr;
+
+  if (CmdData_p->Type == GENERAL_RESPONSE_PACKAGE)
+  {
+    response = TRUE;
+//    PL_GRSize = CmdData_p->Payload.Size;
+//    ResponseStatus = (ErrorCode_e)get_uint16(&Data_p);
+  }
+
+#ifdef CFG_ENABLE_AUDIT_CMD
+  if(COMMAND_TYPE == CmdData_p->Type)
+  {
+    ErrorCode_e AuditResponse = CommandAudit(CmdData_p);
+    CommandData_t CmdData = {0};
+    uint32 PLSize = sizeof(ErrorCode_e);
+
+    if (E_SUCCESS != AuditResponse)
+    {
+      memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t));
+
+      CmdData.Type           = GENERAL_RESPONSE;
+      CmdData.CommandNr      = CmdData_p->CommandNr;
+      CmdData.ApplicationNr  = CmdData_p->ApplicationNr;
+      CmdData.SessionNr      = CmdData_p->SessionNr;
+      CmdData.Payload.Size   = PLSize;
+      CmdData.Payload.Data_p = NULL;
+      CmdData.Payload.Data_p = (uint8*)malloc(PLSize);
+      if (NULL == CmdData.Payload.Data_p)
+      {
+        A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);)
+        return  E_ALLOCATE_FAILED;
+      }
+
+      Data_p = CmdData.Payload.Data_p;
+      put_uint32(&Data_p, AuditResponse);
+
+      Status = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+      if (NULL != CmdData.Payload.Data_p)
+      {
+        free(CmdData.Payload.Data_p);
+      }
+
+      if (E_SUCCESS != Status)
+      {
+        return Status;
+      }
+
+      if (E_UNSUPPORTED_CMD == AuditResponse)
+      {
+        Status = Do_System_ShutDownImpl(CmdData.SessionNr);
+      }
+      return Status;
+    }
+  }
+#endif
+
+  switch(COMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+  {
+  
+ /*
+  * System commands group (0x01)
+  */
+
+    /* Response to System application / Loader Start-up Status (01 / 1) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_LOADERSTARTUPSTATUS):
+    { 
+  
+      
+      ResponseStatus = (ErrorCode_e)get_uint32_le(&Data_p);
+  
+      Status = Done_System_LoaderStartUpStatusImpl(Session, ResponseStatus);
+      
+    }
+    break;
+
+    /* Command System application / System Reboot (01 / 3) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_REBOOT):
+    { 
+      uint32 Mode;
+  
+      Mode = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_System_RebootImpl(Session, Mode);
+      
+    }
+    break;
+
+    /* Command System application / System Shutdown (01 / 4) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_SHUTDOWN):
+    { 
+  
+      Status = Do_System_ShutDownImpl(Session);
+      
+    }
+    break;
+
+    /* Command System application / System Supported Command (01 / 5) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_SUPPORTEDCOMMANDS):
+    { 
+  
+      Status = Do_System_SupportedCommandsImpl(Session);
+      
+    }
+    break;
+
+    /* Command System application / System Execute Software (01 / 6) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_EXECUTESOFTWARE):
+    { 
+      uint32 ExecuteMode;
+      char *SourcePath_p;
+      uint64 Length;
+  
+      ExecuteMode = get_uint32_le(&Data_p);
+      SourcePath_p = skip_str(&Data_p);
+      Length = get_uint64_le(&Data_p);
+  
+  
+      Status = Do_System_ExecuteSoftwareImpl(Session, ExecuteMode, SourcePath_p, Length);
+      
+    }
+    break;
+
+    /* Command System application / System Authenticate (01 / 7) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATE):
+    { 
+      uint32 Type;
+  
+      Type = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_System_AuthenticateImpl(Session, Type);
+      
+    }
+    break;
+
+    /* Response to System application / System Get Control Keys (01 / 8) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYS):
+    { 
+      char *NLCKLock_p;
+      char *NSLCKLock_p;
+      char *SPLCKLock_p;
+      char *CLCKLock_p;
+      char *PCKLock_p;
+      char *ESLCKLock_p;
+      char *NLCKUnlock_p;
+      char *NSLCKUnlock_p;
+      char *SPLCKUnlock_p;
+      char *CLCKUnlock_p;
+      char *PCKUnlock_p;
+      char *ESLCKUnlock_p;
+  
+  
+      
+      ResponseStatus = (ErrorCode_e)get_uint32_le(&Data_p);
+      NLCKLock_p = skip_str(&Data_p);
+      NSLCKLock_p = skip_str(&Data_p);
+      SPLCKLock_p = skip_str(&Data_p);
+      CLCKLock_p = skip_str(&Data_p);
+      PCKLock_p = skip_str(&Data_p);
+      ESLCKLock_p = skip_str(&Data_p);
+      NLCKUnlock_p = skip_str(&Data_p);
+      NSLCKUnlock_p = skip_str(&Data_p);
+      SPLCKUnlock_p = skip_str(&Data_p);
+      CLCKUnlock_p = skip_str(&Data_p);
+      PCKUnlock_p = skip_str(&Data_p);
+      ESLCKUnlock_p = skip_str(&Data_p);
+  
+  
+      Status = Done_System_GetControlKeysImpl(Session, ResponseStatus, NLCKLock_p, NSLCKLock_p, SPLCKLock_p, CLCKLock_p, PCKLock_p, ESLCKLock_p, NLCKUnlock_p, NSLCKUnlock_p, SPLCKUnlock_p, CLCKUnlock_p, PCKUnlock_p, ESLCKUnlock_p);
+      
+    }
+    break;
+
+    /* Response to System application / System Authentication Challenge (01 / 9) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE):
+    { 
+      uint32 ResponseBlockLength;
+      void *ResponseBlock_p;
+  
+  
+      
+      ResponseStatus = (ErrorCode_e)get_uint32_le(&Data_p);
+      ResponseBlockLength = get_uint32_le(&Data_p);
+      ResponseBlock_p = Data_p;
+      skip_block( &Data_p, ResponseBlockLength);    
+  
+  
+      Status = Done_System_AuthenticationChallengeImpl(Session, ResponseStatus, ResponseBlockLength, ResponseBlock_p);
+      
+    }
+    break;
+
+    /* Command System application / System Collect Data (01 / 10) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_COLLECTDATA):
+    { 
+      uint32 Type;
+  
+      Type = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_System_CollectDataImpl(Session, Type);
+      
+    }
+    break;
+
+    /* Command System application / System Get Progress Status (01 / 11) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETPROGRESSSTATUS):
+    { 
+  
+      Status = Do_System_GetProgressStatusImpl(Session);
+      
+    }
+    break;
+
+    /* Command System application / Set System Time (01 / 12) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_SETSYSTEMTIME):
+    { 
+      uint32 EpochTime;
+  
+      EpochTime = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_System_SetSystemTimeImpl(Session, EpochTime);
+      
+    }
+    break;
+
+    /* Command System application / Switch Communication Device (01 / 13) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE):
+    { 
+      uint32 Device;
+      uint32 DeviceParam;
+  
+      Device = get_uint32_le(&Data_p);
+      DeviceParam = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_System_SwitchCommunicationDeviceImpl(Session, Device, DeviceParam);
+      
+    }
+    break;
+
+    /* Response to System application / System Get Control Keys Data (01 / 14) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYSDATA):
+    { 
+      uint32 iDataSize;
+      void *SIMLockKeysData_p;
+  
+  
+      
+      ResponseStatus = (ErrorCode_e)get_uint32_le(&Data_p);
+      iDataSize = get_uint32_le(&Data_p);
+      SIMLockKeysData_p = Data_p;
+      skip_block( &Data_p, iDataSize);    
+  
+  
+      Status = Done_System_GetControlKeysDataImpl(Session, ResponseStatus, iDataSize, SIMLockKeysData_p);
+      
+    }
+    break;
+
+    /* Command System application / System Start Communication Relay (01 / 15) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_STARTCOMMRELAY):
+    { 
+      uint32 HostDeviceId;
+      uint32 TargetDeviceId;
+      uint32 ControlDeviceId;
+  
+      HostDeviceId = get_uint32_le(&Data_p);
+      TargetDeviceId = get_uint32_le(&Data_p);
+      ControlDeviceId = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_System_StartCommRelayImpl(Session, HostDeviceId, TargetDeviceId, ControlDeviceId);
+      
+    }
+    break;
+
+ /*
+  * Flash Commands group (0x02)
+  */
+
+    /* Command Flash application / Process File (02 / 1) */ 
+    case COMMAND(FALSE, GROUP_FLASH, COMMAND_FLASH_PROCESSFILE):
+    { 
+      uint64 Length;
+      char *Type_p;
+      char *SourcePath_p;
+  
+      Length = get_uint64_le(&Data_p);
+      Type_p = skip_str(&Data_p);
+      SourcePath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_Flash_ProcessFileImpl(Session, Length, Type_p, SourcePath_p);
+      
+    }
+    break;
+
+    /* Command Flash application / List Devices (02 / 2) */ 
+    case COMMAND(FALSE, GROUP_FLASH, COMMAND_FLASH_LISTDEVICES):
+    { 
+  
+      Status = Do_Flash_ListDevicesImpl(Session);
+      
+    }
+    break;
+
+    /* Command Flash application / Dump Area (02 / 3) */ 
+    case COMMAND(FALSE, GROUP_FLASH, COMMAND_FLASH_DUMPAREA):
+    { 
+      char *Path_p;
+      uint64 Start;
+      uint64 Length;
+      char *TargetPath_p;
+      uint32 RedundantArea;
+  
+      Path_p = skip_str(&Data_p);
+      Start = get_uint64_le(&Data_p);
+      Length = get_uint64_le(&Data_p);
+      TargetPath_p = skip_str(&Data_p);
+      RedundantArea = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_Flash_DumpAreaImpl(Session, Path_p, Start, Length, TargetPath_p, RedundantArea);
+      
+    }
+    break;
+
+    /* Command Flash application / Erase Area (02 / 4) */ 
+    case COMMAND(FALSE, GROUP_FLASH, COMMAND_FLASH_ERASEAREA):
+    { 
+      char *Path_p;
+      uint64 Start;
+      uint64 Length;
+  
+      Path_p = skip_str(&Data_p);
+      Start = get_uint64_le(&Data_p);
+      Length = get_uint64_le(&Data_p);
+  
+  
+      Status = Do_Flash_EraseAreaImpl(Session, Path_p, Start, Length);
+      
+    }
+    break;
+
+    /* Command Flash application / Flash RAW (02 / 5) */ 
+    case COMMAND(FALSE, GROUP_FLASH, COMMAND_FLASH_FLASHRAW):
+    { 
+      uint64 Start;
+      uint64 Length;
+      uint32 Device;
+      char *SourcePath_p;
+  
+      Start = get_uint64_le(&Data_p);
+      Length = get_uint64_le(&Data_p);
+      Device = get_uint32_le(&Data_p);
+      SourcePath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_Flash_FlashRawImpl(Session, Start, Length, Device, SourcePath_p);
+      
+    }
+    break;
+
+ /*
+  * File System Commands Group (0x03)
+  */
+
+    /* Command File system operations / Volume Properties (03 / 2) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES):
+    { 
+      char *DevicePath_p;
+  
+      DevicePath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_VolumePropertiesImpl(Session, DevicePath_p);
+      
+    }
+    break;
+
+    /* Command File system operations / Format Volume (03 / 3) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME):
+    { 
+      char *DevicePath_p;
+  
+      DevicePath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_FormatVolumeImpl(Session, DevicePath_p);
+      
+    }
+    break;
+
+    /* Command File system operations / List Directory (03 / 4) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY):
+    { 
+      char *Path_p;
+  
+      Path_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_ListDirectoryImpl(Session, Path_p);
+      
+    }
+    break;
+
+    /* Command File system operations / Move File (03 / 5) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE):
+    { 
+      char *SourcePath_p;
+      char *DestinationPath_p;
+  
+      SourcePath_p = skip_str(&Data_p);
+      DestinationPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_MoveFileImpl(Session, SourcePath_p, DestinationPath_p);
+      
+    }
+    break;
+
+    /* Command File system operations / Delete File (03 / 6) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE):
+    { 
+      char *TargetPath_p;
+  
+      TargetPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_DeleteFileImpl(Session, TargetPath_p);
+      
+    }
+    break;
+
+    /* Command File system operations / Copy File (03 / 7) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE):
+    { 
+      char *SourcePath_p;
+      char *DestinationPath_p;
+  
+      SourcePath_p = skip_str(&Data_p);
+      DestinationPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_CopyFileImpl(Session, SourcePath_p, DestinationPath_p);
+      
+    }
+    break;
+
+    /* Command File system operations / Create Directory (03 / 8) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY):
+    { 
+      char *TargetPath_p;
+  
+      TargetPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_CreateDirectoryImpl(Session, TargetPath_p);
+      
+    }
+    break;
+
+    /* Command File system operations / Properties (Stat) (03 / 9) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES):
+    { 
+      char *TargetPath_p;
+  
+      TargetPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_PropertiesImpl(Session, TargetPath_p);
+      
+    }
+    break;
+
+    /* Response to File system operations / Properties (Stat) (03 / 9) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES):
+    { 
+      uint32 Mode;
+      uint64 Size;
+      uint32 MTime;
+      uint32 ATime;
+      uint32 CTime;
+  
+  
+      
+      ResponseStatus = (ErrorCode_e)get_uint32_le(&Data_p);
+      Mode = get_uint32_le(&Data_p);
+      Size = get_uint64_le(&Data_p);
+      MTime = get_uint32_le(&Data_p);
+      ATime = get_uint32_le(&Data_p);
+      CTime = get_uint32_le(&Data_p);
+  
+  
+      Status = Done_File_System_Operations_PropertiesImpl(Session, ResponseStatus, Mode, Size, MTime, ATime, CTime);
+      
+    }
+    break;
+
+    /* Command File system operations / Change Access (Chmod) (03 / 10) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS):
+    { 
+      char *TargetPath_p;
+      uint32 Access;
+  
+      TargetPath_p = skip_str(&Data_p);
+      Access = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_ChangeAccessImpl(Session, TargetPath_p, Access);
+      
+    }
+    break;
+
+    /* Command File system operations / Read Load Modules Manifests (03 / 11) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS):
+    { 
+      char *TargetPath_p;
+  
+      TargetPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_File_System_Operations_ReadLoadModulesManifestsImpl(Session, TargetPath_p);
+      
+    }
+    break;
+
+ /*
+  * OTP handling commands Group (0x04)
+  */
+
+    /* Command OTP / Read Bits (04 / 1) */ 
+    case COMMAND(FALSE, GROUP_OTP, COMMAND_OTP_READBITS):
+    { 
+      uint32 OTP_id;
+      uint32 Start;
+      uint32 Length;
+  
+      OTP_id = get_uint32_le(&Data_p);
+      Start = get_uint32_le(&Data_p);
+      Length = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_OTP_ReadBitsImpl(Session, OTP_id, Start, Length);
+      
+    }
+    break;
+
+#ifndef CFG_ENABLE_WRITEBITS_CMD
+    /* Command OTP / Set Bits (04 / 2) */ 
+    case COMMAND(FALSE, GROUP_OTP, COMMAND_OTP_SETBITS):
+    { 
+      uint32 OTP_id;
+      uint32 Start;
+      uint32 BitsLength;
+      uint32 DataBitsLength;
+      void *DataBits_p;
+  
+      OTP_id = get_uint32_le(&Data_p);
+      Start = get_uint32_le(&Data_p);
+      BitsLength = get_uint32_le(&Data_p);
+      DataBitsLength = get_uint32_le(&Data_p);
+      DataBits_p = Data_p;
+      skip_block( &Data_p, DataBitsLength);    
+  
+  
+      Status = Do_OTP_SetBitsImpl(Session, OTP_id, Start, BitsLength, DataBitsLength, DataBits_p);
+      
+    }
+    break;
+#endif
+  
+#ifndef CFG_ENABLE_WRITEBITS_CMD
+    /* Command OTP / Write and Lock OTP (04 / 3) */ 
+    case COMMAND(FALSE, GROUP_OTP, COMMAND_OTP_WRITEANDLOCK):
+    { 
+      uint32 OTP_id;
+      uint32 ForceWrite;
+  
+      OTP_id = get_uint32_le(&Data_p);
+      ForceWrite = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_OTP_WriteAndLockImpl(Session, OTP_id, ForceWrite);
+      
+    }
+    break;
+#endif
+  
+#ifndef CFG_ENABLE_WRITEBITS_CMD
+    /* Command OTP / Store Secure Object (04 / 4) */ 
+    case COMMAND(FALSE, GROUP_OTP, COMMAND_OTP_STORESECUREOBJECT):
+    { 
+      char *SourcePath;
+      uint32 SecureObjectDestination;
+  
+      SourcePath = skip_str(&Data_p);
+      SecureObjectDestination = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_OTP_StoreSecureObjectImpl(Session, SourcePath, SecureObjectDestination);
+      
+    }
+    break;
+#endif
+  
+ /*
+  * Parameter Storage Commands Group (0x05)
+  */
+
+    /* Command Parameter Storage / Read Global Data Unit (05 / 1) */ 
+    case COMMAND(FALSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT):
+    { 
+      char *DevicePath_p;
+      uint32 Unit_id;
+  
+      DevicePath_p = skip_str(&Data_p);
+      Unit_id = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_ParameterStorage_ReadGlobalDataUnitImpl(Session, DevicePath_p, Unit_id);
+      
+    }
+    break;
+
+    /* Command Parameter Storage / Write Global Data Unit (05 / 2) */ 
+    case COMMAND(FALSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT):
+    { 
+      char *DevicePath_p;
+      uint32 Unit_id;
+      uint32 DataBuffLength;
+      void *DataBuff_p;
+  
+      DevicePath_p = skip_str(&Data_p);
+      Unit_id = get_uint32_le(&Data_p);
+      DataBuffLength = get_uint32_le(&Data_p);
+      DataBuff_p = Data_p;
+      skip_block( &Data_p, DataBuffLength);    
+  
+  
+      Status = Do_ParameterStorage_WriteGlobalDataUnitImpl(Session, DevicePath_p, Unit_id, DataBuffLength, DataBuff_p);
+      
+    }
+    break;
+
+    /* Command Parameter Storage / Read Global Data Set (05 / 3) */ 
+    case COMMAND(FALSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATASET):
+    { 
+      char *DevicePath_p;
+      char *TargetPath_p;
+  
+      DevicePath_p = skip_str(&Data_p);
+      TargetPath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_ParameterStorage_ReadGlobalDataSetImpl(Session, DevicePath_p, TargetPath_p);
+      
+    }
+    break;
+
+    /* Command Parameter Storage / Write Global Data Set (05 / 4) */ 
+    case COMMAND(FALSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET):
+    { 
+      char *DevicePath_p;
+      uint64 DataLength;
+      char *SourcePath_p;
+  
+      DevicePath_p = skip_str(&Data_p);
+      DataLength = get_uint64_le(&Data_p);
+      SourcePath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_ParameterStorage_WriteGlobalDataSetImpl(Session, DevicePath_p, DataLength, SourcePath_p);
+      
+    }
+    break;
+
+    /* Command Parameter Storage / Erase Global Data Set (05 / 5) */ 
+    case COMMAND(FALSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET):
+    { 
+      char *DevicePath_p;
+  
+      DevicePath_p = skip_str(&Data_p);
+  
+  
+      Status = Do_ParameterStorage_EraseGlobalDataSetImpl(Session, DevicePath_p);
+      
+    }
+    break;
+
+ /*
+  * Security settings Commands Group (0x06)
+  */
+
+    /* Command Security / Set Domain (06 / 1) */ 
+    case COMMAND(FALSE, GROUP_SECURITY, COMMAND_SECURITY_SETDOMAIN):
+    { 
+      uint32 Domain;
+  
+      Domain = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_Security_SetDomainImpl(Session, Domain);
+      
+    }
+    break;
+
+    /* Command Security / Get Domain (06 / 2) */ 
+    case COMMAND(FALSE, GROUP_SECURITY, COMMAND_SECURITY_GETDOMAIN):
+    { 
+  
+      Status = Do_Security_GetDomainImpl(Session);
+      
+    }
+    break;
+
+    /* Command Security / Get Properties (06 / 3) */ 
+    case COMMAND(FALSE, GROUP_SECURITY, COMMAND_SECURITY_GETPROPERTIES):
+    { 
+      uint32 Unit_id;
+  
+      Unit_id = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_Security_GetPropertiesImpl(Session, Unit_id);
+      
+    }
+    break;
+
+    /* Command Security / Set Properties (06 / 4) */ 
+    case COMMAND(FALSE, GROUP_SECURITY, COMMAND_SECURITY_SETPROPERTIES):
+    { 
+      uint32 Unit_id;
+      uint32 DataBuffLength;
+      void *DataBuff_p;
+  
+      Unit_id = get_uint32_le(&Data_p);
+      DataBuffLength = get_uint32_le(&Data_p);
+      DataBuff_p = Data_p;
+      skip_block( &Data_p, DataBuffLength);    
+  
+  
+      Status = Do_Security_SetPropertiesImpl(Session, Unit_id, DataBuffLength, DataBuff_p);
+      
+    }
+    break;
+
+    /* Command Security / Bind Properties (06 / 5) */ 
+    case COMMAND(FALSE, GROUP_SECURITY, COMMAND_SECURITY_BINDPROPERTIES):
+    { 
+  
+      Status = Do_Security_BindPropertiesImpl(Session);
+      
+    }
+    break;
+
+ /*
+  * ADbg test suite (automatic test tool)
+  */
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+    /* Command ADbg application / List all modules, test cases and its parameters  (08 / 1) */ 
+    case COMMAND(FALSE, GROUP_ADBG, COMMAND_ADBG_LISTCASE):
+    { 
+  
+      Status = Do_ADbg_ListCaseImpl(Session);
+      
+    }
+    break;
+#endif
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+    /* Command ADbg application / List all modules, interface groups, interface functions and its parameters  (08 / 2) */ 
+    case COMMAND(FALSE, GROUP_ADBG, COMMAND_ADBG_LISTINTERFACE):
+    { 
+  
+      Status = Do_ADbg_ListInterfaceImpl(Session);
+      
+    }
+    break;
+#endif
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+    /* Command ADbg application / Set test case precondition  (08 / 3) */ 
+    case COMMAND(FALSE, GROUP_ADBG, COMMAND_ADBG_SETPRECONDITION):
+    { 
+      uint32 ModuleId;
+      uint32 IntGroupId;
+      uint32 IntFunctionId;
+      uint32 RecoveryFlag;
+      uint32 PreconditionLength;
+      void *Precondition_p;
+  
+      ModuleId = get_uint32_le(&Data_p);
+      IntGroupId = get_uint32_le(&Data_p);
+      IntFunctionId = get_uint32_le(&Data_p);
+      RecoveryFlag = get_uint32_le(&Data_p);
+      PreconditionLength = get_uint32_le(&Data_p);
+      Precondition_p = Data_p;
+      skip_block( &Data_p, PreconditionLength);    
+  
+  
+      Status = Do_ADbg_SetPreconditionImpl(Session, ModuleId, IntGroupId, IntFunctionId, RecoveryFlag, PreconditionLength, Precondition_p);
+      
+    }
+    break;
+#endif
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+    /* Command ADbg application / Recovery test case condition  (08 / 4) */ 
+    case COMMAND(FALSE, GROUP_ADBG, COMMAND_ADBG_RECOVERYCONDITION):
+    { 
+      uint32 ModuleId;
+      uint32 IntGroupId;
+      uint32 IntFunctionId;
+  
+      ModuleId = get_uint32_le(&Data_p);
+      IntGroupId = get_uint32_le(&Data_p);
+      IntFunctionId = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_ADbg_RecoveryConditionImpl(Session, ModuleId, IntGroupId, IntFunctionId);
+      
+    }
+    break;
+#endif
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+    /* Command ADbg application / Run test case  (08 / 5) */ 
+    case COMMAND(FALSE, GROUP_ADBG, COMMAND_ADBG_RUN):
+    { 
+      uint32 ModuleId;
+      uint32 CaseId;
+      uint32 PreconditionLength;
+      void *Precondition_p;
+  
+      ModuleId = get_uint32_le(&Data_p);
+      CaseId = get_uint32_le(&Data_p);
+      PreconditionLength = get_uint32_le(&Data_p);
+      Precondition_p = Data_p;
+      skip_block( &Data_p, PreconditionLength);    
+  
+  
+      Status = Do_ADbg_RunImpl(Session, ModuleId, CaseId, PreconditionLength, Precondition_p);
+      
+    }
+    break;
+#endif
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+    /* Command ADbg application / Protocol test case  (08 / 6) */ 
+    case COMMAND(FALSE, GROUP_ADBG, COMMAND_ADBG_PROTOCOLTEST):
+    { 
+      uint32 NrOfRetransmission;
+      uint32 Type;
+  
+      NrOfRetransmission = get_uint32_le(&Data_p);
+      Type = get_uint32_le(&Data_p);
+  
+  
+      Status = Do_ADbg_ProtocolTestImpl(Session, NrOfRetransmission, Type);
+      
+    }
+    break;
+#endif
+  
+  default:
+    {
+      Status = Do_CustomCEH_Call(CmdData_p);
+      if (E_SUCCESS != Status)
+      {
+        Status = Do_System_ShutDownImpl(Session);
+      }
+    }
+    break;
+  }
+
+  return Status;
+}
+
+  
+/*
+ * System commands group (0x01)
+ */
+
+ErrorCode_e Do_System_LoaderStartUpStatus(const uint32 Status, const char *LoaderVersion_p, const char *ProtocolVersion_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  uint32 PLSizeLoaderVersion_p = 0;
+  uint32 PLSizeProtocolVersion_p = 0;
+  PLSize += sizeof(uint32);
+  PLSize += PLSizeLoaderVersion_p = get_uint32_string_le((void**)&LoaderVersion_p);
+  PLSize += PLSizeProtocolVersion_p = get_uint32_string_le((void**)&ProtocolVersion_p);
+  
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_LOADERSTARTUPSTATUS, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  (void)(Data_p);  //XVSZOAN Temporary solution!
+  put_uint32_le(&Data_p, Status);
+  put_block(&Data_p, LoaderVersion_p, PLSizeLoaderVersion_p);
+  put_block(&Data_p, ProtocolVersion_p, PLSizeProtocolVersion_p);
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e Done_System_Reboot(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_REBOOT, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_ShutDown(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_SHUTDOWN, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_SupportedCommands(uint16 Session, ErrorCode_e Status, const uint32 CommandCount, SupportedCommand_t Commands[])
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  uint32 PLSizeCommands = 0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += PLSizeCommands = CommandCount * sizeof(SupportedCommand_t);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_SUPPORTEDCOMMANDS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, CommandCount);
+  if (Commands != NULL)
+  {
+    put_block(&Data_p, Commands, PLSizeCommands);
+  }
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_ExecuteSoftware(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_EXECUTESOFTWARE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_Authenticate(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Do_System_GetControlKeys(void)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYS, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  (void)(Data_p);  //XVSZOAN Temporary solution!
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e Do_System_AuthenticationChallenge(const uint32 ChallengeBlockLength,  void *ChallengeBlock_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  PLSize += sizeof(uint32);
+  PLSize += ChallengeBlockLength;
+  
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  (void)(Data_p);  //XVSZOAN Temporary solution!
+  put_uint32_le(&Data_p, ChallengeBlockLength);
+  put_block(&Data_p, ChallengeBlock_p, ChallengeBlockLength);
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e Done_System_CollectData(uint16 Session, ErrorCode_e Status, const uint32 DataLenght,  void *CollectedData_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += DataLenght;
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_COLLECTDATA, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, DataLenght);
+  put_block(&Data_p, CollectedData_p, DataLenght);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_GetProgressStatus(uint16 Session, ErrorCode_e Status, const uint32 ProgressStatus)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETPROGRESSSTATUS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, ProgressStatus);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_SetSystemTime(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_SETSYSTEMTIME, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_System_SwitchCommunicationDevice(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Do_System_GetControlKeysData(void)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYSDATA, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  (void)(Data_p);  //XVSZOAN Temporary solution!
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e Done_System_StartCommRelay(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_STARTCOMMRELAY, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+/*
+ * Flash Commands group (0x02)
+ */
+
+ErrorCode_e Done_Flash_ProcessFile(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FLASH, COMMAND_FLASH_PROCESSFILE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Flash_ListDevices(uint16 Session, ErrorCode_e Status, const uint32 DeviceCount, ListDevice_t Devices[])
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += get_device_entries_len(Devices, DeviceCount); 
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FLASH, COMMAND_FLASH_LISTDEVICES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, DeviceCount);
+  serialize_device_entries(&Data_p, Devices, DeviceCount);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Flash_DumpArea(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FLASH, COMMAND_FLASH_DUMPAREA, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Flash_EraseArea(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FLASH, COMMAND_FLASH_ERASEAREA, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Flash_FlashRaw(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FLASH, COMMAND_FLASH_FLASHRAW, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+/*
+ * File System Commands Group (0x03)
+ */
+
+ErrorCode_e Done_File_System_Operations_VolumeProperties(uint16 Session, ErrorCode_e Status, const char *FS_Type_p, const uint64 Size, const uint64 Free)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  uint32 PLSizeFS_Type_p = 0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += PLSizeFS_Type_p = get_uint32_string_le((void**)&FS_Type_p);
+  PLSize += sizeof(uint64);
+   PLSize += sizeof(uint64);
+   
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_block(&Data_p, FS_Type_p, PLSizeFS_Type_p);
+  put_uint64_le(&Data_p, Size);
+  put_uint64_le(&Data_p, Free);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_FormatVolume(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_ListDirectory(uint16 Session, ErrorCode_e Status, const uint32 EntriesCount, DirEntry_t Entries[])
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += get_directory_entries_len(Entries, EntriesCount); 
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, EntriesCount);
+  serialize_directory_entries(&Data_p, Entries, EntriesCount);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_MoveFile(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_DeleteFile(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_CopyFile(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_CreateDirectory(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Do_File_System_Operations_Properties(const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += PLSizeTargetPath_p = get_uint32_string_le((void**)&TargetPath_p);
+  
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  (void)(Data_p);  //XVSZOAN Temporary solution!
+  put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e Done_File_System_Operations_Properties(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint64);
+   PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, Mode);
+  put_uint64_le(&Data_p, Size);
+  put_uint32_le(&Data_p, MTime);
+  put_uint32_le(&Data_p, ATime);
+  put_uint32_le(&Data_p, CTime);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_ChangeAccess(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_File_System_Operations_ReadLoadModulesManifests(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+/*
+ * OTP handling commands Group (0x04)
+ */
+
+ErrorCode_e Done_OTP_ReadBits(uint16 Session, ErrorCode_e Status, const uint32 BitsLength, const uint32 DataBitsLength,  void *DataBits_p, const uint32 LockStatusBitsLength, const uint32 LockStatusLength,  void *LockStatus_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBitsLength;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += LockStatusLength;
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_OTP, COMMAND_OTP_READBITS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, BitsLength);
+  put_uint32_le(&Data_p, DataBitsLength);
+  put_block(&Data_p, DataBits_p, DataBitsLength);
+  put_uint32_le(&Data_p, LockStatusBitsLength);
+  put_uint32_le(&Data_p, LockStatusLength);
+  put_block(&Data_p, LockStatus_p, LockStatusLength);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_OTP_SetBits(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_OTP, COMMAND_OTP_SETBITS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_OTP_WriteAndLock(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_OTP, COMMAND_OTP_WRITEANDLOCK, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_OTP_StoreSecureObject(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_OTP, COMMAND_OTP_STORESECUREOBJECT, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+/*
+ * Parameter Storage Commands Group (0x05)
+ */
+
+ErrorCode_e Done_ParameterStorage_ReadGlobalDataUnit(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength,  void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += DataBuffLength;
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, DataBuffLength);
+  put_block(&Data_p, DataBuff_p, DataBuffLength);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_ParameterStorage_WriteGlobalDataUnit(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_ParameterStorage_ReadGlobalDataSet(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATASET, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_ParameterStorage_WriteGlobalDataSet(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_ParameterStorage_EraseGlobalDataSet(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+/*
+ * Security settings Commands Group (0x06)
+ */
+
+ErrorCode_e Done_Security_SetDomain(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SECURITY, COMMAND_SECURITY_SETDOMAIN, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Security_GetDomain(uint16 Session, ErrorCode_e Status, const uint32 CurrentDomain)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SECURITY, COMMAND_SECURITY_GETDOMAIN, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, CurrentDomain);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Security_GetProperties(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength,  void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += DataBuffLength;
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SECURITY, COMMAND_SECURITY_GETPROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, DataBuffLength);
+  put_block(&Data_p, DataBuff_p, DataBuffLength);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Security_SetProperties(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SECURITY, COMMAND_SECURITY_SETPROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+ErrorCode_e Done_Security_BindProperties(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SECURITY, COMMAND_SECURITY_BINDPROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+#ifdef CFG_ENABLE_ADBG_LOADER
+  Answer = ReleaseADbg_AppFunc(Status);
+  Answer = E_SUCCESS;
+  
+#else 
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+#endif
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  
+/*
+ * ADbg test suite (automatic test tool)
+ */
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+ErrorCode_e Done_ADbg_ListCase(uint16 Session, ErrorCode_e Status, const uint32 CmdDataLength,  void *CmdDataPayLoad_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += CmdDataLength;
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_ADBG, COMMAND_ADBG_LISTCASE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, CmdDataLength);
+  put_block(&Data_p, CmdDataPayLoad_p, CmdDataLength);
+  
+  Answer = E_SUCCESS;
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  #endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+ErrorCode_e Done_ADbg_ListInterface(uint16 Session, ErrorCode_e Status, const uint32 CmdDataLength,  void *CmdDataPayLoad_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += CmdDataLength;
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_ADBG, COMMAND_ADBG_LISTINTERFACE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, CmdDataLength);
+  put_block(&Data_p, CmdDataPayLoad_p, CmdDataLength);
+  
+  Answer = E_SUCCESS;
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  #endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+ErrorCode_e Done_ADbg_SetPrecondition(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_ADBG, COMMAND_ADBG_SETPRECONDITION, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+  Answer = E_SUCCESS;
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  #endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+ErrorCode_e Done_ADbg_RecoveryCondition(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_ADBG, COMMAND_ADBG_RECOVERYCONDITION, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  
+  Answer = E_SUCCESS;
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  #endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+ErrorCode_e Done_ADbg_Run(uint16 Session, ErrorCode_e Status, const uint32 AssertStatus)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_ADBG, COMMAND_ADBG_RUN, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, AssertStatus);
+  
+  Answer = E_SUCCESS;
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  #endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+ErrorCode_e Done_ADbg_ProtocolTest(uint16 Session, ErrorCode_e Status, const uint32 ProtocolTestStatus)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize =0;
+  
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_ADBG, COMMAND_ADBG_PROTOCOLTEST, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+
+  put_uint32(&Data_p, Status);
+  put_uint32_le(&Data_p, ProtocolTestStatus);
+  
+  Answer = E_SUCCESS;
+  
+  Answer = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+  
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+  #endif
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/commands.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/commands.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/commands.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/commands.h	2011-11-01 10:47:46.025981936 +0100
@@ -0,0 +1,593 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_H
+#define _COMMANDS_H
+#include "error_codes.h"
+#include "t_command_protocol.h"
+#include "command_ids.h"
+
+ErrorCode_e Do_CEH_Call(void *Object_p, CommandData_t *CmdData_p);
+
+/*
+ * System commands group (0x01)
+ */
+
+/**
+ * The Loader Start-up Status command is sent by the ME to notify the host that it has started. The Status parameter indicates in what mode the Loader started.
+ * \see Done_System_LoaderStartUpStatusImpl
+ * Call source: ME
+ * 
+ * @param [in] Status 0 = started successfully, 1 = failed to start (lack of permissions), 2 = software module failed to initialize
+ * @param [in] LoaderVersion_p Loader version identifier
+ * @param [in] ProtocolVersion_p Protocol version identifier
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Do_System_LoaderStartUpStatus(const uint32 Status, const char *LoaderVersion_p, const char *ProtocolVersion_p);
+
+/**
+ * Response to \see Do_System_RebootImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_Reboot(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_System_ShutDownImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_ShutDown(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_System_SupportedCommandsImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] CommandCount Number of implemented commands
+ * @param [in] Commands An array of command identifiers. The Permitted field indicates whether the command can be executed at the current time (non-zero value means allowed)
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_SupportedCommands(uint16 Session, ErrorCode_e Status, const uint32 CommandCount, SupportedCommand_t Commands[]);
+
+/**
+ * Response to \see Do_System_ExecuteSoftwareImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_ExecuteSoftware(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_System_AuthenticateImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_Authenticate(uint16 Session, ErrorCode_e Status);
+
+/**
+ * This command is used by the Loader to retrieve the SimLock Control Keys from the host in order to authenticate a user. The command is used in authentication context.
+ * \see Done_System_GetControlKeysImpl
+ * Call source: ME
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Do_System_GetControlKeys(void);
+
+/**
+ * This command is used by the Loader to perform a certificate authentication. The command is only used in authentication context.
+ * \see Done_System_AuthenticationChallengeImpl
+ * Call source: ME
+ * 
+ * @param [in] ChallengeBlockLength Authentication Challenge buffer length
+ * @param [in] ChallengeBlock_p Authentication Challenge that must be signed using the correct certificate and returned to the Loader
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Do_System_AuthenticationChallenge(const uint32 ChallengeBlockLength,  void *ChallengeBlock_p);
+
+/**
+ * Response to \see Do_System_CollectDataImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] DataLenght Length of output buffer.
+ * @param [in] CollectedData_p Output data buffer. Contain debug data (printouts) or measurement data.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_CollectData(uint16 Session, ErrorCode_e Status, const uint32 DataLenght,  void *CollectedData_p);
+
+/**
+ * Response to \see Do_System_GetProgressStatusImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] ProgressStatus Command progress status presented in percent.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_GetProgressStatus(uint16 Session, ErrorCode_e Status, const uint32 ProgressStatus);
+
+/**
+ * Response to \see Do_System_SetSystemTimeImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_SetSystemTime(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_System_SwitchCommunicationDeviceImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_SwitchCommunicationDevice(uint16 Session, ErrorCode_e Status);
+
+/**
+ * This command is used by the Loader to retrieve the SimLock Control Keys data buffer from the host in order to authenticate a user. The command is used in authentication context.
+ * \see Done_System_GetControlKeysDataImpl
+ * Call source: ME
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Do_System_GetControlKeysData(void);
+
+/**
+ * Response to \see Do_System_StartCommRelayImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_System_StartCommRelay(uint16 Session, ErrorCode_e Status);
+
+/*
+ * Flash Commands group (0x02)
+ */
+
+/**
+ * Response to \see Do_Flash_ProcessFileImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Flash_ProcessFile(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_Flash_ListDevicesImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] DeviceCount Indicates the number of returned devices
+ * @param [in] Devices Absolute device path, Type of the device, Block Size, Start address of the device, Length of the device
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Flash_ListDevices(uint16 Session, ErrorCode_e Status, const uint32 DeviceCount, ListDevice_t Devices[]);
+
+/**
+ * Response to \see Do_Flash_DumpAreaImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Flash_DumpArea(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_Flash_EraseAreaImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Flash_EraseArea(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_Flash_FlashRawImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Flash_FlashRaw(uint16 Session, ErrorCode_e Status);
+
+/*
+ * File System Commands Group (0x03)
+ */
+
+/**
+ * Response to \see Do_File_System_Operations_VolumePropertiesImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] FS_Type_p File system type
+ * @param [in] Size Total size of the file system (in bytes)
+ * @param [in] Free Available space (in bytes)
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_VolumeProperties(uint16 Session, ErrorCode_e Status, const char *FS_Type_p, const uint64 Size, const uint64 Free);
+
+/**
+ * Response to \see Do_File_System_Operations_FormatVolumeImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_FormatVolume(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_File_System_Operations_ListDirectoryImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] EntriesCount Number of directory entries
+ * @param [in] Entries Name and Size of file or directory, Mode as indicator if it is file or directory, Time of last modification
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_ListDirectory(uint16 Session, ErrorCode_e Status, const uint32 EntriesCount, DirEntry_t Entries[]);
+
+/**
+ * Response to \see Do_File_System_Operations_MoveFileImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_MoveFile(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_File_System_Operations_DeleteFileImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_DeleteFile(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_File_System_Operations_CopyFileImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_CopyFile(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_File_System_Operations_CreateDirectoryImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_CreateDirectory(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Retrieves the properties of a file or directory
+ * \see Done_File_System_Operations_PropertiesImpl
+ * Call source: ME
+ * 
+ * @param [in] TargetPath_p File system path
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Do_File_System_Operations_Properties(const char *TargetPath_p);
+
+/**
+ * Response to \see Do_File_System_Operations_PropertiesImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] Mode File Type and Access restrictions descriptor (see 5.1)
+ * @param [in] Size File size in bytes
+ * @param [in] MTime Last modification time stamp
+ * @param [in] ATime Last access time stamp
+ * @param [in] CTime Creation time stamp
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_Properties(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime);
+
+/**
+ * Response to \see Do_File_System_Operations_ChangeAccessImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_ChangeAccess(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_File_System_Operations_ReadLoadModulesManifestsImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_File_System_Operations_ReadLoadModulesManifests(uint16 Session, ErrorCode_e Status);
+
+/*
+ * OTP handling commands Group (0x04)
+ */
+
+/**
+ * Response to \see Do_OTP_ReadBitsImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] BitsLength Length of read bits
+ * @param [in] DataBitsLength Length of the DataBits buffer
+ * @param [in] DataBits_p A left-adjusted buffer of the read data. Padded with zeroes. Length of returned value (in bytes), equal to floor((Length + 7) / 8). 
+ * @param [in] LockStatusBitsLength Length of the LockStatus of read bits
+ * @param [in] LockStatusLength Length of the LockStatus buffer
+ * @param [in] LockStatus_p A left-adjusted buffer of the lock status of each read bit. Padded with zeroes. Length of returned value (in bytes), equal to floor((Length + 7) / 8). 
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_OTP_ReadBits(uint16 Session, ErrorCode_e Status, const uint32 BitsLength, const uint32 DataBitsLength,  void *DataBits_p, const uint32 LockStatusBitsLength, const uint32 LockStatusLength,  void *LockStatus_p);
+
+/**
+ * Response to \see Do_OTP_SetBitsImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_OTP_SetBits(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_OTP_WriteAndLockImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_OTP_WriteAndLock(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_OTP_StoreSecureObjectImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_OTP_StoreSecureObject(uint16 Session, ErrorCode_e Status);
+
+/*
+ * Parameter Storage Commands Group (0x05)
+ */
+
+/**
+ * Response to \see Do_ParameterStorage_ReadGlobalDataUnitImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] DataBuffLength Length of the Data buffer
+ * @param [in] DataBuff_p The read data
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ParameterStorage_ReadGlobalDataUnit(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength,  void *DataBuff_p);
+
+/**
+ * Response to \see Do_ParameterStorage_WriteGlobalDataUnitImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ParameterStorage_WriteGlobalDataUnit(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_ParameterStorage_ReadGlobalDataSetImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ParameterStorage_ReadGlobalDataSet(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_ParameterStorage_WriteGlobalDataSetImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ParameterStorage_WriteGlobalDataSet(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_ParameterStorage_EraseGlobalDataSetImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ParameterStorage_EraseGlobalDataSet(uint16 Session, ErrorCode_e Status);
+
+/*
+ * Security settings Commands Group (0x06)
+ */
+
+/**
+ * Response to \see Do_Security_SetDomainImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Security_SetDomain(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_Security_GetDomainImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] CurrentDomain The ME Domain
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Security_GetDomain(uint16 Session, ErrorCode_e Status, const uint32 CurrentDomain);
+
+/**
+ * Response to \see Do_Security_GetPropertiesImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] DataBuffLength Length of the Data buffer
+ * @param [in] DataBuff_p The unit data
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Security_GetProperties(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength,  void *DataBuff_p);
+
+/**
+ * Response to \see Do_Security_SetPropertiesImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Security_SetProperties(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_Security_BindPropertiesImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_Security_BindProperties(uint16 Session, ErrorCode_e Status);
+
+/*
+ * ADbg test suite (automatic test tool)
+ */
+
+/**
+ * Response to \see Do_ADbg_ListCaseImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] CmdDataLength 
+ * @param [in] CmdDataPayLoad_p CmdData
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ADbg_ListCase(uint16 Session, ErrorCode_e Status, const uint32 CmdDataLength,  void *CmdDataPayLoad_p);
+
+/**
+ * Response to \see Do_ADbg_ListInterfaceImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] CmdDataLength 
+ * @param [in] CmdDataPayLoad_p CmdData
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ADbg_ListInterface(uint16 Session, ErrorCode_e Status, const uint32 CmdDataLength,  void *CmdDataPayLoad_p);
+
+/**
+ * Response to \see Do_ADbg_SetPreconditionImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ADbg_SetPrecondition(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_ADbg_RecoveryConditionImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ADbg_RecoveryCondition(uint16 Session, ErrorCode_e Status);
+
+/**
+ * Response to \see Do_ADbg_RunImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] AssertStatus 
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ADbg_Run(uint16 Session, ErrorCode_e Status, const uint32 AssertStatus);
+
+/**
+ * Response to \see Do_ADbg_ProtocolTestImpl
+ * Call source: PC
+ * @param [in] Session Transfered input session.
+ * @param [in] Status Completion status code.
+ * 
+ * @param [in] ProtocolTestStatus 
+ * 
+ * @return ErrorCode_e ...
+ */
+ErrorCode_e Done_ADbg_ProtocolTest(uint16 Session, ErrorCode_e Status, const uint32 ProtocolTestStatus);
+
+#endif /* _COMMANDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/error_codes.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/error_codes.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/lib/error_codes.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/lib/error_codes.h	2011-11-01 10:47:47.229987928 +0100
@@ -0,0 +1,805 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _ERRORCODE_H
+#define _ERRORCODE_H
+
+
+/**
+ *  @addtogroup ldr_LCM
+ *  Error codes for internal loader commands. 
+ *  @{
+ */
+
+/*************************************************************************
+* Includes
+*************************************************************************/
+#include "t_basicdefinitions.h"
+
+#define A2_ERROR_CODES_OFFSET 5000
+/**
+ *  Internal loader command error codes. Possible range 0x0000 - 0x0FFE (4094).
+ */
+ 
+
+/**
+ * Table for Error groups range
+ * 
+ * General Fatal 0-50
+ * General non-fatal 51-99
+ * 
+ * IO Fatal 100-150
+ * IO non-fatal 151-199
+ * 
+ * Communication Fatal 200-250
+ * Communication non-fatal 251-299
+ * 
+ * Signature Fatal 300-350
+ * Signature non-fatal 351-399
+ * 
+ * Authentication Fatal 400-450
+ * Authentication non-fatal 451-499
+ * 
+ * COPS General Fatal 500-550
+ * COPS General non-fatal 551-599
+ * 
+ * System Fatal 600-650
+ * System non-fatal 651-699
+ * 
+ * Flash Fatal 700-750
+ * Flash non-fatal 751-799
+ * 
+ * Parameters Fatal 800-850
+ * Parameters non-fatal 851-899
+ * 
+ * File management Fatal 900-950
+ * File management non-fatal 951-999
+ * 
+ * Command Auditing and execution Fatal 1000-1050
+ * Command Auditing and execution non-fatal 1051-1099
+ * 
+ * Emulation Fatal 1100-1150
+ * Emulation non-fatal 1151-1199
+ * 
+ * Timers Fatal 1200-1250
+ * Timers non-fatal 1251-1299
+ * 
+ * CABS Fatal 1300-1350
+ * CABS non-fatal 1351-1399
+ * 
+ * GDFS Fatal 1400-1450
+ * GDFS non-fatal 1451-1499
+ * 
+ * Antirollback Fatal 1500-1550
+ * Antirollback non-fatal 1551-1599
+ * 
+ * Memory and Boot Fatal 1600-1650
+ * Memory and Boot non-fatal 1651-1699
+ * 
+ * @todo this should be removed and error codes should be remaped.
+ * The same applies to Emulator errors.
+ * 
+ * Job Handler Fatal 1700-1750
+ * Job Handler non-fatal 1751-1799
+ * 
+ * Emulator Fatal 1800-1850
+ * Emulator non-fatal 1851-1899
+ * 
+ * Loader utilities Fatal 1900-1950
+ * Loader utilities non-fatal 1951-1999
+ */
+
+
+typedef enum {
+  E_SUCCESS = 0, /**<  Operation successful. */ 
+  E_GENERAL_FATAL_ERROR = 1, /**<  General Failure. */ 
+  E_ALLOCATE_FAILED = 2, /**<  Failed to allocate memory. */ 
+  E_INVALID_INPUT_PARAMETERS = 51, /**<  The expected value into the function was incorrect. */ 
+  E_INVALID_CURRDATE_STRING_LENGTH = 52, /**<  Indicate that the currdate string array variable has invalid length. */ 
+  E_UNALIGNED_DATA = 53, /**<  Indicate that a variable is not aligned. */ 
+  E_VECTOR_CREATE_FAIL = 100, /**<  Failed to create vector in IO Layer. */ 
+  E_VECTOR_DESTROY_FAIL = 101, /**<  Failed to destroy vector in IO Layer. */ 
+  E_GENERAL_IO_ERROR = 151, /**<  Unknown IO error. */ 
+  E_IO_FAILED_TO_READ = 152, /**<  IO failed to read from source. */ 
+  E_IO_FAILED_TO_WRITE = 153, /**<  IO failed to write to destination. */ 
+  E_IO_FAILED_TO_CLOSE = 154, /**<  IO failed to close media. */ 
+  E_IO_FAILED_TO_OPEN = 155, /**<  IO failed to open media. */ 
+  E_IO_FAILED_TO_GET_LENGTH = 156, /**<  IO failed to get length of media. */ 
+  E_GENERAL_COMMUNICATION_ERROR = 200, /**<  General communication error. */ 
+  E_FAILED_TO_START_BULK_SESSION = 201, /**<  Failed to start bulk session. */ 
+  E_FAILED_TO_CLOSE_BULK_SESSION = 202, /**<  Failed to initialize the transport layer. */ 
+  E_FAILED_TO_FIND_CHUNK_DATA_BLOCK = 203, /**<  Failed to find chunk data block. */ 
+  E_FAILED_TO_INIT_COM_DEVICE = 204, /**<  Failed to reinitialize communication device. */ 
+  E_FAILED_TO_USE_COM_DEVICE = 205, /**<  Failed to use communication device. */ 
+  E_FAILED_TO_ALLOCATE_COMM_BUFFER = 206, /**<  Failed to allocate communication buffer. */ 
+  E_FAILED_TO_FLUSH_RXFIFO = 207, /**<  Failed to flush RX FIFO. */ 
+  E_RETRANSMITION_FAILED = 208, /**<  Retransmission failed. After MAX_RESENDS attempt, failed to send packet. */ 
+  E_COMMAND_NO_ERROR = 209, /**<  Stopped command error sequence. */ 
+  E_FAILED_TO_RELEASE_COMM_BUFFER = 210, /**<  Failed to release communication buffer. */ 
+  E_FAILED_TO_INTIALIZE_TIMER_FUNCTIONS = 211, /**<  Failed to initialize timer functions. */ 
+  E_FAILED_TO_INTIALIZE_QUEUE_FUNCTIONS = 212, /**<  Failed to initialize queue functions. */ 
+  E_DMA_INIT_ERROR = 213, /**<  Failed to initialize DMA. */ 
+  E_FAILED_TO_STOP_DMA = 214, /**<  Failed to stop DMA channel. */ 
+  E_FAILED_TO_OPEN_DMA_CHANNEL = 215, /**<  Failed to open DMA channel. */ 
+  E_FAILED_TO_SET_DMA_CHANNEL_TYPE = 216, /**<  Failed to set DMA channel type. */ 
+  E_FAILED_TO_SET_DMA_CHANNEL_MODE = 217, /**<  Failed to set DMA channel mode. */ 
+  E_FAILED_TO_OPEN_DMA_PIPE = 218, /**<  Failed to open DMA pipe. */ 
+  E_FAILED_TO_SET_DMA_IT_LOGIC = 219, /**<  Failed to set DMA interrupt logic. */ 
+  E_FAILED_TO_CLOSE_DMA_PIPE = 220, /**<  Failed to close DMA pipe. */ 
+  E_FAILED_TO_CLOSE_DMA_CHANNEL = 221, /**<  Failed to close DMA channel. */ 
+  E_FAILED_TO_CONFIG_SRC_DMA_DEVICE = 222, /**<  Failed to configure DMA source device. */ 
+  E_FAILED_TO_UPDATE_DMA_SRC_MEMORY_BUFFER = 223, /**<  Failed to update DMA source memory buffer. */ 
+  E_FAILED_TO_CONFIG_DEST_DMA_DEVICE = 224, /**<  Failed to configure DMA destination device. */ 
+  E_FAILED_TO_UPDATE_DMA_DEST_MEMORY_BUFFER = 225, /**<  Failed to update DMA destination memory buffer. */ 
+  E_FAILED_TO_RUN_DMA = 226, /**<  Failed to run DMA transfer. */ 
+  E_INVALID_BULK_MODE = 251, /**<  Invalid bulk mode. */ 
+  E_FAILED_TO_FIND_COMM_BUFFER = 252, /**<  Failed to find communication buffer. */ 
+  E_INVALID_TYPE_OF_BUFFER = 253, /**<  Invalid type of buffer. */ 
+  E_COM_DEVICE_BUSY = 254, /**<  Communication device is busy. */ 
+  E_NOT_FOUND_ELEMENT_IN_RETRANSMISSION_LIST = 255, /**<  The element in retransmission list is not found. */ 
+  E_FAILED_READING_FROM_BULK = 256, /**<  Failed to read from bulk. */ 
+  E_FAILED_WRITING_TO_BULK = 257, /**<  Failed to write to bulk. */ 
+  E_FAILED_TO_GET_UART_DESCRIPTOR = 258, /**<  Failed to get UART descriptor. */ 
+  E_FAILED_TO_GET_USB_DESCRIPTOR = 259, /**<  Failed to get USB descriptor. */ 
+  E_INVALID_BULK_SESSION_ID = 260, /**<  Invalid bulk session ID is used. */ 
+  E_PREVIOUS_BULK_SESSION_IS_NOT_CLOSED = 261, /**<  Previous bulk session not closed. */ 
+  E_INVALID_BULK_PROTOCOL_STATE = 262, /**<  Invalid bulk protocol state. */ 
+  E_UNKNWON_PROPERTY = 351, /**<  Unknown property id. */ 
+  E_CYCLIC_GRAPH = 451, /**<  Cyclic graph in services detected. */ 
+  E_SERVICE_NOT_SUPPORTED = 452, /**<  The service is not supported. */ 
+  E_INCONSISTENCY_IN_SERVICES = 453, /**<  Inconsistency in services is detected. */ 
+  E_SERVICE_IN_USE = 454, /**<  The service is in use and can't be stopped. */ 
+  E_UNREGISTER_BDM_SERVICE_FAILED = 455, /**<  Unregistering of Block Device Manager Service failed. */ 
+  E_UNREGISTER_BAM_SERVICE_FAILED = 456, /**<  Unregistering of Boot Area Manager Service failed. */ 
+  E_UNREGISTER_COPS_SERVICE_FAILED = 457, /**<  Unregistering of COPS Data Manager Service failed. */ 
+  E_UNREGISTER_FS_SERVICE_FAILED = 458, /**<  Unregistering of File System Manager Service failed. */ 
+  E_UNREGISTER_FPD_SERVICE_FAILED = 459, /**<  Unregistering of Flash Physical Driver Service failed. */ 
+  E_UNREGISTER_GD_SERVICE_FAILED = 460, /**<  Unregistering of Global Data Manager Service failed. */ 
+  E_GENERAL_ZIP_ERROR = 551, /**<  General error. */ 
+  E_ZIP_FAILED_TO_CREATE_CONTEXT = 552, /**<   Failed to parse the zip. */ 
+  E_ZIP_FAILED_TO_OPEN_FILE = 553, /**<   Failed to open file from the zip. */ 
+  E_FILESYS_APP_INIT_FAILURE = 600, /**<  Failed to initialize the file system application. */ 
+  E_NO_FILESYSTEM_PROPERTY = 601, /**<  Failed to start file system. */ 
+  E_UNDEFINED_AUTHENTICATION_TYPE = 602, /**<  Undefined authentication type. */ 
+  E_RTC_TIME_NOT_ACCURATE = 651, /**<  System Time is not properly set. */ 
+  E_RTC_INTIALIZATION_FAILED = 652, /**<  Hardware error ocure during initialization of RTC. */ 
+  E_DIFFERENT_FLASHLAYOUT = 751, /**<  Different flashlayout. */ 
+  E_EMPTY_FILE_IN_ARCHIVE = 752, /**<  Archive contain empty file. */ 
+  E_UNKNOWN_COMM_DEVICE = 753, /**<  Unknown communication device was detected. */ 
+  E_FLASH_APP_INTERNAL_ERROR = 754, /**<  Internal during execution of flash commands. */ 
+  E_DEVICE_NAME_TOO_LONG = 755, /**<  Device name is too long. */ 
+  E_FLASH_ARCHIVE_MISMATCH = 756, /**<  Mismatch between archieve that is flashed and previosly flashed one. */ 
+  E_UNSUPPORTED_FLASH_TYPE = 757, /**<  Flash memory device type is not supported. */ 
+  E_FPD_NOT_CONFIGURED = 758, /**<  Flash physical driver is not configured. */ 
+  E_INVALID_SIZE_IN_MEMCONF = 759, /**<  MEMCONF boot record contain invalid TotalSize field. */ 
+  E_ARCHIVE_TO_LARGE = 760, /**<  Flash archive larger than available space in BDM. */ 
+  E_ENTRY_NOT_FOUND_IN_FLASHLAYOUT = 761, /**<  Entry not found in flashlayout file. */ 
+  E_MISMATCH_MANIFEST_FLASHLAYOUT = 762, /**<  Mismatch between manifest and flashlayout. */ 
+  E_INVALID_SUBTOC_PARAMETERS = 763, /**<  SUBTOC is invalid. */ 
+  E_FAILED_TO_READ_SUBTOC = 764, /**<  Reading SUBTOC from flash failed. */ 
+  E_OVERLAPPING_PARTITIONS_FOUND = 765, /**<  Overlapping partitions found in the archive. */ 
+  E_PARTITION_NOT_FOUND = 766, /**<  Partition not found in TOC. */ 
+  E_FLASHLAYOUT_NULL = 767, /**<  Flashlayout data equals NULL. */ 
+  E_INVALID_TOC_TYPE = 768, /**<  Invalid TOC type supplied during TOC list creation. */ 
+  E_TOC_HANDLER_INPUT_DATA_EMPTY = 769, /**<  TOC list cannot be created because supplied buffer is empty. */ 
+  E_TOC_HANDLER_INPUT_DATA_CORRUPTED = 770, /**<  TOC list cannot be created because supplied buffer contains corrupted data. */ 
+  E_TOC_LIST_CORRUPTED = 771, /**<  TOC list cannot be created. Some malicious state occurs. */ 
+  E_TOC_BOOT_AREA_EMPTY = 772, /**<  TOC list cannot be created. Boot area is empty. */ 
+  E_BOOT_AREA_NOT_FOUND = 773, /**<  Boot Area not found. */ 
+  E_MISMATCH_MANIFEST_TOC = 774, /**<  Mismatch between manifest and TOC. */ 
+  E_FILE_TOO_LARGE = 775, /**<  File too large. */ 
+  E_FILE_OUT_OF_BOOT_AREA = 776, /**<  File outside of boot area */ 
+  E_DUMP_OUT_OF_FLASH_RANGE = 777, /**<  Dump outside of flash range */ 
+  E_PATH_NOT_EXISTS = 951, /**<  Path not exist. */ 
+  E_CLOSE_FILE = 952, /**<  Failed to close a file in the file system. */ 
+  E_INSUFFICENT_SPACE = 953, /**<  Not enough memory space for desired operation. */ 
+  E_REMOVE_FILE = 954, /**<  Failed to remove a file from the file system. */ 
+  E_RENAME_FILE = 955, /**<  Failed to rename a file from the file system. */ 
+  E_CREATE_DIR = 956, /**<  Failed to create a new directory in the file system. */ 
+  E_REMOVE_DIRECTORY = 957, /**<  Failed to remove directory. */ 
+  E_FREE_SPACE = 958, /**<  No free space left. */ 
+  E_ITEM_STAT = 959, /**<  Failed to retrieve status data. */ 
+  E_CLOSE_DIRECTORY = 960, /**<  Failed to close a directory in the file system. */ 
+  E_MOUNT_VOLUME = 961, /**<  Failed to mount volume in the file system. */ 
+  E_READ_DIRECTORY = 962, /**<  Failed to read directory in the file system. */ 
+  E_FS_IO = 963, /**<  Input/output error. */ 
+  E_FS_ARGUMENT_LIST_2BIG = 964, /**<  Argument list too long. */ 
+  E_FS_BAD_FILE_DESC = 965, /**<  Bad file descriptor. */ 
+  E_FS_ACCESS = 966, /**<  Permission denied. */ 
+  E_FS_BAD_ADDRESS = 967, /**<  Bad address. */ 
+  E_FS_FILE_EXIST = 968, /**<  File exists. */ 
+  E_FS_NOT_DIR = 969, /**<  Not a directory. */ 
+  E_FS_IS_DIR = 970, /**<  Is a directory. */ 
+  E_FS_FILE_TOO_LARGE = 971, /**<  File too large. */ 
+  E_FS_READ_ONLY_FS = 972, /**<  Read-only file system. */ 
+  E_FS_OPER_NOT_SUPP = 973, /**<  Operation not supported. */ 
+  E_FS_NAME_TOO_LONG = 974, /**<  File name too long. */ 
+  E_FS_OPERATION_CANCELED = 975, /**<  Operation canceled. */ 
+  E_FS_FAIL = 976, /**<  Cannot start operation. */ 
+  E_FS_INTERNAL = 977, /**<  Internal error. */ 
+  E_FS_NOT_MOUNTED = 978, /**<  Volume not mounted. */ 
+  E_FS_NOT_PERMITED = 979, /**<  Operation not permitted. */ 
+  E_FS_NO_SUCH_FILE_OR_DIR = 980, /**<  No such file or directory. */ 
+  E_FS_NOT_EXIST = 981, /**<  Specified FS does not exist. */ 
+  E_FS_UNKNOWN_ERROR = 982, /**<  Error is unknown. */ 
+  E_FAILED_WRITING_TO_FILE = 983, /**<  Failed to write to file. */ 
+  E_FAILED_READING_FROM_FILE = 984, /**<  Failed to read from the specified file. */ 
+  E_ACCESS_DENIED = 985, /**<  The access permission attributes do not allow operation. */ 
+  E_CANNOT_OPEN_FILE = 986, /**<  Can not open the specified file. */ 
+  E_FAILED_TO_STOP_FS = 987, /**<  Can not stop file system. */ 
+  E_FILE_NAME_TOO_LONG = 988, /**<  File name is too long. */ 
+  E_FAILED_TO_FIND_ELF_SECTION = 989, /**<  Can not find elf section. */ 
+  E_MAX_NUMBER_OF_MOUNTED_VOLUMES_EXCEEDED = 990, /**<  Unable to mount volume due to exceeding the maximum number of allowed volumes. */ 
+  E_NO_MOUNTED_DEVICES_ARE_FOUND = 991, /**<  Information message that no mounted devices are found. */ 
+  E_NOT_FREE_CMD_SPACE = 1000, /**<  Index for new command is not founded in execution queue. */ 
+  E_INVALID_INPUT_PARAMETER = 1001, /**<  Invalid input parameter */ 
+  E_UNSUPPORTED_CMD = 1002, /**<  The loader does not support the requested command. */ 
+  E_UNSUPPORTED_GROUP = 1003, /**<  The loader does not support the requested group. */ 
+  E_INVALID_COMMAND_SIZE = 1051, /**<  The size of the command is invalid. */ 
+  E_OVERLOAD_COMMAND_TABLE = 1052, /**<  Too many commands are registered. */ 
+  E_COMMAND_ALREADY_REGISTERED = 1053, /**<  Command has already registered in execution queue. */ 
+  E_AUDITING_FAILED = 1054, /**<   Command auditing failed. */ 
+  E_NONEXIST_TIMER = 1251, /**<  Timer with the specified index does not exist. */ 
+  E_FAILED_TO_SET_TIMER = 1252, /**<  Failed to start the timer. */ 
+  E_TIMER_INIT_FAILED = 1253, /**<  Timer initialization failed. */ 
+  E_TIMER_IRQ_CONF_FAILED = 1254, /**<   */ 
+  E_GD_INVALID_UNIT_SIZE = 1351, /**<  GD/GDFS: Error in specifying unit size. */ 
+  E_GD_LL_ILLEGAL_SIZE = 1352, /**<  GD/GDFS: Size too large for the block. */ 
+  E_GD_LL_WRITE_FAILED = 1353, /**<  GD/GDFS: Write failed on FLASH device level. */ 
+  E_GD_LL_ERASE_FAILED = 1354, /**<  GD/GDFS: Erase failed on FLASH device level. */ 
+  E_GD_LL_UNKNOWN_DEVICE = 1355, /**<  GD/GDFS: FLASH device unknown. */ 
+  E_GD_STARTUP_LOG_BLK_MISSING = 1356, /**<  GD/GDFS: Logical block not found during start-up scan. */ 
+  E_GD_STARTUP_DUPLICATE_LOG_BLK = 1357, /**<  GD/GDFS: Duplicate instances of same logical block. */ 
+  E_GD_ERASE_ILLEGAL_BLK_NR = 1358, /**<  GD/GDFS: Attempt to erase non-existing physical block. */ 
+  E_GD_FG_UNIT_NOT_FOUND = 1359, /**<  GD/GDFS: Requested unit not found, probably never written or has been deleted. */ 
+  E_GD_FG_UNIT_SIZE_MISMATCH = 1360, /**<  GD/GDFS: Attempt to access a unit outside its beyond its end. */ 
+  E_GD_FG_ILLEGAL_LOG_BLK_NR = 1361, /**<  GD/GDFS: Attempt to access a logical block that does not exist. (Hardware, fatal). */ 
+  E_GD_FG_ILLEGAL_PHYS_BLK_NR = 1362, /**<  GD/GDFS: Attempt to access a physical block that does not exist (internal error). */ 
+  E_GD_FG_BLK_FULL = 1363, /**<  GD/GDFS: Attempted to write more data to a block than could be fitted into one FLASH block. */ 
+  E_GD_FG_NO_BLK_FREE = 1364, /**<  GD/GDFS: Internal error (no free blocks are available). */ 
+  E_GD_FG_UNIT_CHECKSUM = 1365, /**<  GD/GDFS: The checksum or a unit being read is wrong. */ 
+  E_GD_FG_NOT_DIRECT_BLOCK = 1366, /**<  GD/GDFS: Block is not direct. */ 
+  E_GD_FG_NOT_FREE_BLOCK = 1367, /**<  GD/GDFS: For some reason, a free block could not be properly erased. */ 
+  E_GD_FG_ILLEGAL_SIZE = 1368, /**<  GD/GDFS: The size of a unit being written exceeds the maximum limit of a unit. */ 
+  E_GD_E_FG_FREE_AREA_DIRTY = 1369, /**<  GD/GDFS: The startup check found non-FF bytes in unused range within a block. */ 
+  E_GD_FG_SYNC_FAILED = 1370, /**<  GD/GDFS: Failed to synchronize. */ 
+  E_GD_NOT_OPEN = 1371, /**<  GD/GDFS: Tried to access data although GD was in closed state. */ 
+  E_GD_NOT_ALLOWED = 1372, /**<  GD/GDFS: Operation not allowed in the current mode. */ 
+  E_GD_ALREADY_OPEN = 1373, /**<  GD/GDFS: Tried to open or format when GD was already opened. */ 
+  E_GD_FRONKENSTIENS_PATTERN_MISMATCH = 1374, /**<  GD/GDFS: The id mark of the GDVAR file does not match the data in the flash. Fatal and makes GD read only. */ 
+  E_GD_ILLEGAL_ALIGNMENT = 1375, /**<  GD/GDFS: Tried to erase at an address that was not aligned to a flash block boundary. Internal error. */ 
+  E_GD_ILLEGAL_SIZE = 1376, /**<  GD/GDFS: The operation may not be performed with the specified size. Tried to write a to large unit. */ 
+  E_GD_ACCESS_DENIED = 1377, /**<  GD/GDFS: Operation not allowed. Flash device protected. Possible wrong flash driver configuration. */ 
+  E_GD_ILLEGAL_INDEX = 1378, /**<  GD/GDFS: Illegal GD index. */ 
+  E_GD_MEMORY_ALLOCATION_FAILED = 1379, /**<  GD/GDFS: Fatal. Failed to allocate dynamic memory. */ 
+  E_GD_MISSING_CONFIG = 1380, /**<  GD/GDFS: Missing configuration parameter. */ 
+  E_GD_ILLEGAL_CONFIG = 1381, /**<  GD/GDFS: Illegal configuration. */ 
+  E_GD_TRANSACTION_LOG_CORRUPT = 1382, /**<  GD/GDFS: The transaction log used for tracking updates to GD contents is corrupt and prevents roll-back from working properly. */ 
+  E_CSPSA_RESULT_E_INVALID_KEY = 1383, /**<  Error, parameter key not valid. */ 
+  E_CSPSA_RESULT_E_OUT_OF_SPACE = 1384, /**<  Error, there is not space enough on memory media to update the parameter area. */ 
+  E_CSPSA_RESULT_E_NO_VALID_IMAGE = 1385, /**<  Error, no valid CSPSA image found. */ 
+  E_CSPSA_RESULT_E_MEDIA_INACCESSIBLE = 1386, /**<  Memory media could not be accessed. */ 
+  E_CSPSA_RESULT_E_READ_ONLY = 1387, /**<  Image is read-only. */ 
+  E_CSPSA_RESULT_E_READ_ERROR = 1388, /**<  Error occurred while reading from media. */ 
+  E_CSPSA_RESULT_E_WRITE_ERROR = 1389, /**<  Error occurred while writing to media. */ 
+  E_CSPSA_RESULT_UNDEFINED = 1390, /**<  Represents an undefined value of this enum. */ 
+  E_CSPSA_RESULT_E_END_OF_DATA = 1391, /**<  No more parameters, end of data has been reached. */ 
+  E_CSPSA_RESULT_E_OPEN_ERROR = 1392, /**<  Parameter storage area could not be opened (media error). */ 
+  E_CSPSA_RESULT_E_ALREADY_EXISTS = 1393, /**<  Parameter storage area with same name was already registered. */ 
+  E_CSPSA_RESULT_E_OUT_OF_MEMORY = 1394, /**<  There was not enough memory to perform the operation. */ 
+  E_CSPSA_RESULT_E_BAD_PARAMETER = 1395, /**<  Error because of bad input parameter. */ 
+  E_GD_NO_DATA_TO_READ = 1399, /**<  GD: No data to read. */ 
+  E_BDM_W_NO_MORE_GC_POSSIBLE = 1451, /**<  BDM: No more garbage collection is possible. */ 
+  E_BDM_UNIT_STARTED = 1452, /**<  BDM: Unit has already been started. */ 
+  E_BDM_UNIT_NOT_STARTED = 1453, /**<  BDM: Unit has not yet been started. */ 
+  E_BDM_NOT_CONFIGURED = 1454, /**<  BDM: Has not been configured yet. */ 
+  E_BDM_STARTUP_FAILED = 1455, /**<  BDM: Startup failed. */ 
+  E_BDM_SHUTDOWN_FAILED = 1456, /**<  BDM: Shutdown failed. */ 
+  E_BDM_WRITE_FAILED = 1457, /**<  BDM: An error occurred while writing. */ 
+  E_BDM_READ_FAILED = 1458, /**<  BDM: An error occurred while reading */ 
+  E_BDM_ERASE_FAILED = 1459, /**<  BDM: An error occurred while erasing. */ 
+  E_BDM_JUNK_FAILED = 1460, /**<  BDM: An error occurred while junking. */ 
+  E_BDM_GC_FAILED = 1461, /**<  BDM: An error occurred while garbage collecting. */ 
+  E_BDM_GET_INFO_FAILED = 1462, /**<  BDM: An error occurred while retrieving info about a BDM unit. */ 
+  E_BDM_WRITE_NOT_SUPPORTED = 1463, /**<  BDM: Write not supported. */ 
+  E_BDM_JUNK_NOT_SUPPORTED = 1464, /**<  BDM: Junk not supported. */ 
+  E_BDM_GC_NOT_SUPPORTED = 1465, /**<  BDM: Garbage collection not supported. */ 
+  E_BDM_SYNC_FAILED = 1466, /**<  BDM: Synchronize failed. */ 
+  E_BDM_NOT_SUPPORTED = 1467, /**<  BDM: Function not supported. */ 
+  E_BDM_PAUSED = 1468, /**<  BDM: Paused. */ 
+  E_BDM_NOT_PAUSED = 1469, /**<  BDM: Not paused. */ 
+  E_BDM_FINDING_BAM_BLOCKS = 1470, /**<  BDM: BAM blocks not found. */ 
+  E_BDM_BAD_PARAM = 1471, /**<  BDM: Argument invalid or out of range. */ 
+  E_BDM_FORMAT_FAILED = 1472, /**<  BDM: Formatting failed. */ 
+  E_BDM_INVALID_UNIT = 1473, /**<  BDM: The unit number is out of range. */ 
+  E_BDM_INVALID_CONFIG = 1474, /**<  BDM: Some part of the configuration is invalid. */ 
+  E_BDM_PRE_FLASH_FINISHED = 1475, /**<  BDM: No more preflash blocks can be fetched. */ 
+  E_BDM_PRE_FLASH_TERMINATE_FAILED = 1476, /**<  BDM: Termination of preflash failed. */ 
+  E_BDM_OUT_OF_MEM = 1477, /**<  BDM: Could not allocate enough memory. */ 
+  E_BDM_XSR_CRITICAL_ERROR = 1481, /**<  BDM XSR: Critical error. */ 
+  E_BDM_XSR_INVALID_PARAMS = 1482, /**<  BDM XSR: Invalid parameters. */ 
+  E_BDM_XSR_PARTITION_NOT_OPENED = 1483, /**<  BDM XSR: Could not open partition. */ 
+  E_BDM_XSR_UNFORMATTED_FLASH = 1484, /**<  BDM XSR: Unformatted flash. */ 
+  E_BDM_XSR_ALLOCATION_ERROR = 1485, /**<  BDM XSR: Failed to allocate. */ 
+  E_BDM_XSR_INVALID_PARTITION = 1486, /**<  BDM XSR: Invalid partition. */ 
+  E_BDM_XSR_READ_ERROR = 1487, /**<  BDM XSR: An error occurred while reading. */ 
+  E_BDM_XSR_WRITE_ERROR = 1488, /**<  BDM XSR: An error occurred while writing. */ 
+  E_BDM_XSR_ERASE_ERROR = 1489, /**<  BDM XSR: An error occurred while erasing. */ 
+  E_BDM_XSR_DEVICE_ERROR = 1490, /**<  BDM XSR: Device error. */ 
+  E_BDM_XSR_GOODBLOCK = 1491, /**<  BDM XSR: Good block. */ 
+  E_BDM_XSR_BADBLOCK = 1492, /**<  BDM XSR: Bad block. */ 
+  E_BAM_NOT_CONFIGURED = 1551, /**<  BAM: Is not configured. */ 
+  E_BAM_ERR_UNSUPPORTED_PAGE_SIZE = 1552, /**<  BAM: Unsupported page size. */ 
+  E_BAM_ERR_ERASING_BLOCK = 1553, /**<  BAM: Erase block could not be properly erased. */ 
+  E_BAM_ERR_OUT_OF_MEMORY = 1554, /**<  BAM: Not enough free memory to serve request. */ 
+  E_BAM_ERR_CHECKING_BADNESS = 1555, /**<  BAM: There was a problem checking if a block was bad or not. */ 
+  E_BAM_ERR_FINDING_BLOCK = 1556, /**<  BAM: Reserved block could not be found. */ 
+  E_BAM_ERR_READING_PAGE = 1557, /**<  BAM: An error occurred while reading a page in a block. */ 
+  E_BAM_ERR_MARKING_BLOCK_BAD = 1558, /**<  BAM: A block went bad and BAM could not mark it as bad properly. */ 
+  E_BAM_ERR_READING_OUTSIDE_BLOCK = 1559, /**<  BAM: Read would result in a read beyond end of reserved block. */ 
+  E_BAM_ERR_UNCORRECTABLE_ERROR = 1560, /**<  BAM: An uncorrectable read error occurred while reading block. */ 
+  E_BAM_ERR_WRITING_PAGE = 1561, /**<  BAM: An error occurred while writing a page to a reserved block. */ 
+  E_BAM_ERR_WRITING_BLOCK = 1562, /**<  BAM: An error occurred while writing to a reserved block. */ 
+  E_BAM_ERR_RESCUING_BLOCK = 1563, /**<  BAM: There was a problem rescuing a block that went bad during the request. */ 
+  E_BAM_ERR_CONFIG_MISSING = 1564, /**<  BAM: No configuration was given. */ 
+  E_BAM_ERR_ALREADY_STARTED = 1565, /**<  BAM: Has already been started. */ 
+  E_BAM_ERR_NOT_STARTED = 1566, /**<  BAM: Has not been started yet. */ 
+  E_BAM_ERR_UNSUPPORTED_OPERATION = 1567, /**<  BAM: Requested operation is not supported. */ 
+  E_BAM_ERR_CORRUPT_STATE = 1568, /**<  BAM: Internal state has been corrupted. */ 
+  E_BAM_ERR_UNSUPPORTED_MEDIA = 1569, /**<  BAM: The configured media type is not supported. */ 
+  E_BAM_ERR_UNSUPPORTED_REDUNDANT_AREA_SIZE = 1570, /**<  BAM: Unsupported redundant area size. */ 
+  E_BAM_ERR_READING_BLOCK = 1571, /**<  BAM: Reading block failed. */ 
+  E_BAM_ERR_SHUTTING_DOWN = 1572, /**<  BAM: Shutting down failed. */ 
+  E_BAM_ERR_UNINITIALIZING = 1573, /**<  BAM: An error occurred with uninitializing. */ 
+  E_BAM_ERR_INVALID_OFFSET = 1574, /**<  BAM: Invalid offset. */ 
+  E_BAM_ERR_INVALID_SIZE = 1575, /**<  BAM: Invalid size. */ 
+  E_BAM_ERR_RETRIEVING_INFO = 1576, /**<  BAM: Retrieving info failed. */ 
+  E_BAM_ERR_INVALID_CONFIG = 1577, /**<  BAM: Invalid configuration. */ 
+  E_BAM_ERR_ERASING_ALL_BLOCKS = 1578, /**<  BAM: An error occurred while erasing all blocks. */ 
+  E_BAM_ERR_BLOCK_MARKED_BAD = 1579, /**<  BAM: Block was marked as bad while doing an operation. */ 
+  E_BAM_ERR_VALIDATING_START_BLOCK = 1580, /**<  BAM: Can not assure that start block configuration refers to a block boundary. */ 
+  E_BAM_ERR_FAILED_TO_GET_MEMORYTECHNOLOGY = 1581, /**<  BAM: Unable the query FAM about the memory technology used in the memory we are trying to initialize BAM on. */ 
+  E_BAM_ERR_BLOCK_RESCUED = 1582, /**<  BAM: Block rescue failed. */ 
+  E_BAM_ERR_DETERMINING_BBM = 1583, /**<  BAM: Failed to determine what BBM type configuration has been written to flash. */ 
+  E_BAM_ERR_SET_ECC_LENGTH = 1584, /**<  BAM: Failed to set the length to use with HW ECC acceleration. */ 
+  E_BAM_ERR_INVALID_BBM_TYPE = 1585, /**<  BAM: Invalid BBM type. */ 
+  E_BAM_ERR_BOOT_BDM_CONFIG_FAILED = 1586, /**<  BAM: Failed to configure boot block device management. */ 
+  E_BAM_ERR_BOOT_BDM_STARTUP_FAILED = 1587, /**<  BAM: Failed to startup boot block device management. */ 
+  E_BAM_ERR_BOOT_BDM_INSTANCE_NOT_FOUND = 1588, /**<  BAM: Boot block device management instance not found. */ 
+  E_BAM_ERR_BOOT_BDM_BLOCKS_NOT_FOUND = 1589, /**<  BAM: Boot block device management blocks not found. */ 
+  E_BAM_ERR_BOOT_BDM_NOT_STARTED = 1590, /**<  BAM: Boot block device management not started. Requested operation require BDM to be started. */ 
+  E_BAM_ERR_UNIT_OUT_OF_RANGE = 1591, /**<  BAM: Unit is out of range. */ 
+  E_BAM_ERR_BDM_STARTUP_FAILED = 1592, /**<  BAM: Block device management startup failed. */ 
+  E_BAM_ERR_BLOCK_NOT_ERASED = 1593, /**<  BAM: Block not erased. */ 
+  E_BAM_ONLD_CRITICAL_ERROR = 1601, /**<  BAM ONLD: Critical error. */ 
+  E_BAM_ONLD_INVALID_PARAMS = 1602, /**<  BAM ONLD: Invalid parameters. */ 
+  E_BAM_ONLD_INITIALISATION_ERROR = 1603, /**<  BAM ONLD: Initialisation error. */ 
+  E_BAM_ONLD_READ_ERROR = 1604, /**<  BAM ONLD: An error occurred while reading. */ 
+  E_BAM_ONLD_WRITE_ERROR = 1605, /**<  BAM ONLD: An error occurred while writing. */ 
+  E_BAM_ONLD_ERASE_ERROR = 1606, /**<  BAM ONLD: An error occurred while erasing. */ 
+  E_BAM_ONLD_DEVICE_ERROR = 1607, /**<  BAM ONLD: Device error. */ 
+  E_BAM_ONLD_GOODBLOCK = 1608, /**<  BAM ONLD: Good block. */ 
+  E_BAM_ONLD_BADBLOCK = 1609, /**<  BAM ONLD: Bad block. */ 
+  E_COPS_MEMORY_ALLOC_FAILED = 1651, /**<  COPS: Memory allocation failed. */ 
+  E_COPS_DATA_TAMPERED = 1652, /**<  COPS: Data is tempered. */ 
+  E_COPS_IMEI_MISSMATCH = 1653, /**<  COPS: IMEI missmatch. */ 
+  E_COPS_OTP_LOCKED = 1654, /**<  COPS: OTP is locked. */ 
+  E_COPS_MAC_FUNCTION_LOCKED_DOWN = 1655, /**<  COPS: Function for calculating MAC is locked down. */ 
+  E_COPS_AUTHENTICATION_FAILED = 1656, /**<  COPS: Authentication failed. */ 
+  E_COPS_DATA_NOT_PRESENT = 1657, /**<  COPS: Default Data is not present. */ 
+  E_COPS_IMEI_UPDATE_NOT_ALLOWED = 1658, /**<  COPS: IMEI update is not allowed. */ 
+  E_COPS_LOCK_PERMANENTLY_DISABLED = 1659, /**<  COPS: Locking of SIMLocks is disabled. */ 
+  E_COPS_NO_ATTEMPTS_LEFT = 1660, /**<  COPS: No more attempts for verification left. */ 
+  E_COPS_INCORRECT_CONTROLKEY = 1661, /**<  COPS: Control key is not correct. */ 
+  E_COPS_TOO_SHORT_CONTROLKEY = 1662, /**<  COPS: Control key is too short. */ 
+  E_COPS_TOO_LONG_CONTROLKEY = 1663, /**<  COPS: Control key is too long. */ 
+  E_COPS_INVALID_CONTROLKEY = 1664, /**<  COPS: Control key is not valid. */ 
+  E_COPS_TIMER_RUNNING = 1665, /**<  COPS: Timer is running. */ 
+  E_COPS_SIM_ERROR = 1666, /**<  COPS: SIM error. */ 
+  E_COPS_LOCKING_FAILED = 1667, /**<  COPS: Locking failed. */ 
+  E_COPS_OTA_UNLOCK_IMEI_MISMATCH = 1668, /**<  COPS: OTA unlock IMEI mismatch. */ 
+  E_COPS_INCORRECT_IMSI = 1669, /**<  COPS: Incorrect IMSI. */ 
+  E_COPS_PARAMETER_ERROR = 1670, /**<  COPS: Parameter error. */ 
+  E_COPS_BUFFER_TOO_SMALL = 1671, /**<  COPS: Memory buffer is too small. */ 
+  E_COPS_FORBIDDEN_PARAMETER_ID = 1672, /**<  COPS: Parameter is not allowed. */ 
+  E_COPS_UNKNOWN_PARAMETER_ID = 1673, /**<  COPS: Parameter can not be recognised. */ 
+  E_COPS_ARGUMENT_ERROR = 1674, /**<  COPS: Argument error! */ 
+  E_COPS_VERIFY_FAILED = 1698, /**<  COPS: Failed to verify internal data. */ 
+  E_COPS_UNDEFINED_ERROR = 1699, /**<  COPS: Undefined error. */ 
+  E_PD_NAND_RESULT_BIT_ERROR_CORRECTED = 1751, /**<  PD NAND: A bit error was detected and corrected. */ 
+  E_PD_NAND_RESULT_UNCORRECTABLE_BIT_ERROR = 1752, /**<  PD NAND: An uncorrectable bit error was detected. */ 
+  E_PD_NAND_RESULT_BAD_PARAMETER = 1753, /**<  PD NAND: The function could not perform the requested operation due to a bad parameter. */ 
+  E_PD_NAND_RESULT_HW_ERROR = 1754, /**<  PD NAND: A hardware error occurred. */ 
+  E_PD_NAND_RESULT_INTERNAL_ERROR = 1755, /**<  PD NAND: A module internal error has occurred. The module has reach an unexpected state or request. */ 
+  E_PD_NAND_RESULT_BUSY = 1756, /**<  PD NAND: Busy flag was returned. */ 
+  E_PD_NAND_RESULT_READING_ERASED_PAGE = 1757, /**<  PD NAND: Attempting to read erased page. */ 
+  E_PD_NAND_RESULT_NUMBER_OF_ITEMS = 1758, /**<  PD NAND: Number of valid states of this type. */ 
+  E_PD_NAND_RESULT_UNDEFINED = 1759, /**<  PD NAND: Represents an undefined value of this type. */ 
+  E_GD_TA_BASE = 1851, /**<  GD/TA: TA base. */ 
+  E_GD_TA_UNKNOWN_PARTITION = 1852, /**<  GD/TA: Unknown partition. */ 
+  E_GD_TA_UNKNOWN_CONFIG = 1853, /**<  GD/TA: Unknown configuration. */ 
+  E_GD_TA_ILLOGICAL_CONFIGURATION = 1854, /**<  GD/TA: Ilogical configuration. */ 
+  E_GD_TA_UNKNOWN_MEMORY_TYPE = 1855, /**<  GD/TA: Unknown memory type. */ 
+  E_GD_TA_WRONG_PARAMETER = 1856, /**<  GD/TA: Wrong parameter. */ 
+  E_GD_TA_OUT_OF_MEMORY = 1857, /**<  GD/TA: Out of memory. */ 
+  E_GD_TA_INVALID_ADRESS = 1858, /**<  GD/TA: Invalid adress. */ 
+  E_GD_TA_UNUSED_ADRESS = 1859, /**<  GD/TA: Unused adress. */ 
+  E_GD_TA_UNIT_NOT_FOUND = 1860, /**<  GD/TA: Unit not found. */ 
+  E_GD_TA_NOT_IMPLEMENTED = 1861, /**<  GD/TA: TA is not supported. */ 
+  E_GD_TA_FAIL = 1862, /**<  GD/TA: TA fail. */ 
+  E_GD_UNKNOWN_UNIT_NAME = 1863, /**<  GD: Unknown unit name. */ 
+  E_GD_LAST = 1864, /**<  GD: Last enumeration (last valid + 1). */ 
+  E_FAILED_TO_STORE_IN_FIFO = 1900, /**<  Failed to store data in FIFO. */ 
+  E_FAILED_TO_SET_COMM_DEVICES = 1951, /**<  Failed to set parameters of communications devices. */ 
+  E_FAILED_TO_STORE_IN_STACK = 1952, /**<  Failed to store in stack. */ 
+  E_ZIP_PARSER_FILE_NOT_FOUND = 1954, /**<  The requested file is not found in the specified Zip archive. */ 
+  E_ELF_FILE_FORMAT = 1955, /**<  The requested file is not an elf file. */ 
+  E_ELF_OPEN_SECTION = 1956, /**<  Can not open elf section. */ 
+  E_NAME_TOO_LONG = 1957, /**<  The name of parameter is too long. */ 
+  E_BOOTRECORDS_MISMATCH = 1958, /**<  Error in boot records. */ 
+  E_BOOTRECORD_EMPTY = 1959, /**<  Boot record is empty and operation cannot be executed. */ 
+  E_INVALID_BOOTRECORD_IMAGE = 1960, /**<  Boot record image is not valid. */ 
+  E_BOOTRECORD_FULL = 1961, /**<  Boot record has no space to accept new boot record. */ 
+  E_BOOTRECORD_NOT_EXIST = 1962, /**<  Boot record not exist. */ 
+  E_BOOTRECORD_WRITE_FAILED = 1963, /**<  Writing failed. */ 
+  E_BOOTRECORD_UNALIGNED_DATA = 1964, /**<  Boot record data is unaligned. */ 
+  E_CONTENT_TYPE = 1965, /**<  Content type to long. */ 
+  E_DEVICE_TYPE = 1966, /**<  Device type to long. */ 
+  E_NUMBER_OF_TARGET_DEVICES = 1967, /**<  Number of target devices to big. */ 
+  E_DESCRIPTION_TOO_LONG = 1968, /**<  Description field too long. */ 
+  E_MODULE_NOT_FOUND = 2000, /**<  Testing this module currently not supported in ADbg. */ 
+  E_MODULE_LIST_EMPTY = 2001, /**<  There isn't any module available for testing. */ 
+  E_CASE_NOT_FOUND = 2002, /**<  Specified case can not be found. */ 
+  E_CASE_LIST_EMPTY = 2003, /**<  There isn't any test cases in specified module. */ 
+  E_INT_GROUP_NOT_FOUND = 2004, /**<  Specified internal group can not be found. */ 
+  E_INT_GROUP_LIST_EMPTY = 2005, /**<  There isn't any internal group. */ 
+  E_INT_FUNCTION_NOT_FOUND = 2006, /**<  Specified interface function cannot be found. */ 
+  E_INT_FUNCTION_LIST_EMPTY = 2007, /**<  There isn't any interface function in interface group. */ 
+  E_PRECONDITION_IS_ALREADY_SET = 2008, /**<  Request for setting precondition that is already set. */ 
+  E_PRECONDITION_IS_NOT_SET = 2009, /**<  Request to recover condition that is not changed. */ 
+  E_INIT_OTP_PD_FAILED = 2100, /**<  Failed to initialize OTD driver. */ 
+  E_READING_OTP_FAILED = 2101, /**<  Failed to read data from OTP. */ 
+  E_WRITTING_OTP_FAILED = 2102, /**<  Failed to write data in OTP. */ 
+  E_INVALID_CID_VALUE = 2103, /**<  Trying to write invalid CID in OTP. */ 
+  E_INIT_OTP_LD_FAILED = 2104, /**<  Failed to initialize OTD logical driver. */ 
+  E_OTP_AREA_LOCKED = 2105, /**<  Requested OTP area is already locked. */ 
+  E_SEC_APP_PROPERTY_NOT_FOUND = 2251, /**<  App property cannot be found. */ 
+  E_SEC_APP_IMEI_NOT_CHANGABLE = 2252, /**<  IMEI not changeable. */ 
+  E_SEC_APP_OPERATION_DENIED = 2253, /**<  Security operation denied. */ 
+  E_SEC_APP_UNABLE_TO_READ_BS_PARAMETERS = 2254, /**<  Incorrect Boot Stage Parameter vector. */ 
+  E_SEC_APP_ROM_ERROR_CRITICAL = 2255, /**<  Critical error in ROM has occurred. */ 
+  E_SEC_APP_ROM_ERROR = 2256, /**<  Unexpected ROM error. */ 
+  E_SEC_APP_PATCH_EXISTS = 2257, /**<  ROM Patch is already installed. */ 
+  E_SEC_APP_PATCH_REINSTALLED = 2258, /**<  Operation successful. */ 
+  E_SEC_APP_ROOTKEY_EXISTS = 2259, /**<  RootKey is already installed. */ 
+  E_SEC_APP_ROOTKEY_REINSTALLED = 2260, /**<  Operation successful. */ 
+  E_TA_WRONG_PARTITION = 2351, /**<  TA: Unknown partition. */ 
+  E_TA_ILLOGICAL_CONFIGURATION = 2352, /**<  TA: Configuration error. */ 
+  E_TA_UNKNOWN_MEMORY_TYPE = 2353, /**<  TA: Unsupported memory type. */ 
+  E_TA_WRONG_PARAMETER = 2354, /**<  TA: Wrong parameter. */ 
+  E_TA_OUT_OF_MEMORY = 2355, /**<  TA: No heap memory left. */ 
+  E_TA_INVALID_ADRESS = 2356, /**<  TA: Invalid address. */ 
+  E_TA_UNUSED_ADRESS = 2357, /**<  TA: Unused address. */ 
+  E_TA_UNIT_NOT_FOUND = 2358, /**<  TA: Unit was not found. */ 
+  E_TA_WRONG_SIZE = 2359, /**<  TA: Wrong size when reading unit. */ 
+  E_TA_INSUFFICIANT_SPACE = 2360, /**<  TA: Not enough space to flush the Trim Area. */ 
+  E_TA_UNKNOWN_PARTITION = 2361, /**<  TA: Unknown partition. */ 
+  E_TA_FAIL = 2362, /**<  TA: Fail. */ 
+  E_TA_MEDIA_ERROR = 2460, /**<  TA: Media error. */ 
+  E_TA_NOT_CONFIGURED = 2461, /**<  TA: Error occurs during configuration. */ 
+  E_REQUEST_DENIED = 2500, /**<  Request for change operation denied. */ 
+  E_UNDEFINED_CHANGE_OPERATION = 2501, /**<  Requested change operation is not supported. */ 
+  E_PD_CFI_IN_PROGRESS = 2651, /**<  PD CFI: The operation is in progress. Additional poll calls must be done. */ 
+  E_PD_CFI_UNKNOWN_REQUEST = 2652, /**<  PD CFI: Type not recognized. */ 
+  E_PD_CFI_HARDWARE_ERROR = 2653, /**<  PD CFI: Operation could not be completed because of a hardware malfunction. */ 
+  E_PD_CFI_NOT_SUPPORTED = 2654, /**<  PD CFI: The driver does not implement the requested function. */ 
+  E_PD_CFI_PARAMETER_ERROR = 2655, /**<  PD CFI: Invalid parameter value. */ 
+  E_PD_CFI_PROTECTED = 2656, /**<  PD CFI: The requested flash address is protected from the requested type of access. */ 
+  E_PD_CFI_UNSUPPORTED_DEVICE = 2657, /**<  PD CFI: Flash devices not supported by this driver. */ 
+  E_PD_CFI_OPERATION_COMPLETE = 2658, /**<  PD CFI: Requested operation was not suspended as it has completed. */ 
+  E_PD_CFI_HARDWARE_NOT_DETECTED = 2659, /**<  PD CFI: NOR memory was not detected on current configuration. */ 
+  E_HSI_BSC_RESULT_FAILED = 2701, /**<  General Error. */ 
+  E_HSI_BSC_RESULT_FAILED_INVALIDARGS = 2702, /**<  Invalid arguments. */ 
+  E_HSI_BSC_RESULT_FAILED_NOTSUPPORTED = 2703, /**<  Implementation is removed. */ 
+  E_HSI_BSC_RESULT_FAILED_HSIERR = 2704, /**<  HSI internal error. */ 
+  E_HSI_BSC_RESULT_FAILED_BUSY = 2705, /**<  Communication device is busy. */ 
+  E_HSI_BSC_ERROR_SIGNAL = 2751, /**<  Signal error. */ 
+  E_HSI_BSC_ERROR_TIMEOUT = 2752, /**<  Timeout error. */ 
+  E_HSI_BSC_ERROR_BREAK = 2753, /**<  Break received. */ 
+  E_HSI_BSC_ERROR_RECEIVE = 2754, /**<  Receive buffer is not provided. */ 
+  E_HSI_BSC_ERROR_TRANSMIT = 2755, /**<  Transmit buffer is not provided. */ 
+  E_CR_INVALID_STATE = 2850, /**<  Invalid state for commnication relay detected. */ 
+  E_CR_NOT_RUNNING = 2851, /**<  Communication Relay is not running. */ 
+  E_SDIO_BSC_RESULT_FAILED = 2901, /**<  General Error. */ 
+  E_SDIO_BSC_RESULT_FAILED_INVALIDARGS = 2902, /**<  Invalid arguments. */ 
+  E_SDIO_BSC_RESULT_FAILED_NOTSUPPORTED = 2903, /**<  Implementation is removed. */ 
+  E_SDIO_BSC_RESULT_FAILED_SDIOERR = 2904, /**<  SDIO internal error. */ 
+  E_SDIO_BSC_RESULT_FAILED_BUSY = 2905, /**<  Communication device is busy. */ 
+  E_SDIO_BSC_ERROR_TIMEOUT = 2951, /**<  Timeout error. */ 
+  E_SDIO_BSC_ERROR_BREAK = 2952, /**<  Break received. */ 
+  E_SDIO_BSC_ERROR_RECEIVE = 2953, /**<  Receive buffer is not provided. */ 
+  E_SDIO_BSC_ERROR_TRANSMIT = 2954, /**<  Transmit buffer is not provided. */ 
+  E_LOADER_SEC_LIB_CHIP_ID_INVALID = 4000, /**<  Invalid input parameters. */ 
+  E_LOADER_SEC_LIB_INVALID_PARAMETER_TO_FUNC = 4096, /**<  Invalid input parameters. */ 
+  E_LOADER_SEC_LIB_FAILURE = 4120, /**<  Failure. */ 
+  E_LOADER_SEC_LIB_HASH_LIST_HASH_FAILURE = 4121, /**<  hash list verification failed. */ 
+  E_LOADER_SEC_LIB_HEADER_VERIFICATION_FAILURE = 4122, /**<  Header verification failed.  */ 
+  E_LOADER_SEC_LIB_HEADER_VERIFIED = 4123, /**<  Successful verification of the header */ 
+  E_LOADER_SEC_LIB_VERIFY_FAILURE = 4124, /**<  Unsuccessful verification. */ 
+  E_LOADER_SEC_LIB_INIT_CALLED_TWICE = 4150, /**<  The security library init function has been called 2 times. */ 
+  E_LOADER_SEC_LIB_MEMORY_RELEASE_FAILED = 4180, /**<  Memory release failed. */ 
+  E_LOADER_SEC_LIB_MEMORY_ALLOCATION_FAILED = 4181, /**<  Memory allocation failed. */ 
+  E_LOADER_SEC_LIB_DATA_BLOCK_EXIST = 4182, /**<  Data block exist in the linked list. */ 
+  E_LOADER_SEC_LIB_DATA_BLOCK_DO_NOT_EXIST = 4183, /**<  Data block do not exist in the linked list. */ 
+  E_LOADER_SEC_LIB_INVALID_AUTHENTICATION_TYPE = 4184, /**<  Invalid authentication type. */ 
+  E_LOADER_SEC_LIB_EXCEEDED_NUMBER_OF_AUTHENTICATION = 4185, /**<  Exceeded number of authentication. Loader will be shut downed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_INIT_FAILED = 4186, /**<  Initialization of ESB block for MAC calculation failed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_UPDATE_FAILED = 4187, /**<  MAC update with ESB block failed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_FINAL_FAILED = 4188, /**<  MAC finalize with ESB block failed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_NOT_VERIFIED = 4189, /**<  MAC verification with ESB block failed. */ 
+  E_LOADER_SEC_LIB_ESB_DOWNLOCK_FAILED = 4190, /**<  ESB downlock failed. */ 
+  E_LOADER_SEC_LIB_CONTROL_KEY_VERIFICATION_FAILURE = 4191, /**<  Control key verification failed. */ 
+  E_LOADER_SEC_LIB_CA_CERTIFICATE_VERIFICATION_FAILURE = 4192, /**<  CA certificate verification failed. */ 
+  E_LOADER_SEC_LIB_X509_ERROR_IN_CERTIFICATE = 4193, /**<  X509 certificate error. */ 
+  E_LOADER_SEC_LIB_COPS_INIT_FAILED = 4194, /**<  COPS initialization failed. */ 
+  E_LOADER_SEC_LIB_COPS_PROTECT_DATA_INIT_FAILED = 4195, /**<  COPS protect data initialization failed. */ 
+  E_LOADER_SEC_LIB_COPS_DATA_READ_FAILED = 4196, /**<  COPS data read failed. */ 
+  E_LOADER_SEC_LIB_COPS_DATA_WRITE_FAILED = 4197, /**<  COPS data write failed. */ 
+  E_LOADER_SEC_LIB_READ_OTP_FAILED = 4198, /**<  Reading OTP data failed. */ 
+  E_LOADER_SEC_LIB_WRITE_OTP_FAILED = 4199, /**<  Writing OTP data failed. */ 
+  E_LOADER_SEC_LIB_LOCK_OTP_FAILED = 4200, /**<  Locking OTP data failed. */ 
+  E_LOADER_SEC_LIB_UNPACKING_IMEI_FAILED = 4201, /**<  Unpacking IMEI data failed. */ 
+  E_LOADER_SEC_LIB_PACKING_IMEI_FAILED = 4202, /**<  Packing IMEI data failed. */ 
+  E_LOADER_SEC_LIB_OTP_ALREADY_LOCKED = 4203, /**<  OTP is already locked. */ 
+  E_LOADER_SEC_LIB_INVALID_CID_VALUE = 4204, /**<  CID value is out of range. */ 
+  E_LOADER_SEC_LIB_OTP_LOCKBITS_MISSMATCH = 4205, /**<  OTP lock bits have different values. */ 
+  E_LOADER_SEC_LIB_WRITING_BOOTRECORD_FAILED = 4206, /**<  Failed to write in boot records. */ 
+  E_LOADER_SEC_LIB_UNSUPPORTED_NO_DEBUG_HW = 4207, /**<  No debug hardware detected. */ 
+  E_LOADER_SEC_LIB_CHANGE_OPERATION_NOT_SUPPORTED = 4208, /**<  Requested change operation is not supported or not allowed. */ 
+  E_LOADER_SEC_LIB_INVALID_CHANGE_OPERATION = 4209, /**<  Invalid change operation. */ 
+  E_LOADER_SEC_LIB_RWIMEI_NOT_ALLOWED = 4210, /**<  Rewriteable IMEI is not allowed to change. */ 
+  E_LOADER_SEC_LIB_REQUEST_DENIED = 4211, /**<  Request for change operation is denied. */ 
+  E_LOADER_SEC_LIB_BOOT_BLOCK_DO_NOT_EXIST = 4212, /**<  Boot record do not exist. */ 
+  E_LOADER_SEC_LIB_CORRUPTED_DOMAIN_DATA = 4213, /**<  Corrupted or do not exist domain data in boot block. */ 
+  E_LOADER_SEC_LIB_INVALID_DOMAIN = 4214, /**<  Invalid domain. */ 
+  E_LOADER_SEC_LIB_INVALID_CHALLENGE_DATA_BLOCK = 4215, /**<  Invalid challenge data block. */ 
+  E_LOADER_SEC_LIB_NO_DEBUG_HW_NOT_ALLOWED = 4216, /**<  Not allowed operation on NoDebug HW. */ 
+  E_FIFO_OVERFLOW = 4300, /**<  UART FIFO overflow. */ 
+  E_FIFO_UNDERFLOW = 4301, /**<  UART FIFO underflow. */ 
+  E_OBJECT_NULL = 4302, /**<  Null pointer to Object. */ 
+  E_POINTER_NOT_NULL = 4303, /**<  Pointer is not NULL. */ 
+  E_UNRECOGNIZED_STATE = 4304, /**<  The state in the State Machine is invalid. */ 
+  E_UNKNOWN_MANUFACTURER_ID = 4305, /**<  The provided manufacturer ID is not valid. */ 
+  E_UNKNOWN_DEVICE_ID = 4306, /**<  The provided device ID is not valid. */ 
+  E_INVALID_A01_FORMAT = 4308, /**<  Something wrong with the A01 file containing the flash image. */ 
+  E_A01_BUFFER_FULL = 4309, /**<  Buffer holding the data from the A01 file is full. */ 
+  E_CONFIG_FILE_NOT_SPECIFIED = 4350, /**<  Configuration file for the emulator is not specified. */ 
+  A2_E_SUCCESS = 5000, /**<  Operation successful. */ 
+  A2_E_PROP_NOT_SUPPORTED = 5001, /**<  The property is not supported. */ 
+  A2_E_PROP_READ_ONLY = 5002, /**<  The property is read only. */ 
+  A2_E_PROP_INVALID = 5003, /**<  The property value is invalid. */ 
+  A2_E_AUTH_DECLINED = 5004, /**<  Authentication declined. The ME is automatically shut down after sending this. */ 
+  A2_E_AUTH_UNSUPPORTED = 5005, /**<  The authentication type is not supported. */ 
+  A2_E_ALLOCATE_FAILED = 5006, /**<  Failed to allocate memory. */ 
+  A2_E_INVALID_TIME = 5007, /**<  Invalid time specified. */ 
+  A2_E_UNKNWON_PROPERTY = 5008, /**<  Unknown property id. */ 
+  A2_E_START_AAIF_FAILED = 5009, /**<  Failed to start the AAIF in the loader on loader. */ 
+  A2_E_UNSUPPORTED_CMD = 5010, /**<  Unsupported command. */ 
+  A2_E_POINTER_NOT_ALIGNED = 5011, /**<  Pointer not aligned. */ 
+  A2_E_ERROR_WRITING_BOOTRECORD = 5012, /**<  Writing of the boot record failed. */ 
+  A2_E_INVALID_CURRDATE_STRING_LENGTH = 5013, /**<  String data length is invalid. */ 
+  A2_E_NO_COMMAND_GROUPS_DEFINED = 5014, /**<  Unknown command group. */ 
+  A2_E_READ_OTP_FAILED = 5015, /**<  Read OTP failed. */ 
+  A2_E_COMMAND_IS_NOT_IMPLEMENTED = 5016, /**<  Specified command is not implemented. */ 
+  A2_E_FAILED_TO_GET_ASIC_COPS_SETTINGS = 5017, /**<  Failed to get ASIC COPS setting. */ 
+  A2_E_FAILED_TO_SET_PLAT_PROP = 5018, /**<  Failed to set platform properties. */ 
+  A2_E_MEMORY_FAILED = 5019, /**<  Memory fail. */ 
+  A2_E_JTAG_UNLOCK_FAILED = 5020, /**<  JTAG unlock fail. */ 
+  A2_E_AUTOCONFIGURE_FLASH = 5021, /**<   */ 
+  A2_E_E_GET_FIRST_FLASH_DEV = 5022, /**<   */ 
+  A2_E_E_FAILED_INIT_COPS_LIB = 5023, /**<  Failed to initialize COPS library. */ 
+  A2_E_OTP_SECURITY_ERROR = 5024, /**<  OTP security error. */ 
+  A2_E_I2C_BUS_SECURITY_ERROR = 5025, /**<  I2C bus security error. */ 
+  A2_E_GET_STATIC_DATA_FAILED = 5026, /**<  Can't get static data. */ 
+  A2_E_STORE_MAC_TO_BOOTIMAGE_FAILED = 5027, /**<  Failed to store MAC in boot image. */ 
+  A2_E_SEC_GENERAL_COPS_LIB_ERROR = 5028, /**<  General COPS error. */ 
+  A2_E_HASH_VERIFICATION_ERROR = 5029, /**<  Hash verification failed. */ 
+  A2_E_READ_FLASH_FAILED = 5030, /**<  Failed to read hash. */ 
+  A2_E_APP_HANDSHAKE_FAILED = 5031, /**<  Processors handshake failed. */ 
+  A2_E_BOOTIMAGE_MEMCONF_INVALID = 5032, /**<  Invalid memconfig in boot image. */ 
+  A2_E_BOOTIMAGE_SIGNATURE_FAILED = 5033, /**<  Boot image signature failed. */ 
+  A2_E_BOOTIMAGE_FAILED_TO_READ_IMAGE = 5034, /**<  Failed to read image. */ 
+  A2_E_BOOTIMAGE_FAILED_ALLOCATE_MEM = 5035, /**<  Failed to allocate memory. */ 
+  A2_E_BOOTIMAGE_INVALID_PARAM = 5036, /**<  Boot image invalid parametars. */ 
+  A2_E_BOOTIMAGE_INVALID_LENGTH = 5037, /**<  Boot image has invalid length. */ 
+  A2_E_BOOTIMAGE_MACED_HEADER_SIZE_ZERO = 5038, /**<  Header size is zero. */ 
+  A2_E_FLASH_RESULT_DEVICE_PROTECTED = 5039, /**<  The flash device was protected. */ 
+  A2_E_FLASH_RESULT_WRITE_SUSPENDED = 5040, /**<  The last write process was suspended. */ 
+  A2_E_FLASH_RESULT_VOLTAGE_RANGE_ERROR = 5041, /**<  The voltage range is invalid. */ 
+  A2_E_FLASH_RESULT_PROGRAM_ERROR = 5042, /**<  Failed to write to the flash device. */ 
+  A2_E_FLASH_RESULT_ERASE_ERROR = 5043, /**<  Failed to erase a block in the flash device. */ 
+  A2_E_FLASH_RESULT_ERASE_SUSPENDED = 5044, /**<  The erase process was suspended. */ 
+  A2_E_FLASH_RESULT_COMMAND_SEQUENCE_ERROR = 5045, /**<  The sequence of the flash commands was invalid. */ 
+  A2_E_FLASH_RESULT_OPERATION_NOT_SUPPORTED = 5046, /**<  Operation was not supported in flashdriver. */ 
+  A2_E_FLASH_RESULT_INVALID_PARAMETER = 5047, /**<  Invalid in-parameter specified when reading/writing to flash. */ 
+  A2_E_FLASH_RESULT_NO_FLASH_DEVICE = 5048, /**<  No flash device was found on the physical address. */ 
+  A2_E_FLASH_RESULT_CONFIGURATION_ERROR = 5049, /**<  Configuration error of flash device. */ 
+  A2_E_FLASH_RESULT_INVALID_STARTADDRESS = 5050, /**<  Invalid start address of the parameter. */ 
+  A2_E_FLASH_RESULT_INVALID_PHYSICAL_ADDRESS = 5051, /**<  Invalid physical address of the parameter. */ 
+  A2_E_FLASH_RESULT_INVALID_DATALENGTH = 5052, /**<  The data length of the parameter is invalid. */ 
+  A2_E_FLASH_RESULT_GETREGION_ERROR = 5053, /**<  Invalid flash region specified. */ 
+  A2_E_FLASH_RESULT_NULL_POINTER_BUF = 5054, /**<  A buffer was NULL. */ 
+  A2_E_FLASH_RESULT_NAND_READ_FAILED = 5055, /**<  Failed to read from the NAND flash. */ 
+  A2_E_FLASH_RESULT_NAND_PAGE_SIZE_UNSUPPORTED = 5056, /**<  The nand page size is unsupported. */ 
+  A2_E_FLASH_RESULT_WRITE_ERROR = 5057, /**<  Failed to write to the flash device. */ 
+  A2_E_FLASH_RESULT_READ_ID_ERROR = 5058, /**<  Failed to read the device ID from the flash device. */ 
+  A2_E_FLASH_RESULT_HARDWARE_ERROR = 5059, /**<  Hardware error in the flash status. */ 
+  A2_E_FLASH_RESULT_READ_FROM_FLASH = 5060, /**<  Failed to read from the flash device. */ 
+  A2_E_FLASH_RESULT_ADD_NEW_DEVICE = 5061, /**<  Failed to add a new instance of a flash device. */ 
+  A2_E_FLASH_RESULT_OTP_UNSUPPORTED_IN_FLASH = 5062, /**<  OTP is not support in the current flash device. */ 
+  A2_E_FLASH_RESULT_OTP_TOO_SMALL = 5063, /**<  The OTP size is to small for the length requested. */ 
+  A2_E_FLASH_RESULT_OTP_READ_FAILED = 5064, /**<  Failed to read the OTP area in the flash device. */ 
+  A2_E_FLASH_RESULT_INVALID_FLASH_TYPE = 5065, /**<  The flash type is unknown. */ 
+  A2_E_FLASH_RESULT_NAND_FLUSH_ERROR = 5066, /**<  Failed to flush the NAND write buffer. */ 
+  A2_E_FLASH_RESULT_NOR_FLUSH_ERROR = 5067, /**<  Failed to flush the NOR write buffer. */ 
+  A2_E_INVALID_LOL_STATE = 5068, /**<  Invalid Loader on loader state. */ 
+  A2_E_INVALID_STATUS_LOLSTATE = 5069, /**<  Invalid loader on loader status. */ 
+  A2_E_WRITE_STATIC_DATA = 5070, /**<  Write static data failed. */ 
+  A2_E_HEADER_NOT_VERIFIED_YET = 5071, /**<  Header is still not verified. */ 
+  A2_E_ALL_BLOCKS_VERIFIED_FAILED = 5072, /**<  Blocks verification failed. */ 
+  A2_E_HANDSHAKE_WITH_APP_SIDE = 5073, /**<  Handshake with App side failed. */ 
+  A2_E_READ_STATIC_DATA = 5074, /**<  Failed to read static data. */ 
+  A2_E_ENABLE_CLOCK_HARDWARE_FAILED = 5075, /**<  Failed to enable clock hardware. */ 
+  A2_E_ENABLE_BLOCK_HARDWARE_FAILED = 5076, /**<  Failed to enable block hardware. */ 
+  A2_E_NO_HEADER_TO_MAC_IN_BOOT = 5077, /**<  Indicates that the loader did not find any header in the bootimage records that could be MAC'ed. */ 
+  A2_E_MMU_SETUP = 5078, /**<  MMU setup failed. */ 
+  A2_E_INVALID_COMMAND_SIZE = 5079, /**<  Invalid command size. */ 
+  A2_E_HASH_LIST_LENGTH_INVALID = 5080, /**<  Invalid hash list length. */ 
+  A2_E_INVALID_INPUT_PARAMETERS = 5081, /**<  Invalid input parameters. */ 
+  A2_E_FAILED_SETUP_MSL_DRIVER = 5082, /**<  MSL driver setup failed. */ 
+  A2_E_REQUEST_DENIED = 5083, /**<  Request denied. */ 
+  A2_E_ASIC_FUSES_INVALID = 5084, /**<  Fuses for the ASIC are invalid. */ 
+  A2_E_STATIC_DATA_NOT_CHECKED = 5085, /**<  Static data is not checked. */ 
+  A2_E_COPS_DATA_MAN_INIT = 5086, /**<  Failed to initialize the cops data man, this can be caused by an corrupt boot image. You probably just need to flash a platform software to get it work. */ 
+  A2_E_UART_DRIVER_ERROR = 5087, /**<  UART driver error. */ 
+  A2_E_INVALID_DOMAIN_FOR_LOADER_TYPE = 5088, /**<  Loader type is not compatible with this domain. */ 
+  A2_E_FUNCTIONALITY_NOT_IN_PRODUCT = 5089, /**<  Functionality not supported. */ 
+  A2_E_DEFALT_DATA_NOT_FOUND = 5090, /**<  Default data can not be found. */ 
+  A2_E_FAILED_TO_MAC_HEADER = 5091, /**<  Failed to send the header to access side to be MAC'ed, could be something wrong with the header. */ 
+  A2_E_APP_PRELOADER_NOT_STARTED = 5092, /**<  App preloader not started. */ 
+  A2_E_INVALID_DEST_ADDRESS = 5093, /**<  Invalid destination address. */ 
+  A2_E_SYS_APP_INIT_FAILURE = 5094, /**<  Failed to initialize the system application. */ 
+  A2_E_FLASH_APP_INIT_FAILURE = 5095, /**<  Failed to initialize the flash application. */ 
+  A2_E_SIGNATURE_APP_INIT_FAILURE = 5096, /**<  Failed to initialize the signature application. */ 
+  A2_E_RESET_APP_INIT_FAILURE = 5097, /**<  Failed to initialize the reset application. */ 
+  A2_E_INT_SEC_APP_INIT_FAILURE = 5098, /**<  Failed to initialize the internal security application. */ 
+  A2_E_COPS_DATA_MAN_FORMAT = 5099, /**<  COPS data man Format. */ 
+  A2_E_COPS_DATA_MAN_WRITE = 5100, /**<  COPS data man write. */ 
+  A2_E_COPS_DATA_MAN_FLUSH = 5101, /**<  Failed to Flush the memory into the security partition. */ 
+  A2_E_COPS_DATA_MAN_GETBLOCKSIZE = 5102, /**<  Failed to get the block size of a unit in the security partition. */ 
+  A2_E_COPS_DATA_MAN_READBLOCK = 5103, /**<  Failed to read an index from the security partition. */ 
+  A2_E_INVALID_FLASH_VAR_LENGTH = 5104, /**<  The bytes left to program should be less than a NAND page. */ 
+  A2_E_BOOTIMAGE_TOO_BIG = 5105, /**<  Boot image is too big. */ 
+  A2_E_GDFS_APP_INIT_FAILURE = 5106, /**<  App GD init failed. */ 
+  A2_E_FILESYS_APP_INIT_FAILURE = 5107, /**<  Failed to initialize the file system. */ 
+  A2_E_INVALID_SOURCE_DEST_ADDRESS = 5108, /**<  Invalid source or destination address. */ 
+  A2_E_INVALID_RESPONSE_COMMAND = 5109, /**<  Invalid Response command number on the internal security command group, was expecting command 0xFF. */ 
+  A2_E_INVALID_RESP_TO_CMD = 5110, /**<  The internal sec command response should have responded to another command. */ 
+  A2_E_VERIFICATION_OF_WRITTEN_DATA_FAILED = 5111, /**<  The data programmed into flash was not the same as the data received! */ 
+  A2_E_INVALID_NAND_PADMUX_SETTING = 5112, /**<  The PADMUX configuration has not been set. */ 
+  A2_E_FLASH_DRIVER_FAILED_SET_BOOT_ADDR = 5113, /**<  Failed to set the start boot address, this address are used to read the static data. */ 
+  A2_E_FLASH_BOOT_IS_NOT_EMPTY = 5114, /**<  if the static data was not found, the flash should be empty! */ 
+  A2_E_BOOTIMAGE_PMC_NOT_NEEDED = 5115, /**<  This error code informs that found boot container holds information that is not PMC protected. */ 
+  A2_E_UNSUPPORTED_PMC = 5116, /**<  The PMC ID is not supported. */ 
+  A2_E_FSVN_VS_PMC = 5117, /**<  The PMC ID is not coordinated with FSVN. */ 
+  A2_E_WRONG_PMC_START_COUNT = 5118, /**<  PMC start count to high or zero. */ 
+  A2_E_UNSUITABLE_PMC_FOR_LOCATION = 5119, /**<  Unsuitable PMC for the location. */ 
+  A2_E_PMC_MISSING = 5120, /**<  The PMC can not be found. */ 
+  A2_E_VERSION_NOT_ACCEPTED = 5121, /**<  FSVN is too low. */ 
+  A2_E_PMC_OVERFLOWN = 5122, /**<  All steps of the PMC are destroyed. */ 
+  A2_E_PMC_ONCE_REQUIRED = 5123, /**<  New version of once protected module attempted to be loaded without ARB flag set. */ 
+  A2_E_PMC_BAD_N_OF_STEPS = 5124, /**<  Unsuitable number of steps within PMC. */ 
+  A2_E_UNIT_MISSING = 5125, /**<  Dynamyc variable is missing. */ 
+  A2_E_UNIT_TO_BIG = 5126, /**<  Dynamyc variable found is to big. */ 
+  A2_E_PARTMAN_READ_ERROR = 5127, /**<  Error reading partition manger status. */ 
+  A2_E_PARTMAN_INIT_ERROR = 5128, /**<  Error initializing partition manger. */ 
+  A2_E_BOOTIMAGE_INVALID_ALLIGNMENT = 5129, /**<  Boot container size is not word alligned. */ 
+  A2_E_BOOTIMAGE_INSUFFICIENT_CONTAINERS = 5130, /**<  Not enough boot containers are allocated. */ 
+  A2_E_BOOTIMAGE_INVALID_CONTAINER_TYPE = 5131, /**<  Invalid boot container type. At this position other type of container is expected. */ 
+  A2_E_DATA_LENGTH_IS_NOT_ALIGNED = 5132, /**<  The data size must be aligned to 512 bytes when reading or writing pages to/from the NAND. */ 
+  A2_E_LOADER_SWINIT_JTAG_UNLOCK_FAILED = 5133, /**<  TEST JTAG EANBLENODEBUG. */ 
+  A2_E_BOOTIMAGE_RECORD_NOT_FOUND = 5134, /**<  Required record is not found in the boot containers. */ 
+  A2_E_BUFFER_OVERFLOW = 5135, /**<  Buffer overflow. */ 
+  A2_E_BUFFER_NOT_ALLOCATED = 5136, /**<  Buffer has not been allocated. */ 
+  A2_E_WRONG_DATA_SIZE = 5137, /**<  Size of data has an unexpected value. */ 
+  A2_E_NO_STATIC_DATA_IN_BOOTIMAGE = 5138, /**<  Static data in boot record is corrupted. */ 
+  A2_E_NOT_ALLOWED_TO_FLASH = 5139, /**<  Not allowed to flash this block. */ 
+  A2_E_UNABLE_TO_CHANGE_MMU_SETTINGS = 5140, /**<  Unable to change MMU settings. */ 
+  A2_E_INVALID_HW_FOR_LOADER_SETTINGS = 5141, /**<  Loader settings are not compatible with loader settings. */ 
+  A2_E_CABS_START_FAILED = 5142, /**<   */ 
+  A2_E_CABS_READ_ERROR = 5143, /**<   */ 
+  A2_E_CABS_WRITE_ERROR = 5144, /**<   */ 
+  A2_E_ELF_DECODE_GENERAL_ERROR = 5145, /**<   */ 
+  A2_E_ELF_INVALID_PARAMETER = 5146, /**<   */ 
+  A2_E_PARTMAN_INIT_FAILED = 5147, /**<   */ 
+  A2_E_PARTMAN_WRITE_FAILED = 5148, /**<   */ 
+  A2_E_PARTMAN_READ_FAILED = 5149, /**<   */ 
+  A2_E_PARTMAN_ERASE_ERROR = 5150, /**<   */ 
+  A2_E_MBBS_CONFIG_ERROR = 5151, /**<   */ 
+  A2_E_MBBS_READ_ERROR = 5152, /**<   */ 
+  A2_E_MBBS_WRITE_ERROR = 5153, /**<   */ 
+  A2_E_MBBS_ERASE_ERROR = 5154, /**<   */ 
+  A2_E_FLASH_HW_CONFIG = 5155, /**<   */ 
+  A2_E_VSP_IS_NOT_ALLOWED = 5156, /**<  Virtual security partition is not allowed in this configuration. */ 
+  A2_E_VSP_WRITE_STATIC_DATA = 5157, /**<  Failed to write static data to virtual security partition. */ 
+  A2_E_VSP_READ_STATIC_DATA = 5158, /**<  Failed to read static data from virtual security partition. */ 
+  A2_E_VSP_NOT_FORMATED = 5159, /**<  Virtual security partition is not initialized. */ 
+  A2_E_VSP_UNSUPPORTED_UNIT_TYPE = 5160, /**<  Unit type is out of range in virtual security partition. */ 
+  A2_E_GET_DYNAMIC_DATA_FAILED = 5161, /**<  Could not get the dynamic data from the security library. */ 
+  A2_E_FLASH_RESULT_PARTITION_TABLE_FLASHED = 5162, /**<  Partition table repaired!! Please load file again. */ 
+  A2_E_FLASH_RESULT_PARTITION_TABLE_NOT_FLASHED = 5163, /**<  Partition table is damaged! */ 
+  A2_E_FLASH_RESULT_READ_FROM_PARTITION_TABLE = 5164, /**<  Partition table is damaged. */ 
+  A2_E_BOOTIMAGE_PARTITION_RECORD_NOT_FOUND = 5165, /**<  Partition table record is not found in the boot containers. */ 
+  A2_E_CORRUPT_STATIC_DATA_IN_BOOT_BLOCK = 5166, /**<  Static data in boot block is corrupt. */ 
+  A2_E_MBBS_BBM_TYPE_CONFLICT = 5167, /**<  MBBS and BBM type conflict. */ 
+  A2_E_EXECUTION_NOT_PERMITTED = 5168, /**<  Execution of this command is not allowed in the current domain with current authentication state. */ 
+  A2_E_EXECUTION_NOT_PERMITTED_WARNING = 5169, /**<  Execution of this command is not allowed in the current domain with current authentication state. */ 
+  A2_E_UNABLE_TO_INITIALIZE_LCD = 5171, /**<  Error during initialization of LCD drivers. */ 
+  A2_E_LCD_NOT_INITIALIZED = 5172, /**<  LCD is not initialized. */ 
+  A2_E_UNABLE_TO_DISPLAY_DATA_ON_LCD = 5173, /**<  Unrecoverable error during BMP image is processed. */ 
+  A2_E_NETWORK_BUFFER_CORRUPTED = 5174, /**<  The network buffer area is corrupted. */ 
+  A2_E_TOO_MENY_FRAGMENTS = 5200, /**<   */ 
+  A2_E_FAILED_TO_GET_APPLICATION = 5201, /**<   */ 
+  A2_E_SECURITY_LIBRARY_ERROR_BEGIN = 9096, /**<   */ 
+  A2_E_SECURITY_LIBRARY_ERROR_END = 9300, /**<   */ 
+  A2_E_UNSUPPORTED_PROPERTY = 5301, /**<  Unsupported file system property. */ 
+  A2_E_READ_ONLY = 5302, /**<  The property is read only. */ 
+  A2_E_INVALLID_PROPERTY_SPECIFIED = 5303, /**<  The specified property value was invalid. */ 
+  A2_E_ACCESS_DENIED = 5304, /**<  The access permission attributes do not allow operation. */ 
+  A2_E_FORMATTING_FS = 5305, /**<  The file system is formatting. */ 
+  A2_E_PATH_NOT_EXISTS = 5306, /**<  The path does not exist. */ 
+  A2_E_PATH_ALREADY_EXISTS = 5307, /**<  The path already exists. */ 
+  A2_E_PATH_READ_ONLY = 5308, /**<  The path is read only. */ 
+  A2_E_INSUFFICENT_SPACE = 5309, /**<  Insufficient space. */ 
+  A2_E_DIRECTORY_NOT_EMPTY = 5310, /**<  The directory is not empty. */ 
+  A2_E_INVALID_RESTRICTION_SPECIFIED = 5311, /**<  Invalid access restrictions specified. */ 
+  A2_E_NO_FILESYSTEM_PROPERTY = 5312, /**<  No file system property. */ 
+  A2_E_FILE_NOT_EXISTS = 5313, /**<  The file does not exist. */ 
+  A2_E_CHANGE_DIR = 5314, /**<  Failed to change directory. */ 
+  A2_E_CHMOD = 5315, /**<  Failed to set new CH mod. */ 
+  A2_E_GWD = 5316, /**<  Failed to get the current directory. */ 
+  A2_E_OPEN_FILE = 5317, /**<  Failed to open a file in the file system. */ 
+  A2_E_ITEM_STAT = 5318, /**<  Failed to read the stat from file. */ 
+  A2_E_LIST_VOL = 5319, /**<  Failed to list volumes. */ 
+  A2_E_FREE_SPACE = 5320, /**<  No free space left. */ 
+  A2_E_CLOSE_FILE = 5321, /**<  Failed to close a file in the filesystem. */ 
+  A2_E_CLOSE_DIRECTORY = 5322, /**<  Failed to close the directory. */ 
+  A2_E_REMOVE_FILE = 5323, /**<  Failed to remove a file from the filesystem. */ 
+  A2_E_RENAME_FILE = 5324, /**<  Failed to rename a file in the filesystem. */ 
+  A2_E_CREATE_DIR = 5325, /**<  Failed to create a new directory in the filesystem. */ 
+  A2_E_REMOVE_DIRECTORY = 5326, /**<  Failed to remove a directory from the file system. */ 
+  A2_E_WRITE_FILE = 5327, /**<  Failed to write a file to the file system. */ 
+  A2_E_INVALID_SFA_STATE = 5328, /**<  The state of the SFA programming is incorrect. */ 
+  A2_E_READ_FILE = 5329, /**<  Failed to read a file from the file system. */ 
+  A2_E_CORE_SUPERV = 61797, /**<   */ 
+  A2_E_MEM_ALLOC = 66166, /**<   */ 
+  A2_E_GDFS_UNSUPPORTED_PROPERTY = 5401, /**<  Unsupported GDFS property. */ 
+  A2_E_GDFS_READ_ONLY = 5402, /**<  The GDFS property is read only. */ 
+  A2_E_GDFS_PROPERTY_VALUE_INVALID = 5403, /**<  The property value is invalid. */ 
+  A2_E_GDFS_INVALID_START_PROPERTY = 5404, /**<  Invalid start property. */ 
+  A2_E_GDFS_NOT_STARTED = 5405, /**<  GDFS has not been started yet. */ 
+  A2_E_GDFS_FAILED_TO_FORMAT = 5406, /**<  Failed to format the GDFS area. */ 
+  A2_E_GDFS_NOT_FORMATTED = 5407, /**<  GDFS is not formatted, as it should be. */ 
+  A2_E_GDFS_INVALID_BLOCK_UNIT_SPECIFIED = 5408, /**<  Invalid Block unit number. */ 
+  A2_E_GDFS_NO_CONFIGURATION_FOUND = 5409, /**<  Could not find any GDFS configuration from the platform software in flash. */ 
+  A2_E_GDFS_CLOSE = 5410, /**<  Failed to close the GDFS area. */ 
+  A2_E_GDFS_OPEN = 5411, /**<  Failed to open the GDFS area. */ 
+  A2_E_GDFS_INVALID_UNIT_SIZE = 5412, /**<  Invalid GDFS UNIT size(size=0). */ 
+  A2_E_GDFS_WRITE_TO_UNIT_FAILED = 5413, /**<  Failed to write to the specified unit. */ 
+  A2_E_GDFS_FAILED_TO_READ_FROM_UNIT = 5414, /**<  Failed to read from the specified unit. */ 
+  A2_E_GDFS_EMPTY = 5415, /**<  Failed read access on an empty GDFS. */ 
+  A2_E_GENERAL_FATAL_ERROR = 70535, /**<   */ 
+  E_DUMMY_CODE = 80009  /**<  */ 
+} ErrorCode_e;
+
+#endif /* _ERRORCODE_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/audit.c riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/audit.c
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/audit.c	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/audit.c	2011-11-01 10:47:49.505606300 +0100
@@ -0,0 +1,104 @@
+/* $Copyright ST-Ericsson 2010 $ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "t_command_protocol.h"
+#include "r_debug.h"
+#include "r_communication_service.h"
+#include "commands.h"
+#include "command_ids.h"
+#include "commands_impl.h"
+#include "error_codes.h"
+#include "r_serialization.h"
+#include "r_command_protocol.h"
+#include "audit.h"
+
+#ifdef CFG_ENABLE_AUDIT_CMD
+#include "r_loader_sec_lib.h"
+#endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+#include "r_adbg_command.h"
+#endif
+
+/*
+ * Command Permissions Vectors.
+ */
+
+/*
+ * Command Authentication Vectors.
+ */
+
+
+CommandPermissionList_t CommandPermissionList[]=
+{
+  /* End of array */
+  {
+    0,
+    (CommandId_e)0,
+    0,
+    NULL,
+    0,
+    NULL,
+    0,
+    FALSE,
+    FALSE,
+    FALSE,
+    FALSE,
+    NULL
+  }
+};
+
+CommandPermissionList_t * GetAuditData(CommandData_t * CmdData_p)
+{
+/*
+  boolean A1_Authentication = FALSE;
+  boolean CA_Authentication = FALSE;
+
+  boolean A1_Factory        = FALSE;
+  boolean A1_RD             = FALSE;
+  boolean A1_Product        = FALSE;
+  boolean A1_Service        = FALSE;
+
+  uint8 A1_depandancy       = 0x00;
+
+  uint32 AuthenticationVector = 0; */
+  int CounterList = 0;
+
+  while(CommandPermissionList[CounterList].Group != 0)
+  {
+    if(CmdData_p->ApplicationNr==CommandPermissionList[CounterList].Group && CmdData_p->CommandNr==CommandPermissionList[CounterList].Command)
+    {
+      CommandPermissionList[CounterList].DataParam_p = CmdData_p->Payload.Data_p;
+      return (&CommandPermissionList[CounterList]);
+    }
+    CounterList++;
+  }
+  return NULL;
+}
+
+#ifdef CFG_ENABLE_AUDIT_CMD
+ErrorCode_e CommandAudit(CommandData_t * CmdData_p)
+{
+  ErrorCode_e ReturnValue = E_GENERAL_FATAL_ERROR;
+  CommandPermissionList_t* CmdPermission_p = NULL;
+
+  CmdPermission_p = GetAuditData(CmdData_p);
+  if(NULL == CmdPermission_p)
+  {
+    ReturnValue = E_UNSUPPORTED_CMD;
+    goto ErrorExit;
+  }
+
+  ReturnValue = (ErrorCode_e)Do_LoaderSecLib_Audit_Permission_Levels(CmdPermission_p);
+  if(ReturnValue != E_SUCCESS)
+  {
+    ReturnValue = E_AUDITING_FAILED;
+  }
+
+ErrorExit:
+  return ReturnValue;
+}
+#endif
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/audit.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/audit.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/audit.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/audit.h	2011-11-01 10:47:48.989613712 +0100
@@ -0,0 +1,49 @@
+
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _AUDIT_H
+#define _AUDIT_H
+#include "t_command_protocol.h"
+#include "command_ids.h"
+
+/**
+ *  @addtogroup ldr_LCM
+ *  Error codes for internal loader commands.
+ *  @{
+ */
+
+TYPEDEF_ENUM {
+  A1 = 1, /**< A1 */
+  CA = 2  /**< CA */
+}ENUM8(CommandAuthentication_e);
+
+TYPEDEF_ENUM {
+  ServiceModeLevel = 0, /**< ServiceModeLevel */
+  FlashModeLevel = 1, /**< FlashModeLevel */
+  AdvanceServiceModeLevel = 64, /**< AdvanceServiceModeLevel */
+  LimitedProductionModeLevel = 65, /**< LimitedProductionModeLevel */
+  VeryLimitedProductionModeLevel = 66, /**< VeryLimitedProductionModeLevel */
+  ProductionModeLevel = 127  /**< ProductionModeLevel */
+}ENUM8(CommandPermission_e);
+
+
+typedef struct CommandPermissionList_s
+{
+  GroupId_e               Group;
+  CommandId_e             Command;
+  int                     CommmandPermissionLength;
+  CommandPermission_e     *CommmandPermmision_p;
+  int                     ComandAuthenticationLength;
+  CommandAuthentication_e *CommandAuthentication_p;
+  int                     Depandancy;
+  boolean                 factory;
+  boolean                 rd;
+  boolean                 product;
+  boolean                 service;
+  uint8                   *DataParam_p;
+}CommandPermissionList_t;
+
+CommandPermissionList_t * GetAuditData(CommandData_t * CmdData_p);
+ErrorCode_e CommandAudit(CommandData_t * CmdData_p);
+#endif /* _AUDIT_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/ces_commands.c riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/ces_commands.c
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/ces_commands.c	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/ces_commands.c	2011-11-01 10:47:53.413988720 +0100
@@ -0,0 +1,49 @@
+
+/*******************************************************************************
+ * $Copyright ST-Ericsson 2010 $
+ ******************************************************************************/
+/**
+ *  @addtogroup ldr_communication_module
+ *  @{
+ */
+
+/*******************************************************************************
+ * Includes
+ ******************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ces_commands.h"
+#include "t_command_exec_service.h"
+#include "command_ids.h"
+#include "command_execution_control.h"
+
+/*******************************************************************************
+ * File scope types, constants and variables
+ ******************************************************************************/
+/*
+ *  Commands that need command execution service
+ */
+
+
+ApplicationInfo_t ActiveApplications[]=
+{
+
+/* ADD MORE APPLICATIONS HERE */
+};
+
+/*******************************************************************************
+ * Definition of external functions
+ ******************************************************************************/
+uint32 Get_ApplicationInfoSize(void)
+{
+  return sizeof(ApplicationInfo_t);
+}
+
+uint32 Get_ActiveApplicationsSize(void)
+{
+  return sizeof(ActiveApplications);
+}
+
+/*@}*/
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/ces_commands.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/ces_commands.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/ces_commands.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/ces_commands.h	2011-11-01 10:47:53.837823984 +0100
@@ -0,0 +1,24 @@
+
+/*******************************************************************************
+ * $Copyright ST-Ericsson 2010 $
+ ******************************************************************************/
+#ifndef _CES_COMMANDS_H_
+#define _CES_COMMANDS_H_
+/**
+ *  @addtogroup ldr_communication_module
+ *  @{
+ */
+
+/*******************************************************************************
+ * Includes
+ ******************************************************************************/
+#include "error_codes.h"
+
+/*******************************************************************************
+ * Declaration of functions
+ ******************************************************************************/
+uint32 Get_ApplicationInfoSize(void);
+uint32 Get_ActiveApplicationsSize(void);
+
+/*@}*/
+#endif /*_CES_COMMANDS_H_*/
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/command_ids.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/command_ids.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/command_ids.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/command_ids.h	2011-11-01 10:47:49.981985727 +0100
@@ -0,0 +1,48 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMAND_IDS_H
+#define _COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+TYPEDEF_ENUM {
+} ENUM8(GroupId_e);
+
+typedef enum {
+} CommandId_e;
+
+
+typedef struct SupportedCommand_s
+{
+  uint32  Group; /**< Application Group number */
+    uint32  Command; /**< Command number */
+    uint32  Permitted; /**< Permission value */
+  }SupportedCommand_t;
+
+typedef struct ListDevice_s
+{
+  
+  char *  Path_p; /**< Absolute device path pointing of the described device */
+    
+  char *  Type_p; /**< Type of the device */
+    uint64  BlockSize; /**< Size of the smallest addressable unit in the device in bytes */
+    uint64  Start; /**< Offset in bytes of the start of the device relative to its parents offset 0 with a granularity of its parents block size */
+    uint64  Length; /**< Length of the device in bytes */
+  }ListDevice_t;
+
+typedef struct DirEntry_s
+{
+  
+  char *  Name_p; /**< Name of file or directory */
+    uint64  Size; /**< Size of file or directory */
+    uint32  Mode; /**< Indicator if it is file or directory */
+    uint32  Time; /**< Time of last modification */
+  }DirEntry_t;
+
+typedef struct Cipher_s
+{
+  
+  char *  Name_p; /**< supported ciphers */
+  }Cipher_t;
+
+#endif /* _COMMAND_IDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/command_marshal.c riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/command_marshal.c
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/command_marshal.c	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/command_marshal.c	2011-11-01 10:47:51.425988773 +0100
@@ -0,0 +1,161 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "t_command_protocol.h"
+#include "r_debug.h"
+#include "r_communication_service.h"
+#include "commands.h"
+#include "custom_commands.h"
+#include "command_ids.h"
+#include "commands_impl.h"
+#include "error_codes.h"
+#include "r_serialization.h"
+#include "r_command_protocol.h"
+#ifdef CFG_ENABLE_ADBG_LOADER
+#include "r_adbg_applications.h"
+#endif
+
+#ifdef CFG_ENABLE_AUDIT_CMD 
+#include "audit.h"
+#endif
+
+#ifdef CFG_ENABLE_ADBG_LOADER
+#include "r_adbg_command.h"
+#endif
+
+#define COMMAND(response, group, id) ((((int)(response)) << 30) | (((int)(group)) << 16) | ((int)(id))) 
+#define COMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP)\
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t));\
+  CmdData.Type           = TypeP;\
+  CmdData.ApplicationNr  = ApplicationP;\
+  CmdData.CommandNr      = CommandP;\
+  CmdData.SessionNr      = SessionP;\
+  CmdData.Payload.Size   = SizeP;\
+  CmdData.Payload.Data_p = NULL;\
+  CmdData.Payload.Data_p = (uint8*)malloc(SizeP);\
+  if (NULL == CmdData.Payload.Data_p)\
+  {\
+    A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);)\
+    return E_ALLOCATE_FAILED;\
+  }\
+
+#define COMMANDDATAOUT(TypeP,ApplicationP,CommandP,SizeP)\
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t));\
+  CmdData.Type           = TypeP;\
+  CmdData.ApplicationNr  = ApplicationP;\
+  CmdData.CommandNr      = CommandP;\
+  CmdData.SessionNr      = 0;\
+  CmdData.Payload.Size   = SizeP;\
+  CmdData.Payload.Data_p = NULL;\
+  if (0 != SizeP)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc( SizeP);\
+    if (NULL == CmdData.Payload.Data_p)\
+    {\
+      A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);)\
+      return E_ALLOCATE_FAILED;\
+    }\
+  }
+
+//static uint16 Session;
+
+void disable_interrupt(void)
+{
+#ifndef WIN32
+/* todo implement this */
+//#warning This is disable_interrupt
+#endif
+}
+void enable_interrupt(void)
+{
+#ifndef WIN32
+/* todo implement this */
+//#warning This is enable_interrupt  
+#endif
+}
+
+ErrorCode_e Do_CEH_Call(void *Object_p, CommandData_t *CmdData_p)
+{
+  ErrorCode_e Status = E_GENERAL_FATAL_ERROR;
+//  uint32 PL_GRSize = 0;
+  ErrorCode_e ResponseStatus = E_GENERAL_FATAL_ERROR;
+  boolean response = FALSE;
+//  CommandPermissionList_t* CmdPermission_p;
+  void *Data_p = CmdData_p->Payload.Data_p;
+  uint16 Session = CmdData_p->SessionNr;
+
+  if (CmdData_p->Type == GENERAL_RESPONSE_PACKAGE)
+  {
+    response = TRUE;
+//    PL_GRSize = CmdData_p->Payload.Size;
+//    ResponseStatus = (ErrorCode_e)get_uint16(&Data_p);
+  }
+
+#ifdef CFG_ENABLE_AUDIT_CMD
+  if(COMMAND_TYPE == CmdData_p->Type)
+  {
+    ErrorCode_e AuditResponse = CommandAudit(CmdData_p);
+    CommandData_t CmdData = {0};
+    uint32 PLSize = sizeof(ErrorCode_e);
+
+    if (E_SUCCESS != AuditResponse)
+    {
+      memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t));
+
+      CmdData.Type           = GENERAL_RESPONSE;
+      CmdData.CommandNr      = CmdData_p->CommandNr;
+      CmdData.ApplicationNr  = CmdData_p->ApplicationNr;
+      CmdData.SessionNr      = CmdData_p->SessionNr;
+      CmdData.Payload.Size   = PLSize;
+      CmdData.Payload.Data_p = NULL;
+      CmdData.Payload.Data_p = (uint8*)malloc(PLSize);
+      if (NULL == CmdData.Payload.Data_p)
+      {
+        A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);)
+        return  E_ALLOCATE_FAILED;
+      }
+
+      Data_p = CmdData.Payload.Data_p;
+      put_uint32(&Data_p, AuditResponse);
+
+      Status = Do_R15_Command_Send(GlobalCommunication_p, &CmdData);
+      if (NULL != CmdData.Payload.Data_p)
+      {
+        free(CmdData.Payload.Data_p);
+      }
+
+      if (E_SUCCESS != Status)
+      {
+        return Status;
+      }
+
+      if (E_UNSUPPORTED_CMD == AuditResponse)
+      {
+        Status = Do_System_ShutDownImpl(CmdData.SessionNr);
+      }
+      return Status;
+    }
+  }
+#endif
+
+  switch(COMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+  {
+  
+  default:
+    {
+      Status = Do_CustomCEH_Call(CmdData_p);
+      if (E_SUCCESS != Status)
+      {
+        Status = Do_System_ShutDownImpl(Session);
+      }
+    }
+    break;
+  }
+
+  return Status;
+}
+
+  
\ Manca newline alla fine del file
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/commands.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/commands.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/commands.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/commands.h	2011-11-01 10:47:50.929988624 +0100
@@ -0,0 +1,12 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_H
+#define _COMMANDS_H
+#include "error_codes.h"
+#include "t_command_protocol.h"
+#include "command_ids.h"
+
+ErrorCode_e Do_CEH_Call(void *Object_p, CommandData_t *CmdData_p);
+
+#endif /* _COMMANDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/commands_impl.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/commands_impl.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/commands_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/commands_impl.h	2011-11-01 10:47:50.466106590 +0100
@@ -0,0 +1,8 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_IMPL_H
+#define _COMMANDS_IMPL_H
+#include "error_codes.h"
+
+#endif /* _COMMANDS_IMPL_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_command_ids.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_command_ids.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_command_ids.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_command_ids.h	2011-11-01 10:47:51.805988706 +0100
@@ -0,0 +1,12 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _CUSTOM_COMMAND_IDS_H
+#define _CUSTOM_COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+
+
+
+
+#endif /* _CUSTOM_COMMAND_IDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_command_marshal.c riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_command_marshal.c
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_command_marshal.c	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_command_marshal.c	2011-11-01 10:47:52.957905854 +0100
@@ -0,0 +1,141 @@
+
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "t_command_protocol.h"
+#include "r_debug.h"
+#include "r_communication_service.h"
+#include "custom_commands.h"
+#include "custom_command_ids.h"
+#include "custom_commands_impl.h"
+#include "error_codes.h"
+#include "r_serialization.h"
+#include "r_command_protocol.h"
+
+
+#define CUSTOMCOMMAND(response, group, id) (((response) << 31) | ((group) << 16) | (id)) 
+#define CUSTOMCOMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t)); \
+  CmdData.Type             = TypeP; \
+  CmdData.ApplicationNr    = ApplicationP; \
+  CmdData.CommandNr        = CommandP; \
+  CmdData.SessionNr        = SessionP; \
+  CmdData.Payload.Size     = sizeof(ErrorCode_e)+SizeP; \
+  CmdData.Payload.Data_p  = NULL; \
+  if(SizeP !=0)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc(sizeof(ErrorCode_e)+SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);) \
+      return  E_ALLOCATE_FAILED; \
+    }\
+  }
+
+#define CUSTOMCOMMANDDATAOUT(TypeP,ApplicationP,CommandP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t)); \
+  CmdData.Type             = TypeP; \
+  CmdData.ApplicationNr    = ApplicationP; \
+  CmdData.CommandNr        = CommandP; \
+  CmdData.SessionNr        = 0; \
+  CmdData.Payload.Size     = SizeP; \
+  CmdData.Payload.Data_p  = NULL; \
+  if(SizeP !=0)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc( SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      A_(printf("command_marshal.c (%d): ** memory allocation failed! **\n",__LINE__);) \
+      return  E_ALLOCATE_FAILED; \
+    }\
+  }
+  
+//static uint16 Session;
+
+ErrorCode_e Do_CustomCEH_Call(CommandData_t * CmdData_p)
+{
+  ErrorCode_e Status = E_GENERAL_FATAL_ERROR;
+//  uint32 PL_GRSize = 0;
+//  ErrorCode_e ResponseStatus = E_SUCCESS;
+  boolean response = FALSE;
+
+  void *Data_p = CmdData_p->Payload.Data_p;
+  (void)(Data_p);  //XVSZOAN Temporary solution!
+  
+  if (CmdData_p->Type == GENERAL_RESPONSE_PACKAGE)
+  {
+    response = TRUE;
+//    PL_GRSize = CmdData_p->Payload.Size;
+//    ResponseStatus = (ErrorCode_e)get_uint16(&Data_p);
+  }
+
+//  Session = CmdData_p->SessionNr;
+
+	switch(CUSTOMCOMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+  {
+ /*
+  * System command group.
+  */
+
+ /*
+  * Flash command group.
+  */
+
+ /*
+  * GDFS command group.
+  */
+
+ /*
+  * File System Unit
+  */
+
+ /*
+  * Signature application
+  */
+
+ /*
+  * Internal Security application
+  */
+
+ /*
+  * Reset application
+  */
+
+  default:
+    break;
+  }
+
+  return Status;
+}
+
+  
+/*
+ * System command group.
+ */
+
+/*
+ * Flash command group.
+ */
+
+/*
+ * GDFS command group.
+ */
+
+/*
+ * File System Unit
+ */
+
+/*
+ * Signature application
+ */
+
+/*
+ * Internal Security application
+ */
+
+/*
+ * Reset application
+ */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_commands.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_commands.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_commands.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_commands.h	2011-11-01 10:47:52.565988393 +0100
@@ -0,0 +1,39 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _CUSTOM_COMMANDS_H
+#define _CUSTOM_COMMANDS_H
+#include "error_codes.h"
+#include "t_command_protocol.h"
+
+ErrorCode_e Do_CustomCEH_Call(CommandData_t *CmdData_p);
+
+/*
+ * System command group.
+ */
+
+/*
+ * Flash command group.
+ */
+
+/*
+ * GDFS command group.
+ */
+
+/*
+ * File System Unit
+ */
+
+/*
+ * Signature application
+ */
+
+/*
+ * Internal Security application
+ */
+
+/*
+ * Reset application
+ */
+
+#endif /* _CUSTOM_COMMANDS_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_commands_impl.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_commands_impl.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/custom_commands_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/custom_commands_impl.h	2011-11-01 10:47:52.185680933 +0100
@@ -0,0 +1,36 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _CUSTOM_COMMANDS_IMPL_H
+#define _CUSTOM_COMMANDS_IMPL_H
+#include "error_codes.h"
+
+/*
+ * System command group.
+ */
+
+/*
+ * Flash command group.
+ */
+
+/*
+ * GDFS command group.
+ */
+
+/*
+ * File System Unit
+ */
+
+/*
+ * Signature application
+ */
+
+/*
+ * Internal Security application
+ */
+
+/*
+ * Reset application
+ */
+
+#endif /* _CUSTOM_COMMANDS_IMPL_H */
diff -Naur riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/error_codes.h riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/error_codes.h
--- riff-loadercomm-0.4.2+rcf4825b61e/build/autogen/loader/error_codes.h	1970-01-01 01:00:00.000000000 +0100
+++ riff-loadercomm-0.4.2+rcf4825b61ea/build/autogen/loader/error_codes.h	2011-11-01 10:47:48.585988364 +0100
@@ -0,0 +1,805 @@
+/* $Copyright$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _ERRORCODE_H
+#define _ERRORCODE_H
+
+
+/**
+ *  @addtogroup ldr_LCM
+ *  Error codes for internal loader commands. 
+ *  @{
+ */
+
+/*************************************************************************
+* Includes
+*************************************************************************/
+#include "t_basicdefinitions.h"
+
+#define A2_ERROR_CODES_OFFSET 5000
+/**
+ *  Internal loader command error codes. Possible range 0x0000 - 0x0FFE (4094).
+ */
+ 
+
+/**
+ * Table for Error groups range
+ * 
+ * General Fatal 0-50
+ * General non-fatal 51-99
+ * 
+ * IO Fatal 100-150
+ * IO non-fatal 151-199
+ * 
+ * Communication Fatal 200-250
+ * Communication non-fatal 251-299
+ * 
+ * Signature Fatal 300-350
+ * Signature non-fatal 351-399
+ * 
+ * Authentication Fatal 400-450
+ * Authentication non-fatal 451-499
+ * 
+ * COPS General Fatal 500-550
+ * COPS General non-fatal 551-599
+ * 
+ * System Fatal 600-650
+ * System non-fatal 651-699
+ * 
+ * Flash Fatal 700-750
+ * Flash non-fatal 751-799
+ * 
+ * Parameters Fatal 800-850
+ * Parameters non-fatal 851-899
+ * 
+ * File management Fatal 900-950
+ * File management non-fatal 951-999
+ * 
+ * Command Auditing and execution Fatal 1000-1050
+ * Command Auditing and execution non-fatal 1051-1099
+ * 
+ * Emulation Fatal 1100-1150
+ * Emulation non-fatal 1151-1199
+ * 
+ * Timers Fatal 1200-1250
+ * Timers non-fatal 1251-1299
+ * 
+ * CABS Fatal 1300-1350
+ * CABS non-fatal 1351-1399
+ * 
+ * GDFS Fatal 1400-1450
+ * GDFS non-fatal 1451-1499
+ * 
+ * Antirollback Fatal 1500-1550
+ * Antirollback non-fatal 1551-1599
+ * 
+ * Memory and Boot Fatal 1600-1650
+ * Memory and Boot non-fatal 1651-1699
+ * 
+ * @todo this should be removed and error codes should be remaped.
+ * The same applies to Emulator errors.
+ * 
+ * Job Handler Fatal 1700-1750
+ * Job Handler non-fatal 1751-1799
+ * 
+ * Emulator Fatal 1800-1850
+ * Emulator non-fatal 1851-1899
+ * 
+ * Loader utilities Fatal 1900-1950
+ * Loader utilities non-fatal 1951-1999
+ */
+
+
+typedef enum {
+  E_SUCCESS = 0, /**<  Operation successful. */ 
+  E_GENERAL_FATAL_ERROR = 1, /**<  General Failure. */ 
+  E_ALLOCATE_FAILED = 2, /**<  Failed to allocate memory. */ 
+  E_INVALID_INPUT_PARAMETERS = 51, /**<  The expected value into the function was incorrect. */ 
+  E_INVALID_CURRDATE_STRING_LENGTH = 52, /**<  Indicate that the currdate string array variable has invalid length. */ 
+  E_UNALIGNED_DATA = 53, /**<  Indicate that a variable is not aligned. */ 
+  E_VECTOR_CREATE_FAIL = 100, /**<  Failed to create vector in IO Layer. */ 
+  E_VECTOR_DESTROY_FAIL = 101, /**<  Failed to destroy vector in IO Layer. */ 
+  E_GENERAL_IO_ERROR = 151, /**<  Unknown IO error. */ 
+  E_IO_FAILED_TO_READ = 152, /**<  IO failed to read from source. */ 
+  E_IO_FAILED_TO_WRITE = 153, /**<  IO failed to write to destination. */ 
+  E_IO_FAILED_TO_CLOSE = 154, /**<  IO failed to close media. */ 
+  E_IO_FAILED_TO_OPEN = 155, /**<  IO failed to open media. */ 
+  E_IO_FAILED_TO_GET_LENGTH = 156, /**<  IO failed to get length of media. */ 
+  E_GENERAL_COMMUNICATION_ERROR = 200, /**<  General communication error. */ 
+  E_FAILED_TO_START_BULK_SESSION = 201, /**<  Failed to start bulk session. */ 
+  E_FAILED_TO_CLOSE_BULK_SESSION = 202, /**<  Failed to initialize the transport layer. */ 
+  E_FAILED_TO_FIND_CHUNK_DATA_BLOCK = 203, /**<  Failed to find chunk data block. */ 
+  E_FAILED_TO_INIT_COM_DEVICE = 204, /**<  Failed to reinitialize communication device. */ 
+  E_FAILED_TO_USE_COM_DEVICE = 205, /**<  Failed to use communication device. */ 
+  E_FAILED_TO_ALLOCATE_COMM_BUFFER = 206, /**<  Failed to allocate communication buffer. */ 
+  E_FAILED_TO_FLUSH_RXFIFO = 207, /**<  Failed to flush RX FIFO. */ 
+  E_RETRANSMITION_FAILED = 208, /**<  Retransmission failed. After MAX_RESENDS attempt, failed to send packet. */ 
+  E_COMMAND_NO_ERROR = 209, /**<  Stopped command error sequence. */ 
+  E_FAILED_TO_RELEASE_COMM_BUFFER = 210, /**<  Failed to release communication buffer. */ 
+  E_FAILED_TO_INTIALIZE_TIMER_FUNCTIONS = 211, /**<  Failed to initialize timer functions. */ 
+  E_FAILED_TO_INTIALIZE_QUEUE_FUNCTIONS = 212, /**<  Failed to initialize queue functions. */ 
+  E_DMA_INIT_ERROR = 213, /**<  Failed to initialize DMA. */ 
+  E_FAILED_TO_STOP_DMA = 214, /**<  Failed to stop DMA channel. */ 
+  E_FAILED_TO_OPEN_DMA_CHANNEL = 215, /**<  Failed to open DMA channel. */ 
+  E_FAILED_TO_SET_DMA_CHANNEL_TYPE = 216, /**<  Failed to set DMA channel type. */ 
+  E_FAILED_TO_SET_DMA_CHANNEL_MODE = 217, /**<  Failed to set DMA channel mode. */ 
+  E_FAILED_TO_OPEN_DMA_PIPE = 218, /**<  Failed to open DMA pipe. */ 
+  E_FAILED_TO_SET_DMA_IT_LOGIC = 219, /**<  Failed to set DMA interrupt logic. */ 
+  E_FAILED_TO_CLOSE_DMA_PIPE = 220, /**<  Failed to close DMA pipe. */ 
+  E_FAILED_TO_CLOSE_DMA_CHANNEL = 221, /**<  Failed to close DMA channel. */ 
+  E_FAILED_TO_CONFIG_SRC_DMA_DEVICE = 222, /**<  Failed to configure DMA source device. */ 
+  E_FAILED_TO_UPDATE_DMA_SRC_MEMORY_BUFFER = 223, /**<  Failed to update DMA source memory buffer. */ 
+  E_FAILED_TO_CONFIG_DEST_DMA_DEVICE = 224, /**<  Failed to configure DMA destination device. */ 
+  E_FAILED_TO_UPDATE_DMA_DEST_MEMORY_BUFFER = 225, /**<  Failed to update DMA destination memory buffer. */ 
+  E_FAILED_TO_RUN_DMA = 226, /**<  Failed to run DMA transfer. */ 
+  E_INVALID_BULK_MODE = 251, /**<  Invalid bulk mode. */ 
+  E_FAILED_TO_FIND_COMM_BUFFER = 252, /**<  Failed to find communication buffer. */ 
+  E_INVALID_TYPE_OF_BUFFER = 253, /**<  Invalid type of buffer. */ 
+  E_COM_DEVICE_BUSY = 254, /**<  Communication device is busy. */ 
+  E_NOT_FOUND_ELEMENT_IN_RETRANSMISSION_LIST = 255, /**<  The element in retransmission list is not found. */ 
+  E_FAILED_READING_FROM_BULK = 256, /**<  Failed to read from bulk. */ 
+  E_FAILED_WRITING_TO_BULK = 257, /**<  Failed to write to bulk. */ 
+  E_FAILED_TO_GET_UART_DESCRIPTOR = 258, /**<  Failed to get UART descriptor. */ 
+  E_FAILED_TO_GET_USB_DESCRIPTOR = 259, /**<  Failed to get USB descriptor. */ 
+  E_INVALID_BULK_SESSION_ID = 260, /**<  Invalid bulk session ID is used. */ 
+  E_PREVIOUS_BULK_SESSION_IS_NOT_CLOSED = 261, /**<  Previous bulk session not closed. */ 
+  E_INVALID_BULK_PROTOCOL_STATE = 262, /**<  Invalid bulk protocol state. */ 
+  E_UNKNWON_PROPERTY = 351, /**<  Unknown property id. */ 
+  E_CYCLIC_GRAPH = 451, /**<  Cyclic graph in services detected. */ 
+  E_SERVICE_NOT_SUPPORTED = 452, /**<  The service is not supported. */ 
+  E_INCONSISTENCY_IN_SERVICES = 453, /**<  Inconsistency in services is detected. */ 
+  E_SERVICE_IN_USE = 454, /**<  The service is in use and can't be stopped. */ 
+  E_UNREGISTER_BDM_SERVICE_FAILED = 455, /**<  Unregistering of Block Device Manager Service failed. */ 
+  E_UNREGISTER_BAM_SERVICE_FAILED = 456, /**<  Unregistering of Boot Area Manager Service failed. */ 
+  E_UNREGISTER_COPS_SERVICE_FAILED = 457, /**<  Unregistering of COPS Data Manager Service failed. */ 
+  E_UNREGISTER_FS_SERVICE_FAILED = 458, /**<  Unregistering of File System Manager Service failed. */ 
+  E_UNREGISTER_FPD_SERVICE_FAILED = 459, /**<  Unregistering of Flash Physical Driver Service failed. */ 
+  E_UNREGISTER_GD_SERVICE_FAILED = 460, /**<  Unregistering of Global Data Manager Service failed. */ 
+  E_GENERAL_ZIP_ERROR = 551, /**<  General error. */ 
+  E_ZIP_FAILED_TO_CREATE_CONTEXT = 552, /**<   Failed to parse the zip. */ 
+  E_ZIP_FAILED_TO_OPEN_FILE = 553, /**<   Failed to open file from the zip. */ 
+  E_FILESYS_APP_INIT_FAILURE = 600, /**<  Failed to initialize the file system application. */ 
+  E_NO_FILESYSTEM_PROPERTY = 601, /**<  Failed to start file system. */ 
+  E_UNDEFINED_AUTHENTICATION_TYPE = 602, /**<  Undefined authentication type. */ 
+  E_RTC_TIME_NOT_ACCURATE = 651, /**<  System Time is not properly set. */ 
+  E_RTC_INTIALIZATION_FAILED = 652, /**<  Hardware error ocure during initialization of RTC. */ 
+  E_DIFFERENT_FLASHLAYOUT = 751, /**<  Different flashlayout. */ 
+  E_EMPTY_FILE_IN_ARCHIVE = 752, /**<  Archive contain empty file. */ 
+  E_UNKNOWN_COMM_DEVICE = 753, /**<  Unknown communication device was detected. */ 
+  E_FLASH_APP_INTERNAL_ERROR = 754, /**<  Internal during execution of flash commands. */ 
+  E_DEVICE_NAME_TOO_LONG = 755, /**<  Device name is too long. */ 
+  E_FLASH_ARCHIVE_MISMATCH = 756, /**<  Mismatch between archieve that is flashed and previosly flashed one. */ 
+  E_UNSUPPORTED_FLASH_TYPE = 757, /**<  Flash memory device type is not supported. */ 
+  E_FPD_NOT_CONFIGURED = 758, /**<  Flash physical driver is not configured. */ 
+  E_INVALID_SIZE_IN_MEMCONF = 759, /**<  MEMCONF boot record contain invalid TotalSize field. */ 
+  E_ARCHIVE_TO_LARGE = 760, /**<  Flash archive larger than available space in BDM. */ 
+  E_ENTRY_NOT_FOUND_IN_FLASHLAYOUT = 761, /**<  Entry not found in flashlayout file. */ 
+  E_MISMATCH_MANIFEST_FLASHLAYOUT = 762, /**<  Mismatch between manifest and flashlayout. */ 
+  E_INVALID_SUBTOC_PARAMETERS = 763, /**<  SUBTOC is invalid. */ 
+  E_FAILED_TO_READ_SUBTOC = 764, /**<  Reading SUBTOC from flash failed. */ 
+  E_OVERLAPPING_PARTITIONS_FOUND = 765, /**<  Overlapping partitions found in the archive. */ 
+  E_PARTITION_NOT_FOUND = 766, /**<  Partition not found in TOC. */ 
+  E_FLASHLAYOUT_NULL = 767, /**<  Flashlayout data equals NULL. */ 
+  E_INVALID_TOC_TYPE = 768, /**<  Invalid TOC type supplied during TOC list creation. */ 
+  E_TOC_HANDLER_INPUT_DATA_EMPTY = 769, /**<  TOC list cannot be created because supplied buffer is empty. */ 
+  E_TOC_HANDLER_INPUT_DATA_CORRUPTED = 770, /**<  TOC list cannot be created because supplied buffer contains corrupted data. */ 
+  E_TOC_LIST_CORRUPTED = 771, /**<  TOC list cannot be created. Some malicious state occurs. */ 
+  E_TOC_BOOT_AREA_EMPTY = 772, /**<  TOC list cannot be created. Boot area is empty. */ 
+  E_BOOT_AREA_NOT_FOUND = 773, /**<  Boot Area not found. */ 
+  E_MISMATCH_MANIFEST_TOC = 774, /**<  Mismatch between manifest and TOC. */ 
+  E_FILE_TOO_LARGE = 775, /**<  File too large. */ 
+  E_FILE_OUT_OF_BOOT_AREA = 776, /**<  File outside of boot area */ 
+  E_DUMP_OUT_OF_FLASH_RANGE = 777, /**<  Dump outside of flash range */ 
+  E_PATH_NOT_EXISTS = 951, /**<  Path not exist. */ 
+  E_CLOSE_FILE = 952, /**<  Failed to close a file in the file system. */ 
+  E_INSUFFICENT_SPACE = 953, /**<  Not enough memory space for desired operation. */ 
+  E_REMOVE_FILE = 954, /**<  Failed to remove a file from the file system. */ 
+  E_RENAME_FILE = 955, /**<  Failed to rename a file from the file system. */ 
+  E_CREATE_DIR = 956, /**<  Failed to create a new directory in the file system. */ 
+  E_REMOVE_DIRECTORY = 957, /**<  Failed to remove directory. */ 
+  E_FREE_SPACE = 958, /**<  No free space left. */ 
+  E_ITEM_STAT = 959, /**<  Failed to retrieve status data. */ 
+  E_CLOSE_DIRECTORY = 960, /**<  Failed to close a directory in the file system. */ 
+  E_MOUNT_VOLUME = 961, /**<  Failed to mount volume in the file system. */ 
+  E_READ_DIRECTORY = 962, /**<  Failed to read directory in the file system. */ 
+  E_FS_IO = 963, /**<  Input/output error. */ 
+  E_FS_ARGUMENT_LIST_2BIG = 964, /**<  Argument list too long. */ 
+  E_FS_BAD_FILE_DESC = 965, /**<  Bad file descriptor. */ 
+  E_FS_ACCESS = 966, /**<  Permission denied. */ 
+  E_FS_BAD_ADDRESS = 967, /**<  Bad address. */ 
+  E_FS_FILE_EXIST = 968, /**<  File exists. */ 
+  E_FS_NOT_DIR = 969, /**<  Not a directory. */ 
+  E_FS_IS_DIR = 970, /**<  Is a directory. */ 
+  E_FS_FILE_TOO_LARGE = 971, /**<  File too large. */ 
+  E_FS_READ_ONLY_FS = 972, /**<  Read-only file system. */ 
+  E_FS_OPER_NOT_SUPP = 973, /**<  Operation not supported. */ 
+  E_FS_NAME_TOO_LONG = 974, /**<  File name too long. */ 
+  E_FS_OPERATION_CANCELED = 975, /**<  Operation canceled. */ 
+  E_FS_FAIL = 976, /**<  Cannot start operation. */ 
+  E_FS_INTERNAL = 977, /**<  Internal error. */ 
+  E_FS_NOT_MOUNTED = 978, /**<  Volume not mounted. */ 
+  E_FS_NOT_PERMITED = 979, /**<  Operation not permitted. */ 
+  E_FS_NO_SUCH_FILE_OR_DIR = 980, /**<  No such file or directory. */ 
+  E_FS_NOT_EXIST = 981, /**<  Specified FS does not exist. */ 
+  E_FS_UNKNOWN_ERROR = 982, /**<  Error is unknown. */ 
+  E_FAILED_WRITING_TO_FILE = 983, /**<  Failed to write to file. */ 
+  E_FAILED_READING_FROM_FILE = 984, /**<  Failed to read from the specified file. */ 
+  E_ACCESS_DENIED = 985, /**<  The access permission attributes do not allow operation. */ 
+  E_CANNOT_OPEN_FILE = 986, /**<  Can not open the specified file. */ 
+  E_FAILED_TO_STOP_FS = 987, /**<  Can not stop file system. */ 
+  E_FILE_NAME_TOO_LONG = 988, /**<  File name is too long. */ 
+  E_FAILED_TO_FIND_ELF_SECTION = 989, /**<  Can not find elf section. */ 
+  E_MAX_NUMBER_OF_MOUNTED_VOLUMES_EXCEEDED = 990, /**<  Unable to mount volume due to exceeding the maximum number of allowed volumes. */ 
+  E_NO_MOUNTED_DEVICES_ARE_FOUND = 991, /**<  Information message that no mounted devices are found. */ 
+  E_NOT_FREE_CMD_SPACE = 1000, /**<  Index for new command is not founded in execution queue. */ 
+  E_INVALID_INPUT_PARAMETER = 1001, /**<  Invalid input parameter */ 
+  E_UNSUPPORTED_CMD = 1002, /**<  The loader does not support the requested command. */ 
+  E_UNSUPPORTED_GROUP = 1003, /**<  The loader does not support the requested group. */ 
+  E_INVALID_COMMAND_SIZE = 1051, /**<  The size of the command is invalid. */ 
+  E_OVERLOAD_COMMAND_TABLE = 1052, /**<  Too many commands are registered. */ 
+  E_COMMAND_ALREADY_REGISTERED = 1053, /**<  Command has already registered in execution queue. */ 
+  E_AUDITING_FAILED = 1054, /**<   Command auditing failed. */ 
+  E_NONEXIST_TIMER = 1251, /**<  Timer with the specified index does not exist. */ 
+  E_FAILED_TO_SET_TIMER = 1252, /**<  Failed to start the timer. */ 
+  E_TIMER_INIT_FAILED = 1253, /**<  Timer initialization failed. */ 
+  E_TIMER_IRQ_CONF_FAILED = 1254, /**<   */ 
+  E_GD_INVALID_UNIT_SIZE = 1351, /**<  GD/GDFS: Error in specifying unit size. */ 
+  E_GD_LL_ILLEGAL_SIZE = 1352, /**<  GD/GDFS: Size too large for the block. */ 
+  E_GD_LL_WRITE_FAILED = 1353, /**<  GD/GDFS: Write failed on FLASH device level. */ 
+  E_GD_LL_ERASE_FAILED = 1354, /**<  GD/GDFS: Erase failed on FLASH device level. */ 
+  E_GD_LL_UNKNOWN_DEVICE = 1355, /**<  GD/GDFS: FLASH device unknown. */ 
+  E_GD_STARTUP_LOG_BLK_MISSING = 1356, /**<  GD/GDFS: Logical block not found during start-up scan. */ 
+  E_GD_STARTUP_DUPLICATE_LOG_BLK = 1357, /**<  GD/GDFS: Duplicate instances of same logical block. */ 
+  E_GD_ERASE_ILLEGAL_BLK_NR = 1358, /**<  GD/GDFS: Attempt to erase non-existing physical block. */ 
+  E_GD_FG_UNIT_NOT_FOUND = 1359, /**<  GD/GDFS: Requested unit not found, probably never written or has been deleted. */ 
+  E_GD_FG_UNIT_SIZE_MISMATCH = 1360, /**<  GD/GDFS: Attempt to access a unit outside its beyond its end. */ 
+  E_GD_FG_ILLEGAL_LOG_BLK_NR = 1361, /**<  GD/GDFS: Attempt to access a logical block that does not exist. (Hardware, fatal). */ 
+  E_GD_FG_ILLEGAL_PHYS_BLK_NR = 1362, /**<  GD/GDFS: Attempt to access a physical block that does not exist (internal error). */ 
+  E_GD_FG_BLK_FULL = 1363, /**<  GD/GDFS: Attempted to write more data to a block than could be fitted into one FLASH block. */ 
+  E_GD_FG_NO_BLK_FREE = 1364, /**<  GD/GDFS: Internal error (no free blocks are available). */ 
+  E_GD_FG_UNIT_CHECKSUM = 1365, /**<  GD/GDFS: The checksum or a unit being read is wrong. */ 
+  E_GD_FG_NOT_DIRECT_BLOCK = 1366, /**<  GD/GDFS: Block is not direct. */ 
+  E_GD_FG_NOT_FREE_BLOCK = 1367, /**<  GD/GDFS: For some reason, a free block could not be properly erased. */ 
+  E_GD_FG_ILLEGAL_SIZE = 1368, /**<  GD/GDFS: The size of a unit being written exceeds the maximum limit of a unit. */ 
+  E_GD_E_FG_FREE_AREA_DIRTY = 1369, /**<  GD/GDFS: The startup check found non-FF bytes in unused range within a block. */ 
+  E_GD_FG_SYNC_FAILED = 1370, /**<  GD/GDFS: Failed to synchronize. */ 
+  E_GD_NOT_OPEN = 1371, /**<  GD/GDFS: Tried to access data although GD was in closed state. */ 
+  E_GD_NOT_ALLOWED = 1372, /**<  GD/GDFS: Operation not allowed in the current mode. */ 
+  E_GD_ALREADY_OPEN = 1373, /**<  GD/GDFS: Tried to open or format when GD was already opened. */ 
+  E_GD_FRONKENSTIENS_PATTERN_MISMATCH = 1374, /**<  GD/GDFS: The id mark of the GDVAR file does not match the data in the flash. Fatal and makes GD read only. */ 
+  E_GD_ILLEGAL_ALIGNMENT = 1375, /**<  GD/GDFS: Tried to erase at an address that was not aligned to a flash block boundary. Internal error. */ 
+  E_GD_ILLEGAL_SIZE = 1376, /**<  GD/GDFS: The operation may not be performed with the specified size. Tried to write a to large unit. */ 
+  E_GD_ACCESS_DENIED = 1377, /**<  GD/GDFS: Operation not allowed. Flash device protected. Possible wrong flash driver configuration. */ 
+  E_GD_ILLEGAL_INDEX = 1378, /**<  GD/GDFS: Illegal GD index. */ 
+  E_GD_MEMORY_ALLOCATION_FAILED = 1379, /**<  GD/GDFS: Fatal. Failed to allocate dynamic memory. */ 
+  E_GD_MISSING_CONFIG = 1380, /**<  GD/GDFS: Missing configuration parameter. */ 
+  E_GD_ILLEGAL_CONFIG = 1381, /**<  GD/GDFS: Illegal configuration. */ 
+  E_GD_TRANSACTION_LOG_CORRUPT = 1382, /**<  GD/GDFS: The transaction log used for tracking updates to GD contents is corrupt and prevents roll-back from working properly. */ 
+  E_CSPSA_RESULT_E_INVALID_KEY = 1383, /**<  Error, parameter key not valid. */ 
+  E_CSPSA_RESULT_E_OUT_OF_SPACE = 1384, /**<  Error, there is not space enough on memory media to update the parameter area. */ 
+  E_CSPSA_RESULT_E_NO_VALID_IMAGE = 1385, /**<  Error, no valid CSPSA image found. */ 
+  E_CSPSA_RESULT_E_MEDIA_INACCESSIBLE = 1386, /**<  Memory media could not be accessed. */ 
+  E_CSPSA_RESULT_E_READ_ONLY = 1387, /**<  Image is read-only. */ 
+  E_CSPSA_RESULT_E_READ_ERROR = 1388, /**<  Error occurred while reading from media. */ 
+  E_CSPSA_RESULT_E_WRITE_ERROR = 1389, /**<  Error occurred while writing to media. */ 
+  E_CSPSA_RESULT_UNDEFINED = 1390, /**<  Represents an undefined value of this enum. */ 
+  E_CSPSA_RESULT_E_END_OF_DATA = 1391, /**<  No more parameters, end of data has been reached. */ 
+  E_CSPSA_RESULT_E_OPEN_ERROR = 1392, /**<  Parameter storage area could not be opened (media error). */ 
+  E_CSPSA_RESULT_E_ALREADY_EXISTS = 1393, /**<  Parameter storage area with same name was already registered. */ 
+  E_CSPSA_RESULT_E_OUT_OF_MEMORY = 1394, /**<  There was not enough memory to perform the operation. */ 
+  E_CSPSA_RESULT_E_BAD_PARAMETER = 1395, /**<  Error because of bad input parameter. */ 
+  E_GD_NO_DATA_TO_READ = 1399, /**<  GD: No data to read. */ 
+  E_BDM_W_NO_MORE_GC_POSSIBLE = 1451, /**<  BDM: No more garbage collection is possible. */ 
+  E_BDM_UNIT_STARTED = 1452, /**<  BDM: Unit has already been started. */ 
+  E_BDM_UNIT_NOT_STARTED = 1453, /**<  BDM: Unit has not yet been started. */ 
+  E_BDM_NOT_CONFIGURED = 1454, /**<  BDM: Has not been configured yet. */ 
+  E_BDM_STARTUP_FAILED = 1455, /**<  BDM: Startup failed. */ 
+  E_BDM_SHUTDOWN_FAILED = 1456, /**<  BDM: Shutdown failed. */ 
+  E_BDM_WRITE_FAILED = 1457, /**<  BDM: An error occurred while writing. */ 
+  E_BDM_READ_FAILED = 1458, /**<  BDM: An error occurred while reading */ 
+  E_BDM_ERASE_FAILED = 1459, /**<  BDM: An error occurred while erasing. */ 
+  E_BDM_JUNK_FAILED = 1460, /**<  BDM: An error occurred while junking. */ 
+  E_BDM_GC_FAILED = 1461, /**<  BDM: An error occurred while garbage collecting. */ 
+  E_BDM_GET_INFO_FAILED = 1462, /**<  BDM: An error occurred while retrieving info about a BDM unit. */ 
+  E_BDM_WRITE_NOT_SUPPORTED = 1463, /**<  BDM: Write not supported. */ 
+  E_BDM_JUNK_NOT_SUPPORTED = 1464, /**<  BDM: Junk not supported. */ 
+  E_BDM_GC_NOT_SUPPORTED = 1465, /**<  BDM: Garbage collection not supported. */ 
+  E_BDM_SYNC_FAILED = 1466, /**<  BDM: Synchronize failed. */ 
+  E_BDM_NOT_SUPPORTED = 1467, /**<  BDM: Function not supported. */ 
+  E_BDM_PAUSED = 1468, /**<  BDM: Paused. */ 
+  E_BDM_NOT_PAUSED = 1469, /**<  BDM: Not paused. */ 
+  E_BDM_FINDING_BAM_BLOCKS = 1470, /**<  BDM: BAM blocks not found. */ 
+  E_BDM_BAD_PARAM = 1471, /**<  BDM: Argument invalid or out of range. */ 
+  E_BDM_FORMAT_FAILED = 1472, /**<  BDM: Formatting failed. */ 
+  E_BDM_INVALID_UNIT = 1473, /**<  BDM: The unit number is out of range. */ 
+  E_BDM_INVALID_CONFIG = 1474, /**<  BDM: Some part of the configuration is invalid. */ 
+  E_BDM_PRE_FLASH_FINISHED = 1475, /**<  BDM: No more preflash blocks can be fetched. */ 
+  E_BDM_PRE_FLASH_TERMINATE_FAILED = 1476, /**<  BDM: Termination of preflash failed. */ 
+  E_BDM_OUT_OF_MEM = 1477, /**<  BDM: Could not allocate enough memory. */ 
+  E_BDM_XSR_CRITICAL_ERROR = 1481, /**<  BDM XSR: Critical error. */ 
+  E_BDM_XSR_INVALID_PARAMS = 1482, /**<  BDM XSR: Invalid parameters. */ 
+  E_BDM_XSR_PARTITION_NOT_OPENED = 1483, /**<  BDM XSR: Could not open partition. */ 
+  E_BDM_XSR_UNFORMATTED_FLASH = 1484, /**<  BDM XSR: Unformatted flash. */ 
+  E_BDM_XSR_ALLOCATION_ERROR = 1485, /**<  BDM XSR: Failed to allocate. */ 
+  E_BDM_XSR_INVALID_PARTITION = 1486, /**<  BDM XSR: Invalid partition. */ 
+  E_BDM_XSR_READ_ERROR = 1487, /**<  BDM XSR: An error occurred while reading. */ 
+  E_BDM_XSR_WRITE_ERROR = 1488, /**<  BDM XSR: An error occurred while writing. */ 
+  E_BDM_XSR_ERASE_ERROR = 1489, /**<  BDM XSR: An error occurred while erasing. */ 
+  E_BDM_XSR_DEVICE_ERROR = 1490, /**<  BDM XSR: Device error. */ 
+  E_BDM_XSR_GOODBLOCK = 1491, /**<  BDM XSR: Good block. */ 
+  E_BDM_XSR_BADBLOCK = 1492, /**<  BDM XSR: Bad block. */ 
+  E_BAM_NOT_CONFIGURED = 1551, /**<  BAM: Is not configured. */ 
+  E_BAM_ERR_UNSUPPORTED_PAGE_SIZE = 1552, /**<  BAM: Unsupported page size. */ 
+  E_BAM_ERR_ERASING_BLOCK = 1553, /**<  BAM: Erase block could not be properly erased. */ 
+  E_BAM_ERR_OUT_OF_MEMORY = 1554, /**<  BAM: Not enough free memory to serve request. */ 
+  E_BAM_ERR_CHECKING_BADNESS = 1555, /**<  BAM: There was a problem checking if a block was bad or not. */ 
+  E_BAM_ERR_FINDING_BLOCK = 1556, /**<  BAM: Reserved block could not be found. */ 
+  E_BAM_ERR_READING_PAGE = 1557, /**<  BAM: An error occurred while reading a page in a block. */ 
+  E_BAM_ERR_MARKING_BLOCK_BAD = 1558, /**<  BAM: A block went bad and BAM could not mark it as bad properly. */ 
+  E_BAM_ERR_READING_OUTSIDE_BLOCK = 1559, /**<  BAM: Read would result in a read beyond end of reserved block. */ 
+  E_BAM_ERR_UNCORRECTABLE_ERROR = 1560, /**<  BAM: An uncorrectable read error occurred while reading block. */ 
+  E_BAM_ERR_WRITING_PAGE = 1561, /**<  BAM: An error occurred while writing a page to a reserved block. */ 
+  E_BAM_ERR_WRITING_BLOCK = 1562, /**<  BAM: An error occurred while writing to a reserved block. */ 
+  E_BAM_ERR_RESCUING_BLOCK = 1563, /**<  BAM: There was a problem rescuing a block that went bad during the request. */ 
+  E_BAM_ERR_CONFIG_MISSING = 1564, /**<  BAM: No configuration was given. */ 
+  E_BAM_ERR_ALREADY_STARTED = 1565, /**<  BAM: Has already been started. */ 
+  E_BAM_ERR_NOT_STARTED = 1566, /**<  BAM: Has not been started yet. */ 
+  E_BAM_ERR_UNSUPPORTED_OPERATION = 1567, /**<  BAM: Requested operation is not supported. */ 
+  E_BAM_ERR_CORRUPT_STATE = 1568, /**<  BAM: Internal state has been corrupted. */ 
+  E_BAM_ERR_UNSUPPORTED_MEDIA = 1569, /**<  BAM: The configured media type is not supported. */ 
+  E_BAM_ERR_UNSUPPORTED_REDUNDANT_AREA_SIZE = 1570, /**<  BAM: Unsupported redundant area size. */ 
+  E_BAM_ERR_READING_BLOCK = 1571, /**<  BAM: Reading block failed. */ 
+  E_BAM_ERR_SHUTTING_DOWN = 1572, /**<  BAM: Shutting down failed. */ 
+  E_BAM_ERR_UNINITIALIZING = 1573, /**<  BAM: An error occurred with uninitializing. */ 
+  E_BAM_ERR_INVALID_OFFSET = 1574, /**<  BAM: Invalid offset. */ 
+  E_BAM_ERR_INVALID_SIZE = 1575, /**<  BAM: Invalid size. */ 
+  E_BAM_ERR_RETRIEVING_INFO = 1576, /**<  BAM: Retrieving info failed. */ 
+  E_BAM_ERR_INVALID_CONFIG = 1577, /**<  BAM: Invalid configuration. */ 
+  E_BAM_ERR_ERASING_ALL_BLOCKS = 1578, /**<  BAM: An error occurred while erasing all blocks. */ 
+  E_BAM_ERR_BLOCK_MARKED_BAD = 1579, /**<  BAM: Block was marked as bad while doing an operation. */ 
+  E_BAM_ERR_VALIDATING_START_BLOCK = 1580, /**<  BAM: Can not assure that start block configuration refers to a block boundary. */ 
+  E_BAM_ERR_FAILED_TO_GET_MEMORYTECHNOLOGY = 1581, /**<  BAM: Unable the query FAM about the memory technology used in the memory we are trying to initialize BAM on. */ 
+  E_BAM_ERR_BLOCK_RESCUED = 1582, /**<  BAM: Block rescue failed. */ 
+  E_BAM_ERR_DETERMINING_BBM = 1583, /**<  BAM: Failed to determine what BBM type configuration has been written to flash. */ 
+  E_BAM_ERR_SET_ECC_LENGTH = 1584, /**<  BAM: Failed to set the length to use with HW ECC acceleration. */ 
+  E_BAM_ERR_INVALID_BBM_TYPE = 1585, /**<  BAM: Invalid BBM type. */ 
+  E_BAM_ERR_BOOT_BDM_CONFIG_FAILED = 1586, /**<  BAM: Failed to configure boot block device management. */ 
+  E_BAM_ERR_BOOT_BDM_STARTUP_FAILED = 1587, /**<  BAM: Failed to startup boot block device management. */ 
+  E_BAM_ERR_BOOT_BDM_INSTANCE_NOT_FOUND = 1588, /**<  BAM: Boot block device management instance not found. */ 
+  E_BAM_ERR_BOOT_BDM_BLOCKS_NOT_FOUND = 1589, /**<  BAM: Boot block device management blocks not found. */ 
+  E_BAM_ERR_BOOT_BDM_NOT_STARTED = 1590, /**<  BAM: Boot block device management not started. Requested operation require BDM to be started. */ 
+  E_BAM_ERR_UNIT_OUT_OF_RANGE = 1591, /**<  BAM: Unit is out of range. */ 
+  E_BAM_ERR_BDM_STARTUP_FAILED = 1592, /**<  BAM: Block device management startup failed. */ 
+  E_BAM_ERR_BLOCK_NOT_ERASED = 1593, /**<  BAM: Block not erased. */ 
+  E_BAM_ONLD_CRITICAL_ERROR = 1601, /**<  BAM ONLD: Critical error. */ 
+  E_BAM_ONLD_INVALID_PARAMS = 1602, /**<  BAM ONLD: Invalid parameters. */ 
+  E_BAM_ONLD_INITIALISATION_ERROR = 1603, /**<  BAM ONLD: Initialisation error. */ 
+  E_BAM_ONLD_READ_ERROR = 1604, /**<  BAM ONLD: An error occurred while reading. */ 
+  E_BAM_ONLD_WRITE_ERROR = 1605, /**<  BAM ONLD: An error occurred while writing. */ 
+  E_BAM_ONLD_ERASE_ERROR = 1606, /**<  BAM ONLD: An error occurred while erasing. */ 
+  E_BAM_ONLD_DEVICE_ERROR = 1607, /**<  BAM ONLD: Device error. */ 
+  E_BAM_ONLD_GOODBLOCK = 1608, /**<  BAM ONLD: Good block. */ 
+  E_BAM_ONLD_BADBLOCK = 1609, /**<  BAM ONLD: Bad block. */ 
+  E_COPS_MEMORY_ALLOC_FAILED = 1651, /**<  COPS: Memory allocation failed. */ 
+  E_COPS_DATA_TAMPERED = 1652, /**<  COPS: Data is tempered. */ 
+  E_COPS_IMEI_MISSMATCH = 1653, /**<  COPS: IMEI missmatch. */ 
+  E_COPS_OTP_LOCKED = 1654, /**<  COPS: OTP is locked. */ 
+  E_COPS_MAC_FUNCTION_LOCKED_DOWN = 1655, /**<  COPS: Function for calculating MAC is locked down. */ 
+  E_COPS_AUTHENTICATION_FAILED = 1656, /**<  COPS: Authentication failed. */ 
+  E_COPS_DATA_NOT_PRESENT = 1657, /**<  COPS: Default Data is not present. */ 
+  E_COPS_IMEI_UPDATE_NOT_ALLOWED = 1658, /**<  COPS: IMEI update is not allowed. */ 
+  E_COPS_LOCK_PERMANENTLY_DISABLED = 1659, /**<  COPS: Locking of SIMLocks is disabled. */ 
+  E_COPS_NO_ATTEMPTS_LEFT = 1660, /**<  COPS: No more attempts for verification left. */ 
+  E_COPS_INCORRECT_CONTROLKEY = 1661, /**<  COPS: Control key is not correct. */ 
+  E_COPS_TOO_SHORT_CONTROLKEY = 1662, /**<  COPS: Control key is too short. */ 
+  E_COPS_TOO_LONG_CONTROLKEY = 1663, /**<  COPS: Control key is too long. */ 
+  E_COPS_INVALID_CONTROLKEY = 1664, /**<  COPS: Control key is not valid. */ 
+  E_COPS_TIMER_RUNNING = 1665, /**<  COPS: Timer is running. */ 
+  E_COPS_SIM_ERROR = 1666, /**<  COPS: SIM error. */ 
+  E_COPS_LOCKING_FAILED = 1667, /**<  COPS: Locking failed. */ 
+  E_COPS_OTA_UNLOCK_IMEI_MISMATCH = 1668, /**<  COPS: OTA unlock IMEI mismatch. */ 
+  E_COPS_INCORRECT_IMSI = 1669, /**<  COPS: Incorrect IMSI. */ 
+  E_COPS_PARAMETER_ERROR = 1670, /**<  COPS: Parameter error. */ 
+  E_COPS_BUFFER_TOO_SMALL = 1671, /**<  COPS: Memory buffer is too small. */ 
+  E_COPS_FORBIDDEN_PARAMETER_ID = 1672, /**<  COPS: Parameter is not allowed. */ 
+  E_COPS_UNKNOWN_PARAMETER_ID = 1673, /**<  COPS: Parameter can not be recognised. */ 
+  E_COPS_ARGUMENT_ERROR = 1674, /**<  COPS: Argument error! */ 
+  E_COPS_VERIFY_FAILED = 1698, /**<  COPS: Failed to verify internal data. */ 
+  E_COPS_UNDEFINED_ERROR = 1699, /**<  COPS: Undefined error. */ 
+  E_PD_NAND_RESULT_BIT_ERROR_CORRECTED = 1751, /**<  PD NAND: A bit error was detected and corrected. */ 
+  E_PD_NAND_RESULT_UNCORRECTABLE_BIT_ERROR = 1752, /**<  PD NAND: An uncorrectable bit error was detected. */ 
+  E_PD_NAND_RESULT_BAD_PARAMETER = 1753, /**<  PD NAND: The function could not perform the requested operation due to a bad parameter. */ 
+  E_PD_NAND_RESULT_HW_ERROR = 1754, /**<  PD NAND: A hardware error occurred. */ 
+  E_PD_NAND_RESULT_INTERNAL_ERROR = 1755, /**<  PD NAND: A module internal error has occurred. The module has reach an unexpected state or request. */ 
+  E_PD_NAND_RESULT_BUSY = 1756, /**<  PD NAND: Busy flag was returned. */ 
+  E_PD_NAND_RESULT_READING_ERASED_PAGE = 1757, /**<  PD NAND: Attempting to read erased page. */ 
+  E_PD_NAND_RESULT_NUMBER_OF_ITEMS = 1758, /**<  PD NAND: Number of valid states of this type. */ 
+  E_PD_NAND_RESULT_UNDEFINED = 1759, /**<  PD NAND: Represents an undefined value of this type. */ 
+  E_GD_TA_BASE = 1851, /**<  GD/TA: TA base. */ 
+  E_GD_TA_UNKNOWN_PARTITION = 1852, /**<  GD/TA: Unknown partition. */ 
+  E_GD_TA_UNKNOWN_CONFIG = 1853, /**<  GD/TA: Unknown configuration. */ 
+  E_GD_TA_ILLOGICAL_CONFIGURATION = 1854, /**<  GD/TA: Ilogical configuration. */ 
+  E_GD_TA_UNKNOWN_MEMORY_TYPE = 1855, /**<  GD/TA: Unknown memory type. */ 
+  E_GD_TA_WRONG_PARAMETER = 1856, /**<  GD/TA: Wrong parameter. */ 
+  E_GD_TA_OUT_OF_MEMORY = 1857, /**<  GD/TA: Out of memory. */ 
+  E_GD_TA_INVALID_ADRESS = 1858, /**<  GD/TA: Invalid adress. */ 
+  E_GD_TA_UNUSED_ADRESS = 1859, /**<  GD/TA: Unused adress. */ 
+  E_GD_TA_UNIT_NOT_FOUND = 1860, /**<  GD/TA: Unit not found. */ 
+  E_GD_TA_NOT_IMPLEMENTED = 1861, /**<  GD/TA: TA is not supported. */ 
+  E_GD_TA_FAIL = 1862, /**<  GD/TA: TA fail. */ 
+  E_GD_UNKNOWN_UNIT_NAME = 1863, /**<  GD: Unknown unit name. */ 
+  E_GD_LAST = 1864, /**<  GD: Last enumeration (last valid + 1). */ 
+  E_FAILED_TO_STORE_IN_FIFO = 1900, /**<  Failed to store data in FIFO. */ 
+  E_FAILED_TO_SET_COMM_DEVICES = 1951, /**<  Failed to set parameters of communications devices. */ 
+  E_FAILED_TO_STORE_IN_STACK = 1952, /**<  Failed to store in stack. */ 
+  E_ZIP_PARSER_FILE_NOT_FOUND = 1954, /**<  The requested file is not found in the specified Zip archive. */ 
+  E_ELF_FILE_FORMAT = 1955, /**<  The requested file is not an elf file. */ 
+  E_ELF_OPEN_SECTION = 1956, /**<  Can not open elf section. */ 
+  E_NAME_TOO_LONG = 1957, /**<  The name of parameter is too long. */ 
+  E_BOOTRECORDS_MISMATCH = 1958, /**<  Error in boot records. */ 
+  E_BOOTRECORD_EMPTY = 1959, /**<  Boot record is empty and operation cannot be executed. */ 
+  E_INVALID_BOOTRECORD_IMAGE = 1960, /**<  Boot record image is not valid. */ 
+  E_BOOTRECORD_FULL = 1961, /**<  Boot record has no space to accept new boot record. */ 
+  E_BOOTRECORD_NOT_EXIST = 1962, /**<  Boot record not exist. */ 
+  E_BOOTRECORD_WRITE_FAILED = 1963, /**<  Writing failed. */ 
+  E_BOOTRECORD_UNALIGNED_DATA = 1964, /**<  Boot record data is unaligned. */ 
+  E_CONTENT_TYPE = 1965, /**<  Content type to long. */ 
+  E_DEVICE_TYPE = 1966, /**<  Device type to long. */ 
+  E_NUMBER_OF_TARGET_DEVICES = 1967, /**<  Number of target devices to big. */ 
+  E_DESCRIPTION_TOO_LONG = 1968, /**<  Description field too long. */ 
+  E_MODULE_NOT_FOUND = 2000, /**<  Testing this module currently not supported in ADbg. */ 
+  E_MODULE_LIST_EMPTY = 2001, /**<  There isn't any module available for testing. */ 
+  E_CASE_NOT_FOUND = 2002, /**<  Specified case can not be found. */ 
+  E_CASE_LIST_EMPTY = 2003, /**<  There isn't any test cases in specified module. */ 
+  E_INT_GROUP_NOT_FOUND = 2004, /**<  Specified internal group can not be found. */ 
+  E_INT_GROUP_LIST_EMPTY = 2005, /**<  There isn't any internal group. */ 
+  E_INT_FUNCTION_NOT_FOUND = 2006, /**<  Specified interface function cannot be found. */ 
+  E_INT_FUNCTION_LIST_EMPTY = 2007, /**<  There isn't any interface function in interface group. */ 
+  E_PRECONDITION_IS_ALREADY_SET = 2008, /**<  Request for setting precondition that is already set. */ 
+  E_PRECONDITION_IS_NOT_SET = 2009, /**<  Request to recover condition that is not changed. */ 
+  E_INIT_OTP_PD_FAILED = 2100, /**<  Failed to initialize OTD driver. */ 
+  E_READING_OTP_FAILED = 2101, /**<  Failed to read data from OTP. */ 
+  E_WRITTING_OTP_FAILED = 2102, /**<  Failed to write data in OTP. */ 
+  E_INVALID_CID_VALUE = 2103, /**<  Trying to write invalid CID in OTP. */ 
+  E_INIT_OTP_LD_FAILED = 2104, /**<  Failed to initialize OTD logical driver. */ 
+  E_OTP_AREA_LOCKED = 2105, /**<  Requested OTP area is already locked. */ 
+  E_SEC_APP_PROPERTY_NOT_FOUND = 2251, /**<  App property cannot be found. */ 
+  E_SEC_APP_IMEI_NOT_CHANGABLE = 2252, /**<  IMEI not changeable. */ 
+  E_SEC_APP_OPERATION_DENIED = 2253, /**<  Security operation denied. */ 
+  E_SEC_APP_UNABLE_TO_READ_BS_PARAMETERS = 2254, /**<  Incorrect Boot Stage Parameter vector. */ 
+  E_SEC_APP_ROM_ERROR_CRITICAL = 2255, /**<  Critical error in ROM has occurred. */ 
+  E_SEC_APP_ROM_ERROR = 2256, /**<  Unexpected ROM error. */ 
+  E_SEC_APP_PATCH_EXISTS = 2257, /**<  ROM Patch is already installed. */ 
+  E_SEC_APP_PATCH_REINSTALLED = 2258, /**<  Operation successful. */ 
+  E_SEC_APP_ROOTKEY_EXISTS = 2259, /**<  RootKey is already installed. */ 
+  E_SEC_APP_ROOTKEY_REINSTALLED = 2260, /**<  Operation successful. */ 
+  E_TA_WRONG_PARTITION = 2351, /**<  TA: Unknown partition. */ 
+  E_TA_ILLOGICAL_CONFIGURATION = 2352, /**<  TA: Configuration error. */ 
+  E_TA_UNKNOWN_MEMORY_TYPE = 2353, /**<  TA: Unsupported memory type. */ 
+  E_TA_WRONG_PARAMETER = 2354, /**<  TA: Wrong parameter. */ 
+  E_TA_OUT_OF_MEMORY = 2355, /**<  TA: No heap memory left. */ 
+  E_TA_INVALID_ADRESS = 2356, /**<  TA: Invalid address. */ 
+  E_TA_UNUSED_ADRESS = 2357, /**<  TA: Unused address. */ 
+  E_TA_UNIT_NOT_FOUND = 2358, /**<  TA: Unit was not found. */ 
+  E_TA_WRONG_SIZE = 2359, /**<  TA: Wrong size when reading unit. */ 
+  E_TA_INSUFFICIANT_SPACE = 2360, /**<  TA: Not enough space to flush the Trim Area. */ 
+  E_TA_UNKNOWN_PARTITION = 2361, /**<  TA: Unknown partition. */ 
+  E_TA_FAIL = 2362, /**<  TA: Fail. */ 
+  E_TA_MEDIA_ERROR = 2460, /**<  TA: Media error. */ 
+  E_TA_NOT_CONFIGURED = 2461, /**<  TA: Error occurs during configuration. */ 
+  E_REQUEST_DENIED = 2500, /**<  Request for change operation denied. */ 
+  E_UNDEFINED_CHANGE_OPERATION = 2501, /**<  Requested change operation is not supported. */ 
+  E_PD_CFI_IN_PROGRESS = 2651, /**<  PD CFI: The operation is in progress. Additional poll calls must be done. */ 
+  E_PD_CFI_UNKNOWN_REQUEST = 2652, /**<  PD CFI: Type not recognized. */ 
+  E_PD_CFI_HARDWARE_ERROR = 2653, /**<  PD CFI: Operation could not be completed because of a hardware malfunction. */ 
+  E_PD_CFI_NOT_SUPPORTED = 2654, /**<  PD CFI: The driver does not implement the requested function. */ 
+  E_PD_CFI_PARAMETER_ERROR = 2655, /**<  PD CFI: Invalid parameter value. */ 
+  E_PD_CFI_PROTECTED = 2656, /**<  PD CFI: The requested flash address is protected from the requested type of access. */ 
+  E_PD_CFI_UNSUPPORTED_DEVICE = 2657, /**<  PD CFI: Flash devices not supported by this driver. */ 
+  E_PD_CFI_OPERATION_COMPLETE = 2658, /**<  PD CFI: Requested operation was not suspended as it has completed. */ 
+  E_PD_CFI_HARDWARE_NOT_DETECTED = 2659, /**<  PD CFI: NOR memory was not detected on current configuration. */ 
+  E_HSI_BSC_RESULT_FAILED = 2701, /**<  General Error. */ 
+  E_HSI_BSC_RESULT_FAILED_INVALIDARGS = 2702, /**<  Invalid arguments. */ 
+  E_HSI_BSC_RESULT_FAILED_NOTSUPPORTED = 2703, /**<  Implementation is removed. */ 
+  E_HSI_BSC_RESULT_FAILED_HSIERR = 2704, /**<  HSI internal error. */ 
+  E_HSI_BSC_RESULT_FAILED_BUSY = 2705, /**<  Communication device is busy. */ 
+  E_HSI_BSC_ERROR_SIGNAL = 2751, /**<  Signal error. */ 
+  E_HSI_BSC_ERROR_TIMEOUT = 2752, /**<  Timeout error. */ 
+  E_HSI_BSC_ERROR_BREAK = 2753, /**<  Break received. */ 
+  E_HSI_BSC_ERROR_RECEIVE = 2754, /**<  Receive buffer is not provided. */ 
+  E_HSI_BSC_ERROR_TRANSMIT = 2755, /**<  Transmit buffer is not provided. */ 
+  E_CR_INVALID_STATE = 2850, /**<  Invalid state for commnication relay detected. */ 
+  E_CR_NOT_RUNNING = 2851, /**<  Communication Relay is not running. */ 
+  E_SDIO_BSC_RESULT_FAILED = 2901, /**<  General Error. */ 
+  E_SDIO_BSC_RESULT_FAILED_INVALIDARGS = 2902, /**<  Invalid arguments. */ 
+  E_SDIO_BSC_RESULT_FAILED_NOTSUPPORTED = 2903, /**<  Implementation is removed. */ 
+  E_SDIO_BSC_RESULT_FAILED_SDIOERR = 2904, /**<  SDIO internal error. */ 
+  E_SDIO_BSC_RESULT_FAILED_BUSY = 2905, /**<  Communication device is busy. */ 
+  E_SDIO_BSC_ERROR_TIMEOUT = 2951, /**<  Timeout error. */ 
+  E_SDIO_BSC_ERROR_BREAK = 2952, /**<  Break received. */ 
+  E_SDIO_BSC_ERROR_RECEIVE = 2953, /**<  Receive buffer is not provided. */ 
+  E_SDIO_BSC_ERROR_TRANSMIT = 2954, /**<  Transmit buffer is not provided. */ 
+  E_LOADER_SEC_LIB_CHIP_ID_INVALID = 4000, /**<  Invalid input parameters. */ 
+  E_LOADER_SEC_LIB_INVALID_PARAMETER_TO_FUNC = 4096, /**<  Invalid input parameters. */ 
+  E_LOADER_SEC_LIB_FAILURE = 4120, /**<  Failure. */ 
+  E_LOADER_SEC_LIB_HASH_LIST_HASH_FAILURE = 4121, /**<  hash list verification failed. */ 
+  E_LOADER_SEC_LIB_HEADER_VERIFICATION_FAILURE = 4122, /**<  Header verification failed.  */ 
+  E_LOADER_SEC_LIB_HEADER_VERIFIED = 4123, /**<  Successful verification of the header */ 
+  E_LOADER_SEC_LIB_VERIFY_FAILURE = 4124, /**<  Unsuccessful verification. */ 
+  E_LOADER_SEC_LIB_INIT_CALLED_TWICE = 4150, /**<  The security library init function has been called 2 times. */ 
+  E_LOADER_SEC_LIB_MEMORY_RELEASE_FAILED = 4180, /**<  Memory release failed. */ 
+  E_LOADER_SEC_LIB_MEMORY_ALLOCATION_FAILED = 4181, /**<  Memory allocation failed. */ 
+  E_LOADER_SEC_LIB_DATA_BLOCK_EXIST = 4182, /**<  Data block exist in the linked list. */ 
+  E_LOADER_SEC_LIB_DATA_BLOCK_DO_NOT_EXIST = 4183, /**<  Data block do not exist in the linked list. */ 
+  E_LOADER_SEC_LIB_INVALID_AUTHENTICATION_TYPE = 4184, /**<  Invalid authentication type. */ 
+  E_LOADER_SEC_LIB_EXCEEDED_NUMBER_OF_AUTHENTICATION = 4185, /**<  Exceeded number of authentication. Loader will be shut downed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_INIT_FAILED = 4186, /**<  Initialization of ESB block for MAC calculation failed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_UPDATE_FAILED = 4187, /**<  MAC update with ESB block failed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_FINAL_FAILED = 4188, /**<  MAC finalize with ESB block failed. */ 
+  E_LOADER_SEC_LIB_ESB_MAC_NOT_VERIFIED = 4189, /**<  MAC verification with ESB block failed. */ 
+  E_LOADER_SEC_LIB_ESB_DOWNLOCK_FAILED = 4190, /**<  ESB downlock failed. */ 
+  E_LOADER_SEC_LIB_CONTROL_KEY_VERIFICATION_FAILURE = 4191, /**<  Control key verification failed. */ 
+  E_LOADER_SEC_LIB_CA_CERTIFICATE_VERIFICATION_FAILURE = 4192, /**<  CA certificate verification failed. */ 
+  E_LOADER_SEC_LIB_X509_ERROR_IN_CERTIFICATE = 4193, /**<  X509 certificate error. */ 
+  E_LOADER_SEC_LIB_COPS_INIT_FAILED = 4194, /**<  COPS initialization failed. */ 
+  E_LOADER_SEC_LIB_COPS_PROTECT_DATA_INIT_FAILED = 4195, /**<  COPS protect data initialization failed. */ 
+  E_LOADER_SEC_LIB_COPS_DATA_READ_FAILED = 4196, /**<  COPS data read failed. */ 
+  E_LOADER_SEC_LIB_COPS_DATA_WRITE_FAILED = 4197, /**<  COPS data write failed. */ 
+  E_LOADER_SEC_LIB_READ_OTP_FAILED = 4198, /**<  Reading OTP data failed. */ 
+  E_LOADER_SEC_LIB_WRITE_OTP_FAILED = 4199, /**<  Writing OTP data failed. */ 
+  E_LOADER_SEC_LIB_LOCK_OTP_FAILED = 4200, /**<  Locking OTP data failed. */ 
+  E_LOADER_SEC_LIB_UNPACKING_IMEI_FAILED = 4201, /**<  Unpacking IMEI data failed. */ 
+  E_LOADER_SEC_LIB_PACKING_IMEI_FAILED = 4202, /**<  Packing IMEI data failed. */ 
+  E_LOADER_SEC_LIB_OTP_ALREADY_LOCKED = 4203, /**<  OTP is already locked. */ 
+  E_LOADER_SEC_LIB_INVALID_CID_VALUE = 4204, /**<  CID value is out of range. */ 
+  E_LOADER_SEC_LIB_OTP_LOCKBITS_MISSMATCH = 4205, /**<  OTP lock bits have different values. */ 
+  E_LOADER_SEC_LIB_WRITING_BOOTRECORD_FAILED = 4206, /**<  Failed to write in boot records. */ 
+  E_LOADER_SEC_LIB_UNSUPPORTED_NO_DEBUG_HW = 4207, /**<  No debug hardware detected. */ 
+  E_LOADER_SEC_LIB_CHANGE_OPERATION_NOT_SUPPORTED = 4208, /**<  Requested change operation is not supported or not allowed. */ 
+  E_LOADER_SEC_LIB_INVALID_CHANGE_OPERATION = 4209, /**<  Invalid change operation. */ 
+  E_LOADER_SEC_LIB_RWIMEI_NOT_ALLOWED = 4210, /**<  Rewriteable IMEI is not allowed to change. */ 
+  E_LOADER_SEC_LIB_REQUEST_DENIED = 4211, /**<  Request for change operation is denied. */ 
+  E_LOADER_SEC_LIB_BOOT_BLOCK_DO_NOT_EXIST = 4212, /**<  Boot record do not exist. */ 
+  E_LOADER_SEC_LIB_CORRUPTED_DOMAIN_DATA = 4213, /**<  Corrupted or do not exist domain data in boot block. */ 
+  E_LOADER_SEC_LIB_INVALID_DOMAIN = 4214, /**<  Invalid domain. */ 
+  E_LOADER_SEC_LIB_INVALID_CHALLENGE_DATA_BLOCK = 4215, /**<  Invalid challenge data block. */ 
+  E_LOADER_SEC_LIB_NO_DEBUG_HW_NOT_ALLOWED = 4216, /**<  Not allowed operation on NoDebug HW. */ 
+  E_FIFO_OVERFLOW = 4300, /**<  UART FIFO overflow. */ 
+  E_FIFO_UNDERFLOW = 4301, /**<  UART FIFO underflow. */ 
+  E_OBJECT_NULL = 4302, /**<  Null pointer to Object. */ 
+  E_POINTER_NOT_NULL = 4303, /**<  Pointer is not NULL. */ 
+  E_UNRECOGNIZED_STATE = 4304, /**<  The state in the State Machine is invalid. */ 
+  E_UNKNOWN_MANUFACTURER_ID = 4305, /**<  The provided manufacturer ID is not valid. */ 
+  E_UNKNOWN_DEVICE_ID = 4306, /**<  The provided device ID is not valid. */ 
+  E_INVALID_A01_FORMAT = 4308, /**<  Something wrong with the A01 file containing the flash image. */ 
+  E_A01_BUFFER_FULL = 4309, /**<  Buffer holding the data from the A01 file is full. */ 
+  E_CONFIG_FILE_NOT_SPECIFIED = 4350, /**<  Configuration file for the emulator is not specified. */ 
+  A2_E_SUCCESS = 5000, /**<  Operation successful. */ 
+  A2_E_PROP_NOT_SUPPORTED = 5001, /**<  The property is not supported. */ 
+  A2_E_PROP_READ_ONLY = 5002, /**<  The property is read only. */ 
+  A2_E_PROP_INVALID = 5003, /**<  The property value is invalid. */ 
+  A2_E_AUTH_DECLINED = 5004, /**<  Authentication declined. The ME is automatically shut down after sending this. */ 
+  A2_E_AUTH_UNSUPPORTED = 5005, /**<  The authentication type is not supported. */ 
+  A2_E_ALLOCATE_FAILED = 5006, /**<  Failed to allocate memory. */ 
+  A2_E_INVALID_TIME = 5007, /**<  Invalid time specified. */ 
+  A2_E_UNKNWON_PROPERTY = 5008, /**<  Unknown property id. */ 
+  A2_E_START_AAIF_FAILED = 5009, /**<  Failed to start the AAIF in the loader on loader. */ 
+  A2_E_UNSUPPORTED_CMD = 5010, /**<  Unsupported command. */ 
+  A2_E_POINTER_NOT_ALIGNED = 5011, /**<  Pointer not aligned. */ 
+  A2_E_ERROR_WRITING_BOOTRECORD = 5012, /**<  Writing of the boot record failed. */ 
+  A2_E_INVALID_CURRDATE_STRING_LENGTH = 5013, /**<  String data length is invalid. */ 
+  A2_E_NO_COMMAND_GROUPS_DEFINED = 5014, /**<  Unknown command group. */ 
+  A2_E_READ_OTP_FAILED = 5015, /**<  Read OTP failed. */ 
+  A2_E_COMMAND_IS_NOT_IMPLEMENTED = 5016, /**<  Specified command is not implemented. */ 
+  A2_E_FAILED_TO_GET_ASIC_COPS_SETTINGS = 5017, /**<  Failed to get ASIC COPS setting. */ 
+  A2_E_FAILED_TO_SET_PLAT_PROP = 5018, /**<  Failed to set platform properties. */ 
+  A2_E_MEMORY_FAILED = 5019, /**<  Memory fail. */ 
+  A2_E_JTAG_UNLOCK_FAILED = 5020, /**<  JTAG unlock fail. */ 
+  A2_E_AUTOCONFIGURE_FLASH = 5021, /**<   */ 
+  A2_E_E_GET_FIRST_FLASH_DEV = 5022, /**<   */ 
+  A2_E_E_FAILED_INIT_COPS_LIB = 5023, /**<  Failed to initialize COPS library. */ 
+  A2_E_OTP_SECURITY_ERROR = 5024, /**<  OTP security error. */ 
+  A2_E_I2C_BUS_SECURITY_ERROR = 5025, /**<  I2C bus security error. */ 
+  A2_E_GET_STATIC_DATA_FAILED = 5026, /**<  Can't get static data. */ 
+  A2_E_STORE_MAC_TO_BOOTIMAGE_FAILED = 5027, /**<  Failed to store MAC in boot image. */ 
+  A2_E_SEC_GENERAL_COPS_LIB_ERROR = 5028, /**<  General COPS error. */ 
+  A2_E_HASH_VERIFICATION_ERROR = 5029, /**<  Hash verification failed. */ 
+  A2_E_READ_FLASH_FAILED = 5030, /**<  Failed to read hash. */ 
+  A2_E_APP_HANDSHAKE_FAILED = 5031, /**<  Processors handshake failed. */ 
+  A2_E_BOOTIMAGE_MEMCONF_INVALID = 5032, /**<  Invalid memconfig in boot image. */ 
+  A2_E_BOOTIMAGE_SIGNATURE_FAILED = 5033, /**<  Boot image signature failed. */ 
+  A2_E_BOOTIMAGE_FAILED_TO_READ_IMAGE = 5034, /**<  Failed to read image. */ 
+  A2_E_BOOTIMAGE_FAILED_ALLOCATE_MEM = 5035, /**<  Failed to allocate memory. */ 
+  A2_E_BOOTIMAGE_INVALID_PARAM = 5036, /**<  Boot image invalid parametars. */ 
+  A2_E_BOOTIMAGE_INVALID_LENGTH = 5037, /**<  Boot image has invalid length. */ 
+  A2_E_BOOTIMAGE_MACED_HEADER_SIZE_ZERO = 5038, /**<  Header size is zero. */ 
+  A2_E_FLASH_RESULT_DEVICE_PROTECTED = 5039, /**<  The flash device was protected. */ 
+  A2_E_FLASH_RESULT_WRITE_SUSPENDED = 5040, /**<  The last write process was suspended. */ 
+  A2_E_FLASH_RESULT_VOLTAGE_RANGE_ERROR = 5041, /**<  The voltage range is invalid. */ 
+  A2_E_FLASH_RESULT_PROGRAM_ERROR = 5042, /**<  Failed to write to the flash device. */ 
+  A2_E_FLASH_RESULT_ERASE_ERROR = 5043, /**<  Failed to erase a block in the flash device. */ 
+  A2_E_FLASH_RESULT_ERASE_SUSPENDED = 5044, /**<  The erase process was suspended. */ 
+  A2_E_FLASH_RESULT_COMMAND_SEQUENCE_ERROR = 5045, /**<  The sequence of the flash commands was invalid. */ 
+  A2_E_FLASH_RESULT_OPERATION_NOT_SUPPORTED = 5046, /**<  Operation was not supported in flashdriver. */ 
+  A2_E_FLASH_RESULT_INVALID_PARAMETER = 5047, /**<  Invalid in-parameter specified when reading/writing to flash. */ 
+  A2_E_FLASH_RESULT_NO_FLASH_DEVICE = 5048, /**<  No flash device was found on the physical address. */ 
+  A2_E_FLASH_RESULT_CONFIGURATION_ERROR = 5049, /**<  Configuration error of flash device. */ 
+  A2_E_FLASH_RESULT_INVALID_STARTADDRESS = 5050, /**<  Invalid start address of the parameter. */ 
+  A2_E_FLASH_RESULT_INVALID_PHYSICAL_ADDRESS = 5051, /**<  Invalid physical address of the parameter. */ 
+  A2_E_FLASH_RESULT_INVALID_DATALENGTH = 5052, /**<  The data length of the parameter is invalid. */ 
+  A2_E_FLASH_RESULT_GETREGION_ERROR = 5053, /**<  Invalid flash region specified. */ 
+  A2_E_FLASH_RESULT_NULL_POINTER_BUF = 5054, /**<  A buffer was NULL. */ 
+  A2_E_FLASH_RESULT_NAND_READ_FAILED = 5055, /**<  Failed to read from the NAND flash. */ 
+  A2_E_FLASH_RESULT_NAND_PAGE_SIZE_UNSUPPORTED = 5056, /**<  The nand page size is unsupported. */ 
+  A2_E_FLASH_RESULT_WRITE_ERROR = 5057, /**<  Failed to write to the flash device. */ 
+  A2_E_FLASH_RESULT_READ_ID_ERROR = 5058, /**<  Failed to read the device ID from the flash device. */ 
+  A2_E_FLASH_RESULT_HARDWARE_ERROR = 5059, /**<  Hardware error in the flash status. */ 
+  A2_E_FLASH_RESULT_READ_FROM_FLASH = 5060, /**<  Failed to read from the flash device. */ 
+  A2_E_FLASH_RESULT_ADD_NEW_DEVICE = 5061, /**<  Failed to add a new instance of a flash device. */ 
+  A2_E_FLASH_RESULT_OTP_UNSUPPORTED_IN_FLASH = 5062, /**<  OTP is not support in the current flash device. */ 
+  A2_E_FLASH_RESULT_OTP_TOO_SMALL = 5063, /**<  The OTP size is to small for the length requested. */ 
+  A2_E_FLASH_RESULT_OTP_READ_FAILED = 5064, /**<  Failed to read the OTP area in the flash device. */ 
+  A2_E_FLASH_RESULT_INVALID_FLASH_TYPE = 5065, /**<  The flash type is unknown. */ 
+  A2_E_FLASH_RESULT_NAND_FLUSH_ERROR = 5066, /**<  Failed to flush the NAND write buffer. */ 
+  A2_E_FLASH_RESULT_NOR_FLUSH_ERROR = 5067, /**<  Failed to flush the NOR write buffer. */ 
+  A2_E_INVALID_LOL_STATE = 5068, /**<  Invalid Loader on loader state. */ 
+  A2_E_INVALID_STATUS_LOLSTATE = 5069, /**<  Invalid loader on loader status. */ 
+  A2_E_WRITE_STATIC_DATA = 5070, /**<  Write static data failed. */ 
+  A2_E_HEADER_NOT_VERIFIED_YET = 5071, /**<  Header is still not verified. */ 
+  A2_E_ALL_BLOCKS_VERIFIED_FAILED = 5072, /**<  Blocks verification failed. */ 
+  A2_E_HANDSHAKE_WITH_APP_SIDE = 5073, /**<  Handshake with App side failed. */ 
+  A2_E_READ_STATIC_DATA = 5074, /**<  Failed to read static data. */ 
+  A2_E_ENABLE_CLOCK_HARDWARE_FAILED = 5075, /**<  Failed to enable clock hardware. */ 
+  A2_E_ENABLE_BLOCK_HARDWARE_FAILED = 5076, /**<  Failed to enable block hardware. */ 
+  A2_E_NO_HEADER_TO_MAC_IN_BOOT = 5077, /**<  Indicates that the loader did not find any header in the bootimage records that could be MAC'ed. */ 
+  A2_E_MMU_SETUP = 5078, /**<  MMU setup failed. */ 
+  A2_E_INVALID_COMMAND_SIZE = 5079, /**<  Invalid command size. */ 
+  A2_E_HASH_LIST_LENGTH_INVALID = 5080, /**<  Invalid hash list length. */ 
+  A2_E_INVALID_INPUT_PARAMETERS = 5081, /**<  Invalid input parameters. */ 
+  A2_E_FAILED_SETUP_MSL_DRIVER = 5082, /**<  MSL driver setup failed. */ 
+  A2_E_REQUEST_DENIED = 5083, /**<  Request denied. */ 
+  A2_E_ASIC_FUSES_INVALID = 5084, /**<  Fuses for the ASIC are invalid. */ 
+  A2_E_STATIC_DATA_NOT_CHECKED = 5085, /**<  Static data is not checked. */ 
+  A2_E_COPS_DATA_MAN_INIT = 5086, /**<  Failed to initialize the cops data man, this can be caused by an corrupt boot image. You probably just need to flash a platform software to get it work. */ 
+  A2_E_UART_DRIVER_ERROR = 5087, /**<  UART driver error. */ 
+  A2_E_INVALID_DOMAIN_FOR_LOADER_TYPE = 5088, /**<  Loader type is not compatible with this domain. */ 
+  A2_E_FUNCTIONALITY_NOT_IN_PRODUCT = 5089, /**<  Functionality not supported. */ 
+  A2_E_DEFALT_DATA_NOT_FOUND = 5090, /**<  Default data can not be found. */ 
+  A2_E_FAILED_TO_MAC_HEADER = 5091, /**<  Failed to send the header to access side to be MAC'ed, could be something wrong with the header. */ 
+  A2_E_APP_PRELOADER_NOT_STARTED = 5092, /**<  App preloader not started. */ 
+  A2_E_INVALID_DEST_ADDRESS = 5093, /**<  Invalid destination address. */ 
+  A2_E_SYS_APP_INIT_FAILURE = 5094, /**<  Failed to initialize the system application. */ 
+  A2_E_FLASH_APP_INIT_FAILURE = 5095, /**<  Failed to initialize the flash application. */ 
+  A2_E_SIGNATURE_APP_INIT_FAILURE = 5096, /**<  Failed to initialize the signature application. */ 
+  A2_E_RESET_APP_INIT_FAILURE = 5097, /**<  Failed to initialize the reset application. */ 
+  A2_E_INT_SEC_APP_INIT_FAILURE = 5098, /**<  Failed to initialize the internal security application. */ 
+  A2_E_COPS_DATA_MAN_FORMAT = 5099, /**<  COPS data man Format. */ 
+  A2_E_COPS_DATA_MAN_WRITE = 5100, /**<  COPS data man write. */ 
+  A2_E_COPS_DATA_MAN_FLUSH = 5101, /**<  Failed to Flush the memory into the security partition. */ 
+  A2_E_COPS_DATA_MAN_GETBLOCKSIZE = 5102, /**<  Failed to get the block size of a unit in the security partition. */ 
+  A2_E_COPS_DATA_MAN_READBLOCK = 5103, /**<  Failed to read an index from the security partition. */ 
+  A2_E_INVALID_FLASH_VAR_LENGTH = 5104, /**<  The bytes left to program should be less than a NAND page. */ 
+  A2_E_BOOTIMAGE_TOO_BIG = 5105, /**<  Boot image is too big. */ 
+  A2_E_GDFS_APP_INIT_FAILURE = 5106, /**<  App GD init failed. */ 
+  A2_E_FILESYS_APP_INIT_FAILURE = 5107, /**<  Failed to initialize the file system. */ 
+  A2_E_INVALID_SOURCE_DEST_ADDRESS = 5108, /**<  Invalid source or destination address. */ 
+  A2_E_INVALID_RESPONSE_COMMAND = 5109, /**<  Invalid Response command number on the internal security command group, was expecting command 0xFF. */ 
+  A2_E_INVALID_RESP_TO_CMD = 5110, /**<  The internal sec command response should have responded to another command. */ 
+  A2_E_VERIFICATION_OF_WRITTEN_DATA_FAILED = 5111, /**<  The data programmed into flash was not the same as the data received! */ 
+  A2_E_INVALID_NAND_PADMUX_SETTING = 5112, /**<  The PADMUX configuration has not been set. */ 
+  A2_E_FLASH_DRIVER_FAILED_SET_BOOT_ADDR = 5113, /**<  Failed to set the start boot address, this address are used to read the static data. */ 
+  A2_E_FLASH_BOOT_IS_NOT_EMPTY = 5114, /**<  if the static data was not found, the flash should be empty! */ 
+  A2_E_BOOTIMAGE_PMC_NOT_NEEDED = 5115, /**<  This error code informs that found boot container holds information that is not PMC protected. */ 
+  A2_E_UNSUPPORTED_PMC = 5116, /**<  The PMC ID is not supported. */ 
+  A2_E_FSVN_VS_PMC = 5117, /**<  The PMC ID is not coordinated with FSVN. */ 
+  A2_E_WRONG_PMC_START_COUNT = 5118, /**<  PMC start count to high or zero. */ 
+  A2_E_UNSUITABLE_PMC_FOR_LOCATION = 5119, /**<  Unsuitable PMC for the location. */ 
+  A2_E_PMC_MISSING = 5120, /**<  The PMC can not be found. */ 
+  A2_E_VERSION_NOT_ACCEPTED = 5121, /**<  FSVN is too low. */ 
+  A2_E_PMC_OVERFLOWN = 5122, /**<  All steps of the PMC are destroyed. */ 
+  A2_E_PMC_ONCE_REQUIRED = 5123, /**<  New version of once protected module attempted to be loaded without ARB flag set. */ 
+  A2_E_PMC_BAD_N_OF_STEPS = 5124, /**<  Unsuitable number of steps within PMC. */ 
+  A2_E_UNIT_MISSING = 5125, /**<  Dynamyc variable is missing. */ 
+  A2_E_UNIT_TO_BIG = 5126, /**<  Dynamyc variable found is to big. */ 
+  A2_E_PARTMAN_READ_ERROR = 5127, /**<  Error reading partition manger status. */ 
+  A2_E_PARTMAN_INIT_ERROR = 5128, /**<  Error initializing partition manger. */ 
+  A2_E_BOOTIMAGE_INVALID_ALLIGNMENT = 5129, /**<  Boot container size is not word alligned. */ 
+  A2_E_BOOTIMAGE_INSUFFICIENT_CONTAINERS = 5130, /**<  Not enough boot containers are allocated. */ 
+  A2_E_BOOTIMAGE_INVALID_CONTAINER_TYPE = 5131, /**<  Invalid boot container type. At this position other type of container is expected. */ 
+  A2_E_DATA_LENGTH_IS_NOT_ALIGNED = 5132, /**<  The data size must be aligned to 512 bytes when reading or writing pages to/from the NAND. */ 
+  A2_E_LOADER_SWINIT_JTAG_UNLOCK_FAILED = 5133, /**<  TEST JTAG EANBLENODEBUG. */ 
+  A2_E_BOOTIMAGE_RECORD_NOT_FOUND = 5134, /**<  Required record is not found in the boot containers. */ 
+  A2_E_BUFFER_OVERFLOW = 5135, /**<  Buffer overflow. */ 
+  A2_E_BUFFER_NOT_ALLOCATED = 5136, /**<  Buffer has not been allocated. */ 
+  A2_E_WRONG_DATA_SIZE = 5137, /**<  Size of data has an unexpected value. */ 
+  A2_E_NO_STATIC_DATA_IN_BOOTIMAGE = 5138, /**<  Static data in boot record is corrupted. */ 
+  A2_E_NOT_ALLOWED_TO_FLASH = 5139, /**<  Not allowed to flash this block. */ 
+  A2_E_UNABLE_TO_CHANGE_MMU_SETTINGS = 5140, /**<  Unable to change MMU settings. */ 
+  A2_E_INVALID_HW_FOR_LOADER_SETTINGS = 5141, /**<  Loader settings are not compatible with loader settings. */ 
+  A2_E_CABS_START_FAILED = 5142, /**<   */ 
+  A2_E_CABS_READ_ERROR = 5143, /**<   */ 
+  A2_E_CABS_WRITE_ERROR = 5144, /**<   */ 
+  A2_E_ELF_DECODE_GENERAL_ERROR = 5145, /**<   */ 
+  A2_E_ELF_INVALID_PARAMETER = 5146, /**<   */ 
+  A2_E_PARTMAN_INIT_FAILED = 5147, /**<   */ 
+  A2_E_PARTMAN_WRITE_FAILED = 5148, /**<   */ 
+  A2_E_PARTMAN_READ_FAILED = 5149, /**<   */ 
+  A2_E_PARTMAN_ERASE_ERROR = 5150, /**<   */ 
+  A2_E_MBBS_CONFIG_ERROR = 5151, /**<   */ 
+  A2_E_MBBS_READ_ERROR = 5152, /**<   */ 
+  A2_E_MBBS_WRITE_ERROR = 5153, /**<   */ 
+  A2_E_MBBS_ERASE_ERROR = 5154, /**<   */ 
+  A2_E_FLASH_HW_CONFIG = 5155, /**<   */ 
+  A2_E_VSP_IS_NOT_ALLOWED = 5156, /**<  Virtual security partition is not allowed in this configuration. */ 
+  A2_E_VSP_WRITE_STATIC_DATA = 5157, /**<  Failed to write static data to virtual security partition. */ 
+  A2_E_VSP_READ_STATIC_DATA = 5158, /**<  Failed to read static data from virtual security partition. */ 
+  A2_E_VSP_NOT_FORMATED = 5159, /**<  Virtual security partition is not initialized. */ 
+  A2_E_VSP_UNSUPPORTED_UNIT_TYPE = 5160, /**<  Unit type is out of range in virtual security partition. */ 
+  A2_E_GET_DYNAMIC_DATA_FAILED = 5161, /**<  Could not get the dynamic data from the security library. */ 
+  A2_E_FLASH_RESULT_PARTITION_TABLE_FLASHED = 5162, /**<  Partition table repaired!! Please load file again. */ 
+  A2_E_FLASH_RESULT_PARTITION_TABLE_NOT_FLASHED = 5163, /**<  Partition table is damaged! */ 
+  A2_E_FLASH_RESULT_READ_FROM_PARTITION_TABLE = 5164, /**<  Partition table is damaged. */ 
+  A2_E_BOOTIMAGE_PARTITION_RECORD_NOT_FOUND = 5165, /**<  Partition table record is not found in the boot containers. */ 
+  A2_E_CORRUPT_STATIC_DATA_IN_BOOT_BLOCK = 5166, /**<  Static data in boot block is corrupt. */ 
+  A2_E_MBBS_BBM_TYPE_CONFLICT = 5167, /**<  MBBS and BBM type conflict. */ 
+  A2_E_EXECUTION_NOT_PERMITTED = 5168, /**<  Execution of this command is not allowed in the current domain with current authentication state. */ 
+  A2_E_EXECUTION_NOT_PERMITTED_WARNING = 5169, /**<  Execution of this command is not allowed in the current domain with current authentication state. */ 
+  A2_E_UNABLE_TO_INITIALIZE_LCD = 5171, /**<  Error during initialization of LCD drivers. */ 
+  A2_E_LCD_NOT_INITIALIZED = 5172, /**<  LCD is not initialized. */ 
+  A2_E_UNABLE_TO_DISPLAY_DATA_ON_LCD = 5173, /**<  Unrecoverable error during BMP image is processed. */ 
+  A2_E_NETWORK_BUFFER_CORRUPTED = 5174, /**<  The network buffer area is corrupted. */ 
+  A2_E_TOO_MENY_FRAGMENTS = 5200, /**<   */ 
+  A2_E_FAILED_TO_GET_APPLICATION = 5201, /**<   */ 
+  A2_E_SECURITY_LIBRARY_ERROR_BEGIN = 9096, /**<   */ 
+  A2_E_SECURITY_LIBRARY_ERROR_END = 9300, /**<   */ 
+  A2_E_UNSUPPORTED_PROPERTY = 5301, /**<  Unsupported file system property. */ 
+  A2_E_READ_ONLY = 5302, /**<  The property is read only. */ 
+  A2_E_INVALLID_PROPERTY_SPECIFIED = 5303, /**<  The specified property value was invalid. */ 
+  A2_E_ACCESS_DENIED = 5304, /**<  The access permission attributes do not allow operation. */ 
+  A2_E_FORMATTING_FS = 5305, /**<  The file system is formatting. */ 
+  A2_E_PATH_NOT_EXISTS = 5306, /**<  The path does not exist. */ 
+  A2_E_PATH_ALREADY_EXISTS = 5307, /**<  The path already exists. */ 
+  A2_E_PATH_READ_ONLY = 5308, /**<  The path is read only. */ 
+  A2_E_INSUFFICENT_SPACE = 5309, /**<  Insufficient space. */ 
+  A2_E_DIRECTORY_NOT_EMPTY = 5310, /**<  The directory is not empty. */ 
+  A2_E_INVALID_RESTRICTION_SPECIFIED = 5311, /**<  Invalid access restrictions specified. */ 
+  A2_E_NO_FILESYSTEM_PROPERTY = 5312, /**<  No file system property. */ 
+  A2_E_FILE_NOT_EXISTS = 5313, /**<  The file does not exist. */ 
+  A2_E_CHANGE_DIR = 5314, /**<  Failed to change directory. */ 
+  A2_E_CHMOD = 5315, /**<  Failed to set new CH mod. */ 
+  A2_E_GWD = 5316, /**<  Failed to get the current directory. */ 
+  A2_E_OPEN_FILE = 5317, /**<  Failed to open a file in the file system. */ 
+  A2_E_ITEM_STAT = 5318, /**<  Failed to read the stat from file. */ 
+  A2_E_LIST_VOL = 5319, /**<  Failed to list volumes. */ 
+  A2_E_FREE_SPACE = 5320, /**<  No free space left. */ 
+  A2_E_CLOSE_FILE = 5321, /**<  Failed to close a file in the filesystem. */ 
+  A2_E_CLOSE_DIRECTORY = 5322, /**<  Failed to close the directory. */ 
+  A2_E_REMOVE_FILE = 5323, /**<  Failed to remove a file from the filesystem. */ 
+  A2_E_RENAME_FILE = 5324, /**<  Failed to rename a file in the filesystem. */ 
+  A2_E_CREATE_DIR = 5325, /**<  Failed to create a new directory in the filesystem. */ 
+  A2_E_REMOVE_DIRECTORY = 5326, /**<  Failed to remove a directory from the file system. */ 
+  A2_E_WRITE_FILE = 5327, /**<  Failed to write a file to the file system. */ 
+  A2_E_INVALID_SFA_STATE = 5328, /**<  The state of the SFA programming is incorrect. */ 
+  A2_E_READ_FILE = 5329, /**<  Failed to read a file from the file system. */ 
+  A2_E_CORE_SUPERV = 61797, /**<   */ 
+  A2_E_MEM_ALLOC = 66166, /**<   */ 
+  A2_E_GDFS_UNSUPPORTED_PROPERTY = 5401, /**<  Unsupported GDFS property. */ 
+  A2_E_GDFS_READ_ONLY = 5402, /**<  The GDFS property is read only. */ 
+  A2_E_GDFS_PROPERTY_VALUE_INVALID = 5403, /**<  The property value is invalid. */ 
+  A2_E_GDFS_INVALID_START_PROPERTY = 5404, /**<  Invalid start property. */ 
+  A2_E_GDFS_NOT_STARTED = 5405, /**<  GDFS has not been started yet. */ 
+  A2_E_GDFS_FAILED_TO_FORMAT = 5406, /**<  Failed to format the GDFS area. */ 
+  A2_E_GDFS_NOT_FORMATTED = 5407, /**<  GDFS is not formatted, as it should be. */ 
+  A2_E_GDFS_INVALID_BLOCK_UNIT_SPECIFIED = 5408, /**<  Invalid Block unit number. */ 
+  A2_E_GDFS_NO_CONFIGURATION_FOUND = 5409, /**<  Could not find any GDFS configuration from the platform software in flash. */ 
+  A2_E_GDFS_CLOSE = 5410, /**<  Failed to close the GDFS area. */ 
+  A2_E_GDFS_OPEN = 5411, /**<  Failed to open the GDFS area. */ 
+  A2_E_GDFS_INVALID_UNIT_SIZE = 5412, /**<  Invalid GDFS UNIT size(size=0). */ 
+  A2_E_GDFS_WRITE_TO_UNIT_FAILED = 5413, /**<  Failed to write to the specified unit. */ 
+  A2_E_GDFS_FAILED_TO_READ_FROM_UNIT = 5414, /**<  Failed to read from the specified unit. */ 
+  A2_E_GDFS_EMPTY = 5415, /**<  Failed read access on an empty GDFS. */ 
+  A2_E_GENERAL_FATAL_ERROR = 70535, /**<   */ 
+  E_DUMMY_CODE = 80009  /**<  */ 
+} ErrorCode_e;
+
+#endif /* _ERRORCODE_H */
