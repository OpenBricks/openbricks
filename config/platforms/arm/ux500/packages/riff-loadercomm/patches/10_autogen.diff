diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_command_ids.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_command_ids.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_command_ids.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_command_ids.h	2012-05-29 21:37:35.087187513 +0300
@@ -0,0 +1,33 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _A2_COMMAND_IDS_H
+#define _A2_COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+typedef enum {
+  GROUP_A2_SYSTEM = 1, /**< A2 System group */
+  GROUP_A2_FLASH = 2, /**< A2 Flash group */
+  GROUP_A2_CONTROL = 16, /**< Control message */
+} A2_GroupId_e;
+
+typedef enum {
+  COMMAND_A2_SYSTEM_SHUTDOWN = 1, /**< Shutdown */
+  COMMAND_A2_SYSTEM_LOADERVERSION = 2, /**< Loader Version */
+  COMMAND_A2_SYSTEM_LOADERONLOADER = 17, /**< Loader on Loader */
+  COMMAND_A2_SYSTEM_RESET = 19, /**< Reset */
+  COMMAND_A2_FLASH_VERIFYSIGNEDHEADER = 1, /**< Verify Signed Header */
+  COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS = 2, /**< Software Block Address */
+  COMMAND_A2_FLASH_PROGRAMFLASH = 3, /**< Program Flash */
+  COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH = 4, /**< Verify Software Flash */
+  COMMAND_A2_FLASH_ERASEFLASH = 7, /**< Erase Flash */
+  COMMAND_A2_FLASH_SPEEDFLASH = 10, /**< Speedflash */
+  COMMAND_A2_CONTROL_LOADERSTARTED = 1, /**< Loader Started */
+  COMMAND_A2_CONTROL_PING = 2, /**< Ping */
+  COMMAND_A2_CONTROL_PONG = 3, /**< Pong */
+  COMMAND_A2_CONTROL_MAXPACKETSIZE = 4, /**< Max Packet Size */
+  COMMAND_A2_CONTROL_LOADERNOTSTARTED = 5, /**< Loader Not Started */
+} A2_CommandId_e;
+
+
+#endif /* _A2_COMMAND_IDS_H */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_commands.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_commands.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_commands.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_commands.h	2012-05-29 21:37:35.439189264 +0300
@@ -0,0 +1,215 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _A2_COMMANDS_H_
+#define _A2_COMMANDS_H_
+
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "t_basicdefinitions.h"
+#include "CmdResult.h"
+//#include "error_codes.h"
+//#include "t_a2_protocol.h"
+//#include "a2_command_ids.h"
+
+class CLCDriverMethods;
+
+class A2LoaderRpcInterface
+{
+public:
+  A2LoaderRpcInterface(CLCDriverMethods* lcdMethods, CmdResult* cmdResult, LcmInterface* lcmInterface):
+    lcdMethods_(lcdMethods),
+    cmdResult_(cmdResult),
+    lcmInterface_(lcmInterface),
+    targetCpu_(0),
+    morePackets_(0)
+  {
+  }
+
+  virtual ~A2LoaderRpcInterface()
+  {
+  }
+
+  /*
+   * A2 System commands group (0x01)
+   */
+
+  /**
+   * The Loader shuts down in a controlled fashion and proceeds to shut down the ME itself.
+   * \see DoneRPC_A2_System_ShutdownImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_Shutdown(uint16 SessionOut);
+  
+  /**
+   * The Loader Version command is sent by the PC to request version information from the loader. The ME responds with a Loader Version information coded as ASCII characters in the data field.
+   * \see DoneRPC_A2_System_LoaderVersionImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_LoaderVersion(uint16 SessionOut);
+  
+  /**
+   * This command is used to transfer a new Loader to the ME. The data should hold either Header or Payload.
+   * \see DoneRPC_A2_System_LoaderOnLoaderImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] PayloadSize Application packet length
+   * @param [in] Payload 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_LoaderOnLoader(uint16 SessionOut, const uint32 PayloadSize, const void *Payload);
+  
+  /**
+   * The Reset command is used to instruct the Loader to reset the ME. Upon receiving this command, the Loader shuts down in a controlled fashion and restarts the ME.
+   * \see DoneRPC_A2_System_ResetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Timeout Timeout in ms.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_System_Reset(uint16 SessionOut, const uint32 Timeout);
+  
+  /*
+   * A2 Flash Commands group (0x02)
+   */
+
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_VerifySignedHeaderImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] PayloadSize Application packet length
+   * @param [in] VerifyHeaderIn 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_VerifySignedHeader(uint16 SessionOut, const uint32 PayloadSize, const void *VerifyHeaderIn);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_SoftwareBlockAddressImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] StartAddress Start address of the block.
+   * @param [in] BlockSize Size of the block.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_SoftwareBlockAddress(uint16 SessionOut, const uint32 StartAddress, const uint32 BlockSize);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_ProgramFlashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] PayloadSize Application packet length
+   * @param [in] Payload 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_ProgramFlash(uint16 SessionOut, const uint32 PayloadSize, const void *Payload);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Flash_VerifySoftwareFlashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_VerifySoftwareFlash(uint16 SessionOut);
+  
+  /**
+   * The Erase flash command is used to erase the complete flash memory.
+   * \see DoneRPC_A2_Flash_EraseFlashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_EraseFlash(uint16 SessionOut);
+  
+  /**
+   * The Dump physical flash image command is used to read data from a physical flash location (physical addresses) and send it to the PC.
+   * \see DoneRPC_A2_Flash_SpeedflashImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] StartAddress Start address of the block to be flashed
+   * @param [in] EndAddress End address of the block to be flashed
+   * @param [in] SubBlockSize Size of the single block to be transfered
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Flash_Speedflash(uint16 SessionOut, const uint32 StartAddress, const uint32 EndAddress, const uint32 SubBlockSize);
+  
+  /*
+   * A2 Control message (0x10)
+   */
+
+  /**
+   * Response to \see DoRPC_A2_Control_LoaderStartedImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_LoaderStarted(uint16 Session);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_PingImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_Ping(uint16 SessionOut);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_PongImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_Pong(uint16 Session);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_MaxPacketSizeImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_MaxPacketSize(uint16 SessionOut);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_LoaderNotStartedImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_LoaderNotStarted(uint16 Session);
+  
+public:
+  void setTargetCpu(uint8 targetCpu) { targetCpu_ = targetCpu; }
+  void setMorePackets(uint8 morePackets) { morePackets_ = morePackets; }
+protected:
+  CLCDriverMethods* lcdMethods_;
+  CmdResult* cmdResult_;
+  LcmInterface* lcmInterface_;
+  uint8 targetCpu_;
+  uint8 morePackets_;
+};
+
+#endif /* _A2_COMMANDS_H_ */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_commands_impl.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_commands_impl.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_commands_impl.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_commands_impl.h	2012-05-29 21:37:35.811191108 +0300
@@ -0,0 +1,197 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _A2_COMMANDS_IMPL_H_
+#define _A2_COMMANDS_IMPL_H_
+
+#include "a2_commands.h"
+#include "a2_command_ids.h"
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "error_codes.h"
+
+class CLCDriverMethods;
+
+class A2LoaderRpcInterfaceImpl : public A2LoaderRpcInterface 
+{
+public:
+	A2LoaderRpcInterfaceImpl(CLCDriverMethods* lcdMethods, CmdResult* cmdResult, LcmInterface* lcmInterface):
+    A2LoaderRpcInterface(lcdMethods, cmdResult, lcmInterface)
+  {
+  }
+
+	~A2LoaderRpcInterfaceImpl()
+  {
+  }
+
+	ErrorCode_e	Do_CEH_Callback(CommandData_t* pCmdData);
+
+  /*
+   * A2 System commands group (0x01)
+   */
+
+  /**
+   * Response to \see DoRPC_A2_System_Shutdown
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_ShutdownImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_System_LoaderVersion
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] LoaderVersionOut Loader version identifier
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_LoaderVersionImpl(uint16 Session, ErrorCode_e Status, int LoaderVersionOutPLSize, const void *LoaderVersionOut);
+  
+  /**
+   * Response to \see DoRPC_A2_System_LoaderOnLoader
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_LoaderOnLoaderImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_System_Reset
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_System_ResetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * A2 Flash Commands group (0x02)
+   */
+
+  /**
+   * Response to \see DoRPC_A2_Flash_VerifySignedHeader
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_VerifySignedHeaderImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_SoftwareBlockAddress
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_SoftwareBlockAddressImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_ProgramFlash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_ProgramFlashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_VerifySoftwareFlash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_VerifySoftwareFlashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_EraseFlash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_EraseFlashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_A2_Flash_Speedflash
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Flash_SpeedflashImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * A2 Control message (0x10)
+   */
+
+  /**
+   * 
+   * \see DoneRPC_A2_Control_LoaderStarted
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] MaxLoaderPacketSize 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_LoaderStartedImpl(uint16 Session, const uint32 MaxLoaderPacketSize);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_Ping
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_PingImpl(uint16 Session);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_Pong
+   * Call source: ME
+   * @param [in] Session Input session.
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_PongImpl(uint16 Session);
+  
+  /**
+   * Response to \see DoRPC_A2_Control_MaxPacketSize
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] MaxPacketSize 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_A2_Control_MaxPacketSizeImpl(uint16 Session, const uint16 MaxPacketSize);
+  
+  /**
+   * 
+   * \see DoneRPC_A2_Control_LoaderNotStarted
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] ErrorCode 
+   *
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_A2_Control_LoaderNotStartedImpl(uint16 Session, const uint16 ErrorCode);
+  
+};
+
+#endif /* _A2_COMMANDS_IMPL_H_ */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_commands_marshal.cpp riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_commands_marshal.cpp
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/a2_commands_marshal.cpp	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/a2_commands_marshal.cpp	2012-05-29 21:37:36.203193046 +0300
@@ -0,0 +1,656 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "Serialization.h"
+#include "a2_commands_impl.h"
+#include "t_a2_protocol.h"
+//#include "a2_custom_commands.h" //when customer commands will be implemented
+#include "LCDriverMethods.h"
+
+#define A2_COMMAND(response, group, id) ((((int)(response)) << 30) | (((int)(group)) << 16) | ((int)(id))) 
+#define A2_COMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(A2_CommandData_t)); \
+  CmdData.Type             = TypeP; \
+  CmdData.ApplicationNr    = ApplicationP; \
+  CmdData.CommandNr        = CommandP; \
+  CmdData.SessionNr        = SessionP; \
+  CmdData.Payload.Size     = SizeP; \
+  CmdData.Payload.Data_p   = NULL; \
+  if(SizeP != 0)\
+  { \
+    CmdData.Payload.Data_p = (uint8*)malloc(sizeof(ErrorCode_e) + SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    }\
+  }
+
+#define A2_COMMANDDATAOUT(TypeP,ApplicationP,CommandP,SessionP,SizeP,TargetCPU) \
+  memset((uint8*)&CmdData, 0x00, sizeof(A2_CommandData_t)); \
+  CmdData.Type                    = TypeP; \
+  CmdData.ApplicationNr           = ApplicationP; \
+  CmdData.CommandNr               = CommandP; \
+  CmdData.SessionNr               = SessionP; \
+  CmdData.Payload.Size            = SizeP; \
+  CmdData.Payload.Data_p          = NULL; \
+  CmdData.DestAddress             = TargetCPU; \
+  if(SizeP != 0) \
+  { \
+    CmdData.Payload.Data_p = (uint8*)malloc(SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    } \
+  }
+
+ErrorCode_e A2LoaderRpcInterfaceImpl::Do_CEH_Callback(CommandData_t* pCmdData)
+{
+  A2_CommandData_t* CmdData_p = (A2_CommandData_t*)pCmdData;
+  ErrorCode_e ReturnValue = E_GENERAL_FATAL_ERROR;
+  ErrorCode_e ResponseStatus = E_GENERAL_FATAL_ERROR;
+  boolean response = FALSE;
+  const void *Data_p = CmdData_p->Payload.Data_p;
+  uint32 PayloadSize = CmdData_p->Payload.Size;
+  uint16 Session = CmdData_p->SessionNr;
+
+  if (A2_GENERAL_RESPONSE == CmdData_p->Type)
+  {
+    // skip fields already handled by LCM: command group, 0xFF, more packets and original command
+    Data_p = ((uint8*)Data_p) + 4;
+    PayloadSize -= 4;
+    response = TRUE;
+  }
+  else if (A2_COMMAND == CmdData_p->Type)
+  {
+    // skip fields already handled by LCM: command group, command and more packets fields
+    Data_p = ((uint8*)Data_p) + 3;
+    PayloadSize -= 3;
+    response = FALSE;
+  }
+  else if (A2_CONTROL_MESSAGE == CmdData_p->Type)
+  {
+    // skip control message ID
+    Data_p = ((uint8*)Data_p) + 1;
+    PayloadSize -= 1;
+    response = FALSE;
+  }
+  else if (A2_SPEEDFLASH_GR == CmdData_p->Type)
+  {
+    uint16 Status = Serialization::get_uint16_le(&Data_p);
+    lcdMethods_->AddEvent(new Event(EVENT_SPEEDFLASH, Status));
+    return E_SUCCESS;
+  }
+  else
+  {
+    return E_GENERAL_FATAL_ERROR;
+  }
+
+  switch(A2_COMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+  {
+
+  /*
+   * A2 System commands group (0x01)
+   */
+
+    /* Response to A2 System group / Shutdown (1 / 1) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_SHUTDOWN):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_System_ShutdownImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 System group / Loader Version (1 / 2) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERVERSION):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+      const void *LoaderVersionOut = NULL;
+      uint32 LoaderVersionOutPLSize = PayloadSize;
+      if (E_SUCCESS == ResponseStatus)
+      {
+        LoaderVersionOut = Data_p;
+        Serialization::skip_block(&Data_p, LoaderVersionOutPLSize);
+      }
+      ReturnValue = DoneRPC_A2_System_LoaderVersionImpl(Session, ResponseStatus, LoaderVersionOutPLSize, LoaderVersionOut);
+    }
+    break;
+  
+    /* Response to A2 System group / Loader on Loader (1 / 17) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERONLOADER):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_System_LoaderOnLoaderImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 System group / Reset (1 / 19) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_RESET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_System_ResetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * A2 Flash Commands group (0x02)
+   */
+
+    /* Response to A2 Flash group / Verify Signed Header (2 / 1) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSIGNEDHEADER):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_VerifySignedHeaderImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Software Block Address (2 / 2) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_SoftwareBlockAddressImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Program Flash (2 / 3) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_PROGRAMFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_ProgramFlashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Verify Software Flash (2 / 4) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_VerifySoftwareFlashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Erase Flash (2 / 7) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_ERASEFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_EraseFlashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to A2 Flash group / Speedflash (2 / 10) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_FLASH, COMMAND_A2_FLASH_SPEEDFLASH):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint16_le(&Data_p);
+      PayloadSize -= 2;
+
+      ReturnValue = DoneRPC_A2_Flash_SpeedflashImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * A2 Control message (0x10)
+   */
+
+    /* Command Control message / Loader Started (16 / 1) */ 
+    case A2_COMMAND(FALSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERSTARTED):
+    {
+      uint32 MaxLoaderPacketSize = 0;
+      if (0 != PayloadSize)
+      {
+        MaxLoaderPacketSize = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoRPC_A2_Control_LoaderStartedImpl(Session, MaxLoaderPacketSize);
+    }
+    break;
+  
+    /* Response to Control message / Ping (16 / 2) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PING):
+    {
+
+
+      ReturnValue = DoneRPC_A2_Control_PingImpl(Session);
+    }
+    break;
+  
+    /* Command Control message / Pong (16 / 3) */ 
+    case A2_COMMAND(FALSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PONG):
+    {
+      ReturnValue = DoRPC_A2_Control_PongImpl(Session);
+    }
+    break;
+  
+    /* Response to Control message / Max Packet Size (16 / 4) */ 
+    case A2_COMMAND(TRUE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_MAXPACKETSIZE):
+    {
+
+      uint16 MaxPacketSize = 0;
+
+      {
+        MaxPacketSize = Serialization::get_uint16_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_A2_Control_MaxPacketSizeImpl(Session, MaxPacketSize);
+    }
+    break;
+  
+    /* Command Control message / Loader Not Started (16 / 5) */ 
+    case A2_COMMAND(FALSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERNOTSTARTED):
+    {
+      uint16 ErrorCode = 0;
+      if (0 != PayloadSize)
+      {
+        ErrorCode = Serialization::get_uint16_le(&Data_p);
+      }
+      ReturnValue = DoRPC_A2_Control_LoaderNotStartedImpl(Session, ErrorCode);
+    }
+    break;
+  
+  default:
+    {
+      return E_COMMAND_NO_ERROR; // Do_CustomCEH_Call(CmdData_p); // when customer commands will be implemented
+    }
+  }
+
+  if (response)
+  {
+    lcdMethods_->AddEvent(new Event(EVENT_GR_RECEIVED, ResponseStatus, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+  }
+  else
+  {
+    lcdMethods_->AddEvent(new Event(EVENT_CMD_RECEIVED, 0, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+  }
+
+  return ReturnValue;
+}
+
+/*
+ * A2 System commands group (0x01)
+ */
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_Shutdown(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_SHUTDOWN, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_SHUTDOWN);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_LoaderVersion(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERVERSION, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_LOADERVERSION);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_LoaderOnLoader(uint16 SessionOut, const uint32 PayloadSize, const void *Payload)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += PayloadSize;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_LOADERONLOADER, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_LOADERONLOADER);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_block(&Data_p, Payload, PayloadSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_System_Reset(uint16 SessionOut, const uint32 Timeout)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += sizeof(uint32);
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_SYSTEM, COMMAND_A2_SYSTEM_RESET, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_SYSTEM);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_SYSTEM_RESET);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_uint32_le(&Data_p, Timeout);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+/*
+ * A2 Flash Commands group (0x02)
+ */
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_VerifySignedHeader(uint16 SessionOut, const uint32 PayloadSize, const void *VerifyHeaderIn)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += PayloadSize;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSIGNEDHEADER, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_VERIFYSIGNEDHEADER);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_block(&Data_p, VerifyHeaderIn, PayloadSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_SoftwareBlockAddress(uint16 SessionOut, const uint32 StartAddress, const uint32 BlockSize)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_SOFTWAREBLOCKADDRESS);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_uint32_le(&Data_p, StartAddress);
+  Serialization::put_uint32_le(&Data_p, BlockSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_ProgramFlash(uint16 SessionOut, const uint32 PayloadSize, const void *Payload)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += PayloadSize;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_PROGRAMFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_PROGRAMFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_block(&Data_p, Payload, PayloadSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_VerifySoftwareFlash(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_VERIFYSOFTWAREFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_EraseFlash(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_ERASEFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_ERASEFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Flash_Speedflash(uint16 SessionOut, const uint32 StartAddress, const uint32 EndAddress, const uint32 SubBlockSize)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_FLASH, COMMAND_A2_FLASH_SPEEDFLASH, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_FLASH);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_FLASH_SPEEDFLASH);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+  Serialization::put_uint32_le(&Data_p, StartAddress);
+  Serialization::put_uint32_le(&Data_p, EndAddress);
+  Serialization::put_uint32_le(&Data_p, SubBlockSize);
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+/*
+ * A2 Control message (0x10)
+ */
+
+ErrorCode_e A2LoaderRpcInterface::DoneRPC_A2_Control_LoaderStarted(uint16 Session)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  A2_COMMANDDATA(A2_GENERAL_RESPONSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERSTARTED, Session, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Control_Ping(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PING, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_CONTROL);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_CONTROL_PING);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoneRPC_A2_Control_Pong(uint16 Session)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  A2_COMMANDDATA(A2_GENERAL_RESPONSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_PONG, Session, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoRPC_A2_Control_MaxPacketSize(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 3;
+
+  A2_COMMANDDATAOUT(A2_COMMAND, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_MAXPACKETSIZE, SessionOut, PLSize, targetCpu_);
+  Data_p = CmdData.Payload.Data_p;
+
+  // set command group and command
+  Serialization::put_uint8(&Data_p, GROUP_A2_CONTROL);
+  Serialization::put_uint8(&Data_p, COMMAND_A2_CONTROL_MAXPACKETSIZE);
+  // set more packets
+  Serialization::put_uint8(&Data_p, morePackets_);
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
+
+ErrorCode_e A2LoaderRpcInterface::DoneRPC_A2_Control_LoaderNotStarted(uint16 Session)
+{
+  ErrorCode_e Answer;
+  A2_CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  A2_COMMANDDATA(A2_GENERAL_RESPONSE, GROUP_A2_CONTROL, COMMAND_A2_CONTROL_LOADERNOTSTARTED, Session, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+
+  Answer = lcmInterface_->A2CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;
+}
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/command_ids.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/command_ids.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/command_ids.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/command_ids.h	2012-05-29 21:37:33.215178227 +0300
@@ -0,0 +1,97 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMAND_IDS_H
+#define _COMMAND_IDS_H
+#include "t_basicdefinitions.h"
+
+typedef enum {
+  GROUP_SYSTEM = 1, /**< System application */
+  GROUP_FLASH = 2, /**< Flash application */
+  GROUP_FILE_SYSTEM_OPERATIONS = 3, /**< File system operations */
+  GROUP_OTP = 4, /**< OTP */
+  GROUP_PARAMETERSTORAGE = 5, /**< Parameter Storage */
+  GROUP_SECURITY = 6, /**< Security */
+} GroupId_e;
+
+typedef enum {
+  COMMAND_SYSTEM_LOADERSTARTUPSTATUS = 1, /**< Loader Start-up Status */
+  COMMAND_SYSTEM_CHANGEBAUDRATE = 2, /**< Change Uart Baud Rate */
+  COMMAND_SYSTEM_REBOOT = 3, /**< System Reboot */
+  COMMAND_SYSTEM_SHUTDOWN = 4, /**< System Shutdown */
+  COMMAND_SYSTEM_SUPPORTEDCOMMANDS = 5, /**< System Supported Command */
+  COMMAND_SYSTEM_EXECUTESOFTWARE = 6, /**< System Execute Software */
+  COMMAND_SYSTEM_AUTHENTICATE = 7, /**< System Authenticate */
+  COMMAND_SYSTEM_GETCONTROLKEYS = 8, /**< System Get Control Keys */
+  COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE = 9, /**< System Authentication Challenge */
+  COMMAND_SYSTEM_COLLECTDATA = 10, /**< System Collect Data */
+  COMMAND_SYSTEM_GETPROGRESSSTATUS = 11, /**< System Get Progress Status */
+  COMMAND_SYSTEM_SETSYSTEMTIME = 12, /**< Set System Time */
+  COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE = 13, /**< Switch Communication Device */
+  COMMAND_SYSTEM_GETCONTROLKEYSDATA = 14, /**< System Get Control Keys Data */
+  COMMAND_SYSTEM_STARTCOMMRELAY = 15, /**< System Start Communication Relay */
+  COMMAND_SYSTEM_DEAUTHENTICATE = 16, /**< System Deauthenticate */
+  COMMAND_FLASH_PROCESSFILE = 1, /**< Process File */
+  COMMAND_FLASH_LISTDEVICES = 2, /**< List Devices */
+  COMMAND_FLASH_DUMPAREA = 3, /**< Dump Area */
+  COMMAND_FLASH_ERASEAREA = 4, /**< Erase Area */
+  COMMAND_FLASH_FLASHRAW = 5, /**< Flash RAW */
+  COMMAND_FLASH_SETENHANCEDAREA = 6, /**< Set Enhanced Area */
+  COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES = 2, /**< Volume Properties */
+  COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME = 3, /**< Format Volume */
+  COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY = 4, /**< List Directory */
+  COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE = 5, /**< Move File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE = 6, /**< Delete File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE = 7, /**< Copy File */
+  COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY = 8, /**< Create Directory */
+  COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES = 9, /**< Properties (Stat) */
+  COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS = 10, /**< Change Access (Chmod) */
+  COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS = 11, /**< Read Load Modules Manifests */
+  COMMAND_OTP_READBITS = 1, /**< Read Bits */
+  COMMAND_OTP_SETBITS = 2, /**< Set Bits */
+  COMMAND_OTP_WRITEANDLOCK = 3, /**< Write and Lock OTP */
+  COMMAND_OTP_STORESECUREOBJECT = 4, /**< Store Secure Object */
+  COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT = 1, /**< Read Global Data Unit */
+  COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT = 2, /**< Write Global Data Unit */
+  COMMAND_PARAMETERSTORAGE_READGLOBALDATASET = 3, /**< Read Global Data Set */
+  COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET = 4, /**< Write Global Data Set */
+  COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET = 5, /**< Erase Global Data Set */
+  COMMAND_SECURITY_SETDOMAIN = 1, /**< Set Domain */
+  COMMAND_SECURITY_GETDOMAIN = 2, /**< Get Domain */
+  COMMAND_SECURITY_GETPROPERTIES = 3, /**< Get Properties */
+  COMMAND_SECURITY_SETPROPERTIES = 4, /**< Set Properties */
+  COMMAND_SECURITY_BINDPROPERTIES = 5, /**< Bind Properties */
+  COMMAND_SECURITY_INITARBTABLE = 6, /**< Init ARBTable */
+} CommandId_e;
+
+typedef struct SupportedCommand_s
+{
+  uint32 Group; /**< Application Group number */
+  uint32 Command; /**< Command number */
+  uint32 Permitted; /**< Permission value */
+}SupportedCommand_t;
+
+typedef struct ListDevice_s
+{
+  char Path_p[256]; /**< Absolute device path pointing of the described device */
+  char Type_p[256]; /**< Type of the device */
+  uint64 BlockSize; /**< Size of the smallest addressable unit in the device in bytes */
+  uint64 Start; /**< Offset in bytes of the start of the device relative to its parents offset 0 with a granularity of its parents block size */
+  uint64 Length; /**< Length of the device in bytes */
+}ListDevice_t;
+
+typedef struct DirEntry_s
+{
+  char *Name_p; /**< Name of file or directory */
+  uint64 Size; /**< Size of file or directory */
+  uint32 Mode; /**< Indicator if it is file or directory */
+  uint32 Time; /**< Time of last modification */
+}DirEntry_t;
+
+typedef struct Cipher_s
+{
+  char *Name_p; /**< supported ciphers */
+}Cipher_t;
+
+
+#endif /* _COMMAND_IDS_H */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/commands.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/commands.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/commands.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/commands.h	2012-05-29 21:37:33.603180154 +0300
@@ -0,0 +1,636 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_H_
+#define _COMMANDS_H_
+
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "t_basicdefinitions.h"
+#include "CmdResult.h"
+
+class CLCDriverMethods;
+
+class LoaderRpcInterface
+{
+public:
+  LoaderRpcInterface(CLCDriverMethods* lcdMethods, CmdResult* cmdResult, LcmInterface* lcmInterface):
+    cmdResult_(cmdResult),
+    lcmInterface_(lcmInterface),
+    lcdMethods_(lcdMethods)
+  {
+  }
+
+  virtual ~LoaderRpcInterface()
+  {
+  }
+
+  /*
+   * System commands group (0x01)
+   */
+
+  /**
+   * Response to \see DoRPC_System_LoaderStartUpStatusImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_LoaderStartUpStatus(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * This command is used to change the loader UART baudrate.
+   * \see DoneRPC_System_ChangeBaudRateImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] BaudRate Baud rate.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_ChangeBaudRate(uint16 SessionOut, const uint32 BaudRate);
+  
+  /**
+   * The Reboot command is used to instruct the Loader to reset the ME. Upon receiving this command, the Loader shuts down in a controlled fashion and restarts the ME. The Mode parameter is used to select the mode of reset.
+   * \see DoneRPC_System_RebootImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Mode 0 = normal restart, 1 = restart in service mode, 2 = restart with JTAG debugging enabled, 3 = restart in service mode and with JTAG debugging enabled
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_Reboot(uint16 SessionOut, const uint32 Mode);
+  
+  /**
+   * The Loader shuts down in a controlled fashion and proceeds to shut down the ME itself.
+   * \see DoneRPC_System_ShutDownImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_ShutDown(uint16 SessionOut);
+  
+  /**
+   * The Loader returns a list of implemented commands and whether they are permitted to execute in the current Loader state. Further fine-grained permission controls might also deny execution of a specific command.
+   * \see DoneRPC_System_SupportedCommandsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_SupportedCommands(uint16 SessionOut);
+  
+  /**
+   * Receive, verify and execute software, which can be a signed Loader. After having sent this command, the ME will attempt to read the software payload data from the host using the Bulk protocol or from the flash file system depending on the selected path.
+   * \see DoneRPC_System_ExecuteSoftwareImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] ExecuteMode Execute mode: 1 = execution from specified address, 2 = first load the software then execute.
+   * @param [in] SourcePath_p File system or Bulk id path
+   * @param [in] Length Total length of the execute software file
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_ExecuteSoftware(uint16 SessionOut, const uint32 ExecuteMode, const char *SourcePath_p, const uint64 Length);
+  
+  /**
+   * This command is used to escalate the privileges of the operator. Two modes of authentication are available by default; Control Key authentication and Certificate based authentication. The authentication command sets the loader in a specific authentication context when it takes control over the command flow. After receiving the authentication command, the Loader will send the appropriate request for information to the PC.
+   * \see DoneRPC_System_AuthenticateImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Type Authentication type: 0 = Control Key authentication, 1 = Certificate authentication.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_Authenticate(uint16 SessionOut, const uint32 Type);
+  
+  /**
+   * Response to \see DoRPC_System_GetControlKeysImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] NLCKLock_p 
+   * @param [in] NSLCKLock_p 
+   * @param [in] SPLCKLock_p 
+   * @param [in] CLCKLock_p 
+   * @param [in] PCKLock_p 
+   * @param [in] ESLCKLock_p 
+   * @param [in] NLCKUnlock_p 
+   * @param [in] NSLCKUnlock_p 
+   * @param [in] SPLCKUnlock_p 
+   * @param [in] CLCKUnlock_p 
+   * @param [in] PCKUnlock_p 
+   * @param [in] ESLCKUnlock_p 
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_GetControlKeys(uint16 Session, ErrorCode_e Status, const char *NLCKLock_p, const char *NSLCKLock_p, const char *SPLCKLock_p, const char *CLCKLock_p, const char *PCKLock_p, const char *ESLCKLock_p, const char *NLCKUnlock_p, const char *NSLCKUnlock_p, const char *SPLCKUnlock_p, const char *CLCKUnlock_p, const char *PCKUnlock_p, const char *ESLCKUnlock_p);
+  
+  /**
+   * Response to \see DoRPC_System_AuthenticationChallengeImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] ResponseBlockLength Updated authentication challenge buffer length
+   * @param [in] ResponseBlock_p Signed authentication challenge together with the requested permissions.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_AuthenticationChallenge(uint16 Session, ErrorCode_e Status, const uint32 ResponseBlockLength, const void *ResponseBlock_p);
+  
+  /**
+   * This command is used to collect printouts (debug data) and measurements results.
+   * \see DoneRPC_System_CollectDataImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Type Type of requested data.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_CollectData(uint16 SessionOut, const uint32 Type);
+  
+  /**
+   * This command is used by the Loader to get the minimal progress status from all running commands.
+   * \see DoneRPC_System_GetProgressStatusImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_GetProgressStatus(uint16 SessionOut);
+  
+  /**
+   * The Set System Time command is used to instruct the Loader to use real world time and date during its run time. Upon receiving this command, the Loader sets internal Real Time Clock. This command can be issued more then once by PC tool.
+   * \see DoneRPC_System_SetSystemTimeImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] EpochTime Number of seconds since January 1, 1970 (midnight UTC/GMT).
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_SetSystemTime(uint16 SessionOut, const uint32 EpochTime);
+  
+  /**
+   * This command is used to instruct the Loader to switch to a new communication device.
+   * \see DoneRPC_System_SwitchCommunicationDeviceImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Device Communication device number to switch to.
+   * @param [in] DeviceParam Communication device parameters.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_SwitchCommunicationDevice(uint16 SessionOut, const uint32 Device, const uint32 DeviceParam);
+  
+  /**
+   * Response to \see DoRPC_System_GetControlKeysDataImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] iDataSize Length of output buffer.
+   * @param [in] SIMLockKeysData_p Data buffer with all SIMLock keys.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_GetControlKeysData(uint16 Session, ErrorCode_e Status, const uint32 iDataSize, const void *SIMLockKeysData_p);
+  
+  /**
+   * The Loader shuts down the global communication and enters in a Relay working mode.
+   * \see DoneRPC_System_StartCommRelayImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] HostDeviceId Communication device number of the relay input (host device).
+   * @param [in] TargetDeviceId Communication device number of the relay ouptut (target device).
+   * @param [in] ControlDeviceId Communication device number for the loader commands (control device).
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_StartCommRelay(uint16 SessionOut, const uint32 HostDeviceId, const uint32 TargetDeviceId, const uint32 ControlDeviceId);
+  
+  /**
+   * This command is used by the Loader to deauthenticates the ME from prior authentications to prevent unauthorized access.
+   * \see DoneRPC_System_DeauthenticateImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Type Deauthentication type: 1 = permanent deauthentication, 0 = deauthenticate until next reboot of the ME.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_Deauthenticate(uint16 SessionOut, const uint32 Type);
+  
+  /*
+   * Flash Commands group (0x02)
+   */
+
+  /**
+   * This command is used to initiate a flashing session. The Type argument is used to select the type of file to process and Length parameter defines the total size of the file.
+   * \see DoneRPC_Flash_ProcessFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Length Total length of the opened file
+   * @param [in] Type_p Type of the opened file. Currently the only supported type is    x-empflash/flasharchive   
+   * @param [in] SourcePath_p File system or Bulk id path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_ProcessFile(uint16 SessionOut, const uint64 Length, const char *Type_p, const char *SourcePath_p);
+  
+  /**
+   * The Loader returns a list of detected block devices. A block device can be a physical device ( flash0 , mmc0 , usb0 ), a logical device ( cabs0 , mbbs0 ) or a file system volume ( boot , sys ). Together they form paths on the form /flash0/mbbs0 or /flash1/cabs1/vfat .
+   * \see DoneRPC_Flash_ListDevicesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_ListDevices(uint16 SessionOut);
+  
+  /**
+   * This command is used to initiate a Dump session.
+   * \see DoneRPC_Flash_DumpAreaImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p Path to the device to dump.
+   * @param [in] Start Start of the dump relative to the start of the device indicated by Path in bytes. Actual start is determined by the Mode parameter.
+   * @param [in] Length Length of the dump in bytes. Actual length is determined by the Mode parameter.
+   * @param [in] TargetPath_p File system or bulk id path.
+   * @param [in] RedundantArea If set to 0 dump flash including redundant area, if set to 1 dump flash without redundant area.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_DumpArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length, const char *TargetPath_p, const uint32 RedundantArea);
+  
+  /**
+   * This command is used to erase a flash device or part of a flash device.
+   * \see DoneRPC_Flash_EraseAreaImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p Path to the device to erase.
+   * @param [in] Start Start of the dump relative to the start of the device indicated by Path in bytes. This must be a multiple of the block size of the device.
+   * @param [in] Length Length of the dump in bytes. This must be a multiple of the block size of the device.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_EraseArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length);
+  
+  /**
+   * This command is used to flash raw flash image.
+   * \see DoneRPC_Flash_FlashRawImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Start Address where RAW image should be written. This must be a multiple of the block size of the device.
+   * @param [in] Length Length of RAW data in bytes
+   * @param [in] Device Target flash device.[0,1]
+   * @param [in] SourcePath_p Bulk id path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_FlashRaw(uint16 SessionOut, const uint64 Start, const uint64 Length, const uint32 Device, const char *SourcePath_p);
+  
+  /**
+   * This command is used to set enhanced area on eMC card.
+   * \see DoneRPC_Flash_SetEnhancedAreaImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p Path to the device where area will be set.
+   * @param [in] Start Start address of enhanced area in bytes.
+   * @param [in] Length Length of the enhanced area in bytes.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Flash_SetEnhancedArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length);
+  
+  /*
+   * File System Commands Group (0x03)
+   */
+
+  /**
+   * Retrieve properties of the specified file system volume
+   * \see DoneRPC_File_System_Operations_VolumePropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p Path of file system volume
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_VolumeProperties(uint16 SessionOut, const char *DevicePath_p);
+  
+  /**
+   * Formats an unmounted file system volume. This operation fails if the volume is currently in use.
+   * \see DoneRPC_File_System_Operations_FormatVolumeImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p Device path of the file system volume
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_FormatVolume(uint16 SessionOut, const char *DevicePath_p);
+  
+  /**
+   * List files and directories residing in a specified path
+   * \see DoneRPC_File_System_Operations_ListDirectoryImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Path_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_ListDirectory(uint16 SessionOut, const char *Path_p);
+  
+  /**
+   * Moves or renames a file.
+   * \see DoneRPC_File_System_Operations_MoveFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] SourcePath_p File system path (source)
+   * @param [in] DestinationPath_p File system path (destination)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_MoveFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p);
+  
+  /**
+   * Deletes the specified file or directory. The Loader will only delete empty directories.
+   * \see DoneRPC_File_System_Operations_DeleteFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_DeleteFile(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Copies a file from the PC to the ME, between two directories or file systems on the ME or from the ME to the PC.
+   * \see DoneRPC_File_System_Operations_CopyFileImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] SourcePath_p File system or bulk id path (source)
+   * @param [in] DestinationPath_p File system or bulk id path (destination)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_CopyFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p);
+  
+  /**
+   * Creates a directory
+   * \see DoneRPC_File_System_Operations_CreateDirectoryImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_CreateDirectory(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_PropertiesImpl
+   * Call source: ME
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] Mode File Type and Access restrictions descriptor (see 5.1)
+   * @param [in] Size File size in bytes
+   * @param [in] MTime Last modification time stamp
+   * @param [in] ATime Last access time stamp
+   * @param [in] CTime Creation time stamp
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_Properties(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime);
+  
+  /**
+   * Retrieves the properties of a file or directory
+   * \see DoneRPC_File_System_Operations_PropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_Properties(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Changes the access permissions of a path
+   * \see DoneRPC_File_System_Operations_ChangeAccessImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * @param [in] Access New access permissions
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_ChangeAccess(uint16 SessionOut, const char *TargetPath_p, const uint32 Access);
+  
+  /**
+   * Read all manifests in elf files and send it to PC
+   * \see DoneRPC_File_System_Operations_ReadLoadModulesManifestsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_ReadLoadModulesManifests(uint16 SessionOut, const char *TargetPath_p);
+  
+  /*
+   * OTP handling commands Group (0x04)
+   */
+
+  /**
+   * Reads the specified bits from the OTP
+   * \see DoneRPC_OTP_ReadBitsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] OTP_id Indicates which OTP memory is to be read
+   * @param [in] Start Starting offset in bits
+   * @param [in] Length Length of read in bits
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_ReadBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 Length);
+  
+  /**
+   * Writes and locks the specified bits in the OTP
+   * \see DoneRPC_OTP_SetBitsImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] OTP_id Indicates which OTP memory is to be read
+   * @param [in] Start Starting offset in bits
+   * @param [in] BitsLength Length of write in bits
+   * @param [in] DataBitsLength Length of DataBits buffer
+   * @param [in] DataBits_p Left-adjusted byte buffer containing the data to be written. Only Length bits will be written.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_SetBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 BitsLength, const uint32 DataBitsLength, const void *DataBits_p);
+  
+  /**
+   * Writes and locks the specified bits in the OTP
+   * \see DoneRPC_OTP_WriteAndLockImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] OTP_id Indicates which OTP memory is to be written and locked
+   * @param [in] ForceWrite If = 0 - Write only complete lockable areas. If != 0 Write complete lockable areas even if not all bit are received in cache. 
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_WriteAndLock(uint16 SessionOut, const uint32 OTP_id, const uint32 ForceWrite);
+  
+  /**
+   * Installs Secure objects into OTP or Flash
+   * \see DoneRPC_OTP_StoreSecureObjectImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] SourcePath File system or bulk id path
+   * @param [in] SecureObjectDestination Secure Object destination address
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_OTP_StoreSecureObject(uint16 SessionOut, const char *SourcePath, const uint32 SecureObjectDestination);
+  
+  /*
+   * Parameter Storage Commands Group (0x05)
+   */
+
+  /**
+   * Reads the specified unit from Global Data area
+   * \see DoneRPC_ParameterStorage_ReadGlobalDataUnitImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to read from (gdfs, trim area)
+   * @param [in] Unit_id Unit id to read
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_ReadGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id);
+  
+  /**
+   * Writes the specified unit to Global Data area
+   * \see DoneRPC_ParameterStorage_WriteGlobalDataUnitImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to write to (gdfs, trim area)
+   * @param [in] Unit_id Unit id to write
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The data to write
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_WriteGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Reads a complete Global Data area
+   * \see DoneRPC_ParameterStorage_ReadGlobalDataSetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to read (gdfs, trim area)
+   * @param [in] TargetPath_p File system or bulk id path indicating the destination of the read operation
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_ReadGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const char *TargetPath_p);
+  
+  /**
+   * Writes a complete Global Data area
+   * \see DoneRPC_ParameterStorage_WriteGlobalDataSetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to write (gdfs, trim area)
+   * @param [in] DataLength Data Length when is used bulk transfer 
+   * @param [in] SourcePath_p File system or bulk id path indicating the source of the write operation
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_WriteGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const uint64 DataLength, const char *SourcePath_p);
+  
+  /**
+   * Erases a complete Global Data area
+   * \see DoneRPC_ParameterStorage_EraseGlobalDataSetImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] DevicePath_p GD storage area to erase (gdfs, trim area)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_ParameterStorage_EraseGlobalDataSet(uint16 SessionOut, const char *DevicePath_p);
+  
+  /*
+   * Security settings Commands Group (0x06)
+   */
+
+  /**
+   * Set the ME domain
+   * \see DoneRPC_Security_SetDomainImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Domain Target domain
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_SetDomain(uint16 SessionOut, const uint32 Domain);
+  
+  /**
+   * Get the ME domain
+   * \see DoneRPC_Security_GetDomainImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_GetDomain(uint16 SessionOut);
+  
+  /**
+   * Reads a security data unit (such as a secure static or dynamic data unit)
+   * \see DoneRPC_Security_GetPropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Unit_id Unit id to read
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_GetProperties(uint16 SessionOut, const uint32 Unit_id);
+  
+  /**
+   * Writes a security data unit (such as a secure static or dynamic data unit)
+   * \see DoneRPC_Security_SetPropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Unit_id Unit id to write
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The data to write
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_SetProperties(uint16 SessionOut, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Associates all security data units with the current ME
+   * \see DoneRPC_Security_BindPropertiesImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_BindProperties(uint16 SessionOut);
+  
+  /**
+   * Initialize a SW version table, intended for checking the ARB functionality.
+   * \see DoneRPC_Security_InitARBTableImpl
+   * Call source: PC
+   * @param [in] SessionOut Output session.
+   * @param [in] Type ARB Type to update
+   * @param [in] DataLength Length of the Data buffer
+   * @param [in] DataBuff_p The data to write
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_Security_InitARBTable(uint16 SessionOut, const uint32 Type, const uint32 DataLength, const void *DataBuff_p);
+  
+protected:
+  CmdResult* cmdResult_;
+  LcmInterface* lcmInterface_;
+  CLCDriverMethods* lcdMethods_;
+};
+
+#endif /* _COMMANDS_H_ */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/commands_impl.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/commands_impl.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/commands_impl.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/commands_impl.h	2012-05-29 21:37:33.987182057 +0300
@@ -0,0 +1,562 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _COMMANDS_IMPL_H_
+#define _COMMANDS_IMPL_H_
+
+#include "commands.h"
+#include "command_ids.h"
+#include "LCDriver.h"
+#include "LcmInterface.h"
+#include "error_codes.h"
+
+class LoaderRpcInterfaceImpl : public LoaderRpcInterface 
+{
+public:
+	LoaderRpcInterfaceImpl(CLCDriverMethods* lcdMethods, CmdResult* CmdResult, LcmInterface* LcmInterface):
+    LoaderRpcInterface(lcdMethods, CmdResult, LcmInterface) {}
+	~LoaderRpcInterfaceImpl() {}
+
+	ErrorCode_e	Do_CEH_Callback(CommandData_t * pCmdData);
+
+  /*
+   * System commands group (0x01)
+   */
+
+  /**
+   * The Loader Start-up Status command is sent by the ME to notify the host that it has started. The Status parameter indicates in what mode the Loader started.
+   * \see DoneRPC_System_LoaderStartUpStatus
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] Status 0 = started successfully, 1 = failed to start (lack of permissions), 2 = software module failed to initialize
+   * @param [in] LoaderVersion_p Loader version identifier
+   * @param [in] ProtocolVersion_p Protocol version identifier
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_LoaderStartUpStatusImpl(uint16 Session, const uint32 Status, const char *LoaderVersion_p, const char *ProtocolVersion_p);
+  
+  /**
+   * Response to \see DoRPC_System_ChangeBaudRate
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_ChangeBaudRateImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_Reboot
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_RebootImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_ShutDown
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_ShutDownImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_SupportedCommands
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] CommandCount Number of implemented commands
+   * @param [in] Commands An array of command identifiers. The Permitted field indicates whether the command can be executed at the current time (non-zero value means allowed)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_SupportedCommandsImpl(uint16 Session, ErrorCode_e Status, const uint32 CommandCount, SupportedCommand_t *Commands);
+  
+  /**
+   * Response to \see DoRPC_System_ExecuteSoftware
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_ExecuteSoftwareImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_Authenticate
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_AuthenticateImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * This command is used by the Loader to retrieve the SimLock Control Keys from the host in order to authenticate a user. The command is used in authentication context.
+   * \see DoneRPC_System_GetControlKeys
+   * Call source: ME
+   * @param [in] Session Input session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_GetControlKeysImpl(uint16 Session);
+  
+  /**
+   * This command is used by the Loader to perform a certificate authentication. The command is only used in authentication context.
+   * \see DoneRPC_System_AuthenticationChallenge
+   * Call source: ME
+   * @param [in] Session Input session.
+   * @param [in] ChallengeBlockLength Authentication Challenge buffer length
+   * @param [in] ChallengeBlock_p Authentication Challenge that must be signed using the correct certificate and returned to the Loader
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_AuthenticationChallengeImpl(uint16 Session, const uint32 ChallengeBlockLength, const void *ChallengeBlock_p);
+  
+  /**
+   * Response to \see DoRPC_System_CollectData
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DataLenght Length of output buffer.
+   * @param [in] CollectedData_p Output data buffer. Contain debug data (printouts) or measurement data.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_CollectDataImpl(uint16 Session, ErrorCode_e Status, const uint32 DataLenght, const void *CollectedData_p);
+  
+  /**
+   * Response to \see DoRPC_System_GetProgressStatus
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] ProgressStatus Command progress status presented in percent.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_GetProgressStatusImpl(uint16 Session, ErrorCode_e Status, const uint32 ProgressStatus);
+  
+  /**
+   * Response to \see DoRPC_System_SetSystemTime
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_SetSystemTimeImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_SwitchCommunicationDevice
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_SwitchCommunicationDeviceImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * This command is used by the Loader to retrieve the SimLock Control Keys data buffer from the host in order to authenticate a user. The command is used in authentication context.
+   * \see DoneRPC_System_GetControlKeysData
+   * Call source: ME
+   * @param [in] Session Input session.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_System_GetControlKeysDataImpl(uint16 Session);
+  
+  /**
+   * Response to \see DoRPC_System_StartCommRelay
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_StartCommRelayImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_System_Deauthenticate
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_System_DeauthenticateImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * Flash Commands group (0x02)
+   */
+
+  /**
+   * Response to \see DoRPC_Flash_ProcessFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_ProcessFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_ListDevices
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DeviceCount Indicates the number of returned devices
+   * @param [in] Devices Absolute device path, Type of the device, Block Size, Start address of the device, Length of the device
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_ListDevicesImpl(uint16 Session, ErrorCode_e Status, const uint32 DeviceCount, ListDevice_t *Devices);
+  
+  /**
+   * Response to \see DoRPC_Flash_DumpArea
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_DumpAreaImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_EraseArea
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_EraseAreaImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_FlashRaw
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_FlashRawImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Flash_SetEnhancedArea
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Flash_SetEnhancedAreaImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * File System Commands Group (0x03)
+   */
+
+  /**
+   * Response to \see DoRPC_File_System_Operations_VolumeProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] FS_Type_p File system type
+   * @param [in] Size Total size of the file system (in bytes)
+   * @param [in] Free Available space (in bytes)
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_VolumePropertiesImpl(uint16 Session, ErrorCode_e Status, const char *FS_Type_p, const uint64 Size, const uint64 Free);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_FormatVolume
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_FormatVolumeImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_ListDirectory
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] EntriesCount Number of directory entries
+   * @param [in] Entries Name and Size of file or directory, Mode as indicator if it is file or directory, Time of last modification
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_ListDirectoryImpl(uint16 Session, ErrorCode_e Status, const uint32 EntriesCount, DirEntry_t *Entries);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_MoveFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_MoveFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_DeleteFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_DeleteFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_CopyFile
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_CopyFileImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_CreateDirectory
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_CreateDirectoryImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_Properties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] Mode File Type and Access restrictions descriptor (see 5.1)
+   * @param [in] Size File size in bytes
+   * @param [in] MTime Last modification time stamp
+   * @param [in] ATime Last access time stamp
+   * @param [in] CTime Creation time stamp
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_PropertiesImpl(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime);
+  
+  /**
+   * Retrieves the properties of a file or directory
+   * \see DoneRPC_File_System_Operations_Properties
+   * Call source: ME
+   * @param [in] SessionOut Output session.
+   * @param [in] TargetPath_p File system path
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoRPC_File_System_Operations_PropertiesImpl(uint16 SessionOut, const char *TargetPath_p);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_ChangeAccess
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_ChangeAccessImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_File_System_Operations_ReadLoadModulesManifests
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_File_System_Operations_ReadLoadModulesManifestsImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * OTP handling commands Group (0x04)
+   */
+
+  /**
+   * Response to \see DoRPC_OTP_ReadBits
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] BitsLength Length of read bits
+   * @param [in] DataBitsLength Length of the DataBits buffer
+   * @param [in] DataBits_p A left-adjusted buffer of the read data. Padded with zeroes. Length of returned value (in bytes), equal to floor((Length + 7) / 8). 
+   * @param [in] LockStatusBitsLength Length of the LockStatus of read bits
+   * @param [in] LockStatusLength Length of the LockStatus buffer
+   * @param [in] LockStatus_p A left-adjusted buffer of the lock status of each read bit. Padded with zeroes. Length of returned value (in bytes), equal to floor((Length + 7) / 8). 
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_ReadBitsImpl(uint16 Session, ErrorCode_e Status, const uint32 BitsLength, const uint32 DataBitsLength, const void *DataBits_p, const uint32 LockStatusBitsLength, const uint32 LockStatusLength, const void *LockStatus_p);
+  
+  /**
+   * Response to \see DoRPC_OTP_SetBits
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_SetBitsImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_OTP_WriteAndLock
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_WriteAndLockImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_OTP_StoreSecureObject
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_OTP_StoreSecureObjectImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * Parameter Storage Commands Group (0x05)
+   */
+
+  /**
+   * Response to \see DoRPC_ParameterStorage_ReadGlobalDataUnit
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The read data
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_ReadGlobalDataUnitImpl(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_WriteGlobalDataUnit
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_WriteGlobalDataUnitImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_ReadGlobalDataSet
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_ReadGlobalDataSetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_WriteGlobalDataSet
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_WriteGlobalDataSetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_ParameterStorage_EraseGlobalDataSet
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_ParameterStorage_EraseGlobalDataSetImpl(uint16 Session, ErrorCode_e Status);
+  
+  /*
+   * Security settings Commands Group (0x06)
+   */
+
+  /**
+   * Response to \see DoRPC_Security_SetDomain
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_SetDomainImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Security_GetDomain
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] CurrentDomain The ME Domain
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_GetDomainImpl(uint16 Session, ErrorCode_e Status, const uint32 CurrentDomain);
+  
+  /**
+   * Response to \see DoRPC_Security_GetProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * @param [in] DataBuffLength Length of the Data buffer
+   * @param [in] DataBuff_p The unit data
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_GetPropertiesImpl(uint16 Session, ErrorCode_e Status, const uint32 DataBuffLength, const void *DataBuff_p);
+  
+  /**
+   * Response to \see DoRPC_Security_SetProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_SetPropertiesImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Security_BindProperties
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_BindPropertiesImpl(uint16 Session, ErrorCode_e Status);
+  
+  /**
+   * Response to \see DoRPC_Security_InitARBTable
+   * Call source: PC
+   * @param [in] Session Transfered input session.
+   * @param [in] Status Completion status code.
+   * 
+   * @return ErrorCode_e ...
+   */
+  ErrorCode_e DoneRPC_Security_InitARBTableImpl(uint16 Session, ErrorCode_e Status);
+  
+};
+
+#endif /* _COMMANDS_IMPL_H_ */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/commands_marshal.cpp riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/commands_marshal.cpp
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/commands_marshal.cpp	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/commands_marshal.cpp	2012-05-29 21:37:34.431184260 +0300
@@ -0,0 +1,1860 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "t_command_protocol.h"
+#include "commands.h"
+//#include "custom_commands.h" // when customer commands will be implemented
+#include "command_ids.h"
+#include "commands_impl.h"
+#include "error_codes.h"
+#include "Serialization.h"
+#include "t_r15_network_layer.h"
+#include "Event.h"
+#include "LCDriverMethods.h"
+
+#define COMMAND(response, group, id) ((((int)(response)) << 30) | (((int)(group)) << 16) | ((int)(id))) 
+#define COMMANDDATA(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t)); \
+  CmdData.Type             = TypeP; \
+  CmdData.ApplicationNr    = ApplicationP; \
+  CmdData.CommandNr        = CommandP; \
+  CmdData.SessionNr        = SessionP; \
+  CmdData.Payload.Size     = SizeP; \
+  CmdData.Payload.Data_p   = NULL; \
+  if(SizeP != 0)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc(sizeof(ErrorCode_e)+SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    }\
+  }
+
+#define COMMANDDATAOUT(TypeP,ApplicationP,CommandP,SessionP,SizeP) \
+  memset((uint8*)&CmdData, 0x00, sizeof(CommandData_t)); \
+  CmdData.Type                    = TypeP; \
+  CmdData.ApplicationNr           = ApplicationP; \
+  CmdData.CommandNr               = CommandP; \
+  CmdData.SessionNr               = SessionP; \
+  CmdData.Payload.Size            = SizeP; \
+  CmdData.Payload.Data_p          = NULL; \
+  if(SizeP != 0)\
+  {\
+    CmdData.Payload.Data_p = (uint8 *)malloc( SizeP); \
+    if(NULL == CmdData.Payload.Data_p) \
+    { \
+      return E_ALLOCATE_FAILED; \
+    }\
+  }
+
+  ErrorCode_e LoaderRpcInterfaceImpl::Do_CEH_Callback(CommandData_t *CmdData_p)
+  {
+    ErrorCode_e ReturnValue = E_GENERAL_FATAL_ERROR;
+    ErrorCode_e ResponseStatus = E_GENERAL_FATAL_ERROR;
+    boolean response = FALSE;
+    const void *Data_p = CmdData_p->Payload.Data_p;
+    uint16 Session = CmdData_p->SessionNr;
+  
+    if (CmdData_p->Type == GENERAL_RESPONSE_PACKAGE)
+    {
+      response = TRUE;
+    }
+    else
+    {
+      response = FALSE;
+    }
+
+    Session = CmdData_p->SessionNr;
+
+    switch(COMMAND(response, CmdData_p->ApplicationNr, CmdData_p->CommandNr))
+    {
+
+  /*
+   * System commands group (0x01)
+   */
+
+    /* Command System application / Loader Start-up Status (1 / 1) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_LOADERSTARTUPSTATUS):
+    {
+      uint32 Status = 0;
+      const char *LoaderVersion_p = NULL;
+      const char *ProtocolVersion_p = NULL;
+        Status = Serialization::get_uint32_le(&Data_p);
+        LoaderVersion_p = Serialization::skip_str(&Data_p);
+        ProtocolVersion_p = Serialization::skip_str(&Data_p);
+      ReturnValue = DoRPC_System_LoaderStartUpStatusImpl(Session, Status, LoaderVersion_p, ProtocolVersion_p);
+    }
+    break;
+  
+    /* Response to System application / Change Uart Baud Rate (1 / 2) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_CHANGEBAUDRATE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_ChangeBaudRateImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Reboot (1 / 3) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_REBOOT):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_RebootImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Shutdown (1 / 4) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SHUTDOWN):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_ShutDownImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Supported Command (1 / 5) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SUPPORTEDCOMMANDS):
+    {
+      uint32 CommandCount = 0;
+      SupportedCommand_t *Commands = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        CommandCount = Serialization::get_uint32_le(&Data_p);
+        Commands = Serialization::get_supportedcommands(&Data_p, CommandCount);
+      }
+      ReturnValue = DoneRPC_System_SupportedCommandsImpl(Session, ResponseStatus, CommandCount, Commands);
+    }
+    break;
+  
+    /* Response to System application / System Execute Software (1 / 6) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_EXECUTESOFTWARE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_ExecuteSoftwareImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Authenticate (1 / 7) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_AuthenticateImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Command System application / System Get Control Keys (1 / 8) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYS):
+    {
+      ReturnValue = DoRPC_System_GetControlKeysImpl(Session);
+    }
+    break;
+  
+    /* Command System application / System Authentication Challenge (1 / 9) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE):
+    {
+      uint32 ChallengeBlockLength = 0;
+      const void *ChallengeBlock_p = NULL;
+        ChallengeBlockLength = Serialization::get_uint32_le(&Data_p);
+        ChallengeBlock_p = Data_p;
+        Serialization::skip_block(&Data_p, ChallengeBlockLength);
+      ReturnValue = DoRPC_System_AuthenticationChallengeImpl(Session, ChallengeBlockLength, ChallengeBlock_p);
+    }
+    break;
+  
+    /* Response to System application / System Collect Data (1 / 10) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_COLLECTDATA):
+    {
+      uint32 DataLenght = 0;
+      const void *CollectedData_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DataLenght = Serialization::get_uint32_le(&Data_p);
+        CollectedData_p = Data_p;
+        Serialization::skip_block(&Data_p, DataLenght);
+      }
+      ReturnValue = DoneRPC_System_CollectDataImpl(Session, ResponseStatus, DataLenght, CollectedData_p);
+    }
+    break;
+  
+    /* Response to System application / System Get Progress Status (1 / 11) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_GETPROGRESSSTATUS):
+    {
+      uint32 ProgressStatus = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        ProgressStatus = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_System_GetProgressStatusImpl(Session, ResponseStatus, ProgressStatus);
+    }
+    break;
+  
+    /* Response to System application / Set System Time (1 / 12) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SETSYSTEMTIME):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_SetSystemTimeImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / Switch Communication Device (1 / 13) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_SwitchCommunicationDeviceImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Command System application / System Get Control Keys Data (1 / 14) */ 
+    case COMMAND(FALSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYSDATA):
+    {
+      ReturnValue = DoRPC_System_GetControlKeysDataImpl(Session);
+    }
+    break;
+  
+    /* Response to System application / System Start Communication Relay (1 / 15) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_STARTCOMMRELAY):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_StartCommRelayImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to System application / System Deauthenticate (1 / 16) */ 
+    case COMMAND(TRUE, GROUP_SYSTEM, COMMAND_SYSTEM_DEAUTHENTICATE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_System_DeauthenticateImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * Flash Commands group (0x02)
+   */
+
+    /* Response to Flash application / Process File (2 / 1) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_PROCESSFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_ProcessFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / List Devices (2 / 2) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_LISTDEVICES):
+    {
+      uint32 DeviceCount = 0;
+      ListDevice_t *Devices = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DeviceCount = Serialization::get_uint32_le(&Data_p);
+        Devices = Serialization::get_devices(&Data_p, DeviceCount);
+      }
+      ReturnValue = DoneRPC_Flash_ListDevicesImpl(Session, ResponseStatus, DeviceCount, Devices);
+    }
+    break;
+  
+    /* Response to Flash application / Dump Area (2 / 3) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_DUMPAREA):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_DumpAreaImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / Erase Area (2 / 4) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_ERASEAREA):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_EraseAreaImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / Flash RAW (2 / 5) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_FLASHRAW):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_FlashRawImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Flash application / Set Enhanced Area (2 / 6) */ 
+    case COMMAND(TRUE, GROUP_FLASH, COMMAND_FLASH_SETENHANCEDAREA):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Flash_SetEnhancedAreaImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * File System Commands Group (0x03)
+   */
+
+    /* Response to File system operations / Volume Properties (3 / 2) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES):
+    {
+      const char *FS_Type_p = NULL;
+      uint64 Size = 0;
+      uint64 Free = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        FS_Type_p = Serialization::skip_str(&Data_p);
+        Size = Serialization::get_uint64_le(&Data_p);
+        Free = Serialization::get_uint64_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_File_System_Operations_VolumePropertiesImpl(Session, ResponseStatus, FS_Type_p, Size, Free);
+    }
+    break;
+  
+    /* Response to File system operations / Format Volume (3 / 3) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_FormatVolumeImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / List Directory (3 / 4) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY):
+    {
+      uint32 EntriesCount = 0;
+      DirEntry_t *Entries = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        EntriesCount = Serialization::get_uint32_le(&Data_p);
+        Entries = Serialization::get_direntries(&Data_p, EntriesCount);
+      }
+      ReturnValue = DoneRPC_File_System_Operations_ListDirectoryImpl(Session, ResponseStatus, EntriesCount, Entries);
+    }
+    break;
+  
+    /* Response to File system operations / Move File (3 / 5) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_MoveFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Delete File (3 / 6) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_DeleteFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Copy File (3 / 7) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_CopyFileImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Create Directory (3 / 8) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_CreateDirectoryImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Properties (Stat) (3 / 9) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES):
+    {
+      uint32 Mode = 0;
+      uint64 Size = 0;
+      uint32 MTime = 0;
+      uint32 ATime = 0;
+      uint32 CTime = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        Mode = Serialization::get_uint32_le(&Data_p);
+        Size = Serialization::get_uint64_le(&Data_p);
+        MTime = Serialization::get_uint32_le(&Data_p);
+        ATime = Serialization::get_uint32_le(&Data_p);
+        CTime = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_File_System_Operations_PropertiesImpl(Session, ResponseStatus, Mode, Size, MTime, ATime, CTime);
+    }
+    break;
+  
+    /* Command File system operations / Properties (Stat) (3 / 9) */ 
+    case COMMAND(FALSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES):
+    {
+      const char *TargetPath_p = NULL;
+        TargetPath_p = Serialization::skip_str(&Data_p);
+      ReturnValue = DoRPC_File_System_Operations_PropertiesImpl(Session, TargetPath_p);
+    }
+    break;
+  
+    /* Response to File system operations / Change Access (Chmod) (3 / 10) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_ChangeAccessImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to File system operations / Read Load Modules Manifests (3 / 11) */ 
+    case COMMAND(TRUE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_File_System_Operations_ReadLoadModulesManifestsImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * OTP handling commands Group (0x04)
+   */
+
+    /* Response to OTP / Read Bits (4 / 1) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_READBITS):
+    {
+      uint32 BitsLength = 0;
+      uint32 DataBitsLength = 0;
+      const void *DataBits_p = NULL;
+      uint32 LockStatusBitsLength = 0;
+      uint32 LockStatusLength = 0;
+      const void *LockStatus_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        BitsLength = Serialization::get_uint32_le(&Data_p);
+        DataBitsLength = Serialization::get_uint32_le(&Data_p);
+        DataBits_p = Data_p;
+        Serialization::skip_block(&Data_p, DataBitsLength);
+        LockStatusBitsLength = Serialization::get_uint32_le(&Data_p);
+        LockStatusLength = Serialization::get_uint32_le(&Data_p);
+        LockStatus_p = Data_p;
+        Serialization::skip_block(&Data_p, LockStatusLength);
+      }
+      ReturnValue = DoneRPC_OTP_ReadBitsImpl(Session, ResponseStatus, BitsLength, DataBitsLength, DataBits_p, LockStatusBitsLength, LockStatusLength, LockStatus_p);
+    }
+    break;
+  
+    /* Response to OTP / Set Bits (4 / 2) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_SETBITS):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_OTP_SetBitsImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to OTP / Write and Lock OTP (4 / 3) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_WRITEANDLOCK):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_OTP_WriteAndLockImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to OTP / Store Secure Object (4 / 4) */ 
+    case COMMAND(TRUE, GROUP_OTP, COMMAND_OTP_STORESECUREOBJECT):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_OTP_StoreSecureObjectImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * Parameter Storage Commands Group (0x05)
+   */
+
+    /* Response to Parameter Storage / Read Global Data Unit (5 / 1) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT):
+    {
+      uint32 DataBuffLength = 0;
+      const void *DataBuff_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DataBuffLength = Serialization::get_uint32_le(&Data_p);
+        DataBuff_p = Data_p;
+        Serialization::skip_block(&Data_p, DataBuffLength);
+      }
+      ReturnValue = DoneRPC_ParameterStorage_ReadGlobalDataUnitImpl(Session, ResponseStatus, DataBuffLength, DataBuff_p);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Write Global Data Unit (5 / 2) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_WriteGlobalDataUnitImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Read Global Data Set (5 / 3) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATASET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_ReadGlobalDataSetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Write Global Data Set (5 / 4) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_WriteGlobalDataSetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Parameter Storage / Erase Global Data Set (5 / 5) */ 
+    case COMMAND(TRUE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_ParameterStorage_EraseGlobalDataSetImpl(Session, ResponseStatus);
+    }
+    break;
+  
+  /*
+   * Security settings Commands Group (0x06)
+   */
+
+    /* Response to Security / Set Domain (6 / 1) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_SETDOMAIN):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_SetDomainImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Security / Get Domain (6 / 2) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_GETDOMAIN):
+    {
+      uint32 CurrentDomain = 0;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        CurrentDomain = Serialization::get_uint32_le(&Data_p);
+      }
+      ReturnValue = DoneRPC_Security_GetDomainImpl(Session, ResponseStatus, CurrentDomain);
+    }
+    break;
+  
+    /* Response to Security / Get Properties (6 / 3) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_GETPROPERTIES):
+    {
+      uint32 DataBuffLength = 0;
+      const void *DataBuff_p = NULL;
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      if (E_SUCCESS == ResponseStatus)
+      {
+        DataBuffLength = Serialization::get_uint32_le(&Data_p);
+        DataBuff_p = Data_p;
+        Serialization::skip_block(&Data_p, DataBuffLength);
+      }
+      ReturnValue = DoneRPC_Security_GetPropertiesImpl(Session, ResponseStatus, DataBuffLength, DataBuff_p);
+    }
+    break;
+  
+    /* Response to Security / Set Properties (6 / 4) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_SETPROPERTIES):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_SetPropertiesImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Security / Bind Properties (6 / 5) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_BINDPROPERTIES):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_BindPropertiesImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    /* Response to Security / Init ARBTable (6 / 6) */ 
+    case COMMAND(TRUE, GROUP_SECURITY, COMMAND_SECURITY_INITARBTABLE):
+    {
+      ResponseStatus = (ErrorCode_e)Serialization::get_uint32_le(&Data_p);
+      ReturnValue = DoneRPC_Security_InitARBTableImpl(Session, ResponseStatus);
+    }
+    break;
+  
+    default:
+      {
+        return E_COMMAND_NO_ERROR; // Do_CustomCEH_Call(CmdData_p); // when customer commands will be implemented
+      }
+    }
+
+    if (response)
+    {
+      lcdMethods_->AddEvent(new Event(EVENT_GR_RECEIVED, ResponseStatus, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+    }
+    else
+    {
+      lcdMethods_->AddEvent(new Event(EVENT_CMD_RECEIVED, 0, CmdData_p->ApplicationNr, CmdData_p->CommandNr));
+    }
+
+    return ReturnValue;
+  }
+
+/*
+ * System commands group (0x01)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_LoaderStartUpStatus(uint16 Session, ErrorCode_e Status)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_LOADERSTARTUPSTATUS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_ChangeBaudRate(uint16 SessionOut, const uint32 BaudRate)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_CHANGEBAUDRATE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, BaudRate);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_Reboot(uint16 SessionOut, const uint32 Mode)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_REBOOT, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Mode);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_ShutDown(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SHUTDOWN, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_SupportedCommands(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SUPPORTEDCOMMANDS, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_ExecuteSoftware(uint16 SessionOut, const uint32 ExecuteMode, const char *SourcePath_p, const uint64 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+  PLSize += sizeof(uint64);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_EXECUTESOFTWARE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, ExecuteMode);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+  Serialization::put_uint64_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_Authenticate(uint16 SessionOut, const uint32 Type)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Type);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_GetControlKeys(uint16 Session, ErrorCode_e Status, const char *NLCKLock_p, const char *NSLCKLock_p, const char *SPLCKLock_p, const char *CLCKLock_p, const char *PCKLock_p, const char *ESLCKLock_p, const char *NLCKUnlock_p, const char *NSLCKUnlock_p, const char *SPLCKUnlock_p, const char *CLCKUnlock_p, const char *PCKUnlock_p, const char *ESLCKUnlock_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeNLCKLock_p = 0;
+  uint32 PLSizeNSLCKLock_p = 0;
+  uint32 PLSizeSPLCKLock_p = 0;
+  uint32 PLSizeCLCKLock_p = 0;
+  uint32 PLSizePCKLock_p = 0;
+  uint32 PLSizeESLCKLock_p = 0;
+  uint32 PLSizeNLCKUnlock_p = 0;
+  uint32 PLSizeNSLCKUnlock_p = 0;
+  uint32 PLSizeSPLCKUnlock_p = 0;
+  uint32 PLSizeCLCKUnlock_p = 0;
+  uint32 PLSizePCKUnlock_p = 0;
+  uint32 PLSizeESLCKUnlock_p = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSizeNLCKLock_p = strlen(NLCKLock_p);
+  PLSize += PLSizeNLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeNSLCKLock_p = strlen(NSLCKLock_p);
+  PLSize += PLSizeNSLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeSPLCKLock_p = strlen(SPLCKLock_p);
+  PLSize += PLSizeSPLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeCLCKLock_p = strlen(CLCKLock_p);
+  PLSize += PLSizeCLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizePCKLock_p = strlen(PCKLock_p);
+  PLSize += PLSizePCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeESLCKLock_p = strlen(ESLCKLock_p);
+  PLSize += PLSizeESLCKLock_p;
+  PLSize += sizeof(uint32);
+  PLSizeNLCKUnlock_p = strlen(NLCKUnlock_p);
+  PLSize += PLSizeNLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeNSLCKUnlock_p = strlen(NSLCKUnlock_p);
+  PLSize += PLSizeNSLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeSPLCKUnlock_p = strlen(SPLCKUnlock_p);
+  PLSize += PLSizeSPLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeCLCKUnlock_p = strlen(CLCKUnlock_p);
+  PLSize += PLSizeCLCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizePCKUnlock_p = strlen(PCKUnlock_p);
+  PLSize += PLSizePCKUnlock_p;
+  PLSize += sizeof(uint32);
+  PLSizeESLCKUnlock_p = strlen(ESLCKUnlock_p);
+  PLSize += PLSizeESLCKUnlock_p;
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYS, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, PLSizeNLCKLock_p);
+  Serialization::put_block(&Data_p, NLCKLock_p, PLSizeNLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeNSLCKLock_p);
+  Serialization::put_block(&Data_p, NSLCKLock_p, PLSizeNSLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeSPLCKLock_p);
+  Serialization::put_block(&Data_p, SPLCKLock_p, PLSizeSPLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeCLCKLock_p);
+  Serialization::put_block(&Data_p, CLCKLock_p, PLSizeCLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizePCKLock_p);
+  Serialization::put_block(&Data_p, PCKLock_p, PLSizePCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeESLCKLock_p);
+  Serialization::put_block(&Data_p, ESLCKLock_p, PLSizeESLCKLock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeNLCKUnlock_p);
+  Serialization::put_block(&Data_p, NLCKUnlock_p, PLSizeNLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeNSLCKUnlock_p);
+  Serialization::put_block(&Data_p, NSLCKUnlock_p, PLSizeNSLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeSPLCKUnlock_p);
+  Serialization::put_block(&Data_p, SPLCKUnlock_p, PLSizeSPLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeCLCKUnlock_p);
+  Serialization::put_block(&Data_p, CLCKUnlock_p, PLSizeCLCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizePCKUnlock_p);
+  Serialization::put_block(&Data_p, PCKUnlock_p, PLSizePCKUnlock_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeESLCKUnlock_p);
+  Serialization::put_block(&Data_p, ESLCKUnlock_p, PLSizeESLCKUnlock_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_AuthenticationChallenge(uint16 Session, ErrorCode_e Status, const uint32 ResponseBlockLength, const void *ResponseBlock_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += ResponseBlockLength;
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_AUTHENTICATIONCHALLENGE, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, ResponseBlockLength);
+  Serialization::put_block(&Data_p, ResponseBlock_p, ResponseBlockLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_CollectData(uint16 SessionOut, const uint32 Type)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_COLLECTDATA, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Type);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_GetProgressStatus(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_GETPROGRESSSTATUS, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_SetSystemTime(uint16 SessionOut, const uint32 EpochTime)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SETSYSTEMTIME, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, EpochTime);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_SwitchCommunicationDevice(uint16 SessionOut, const uint32 Device, const uint32 DeviceParam)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_SWITCHCOMMUNICATIONDEVICE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Device);
+  Serialization::put_uint32_le(&Data_p, DeviceParam);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_System_GetControlKeysData(uint16 Session, ErrorCode_e Status, const uint32 iDataSize, const void *SIMLockKeysData_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += iDataSize;
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_SYSTEM, COMMAND_SYSTEM_GETCONTROLKEYSDATA, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, iDataSize);
+  Serialization::put_block(&Data_p, SIMLockKeysData_p, iDataSize);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_StartCommRelay(uint16 SessionOut, const uint32 HostDeviceId, const uint32 TargetDeviceId, const uint32 ControlDeviceId)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_STARTCOMMRELAY, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, HostDeviceId);
+  Serialization::put_uint32_le(&Data_p, TargetDeviceId);
+  Serialization::put_uint32_le(&Data_p, ControlDeviceId);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_System_Deauthenticate(uint16 SessionOut, const uint32 Type)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SYSTEM, COMMAND_SYSTEM_DEAUTHENTICATE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Type);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * Flash Commands group (0x02)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_ProcessFile(uint16 SessionOut, const uint64 Length, const char *Type_p, const char *SourcePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeType_p = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSizeType_p = strlen(Type_p);
+  PLSize += PLSizeType_p;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_PROCESSFILE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint64_le(&Data_p, Length);
+  Serialization::put_uint32_le(&Data_p, PLSizeType_p);
+  Serialization::put_block(&Data_p, Type_p, PLSizeType_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_ListDevices(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_LISTDEVICES, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_DumpArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length, const char *TargetPath_p, const uint32 RedundantArea)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_DUMPAREA, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+  Serialization::put_uint32_le(&Data_p, RedundantArea);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_EraseArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_ERASEAREA, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_FlashRaw(uint16 SessionOut, const uint64 Start, const uint64 Length, const uint32 Device, const char *SourcePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_FLASHRAW, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+  Serialization::put_uint32_le(&Data_p, Device);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Flash_SetEnhancedArea(uint16 SessionOut, const char *Path_p, const uint64 Start, const uint64 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint64);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FLASH, COMMAND_FLASH_SETENHANCEDAREA, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+  Serialization::put_uint64_le(&Data_p, Start);
+  Serialization::put_uint64_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * File System Commands Group (0x03)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_VolumeProperties(uint16 SessionOut, const char *DevicePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_VOLUMEPROPERTIES, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_FormatVolume(uint16 SessionOut, const char *DevicePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_FORMATVOLUME, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_ListDirectory(uint16 SessionOut, const char *Path_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizePath_p = strlen(Path_p);
+  PLSize += PLSizePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_LISTDIRECTORY, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizePath_p);
+  Serialization::put_block(&Data_p, Path_p, PLSizePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_MoveFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  uint32 PLSizeDestinationPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+  PLSize += sizeof(uint32);
+  PLSizeDestinationPath_p = strlen(DestinationPath_p);
+  PLSize += PLSizeDestinationPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_MOVEFILE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeDestinationPath_p);
+  Serialization::put_block(&Data_p, DestinationPath_p, PLSizeDestinationPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_DeleteFile(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_DELETEFILE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_CopyFile(uint16 SessionOut, const char *SourcePath_p, const char *DestinationPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  uint32 PLSizeDestinationPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+  PLSize += sizeof(uint32);
+  PLSizeDestinationPath_p = strlen(DestinationPath_p);
+  PLSize += PLSizeDestinationPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_COPYFILE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeDestinationPath_p);
+  Serialization::put_block(&Data_p, DestinationPath_p, PLSizeDestinationPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_CreateDirectory(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CREATEDIRECTORY, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_Properties(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoneRPC_File_System_Operations_Properties(uint16 Session, ErrorCode_e Status, const uint32 Mode, const uint64 Size, const uint32 MTime, const uint32 ATime, const uint32 CTime)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  PLSize += sizeof(ErrorCode_e);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATA(GENERAL_RESPONSE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_PROPERTIES, Session, PLSize);
+  Data_p = CmdData.Payload.Data_p;
+  
+  Serialization::put_uint32_le(&Data_p, Status);
+  Serialization::put_uint32_le(&Data_p, Mode);
+  Serialization::put_uint64_le(&Data_p, Size);
+  Serialization::put_uint32_le(&Data_p, MTime);
+  Serialization::put_uint32_le(&Data_p, ATime);
+  Serialization::put_uint32_le(&Data_p, CTime);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_ChangeAccess(uint16 SessionOut, const char *TargetPath_p, const uint32 Access)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_CHANGEACCESS, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+  Serialization::put_uint32_le(&Data_p, Access);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_File_System_Operations_ReadLoadModulesManifests(uint16 SessionOut, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_FILE_SYSTEM_OPERATIONS, COMMAND_FILE_SYSTEM_OPERATIONS_READLOADMODULESMANIFESTS, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * OTP handling commands Group (0x04)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_ReadBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 Length)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_READBITS, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, OTP_id);
+  Serialization::put_uint32_le(&Data_p, Start);
+  Serialization::put_uint32_le(&Data_p, Length);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_SetBits(uint16 SessionOut, const uint32 OTP_id, const uint32 Start, const uint32 BitsLength, const uint32 DataBitsLength, const void *DataBits_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBitsLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_SETBITS, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, OTP_id);
+  Serialization::put_uint32_le(&Data_p, Start);
+  Serialization::put_uint32_le(&Data_p, BitsLength);
+  Serialization::put_uint32_le(&Data_p, DataBitsLength);
+  Serialization::put_block(&Data_p, DataBits_p, DataBitsLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_WriteAndLock(uint16 SessionOut, const uint32 OTP_id, const uint32 ForceWrite)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_WRITEANDLOCK, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, OTP_id);
+  Serialization::put_uint32_le(&Data_p, ForceWrite);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_OTP_StoreSecureObject(uint16 SessionOut, const char *SourcePath, const uint32 SecureObjectDestination)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeSourcePath = 0;
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath = strlen(SourcePath);
+  PLSize += PLSizeSourcePath;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_OTP, COMMAND_OTP_STORESECUREOBJECT, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath);
+  Serialization::put_block(&Data_p, SourcePath, PLSizeSourcePath);
+  Serialization::put_uint32_le(&Data_p, SecureObjectDestination);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * Parameter Storage Commands Group (0x05)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_ReadGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATAUNIT, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_WriteGlobalDataUnit(uint16 SessionOut, const char *DevicePath_p, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBuffLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATAUNIT, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+  Serialization::put_uint32_le(&Data_p, DataBuffLength);
+  Serialization::put_block(&Data_p, DataBuff_p, DataBuffLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_ReadGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const char *TargetPath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  uint32 PLSizeTargetPath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint32);
+  PLSizeTargetPath_p = strlen(TargetPath_p);
+  PLSize += PLSizeTargetPath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_READGLOBALDATASET, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint32_le(&Data_p, PLSizeTargetPath_p);
+  Serialization::put_block(&Data_p, TargetPath_p, PLSizeTargetPath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_WriteGlobalDataSet(uint16 SessionOut, const char *DevicePath_p, const uint64 DataLength, const char *SourcePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  uint32 PLSizeSourcePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+  PLSize += sizeof(uint64);
+  PLSize += sizeof(uint32);
+  PLSizeSourcePath_p = strlen(SourcePath_p);
+  PLSize += PLSizeSourcePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_WRITEGLOBALDATASET, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+  Serialization::put_uint64_le(&Data_p, DataLength);
+  Serialization::put_uint32_le(&Data_p, PLSizeSourcePath_p);
+  Serialization::put_block(&Data_p, SourcePath_p, PLSizeSourcePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_ParameterStorage_EraseGlobalDataSet(uint16 SessionOut, const char *DevicePath_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  uint32 PLSizeDevicePath_p = 0;
+  PLSize += sizeof(uint32);
+  PLSizeDevicePath_p = strlen(DevicePath_p);
+  PLSize += PLSizeDevicePath_p;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_PARAMETERSTORAGE, COMMAND_PARAMETERSTORAGE_ERASEGLOBALDATASET, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, PLSizeDevicePath_p);
+  Serialization::put_block(&Data_p, DevicePath_p, PLSizeDevicePath_p);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+/*
+ * Security settings Commands Group (0x06)
+ */
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_SetDomain(uint16 SessionOut, const uint32 Domain)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_SETDOMAIN, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Domain);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_GetDomain(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_GETDOMAIN, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_GetProperties(uint16 SessionOut, const uint32 Unit_id)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_GETPROPERTIES, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_SetProperties(uint16 SessionOut, const uint32 Unit_id, const uint32 DataBuffLength, const void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataBuffLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_SETPROPERTIES, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Unit_id);
+  Serialization::put_uint32_le(&Data_p, DataBuffLength);
+  Serialization::put_block(&Data_p, DataBuff_p, DataBuffLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_BindProperties(uint16 SessionOut)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_BINDPROPERTIES, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
+
+ErrorCode_e LoaderRpcInterface::DoRPC_Security_InitARBTable(uint16 SessionOut, const uint32 Type, const uint32 DataLength, const void *DataBuff_p)
+{
+  ErrorCode_e Answer;
+  CommandData_t CmdData;
+  void *Data_p;
+  uint32 PLSize = 0;
+  PLSize += sizeof(uint32);
+  PLSize += sizeof(uint32);
+  PLSize += DataLength;
+
+  COMMANDDATAOUT(COMMAND_TYPE, GROUP_SECURITY, COMMAND_SECURITY_INITARBTABLE, SessionOut, PLSize);
+  (void)(Data_p);
+  Data_p = CmdData.Payload.Data_p;
+  Serialization::put_uint32_le(&Data_p, Type);
+  Serialization::put_uint32_le(&Data_p, DataLength);
+  Serialization::put_block(&Data_p, DataBuff_p, DataLength);
+
+  Answer = lcmInterface_->CommandSend(&CmdData);
+
+  if(NULL != CmdData.Payload.Data_p)
+    free(CmdData.Payload.Data_p);
+  return Answer;    
+}
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/error_codes_desc.cpp riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/error_codes_desc.cpp
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/error_codes_desc.cpp	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/error_codes_desc.cpp	2012-05-29 21:37:36.747195745 +0300
@@ -0,0 +1,2558 @@
+/* $Copyright ST-Ericsson 2012$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+/*******************************************************************************
+ * Includes
+ ******************************************************************************/
+#include <string>
+#include <map>
+
+#include "LCDriver.h"
+#include "error_codes_desc.h"
+#if defined(__MINGW32__) || defined(__linux__) || defined(__APPLE__)
+#include "String_s.h"
+#endif // __MINGW32__ || __linux__ || __APPLE__)
+
+/*******************************************************************************
+ * Types, constants
+ ******************************************************************************/
+std::map <int, desc> err_desc;
+static uint32 func_call_once = 0;
+
+/****************************************************************************/
+/*       NAME : Init_map_err_desc                                           */
+/*--------------------------------------------------------------------------*/
+/* DESCRIPTION: Declares the map err_desc with short and long description   */
+/*              of errors.                                                  */
+/*                                                                          */
+/* PARAMETERS :                                                             */
+/*                                                                          */
+/*    RETURN : void                                                         */
+/****************************************************************************/
+void Init_map_err_desc()
+{
+    desc desc_;
+
+/**
+ *  Description of error codes for LCDriver.
+ */
+    desc_.short_desc = "Timeout event occurred.";
+    desc_.long_desc = "Timeout for previously sent request has occurred. Request could be Protrom Command, Bulk transfer, or R15 Command.";
+    err_desc[10001] = desc_;
+    desc_.short_desc = "Invalid parameter during Context initialization.";
+    desc_.long_desc = "Invalid parameter found during executing LCDriver initialization functions. Failed to initialize Context.";
+    err_desc[10002] = desc_;
+    desc_.short_desc = "Failed to create context for connected device.";
+    desc_.long_desc = "Failed to add the LCDriver context for the new device in the devices list. Try to reconnect the device, if the problem is still present report it.";
+    err_desc[10051] = desc_;
+    desc_.short_desc = "Failed to create loader interface.";
+    desc_.long_desc = "Failed to create interface for loader methods, possibly not enough memory to perform the operation. Try to reconnect the device, if the problem is still present report it.";
+    err_desc[10052] = desc_;
+    desc_.short_desc = "Failed to create context for connected device.";
+    desc_.long_desc = "Unknown exception occurred while trying to create context for the connected device. Try to reconnect the device, if the problem is still present report it.";
+    err_desc[10053] = desc_;
+    desc_.short_desc = "Failed to create context for connected device.";
+    desc_.long_desc = "Failed to create LCDriver context for the connected device, possibly not enough memory to perform the operation. Try to reconnect the device, if the problem is still present report it.";
+    err_desc[10054] = desc_;
+    desc_.short_desc = "Invalid pointer to interface.";
+    desc_.long_desc = "Tried to create LCDriver interface with invalid pointer.";
+    err_desc[10055] = desc_;
+    desc_.short_desc = "Invalid pointer to LCDriver context.";
+    desc_.long_desc = "Tried to configure device with invalid pointer to LCDriver interface. Create the LCDriver interface for the connected device and try to configure the device later. If the problem is still present report it.";
+    err_desc[10056] = desc_;
+    desc_.short_desc = "LCDriver interface for the device already exists.";
+    desc_.long_desc = "The context for the device was previously created.";
+    err_desc[10076] = desc_;
+    desc_.short_desc = "Interface for loader methods is not created.";
+    desc_.long_desc = "Tried to execute loader method without creating loader method interface. Create the interface first and retry the same operation. If the problem is still present report it.";
+    err_desc[10077] = desc_;
+    desc_.short_desc = "Failed to create LCDriver context.";
+    desc_.long_desc = "Tried to create LCDriver context with invalid ID for the context. Try to create context with different context ID, if the problem is still present report it.";
+    err_desc[10078] = desc_;
+    desc_.short_desc = "LCDriver context is not started.";
+    desc_.long_desc = "Tried to call loader method before starting the LCDriver context. Try to start the context before calling loader methods, if the problem is still present report it.";
+    err_desc[10079] = desc_;
+    desc_.short_desc = "Unexpected exit of LCDriver thread.";
+    desc_.long_desc = "The LCDriver thread exited in unexpected way. The error is not recognized, if the problem persists report it.";
+    err_desc[10126] = desc_;
+    desc_.short_desc = "Failed to start bulk session.";
+    desc_.long_desc = "Failed to open bulk session due to invalid Bulk Vector ID.";
+    err_desc[10176] = desc_;
+    desc_.short_desc = "Bulk transfer is already in progress.";
+    desc_.long_desc = "Bulk transfer is already in progress. Parallel bulk transfers are not supported";
+    err_desc[10177] = desc_;
+    desc_.short_desc = "ROM Code Failure.";
+    desc_.long_desc = "Error occurred while communicating the ROM code. Possibly there is some security issue with the used SW/HW.";
+    err_desc[10201] = desc_;
+    desc_.short_desc = "Failed to initialize HW.";
+    desc_.long_desc = "The HW failed to respond during the initialization sequence. Try with other HW, if the problem still exist report it, otherwise probably it faulty HW.";
+    err_desc[10226] = desc_;
+    desc_.short_desc = "Failed to start HW initialization.";
+    desc_.long_desc = "The HW initialization failed to start. Try with other HW, if the problem still exist report it, otherwise probably it faulty HW.";
+    err_desc[10227] = desc_;
+    desc_.short_desc = "Command execution failed.";
+    desc_.long_desc = "Failed to execute command because there is other active command. Try to execute command again. If the problem persists probably there is some blocked command. Restart the HW.";
+    err_desc[10276] = desc_;
+    desc_.short_desc = "Communication driver configuration failure.";
+    desc_.long_desc = "Callbacks for communication device are not configured. Try to configure device driver callbacks. If the problem persists report it.";
+    err_desc[10277] = desc_;
+    desc_.short_desc = "Failure during command execution.";
+    desc_.long_desc = "Received response for command other than it was expected. Probably there is communication error. Restart the HW, if the problem persists report it.";
+    err_desc[10278] = desc_;
+    desc_.short_desc = "Failure during command execution.";
+    desc_.long_desc = "Command received from ME other than it was expected. Probably there is communication error. Restart the HW, if the problem persists report it.";
+    err_desc[10279] = desc_;
+    desc_.short_desc = "Operation execution is canceled.";
+    desc_.long_desc = "Canceled execution of active command/communication due to receiving of cancel event.";
+    err_desc[10280] = desc_;
+    desc_.short_desc = "Unexpected event during execution.";
+    desc_.long_desc = "Unexpected event was received during command execution.";
+    err_desc[10281] = desc_;
+    desc_.short_desc = "Invalid execution mode.";
+    desc_.long_desc = "Unexpected event was received during command execution.";
+    err_desc[10282] = desc_;
+    desc_.short_desc = "Bulk transfer failed.";
+    desc_.long_desc = "Failed to load file from local HDD in RAM. Command execution failed.";
+    err_desc[10326] = desc_;
+    desc_.short_desc = "Failed to open file.";
+    desc_.long_desc = "Failed to open the file with the given path. Check if the file path is correct.";
+    err_desc[10376] = desc_;
+    desc_.short_desc = "Failed to load the file in RAM.";
+    desc_.long_desc = "Mapping of the file in RAM failed. Try to execute command again, if problem persist try to restart the HW.";
+    err_desc[10377] = desc_;
+    desc_.short_desc = "Reading of file failed.";
+    desc_.long_desc = "Failed to create desired view on RAM area of the mapped file. Try to execute command again, if problem persist try to restart the HW.";
+    err_desc[10378] = desc_;
+    desc_.short_desc = "Failed to load the file in RAM.";
+    desc_.long_desc = "Failed to read file description. Try to execute command again, if problem persist try to restart the HW.";
+    err_desc[10379] = desc_;
+    desc_.short_desc = "Invalid data offset requested.";
+    desc_.long_desc = "Invalid file offset requested. Try to execute command again, if problem persist try to restart the HW.";
+    err_desc[10379] = desc_;
+    desc_.short_desc = "Failed to read from file.";
+    desc_.long_desc = "Failed to read data from file. Try to execute command again, if problem persist try to restart the HW.";
+    err_desc[10380] = desc_;
+    desc_.short_desc = "Failed to load LCM library.";
+    desc_.long_desc = "Loading of dependent library failed. Make sure that it is placed on correct location.";
+    err_desc[10401] = desc_;
+    desc_.short_desc = "Failed to import LCM functionality.";
+    desc_.long_desc = "Some of dependent functions was not found in the given LCM library. Make sure that the version that is used is compatible.";
+    err_desc[10402] = desc_;
+    desc_.short_desc = "Incompatible PC LCM version.";
+    desc_.long_desc = "Some of functions may not work in the given LCM library. Make sure that the PC LCM version that is used is compatible.";
+    err_desc[10426] = desc_;
+    desc_.short_desc = "Incompatible LDR LCM version.";
+    desc_.long_desc = "Some of functions may not work in the given LCM library. Make sure that the LDR LCM version that is used is compatible.";
+    err_desc[10427] = desc_;
+    desc_.short_desc = "Unknown error has stopped the operation.";
+    desc_.long_desc = "The active operation was stopped by unknown exception. Repeat the failure procedure, if the problem persists report it.";
+    err_desc[10451] = desc_;
+    desc_.short_desc = "Operation execution failed.";
+    desc_.long_desc = "The activity didn't complete properly. Unhandled event was received during execution of command/activity.";
+    err_desc[10476] = desc_;
+    desc_.short_desc = "Bulk transfer failed.";
+    desc_.long_desc = "The transfer of bulk data was interrupted by unknown exception. Data was not transferred successfully.";
+    err_desc[10477] = desc_;
+    desc_.short_desc = "LCDriver context operation failed.";
+    desc_.long_desc = "Failed to perform desired operation on the LCDriver context due to unknown exception.";
+    err_desc[10478] = desc_;
+    desc_.short_desc = "LCDriver thread stopped.";
+    desc_.long_desc = "Execution of LCDriver thread has stopped because the thread was killed with unknown reason.";
+    err_desc[10526] = desc_;
+    desc_.short_desc = "LCDriver thread stopped.";
+    desc_.long_desc = "Execution of LCDriver thread has stopped because the thread was killed by cancel event.";
+    err_desc[10527] = desc_;
+    desc_.short_desc = "LCDriver thread stopped.";
+    desc_.long_desc = "Execution of LCDriver thread has stopped with shutdown request.";
+    err_desc[10528] = desc_;
+    desc_.short_desc = "Failed to start LCDriver thread.";
+    desc_.long_desc = "Starting of LCDriver thread has failed. An error has occurred during initialization. Reconnect the device, if the problem persist report it.";
+    err_desc[10529] = desc_;
+    desc_.short_desc = "LCDriver thread stopped after receiving LCM error.";
+    desc_.long_desc = "LCDriver thread must be stopped due to unrecoverable error state in the LCM. Reconnect the device, if the problem persist report it.";
+    err_desc[10530] = desc_;
+    desc_.short_desc = "LCM failed to send packet.";
+    desc_.long_desc = "Maximum number of packet retransmission attempts failed. Further communication of device is not possible. Reconnect the device, if the problem persist report it.";
+    err_desc[10551] = desc_;
+    desc_.short_desc = "LCM failed to write data on communication device.";
+    desc_.long_desc = "LCM failed to get response from communication device. Further communication of device is not possible. Reconnect the device, if the problem persist report it.";
+    err_desc[10552] = desc_;
+
+/**
+ *  Description of error codes for Loader.
+ */
+    desc_.short_desc = "Operation successful.";
+    desc_.long_desc = " Operation finished successfully.";
+    err_desc[0] = desc_;
+    desc_.short_desc = "General Failure.";
+    desc_.long_desc = " Unknown error.";
+    err_desc[1] = desc_;
+    desc_.short_desc = "Failed to allocate memory.";
+    desc_.long_desc = " Try to reset the loader and if problem still exist, report it.";
+    err_desc[2] = desc_;
+    desc_.short_desc = "The expected value into the function was incorrect.";
+    desc_.long_desc = " Check the input parameters in the command that you try to execute. Repeat operation. Report if problem is not solved.";
+    err_desc[51] = desc_;
+    desc_.short_desc = "Indicate that the currdate string array variable has invalid length.";
+    desc_.long_desc = " Try to reset the loader and if problem still exist, report this error.";
+    err_desc[52] = desc_;
+    desc_.short_desc = "Indicate that a variable is not aligned.";
+    desc_.long_desc = " Try to reset the loader and if still exist the problem, report this error.";
+    err_desc[53] = desc_;
+    desc_.short_desc = "Indicate that ME De-Authentication failed.";
+    desc_.long_desc = " Try to reset the loader and if still exist the problem, report this error.";
+    err_desc[54] = desc_;
+    desc_.short_desc = "Failed to lock code region protected with critical section.";
+    desc_.long_desc = " Loader internal error which should be handled in place where code is executed. Try to reset the loader and if still exist the problem, report this error.";
+    err_desc[55] = desc_;
+    desc_.short_desc = "Failed to create vector in IO Layer.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[100] = desc_;
+    desc_.short_desc = "Failed to destroy vector in IO Layer.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[101] = desc_;
+    desc_.short_desc = "Unknown IO error.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[151] = desc_;
+    desc_.short_desc = "IO failed to read from source.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[152] = desc_;
+    desc_.short_desc = "IO failed to write to destination.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[153] = desc_;
+    desc_.short_desc = "IO failed to close media.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[154] = desc_;
+    desc_.short_desc = "IO failed to open media.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[155] = desc_;
+    desc_.short_desc = "IO failed to get length of media.";
+    desc_.long_desc = "Internal malicious state detected in IO layer. Report this problem.";
+    err_desc[156] = desc_;
+    desc_.short_desc = "General communication error.";
+    desc_.long_desc = "Check the communication cable and restart the loader.";
+    err_desc[200] = desc_;
+    desc_.short_desc = "Failed to start bulk session.";
+    desc_.long_desc = "Try to reset the loader and if still exist the problem, report this error.";
+    err_desc[201] = desc_;
+    desc_.short_desc = "Failed to initialize the transport layer.";
+    desc_.long_desc = "Try to reset the loader and if still exist the problem, report this error.";
+    err_desc[202] = desc_;
+    desc_.short_desc = "Failed to find chunk data block.";
+    desc_.long_desc = "Try to reset the loader and if still exist the problem, report this error.";
+    err_desc[203] = desc_;
+    desc_.short_desc = "Failed to reinitialize communication device.";
+    desc_.long_desc = "Try to reset the loader and if still exist the problem, report this error. Possible hardware problem.";
+    err_desc[204] = desc_;
+    desc_.short_desc = "Failed to use communication device.";
+    desc_.long_desc = "Communication device do not respond and try to reset the loader. If the problem still exist, report this error.";
+    err_desc[205] = desc_;
+    desc_.short_desc = "Failed to allocate communication buffer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[206] = desc_;
+    desc_.short_desc = "Failed to flush RX FIFO.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[207] = desc_;
+    desc_.short_desc = "Retransmission failed. After MAX_RESENDS attempt, failed to send packet.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[208] = desc_;
+    desc_.short_desc = "Stopped command error sequence.";
+    desc_.long_desc = " Reset the loader. Report if problem still exist.";
+    err_desc[209] = desc_;
+    desc_.short_desc = "Failed to release communication buffer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[210] = desc_;
+    desc_.short_desc = "Failed to initialize timer functions.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[211] = desc_;
+    desc_.short_desc = "Failed to initialize queue functions.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[212] = desc_;
+    desc_.short_desc = "Failed to initialize DMA.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[213] = desc_;
+    desc_.short_desc = "Failed to stop DMA channel.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[214] = desc_;
+    desc_.short_desc = "Failed to open DMA channel.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[215] = desc_;
+    desc_.short_desc = "Failed to set DMA channel type.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[216] = desc_;
+    desc_.short_desc = "Failed to set DMA channel mode.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[217] = desc_;
+    desc_.short_desc = "Failed to open DMA pipe.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[218] = desc_;
+    desc_.short_desc = "Failed to set DMA interrupt logic.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[219] = desc_;
+    desc_.short_desc = "Failed to close DMA pipe.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[220] = desc_;
+    desc_.short_desc = "Failed to close DMA channel.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[221] = desc_;
+    desc_.short_desc = "Failed to configure DMA source device.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[222] = desc_;
+    desc_.short_desc = "Failed to update DMA source memory buffer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[223] = desc_;
+    desc_.short_desc = "Failed to configure DMA destination device.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[224] = desc_;
+    desc_.short_desc = "Failed to update DMA destination memory buffer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[225] = desc_;
+    desc_.short_desc = "Failed to run DMA transfer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[226] = desc_;
+    desc_.short_desc = "Invalid bulk mode.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[251] = desc_;
+    desc_.short_desc = "Failed to find communication buffer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[252] = desc_;
+    desc_.short_desc = "Invalid type of buffer.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[253] = desc_;
+    desc_.short_desc = "Communication device is busy.";
+    desc_.long_desc = "Current transfer is not finished.";
+    err_desc[254] = desc_;
+    desc_.short_desc = "The element in retransmission list is not found.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[255] = desc_;
+    desc_.short_desc = "Failed to read from bulk.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[256] = desc_;
+    desc_.short_desc = "Failed to write to bulk.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[257] = desc_;
+    desc_.short_desc = "Failed to get UART descriptor.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[258] = desc_;
+    desc_.short_desc = "Failed to get USB descriptor.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[259] = desc_;
+    desc_.short_desc = "Invalid bulk session ID is used.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[260] = desc_;
+    desc_.short_desc = "Previous bulk session not closed.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[261] = desc_;
+    desc_.short_desc = "Invalid bulk protocol state.";
+    desc_.long_desc = "Try to reset the loader. If the problem still exist, report this error.";
+    err_desc[262] = desc_;
+    desc_.short_desc = "Type of transfer is unsupported.";
+    desc_.long_desc = "USB bulk transfer in DMA mode 1 is only supported.";
+    err_desc[263] = desc_;
+    desc_.short_desc = "Packet can't be registered for retransmission because retransmission list is full.";
+    desc_.long_desc = "All entries in the retransmission list are allocated. No place for new packet to be registered in the retransmission list.";
+    err_desc[264] = desc_;
+    desc_.short_desc = "Unknown property id.";
+    desc_.long_desc = "Check the input value of the command that you try to execute.";
+    err_desc[351] = desc_;
+    desc_.short_desc = "Cyclic graph in services detected.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[451] = desc_;
+    desc_.short_desc = "The service is not supported.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[452] = desc_;
+    desc_.short_desc = "Inconsistency in services is detected.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[453] = desc_;
+    desc_.short_desc = "The service is in use and can't be stopped.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[454] = desc_;
+    desc_.short_desc = "Unregistering of Block Device Manager Service failed.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[455] = desc_;
+    desc_.short_desc = "Unregistering of Boot Area Manager Service failed.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[456] = desc_;
+    desc_.short_desc = "Unregistering of COPS Data Manager Service failed.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[457] = desc_;
+    desc_.short_desc = "Unregistering of File System Manager Service failed.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[458] = desc_;
+    desc_.short_desc = "Unregistering of Flash Physical Driver Service failed.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[459] = desc_;
+    desc_.short_desc = "Unregistering of Global Data Manager Service failed.";
+    desc_.long_desc = " Some internal error occurred and you need to reset the loader to avoid further unpredictable behavior.";
+    err_desc[460] = desc_;
+    desc_.short_desc = "General error.";
+    desc_.long_desc = " Possible error in zip format.Verify that the zip is not corrupted,otherwise report the problem.";
+    err_desc[551] = desc_;
+    desc_.short_desc = " Failed to parse the zip.";
+    desc_.long_desc = " Possible error in zip format.Verify that the zip is not corrupted,otherwise report the problem.";
+    err_desc[552] = desc_;
+    desc_.short_desc = " Failed to open file from the zip.";
+    desc_.long_desc = "Possible error in zip format.Verify that the zip is not corrupted,otherwise report the problem.";
+    err_desc[553] = desc_;
+    desc_.short_desc = "Failed to initialize the file system application.";
+    desc_.long_desc = "Internal error.Reset loader.Report if problem still exist.";
+    err_desc[600] = desc_;
+    desc_.short_desc = "Failed to start file system.";
+    desc_.long_desc = " Verify that archive is successfully flashed.Reset loader. Report if problem still exist.";
+    err_desc[601] = desc_;
+    desc_.short_desc = "Undefined authentication type.";
+    desc_.long_desc = "Check the authentication type. The loader supports authentication with CA certificate and control keyes.Repeat authenticaton. Report if problem still exist.";
+    err_desc[602] = desc_;
+    desc_.short_desc = "System Time is not properly set.";
+    desc_.long_desc = " Default system time is used.Set the Time properly. Report if problem still exist.";
+    err_desc[651] = desc_;
+    desc_.short_desc = "Hardware error occurred during initialization of RTC.";
+    desc_.long_desc = " Report this problem";
+    err_desc[652] = desc_;
+    desc_.short_desc = "Undefined deauthentication type.";
+    desc_.long_desc = " Check input parameters and repeat operation. Report if problem still exist.";
+    err_desc[653] = desc_;
+    desc_.short_desc = "Indicate that ME is in full security mode,Full authentication is needed prior to use COPS functionalities.";
+    desc_.long_desc = " Perform RSA or SIMLOCK authentication prior to use COPS functionalities.";
+    err_desc[654] = desc_;
+    desc_.short_desc = "Indicate that ME is in authenticate security mode, Permanent type authentication is needed prior to use COPS functionalities.";
+    desc_.long_desc = " Perform permanent authentication prior to use COPS functionalities.";
+    err_desc[655] = desc_;
+    desc_.short_desc = "Different flashlayout.";
+    desc_.long_desc = " You must erase the flash before flashing archive with different flashlayout.";
+    err_desc[751] = desc_;
+    desc_.short_desc = "Archive contain empty file.";
+    desc_.long_desc = " Check files in flash archive. Empty files not allowed.";
+    err_desc[752] = desc_;
+    desc_.short_desc = "Unknown communication device was detected.";
+    desc_.long_desc = " Try to restart the loader and if still exist the problem, report this error.";
+    err_desc[753] = desc_;
+    desc_.short_desc = "Internal during execution of flash commands.";
+    desc_.long_desc = " Try to erase flash and restart the loader and if problem still exist, report it.";
+    err_desc[754] = desc_;
+    desc_.short_desc = "Device name is too long.";
+    desc_.long_desc = " Try to erase flash and restart the loader and if problem still exist, report it.";
+    err_desc[755] = desc_;
+    desc_.short_desc = "Mismatch between archive that is flashed and previously flashed one.";
+    desc_.long_desc = " During previous flashing some fail condition occurs. Re-flash same archive again before try a new one.";
+    err_desc[756] = desc_;
+    desc_.short_desc = "Flash memory device type is not supported.";
+    desc_.long_desc = " Try to use loaders with support for memory device attached to DBB. If loaders does not exist, fire CR in FIDO to get loaders that support that memory.";
+    err_desc[757] = desc_;
+    desc_.short_desc = "Flash physical driver is not configured.";
+    desc_.long_desc = " Check MEMCONF settings in flash archive.";
+    err_desc[758] = desc_;
+    desc_.short_desc = "MEMCONF boot record contain invalid TotalSize field.";
+    desc_.long_desc = " Check MEMCONF settings in flash archive. Very likely flash archive is built for ME with flash device with larger capacity";
+    err_desc[759] = desc_;
+    desc_.short_desc = "Flash archive larger than available space in BDM.";
+    desc_.long_desc = " Check CABS settings in flash archive. Very likely flash archive is built for ME with flash device with larger capacity";
+    err_desc[760] = desc_;
+    desc_.short_desc = "Entry not found in flashlayout file.";
+    desc_.long_desc = "Entry stated in manifest file is not found in flashlayout file. All entries in manifest must be defined in flashlayout file.";
+    err_desc[761] = desc_;
+    desc_.short_desc = "Mismatch between manifest and flash layout.";
+    desc_.long_desc = "Entry start address in manifest and flash layout are not equal.";
+    err_desc[762] = desc_;
+    desc_.short_desc = "SUBTOC is invalid.";
+    desc_.long_desc = "SUBTOC parameters are not valid.";
+    err_desc[763] = desc_;
+    desc_.short_desc = "Reading SUBTOC from flash failed.";
+    desc_.long_desc = "Reading SUBTOC from flash failed.";
+    err_desc[764] = desc_;
+    desc_.short_desc = "Overlapping partitions found in the archive.";
+    desc_.long_desc = "Overlapping partitions found in the archive.";
+    err_desc[765] = desc_;
+    desc_.short_desc = "Partition not found in TOC.";
+    desc_.long_desc = "Partition not found in TOC.";
+    err_desc[766] = desc_;
+    desc_.short_desc = "Flashlayout data equals NULL.";
+    desc_.long_desc = "Flashlayout data equals NULL.";
+    err_desc[767] = desc_;
+    desc_.short_desc = "Invalid TOC type supplied during TOC list creation.";
+    desc_.long_desc = "Loader internal error. Report this issue to loaders team.";
+    err_desc[768] = desc_;
+    desc_.short_desc = "TOC list cannot be created because supplied buffer is empty.";
+    desc_.long_desc = "Input buffer in create TOC list functionality is filled from empty location.";
+    err_desc[769] = desc_;
+    desc_.short_desc = "TOC list cannot be created because supplied buffer contains corrupted data.";
+    desc_.long_desc = " Report this issue to loaders team.";
+    err_desc[770] = desc_;
+    desc_.short_desc = "TOC list cannot be created. Some malicious state occurs.";
+    desc_.long_desc = "Erase flash and try all procedure once again. If problem still exist report it to loaders team.";
+    err_desc[771] = desc_;
+    desc_.short_desc = "TOC list cannot be created. Boot area is empty.";
+    desc_.long_desc = "Flash archive first before using some TOC operations.";
+    err_desc[772] = desc_;
+    desc_.short_desc = "Boot Area not found.";
+    desc_.long_desc = "There is no boot area on flash, nor in the archive you are trying to flash.";
+    err_desc[773] = desc_;
+    desc_.short_desc = "Mismatch between manifest and TOC.";
+    desc_.long_desc = "Entry start address or flash device in manifest are not equal to TOC.";
+    err_desc[774] = desc_;
+    desc_.short_desc = "File too large.";
+    desc_.long_desc = "The file is too large to be placed in the partition. Increase the partition size and try to flash the file again. If problem still exist, report it";
+    err_desc[775] = desc_;
+    desc_.short_desc = "File outside of boot area";
+    desc_.long_desc = "The file is too large to be placed in the boot area.";
+    err_desc[776] = desc_;
+    desc_.short_desc = "Dump outside of flash range";
+    desc_.long_desc = "The requested dump size is outside of the flash range, available flash range is dumped.";
+    err_desc[777] = desc_;
+    desc_.short_desc = "Boot area is not empty. Erasing boot area on a logical level is not allowed.";
+    desc_.long_desc = "Please use physical erase configuration for this command. For more details please consult the user manual.";
+    err_desc[778] = desc_;
+    desc_.short_desc = "Enhanced area is not set";
+    desc_.long_desc = "Archive contains image marked for enhanced area, but enhanced area is not set on eMMC";
+    err_desc[779] = desc_;
+    desc_.short_desc = "Image out of enhanced area";
+    desc_.long_desc = "Image marked for enhanced area has start and/or end address out of enhanced area";
+    err_desc[780] = desc_;
+    desc_.short_desc = "Setting of enhanced area failed";
+    desc_.long_desc = "eMMC driver returned error while setting enhanced area";
+    err_desc[781] = desc_;
+    desc_.short_desc = "Path not exist.";
+    desc_.long_desc = " Verify that supplied path is valid. Repeat operation. Report if problem still exist.";
+    err_desc[951] = desc_;
+    desc_.short_desc = "Failed to close a file in the file system.";
+    desc_.long_desc = " Repeat operation. If still doesn't work reset loader. If that does not resolve problem report it.";
+    err_desc[952] = desc_;
+    desc_.short_desc = "Not enough memory space for desired operation.";
+    desc_.long_desc = " Use Volume Properties command to check if enough memory space exists. Report problem in case of information mismatch.";
+    err_desc[953] = desc_;
+    desc_.short_desc = "Failed to remove a file from the file system.";
+    desc_.long_desc = " Check the access of the file. Repeat operation. If problem still exist possible file system corruption and you need to reset the loader. Report if problem is not solved.";
+    err_desc[954] = desc_;
+    desc_.short_desc = "Failed to rename a file from the file system.";
+    desc_.long_desc = " Check the access of the file. Repeat operation. If problem still exist possible file system corruption and you need to reset the loader. Report if problem is not solved.";
+    err_desc[955] = desc_;
+    desc_.short_desc = "Failed to create a new directory in the file system.";
+    desc_.long_desc = " Use Volume Properties command to check if enough memory space exists. Repeat operation or reset loader. If problem still exist possible file system corruption. Report the problem.";
+    err_desc[956] = desc_;
+    desc_.short_desc = "Failed to remove directory.";
+    desc_.long_desc = " Check the access of the file. Repeat operation. If problem still exist possible file system corruption and you need to reset the loader. Report if problem is not solved.";
+    err_desc[957] = desc_;
+    desc_.short_desc = "No free space left.";
+    desc_.long_desc = " Use Volume Properties command to check if enough memory space exists. Report problem in case of information mismatch.";
+    err_desc[958] = desc_;
+    desc_.short_desc = "Failed to retrieve status data.";
+    desc_.long_desc = " Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[959] = desc_;
+    desc_.short_desc = "Failed to close a directory in the file system.";
+    desc_.long_desc = " Internal error. Possible file system corruption. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[960] = desc_;
+    desc_.short_desc = "Failed to mount volume in the file system.";
+    desc_.long_desc = " Internal error. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[961] = desc_;
+    desc_.short_desc = "Failed to read directory in the file system.";
+    desc_.long_desc = " Check the access of the file and check input parameters. Repeat operation. If problem still exist possible file system corruption and you need to reset the loader. Report if problem is not solved.";
+    err_desc[962] = desc_;
+    desc_.short_desc = "Input/output error.";
+    desc_.long_desc = " Internal error. Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[963] = desc_;
+    desc_.short_desc = "Argument list too long.";
+    desc_.long_desc = " Internal error. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[964] = desc_;
+    desc_.short_desc = "Bad file descriptor.";
+    desc_.long_desc = " Internal error. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[965] = desc_;
+    desc_.short_desc = "Permission denied.";
+    desc_.long_desc = " In order to perform operation first change file access permissions and than repeat operation. Report if problem still exist.";
+    err_desc[966] = desc_;
+    desc_.short_desc = "Bad address.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[967] = desc_;
+    desc_.short_desc = "File exists.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[968] = desc_;
+    desc_.short_desc = "Not a directory.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[969] = desc_;
+    desc_.short_desc = "Is a directory.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[970] = desc_;
+    desc_.short_desc = "File too large.";
+    desc_.long_desc = " Check input parameters. Use Volume Properties command to check if enough memory space exists. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[971] = desc_;
+    desc_.short_desc = "Read-only file system.";
+    desc_.long_desc = " Operation is not allowed.";
+    err_desc[972] = desc_;
+    desc_.short_desc = "Operation not supported.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[973] = desc_;
+    desc_.short_desc = "File name too long.";
+    desc_.long_desc = " Repeat operation with correct input parameters. Report if problem still exist.";
+    err_desc[974] = desc_;
+    desc_.short_desc = "Operation canceled.";
+    desc_.long_desc = " Internal error. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[975] = desc_;
+    desc_.short_desc = "Cannot start operation.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[976] = desc_;
+    desc_.short_desc = "Internal error.";
+    desc_.long_desc = " Reset loader. Report if problem still exist.";
+    err_desc[977] = desc_;
+    desc_.short_desc = "Volume not mounted.";
+    desc_.long_desc = " Requested volume not exist. Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[978] = desc_;
+    desc_.short_desc = "Operation not permitted.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[979] = desc_;
+    desc_.short_desc = "No such file or directory.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[980] = desc_;
+    desc_.short_desc = "Specified FS does not exist.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[981] = desc_;
+    desc_.short_desc = "Error is unknown.";
+    desc_.long_desc = " Internal error. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[982] = desc_;
+    desc_.short_desc = "Failed to write to file.";
+    desc_.long_desc = " Internal error. Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[983] = desc_;
+    desc_.short_desc = "Failed to read from the specified file.";
+    desc_.long_desc = " Internal error. Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[984] = desc_;
+    desc_.short_desc = "The access permission attributes do not allow operation.";
+    desc_.long_desc = " Change the access and repeat operation. If problem still exist possible file system corruption and you need to reset the loader. Report if problem is not solved.";
+    err_desc[985] = desc_;
+    desc_.short_desc = "Can not open the specified file.";
+    desc_.long_desc = " Check input parameters. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[986] = desc_;
+    desc_.short_desc = "Can not stop file system.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[987] = desc_;
+    desc_.short_desc = "File name is too long.";
+    desc_.long_desc = " Correct the file name. Repeat operation or reset loader. Report if problem still exist.";
+    err_desc[988] = desc_;
+    desc_.short_desc = "Can not find elf section.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[989] = desc_;
+    desc_.short_desc = "Unable to mount volume due to exceeding the maximum number of allowed volumes.";
+    desc_.long_desc = "First check the defined number of volumes in the flasharchive. If it is lower than maximum allowed volumes repeat the operation or reset loader. Report if problem still exist ";
+    err_desc[990] = desc_;
+    desc_.short_desc = "Information message that no mounted devices are found.";
+    desc_.long_desc = " This message can be issued in case when is detected that loader is trying to unmount zero mounted devices.";
+    err_desc[991] = desc_;
+    desc_.short_desc = "Index for new command is not founded in execution queue.";
+    desc_.long_desc = " Internal limitation. Wait some time and then try again.";
+    err_desc[1000] = desc_;
+    desc_.short_desc = "Invalid input parameter";
+    desc_.long_desc = " Reset loader. If problem still exist report it.";
+    err_desc[1001] = desc_;
+    desc_.short_desc = "The loader does not support the requested command.";
+    desc_.long_desc = " Check your authentication level. Some command need authentication. Verify that you are sending correct command.";
+    err_desc[1002] = desc_;
+    desc_.short_desc = "The loader does not support the requested group.";
+    desc_.long_desc = " Check your authentication level. Verify that you are sending command from existing group.";
+    err_desc[1003] = desc_;
+    desc_.short_desc = "The size of the command is invalid.";
+    desc_.long_desc = " Check the command payload. If payload is fine, report this problem";
+    err_desc[1051] = desc_;
+    desc_.short_desc = "Too many commands are registered.";
+    desc_.long_desc = " It is not allowed more than 5 commands to be registered.";
+    err_desc[1052] = desc_;
+    desc_.short_desc = "Command has already registered in execution queue.";
+    desc_.long_desc = "It is not allowed the command to be registered more than once in execution queue";
+    err_desc[1053] = desc_;
+    desc_.short_desc = " Command auditing failed.";
+    desc_.long_desc = " You should be authenticate with appropriate permission level in order to execute this command.";
+    err_desc[1054] = desc_;
+    desc_.short_desc = "Timer with the specified index does not exist.";
+    desc_.long_desc = "Internal error.Report this problem";
+    err_desc[1251] = desc_;
+    desc_.short_desc = "Failed to start the timer.";
+    desc_.long_desc = "Internal error. Report this problem";
+    err_desc[1252] = desc_;
+    desc_.short_desc = "Timer initialization failed.";
+    desc_.long_desc = "Internal error. Report this problem";
+    err_desc[1253] = desc_;
+    desc_.short_desc = "Timer interrupt configure failed.";
+    desc_.long_desc = "Internal error. Report this problem";
+    err_desc[1254] = desc_;
+    desc_.short_desc = "GD/GDFS: Error in specifying unit size.";
+    desc_.long_desc = " Check input parameters. Repeat command.";
+    err_desc[1351] = desc_;
+    desc_.short_desc = "GD/GDFS: Size too large for the block.";
+    desc_.long_desc = " Internal error. Check input parameters. Repeat command.";
+    err_desc[1352] = desc_;
+    desc_.short_desc = "GD/GDFS: Write failed on FLASH device level.";
+    desc_.long_desc = " Try to reset the loader and repeat operation. If problem still exist, report it.";
+    err_desc[1353] = desc_;
+    desc_.short_desc = "GD/GDFS: Erase failed on FLASH device level.";
+    desc_.long_desc = " Try to reset the loader and repeat operation. If problem still exist, report it.";
+    err_desc[1354] = desc_;
+    desc_.short_desc = "GD/GDFS: FLASH device unknown.";
+    desc_.long_desc = " Possible error in flash driver configuration. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1355] = desc_;
+    desc_.short_desc = "GD/GDFS: Logical block not found during start-up scan.";
+    desc_.long_desc = " Possible wrong configuration or memory corruption. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1356] = desc_;
+    desc_.short_desc = "GD/GDFS: Duplicate instances of same logical block.";
+    desc_.long_desc = " Internal error or memory corruption. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1357] = desc_;
+    desc_.short_desc = "GD/GDFS: Attempt to erase non-existing physical block.";
+    desc_.long_desc = " Internal error. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1358] = desc_;
+    desc_.short_desc = "GD/GDFS: Requested unit not found, probably never written or has been deleted.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1359] = desc_;
+    desc_.short_desc = "GD/GDFS: Attempt to access a unit outside its beyond its end.";
+    desc_.long_desc = " Check input parameters. Repeat command.";
+    err_desc[1360] = desc_;
+    desc_.short_desc = "GD/GDFS: Attempt to access a logical block that does not exist. (Hardware, fatal).";
+    desc_.long_desc = " Check input parameters. Restart loader and if problem doesn't solved, report it.";
+    err_desc[1361] = desc_;
+    desc_.short_desc = "GD/GDFS: Attempt to access a physical block that does not exist (internal error).";
+    desc_.long_desc = " Reset loader. Report if problem doesn't solved.";
+    err_desc[1362] = desc_;
+    desc_.short_desc = "GD/GDFS: Attempted to write more data to a block than could be placed into one FLASH block.";
+    desc_.long_desc = " Check input parameters. Reset loader and if problem doesn't solved reset loader.";
+    err_desc[1363] = desc_;
+    desc_.short_desc = "GD/GDFS: Internal error (no free blocks are available).";
+    desc_.long_desc = " There's no more space available. Check input parameters and try to repeat same operation. Report if problem does't solved.";
+    err_desc[1364] = desc_;
+    desc_.short_desc = "GD/GDFS: The checksum or a unit being read is wrong.";
+    desc_.long_desc = " Internal error. Try to repeat command. Report if problem still exist.";
+    err_desc[1365] = desc_;
+    desc_.short_desc = "GD/GDFS: Block is not direct.";
+    desc_.long_desc = " Internal error. Try to repeat command. Report if problem still exist.";
+    err_desc[1366] = desc_;
+    desc_.short_desc = "GD/GDFS: For some reason, a free block could not be properly erased.";
+    desc_.long_desc = " Internal error. Try to repeat command and reset loader. Report if problem still exist.";
+    err_desc[1367] = desc_;
+    desc_.short_desc = "GD/GDFS: The size of a unit being written exceeds the maximum limit of a unit.";
+    desc_.long_desc = " Internal error. Try to repeat command and reset loader. Report if problem still exist.";
+    err_desc[1368] = desc_;
+    desc_.short_desc = "GD/GDFS: The startup check found non-FF bytes in unused range within a block.";
+    desc_.long_desc = " Internal error. Try to repeat command and reset loader. Report if problem still exist.";
+    err_desc[1369] = desc_;
+    desc_.short_desc = "GD/GDFS: Failed to synchronize.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1370] = desc_;
+    desc_.short_desc = "GD/GDFS: Tried to access data although GD was in closed state.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1371] = desc_;
+    desc_.short_desc = "GD/GDFS: Operation not allowed in the current mode.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1372] = desc_;
+    desc_.short_desc = "GD/GDFS: Tried to open or format when GD was already opened.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1373] = desc_;
+    desc_.short_desc = "GD/GDFS: The id mark of the GDVAR file does not match the data in the flash. Fatal and makes GD read only.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1374] = desc_;
+    desc_.short_desc = "GD/GDFS: Tried to erase at an address that was not aligned to a flash block boundary. Internal error.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1375] = desc_;
+    desc_.short_desc = "GD/GDFS: The operation may not be performed with the specified size. Tried to write a to large unit.";
+    desc_.long_desc = " Check input parameters. Retry command. If problem doesn't solved reset loader. Report this problem if this not help.";
+    err_desc[1376] = desc_;
+    desc_.short_desc = "GD/GDFS: Operation not allowed. Flash device protected. Possible wrong flash driver configuration.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1377] = desc_;
+    desc_.short_desc = "GD/GDFS: Illegal GD index.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1378] = desc_;
+    desc_.short_desc = "GD/GDFS: Fatal. Failed to allocate dynamic memory.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1379] = desc_;
+    desc_.short_desc = "GD/GDFS: Missing configuration parameter.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1380] = desc_;
+    desc_.short_desc = "GD/GDFS: Illegal configuration.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1381] = desc_;
+    desc_.short_desc = "GD/GDFS: The transaction log used for tracking updates to GD contents is corrupt and prevents roll-back from working properly.";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1382] = desc_;
+    desc_.short_desc = "Error, parameter key not valid.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1383] = desc_;
+    desc_.short_desc = "Error, there is not space enough on memory media to update the parameter area.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1384] = desc_;
+    desc_.short_desc = "Error, no valid CSPSA image found.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1385] = desc_;
+    desc_.short_desc = "Memory media could not be accessed.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1386] = desc_;
+    desc_.short_desc = "Image is read-only.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1387] = desc_;
+    desc_.short_desc = "Error occurred while reading from media.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1388] = desc_;
+    desc_.short_desc = "Error occurred while writing to media.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1389] = desc_;
+    desc_.short_desc = "Represents an undefined value of this enum.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1390] = desc_;
+    desc_.short_desc = "No more parameters, end of data has been reached.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1391] = desc_;
+    desc_.short_desc = "Parameter storage area could not be opened (media error).";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1392] = desc_;
+    desc_.short_desc = "Parameter storage area with same name was already registered.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1393] = desc_;
+    desc_.short_desc = "There was not enough memory to perform the operation.";
+    desc_.long_desc = " Loader internal problem. Report this issue.";
+    err_desc[1394] = desc_;
+    desc_.short_desc = "Error because of bad input parameter.";
+    desc_.long_desc = "Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1395] = desc_;
+    desc_.short_desc = "GD: No data to read.";
+    desc_.long_desc = " Write something to GD before attempting to read from it. Report this problem if you are shore that GD is not empty.";
+    err_desc[1399] = desc_;
+    desc_.short_desc = "BDM: No more garbage collection is possible.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1451] = desc_;
+    desc_.short_desc = "BDM: Unit has already been started.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1452] = desc_;
+    desc_.short_desc = "BDM: Unit has not yet been started.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1453] = desc_;
+    desc_.short_desc = "BDM: Has not been configured yet.";
+    desc_.long_desc = " Check is archive was flashed. If not, flash archive. If problem still exist reset loader and report the problem.";
+    err_desc[1454] = desc_;
+    desc_.short_desc = "BDM: Startup failed.";
+    desc_.long_desc = " Check is archive was flashed. If not, flash archive. If problem still exist reset loader and report the problem.";
+    err_desc[1455] = desc_;
+    desc_.short_desc = "BDM: Shutdown failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1456] = desc_;
+    desc_.short_desc = "BDM: An error occurred while writing.";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1457] = desc_;
+    desc_.short_desc = "BDM: An error occurred while reading";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1458] = desc_;
+    desc_.short_desc = "BDM: An error occurred while erasing.";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1459] = desc_;
+    desc_.short_desc = "BDM: An error occurred while junking.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1460] = desc_;
+    desc_.short_desc = "BDM: An error occurred while garbage collecting.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1461] = desc_;
+    desc_.short_desc = "BDM: An error occurred while retrieving info about a BDM unit.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1462] = desc_;
+    desc_.short_desc = "BDM: Write not supported.";
+    desc_.long_desc = "Writing was attempted when compiled as read-only.";
+    err_desc[1463] = desc_;
+    desc_.short_desc = "BDM: Junk not supported.";
+    desc_.long_desc = "Junking was attempted when compiled as read-only.";
+    err_desc[1464] = desc_;
+    desc_.short_desc = "BDM: Garbage collection not supported.";
+    desc_.long_desc = "Garbage collection was attempted when compiled as read-only.";
+    err_desc[1465] = desc_;
+    desc_.short_desc = "BDM: Synchronize failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1466] = desc_;
+    desc_.short_desc = "BDM: Function not supported.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1467] = desc_;
+    desc_.short_desc = "BDM: Paused.";
+    desc_.long_desc = "Error returned when using os-free code when calling any other method then resume or shutdown when BDM is in the paused state.";
+    err_desc[1468] = desc_;
+    desc_.short_desc = "BDM: Not paused.";
+    desc_.long_desc = "Returned when calling resume when BDM is not in the paused state (In the os-free case).";
+    err_desc[1469] = desc_;
+    desc_.short_desc = "BDM: BAM blocks not found.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1470] = desc_;
+    desc_.short_desc = "BDM: Argument invalid or out of range.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1471] = desc_;
+    desc_.short_desc = "BDM: Formatting failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1472] = desc_;
+    desc_.short_desc = "BDM: The unit number is out of range.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1473] = desc_;
+    desc_.short_desc = "BDM: Some part of the configuration is invalid.";
+    desc_.long_desc = " Possible error in flash archive. Check the archive. Flash the correct archive. Report if problem still exist.";
+    err_desc[1474] = desc_;
+    desc_.short_desc = "BDM: No more preflash blocks can be fetched.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1475] = desc_;
+    desc_.short_desc = "BDM: Termination of preflash failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1476] = desc_;
+    desc_.short_desc = "BDM: Could not allocate enough memory.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1477] = desc_;
+    desc_.short_desc = "BDM XSR: Critical error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1481] = desc_;
+    desc_.short_desc = "BDM XSR: Invalid parameters.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1482] = desc_;
+    desc_.short_desc = "BDM XSR: Could not open partition.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1483] = desc_;
+    desc_.short_desc = "BDM XSR: Unformatted flash.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1484] = desc_;
+    desc_.short_desc = "BDM XSR: Failed to allocate.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1485] = desc_;
+    desc_.short_desc = "BDM XSR: Invalid partition.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1486] = desc_;
+    desc_.short_desc = "BDM XSR: An error occurred while reading.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1487] = desc_;
+    desc_.short_desc = "BDM XSR: An error occurred while writing.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1488] = desc_;
+    desc_.short_desc = "BDM XSR: An error occurred while erasing.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1489] = desc_;
+    desc_.short_desc = "BDM XSR: Device error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1490] = desc_;
+    desc_.short_desc = "BDM XSR: Good block.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1491] = desc_;
+    desc_.short_desc = "BDM XSR: Bad block.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1492] = desc_;
+    desc_.short_desc = "BAM: Is not configured.";
+    desc_.long_desc = " Check is archive was flashed. If not, flash archive. If problem still exist reset loader and report the problem.";
+    err_desc[1551] = desc_;
+    desc_.short_desc = "BAM: Unsupported page size.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1552] = desc_;
+    desc_.short_desc = "BAM: Erase block could not be properly erased.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1553] = desc_;
+    desc_.short_desc = "BAM: Not enough free memory to serve request.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1554] = desc_;
+    desc_.short_desc = "BAM: There was a problem checking if a block was bad or not.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1555] = desc_;
+    desc_.short_desc = "BAM: Reserved block could not be found.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1556] = desc_;
+    desc_.short_desc = "BAM: An error occurred while reading a page in a block.";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1557] = desc_;
+    desc_.short_desc = "BAM: A block went bad and BAM could not mark it as bad properly.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1558] = desc_;
+    desc_.short_desc = "BAM: Read would result in a read beyond end of reserved block.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1559] = desc_;
+    desc_.short_desc = "BAM: An uncorrectable read error occurred while reading block.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1560] = desc_;
+    desc_.short_desc = "BAM: An error occurred while writing a page to a reserved block.";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1561] = desc_;
+    desc_.short_desc = "BAM: An error occurred while writing to a reserved block.";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1562] = desc_;
+    desc_.short_desc = "BAM: There was a problem rescuing a block that went bad during the request.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1563] = desc_;
+    desc_.short_desc = "BAM: No configuration was given.";
+    desc_.long_desc = " Check is archive was flashed. If not, flash archive. If problem still exist reset loader and report the problem.";
+    err_desc[1564] = desc_;
+    desc_.short_desc = "BAM: Has already been started.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1565] = desc_;
+    desc_.short_desc = "BAM: Has not been started yet.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1566] = desc_;
+    desc_.short_desc = "BAM: Requested operation is not supported.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1567] = desc_;
+    desc_.short_desc = "BAM: Internal state has been corrupted.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1568] = desc_;
+    desc_.short_desc = "BAM: The configured media type is not supported.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1569] = desc_;
+    desc_.short_desc = "BAM: Unsupported redundant area size.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1570] = desc_;
+    desc_.short_desc = "BAM: Reading block failed.";
+    desc_.long_desc = " Possible error in flash driver. Try to reset the loader and if problem still exist, report it.";
+    err_desc[1571] = desc_;
+    desc_.short_desc = "BAM: Shutting down failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1572] = desc_;
+    desc_.short_desc = "BAM: An error occurred with uninitializing.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1573] = desc_;
+    desc_.short_desc = "BAM: Invalid offset.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1574] = desc_;
+    desc_.short_desc = "BAM: Invalid size.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1575] = desc_;
+    desc_.short_desc = "BAM: Retrieving info failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1576] = desc_;
+    desc_.short_desc = "BAM: Invalid configuration.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1577] = desc_;
+    desc_.short_desc = "BAM: An error occurred while erasing all blocks.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1578] = desc_;
+    desc_.short_desc = "BAM: Block was marked as bad while doing an operation.";
+    desc_.long_desc = " Repeat operation. If problem still exist reset the loader. Report if the problem is not solved.";
+    err_desc[1579] = desc_;
+    desc_.short_desc = "BAM: Can not assure that start block configuration refers to a block boundary.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1580] = desc_;
+    desc_.short_desc = "BAM: Unable the query FAM about the memory technology used in the memory we are trying to initialize BAM on.";
+    desc_.long_desc = "";
+    err_desc[1581] = desc_;
+    desc_.short_desc = "BAM: Block rescue failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1582] = desc_;
+    desc_.short_desc = "BAM: Failed to determine what BBM type configuration has been written to flash.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1583] = desc_;
+    desc_.short_desc = "BAM: Failed to set the length to use with HW ECC acceleration.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1584] = desc_;
+    desc_.short_desc = "BAM: Invalid BBM type.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1585] = desc_;
+    desc_.short_desc = "BAM: Failed to configure boot block device management.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1586] = desc_;
+    desc_.short_desc = "BAM: Failed to startup boot block device management.";
+    desc_.long_desc = " Possible missing configuration for BDM. Check is archive was flashed. If not, flash archive. If problem still exist reset loader and report the problem.";
+    err_desc[1587] = desc_;
+    desc_.short_desc = "BAM: Boot block device management instance not found.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1588] = desc_;
+    desc_.short_desc = "BAM: Boot block device management blocks not found.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1589] = desc_;
+    desc_.short_desc = "BAM: Boot block device management not started. Requested operation require BDM to be started.";
+    desc_.long_desc = " Internal error. Report the problem.";
+    err_desc[1590] = desc_;
+    desc_.short_desc = "BAM: Unit is out of range.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1591] = desc_;
+    desc_.short_desc = "BAM: Block device management startup failed.";
+    desc_.long_desc = " Possible missing configuration for BDM. Check is archive was flashed. If not, flash archive. If problem still exist reset loader and report the problem.";
+    err_desc[1592] = desc_;
+    desc_.short_desc = "BAM: Block not erased.";
+    desc_.long_desc = " Repeat operation. If problem still exist reset the loader. Report if the problem is not solved.";
+    err_desc[1593] = desc_;
+    desc_.short_desc = "BAM ONLD: Critical error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1601] = desc_;
+    desc_.short_desc = "BAM ONLD: Invalid parameters.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1602] = desc_;
+    desc_.short_desc = "BAM ONLD: Initialization error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1603] = desc_;
+    desc_.short_desc = "BAM ONLD: An error occurred while reading.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1604] = desc_;
+    desc_.short_desc = "BAM ONLD: An error occurred while writing.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1605] = desc_;
+    desc_.short_desc = "BAM ONLD: An error occurred while erasing.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1606] = desc_;
+    desc_.short_desc = "BAM ONLD: Device error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1607] = desc_;
+    desc_.short_desc = "BAM ONLD: Good block.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1608] = desc_;
+    desc_.short_desc = "BAM ONLD: Bad block.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[1609] = desc_;
+    desc_.short_desc = "COPS: Asynchronous call initiated.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1621] = desc_;
+    desc_.short_desc = "COPS: IPC failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1622] = desc_;
+    desc_.short_desc = "COPS: Internal IPC lib error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1623] = desc_;
+    desc_.short_desc = "COPS: Asynchronous IPC is not supported/setup for this function.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1624] = desc_;
+    desc_.short_desc = "COPS: Incorrect arguments for function.";
+    desc_.long_desc = " Check input arguments. Report if problem still exist.";
+    err_desc[1625] = desc_;
+    desc_.short_desc = "COPS: Storage error (read/write flash failed).";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1626] = desc_;
+    desc_.short_desc = "COPS: Failed to allocate memory.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1627] = desc_;
+    desc_.short_desc = "COPS: Unspecified error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1628] = desc_;
+    desc_.short_desc = "COPS: Service not available error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1629] = desc_;
+    desc_.short_desc = "COPS: Error in a service.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1630] = desc_;
+    desc_.short_desc = "COPS: Not authenticated error.";
+    desc_.long_desc = " Perform Authenticate before executing current operation. Report if problem still exist.";
+    err_desc[1631] = desc_;
+    desc_.short_desc = "COPS: No challenge found.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1632] = desc_;
+    desc_.short_desc = "COPS: Signature validation failed.";
+    desc_.long_desc = " This could either be because the challenge was signed with the wrong certificate, or the presented control keys were incorrect.";
+    err_desc[1633] = desc_;
+    desc_.short_desc = "COPS: Data tampered.";
+    desc_.long_desc = " Repeat the operation. Report if problem still exist.";
+    err_desc[1634] = desc_;
+    desc_.short_desc = "COPS: Data configuration error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1635] = desc_;
+    desc_.short_desc = "COPS: SIM card is not OK with SIMLock settings.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1636] = desc_;
+    desc_.short_desc = "COPS: A simlock unlock timer is currently running.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1637] = desc_;
+    desc_.short_desc = "COPS: No simlock unlock attempts left.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1638] = desc_;
+    desc_.short_desc = "COPS: The key is invalid.";
+    desc_.long_desc = " Check the key. Repeat operation. Report if problem still exist.";
+    err_desc[1639] = desc_;
+    desc_.short_desc = "COPS: Internal error.";
+    desc_.long_desc = " Reset loader. Report if problem still exist.";
+    err_desc[1640] = desc_;
+    desc_.short_desc = "COPS: Not allowed to lock a simlock.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1641] = desc_;
+    desc_.short_desc = "COPS: Still unlock attempts left for the lock.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1642] = desc_;
+    desc_.short_desc = "COPS: Message should be routed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1643] = desc_;
+    desc_.short_desc = "COPS: Autolock only allowed during first boot.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1644] = desc_;
+    desc_.short_desc = "COPS: Memory allocation failed.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1651] = desc_;
+    desc_.short_desc = "COPS: Data is tempered.";
+    desc_.long_desc = " Check the file that you want to bind. Repeat operation. Report if problem still exist.";
+    err_desc[1652] = desc_;
+    desc_.short_desc = "COPS: IMEI mismatch.";
+    desc_.long_desc = "IMEI in the OTP differs from the IMEI in the COPS data.";
+    err_desc[1653] = desc_;
+    desc_.short_desc = "COPS: OTP is locked.";
+    desc_.long_desc = "It is not allowed to write in already locked OTP area";
+    err_desc[1654] = desc_;
+    desc_.short_desc = "COPS: Function for calculating MAC is locked down.";
+    desc_.long_desc = " Restart loader. Report if problem still exist.";
+    err_desc[1655] = desc_;
+    desc_.short_desc = "COPS: Authentication failed.";
+    desc_.long_desc = "Be sure that authentication is performed with valid data.(Correct Certificate, Domain, Control Keys)";
+    err_desc[1656] = desc_;
+    desc_.short_desc = "COPS: Default Data is not present.";
+    desc_.long_desc = " Execute Bind Properties command first and than repeat operation. Report if problem still exist.";
+    err_desc[1657] = desc_;
+    desc_.short_desc = "COPS: IMEI update is not allowed.";
+    desc_.long_desc = " Check if IMEI changeable is set in OTP. Report this issue if IMEI changeable is set and requested operation can not be executed.";
+    err_desc[1658] = desc_;
+    desc_.short_desc = "COPS: Locking of SIMLocks is disabled.";
+    desc_.long_desc = "lock is disabled or already locked.";
+    err_desc[1659] = desc_;
+    desc_.short_desc = "COPS: No more attempts for verification left.";
+    desc_.long_desc = " Check the validation of the certificate or control keys.";
+    err_desc[1660] = desc_;
+    desc_.short_desc = "COPS: Control key is not correct.";
+    desc_.long_desc = " Control keys that you try to authenticate and control keys from Default Data mismatch.";
+    err_desc[1661] = desc_;
+    desc_.short_desc = "COPS: Control key is too short.";
+    desc_.long_desc = " Valid length is 8-16 bytes. Repeat operation with valid control keys. Report if problem still exist.";
+    err_desc[1662] = desc_;
+    desc_.short_desc = "COPS: Control key is too long.";
+    desc_.long_desc = "Valid length is 8-16 bytes. Repeat operation with valid control keys. Report if problem still exist.";
+    err_desc[1663] = desc_;
+    desc_.short_desc = "COPS: Control key is not valid.";
+    desc_.long_desc = " Check the control keys. Repeat operation with valid control keys. Report if problem still exist.";
+    err_desc[1664] = desc_;
+    desc_.short_desc = "COPS: Timer is running.";
+    desc_.long_desc = "For the appropriate LockType timer is already running.";
+    err_desc[1665] = desc_;
+    desc_.short_desc = "COPS: SIM error.";
+    desc_.long_desc = "Check that the SIM is active. If the SIM is active be sure that you are entering correct SIM Pin. Report if problem still exist";
+    err_desc[1666] = desc_;
+    desc_.short_desc = "COPS: Locking failed.";
+    desc_.long_desc = "Be sure that the SIM data contains valid data for IMSI, GID1 and GID2";
+    err_desc[1667] = desc_;
+    desc_.short_desc = "COPS: OTA unlock IMEI mismatch.";
+    desc_.long_desc = "IMEI in the OTP differs from the IMEI in the COPS data.";
+    err_desc[1668] = desc_;
+    desc_.short_desc = "COPS: Incorrect IMSI.";
+    desc_.long_desc = "IMSI on interface doesn't match SIM IMSI";
+    err_desc[1669] = desc_;
+    desc_.short_desc = "COPS: Parameter error.";
+    desc_.long_desc = " Check the input parameters. Repeat operation. Report if problem still exist.";
+    err_desc[1670] = desc_;
+    desc_.short_desc = "COPS: Memory buffer is too small.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1671] = desc_;
+    desc_.short_desc = "COPS: Parameter is not allowed.";
+    desc_.long_desc = " Check the input parameters. Repeat operation. Report if problem still exist.";
+    err_desc[1672] = desc_;
+    desc_.short_desc = "COPS: Parameter can not be recognized.";
+    desc_.long_desc = " Check the input parameters. Repeat operation. Report if problem still exist.";
+    err_desc[1673] = desc_;
+    desc_.short_desc = "COPS: Argument error!";
+    desc_.long_desc = " Verify the input parameters. Repeat operation. Report if problem still exist.";
+    err_desc[1674] = desc_;
+    desc_.short_desc = "COPS: Failed to verify internal data.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[1698] = desc_;
+    desc_.short_desc = "COPS: Undefined error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1699] = desc_;
+    desc_.short_desc = "PD NAND: A bit error was detected and corrected.";
+    desc_.long_desc = " Repeat operation. Report if problem still exist.";
+    err_desc[1751] = desc_;
+    desc_.short_desc = "PD NAND: An uncorrectable bit error was detected.";
+    desc_.long_desc = " Repeat operation. Report if problem still exist.";
+    err_desc[1752] = desc_;
+    desc_.short_desc = "PD NAND: The function could not perform the requested operation due to a bad parameter.";
+    desc_.long_desc = " Repeat operation. Report if problem still exist.";
+    err_desc[1753] = desc_;
+    desc_.short_desc = "PD NAND: A hardware error occurred.";
+    desc_.long_desc = " Reset loader. Report if problem still exist.";
+    err_desc[1754] = desc_;
+    desc_.short_desc = "PD NAND: A module internal error has occurred. The module has reach an unexpected state or request.";
+    desc_.long_desc = " Reset loader. Report if problem still exist.";
+    err_desc[1755] = desc_;
+    desc_.short_desc = "PD NAND: Busy flag was returned.";
+    desc_.long_desc = "If T_PD_NAND_CONFIG_FLAG_BLOCKING_MUTEX is not set, a call to NAND PD may return with this busy flag.";
+    err_desc[1756] = desc_;
+    desc_.short_desc = "PD NAND: Attempting to read erased page.";
+    desc_.long_desc = " Repeat operation. Report if problem still exist.";
+    err_desc[1757] = desc_;
+    desc_.short_desc = "PD NAND: Number of valid states of this type.";
+    desc_.long_desc = " Repeat operation. Report if problem still exist.";
+    err_desc[1758] = desc_;
+    desc_.short_desc = "PD NAND: Represents an undefined value of this type.";
+    desc_.long_desc = " Repeat operation. Report if problem still exist.";
+    err_desc[1759] = desc_;
+    desc_.short_desc = "GD/TA: TA base.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1851] = desc_;
+    desc_.short_desc = "GD/TA: Unknown partition.";
+    desc_.long_desc = " Check input parameters. Repeat operation with the correct input parameters. Report if problem still exist.";
+    err_desc[1852] = desc_;
+    desc_.short_desc = "GD/TA: Unknown configuration.";
+    desc_.long_desc = " Possible wrong or missing configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1853] = desc_;
+    desc_.short_desc = "GD/TA: Illogical configuration.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1854] = desc_;
+    desc_.short_desc = "GD/TA: Unknown memory type.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[1855] = desc_;
+    desc_.short_desc = "GD/TA: Wrong parameter.";
+    desc_.long_desc = " Check input parameters. Repeat operation with the correct input parameters. Report if problem still exist.";
+    err_desc[1856] = desc_;
+    desc_.short_desc = "GD/TA: Out of memory.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1857] = desc_;
+    desc_.short_desc = "GD/TA: Invalid address.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1858] = desc_;
+    desc_.short_desc = "GD/TA: Unused address.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1859] = desc_;
+    desc_.short_desc = "GD/TA: Unit not found.";
+    desc_.long_desc = " No data was written in the specified unit. Write data to the unit and than perform read operation. Report if problem still exist.";
+    err_desc[1860] = desc_;
+    desc_.short_desc = "GD/TA: TA is not supported.";
+    desc_.long_desc = "";
+    err_desc[1861] = desc_;
+    desc_.short_desc = "GD/TA: TA fail.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[1862] = desc_;
+    desc_.short_desc = "GD: Unknown unit name.";
+    desc_.long_desc = " Check input parameters. Requested unit is not supported. Repeat operation with the correct input parameters. Report if problem still exist.";
+    err_desc[1863] = desc_;
+    desc_.short_desc = "GD: Last enumeration (last valid + 1).";
+    desc_.long_desc = " Reset loader. If problem doesn't solved report it.";
+    err_desc[1864] = desc_;
+    desc_.short_desc = "Failed to store data in FIFO.";
+    desc_.long_desc = " Reset loader.";
+    err_desc[1900] = desc_;
+    desc_.short_desc = "Failed to set parameters of communications devices.";
+    desc_.long_desc = " Reset loader. If problem does'n solved report it.";
+    err_desc[1951] = desc_;
+    desc_.short_desc = "Failed to store in stack.";
+    desc_.long_desc = " Reset loader. If problem does'n solved report it.";
+    err_desc[1952] = desc_;
+    desc_.short_desc = "The requested file is not found in the specified Zip archive.";
+    desc_.long_desc = " Check ZIP archive. Reset loader. If problem doesn't solved, report it.";
+    err_desc[1954] = desc_;
+    desc_.short_desc = "The requested file is not an elf file.";
+    desc_.long_desc = " Check input parameters. Repeat operation with correct input.";
+    err_desc[1955] = desc_;
+    desc_.short_desc = "Can not open elf section.";
+    desc_.long_desc = " Possible damaged elf file. Retry operation and reset loader. If problem doesn't solved report it.";
+    err_desc[1956] = desc_;
+    desc_.short_desc = "The name of parameter is too long.";
+    desc_.long_desc = " Check input parameters. Retry operation.";
+    err_desc[1957] = desc_;
+    desc_.short_desc = "Error in boot records.";
+    desc_.long_desc = " Some information in boot image doesn't agree. Check software that you flash.";
+    err_desc[1958] = desc_;
+    desc_.short_desc = "Boot record is empty and operation cannot be executed.";
+    desc_.long_desc = " Internal error. Reset loader. If problem doesn't solved, report it.";
+    err_desc[1959] = desc_;
+    desc_.short_desc = "Boot record image is not valid.";
+    desc_.long_desc = " Invalid boot image. Check software that you flash.";
+    err_desc[1960] = desc_;
+    desc_.short_desc = "Boot record has no space to accept new boot record.";
+    desc_.long_desc = " Internal limitation. Report this problem.";
+    err_desc[1961] = desc_;
+    desc_.short_desc = "Boot record not exist.";
+    desc_.long_desc = " The boot record with that ID is never written.";
+    err_desc[1962] = desc_;
+    desc_.short_desc = "Writing failed.";
+    desc_.long_desc = " The boot record with that ID was not written.";
+    err_desc[1963] = desc_;
+    desc_.short_desc = "Boot record data is unaligned.";
+    desc_.long_desc = " For successfully writing in flash boot record must be a multiple of four bytes.";
+    err_desc[1964] = desc_;
+    desc_.short_desc = "Content type to long.";
+    desc_.long_desc = " Check manifest file from flash archive. Repeat operation with correct flash archive. Report if problem still exist.";
+    err_desc[1965] = desc_;
+    desc_.short_desc = "Device type to long.";
+    desc_.long_desc = " Check manifest file from flash archive. Repeat operation with correct flash archive. Report if problem still exist.";
+    err_desc[1966] = desc_;
+    desc_.short_desc = "Number of target devices to big.";
+    desc_.long_desc = "Internal error. Reset the loader. Report if problem still exist.";
+    err_desc[1967] = desc_;
+    desc_.short_desc = "Description field too long.";
+    desc_.long_desc = "Internal error. Reset the loader. Report if problem still exist.";
+    err_desc[1968] = desc_;
+    desc_.short_desc = "Testing this module currently not supported in ADbg.";
+    desc_.long_desc = " Check the module number and try again.";
+    err_desc[2000] = desc_;
+    desc_.short_desc = "There isn't any module available for testing.";
+    desc_.long_desc = "  Use List Cases command to see available modules for testing.";
+    err_desc[2001] = desc_;
+    desc_.short_desc = "Specified case can not be found.";
+    desc_.long_desc = " Use List Cases command to see available test cases.";
+    err_desc[2002] = desc_;
+    desc_.short_desc = "There isn't any test cases in specified module.";
+    desc_.long_desc = " Use List Cases command to see available test cases.";
+    err_desc[2003] = desc_;
+    desc_.short_desc = "Specified internal group can not be found.";
+    desc_.long_desc = " Use List Interface command to see available internal groups.";
+    err_desc[2004] = desc_;
+    desc_.short_desc = "There isn't any internal group.";
+    desc_.long_desc = "Use List Interface command to see if is any available internal group.";
+    err_desc[2005] = desc_;
+    desc_.short_desc = "Specified interface function cannot be found.";
+    desc_.long_desc = " Use List Interface command to see if specified internal function exist.";
+    err_desc[2006] = desc_;
+    desc_.short_desc = "There isn't any interface function in interface group.";
+    desc_.long_desc = " Use List Interface command to see if there's any available internal function.";
+    err_desc[2007] = desc_;
+    desc_.short_desc = "Request for setting precondition that is already set.";
+    desc_.long_desc = " Precondition is already set. If you want to change it, recover precondition, and than set it again.";
+    err_desc[2008] = desc_;
+    desc_.short_desc = "Request to recover condition that is not changed.";
+    desc_.long_desc = " You cannot recover condition that is not set before. There's no need of any further activities in order to resolve this problem. Loader will work fine.";
+    err_desc[2009] = desc_;
+    desc_.short_desc = "Failed to initialize OTD driver.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2100] = desc_;
+    desc_.short_desc = "Failed to read data from OTP.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2101] = desc_;
+    desc_.short_desc = "Failed to write data in OTP.";
+    desc_.long_desc = " Internal error.Possible hardware malfunction. Please report this problem immediately";
+    err_desc[2102] = desc_;
+    desc_.short_desc = "Trying to write invalid CID in OTP.";
+    desc_.long_desc = " The value for CID must be in the range from 19 to 16384.0 value is also allowed CID value";
+    err_desc[2103] = desc_;
+    desc_.short_desc = "Failed to initialize OTD logical driver.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2104] = desc_;
+    desc_.short_desc = "Requested OTP area is already locked.";
+    desc_.long_desc = " It is not allowed to write in already locked OTP area";
+    err_desc[2105] = desc_;
+    desc_.short_desc = "App property cannot be found.";
+    desc_.long_desc = "If specified property cannot be found by COPS module.";
+    err_desc[2251] = desc_;
+    desc_.short_desc = "IMEI not changeable.";
+    desc_.long_desc = "If user try to change IMEI in COPS while IMEI is set as non - changeable in OTP area.";
+    err_desc[2252] = desc_;
+    desc_.short_desc = "Security operation denied.";
+    desc_.long_desc = "If some security operation cannot be accomplished due to various reasons.";
+    err_desc[2253] = desc_;
+    desc_.short_desc = "Incorrect Boot Stage Parameter vector.";
+    desc_.long_desc = ".";
+    err_desc[2254] = desc_;
+    desc_.short_desc = "Critical error in ROM has occurred.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[2255] = desc_;
+    desc_.short_desc = "Unexpected ROM error.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[2256] = desc_;
+    desc_.short_desc = "ROM Patch is already installed.";
+    desc_.long_desc = "If you are trying to install flash patch ,please make sure that version of ROM patch is greater than already installed. Reinstallation of OTP patch is not allowed.";
+    err_desc[2257] = desc_;
+    desc_.short_desc = "Operation successful.";
+    desc_.long_desc = " ROM Patch in Flash is successfully reinstalled.";
+    err_desc[2258] = desc_;
+    desc_.short_desc = "RootKey is already installed.";
+    desc_.long_desc = ".Please make sure that version of Root key is the same with already installed";
+    err_desc[2259] = desc_;
+    desc_.short_desc = "Operation successful.";
+    desc_.long_desc = " Root Key is successfully reinstalled.";
+    err_desc[2260] = desc_;
+    desc_.short_desc = "TA: Unknown partition.";
+    desc_.long_desc = " Check input parameters. Repeat operation with the correct input parameters. Report if problem still exist.";
+    err_desc[2351] = desc_;
+    desc_.short_desc = "TA: Configuration error.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[2352] = desc_;
+    desc_.short_desc = "TA: Unsupported memory type.";
+    desc_.long_desc = " Possible wrong configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[2353] = desc_;
+    desc_.short_desc = "TA: Wrong parameter.";
+    desc_.long_desc = " Check input parameters. Repeat operation with the correct input parameters. Report if problem still exist.";
+    err_desc[2354] = desc_;
+    desc_.short_desc = "TA: No heap memory left.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2355] = desc_;
+    desc_.short_desc = "TA: Invalid address.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2356] = desc_;
+    desc_.short_desc = "TA: Unused address.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2357] = desc_;
+    desc_.short_desc = "TA: Unit was not found.";
+    desc_.long_desc = " No data was written in the specified unit. Write data to the unit and than perform read operation. Report if problem still exist.";
+    err_desc[2358] = desc_;
+    desc_.short_desc = "TA: Wrong size when reading unit.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[2359] = desc_;
+    desc_.short_desc = "TA: Not enough space to flush the Trim Area.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist";
+    err_desc[2360] = desc_;
+    desc_.short_desc = "TA: Unknown partition.";
+    desc_.long_desc = " Check input parameters. Repeat operation with the correct input parameters. Report if problem still exist.";
+    err_desc[2361] = desc_;
+    desc_.short_desc = "TA: Fail.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[2362] = desc_;
+    desc_.short_desc = "TA: Media error.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[2460] = desc_;
+    desc_.short_desc = "TA: Error occurs during configuration.";
+    desc_.long_desc = " Possible wrong or missing configuration in flash archive. Check the archive. Flash the correct archive. If problem still exist report the problem.";
+    err_desc[2461] = desc_;
+    desc_.short_desc = "Request for change operation denied.";
+    desc_.long_desc = " Init request is twice called and state is changed. Should be sent Update request then can be used Init request again.";
+    err_desc[2500] = desc_;
+    desc_.short_desc = "Requested change operation is not supported.";
+    desc_.long_desc = " Use the implemented change operation.";
+    err_desc[2501] = desc_;
+    desc_.short_desc = "PD CFI: The operation is in progress. Additional poll calls must be done.";
+    desc_.long_desc = "";
+    err_desc[2651] = desc_;
+    desc_.short_desc = "PD CFI: Type not recognized.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[2652] = desc_;
+    desc_.short_desc = "PD CFI: Operation could not be completed because of a hardware malfunction.";
+    desc_.long_desc = " It is possible that part of the operation has been carried out.";
+    err_desc[2653] = desc_;
+    desc_.short_desc = "PD CFI: The driver does not implement the requested function.";
+    desc_.long_desc = " Internal error. Report the problem.";
+    err_desc[2654] = desc_;
+    desc_.short_desc = "PD CFI: Invalid parameter value.";
+    desc_.long_desc = " Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[2655] = desc_;
+    desc_.short_desc = "PD CFI: The requested flash address is protected from the requested type of access.";
+    desc_.long_desc = " Check input parameters. Repeat operation. Report if problem still exist.";
+    err_desc[2656] = desc_;
+    desc_.short_desc = "PD CFI: Flash devices not supported by this driver.";
+    desc_.long_desc = "Possible hardware malfunction, or error in HW configuration.Reset loader,report if problem still exist. ";
+    err_desc[2657] = desc_;
+    desc_.short_desc = "PD CFI: Requested operation was not suspended as it has completed.";
+    desc_.long_desc = "Operation is completed.";
+    err_desc[2658] = desc_;
+    desc_.short_desc = "PD CFI: NOR memory was not detected on current configuration.";
+    desc_.long_desc = "NOR memory is not present or some hardware malfunction occurred.";
+    err_desc[2659] = desc_;
+    desc_.short_desc = "General Error.";
+    desc_.long_desc = "It is possible to failed to initialize the communication device.Reset loader.Report if problem still exist";
+    err_desc[2701] = desc_;
+    desc_.short_desc = "Invalid arguments.";
+    desc_.long_desc = ".Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[2702] = desc_;
+    desc_.short_desc = "Implementation is removed.";
+    desc_.long_desc = " Implementation it is not supported anymore.";
+    err_desc[2703] = desc_;
+    desc_.short_desc = "HSI internal error.";
+    desc_.long_desc = "Buffer with unaligned length is requested to be transfered or device driver is configured to use unsupported frame size.";
+    err_desc[2704] = desc_;
+    desc_.short_desc = "Communication device is busy.";
+    desc_.long_desc = "Current transfer is not finished.";
+    err_desc[2705] = desc_;
+    desc_.short_desc = "Signal error.";
+    desc_.long_desc = "Simultaneous data and flag transaction.";
+    err_desc[2751] = desc_;
+    desc_.short_desc = "Timeout error.";
+    desc_.long_desc = "Incorrect number of bits received.";
+    err_desc[2752] = desc_;
+    desc_.short_desc = "Break received.";
+    desc_.long_desc = ".Reset loader.Report if problem still exist.";
+    err_desc[2753] = desc_;
+    desc_.short_desc = "Receive buffer is not provided.";
+    desc_.long_desc = "Reset loader.Report if problem still exist.";
+    err_desc[2754] = desc_;
+    desc_.short_desc = "Transmit buffer is not provided.";
+    desc_.long_desc = "Reset loader.Report if problem still exist.";
+    err_desc[2755] = desc_;
+    desc_.short_desc = "Invalid state for communication relay detected.";
+    desc_.long_desc = "Wrong value passed as state for the communication relay and hence it can't be used. Try setting some of predefined communication relay states.";
+    err_desc[2850] = desc_;
+    desc_.short_desc = "Communication Relay is not running.";
+    desc_.long_desc = "Communication relay is set in error state or it is not configured properly. Check the relay state. If error occurred restart the loader, otherwise try reconfiguring the relay.";
+    err_desc[2851] = desc_;
+    desc_.short_desc = "General Error.";
+    desc_.long_desc = "It is possible to failed to initialize the communication device.Reset loader.Report if problem still exist";
+    err_desc[2901] = desc_;
+    desc_.short_desc = "Invalid arguments.";
+    desc_.long_desc = ".Check input parameters. Retry operation. If problem still exist reset loader. Report if problem doesn't solved.";
+    err_desc[2902] = desc_;
+    desc_.short_desc = "Implementation is removed.";
+    desc_.long_desc = " Implementation it is not supported anymore.";
+    err_desc[2903] = desc_;
+    desc_.short_desc = "SDIO internal error.";
+    desc_.long_desc = "Buffer with unaligned length is requested to be transfered or device driver is configured to use unsupported frame size.";
+    err_desc[2904] = desc_;
+    desc_.short_desc = "Communication device is busy.";
+    desc_.long_desc = "Current transfer is not finished.";
+    err_desc[2905] = desc_;
+    desc_.short_desc = "Timeout error.";
+    desc_.long_desc = "Incorrect number of bits received.";
+    err_desc[2951] = desc_;
+    desc_.short_desc = "Break received.";
+    desc_.long_desc = ".Reset loader.Report if problem still exist.";
+    err_desc[2952] = desc_;
+    desc_.short_desc = "Receive buffer is not provided.";
+    desc_.long_desc = "Reset loader.Report if problem still exist.";
+    err_desc[2953] = desc_;
+    desc_.short_desc = "Transmit buffer is not provided.";
+    desc_.long_desc = "Reset loader.Report if problem still exist.";
+    err_desc[2954] = desc_;
+    desc_.short_desc = "The handle supplied to BAM is invalid.";
+    desc_.long_desc = ".";
+    err_desc[3051] = desc_;
+    desc_.short_desc = "The instance if BAM has already been initialized.";
+    desc_.long_desc = ".";
+    err_desc[3052] = desc_;
+    desc_.short_desc = "BAM configuration is invalid.";
+    desc_.long_desc = ".";
+    err_desc[3053] = desc_;
+    desc_.short_desc = "One of the parameter passed to BAM makes no sense.";
+    desc_.long_desc = ".";
+    err_desc[3054] = desc_;
+    desc_.short_desc = "BAM could not allocate enough memory to complete the operation.";
+    desc_.long_desc = ".";
+    err_desc[3055] = desc_;
+    desc_.short_desc = "BAM could not locate the requested image/partition.";
+    desc_.long_desc = ".";
+    err_desc[3056] = desc_;
+    desc_.short_desc = "An image with the same ID has already been written.";
+    desc_.long_desc = ".";
+    err_desc[3057] = desc_;
+    desc_.short_desc = "BAM could not complete the operation due to insufficient storage space.";
+    desc_.long_desc = ".";
+    err_desc[3058] = desc_;
+    desc_.short_desc = "A TOC entry specifies a location outside the area.";
+    desc_.long_desc = ".";
+    err_desc[3059] = desc_;
+    desc_.short_desc = "The TOC passed to BAM was detected as corrupt.";
+    desc_.long_desc = ".";
+    err_desc[3060] = desc_;
+    desc_.short_desc = "An area found in the TOC or passed to BAM is invalid.";
+    desc_.long_desc = ".";
+    err_desc[3061] = desc_;
+    desc_.short_desc = "The instance or update mode of BAM has not been initialized.";
+    desc_.long_desc = ".";
+    err_desc[3062] = desc_;
+    desc_.short_desc = "BAM was unable to perform the operation due to failure in HW.";
+    desc_.long_desc = ".";
+    err_desc[3063] = desc_;
+    desc_.short_desc = "The BAM state is corrupt.";
+    desc_.long_desc = ".";
+    err_desc[3064] = desc_;
+    desc_.short_desc = "The operation is not allowed.";
+    desc_.long_desc = ".";
+    err_desc[3065] = desc_;
+    desc_.short_desc = "An Operation towards the FileSystem return an unexpected result.";
+    desc_.long_desc = ".";
+    err_desc[3066] = desc_;
+    desc_.short_desc = "BAM state files in the FS is not in the expected state.";
+    desc_.long_desc = ".";
+    err_desc[3067] = desc_;
+    desc_.short_desc = "The hash callback function failed unexpectedly.";
+    desc_.long_desc = ".";
+    err_desc[3068] = desc_;
+    desc_.short_desc = "An update is already in progress.";
+    desc_.long_desc = ".";
+    err_desc[3069] = desc_;
+    desc_.short_desc = "The supplied buffer is to small.The image will not be written.";
+    desc_.long_desc = ".";
+    err_desc[3070] = desc_;
+    desc_.short_desc = "An external error occurred.";
+    desc_.long_desc = ".";
+    err_desc[3071] = desc_;
+    desc_.short_desc = "The requested function is not compiled into the loadmodule that supplies the service.";
+    desc_.long_desc = ".";
+    err_desc[3072] = desc_;
+    desc_.short_desc = "The state in the flash prevents BAM from performing any updates.";
+    desc_.long_desc = ".";
+    err_desc[3073] = desc_;
+    desc_.short_desc = "Invalid input parameters.";
+    desc_.long_desc = "The verification of ChipID list failed.";
+    err_desc[4000] = desc_;
+    desc_.short_desc = "Invalid input parameters.";
+    desc_.long_desc = "The function that was called did not have correct parameters passed.";
+    err_desc[4096] = desc_;
+    desc_.short_desc = "Failure.";
+    desc_.long_desc = "Some unexpected error occurs.Reset the loader.If problem does'n solved report it";
+    err_desc[4120] = desc_;
+    desc_.short_desc = "hash list verification failed.";
+    desc_.long_desc = "The verification of hash list in Loader Security Library failed.";
+    err_desc[4121] = desc_;
+    desc_.short_desc = "Header verification failed. ";
+    desc_.long_desc = "The verification of the header has failed.";
+    err_desc[4122] = desc_;
+    desc_.short_desc = "Successful verification of the header";
+    desc_.long_desc = "Successful verification of the header.";
+    err_desc[4123] = desc_;
+    desc_.short_desc = "Unsuccessful verification.";
+    desc_.long_desc = " Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4124] = desc_;
+    desc_.short_desc = "The security library init function has been called 2 times.";
+    desc_.long_desc = "Restart the loader.";
+    err_desc[4150] = desc_;
+    desc_.short_desc = "Memory release failed.";
+    desc_.long_desc = "Restart the loader.";
+    err_desc[4180] = desc_;
+    desc_.short_desc = "Memory allocation failed.";
+    desc_.long_desc = "Restart the loader.";
+    err_desc[4181] = desc_;
+    desc_.short_desc = "Data block exist in the linked list.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4182] = desc_;
+    desc_.short_desc = "Data block do not exist in the linked list.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4183] = desc_;
+    desc_.short_desc = "Invalid authentication type.";
+    desc_.long_desc = " Try to use the appropriate authentication type (control key or CA certificate).";
+    err_desc[4184] = desc_;
+    desc_.short_desc = "Exceeded number of authentication. Loader will be shut downed.";
+    desc_.long_desc = "Restart the loader and use the correct control keys or CA certificate to authenticate.";
+    err_desc[4185] = desc_;
+    desc_.short_desc = "Initialization of ESB block for MAC calculation failed.";
+    desc_.long_desc = "Possible error in hardware configuration, or hardware malfunction.Reset loader. Report if problem still exist.";
+    err_desc[4186] = desc_;
+    desc_.short_desc = "MAC update with ESB block failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4187] = desc_;
+    desc_.short_desc = "MAC finalize with ESB block failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4188] = desc_;
+    desc_.short_desc = "MAC verification with ESB block failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4189] = desc_;
+    desc_.short_desc = "ESB downlock failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4190] = desc_;
+    desc_.short_desc = "Control key verification failed.";
+    desc_.long_desc = " Verify that authentication is performed with correct control keys, otherwise report this error.";
+    err_desc[4191] = desc_;
+    desc_.short_desc = "CA certificate verification failed.";
+    desc_.long_desc = "Verify that CA certificate which is used is valid and appropriate for the HW on which authentication is performed,otherwise report this error.";
+    err_desc[4192] = desc_;
+    desc_.short_desc = "X509 certificate error.";
+    desc_.long_desc = "An error occurred while parsing X.509 certificate. Check that certificate structure is valid.";
+    err_desc[4193] = desc_;
+    desc_.short_desc = "COPS initialization failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4194] = desc_;
+    desc_.short_desc = "COPS protect data initialization failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4195] = desc_;
+    desc_.short_desc = "COPS data read failed.";
+    desc_.long_desc = "Verify that Bind properties is already performed. Report if problem still exist.";
+    err_desc[4196] = desc_;
+    desc_.short_desc = "COPS data write failed.";
+    desc_.long_desc = "Verify that the data is correct and flash is not corrupted. Report if problem still exist.";
+    err_desc[4197] = desc_;
+    desc_.short_desc = "Reading OTP data failed.";
+    desc_.long_desc = "Internal error.Please reset the loader and try again.Please report if problem still exist.";
+    err_desc[4198] = desc_;
+    desc_.short_desc = "Writing OTP data failed.";
+    desc_.long_desc = "Internal error. Possible hardware malfunction. Please report this problem immediately.";
+    err_desc[4199] = desc_;
+    desc_.short_desc = "Locking OTP data failed.";
+    desc_.long_desc = "Internal error.Possible hardware malfunction. Please report this problem immediately.";
+    err_desc[4200] = desc_;
+    desc_.short_desc = "Unpacking IMEI data failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist";
+    err_desc[4201] = desc_;
+    desc_.short_desc = "Packing IMEI data failed.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist>";
+    err_desc[4202] = desc_;
+    desc_.short_desc = "OTP is already locked.";
+    desc_.long_desc = "You are not allowed to write in already locked OTP area.";
+    err_desc[4203] = desc_;
+    desc_.short_desc = "CID value is out of range.";
+    desc_.long_desc = "The value for CID must be in the range from 19 to 16384.0 value is also allowed CID value.";
+    err_desc[4204] = desc_;
+    desc_.short_desc = "OTP lock bits have different values.";
+    desc_.long_desc = "Reset loader. Report if problem still exist";
+    err_desc[4205] = desc_;
+    desc_.short_desc = "Failed to write in boot records.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist";
+    err_desc[4206] = desc_;
+    desc_.short_desc = "No debug hardware detected.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist";
+    err_desc[4207] = desc_;
+    desc_.short_desc = "Requested change operation is not supported or not allowed.";
+    desc_.long_desc = "Check the authentication level and try again. Report if problem still exist";
+    err_desc[4208] = desc_;
+    desc_.short_desc = "Invalid change operation.";
+    desc_.long_desc = "Internal error. Reset loader. Report if problem still exist.";
+    err_desc[4209] = desc_;
+    desc_.short_desc = "Re-writable IMEI is not allowed to change.";
+    desc_.long_desc = "Check if IMEI changeable is set in OTP. Report this issue if IMEI changeable is set and requested operation can not be executed.";
+    err_desc[4210] = desc_;
+    desc_.short_desc = "Request for change operation is denied.";
+    desc_.long_desc = "Check the authentication level and try again. Report if problem still exist";
+    err_desc[4211] = desc_;
+    desc_.short_desc = "Boot record do not exist.";
+    desc_.long_desc = "If boot block is corrupted or do not exist, processFile command should be used to flash the new boot record or recovery domain data to generate the boot record template.";
+    err_desc[4212] = desc_;
+    desc_.short_desc = "Corrupted or do not exist domain data in boot block.";
+    desc_.long_desc = "If domain data are corrupted or do not exist should be use the bind properties command or recover domain data to generate the new domain data.";
+    err_desc[4213] = desc_;
+    desc_.short_desc = "Invalid domain.";
+    desc_.long_desc = "Select appropriated domain.";
+    err_desc[4214] = desc_;
+    desc_.short_desc = "Invalid challenge data block.";
+    desc_.long_desc = "Verify that challenge data block is created properly.";
+    err_desc[4215] = desc_;
+    desc_.short_desc = "Not allowed operation on NoDebug HW.";
+    desc_.long_desc = "Current operation can be executed only on Debug HW.";
+    err_desc[4216] = desc_;
+    desc_.short_desc = "UART FIFO overflow.";
+    desc_.long_desc = " Reset loader. Report if problem still exist.";
+    err_desc[4300] = desc_;
+    desc_.short_desc = "UART FIFO underflow.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[4301] = desc_;
+    desc_.short_desc = "Null pointer to Object.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[4302] = desc_;
+    desc_.short_desc = "Pointer is not NULL.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[4303] = desc_;
+    desc_.short_desc = "The state in the State Machine is invalid.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[4304] = desc_;
+    desc_.short_desc = "The provided manufacturer ID is not valid.";
+    desc_.long_desc = "Possible error in HW configuration. Try to reset the loader and if problem still exist, report it.";
+    err_desc[4305] = desc_;
+    desc_.short_desc = "The provided device ID is not valid.";
+    desc_.long_desc = "Possible error in HW configuration. Try to reset the loader and if problem still exist, report it.";
+    err_desc[4306] = desc_;
+    desc_.short_desc = "Something wrong with the A01 file containing the flash image.";
+    desc_.long_desc = "Verify that the flash image is valid, otherwise report the problem. ";
+    err_desc[4308] = desc_;
+    desc_.short_desc = "Buffer holding the data from the A01 file is full.";
+    desc_.long_desc = "Reset loader. Report if problem still exist.";
+    err_desc[4309] = desc_;
+    desc_.short_desc = "Configuration file for the emulator is not specified.";
+    desc_.long_desc = " The loader will start with the default settings.";
+    err_desc[4350] = desc_;
+    desc_.short_desc = "Operation successful.";
+    desc_.long_desc = ".";
+    err_desc[5000] = desc_;
+    desc_.short_desc = "The property is not supported.";
+    desc_.long_desc = "The selected property is not supported by the loader.";
+    err_desc[5001] = desc_;
+    desc_.short_desc = "The property is read only.";
+    desc_.long_desc = ".";
+    err_desc[5002] = desc_;
+    desc_.short_desc = "The property value is invalid.";
+    desc_.long_desc = ".Property value does not exist.";
+    err_desc[5003] = desc_;
+    desc_.short_desc = "Authentication declined. The ME is automatically shut down after sending this.";
+    desc_.long_desc = ".";
+    err_desc[5004] = desc_;
+    desc_.short_desc = "The authentication type is not supported.";
+    desc_.long_desc = ".";
+    err_desc[5005] = desc_;
+    desc_.short_desc = "Failed to allocate memory.";
+    desc_.long_desc = "Internal error. Reset loader. If problem doesn't solved, report it.";
+    err_desc[5006] = desc_;
+    desc_.short_desc = "Invalid time specified.";
+    desc_.long_desc = "Specify the correct time.";
+    err_desc[5007] = desc_;
+    desc_.short_desc = "Unknown property id.";
+    desc_.long_desc = "Check if property id exists.";
+    err_desc[5008] = desc_;
+    desc_.short_desc = "Failed to start the AAIF in the loader on loader.";
+    desc_.long_desc = ".";
+    err_desc[5009] = desc_;
+    desc_.short_desc = "Unsupported command.";
+    desc_.long_desc = "This command is not supported.";
+    err_desc[5010] = desc_;
+    desc_.short_desc = "Pointer not aligned.";
+    desc_.long_desc = "Internal error. Reset loader.";
+    err_desc[5011] = desc_;
+    desc_.short_desc = "Writing of the boot record failed.";
+    desc_.long_desc = ".";
+    err_desc[5012] = desc_;
+    desc_.short_desc = "String data length is invalid.";
+    desc_.long_desc = "Check if input parameters are in the correct format.";
+    err_desc[5013] = desc_;
+    desc_.short_desc = "Unknown command group.";
+    desc_.long_desc = "The command group is not supported. Check the command documentation.";
+    err_desc[5014] = desc_;
+    desc_.short_desc = "Read OTP failed.";
+    desc_.long_desc = "Reset loader. If problem doesn't solved, report it.";
+    err_desc[5015] = desc_;
+    desc_.short_desc = "Specified command is not implemented.";
+    desc_.long_desc = ".";
+    err_desc[5016] = desc_;
+    desc_.short_desc = "Failed to get ASIC COPS setting.";
+    desc_.long_desc = ".";
+    err_desc[5017] = desc_;
+    desc_.short_desc = "Failed to set platform properties.";
+    desc_.long_desc = "Restart loader, if the problem still exists report it.";
+    err_desc[5018] = desc_;
+    desc_.short_desc = "Memory fail.";
+    desc_.long_desc = "Restart loader, if the problem still exists report it.";
+    err_desc[5019] = desc_;
+    desc_.short_desc = "JTAG unlock fail.";
+    desc_.long_desc = ".";
+    err_desc[5020] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5021] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5022] = desc_;
+    desc_.short_desc = "Failed to initialize COPS library.";
+    desc_.long_desc = "Restart loader, if the problem still exists report it.";
+    err_desc[5023] = desc_;
+    desc_.short_desc = "OTP security error.";
+    desc_.long_desc = ".";
+    err_desc[5024] = desc_;
+    desc_.short_desc = "I2C bus security error.";
+    desc_.long_desc = ".";
+    err_desc[5025] = desc_;
+    desc_.short_desc = "Can't get static data.";
+    desc_.long_desc = ".";
+    err_desc[5026] = desc_;
+    desc_.short_desc = "Failed to store MAC in boot image.";
+    desc_.long_desc = ".";
+    err_desc[5027] = desc_;
+    desc_.short_desc = "General COPS error.";
+    desc_.long_desc = ".";
+    err_desc[5028] = desc_;
+    desc_.short_desc = "Hash verification failed.";
+    desc_.long_desc = ".";
+    err_desc[5029] = desc_;
+    desc_.short_desc = "Failed to read hash.";
+    desc_.long_desc = ".";
+    err_desc[5030] = desc_;
+    desc_.short_desc = "Processors handshake failed.";
+    desc_.long_desc = ".";
+    err_desc[5031] = desc_;
+    desc_.short_desc = "Invalid memconfig in boot image.";
+    desc_.long_desc = ".";
+    err_desc[5032] = desc_;
+    desc_.short_desc = "Boot image signature failed.";
+    desc_.long_desc = ".";
+    err_desc[5033] = desc_;
+    desc_.short_desc = "Failed to read image.";
+    desc_.long_desc = ".";
+    err_desc[5034] = desc_;
+    desc_.short_desc = "Failed to allocate memory.";
+    desc_.long_desc = ".";
+    err_desc[5035] = desc_;
+    desc_.short_desc = "Boot image invalid parameters.";
+    desc_.long_desc = ".";
+    err_desc[5036] = desc_;
+    desc_.short_desc = "Boot image has invalid length.";
+    desc_.long_desc = ".";
+    err_desc[5037] = desc_;
+    desc_.short_desc = "Header size is zero.";
+    desc_.long_desc = ".";
+    err_desc[5038] = desc_;
+    desc_.short_desc = "The flash device was protected.";
+    desc_.long_desc = ".";
+    err_desc[5039] = desc_;
+    desc_.short_desc = "The last write process was suspended.";
+    desc_.long_desc = ".";
+    err_desc[5040] = desc_;
+    desc_.short_desc = "The voltage range is invalid.";
+    desc_.long_desc = ".";
+    err_desc[5041] = desc_;
+    desc_.short_desc = "Failed to write to the flash device.";
+    desc_.long_desc = ".";
+    err_desc[5042] = desc_;
+    desc_.short_desc = "Failed to erase a block in the flash device.";
+    desc_.long_desc = ".";
+    err_desc[5043] = desc_;
+    desc_.short_desc = "The erase process was suspended.";
+    desc_.long_desc = ".";
+    err_desc[5044] = desc_;
+    desc_.short_desc = "The sequence of the flash commands was invalid.";
+    desc_.long_desc = ".";
+    err_desc[5045] = desc_;
+    desc_.short_desc = "Operation was not supported in flashdriver.";
+    desc_.long_desc = ".";
+    err_desc[5046] = desc_;
+    desc_.short_desc = "Invalid in-parameter specified when reading/writing to flash.";
+    desc_.long_desc = ".";
+    err_desc[5047] = desc_;
+    desc_.short_desc = "No flash device was found on the physical address.";
+    desc_.long_desc = ".";
+    err_desc[5048] = desc_;
+    desc_.short_desc = "Configuration error of flash device.";
+    desc_.long_desc = ".";
+    err_desc[5049] = desc_;
+    desc_.short_desc = "Invalid start address of the parameter.";
+    desc_.long_desc = ".";
+    err_desc[5050] = desc_;
+    desc_.short_desc = "Invalid physical address of the parameter.";
+    desc_.long_desc = ".";
+    err_desc[5051] = desc_;
+    desc_.short_desc = "The data length of the parameter is invalid.";
+    desc_.long_desc = ".";
+    err_desc[5052] = desc_;
+    desc_.short_desc = "Invalid flash region specified.";
+    desc_.long_desc = ".";
+    err_desc[5053] = desc_;
+    desc_.short_desc = "A buffer was NULL.";
+    desc_.long_desc = ".";
+    err_desc[5054] = desc_;
+    desc_.short_desc = "Failed to read from the NAND flash.";
+    desc_.long_desc = ".";
+    err_desc[5055] = desc_;
+    desc_.short_desc = "The nand page size is unsupported.";
+    desc_.long_desc = ".";
+    err_desc[5056] = desc_;
+    desc_.short_desc = "Failed to write to the flash device.";
+    desc_.long_desc = ".";
+    err_desc[5057] = desc_;
+    desc_.short_desc = "Failed to read the device ID from the flash device.";
+    desc_.long_desc = ".";
+    err_desc[5058] = desc_;
+    desc_.short_desc = "Hardware error in the flash status.";
+    desc_.long_desc = ".";
+    err_desc[5059] = desc_;
+    desc_.short_desc = "Failed to read from the flash device.";
+    desc_.long_desc = ".";
+    err_desc[5060] = desc_;
+    desc_.short_desc = "Failed to add a new instance of a flash device.";
+    desc_.long_desc = ".";
+    err_desc[5061] = desc_;
+    desc_.short_desc = "OTP is not support in the current flash device.";
+    desc_.long_desc = ".";
+    err_desc[5062] = desc_;
+    desc_.short_desc = "The OTP size is to small for the length requested.";
+    desc_.long_desc = ".";
+    err_desc[5063] = desc_;
+    desc_.short_desc = "Failed to read the OTP area in the flash device.";
+    desc_.long_desc = ".";
+    err_desc[5064] = desc_;
+    desc_.short_desc = "The flash type is unknown.";
+    desc_.long_desc = ".";
+    err_desc[5065] = desc_;
+    desc_.short_desc = "Failed to flush the NAND write buffer.";
+    desc_.long_desc = ".";
+    err_desc[5066] = desc_;
+    desc_.short_desc = "Failed to flush the NOR write buffer.";
+    desc_.long_desc = ".";
+    err_desc[5067] = desc_;
+    desc_.short_desc = "Invalid Loader on loader state.";
+    desc_.long_desc = ".";
+    err_desc[5068] = desc_;
+    desc_.short_desc = "Invalid loader on loader status.";
+    desc_.long_desc = ".";
+    err_desc[5069] = desc_;
+    desc_.short_desc = "Write static data failed.";
+    desc_.long_desc = ".";
+    err_desc[5070] = desc_;
+    desc_.short_desc = "Header is still not verified.";
+    desc_.long_desc = ".";
+    err_desc[5071] = desc_;
+    desc_.short_desc = "Blocks verification failed.";
+    desc_.long_desc = ".";
+    err_desc[5072] = desc_;
+    desc_.short_desc = "Handshake with App side failed.";
+    desc_.long_desc = ".";
+    err_desc[5073] = desc_;
+    desc_.short_desc = "Failed to read static data.";
+    desc_.long_desc = ".";
+    err_desc[5074] = desc_;
+    desc_.short_desc = "Failed to enable clock hardware.";
+    desc_.long_desc = ".";
+    err_desc[5075] = desc_;
+    desc_.short_desc = "Failed to enable block hardware.";
+    desc_.long_desc = ".";
+    err_desc[5076] = desc_;
+    desc_.short_desc = "Indicates that the loader did not find any header in the bootimage records that could be MAC'ed.";
+    desc_.long_desc = ".";
+    err_desc[5077] = desc_;
+    desc_.short_desc = "MMU setup failed.";
+    desc_.long_desc = ".";
+    err_desc[5078] = desc_;
+    desc_.short_desc = "Invalid command size.";
+    desc_.long_desc = ".";
+    err_desc[5079] = desc_;
+    desc_.short_desc = "Invalid hash list length.";
+    desc_.long_desc = ".";
+    err_desc[5080] = desc_;
+    desc_.short_desc = "Invalid input parameters.";
+    desc_.long_desc = ".";
+    err_desc[5081] = desc_;
+    desc_.short_desc = "MSL driver setup failed.";
+    desc_.long_desc = ".";
+    err_desc[5082] = desc_;
+    desc_.short_desc = "Request denied.";
+    desc_.long_desc = ".";
+    err_desc[5083] = desc_;
+    desc_.short_desc = "Fuses for the ASIC are invalid.";
+    desc_.long_desc = ".";
+    err_desc[5084] = desc_;
+    desc_.short_desc = "Static data is not checked.";
+    desc_.long_desc = ".";
+    err_desc[5085] = desc_;
+    desc_.short_desc = "Failed to initialize the cops data man, this can be caused by an corrupt boot image. You probably just need to flash a platform software to get it work.";
+    desc_.long_desc = ".";
+    err_desc[5086] = desc_;
+    desc_.short_desc = "UART driver error.";
+    desc_.long_desc = ".";
+    err_desc[5087] = desc_;
+    desc_.short_desc = "Loader type is not compatible with this domain.";
+    desc_.long_desc = ".";
+    err_desc[5088] = desc_;
+    desc_.short_desc = "Functionality not supported.";
+    desc_.long_desc = ".";
+    err_desc[5089] = desc_;
+    desc_.short_desc = "Default data can not be found.";
+    desc_.long_desc = ".";
+    err_desc[5090] = desc_;
+    desc_.short_desc = "Failed to send the header to access side to be MAC'ed, could be something wrong with the header.";
+    desc_.long_desc = ".";
+    err_desc[5091] = desc_;
+    desc_.short_desc = "App preloader not started.";
+    desc_.long_desc = ".";
+    err_desc[5092] = desc_;
+    desc_.short_desc = "Invalid destination address.";
+    desc_.long_desc = ".";
+    err_desc[5093] = desc_;
+    desc_.short_desc = "Failed to initialize the system application.";
+    desc_.long_desc = ".";
+    err_desc[5094] = desc_;
+    desc_.short_desc = "Failed to initialize the flash application.";
+    desc_.long_desc = ".";
+    err_desc[5095] = desc_;
+    desc_.short_desc = "Failed to initialize the signature application.";
+    desc_.long_desc = ".";
+    err_desc[5096] = desc_;
+    desc_.short_desc = "Failed to initialize the reset application.";
+    desc_.long_desc = ".";
+    err_desc[5097] = desc_;
+    desc_.short_desc = "Failed to initialize the internal security application.";
+    desc_.long_desc = ".";
+    err_desc[5098] = desc_;
+    desc_.short_desc = "COPS data man Format.";
+    desc_.long_desc = ".";
+    err_desc[5099] = desc_;
+    desc_.short_desc = "COPS data man write.";
+    desc_.long_desc = ".";
+    err_desc[5100] = desc_;
+    desc_.short_desc = "Failed to Flush the memory into the security partition.";
+    desc_.long_desc = ".";
+    err_desc[5101] = desc_;
+    desc_.short_desc = "Failed to get the block size of a unit in the security partition.";
+    desc_.long_desc = ".";
+    err_desc[5102] = desc_;
+    desc_.short_desc = "Failed to read an index from the security partition.";
+    desc_.long_desc = ".";
+    err_desc[5103] = desc_;
+    desc_.short_desc = "The bytes left to program should be less than a NAND page.";
+    desc_.long_desc = ".";
+    err_desc[5104] = desc_;
+    desc_.short_desc = "Boot image is too big.";
+    desc_.long_desc = ".";
+    err_desc[5105] = desc_;
+    desc_.short_desc = "App GD init failed.";
+    desc_.long_desc = ".";
+    err_desc[5106] = desc_;
+    desc_.short_desc = "Failed to initialize the file system.";
+    desc_.long_desc = ".";
+    err_desc[5107] = desc_;
+    desc_.short_desc = "Invalid source or destination address.";
+    desc_.long_desc = ".";
+    err_desc[5108] = desc_;
+    desc_.short_desc = "Invalid Response command number on the internal security command group, was expecting command 0xFF.";
+    desc_.long_desc = ".";
+    err_desc[5109] = desc_;
+    desc_.short_desc = "The internal sec command response should have responded to another command.";
+    desc_.long_desc = ".";
+    err_desc[5110] = desc_;
+    desc_.short_desc = "The data programmed into flash was not the same as the data received!";
+    desc_.long_desc = ".";
+    err_desc[5111] = desc_;
+    desc_.short_desc = "The PADMUX configuration has not been set.";
+    desc_.long_desc = ".";
+    err_desc[5112] = desc_;
+    desc_.short_desc = "Failed to set the start boot address, this address are used to read the static data.";
+    desc_.long_desc = ".";
+    err_desc[5113] = desc_;
+    desc_.short_desc = "if the static data was not found, the flash should be empty!";
+    desc_.long_desc = ".";
+    err_desc[5114] = desc_;
+    desc_.short_desc = "This error code informs that found boot container holds information that is not PMC protected.";
+    desc_.long_desc = ".";
+    err_desc[5115] = desc_;
+    desc_.short_desc = "The PMC ID is not supported.";
+    desc_.long_desc = ".";
+    err_desc[5116] = desc_;
+    desc_.short_desc = "The PMC ID is not coordinated with FSVN.";
+    desc_.long_desc = ".";
+    err_desc[5117] = desc_;
+    desc_.short_desc = "PMC start count to high or zero.";
+    desc_.long_desc = ".";
+    err_desc[5118] = desc_;
+    desc_.short_desc = "Unsuitable PMC for the location.";
+    desc_.long_desc = ".";
+    err_desc[5119] = desc_;
+    desc_.short_desc = "The PMC can not be found.";
+    desc_.long_desc = ".";
+    err_desc[5120] = desc_;
+    desc_.short_desc = "FSVN is too low.";
+    desc_.long_desc = ".";
+    err_desc[5121] = desc_;
+    desc_.short_desc = "All steps of the PMC are destroyed.";
+    desc_.long_desc = ".";
+    err_desc[5122] = desc_;
+    desc_.short_desc = "New version of once protected module attempted to be loaded without ARB flag set.";
+    desc_.long_desc = ".";
+    err_desc[5123] = desc_;
+    desc_.short_desc = "Unsuitable number of steps within PMC.";
+    desc_.long_desc = ".";
+    err_desc[5124] = desc_;
+    desc_.short_desc = "Dynamic variable is missing.";
+    desc_.long_desc = ".";
+    err_desc[5125] = desc_;
+    desc_.short_desc = "Dynamic variable found is to big.";
+    desc_.long_desc = ".";
+    err_desc[5126] = desc_;
+    desc_.short_desc = "Error reading partition manger status.";
+    desc_.long_desc = ".";
+    err_desc[5127] = desc_;
+    desc_.short_desc = "Error initializing partition manger.";
+    desc_.long_desc = ".";
+    err_desc[5128] = desc_;
+    desc_.short_desc = "Boot container size is not word aligned.";
+    desc_.long_desc = ".";
+    err_desc[5129] = desc_;
+    desc_.short_desc = "Not enough boot containers are allocated.";
+    desc_.long_desc = ".";
+    err_desc[5130] = desc_;
+    desc_.short_desc = "Invalid boot container type. At this position other type of container is expected.";
+    desc_.long_desc = ".";
+    err_desc[5131] = desc_;
+    desc_.short_desc = "The data size must be aligned to 512 bytes when reading or writing pages to/from the NAND.";
+    desc_.long_desc = ".";
+    err_desc[5132] = desc_;
+    desc_.short_desc = "TEST JTAG EANBLENODEBUG.";
+    desc_.long_desc = ".";
+    err_desc[5133] = desc_;
+    desc_.short_desc = "Required record is not found in the boot containers.";
+    desc_.long_desc = ".";
+    err_desc[5134] = desc_;
+    desc_.short_desc = "Buffer overflow.";
+    desc_.long_desc = "Buffer is not big enough.";
+    err_desc[5135] = desc_;
+    desc_.short_desc = "Buffer has not been allocated.";
+    desc_.long_desc = ".";
+    err_desc[5136] = desc_;
+    desc_.short_desc = "Size of data has an unexpected value.";
+    desc_.long_desc = ".";
+    err_desc[5137] = desc_;
+    desc_.short_desc = "Static data in boot record is corrupted.";
+    desc_.long_desc = ".";
+    err_desc[5138] = desc_;
+    desc_.short_desc = "Not allowed to flash this block.";
+    desc_.long_desc = ".";
+    err_desc[5139] = desc_;
+    desc_.short_desc = "Unable to change MMU settings.";
+    desc_.long_desc = "Error encountered when loader tried to change MMU setting.";
+    err_desc[5140] = desc_;
+    desc_.short_desc = "Loader settings are not compatible with loader settings.";
+    desc_.long_desc = "Error encountered when loader tried to startup on invalid Hardware.";
+    err_desc[5141] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5142] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5143] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5144] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5145] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5146] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5147] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5148] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5149] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5150] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5151] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5152] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5153] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5154] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5155] = desc_;
+    desc_.short_desc = "Virtual security partition is not allowed in this configuration.";
+    desc_.long_desc = ".";
+    err_desc[5156] = desc_;
+    desc_.short_desc = "Failed to write static data to virtual security partition.";
+    desc_.long_desc = ".";
+    err_desc[5157] = desc_;
+    desc_.short_desc = "Failed to read static data from virtual security partition.";
+    desc_.long_desc = ".";
+    err_desc[5158] = desc_;
+    desc_.short_desc = "Virtual security partition is not initialized.";
+    desc_.long_desc = ".";
+    err_desc[5159] = desc_;
+    desc_.short_desc = "Unit type is out of range in virtual security partition.";
+    desc_.long_desc = ".";
+    err_desc[5160] = desc_;
+    desc_.short_desc = "Could not get the dynamic data from the security library.";
+    desc_.long_desc = ".";
+    err_desc[5161] = desc_;
+    desc_.short_desc = "Partition table repaired!! Please load file again.";
+    desc_.long_desc = ".";
+    err_desc[5162] = desc_;
+    desc_.short_desc = "Partition table is damaged!";
+    desc_.long_desc = "Loaded file does not contain a valid partition table. Please load a file containing partition table.";
+    err_desc[5163] = desc_;
+    desc_.short_desc = "Partition table is damaged.";
+    desc_.long_desc = ".";
+    err_desc[5164] = desc_;
+    desc_.short_desc = "Partition table record is not found in the boot containers.";
+    desc_.long_desc = ".";
+    err_desc[5165] = desc_;
+    desc_.short_desc = "Static data in boot block is corrupt.";
+    desc_.long_desc = ".";
+    err_desc[5166] = desc_;
+    desc_.short_desc = "MBBS and BBM type conflict.";
+    desc_.long_desc = ".";
+    err_desc[5167] = desc_;
+    desc_.short_desc = "Execution of this command is not allowed in the current domain with current authentication state.";
+    desc_.long_desc = ".";
+    err_desc[5168] = desc_;
+    desc_.short_desc = "Execution of this command is not allowed in the current domain with current authentication state.";
+    desc_.long_desc = "Non fatal error.";
+    err_desc[5169] = desc_;
+    desc_.short_desc = "Error during initialization of LCD drivers.";
+    desc_.long_desc = ".";
+    err_desc[5171] = desc_;
+    desc_.short_desc = "LCD is not initialized.";
+    desc_.long_desc = ".";
+    err_desc[5172] = desc_;
+    desc_.short_desc = "Unrecoverable error during BMP image is processed.";
+    desc_.long_desc = ".";
+    err_desc[5173] = desc_;
+    desc_.short_desc = "The network buffer area is corrupted.";
+    desc_.long_desc = ".";
+    err_desc[5174] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5200] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[5201] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[9096] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[9300] = desc_;
+    desc_.short_desc = "Unsupported file system property.";
+    desc_.long_desc = ".";
+    err_desc[5301] = desc_;
+    desc_.short_desc = "The property is read only.";
+    desc_.long_desc = ".";
+    err_desc[5302] = desc_;
+    desc_.short_desc = "The specified property value was invalid.";
+    desc_.long_desc = ".";
+    err_desc[5303] = desc_;
+    desc_.short_desc = "The access permission attributes do not allow operation.";
+    desc_.long_desc = ".";
+    err_desc[5304] = desc_;
+    desc_.short_desc = "The file system is formatting.";
+    desc_.long_desc = ".";
+    err_desc[5305] = desc_;
+    desc_.short_desc = "The path does not exist.";
+    desc_.long_desc = ".";
+    err_desc[5306] = desc_;
+    desc_.short_desc = "The path already exists.";
+    desc_.long_desc = ".";
+    err_desc[5307] = desc_;
+    desc_.short_desc = "The path is read only.";
+    desc_.long_desc = ".";
+    err_desc[5308] = desc_;
+    desc_.short_desc = "Insufficient space.";
+    desc_.long_desc = ".";
+    err_desc[5309] = desc_;
+    desc_.short_desc = "The directory is not empty.";
+    desc_.long_desc = ".";
+    err_desc[5310] = desc_;
+    desc_.short_desc = "Invalid access restrictions specified.";
+    desc_.long_desc = ".";
+    err_desc[5311] = desc_;
+    desc_.short_desc = "No file system property.";
+    desc_.long_desc = ".";
+    err_desc[5312] = desc_;
+    desc_.short_desc = "The file does not exist.";
+    desc_.long_desc = ".";
+    err_desc[5313] = desc_;
+    desc_.short_desc = "Failed to change directory.";
+    desc_.long_desc = ".";
+    err_desc[5314] = desc_;
+    desc_.short_desc = "Failed to set new CH mod.";
+    desc_.long_desc = ".";
+    err_desc[5315] = desc_;
+    desc_.short_desc = "Failed to get the current directory.";
+    desc_.long_desc = ".";
+    err_desc[5316] = desc_;
+    desc_.short_desc = "Failed to open a file in the file system.";
+    desc_.long_desc = ".";
+    err_desc[5317] = desc_;
+    desc_.short_desc = "Failed to read the stat from file.";
+    desc_.long_desc = ".";
+    err_desc[5318] = desc_;
+    desc_.short_desc = "Failed to list volumes.";
+    desc_.long_desc = ".";
+    err_desc[5319] = desc_;
+    desc_.short_desc = "No free space left.";
+    desc_.long_desc = ".";
+    err_desc[5320] = desc_;
+    desc_.short_desc = "Failed to close a file in the filesystem.";
+    desc_.long_desc = ".";
+    err_desc[5321] = desc_;
+    desc_.short_desc = "Failed to close the directory.";
+    desc_.long_desc = ".";
+    err_desc[5322] = desc_;
+    desc_.short_desc = "Failed to remove a file from the filesystem.";
+    desc_.long_desc = ".";
+    err_desc[5323] = desc_;
+    desc_.short_desc = "Failed to rename a file in the filesystem.";
+    desc_.long_desc = ".";
+    err_desc[5324] = desc_;
+    desc_.short_desc = "Failed to create a new directory in the filesystem.";
+    desc_.long_desc = ".";
+    err_desc[5325] = desc_;
+    desc_.short_desc = "Failed to remove a directory from the file system.";
+    desc_.long_desc = ".";
+    err_desc[5326] = desc_;
+    desc_.short_desc = "Failed to write a file to the file system.";
+    desc_.long_desc = ".";
+    err_desc[5327] = desc_;
+    desc_.short_desc = "The state of the SFA programming is incorrect.";
+    desc_.long_desc = ".";
+    err_desc[5328] = desc_;
+    desc_.short_desc = "Failed to read a file from the file system.";
+    desc_.long_desc = ".";
+    err_desc[5329] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[61797] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[66166] = desc_;
+    desc_.short_desc = "Unsupported GDFS property.";
+    desc_.long_desc = ".";
+    err_desc[5401] = desc_;
+    desc_.short_desc = "The GDFS property is read only.";
+    desc_.long_desc = ".";
+    err_desc[5402] = desc_;
+    desc_.short_desc = "The property value is invalid.";
+    desc_.long_desc = ".";
+    err_desc[5403] = desc_;
+    desc_.short_desc = "Invalid start property.";
+    desc_.long_desc = ".";
+    err_desc[5404] = desc_;
+    desc_.short_desc = "GDFS has not been started yet.";
+    desc_.long_desc = ".";
+    err_desc[5405] = desc_;
+    desc_.short_desc = "Failed to format the GDFS area.";
+    desc_.long_desc = ".";
+    err_desc[5406] = desc_;
+    desc_.short_desc = "GDFS is not formatted, as it should be.";
+    desc_.long_desc = ".";
+    err_desc[5407] = desc_;
+    desc_.short_desc = "Invalid Block unit number.";
+    desc_.long_desc = ".";
+    err_desc[5408] = desc_;
+    desc_.short_desc = "Could not find any GDFS configuration from the platform software in flash.";
+    desc_.long_desc = ".";
+    err_desc[5409] = desc_;
+    desc_.short_desc = "Failed to close the GDFS area.";
+    desc_.long_desc = ".";
+    err_desc[5410] = desc_;
+    desc_.short_desc = "Failed to open the GDFS area.";
+    desc_.long_desc = ".";
+    err_desc[5411] = desc_;
+    desc_.short_desc = "Invalid GDFS UNIT size(size=0).";
+    desc_.long_desc = ".";
+    err_desc[5412] = desc_;
+    desc_.short_desc = "Failed to write to the specified unit.";
+    desc_.long_desc = ".";
+    err_desc[5413] = desc_;
+    desc_.short_desc = "Failed to read from the specified unit.";
+    desc_.long_desc = ".";
+    err_desc[5414] = desc_;
+    desc_.short_desc = "Failed read access on an empty GDFS.";
+    desc_.long_desc = ".";
+    err_desc[5415] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "";
+    err_desc[70535] = desc_;
+    desc_.short_desc = "";
+    desc_.long_desc = "Request for recovery condition for condition that is not changed.";
+    err_desc[80009] = desc_;
+
+}
+
+/****************************************************************************/
+/*       NAME : GetLoaderErrorDescription_Call                              */
+/*--------------------------------------------------------------------------*/
+/* DESCRIPTION: For a given error code number it returns its short and      */
+/*              long description.                                           */
+/*                                                                          */
+/* PARAMETERS :                                                             */
+/*        IN : uint32 ErrorNr:Error code number.                            */
+/*       OUT : uint8 ShortDescription:Buffer for short description.         */
+/*       OUT : uint8 LongDescription:Buffer for long description.           */
+/*        IN : uint32 ShorDescrBufLen:Max length of ShortDescription.       */
+/*        IN : uint32 LongDescrBufLen:Max length of LongDescription.        */
+/*                                                                          */
+/*    RETURN : void                                                         */
+/****************************************************************************/
+void GetLoaderErrorDescription_Call(uint32 ErrorNr, uint8 *ShortDescription, uint8 *LongDescription, uint32 ShorDescrBufLen, uint32 LongDescrBufLen)
+{
+    std::map <int, desc>::iterator it;
+    uint32 str_len = 0;
+
+    // Define the map err_desc on the first call of this function
+    if (!func_call_once){
+        Init_map_err_desc();
+        func_call_once = 1;
+    }
+
+    it=err_desc.find(ErrorNr);
+    if(err_desc.end() == it){
+        std::string temp = "There is no LCM/LCD error with this number";
+
+        if((temp.length()+1) > ShorDescrBufLen){
+             str_len = ShorDescrBufLen-1;
+        }
+        else{
+             str_len = temp.length();
+        }
+        strcpy_s((char *)ShortDescription, str_len, temp.c_str());
+        ShortDescription[str_len] = '\0';
+
+       if((temp.length()+1) > LongDescrBufLen){
+              str_len = LongDescrBufLen-1;
+        }
+        else{
+              str_len = temp.length();
+        }
+        strcpy_s((char *)LongDescription, str_len, temp.c_str());
+        LongDescription[str_len] = '\0';
+    }
+    else{
+
+        if(((*it).second.short_desc.length()+1) > ShorDescrBufLen){
+            str_len = ShorDescrBufLen-1;
+        }
+        else{
+            str_len = (*it).second.short_desc.length();
+        }
+
+        strcpy_s((char *)ShortDescription, str_len, (*it).second.short_desc.c_str());
+        ShortDescription[str_len] = '\0';
+
+        if(((*it).second.long_desc.length()+1) > LongDescrBufLen){
+            str_len = LongDescrBufLen-1;
+        }
+        else{
+            str_len = (*it).second.long_desc.length();
+        }
+
+        strcpy_s((char *)LongDescription, str_len, (*it).second.long_desc.c_str());
+        LongDescription[str_len] = '\0';
+    }
+}
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/lcdriver_error_codes.h riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/lcdriver_error_codes.h
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/lcdriver_error_codes.h	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/lcdriver_error_codes.h	2012-05-29 21:37:34.727185728 +0300
@@ -0,0 +1,99 @@
+/* $Copyright ST-Ericsson 2010$ */
+/* NOTE: This is an automatically generated file. DO NOT EDIT! */
+
+#ifndef _LCDRIVERERRORCODE_H
+#define _LCDRIVERERRORCODE_H
+
+/**
+ *  Error codes for LCDriver.
+ */
+
+/**
+ * Table for Error groups range
+ *
+ * General Fatal 10001-10025
+ * General Non-Fatal 10026-10050
+ *
+ * Interface Fatal 10051-10075
+ * Interface Non-Fatal 10076-10100
+ *
+ * System Thread Fatal 10101-10125
+ * System Thread Non-Fatal 10126-10150
+ *
+ * Bulk Fatal 10151-10175
+ * Bulk Non-Fatal 10176-10200
+ *
+ * Hardware Fatal 10201-10225
+ * Hardware Non-Fatal 10226-10250
+ *
+ * Loader Command Execution Fatal 10251-10275
+ * Loader Command Execution Non-Fatal 10276-10300
+ *
+ * Buffers Fatal 10301-10325
+ * Buffers Non-Fatal 10326-10350
+ *
+ * IO File Fatal 10351-10375
+ * IO File Non-Fatal 10376-10400
+ *
+ * LCM DLL Fatal 10401-10425
+ * LCM DLL Non-Fatal 10426-10450
+ *
+ * Exceptions Fatal 10451-10475
+ * Exceptions Non-Fatal 10476-10500
+ *
+ * LCDriver Thread Fatal 10501-10525
+ * LCDriver Thread Non-Fatal 10526-10550
+ *
+ */
+
+typedef enum {
+  TIMEOUT = 10001,  /** Timeout event occurred. */
+  INVALID_INPUT_PARAMETERS = 10002,  /** Invalid parameter during Context initialization. */
+  INTERFACE_COULD_NOT_ADD_OBJECT_TO_LIST = 10051,  /** Failed to create context for connected device. */
+  INTERFACE_COULD_NOT_CREATE_OBJECT = 10052,  /** Failed to create loader interface. */
+  INTERFACE_UNKNOWN_EXECPTION_WHILE_ADDING_OBJECT = 10053,  /** Failed to create context for connected device. */
+  INTERFACE_COULD_NOT_CREATE_IFC_OBJECT = 10054,  /** Failed to create context for connected device. */
+  INTERFACE_OBJECT_POINTER_TO_POINTER_NULL = 10055,  /** Invalid pointer to interface. */
+  INTERFACE_OBJECT_POINTER_NULL = 10056,  /** Invalid pointer to LCDriver context. */
+  INTERFACE_OBJECT_ALREADY_EXISTS = 10076,  /** LCDriver interface for the device already exists. */
+  INTERFACE_LC_METHODS_OBJECT_NULL = 10077,  /** Interface for loader methods is not created. */
+  INTERFACE_INTERFACEID_POINTER_NULL = 10078,  /** Failed to create LCDriver context. */
+  INTERFACE_CONTEXT_NOT_STARTED = 10079,  /** LCDriver context is not started. */
+  LCDRIVER_THREAD_UNKNOWN_EXCEPTION = 10126,  /** Unexpected exit of LCDriver thread. */
+  BULK_VECTOR_ID_ERROR = 10176,  /** Failed to start bulk session. */
+  BULK_ALREADY_IN_PROGRESS = 10177,  /** Bulk transfer is already in progress. */
+  PROTROM_STATUS_NOT_OK = 10201,  /** ROM Code Failure. */
+  TIMEOUT_NO_CHIP_ID_DETECTED = 10226,  /** Failed to initialize HW. */
+  TIMEOUT_NO_Z_DETECTED = 10227,  /** Failed to start HW initialization. */
+  PARALLEL_COMMAND_EXECUTION_NOT_SUPPORTED = 10276,  /** Command execution failed. */
+  CALLBACKS_NOT_CONFIGURED_CORRECTLY = 10277,  /** Communication driver configuration failure. */
+  GENERAL_RESPONSE_COMMAND_NUMBER_ERROR = 10278,  /** Failure during command execution. */
+  COMMAND_NUMBER_ERROR = 10279,  /** Failure during command execution. */
+  CANCEL_EVENT_RECEIVED = 10280,  /** Operation execution is canceled. */
+  UNEXPECTED_EVENT_RECEIVED = 10281,  /** Unexpected event during execution. */
+  INVALID_EXECUTION_MODE = 10282,  /** Invalid execution mode. */
+  BUFFER_BULK_FILE_NOT_ALOCATED = 10326,  /** Bulk transfer failed. */
+  FILE_OPENING_ERROR = 10376,  /** Failed to open file. */
+  FILE_CREATE_MAPPING_ERROR = 10377,  /** Failed to load the file in RAM. */
+  FILE_MAPPING_VIEW_ERROR = 10378,  /** Reading of file failed. */
+  FILE_FAILED_TO_GET_SIZE = 10379,  /** Failed to load the file in RAM. */
+  FILE_READ_INVALID_OFFSET = 10379,  /** Invalid data offset requested. */
+  FILE_READ_ERROR = 10380,  /** Failed to read from file. */
+  LCM_DLL_LOAD_LOADLIBRARY_ERROR = 10401,  /** Failed to load LCM library. */
+  LCM_DLL_LOAD_FUNCTION_NOT_FOUND = 10402,  /** Failed to import LCM functionality. */
+  LCM_LOAD_INCOMPATIBLE_PC_VERSION = 10426,  /** Incompatible PC LCM version. */
+  LCM_LOAD_INCOMPATIBLE_LDR_VERSION = 10427,  /** Incompatible LDR LCM version. */
+  UNKNOWN_EXCEPTION = 10451,  /** Unknown error has stopped the operation. */
+  UNKNOWN_WAIT_RETURN_VALUE = 10476,  /** Operation execution failed. */
+  UNKNOWN_BULK_TRANSFER_EXCEPTION = 10477,  /** Bulk transfer failed. */
+  UNKNOWN_INTERFACE_EXCEPTION = 10478,  /** LCDriver context operation failed. */
+  LCDRIVER_THREAD_KILLED = 10526,  /** LCDriver thread stopped. */
+  LCDRIVER_THREAD_KILLED_WITH_CANCEL = 10527,  /** LCDriver thread stopped. */
+  LCDRIVER_THREAD_KILLED_WITH_SIGNAL_DEATH = 10528,  /** LCDriver thread stopped. */
+  LCDRIVER_THREAD_NOT_STARTED = 10529,  /** Failed to start LCDriver thread. */
+  LCDRIVER_THREAD_STOPPED_AFTER_LCM_ERROR = 10530,  /** LCDriver thread stopped after receiving LCM error. */
+  LCM_RETRANSMISSION_ERROR = 10551,  /** LCM failed to send packet. */
+  LCM_DEVICE_WRITE_ERROR = 10552  /** LCM failed to write data on communication device. */
+} InternalErrorCodes_e;
+
+#endif /* _LCDRIVERERRORCODE_H */
diff -ruN riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/LcdVersion.cpp riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/LcdVersion.cpp
--- riff-loadercomm-0.4.2+r9aa6b84a5e/out/autogen/LcdVersion.cpp	1970-01-01 02:00:00.000000000 +0200
+++ riff-loadercomm-0.4.2+r9aa6b84a5e.new/out/autogen/LcdVersion.cpp	2012-05-29 21:37:36.307193568 +0300
@@ -0,0 +1,22 @@
+/*******************************************************************************
+ * Copyright (C) ST-Ericsson SA 2011
+ * License terms: 3-clause BSD license
+ ******************************************************************************/
+#include "lcdriver_error_codes.h"
+#include "LcmInterface.h"
+#include "Error.h"
+#ifdef _WIN32
+#include "WinApiWrappers.h"
+#else
+#include "LinuxApiWrappers.h"
+#include <dlfcn.h>
+#define GetProcAddress dlsym
+#endif
+/**
+ * var char LCD_LCM_Compatibility[]
+ * brief ASCII string holding the LCD version.
+ * This string is compared with the version of the LCM.
+ * Current LCM version is defined in file lcm_version.c in LCM code.
+ */
+char LCD_LCM_Compatibility[] = "";
+
