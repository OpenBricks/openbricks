From edbe4c14bb70d7b8a924c4e40390e14834d75b2f Mon Sep 17 00:00:00 2001
From: Luciana Fujii Pontello <lucianafujii@collabora.co.uk>
Date: Wed, 19 Oct 2011 15:28:11 -0400
Subject: [PATCH 107/154] pvrvideosink: Adding external headers copy

---
 sys/pvr2d/pvr_includes/img_defs.h    |  123 ++++
 sys/pvr2d/pvr_includes/img_types.h   |  143 ++++
 sys/pvr2d/pvr_includes/services.h    | 1244 ++++++++++++++++++++++++++++++++++
 sys/pvr2d/pvr_includes/servicesext.h |  855 +++++++++++++++++++++++
 4 files changed, 2365 insertions(+), 0 deletions(-)
 create mode 100755 sys/pvr2d/pvr_includes/img_defs.h
 create mode 100755 sys/pvr2d/pvr_includes/img_types.h
 create mode 100644 sys/pvr2d/pvr_includes/services.h
 create mode 100755 sys/pvr2d/pvr_includes/servicesext.h

diff --git a/sys/pvr2d/pvr_includes/img_defs.h b/sys/pvr2d/pvr_includes/img_defs.h
new file mode 100755
index 0000000..64db711
--- /dev/null
+++ b/sys/pvr2d/pvr_includes/img_defs.h
@@ -0,0 +1,123 @@
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
+
+
+#if !defined (__IMG_DEFS_H__)
+#define __IMG_DEFS_H__
+
+#include "img_types.h"
+
+typedef		enum	img_tag_TriStateSwitch
+{
+	IMG_ON		=	0x00,
+	IMG_OFF,
+	IMG_IGNORE
+
+} img_TriStateSwitch, * img_pTriStateSwitch;
+
+#define		IMG_SUCCESS				0
+
+#define		IMG_NO_REG				1
+
+#if defined (NO_INLINE_FUNCS)
+	#define	INLINE
+	#define	FORCE_INLINE
+#else
+#if defined (__cplusplus)
+	#define INLINE					inline
+	#define	FORCE_INLINE			inline
+#else
+#if	!defined(INLINE)
+	#define	INLINE					__inline
+#endif
+	#define	FORCE_INLINE			static __inline
+#endif
+#endif
+
+
+#ifndef PVR_UNREFERENCED_PARAMETER
+#define	PVR_UNREFERENCED_PARAMETER(param) (param) = (param)
+#endif
+
+#ifdef __GNUC__
+#define unref__ __attribute__ ((unused))
+#else
+#define unref__
+#endif
+
+#ifndef _TCHAR_DEFINED
+#if defined(UNICODE)
+typedef unsigned short		TCHAR, *PTCHAR, *PTSTR;
+#else	
+typedef char				TCHAR, *PTCHAR, *PTSTR;
+#endif	
+#define _TCHAR_DEFINED
+#endif 
+
+
+			#if defined(__linux__) || defined(__METAG)
+
+				#define IMG_CALLCONV
+				#define IMG_INTERNAL	__attribute__((visibility("hidden")))
+				#define IMG_EXPORT		__attribute__((visibility("default")))
+				#define IMG_IMPORT
+				#define IMG_RESTRICT	__restrict__
+
+			#else
+					#error("define an OS")
+			#endif
+
+#ifndef IMG_ABORT
+	#define IMG_ABORT()	abort()
+#endif
+
+#ifndef IMG_MALLOC
+	#define IMG_MALLOC(A)		malloc	(A)
+#endif
+
+#ifndef IMG_FREE
+	#define IMG_FREE(A)			free	(A)
+#endif
+
+#define IMG_CONST const
+
+#if defined(__GNUC__)
+#define IMG_FORMAT_PRINTF(x,y)		__attribute__((format(printf,x,y)))
+#else
+#define IMG_FORMAT_PRINTF(x,y)
+#endif
+
+#if defined (_WIN64)
+#define IMG_UNDEF	(~0ULL)
+#else
+#define IMG_UNDEF	(~0UL)
+#endif
+
+#endif 
diff --git a/sys/pvr2d/pvr_includes/img_types.h b/sys/pvr2d/pvr_includes/img_types.h
new file mode 100755
index 0000000..c312c83
--- /dev/null
+++ b/sys/pvr2d/pvr_includes/img_types.h
@@ -0,0 +1,143 @@
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
+
+
+#ifndef __IMG_TYPES_H__
+#define __IMG_TYPES_H__
+
+#if !defined(IMG_ADDRSPACE_CPUVADDR_BITS)
+#define IMG_ADDRSPACE_CPUVADDR_BITS		32
+#endif
+
+#if !defined(IMG_ADDRSPACE_PHYSADDR_BITS)
+#define IMG_ADDRSPACE_PHYSADDR_BITS		32
+#endif
+
+typedef unsigned int	IMG_UINT,	*IMG_PUINT;
+typedef signed int		IMG_INT,	*IMG_PINT;
+
+typedef unsigned char	IMG_UINT8,	*IMG_PUINT8;
+typedef unsigned char	IMG_BYTE,	*IMG_PBYTE;
+typedef signed char		IMG_INT8,	*IMG_PINT8;
+typedef char			IMG_CHAR,	*IMG_PCHAR;
+
+typedef unsigned short	IMG_UINT16,	*IMG_PUINT16;
+typedef signed short	IMG_INT16,	*IMG_PINT16;
+#if !defined(IMG_UINT32_IS_ULONG)
+typedef unsigned int	IMG_UINT32,	*IMG_PUINT32;
+typedef signed int		IMG_INT32,	*IMG_PINT32;
+#else
+typedef unsigned long	IMG_UINT32,	*IMG_PUINT32;
+typedef signed long		IMG_INT32,	*IMG_PINT32;
+#endif
+#if !defined(IMG_UINT32_MAX)
+	#define IMG_UINT32_MAX 0xFFFFFFFFUL
+#endif
+
+	#if (defined(LINUX) || defined(__METAG))
+#if !defined(USE_CODE)
+		typedef unsigned long long		IMG_UINT64,	*IMG_PUINT64;
+		typedef long long 				IMG_INT64,	*IMG_PINT64;
+#endif
+	#else
+
+		#error("define an OS")
+
+	#endif
+
+#if !(defined(LINUX) && defined (__KERNEL__))
+typedef float			IMG_FLOAT,	*IMG_PFLOAT;
+typedef double			IMG_DOUBLE, *IMG_PDOUBLE;
+#endif
+
+typedef	enum tag_img_bool
+{
+	IMG_FALSE		= 0,
+	IMG_TRUE		= 1,
+	IMG_FORCE_ALIGN = 0x7FFFFFFF
+} IMG_BOOL, *IMG_PBOOL;
+
+typedef void            IMG_VOID, *IMG_PVOID;
+
+typedef IMG_INT32       IMG_RESULT;
+
+#if defined(_WIN64)
+typedef unsigned __int64 IMG_UINTPTR_T;
+#else
+typedef unsigned int     IMG_UINTPTR_T;
+#endif
+
+typedef IMG_PVOID       IMG_HANDLE;
+
+typedef void**          IMG_HVOID,	* IMG_PHVOID;
+
+typedef IMG_UINT32		IMG_SIZE_T;
+
+#define IMG_NULL        0 
+
+typedef IMG_UINT32      IMG_SID;
+
+
+typedef IMG_PVOID IMG_CPU_VIRTADDR;
+
+typedef struct _IMG_DEV_VIRTADDR
+{
+	
+	IMG_UINT32  uiAddr;
+#define IMG_CAST_TO_DEVVADDR_UINT(var)		(IMG_UINT32)(var)
+	
+} IMG_DEV_VIRTADDR;
+
+typedef struct _IMG_CPU_PHYADDR
+{
+	
+	IMG_UINTPTR_T uiAddr;
+} IMG_CPU_PHYADDR;
+
+typedef struct _IMG_DEV_PHYADDR
+{
+#if IMG_ADDRSPACE_PHYSADDR_BITS == 32
+	
+	IMG_UINTPTR_T uiAddr;
+#else
+	IMG_UINT32 uiAddr;
+	IMG_UINT32 uiHighAddr;
+#endif
+} IMG_DEV_PHYADDR;
+
+typedef struct _IMG_SYS_PHYADDR
+{
+	
+	IMG_UINTPTR_T uiAddr;
+} IMG_SYS_PHYADDR;
+
+#include "img_defs.h"
+
+#endif	
diff --git a/sys/pvr2d/pvr_includes/services.h b/sys/pvr2d/pvr_includes/services.h
new file mode 100644
index 0000000..bad2f1c
--- /dev/null
+++ b/sys/pvr2d/pvr_includes/services.h
@@ -0,0 +1,1244 @@
+/**********************************************************************
+ *
+ * Copyright (C) Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __SERVICES_H__
+#define __SERVICES_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "pdumpdefs.h"
+
+
+#define PVRSRV_4K_PAGE_SIZE		4096UL
+
+#define PVRSRV_MAX_CMD_SIZE		1024
+
+#define PVRSRV_MAX_DEVICES		16	
+
+#define EVENTOBJNAME_MAXLENGTH (50)
+
+#define PVRSRV_MEM_READ						(1U<<0)
+#define PVRSRV_MEM_WRITE					(1U<<1)
+#define PVRSRV_MEM_CACHE_CONSISTENT			(1U<<2)
+#define PVRSRV_MEM_NO_SYNCOBJ				(1U<<3)
+#define PVRSRV_MEM_INTERLEAVED				(1U<<4)
+#define PVRSRV_MEM_DUMMY					(1U<<5)
+#define PVRSRV_MEM_EDM_PROTECT				(1U<<6)
+#define PVRSRV_MEM_ZERO						(1U<<7)
+#define PVRSRV_MEM_USER_SUPPLIED_DEVVADDR	(1U<<8)
+#define PVRSRV_MEM_RAM_BACKED_ALLOCATION	(1U<<9)
+#define PVRSRV_MEM_NO_RESMAN				(1U<<10)
+#define PVRSRV_MEM_EXPORTED					(1U<<11)
+
+
+#define PVRSRV_HAP_CACHED					(1U<<12)
+#define PVRSRV_HAP_UNCACHED					(1U<<13)
+#define PVRSRV_HAP_SMART					(1U<<20)  /* XXX could we use CACHED|UNCACHED? */
+#define PVRSRV_HAP_WRITECOMBINE				(1U<<14)
+#define PVRSRV_HAP_CACHETYPE_MASK			(PVRSRV_HAP_CACHED|PVRSRV_HAP_UNCACHED|PVRSRV_HAP_SMART|PVRSRV_HAP_WRITECOMBINE)
+#define PVRSRV_HAP_KERNEL_ONLY				(1U<<15)
+#define PVRSRV_HAP_SINGLE_PROCESS			(1U<<16)
+#define PVRSRV_HAP_MULTI_PROCESS			(1U<<17)
+#define PVRSRV_HAP_FROM_EXISTING_PROCESS	(1U<<18)
+#define PVRSRV_HAP_NO_CPU_VIRTUAL			(1U<<19)
+#define PVRSRV_HAP_GPU_PAGEABLE				(1U<<21)
+#define PVRSRV_HAP_MAPTYPE_MASK				(PVRSRV_HAP_KERNEL_ONLY \
+                                            |PVRSRV_HAP_SINGLE_PROCESS \
+                                            |PVRSRV_HAP_MULTI_PROCESS \
+                                            |PVRSRV_HAP_FROM_EXISTING_PROCESS \
+                                            |PVRSRV_HAP_NO_CPU_VIRTUAL\
+                                            |PVRSRV_HAP_GPU_PAGEABLE)
+
+#define PVRSRV_MEM_CACHED					PVRSRV_HAP_CACHED
+#define PVRSRV_MEM_UNCACHED					PVRSRV_HAP_UNCACHED
+#define PVRSRV_MEM_SMART					PVRSRV_HAP_SMART
+#define PVRSRV_MEM_WRITECOMBINE				PVRSRV_HAP_WRITECOMBINE
+
+#define PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT	(24)
+
+#define PVRSRV_MAP_NOUSERVIRTUAL            (1UL<<27)
+#define PVRSRV_MEM_XPROC  					(1U<<28)
+
+#define PVRSRV_NO_CONTEXT_LOSS					0		
+#define PVRSRV_SEVERE_LOSS_OF_CONTEXT			1		
+#define PVRSRV_PRE_STATE_CHANGE_MASK			0x80	
+
+
+#define PVRSRV_DEFAULT_DEV_COOKIE			(1)	 
+
+
+#define PVRSRV_MISC_INFO_TIMER_PRESENT				(1U<<0)
+#define PVRSRV_MISC_INFO_CLOCKGATE_PRESENT			(1U<<1)
+#define PVRSRV_MISC_INFO_MEMSTATS_PRESENT			(1U<<2)
+#define PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT	(1U<<3)
+#define PVRSRV_MISC_INFO_DDKVERSION_PRESENT			(1U<<4)
+#define PVRSRV_MISC_INFO_CPUCACHEOP_PRESENT			(1U<<5)
+#define PVRSRV_MISC_INFO_FREEMEM_PRESENT			(1U<<6)
+
+#define PVRSRV_MISC_INFO_RESET_PRESENT				(1U<<31)
+
+#define PVRSRV_PDUMP_MAX_FILENAME_SIZE			20
+#define PVRSRV_PDUMP_MAX_COMMENT_SIZE			200
+
+
+#define PVRSRV_CHANGEDEVMEM_ATTRIBS_CACHECOHERENT		0x00000001
+
+#define PVRSRV_MAPEXTMEMORY_FLAGS_ALTERNATEVA			0x00000001
+#define PVRSRV_MAPEXTMEMORY_FLAGS_PHYSCONTIG			0x00000002
+
+#define PVRSRV_MODIFYSYNCOPS_FLAGS_WO_INC			0x00000001
+#define PVRSRV_MODIFYSYNCOPS_FLAGS_RO_INC			0x00000002
+
+#define SRV_FLAGS_PERSIST		0x1
+#define SRV_FLAGS_PDUMP_ACTIVE	0x2
+
+#define PVRSRV_PDUMP_FLAGS_CONTINUOUS		0x1
+
+#define PVR_FULL_CACHE_OP_THRESHOLD	(0x7D000)
+
+typedef enum _PVRSRV_DEVICE_TYPE_
+{
+	PVRSRV_DEVICE_TYPE_UNKNOWN			= 0 ,
+	PVRSRV_DEVICE_TYPE_MBX1				= 1 ,
+	PVRSRV_DEVICE_TYPE_MBX1_LITE		= 2 ,
+
+	PVRSRV_DEVICE_TYPE_M24VA			= 3,
+	PVRSRV_DEVICE_TYPE_MVDA2			= 4,
+	PVRSRV_DEVICE_TYPE_MVED1			= 5,
+	PVRSRV_DEVICE_TYPE_MSVDX			= 6,
+
+	PVRSRV_DEVICE_TYPE_SGX				= 7,
+
+	PVRSRV_DEVICE_TYPE_VGX				= 8,
+
+	
+	PVRSRV_DEVICE_TYPE_EXT				= 9,
+
+    PVRSRV_DEVICE_TYPE_LAST             = 9,
+
+	PVRSRV_DEVICE_TYPE_FORCE_I32		= 0x7fffffff
+
+} PVRSRV_DEVICE_TYPE;
+
+#define HEAP_ID( _dev_ , _dev_heap_idx_ )	(  ((_dev_)<<24) | ((_dev_heap_idx_)&((1<<24)-1))  )
+#define HEAP_IDX( _heap_id_ )				( (_heap_id_)&((1<<24) - 1 ) )
+#define HEAP_DEV( _heap_id_ )				( (_heap_id_)>>24 )
+
+#define PVRSRV_UNDEFINED_HEAP_ID			(~0LU)
+
+typedef enum
+{
+	IMG_EGL				= 0x00000001,
+	IMG_OPENGLES1		= 0x00000002,
+	IMG_OPENGLES2		= 0x00000003,
+	IMG_D3DM			= 0x00000004,
+	IMG_SRV_UM			= 0x00000005,
+	IMG_OPENVG			= 0x00000006,
+	IMG_SRVCLIENT		= 0x00000007,
+	IMG_VISTAKMD		= 0x00000008,
+	IMG_VISTA3DNODE		= 0x00000009,
+	IMG_VISTAMVIDEONODE	= 0x0000000A,
+	IMG_VISTAVPBNODE	= 0x0000000B,
+	IMG_OPENGL			= 0x0000000C,
+	IMG_D3D				= 0x0000000D,
+#if defined(SUPPORT_GRAPHICS_HAL) || defined(SUPPORT_COMPOSER_HAL)
+	IMG_ANDROID_HAL		= 0x0000000E,
+#endif
+#if defined(SUPPORT_OPENCL)
+	IMG_OPENCL			= 0x0000000F,
+#endif
+
+} IMG_MODULE_ID;
+
+
+#define APPHINT_MAX_STRING_SIZE	256
+
+typedef enum
+{
+	IMG_STRING_TYPE		= 1,
+	IMG_FLOAT_TYPE		,
+	IMG_UINT_TYPE		,
+	IMG_INT_TYPE		,
+	IMG_FLAG_TYPE
+}IMG_DATA_TYPE;
+
+
+typedef struct _PVRSRV_DEV_DATA_ *PPVRSRV_DEV_DATA;
+
+typedef struct _PVRSRV_DEVICE_IDENTIFIER_
+{
+	PVRSRV_DEVICE_TYPE		eDeviceType;		
+	PVRSRV_DEVICE_CLASS		eDeviceClass;		
+	IMG_UINT32				ui32DeviceIndex;	
+	IMG_CHAR				*pszPDumpDevName;	
+	IMG_CHAR				*pszPDumpRegName;	
+
+} PVRSRV_DEVICE_IDENTIFIER;
+
+
+typedef struct _PVRSRV_CLIENT_DEV_DATA_
+{
+	IMG_UINT32		ui32NumDevices;				
+	PVRSRV_DEVICE_IDENTIFIER asDevID[PVRSRV_MAX_DEVICES];		
+	PVRSRV_ERROR	(*apfnDevConnect[PVRSRV_MAX_DEVICES])(PPVRSRV_DEV_DATA);	
+	PVRSRV_ERROR	(*apfnDumpTrace[PVRSRV_MAX_DEVICES])(PPVRSRV_DEV_DATA);		
+
+} PVRSRV_CLIENT_DEV_DATA;
+
+
+typedef struct _PVRSRV_CONNECTION_
+{
+	IMG_HANDLE hServices;					
+	IMG_UINT32 ui32ProcessID;				
+	PVRSRV_CLIENT_DEV_DATA	sClientDevData;	
+	IMG_UINT32 ui32SrvFlags;				
+}PVRSRV_CONNECTION;
+
+
+typedef struct _PVRSRV_DEV_DATA_
+{
+	IMG_CONST PVRSRV_CONNECTION	 *psConnection;	
+#if defined (SUPPORT_SID_INTERFACE)
+	IMG_SID			hDevCookie;				
+#else
+	IMG_HANDLE			hDevCookie;				
+#endif
+
+} PVRSRV_DEV_DATA;
+
+typedef struct _PVRSRV_MEMUPDATE_
+{
+	IMG_UINT32			ui32UpdateAddr;		
+	IMG_UINT32			ui32UpdateVal;		
+} PVRSRV_MEMUPDATE;
+
+typedef struct _PVRSRV_HWREG_
+{
+	IMG_UINT32			ui32RegAddr;	
+	IMG_UINT32			ui32RegVal;		
+} PVRSRV_HWREG;
+
+typedef struct _PVRSRV_MEMBLK_
+{
+	IMG_DEV_VIRTADDR	sDevVirtAddr;			
+	IMG_HANDLE			hOSMemHandle;			
+	IMG_HANDLE			hOSWrapMem;				
+	IMG_HANDLE			hBuffer;				
+	IMG_HANDLE			hResItem;				
+	IMG_SYS_PHYADDR	 	*psIntSysPAddr;
+
+} PVRSRV_MEMBLK;
+
+typedef struct _PVRSRV_KERNEL_MEM_INFO_ *PPVRSRV_KERNEL_MEM_INFO;
+
+typedef struct _PVRSRV_CLIENT_MEM_INFO_
+{
+	
+	IMG_PVOID				pvLinAddr;
+
+	
+	IMG_PVOID				pvLinAddrKM;
+
+	
+	IMG_DEV_VIRTADDR		sDevVAddr;
+
+	
+
+
+
+
+	IMG_CPU_PHYADDR			sCpuPAddr;
+
+	
+	IMG_UINT32				ui32Flags;
+
+	
+
+
+	IMG_UINT32				ui32ClientFlags;
+
+	
+	IMG_SIZE_T				uAllocSize;
+
+
+	
+	struct _PVRSRV_CLIENT_SYNC_INFO_	*psClientSyncInfo;
+
+#if defined (SUPPORT_SID_INTERFACE)
+	
+	IMG_SID								hMappingInfo;
+
+	
+	IMG_SID								hKernelMemInfo;
+
+	
+	IMG_SID								hResItem;
+#else
+	
+	IMG_HANDLE							hMappingInfo;
+
+	
+	IMG_HANDLE							hKernelMemInfo;
+
+	
+	IMG_HANDLE							hResItem;
+#endif
+
+#if defined(SUPPORT_MEMINFO_IDS)
+	#if !defined(USE_CODE)
+	
+	IMG_UINT64							ui64Stamp;
+	#else 
+	IMG_UINT32							dummy1;
+	IMG_UINT32							dummy2;
+	#endif 
+#endif 
+
+	
+
+
+	struct _PVRSRV_CLIENT_MEM_INFO_		*psNext;
+
+} PVRSRV_CLIENT_MEM_INFO, *PPVRSRV_CLIENT_MEM_INFO;
+
+
+#define PVRSRV_MAX_CLIENT_HEAPS (32)
+typedef struct _PVRSRV_HEAP_INFO_
+{
+	IMG_UINT32			ui32HeapID;
+#if defined (SUPPORT_SID_INTERFACE)
+	IMG_SID 			hDevMemHeap;
+#else
+	IMG_HANDLE 			hDevMemHeap;
+#endif
+	IMG_DEV_VIRTADDR	sDevVAddrBase;
+	IMG_UINT32			ui32HeapByteSize;
+	IMG_UINT32			ui32Attribs;
+	IMG_UINT32			ui32XTileStride;
+}PVRSRV_HEAP_INFO;
+
+
+
+
+typedef struct _PVRSRV_EVENTOBJECT_
+{
+	
+	IMG_CHAR	szName[EVENTOBJNAME_MAXLENGTH];
+	
+#if defined (SUPPORT_SID_INTERFACE)
+	IMG_SID     hOSEventKM;
+#else
+	IMG_HANDLE	hOSEventKM;
+#endif
+
+} PVRSRV_EVENTOBJECT;
+
+typedef enum
+{
+	PVRSRV_MISC_INFO_CPUCACHEOP_NONE = 0,
+	PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN,
+	PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH,
+	PVRSRV_MISC_INFO_CPUCACHEOP_CUSTOM_FLUSH,
+	PVRSRV_MISC_INFO_CPUCACHEOP_CUSTOM_INV
+} PVRSRV_MISC_INFO_CPUCACHEOP_TYPE;
+
+typedef struct _PVRSRV_MISC_INFO_
+{
+	IMG_UINT32	ui32StateRequest;		
+	IMG_UINT32	ui32StatePresent;		
+
+	
+	IMG_VOID	*pvSOCTimerRegisterKM;
+	IMG_VOID	*pvSOCTimerRegisterUM;
+#if defined (SUPPORT_SID_INTERFACE)
+	IMG_SID		hSOCTimerRegisterOSMemHandle;
+	IMG_SID		hSOCTimerRegisterMappingInfo;
+#else
+	IMG_HANDLE	hSOCTimerRegisterOSMemHandle;
+	IMG_HANDLE	hSOCTimerRegisterMappingInfo;
+#endif
+
+	
+	IMG_VOID	*pvSOCClockGateRegs;
+	IMG_UINT32	ui32SOCClockGateRegsSize;
+
+	
+	IMG_CHAR	*pszMemoryStr;
+	IMG_UINT32	ui32MemoryStrLen;
+
+	
+	PVRSRV_EVENTOBJECT	sGlobalEventObject;
+#if defined (SUPPORT_SID_INTERFACE)
+	IMG_EVENTSID		hOSGlobalEvent;
+#else
+	IMG_HANDLE			hOSGlobalEvent;
+#endif
+
+	
+	IMG_UINT32	aui32DDKVersion[4];
+
+	
+	struct
+	{
+		
+		IMG_BOOL bDeferOp;
+
+		
+		PVRSRV_MISC_INFO_CPUCACHEOP_TYPE eCacheOpType;
+
+		
+#if !defined (SUPPORT_SID_INTERFACE)
+		union
+		{
+			
+			PVRSRV_CLIENT_MEM_INFO *psClientMemInfo;
+
+			
+			struct _PVRSRV_KERNEL_MEM_INFO_ *psKernelMemInfo;
+		} u;
+#endif
+
+		
+		IMG_VOID *pvBaseVAddr;
+
+		
+		IMG_UINT32	ui32Length;
+	} sCacheOpCtl;
+} PVRSRV_MISC_INFO;
+
+typedef struct _PVRSRV_SYNC_TOKEN_
+{
+	
+
+	struct
+	{
+#if defined (SUPPORT_SID_INTERFACE)
+		IMG_SID    hKernelSyncInfo;
+#else
+		IMG_HANDLE hKernelSyncInfo;
+#endif
+		IMG_UINT32 ui32ReadOpsPendingSnapshot;
+		IMG_UINT32 ui32WriteOpsPendingSnapshot;
+	} sPrivate;
+} PVRSRV_SYNC_TOKEN;
+
+
+typedef enum _PVRSRV_CLIENT_EVENT_
+{
+	PVRSRV_CLIENT_EVENT_HWTIMEOUT = 0,
+} PVRSRV_CLIENT_EVENT;
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVClientEvent(IMG_CONST PVRSRV_CLIENT_EVENT eEvent,
+											PVRSRV_DEV_DATA *psDevData,
+											IMG_PVOID pvData);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVConnect(PVRSRV_CONNECTION **ppsConnection, IMG_UINT32 ui32SrvFlags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVDisconnect(IMG_CONST PVRSRV_CONNECTION *psConnection);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevices(IMG_CONST PVRSRV_CONNECTION 			*psConnection,
+													IMG_UINT32 					*puiNumDevices,
+													PVRSRV_DEVICE_IDENTIFIER 	*puiDevIDs);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVAcquireDeviceData(IMG_CONST PVRSRV_CONNECTION 	*psConnection,
+													IMG_UINT32			uiDevIndex,
+													PVRSRV_DEV_DATA		*psDevData,
+													PVRSRV_DEVICE_TYPE	eDeviceType);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfo (IMG_CONST PVRSRV_CONNECTION *psConnection, PVRSRV_MISC_INFO *psMiscInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVReleaseMiscInfo (IMG_CONST PVRSRV_CONNECTION *psConnection, PVRSRV_MISC_INFO *psMiscInfo);
+
+#if 1
+IMG_IMPORT
+IMG_UINT32 ReadHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset);
+
+IMG_IMPORT
+IMG_VOID WriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset, IMG_UINT32 ui32Value);
+
+IMG_IMPORT IMG_VOID WriteHWRegs(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Count, PVRSRV_HWREG *psHWRegs);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR PVRSRVPollForValue ( const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+							IMG_SID    hOSEvent,
+#else
+							IMG_HANDLE hOSEvent,
+#endif
+							volatile IMG_UINT32 *pui32LinMemAddr,
+							IMG_UINT32 ui32Value,
+							IMG_UINT32 ui32Mask,
+							IMG_UINT32 ui32Waitus,
+							IMG_UINT32 ui32Tries);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDeviceMemContext(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID    *phDevMemContext,
+#else
+											IMG_HANDLE *phDevMemContext,
+#endif
+											IMG_UINT32 *pui32SharedHeapCount,
+											PVRSRV_HEAP_INFO *psHeapInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDeviceMemContext(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID 			hDevMemContext);
+#else
+											IMG_HANDLE 			hDevMemContext);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfo(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID     hDevMemContext,
+#else
+											IMG_HANDLE hDevMemContext,
+#endif
+											IMG_UINT32 *pui32SharedHeapCount,
+											PVRSRV_HEAP_INFO *psHeapInfo);
+
+#if defined(PVRSRV_LOG_MEMORY_ALLOCS)
+	#define PVRSRVAllocDeviceMem_log(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo, logStr) \
+		(PVR_TRACE(("PVRSRVAllocDeviceMem(" #psDevData "," #hDevMemHeap "," #ui32Attribs "," #ui32Size "," #ui32Alignment "," #ppsMemInfo ")" \
+			": " logStr " (size = 0x%lx)", ui32Size)), \
+		PVRSRVAllocDeviceMem(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo))
+#else
+	#define PVRSRVAllocDeviceMem_log(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo, logStr) \
+		PVRSRVAllocDeviceMem(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo)
+#endif
+
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMem(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+									IMG_SID			hDevMemHeap,
+#else
+									IMG_HANDLE		hDevMemHeap,
+#endif
+									IMG_UINT32		ui32Attribs,
+									IMG_SIZE_T		ui32Size,
+									IMG_SIZE_T		ui32Alignment,
+									PVRSRV_CLIENT_MEM_INFO	**ppsMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMem(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+								PVRSRV_CLIENT_MEM_INFO		*psMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVRemapToDev(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+								PVRSRV_CLIENT_MEM_INFO		*psMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapFromDev(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+								PVRSRV_CLIENT_MEM_INFO		*psMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVExportDeviceMem(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+												PVRSRV_CLIENT_MEM_INFO		*psMemInfo,
+#if defined (SUPPORT_SID_INTERFACE)
+												IMG_SID						*phMemInfo);
+#else
+												IMG_HANDLE					*phMemInfo);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVReserveDeviceVirtualMem(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID				hDevMemHeap,
+#else
+											IMG_HANDLE			hDevMemHeap,
+#endif
+											IMG_DEV_VIRTADDR	*psDevVAddr,
+											IMG_SIZE_T			ui32Size,
+											IMG_SIZE_T			ui32Alignment,
+											PVRSRV_CLIENT_MEM_INFO		**ppsMemInfo);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceVirtualMem(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+													PVRSRV_CLIENT_MEM_INFO *psMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+									IMG_SID hKernelMemInfo,
+									IMG_SID hDstDevMemHeap,
+#else
+									IMG_HANDLE hKernelMemInfo,
+									IMG_HANDLE hDstDevMemHeap,
+#endif
+									PVRSRV_CLIENT_MEM_INFO **ppsDstMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
+										PVRSRV_CLIENT_MEM_INFO *psMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVMapExtMemory (IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+									PVRSRV_CLIENT_MEM_INFO		*psMemInfo,
+									IMG_SYS_PHYADDR				*psSysPAddr,
+									IMG_UINT32					ui32Flags);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapExtMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
+									PVRSRV_CLIENT_MEM_INFO		*psMemInfo,
+									IMG_UINT32					ui32Flags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemory(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+												IMG_SID					hDevMemContext,
+#else
+												IMG_HANDLE				hDevMemContext,
+#endif
+												IMG_SIZE_T 				ui32ByteSize,
+												IMG_SIZE_T				ui32PageOffset,
+												IMG_BOOL				bPhysContig,
+												IMG_SYS_PHYADDR	 		*psSysPAddr,
+												IMG_VOID 				*pvLinAddr,
+												IMG_UINT32				ui32Flags,
+												PVRSRV_CLIENT_MEM_INFO **ppsMemInfo);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVUnwrapExtMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
+												PVRSRV_CLIENT_MEM_INFO *psMemInfo);
+
+PVRSRV_ERROR PVRSRVChangeDeviceMemoryAttributes(IMG_CONST PVRSRV_DEV_DATA			*psDevData,
+												PVRSRV_CLIENT_MEM_INFO	*psClientMemInfo,
+												IMG_UINT32				ui32Attribs);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID hDevMemContext,
+										IMG_SID hDeviceClassBuffer,
+#else
+										IMG_HANDLE hDevMemContext,
+										IMG_HANDLE hDeviceClassBuffer,
+#endif
+										PVRSRV_CLIENT_MEM_INFO **ppsMemInfo);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceClassMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
+										PVRSRV_CLIENT_MEM_INFO *psMemInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVMapPhysToUserSpace(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+									  IMG_SYS_PHYADDR sSysPhysAddr,
+									  IMG_UINT32 uiSizeInBytes,
+									  IMG_PVOID *ppvUserAddr,
+									  IMG_UINT32 *puiActualSize,
+									  IMG_PVOID *ppvProcess);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapPhysToUserSpace(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+										IMG_PVOID pvUserAddr,
+										IMG_PVOID pvProcess);
+
+#if defined(LINUX)
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVExportDeviceMem2(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+												 PVRSRV_CLIENT_MEM_INFO		*psMemInfo,
+												 IMG_INT					*iFd);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemory2(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+												 IMG_INT					iFd,
+#if defined (SUPPORT_SID_INTERFACE)
+												 IMG_SID					hDstDevMemHeap,
+#else
+												 IMG_HANDLE					hDstDevMemHeap,
+#endif
+												 PVRSRV_CLIENT_MEM_INFO		**ppsDstMemInfo);
+#endif 
+
+typedef enum _PVRSRV_SYNCVAL_MODE_
+{
+	PVRSRV_SYNCVAL_READ				= IMG_TRUE,
+	PVRSRV_SYNCVAL_WRITE			= IMG_FALSE,
+
+} PVRSRV_SYNCVAL_MODE, *PPVRSRV_SYNCVAL_MODE;
+
+typedef IMG_UINT32 PVRSRV_SYNCVAL;
+
+IMG_IMPORT PVRSRV_ERROR PVRSRVWaitForOpsComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode, PVRSRV_SYNCVAL OpRequired);
+
+IMG_IMPORT PVRSRV_ERROR PVRSRVWaitForAllOpsComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode);
+
+IMG_IMPORT IMG_BOOL PVRSRVTestOpsComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode, PVRSRV_SYNCVAL OpRequired);
+
+IMG_IMPORT IMG_BOOL PVRSRVTestAllOpsComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode);
+
+IMG_IMPORT IMG_BOOL PVRSRVTestOpsNotComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode, PVRSRV_SYNCVAL OpRequired);
+
+IMG_IMPORT IMG_BOOL PVRSRVTestAllOpsNotComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode);
+
+IMG_IMPORT PVRSRV_SYNCVAL PVRSRVGetPendingOpSyncVal(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
+	PVRSRV_SYNCVAL_MODE eMode);
+
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDeviceClass(IMG_CONST PVRSRV_CONNECTION *psConnection,
+													PVRSRV_DEVICE_CLASS DeviceClass,
+													IMG_UINT32 *pui32DevCount,
+													IMG_UINT32 *pui32DevID);
+
+IMG_IMPORT
+IMG_HANDLE IMG_CALLCONV PVRSRVOpenDCDevice(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+											IMG_UINT32 ui32DeviceID);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCloseDCDevice(IMG_CONST PVRSRV_CONNECTION	*psConnection, IMG_HANDLE hDevice);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumDCFormats (IMG_HANDLE hDevice,
+											IMG_UINT32		*pui32Count,
+											DISPLAY_FORMAT	*psFormat);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumDCDims (IMG_HANDLE hDevice,
+										IMG_UINT32 		*pui32Count,
+										DISPLAY_FORMAT	*psFormat,
+										DISPLAY_DIMS	*psDims);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDCSystemBuffer(IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID *phBuffer);
+#else
+										IMG_HANDLE *phBuffer);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDCInfo(IMG_HANDLE hDevice,
+										DISPLAY_INFO* psDisplayInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDCSwapChain (IMG_HANDLE				hDevice,
+													IMG_UINT32				ui32Flags,
+													DISPLAY_SURF_ATTRIBUTES	*psDstSurfAttrib,
+													DISPLAY_SURF_ATTRIBUTES	*psSrcSurfAttrib,
+													IMG_UINT32				ui32BufferCount,
+													IMG_UINT32				ui32OEMFlags,
+													IMG_UINT32				*pui32SwapChainID,
+#if defined (SUPPORT_SID_INTERFACE)
+													IMG_SID					*phSwapChain);
+#else
+													IMG_HANDLE				*phSwapChain);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDCSwapChain (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID hSwapChain);
+#else
+											IMG_HANDLE		hSwapChain);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCDstRect (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID		hSwapChain,
+#else
+										IMG_HANDLE	hSwapChain,
+#endif
+										IMG_RECT	*psDstRect);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCSrcRect (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID		hSwapChain,
+#else
+										IMG_HANDLE	hSwapChain,
+#endif
+										IMG_RECT	*psSrcRect);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCDstColourKey (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID		hSwapChain,
+#else
+											IMG_HANDLE	hSwapChain,
+#endif
+											IMG_UINT32	ui32CKColour);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCSrcColourKey (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID		hSwapChain,
+#else
+											IMG_HANDLE	hSwapChain,
+#endif
+											IMG_UINT32	ui32CKColour);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDCBuffers(IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+									IMG_SID     hSwapChain,
+									IMG_SID    *phBuffer);
+#else
+									IMG_HANDLE hSwapChain,
+									IMG_HANDLE *phBuffer);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSwapToDCBuffer (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID    hBuffer,
+#else
+										IMG_HANDLE hBuffer,
+#endif
+										IMG_UINT32 ui32ClipRectCount,
+										IMG_RECT  *psClipRect,
+										IMG_UINT32 ui32SwapInterval,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID hPrivateTag);
+#else
+										IMG_HANDLE hPrivateTag);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSwapToDCSystem (IMG_HANDLE hDevice,
+#if defined (SUPPORT_SID_INTERFACE)
+										IMG_SID hSwapChain);
+#else
+										IMG_HANDLE hSwapChain);
+#endif
+
+
+IMG_IMPORT
+IMG_HANDLE IMG_CALLCONV PVRSRVOpenBCDevice(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+											IMG_UINT32 ui32DeviceID);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCloseBCDevice(IMG_CONST PVRSRV_CONNECTION *psConnection,
+												IMG_HANDLE hDevice);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetBCBufferInfo(IMG_HANDLE hDevice,
+												BUFFER_INFO	*psBuffer);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetBCBuffer(IMG_HANDLE hDevice,
+												IMG_UINT32 ui32BufferIndex,
+#if defined (SUPPORT_SID_INTERFACE)
+												IMG_SID   *phBuffer);
+#else
+												IMG_HANDLE *phBuffer);
+#endif
+
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpInit(IMG_CONST PVRSRV_CONNECTION *psConnection);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpStartInitPhase(IMG_CONST PVRSRV_CONNECTION *psConnection);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpStopInitPhase(IMG_CONST PVRSRV_CONNECTION *psConnection);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMemPol(IMG_CONST PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+										  IMG_SID    hKernelMemInfo,
+#else
+										  PVRSRV_CLIENT_MEM_INFO *psMemInfo,
+#endif										  
+										  IMG_UINT32 ui32Offset,
+										  IMG_UINT32 ui32Value,
+										  IMG_UINT32 ui32Mask,
+										  PDUMP_POLL_OPERATOR eOperator,
+										  IMG_UINT32 ui32Flags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSyncPol(IMG_CONST PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+											 IMG_SID    hKernelSyncInfo,
+#else
+											 PVRSRV_CLIENT_SYNC_INFO *psClientSyncInfo,
+#endif
+											 IMG_BOOL   bIsRead,
+											 IMG_UINT32 ui32Value,
+											 IMG_UINT32 ui32Mask);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSyncPol2(IMG_CONST PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+											 IMG_SID  hKernelSyncInfo,
+#else
+											 PVRSRV_CLIENT_SYNC_INFO *psClientSyncInfo,
+#endif
+											 IMG_BOOL bIsRead);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMem(IMG_CONST PVRSRV_CONNECTION *psConnection,
+									IMG_PVOID pvAltLinAddr,
+									PVRSRV_CLIENT_MEM_INFO *psMemInfo,
+									IMG_UINT32 ui32Offset,
+									IMG_UINT32 ui32Bytes,
+									IMG_UINT32 ui32Flags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSync(IMG_CONST PVRSRV_CONNECTION *psConnection,
+										IMG_PVOID pvAltLinAddr,
+										PVRSRV_CLIENT_SYNC_INFO *psClientSyncInfo,
+										IMG_UINT32 ui32Offset,
+										IMG_UINT32 ui32Bytes);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpReg(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+										 IMG_CHAR *pszRegRegion,
+											IMG_UINT32 ui32RegAddr,
+											IMG_UINT32 ui32RegValue,
+											IMG_UINT32 ui32Flags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPolWithFlags(const PVRSRV_DEV_DATA *psDevData,
+													 IMG_CHAR *pszRegRegion,
+													 IMG_UINT32 ui32RegAddr,
+													 IMG_UINT32 ui32RegValue,
+													 IMG_UINT32 ui32Mask,
+													 IMG_UINT32 ui32Flags);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPol(const PVRSRV_DEV_DATA *psDevData,
+											IMG_CHAR *pszRegRegion,
+											IMG_UINT32 ui32RegAddr,
+											IMG_UINT32 ui32RegValue,
+											IMG_UINT32 ui32Mask);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpPDReg(IMG_CONST PVRSRV_CONNECTION *psConnection,
+											IMG_UINT32 ui32RegAddr,
+											IMG_UINT32 ui32RegValue);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpPDDevPAddr(IMG_CONST PVRSRV_CONNECTION *psConnection,
+												PVRSRV_CLIENT_MEM_INFO *psMemInfo,
+												IMG_UINT32 ui32Offset,
+												IMG_DEV_PHYADDR sPDDevPAddr);
+
+#if !defined(USE_CODE)
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMemPages(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+#if defined (SUPPORT_SID_INTERFACE)
+														   IMG_SID				hKernelMemInfo,
+#else
+														   IMG_HANDLE			hKernelMemInfo,
+#endif
+														   IMG_DEV_PHYADDR		*pPages,
+														   IMG_UINT32			ui32NumPages,
+												   		   IMG_DEV_VIRTADDR		sDevVAddr,
+														   IMG_UINT32			ui32Start,
+														   IMG_UINT32			ui32Length,
+														   IMG_UINT32			ui32Flags);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSetFrame(IMG_CONST PVRSRV_CONNECTION *psConnection,
+											  IMG_UINT32 ui32Frame);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpComment(IMG_CONST PVRSRV_CONNECTION *psConnection,
+											 IMG_CONST IMG_CHAR *pszComment,
+											 IMG_BOOL bContinuous);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCommentf(IMG_CONST PVRSRV_CONNECTION *psConnection,
+											  IMG_BOOL bContinuous,
+											  IMG_CONST IMG_CHAR *pszFormat, ...)
+#if !defined(USE_CODE)
+											  IMG_FORMAT_PRINTF(3, 4)
+#endif
+;
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCommentWithFlagsf(IMG_CONST PVRSRV_CONNECTION *psConnection,
+													   IMG_UINT32 ui32Flags,
+													   IMG_CONST IMG_CHAR *pszFormat, ...)
+#if !defined(USE_CODE)
+													   IMG_FORMAT_PRINTF(3, 4)
+#endif
+;
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpDriverInfo(IMG_CONST PVRSRV_CONNECTION *psConnection,
+								 				IMG_CHAR *pszString,
+												IMG_BOOL bContinuous);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpIsCapturing(IMG_CONST PVRSRV_CONNECTION *psConnection,
+								 				IMG_BOOL *pbIsCapturing);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpBitmap(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+								 			IMG_CHAR *pszFileName,
+											IMG_UINT32 ui32FileOffset,
+											IMG_UINT32 ui32Width,
+											IMG_UINT32 ui32Height,
+											IMG_UINT32 ui32StrideInBytes,
+											IMG_DEV_VIRTADDR sDevBaseAddr,
+#if defined (SUPPORT_SID_INTERFACE)
+											IMG_SID    hDevMemContext,
+#else
+											IMG_HANDLE hDevMemContext,
+#endif
+											IMG_UINT32 ui32Size,
+											PDUMP_PIXEL_FORMAT ePixelFormat,
+											PDUMP_MEM_FORMAT eMemFormat,
+											IMG_UINT32 ui32PDumpFlags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegRead(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+											IMG_CONST IMG_CHAR *pszRegRegion,
+								 			IMG_CONST IMG_CHAR *pszFileName,
+											IMG_UINT32 ui32FileOffset,
+											IMG_UINT32 ui32Address,
+											IMG_UINT32 ui32Size,
+											IMG_UINT32 ui32PDumpFlags);
+
+
+IMG_IMPORT
+IMG_BOOL IMG_CALLCONV PVRSRVPDumpIsCapturingTest(IMG_CONST PVRSRV_CONNECTION *psConnection);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCycleCountRegRead(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+														IMG_UINT32 ui32RegOffset,
+														IMG_BOOL bLastFrame);
+
+IMG_IMPORT IMG_HANDLE	PVRSRVLoadLibrary(const IMG_CHAR *pszLibraryName);
+IMG_IMPORT PVRSRV_ERROR	PVRSRVUnloadLibrary(IMG_HANDLE hExtDrv);
+IMG_IMPORT PVRSRV_ERROR	PVRSRVGetLibFuncAddr(IMG_HANDLE hExtDrv, const IMG_CHAR *pszFunctionName, IMG_VOID **ppvFuncAddr);
+
+IMG_IMPORT IMG_UINT32 PVRSRVClockus (void);
+IMG_IMPORT IMG_VOID PVRSRVWaitus (IMG_UINT32 ui32Timeus);
+IMG_IMPORT IMG_VOID PVRSRVReleaseThreadQuanta (void);
+IMG_IMPORT IMG_UINT32 IMG_CALLCONV PVRSRVGetCurrentProcessID(void);
+IMG_IMPORT IMG_CHAR * IMG_CALLCONV PVRSRVSetLocale(const IMG_CHAR *pszLocale);
+
+
+
+
+
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVCreateAppHintState(IMG_MODULE_ID eModuleID,
+														const IMG_CHAR *pszAppName,
+														IMG_VOID **ppvState);
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVFreeAppHintState(IMG_MODULE_ID eModuleID,
+										 IMG_VOID *pvHintState);
+
+IMG_IMPORT IMG_BOOL IMG_CALLCONV PVRSRVGetAppHint(IMG_VOID			*pvHintState,
+												  const IMG_CHAR	*pszHintName,
+												  IMG_DATA_TYPE		eDataType,
+												  const IMG_VOID	*pvDefault,
+												  IMG_VOID			*pvReturn);
+
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVAllocUserModeMem (IMG_SIZE_T ui32Size);
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVCallocUserModeMem (IMG_SIZE_T ui32Size);
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVReallocUserModeMem (IMG_PVOID pvBase, IMG_SIZE_T uNewSize);
+IMG_IMPORT IMG_VOID  IMG_CALLCONV PVRSRVFreeUserModeMem (IMG_PVOID pvMem);
+IMG_IMPORT IMG_VOID PVRSRVMemCopy(IMG_VOID *pvDst, const IMG_VOID *pvSrc, IMG_SIZE_T ui32Size);
+IMG_IMPORT IMG_VOID PVRSRVMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_SIZE_T ui32Size);
+
+struct _PVRSRV_MUTEX_OPAQUE_STRUCT_;
+typedef	struct  _PVRSRV_MUTEX_OPAQUE_STRUCT_ *PVRSRV_MUTEX_HANDLE;
+
+IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateMutex(PVRSRV_MUTEX_HANDLE *phMutex);
+IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyMutex(PVRSRV_MUTEX_HANDLE hMutex);
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVLockMutex(PVRSRV_MUTEX_HANDLE hMutex);
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVUnlockMutex(PVRSRV_MUTEX_HANDLE hMutex);
+
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVLockProcessGlobalMutex(void);
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVUnlockProcessGlobalMutex(void);
+
+
+struct _PVRSRV_SEMAPHORE_OPAQUE_STRUCT_;
+typedef	struct  _PVRSRV_SEMAPHORE_OPAQUE_STRUCT_ *PVRSRV_SEMAPHORE_HANDLE;
+
+
+  	#define IMG_SEMAPHORE_WAIT_INFINITE       ((IMG_UINT64)0xFFFFFFFFFFFFFFFFull)
+
+
+#if !defined(USE_CODE)
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVCreateSemaphore)
+#endif
+static INLINE PVRSRV_ERROR PVRSRVCreateSemaphore(PVRSRV_SEMAPHORE_HANDLE *phSemaphore, IMG_INT iInitialCount)
+{
+	PVR_UNREFERENCED_PARAMETER(iInitialCount);
+	*phSemaphore = 0;
+	return PVRSRV_OK;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVDestroySemaphore)
+#endif
+static INLINE PVRSRV_ERROR PVRSRVDestroySemaphore(PVRSRV_SEMAPHORE_HANDLE hSemaphore)
+{
+	PVR_UNREFERENCED_PARAMETER(hSemaphore);
+	return PVRSRV_OK;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVWaitSemaphore)
+#endif
+static INLINE PVRSRV_ERROR PVRSRVWaitSemaphore(PVRSRV_SEMAPHORE_HANDLE hSemaphore, IMG_UINT64 ui64TimeoutMicroSeconds)
+{
+	PVR_UNREFERENCED_PARAMETER(hSemaphore);
+	PVR_UNREFERENCED_PARAMETER(ui64TimeoutMicroSeconds);
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVPostSemaphore)
+#endif
+static INLINE IMG_VOID PVRSRVPostSemaphore(PVRSRV_SEMAPHORE_HANDLE hSemaphore, IMG_INT iPostCount)
+{
+	PVR_UNREFERENCED_PARAMETER(hSemaphore);
+	PVR_UNREFERENCED_PARAMETER(iPostCount);
+}
+
+#endif 
+
+
+#if (defined(DEBUG) && defined(__linux__))
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVAllocUserModeMemTracking(IMG_SIZE_T ui32Size, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
+
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVCallocUserModeMemTracking(IMG_SIZE_T ui32Size, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
+
+IMG_IMPORT IMG_VOID  IMG_CALLCONV PVRSRVFreeUserModeMemTracking(IMG_VOID *pvMem);
+
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVReallocUserModeMemTracking(IMG_VOID *pvMem, IMG_SIZE_T ui32NewSize, 
+													  IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
+#endif 
+
+IMG_IMPORT PVRSRV_ERROR PVRSRVEventObjectWait(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+									IMG_EVENTSID hOSEvent);
+#else
+									IMG_HANDLE hOSEvent);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateSyncInfoModObj(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+													 IMG_SID *phKernelSyncInfoModObj);
+#else
+													 IMG_HANDLE *phKernelSyncInfoModObj);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroySyncInfoModObj(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+													  IMG_SID hKernelSyncInfoModObj);
+#else
+													  IMG_HANDLE hKernelSyncInfoModObj);
+#endif
+
+
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVModifyPendingSyncOps(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+													  IMG_SID    hKernelSyncInfoModObj,
+#else
+													  IMG_HANDLE hKernelSyncInfoModObj,
+#endif
+													  PVRSRV_CLIENT_SYNC_INFO *psSyncInfo,
+													  IMG_UINT32 ui32ModifyFlags,
+													  IMG_UINT32 *pui32ReadOpsPending,
+													  IMG_UINT32 *pui32WriteOpsPending);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVModifyCompleteSyncOps(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+													  IMG_SID hKernelSyncInfoModObj);
+#else
+													  IMG_HANDLE hKernelSyncInfoModObj);
+#endif
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSyncOpsTakeToken(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+												 const IMG_SID      hKernelSyncInfo,
+#else
+												 const PVRSRV_CLIENT_SYNC_INFO *psSyncInfo,
+#endif
+												 PVRSRV_SYNC_TOKEN *psSyncToken);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSyncOpsFlushToToken(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+													const IMG_SID            hKernelSyncInfo,
+#else
+													const PVRSRV_CLIENT_SYNC_INFO *psSyncInfo,
+#endif
+													const PVRSRV_SYNC_TOKEN *psSyncToken,
+													IMG_BOOL bWait);
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSyncOpsFlushToModObj(const PVRSRV_CONNECTION *psConnection,
+#if defined (SUPPORT_SID_INTERFACE)
+													 IMG_SID  hKernelSyncInfoModObj,
+#else
+													 IMG_HANDLE hKernelSyncInfoModObj,
+#endif
+													 IMG_BOOL bWait);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSyncOpsFlushToDelta(const PVRSRV_CONNECTION *psConnection,
+													PVRSRV_CLIENT_SYNC_INFO *psClientSyncInfo,
+													IMG_UINT32 ui32Delta,
+													IMG_BOOL bWait);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfo(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+											  PVRSRV_CLIENT_SYNC_INFO **ppsSyncInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeSyncInfo(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+											 PVRSRV_CLIENT_SYNC_INFO *psSyncInfo);
+
+IMG_IMPORT
+const IMG_CHAR *PVRSRVGetErrorString(PVRSRV_ERROR eError);
+
+
+#define TIME_NOT_PASSED_UINT32(a,b,c)		(((a) - (b)) < (c))
+
+#if defined (__cplusplus)
+}
+#endif
+#endif 
+
diff --git a/sys/pvr2d/pvr_includes/servicesext.h b/sys/pvr2d/pvr_includes/servicesext.h
new file mode 100755
index 0000000..d326245
--- /dev/null
+++ b/sys/pvr2d/pvr_includes/servicesext.h
@@ -0,0 +1,855 @@
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
+
+
+#if !defined (__SERVICESEXT_H__)
+#define __SERVICESEXT_H__
+
+#define PVRSRV_LOCKFLG_READONLY     	(1)		
+
+typedef enum _PVRSRV_ERROR_
+{
+	PVRSRV_OK = 0,
+	PVRSRV_ERROR_OUT_OF_MEMORY,
+	PVRSRV_ERROR_TOO_FEW_BUFFERS,
+	PVRSRV_ERROR_INVALID_PARAMS,
+	PVRSRV_ERROR_INIT_FAILURE,
+	PVRSRV_ERROR_CANT_REGISTER_CALLBACK,
+	PVRSRV_ERROR_INVALID_DEVICE,
+	PVRSRV_ERROR_NOT_OWNER,
+	PVRSRV_ERROR_BAD_MAPPING,
+	PVRSRV_ERROR_TIMEOUT,
+	PVRSRV_ERROR_FLIP_CHAIN_EXISTS,
+	PVRSRV_ERROR_INVALID_SWAPINTERVAL,
+	PVRSRV_ERROR_SCENE_INVALID,
+	PVRSRV_ERROR_STREAM_ERROR,
+	PVRSRV_ERROR_FAILED_DEPENDENCIES,
+	PVRSRV_ERROR_CMD_NOT_PROCESSED,
+	PVRSRV_ERROR_CMD_TOO_BIG,
+	PVRSRV_ERROR_DEVICE_REGISTER_FAILED,
+	PVRSRV_ERROR_TOOMANYBUFFERS,
+	PVRSRV_ERROR_NOT_SUPPORTED,
+	PVRSRV_ERROR_PROCESSING_BLOCKED,
+
+	PVRSRV_ERROR_CANNOT_FLUSH_QUEUE,
+	PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE,
+	PVRSRV_ERROR_CANNOT_GET_RENDERDETAILS,
+	PVRSRV_ERROR_RETRY,
+
+	PVRSRV_ERROR_DDK_VERSION_MISMATCH,
+	PVRSRV_ERROR_BUILD_MISMATCH,
+	PVRSRV_ERROR_CORE_REVISION_MISMATCH,
+
+	PVRSRV_ERROR_UPLOAD_TOO_BIG,
+
+	PVRSRV_ERROR_INVALID_FLAGS,
+	PVRSRV_ERROR_FAILED_TO_REGISTER_PROCESS,
+
+	PVRSRV_ERROR_UNABLE_TO_LOAD_LIBRARY,
+	PVRSRV_ERROR_UNABLE_GET_FUNC_ADDR,
+	PVRSRV_ERROR_UNLOAD_LIBRARY_FAILED,
+
+	PVRSRV_ERROR_BRIDGE_CALL_FAILED,
+	PVRSRV_ERROR_IOCTL_CALL_FAILED,
+
+    PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND,
+	PVRSRV_ERROR_BUFFER_DEVICE_NOT_FOUND,
+	PVRSRV_ERROR_BUFFER_DEVICE_ALREADY_PRESENT,
+
+	PVRSRV_ERROR_PCI_DEVICE_NOT_FOUND,
+	PVRSRV_ERROR_PCI_CALL_FAILED,
+	PVRSRV_ERROR_PCI_REGION_TOO_SMALL,
+	PVRSRV_ERROR_PCI_REGION_UNAVAILABLE,
+	PVRSRV_ERROR_BAD_REGION_SIZE_MISMATCH,
+
+	PVRSRV_ERROR_REGISTER_BASE_NOT_SET,
+
+	PVRSRV_ERROR_FAILED_TO_ALLOC_USER_MEM,
+	PVRSRV_ERROR_FAILED_TO_ALLOC_VP_MEMORY,
+	PVRSRV_ERROR_FAILED_TO_MAP_SHARED_PBDESC,
+	PVRSRV_ERROR_FAILED_TO_GET_PHYS_ADDR,
+
+	PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY,
+	PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY,
+
+	PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES,
+	PVRSRV_ERROR_FAILED_TO_FREE_PAGES,
+	PVRSRV_ERROR_FAILED_TO_COPY_PAGES,
+	PVRSRV_ERROR_UNABLE_TO_LOCK_PAGES,
+	PVRSRV_ERROR_UNABLE_TO_UNLOCK_PAGES,
+	PVRSRV_ERROR_STILL_MAPPED,
+	PVRSRV_ERROR_MAPPING_NOT_FOUND,
+	PVRSRV_ERROR_PHYS_ADDRESS_EXCEEDS_32BIT,
+	PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE,
+
+	PVRSRV_ERROR_INVALID_SEGMENT_BLOCK,
+	PVRSRV_ERROR_INVALID_SGXDEVDATA,
+	PVRSRV_ERROR_INVALID_DEVINFO,
+	PVRSRV_ERROR_INVALID_MEMINFO,
+	PVRSRV_ERROR_INVALID_MISCINFO,
+	PVRSRV_ERROR_UNKNOWN_IOCTL,
+	PVRSRV_ERROR_INVALID_CONTEXT,
+	PVRSRV_ERROR_UNABLE_TO_DESTROY_CONTEXT,
+	PVRSRV_ERROR_INVALID_HEAP,
+	PVRSRV_ERROR_INVALID_KERNELINFO,
+	PVRSRV_ERROR_UNKNOWN_POWER_STATE,
+	PVRSRV_ERROR_INVALID_HANDLE_TYPE,
+	PVRSRV_ERROR_INVALID_WRAP_TYPE,
+	PVRSRV_ERROR_INVALID_PHYS_ADDR,
+	PVRSRV_ERROR_INVALID_CPU_ADDR,
+	PVRSRV_ERROR_INVALID_HEAPINFO,
+	PVRSRV_ERROR_INVALID_PERPROC,
+	PVRSRV_ERROR_FAILED_TO_RETRIEVE_HEAPINFO,
+	PVRSRV_ERROR_INVALID_MAP_REQUEST,
+	PVRSRV_ERROR_INVALID_UNMAP_REQUEST,
+	PVRSRV_ERROR_UNABLE_TO_FIND_MAPPING_HEAP,
+	PVRSRV_ERROR_MAPPING_STILL_IN_USE,
+
+	PVRSRV_ERROR_EXCEEDED_HW_LIMITS,
+	PVRSRV_ERROR_NO_STAGING_BUFFER_ALLOCATED,
+
+	PVRSRV_ERROR_UNABLE_TO_CREATE_PERPROC_AREA,
+	PVRSRV_ERROR_UNABLE_TO_CREATE_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD,
+	PVRSRV_ERROR_UNABLE_TO_CLOSE_THREAD,
+	PVRSRV_ERROR_THREAD_READ_ERROR,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_ISR_HANDLER,
+	PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR,
+	PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR,
+	PVRSRV_ERROR_ISR_ALREADY_INSTALLED,
+	PVRSRV_ERROR_ISR_NOT_INSTALLED,
+	PVRSRV_ERROR_UNABLE_TO_INITIALISE_INTERRUPT,
+	PVRSRV_ERROR_UNABLE_TO_RETRIEVE_INFO,
+	PVRSRV_ERROR_UNABLE_TO_DO_BACKWARDS_BLIT,
+	PVRSRV_ERROR_UNABLE_TO_CLOSE_SERVICES,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE,
+
+	PVRSRV_ERROR_INVALID_CCB_COMMAND,
+
+	PVRSRV_ERROR_UNABLE_TO_LOCK_RESOURCE,
+	PVRSRV_ERROR_INVALID_LOCK_ID,
+	PVRSRV_ERROR_RESOURCE_NOT_LOCKED,
+
+	PVRSRV_ERROR_FLIP_FAILED,
+	PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED,
+
+	PVRSRV_ERROR_TIMEOUT_POLLING_FOR_VALUE,
+
+	PVRSRV_ERROR_CREATE_RENDER_CONTEXT_FAILED,
+	PVRSRV_ERROR_UNKNOWN_PRIMARY_FRAG,
+	PVRSRV_ERROR_UNEXPECTED_SECONDARY_FRAG,
+	PVRSRV_ERROR_UNEXPECTED_PRIMARY_FRAG,
+
+	PVRSRV_ERROR_UNABLE_TO_INSERT_FENCE_ID,
+
+	PVRSRV_ERROR_BLIT_SETUP_FAILED,
+
+	PVRSRV_ERROR_PDUMP_NOT_AVAILABLE,
+	PVRSRV_ERROR_PDUMP_BUFFER_FULL,
+	PVRSRV_ERROR_PDUMP_BUF_OVERFLOW,
+	PVRSRV_ERROR_PDUMP_NOT_ACTIVE,
+	PVRSRV_ERROR_INCOMPLETE_LINE_OVERLAPS_PAGES,
+
+	PVRSRV_ERROR_MUTEX_DESTROY_FAILED,
+	PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR,
+
+	PVRSRV_ERROR_INSUFFICIENT_SCRIPT_SPACE,
+	PVRSRV_ERROR_INSUFFICIENT_SPACE_FOR_COMMAND,
+
+	PVRSRV_ERROR_PROCESS_NOT_INITIALISED,
+	PVRSRV_ERROR_PROCESS_NOT_FOUND,
+	PVRSRV_ERROR_SRV_CONNECT_FAILED,
+	PVRSRV_ERROR_SRV_DISCONNECT_FAILED,
+	PVRSRV_ERROR_DEINT_PHASE_FAILED,
+	PVRSRV_ERROR_INIT2_PHASE_FAILED,
+
+	PVRSRV_ERROR_UNABLE_TO_FIND_RESOURCE,
+
+	PVRSRV_ERROR_NO_DC_DEVICES_FOUND,
+	PVRSRV_ERROR_UNABLE_TO_OPEN_DC_DEVICE,
+	PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE,
+	PVRSRV_ERROR_NO_DEVICEDATA_FOUND,
+	PVRSRV_ERROR_NO_DEVICENODE_FOUND,
+	PVRSRV_ERROR_NO_CLIENTNODE_FOUND,
+	PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE,
+
+	PVRSRV_ERROR_UNABLE_TO_INIT_TASK,
+	PVRSRV_ERROR_UNABLE_TO_SCHEDULE_TASK,
+	PVRSRV_ERROR_UNABLE_TO_KILL_TASK,
+
+	PVRSRV_ERROR_UNABLE_TO_ENABLE_TIMER,
+	PVRSRV_ERROR_UNABLE_TO_DISABLE_TIMER,
+	PVRSRV_ERROR_UNABLE_TO_REMOVE_TIMER,
+
+	PVRSRV_ERROR_UNKNOWN_PIXEL_FORMAT,
+	PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION,
+
+	PVRSRV_ERROR_HANDLE_INDEX_OUT_OF_RANGE,
+	PVRSRV_ERROR_HANDLE_NOT_ALLOCATED,
+	PVRSRV_ERROR_HANDLE_TYPE_MISMATCH,
+	PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE,
+	PVRSRV_ERROR_HANDLE_NOT_SHAREABLE,
+	PVRSRV_ERROR_HANDLE_NOT_FOUND,
+	PVRSRV_ERROR_INVALID_SUBHANDLE,
+	PVRSRV_ERROR_HANDLE_BATCH_IN_USE,
+	PVRSRV_ERROR_HANDLE_BATCH_COMMIT_FAILURE,
+
+	PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE,
+	PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED,
+
+	PVRSRV_ERROR_UNSUPPORTED_BACKING_STORE,
+	PVRSRV_ERROR_UNABLE_TO_DESTROY_BM_HEAP,
+
+	PVRSRV_ERROR_UNKNOWN_INIT_SERVER_STATE,
+
+	PVRSRV_ERROR_NO_FREE_DEVICEIDS_AVALIABLE,
+	PVRSRV_ERROR_INVALID_DEVICEID,
+	PVRSRV_ERROR_DEVICEID_NOT_FOUND,
+
+	PVRSRV_ERROR_MEMORY_TEST_FAILED,
+	PVRSRV_ERROR_CPUPADDR_TEST_FAILED,
+	PVRSRV_ERROR_COPY_TEST_FAILED,
+
+	PVRSRV_ERROR_SEMAPHORE_NOT_INITIALISED,
+
+	PVRSRV_ERROR_UNABLE_TO_RELEASE_CLOCK,
+	PVRSRV_ERROR_CLOCK_REQUEST_FAILED,
+	PVRSRV_ERROR_DISABLE_CLOCK_FAILURE,
+	PVRSRV_ERROR_UNABLE_TO_SET_CLOCK_RATE,
+	PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE,
+	PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK,
+	PVRSRV_ERROR_UNABLE_TO_GET_CLOCK,
+	PVRSRV_ERROR_UNABLE_TO_GET_PARENT_CLOCK,
+	PVRSRV_ERROR_UNABLE_TO_GET_SYSTEM_CLOCK,
+
+	PVRSRV_ERROR_UNKNOWN_SGL_ERROR,
+
+	PVRSRV_ERROR_SYSTEM_POWER_CHANGE_FAILURE,
+	PVRSRV_ERROR_DEVICE_POWER_CHANGE_FAILURE,
+
+	PVRSRV_ERROR_BAD_SYNC_STATE,
+
+	PVRSRV_ERROR_CACHEOP_FAILED,
+
+	PVRSRV_ERROR_FORCE_I32 = 0x7fffffff
+
+} PVRSRV_ERROR;
+
+
+typedef enum _PVRSRV_DEVICE_CLASS_
+{
+	PVRSRV_DEVICE_CLASS_3D				= 0 ,
+	PVRSRV_DEVICE_CLASS_DISPLAY			= 1 ,
+	PVRSRV_DEVICE_CLASS_BUFFER			= 2 ,
+	PVRSRV_DEVICE_CLASS_VIDEO			= 3 ,
+
+	PVRSRV_DEVICE_CLASS_FORCE_I32 		= 0x7fffffff
+
+} PVRSRV_DEVICE_CLASS;
+
+
+typedef enum _PVRSRV_SYS_POWER_STATE_
+{
+	PVRSRV_SYS_POWER_STATE_Unspecified		= -1,	
+	PVRSRV_SYS_POWER_STATE_D0				= 0,	
+	PVRSRV_SYS_POWER_STATE_D1				= 1,	
+	PVRSRV_SYS_POWER_STATE_D2				= 2,	
+	PVRSRV_SYS_POWER_STATE_D3				= 3,	
+	PVRSRV_SYS_POWER_STATE_D4				= 4,	
+
+	PVRSRV_SYS_POWER_STATE_FORCE_I32 = 0x7fffffff
+
+} PVRSRV_SYS_POWER_STATE, *PPVRSRV_SYS_POWER_STATE;
+
+
+typedef enum _PVRSRV_DEV_POWER_STATE_
+{
+	PVRSRV_DEV_POWER_STATE_DEFAULT	= -1,	
+	PVRSRV_DEV_POWER_STATE_ON		= 0,	
+	PVRSRV_DEV_POWER_STATE_IDLE		= 1,	
+	PVRSRV_DEV_POWER_STATE_OFF		= 2,	
+
+	PVRSRV_DEV_POWER_STATE_FORCE_I32 = 0x7fffffff
+
+} PVRSRV_DEV_POWER_STATE, *PPVRSRV_DEV_POWER_STATE;	
+
+
+typedef PVRSRV_ERROR (*PFN_PRE_POWER) (IMG_HANDLE				hDevHandle,
+									   PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									   PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
+typedef PVRSRV_ERROR (*PFN_POST_POWER) (IMG_HANDLE				hDevHandle,
+										PVRSRV_DEV_POWER_STATE	eNewPowerState,
+										PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
+
+typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE				hDevHandle,
+												   IMG_BOOL					bIdleDevice,
+												   PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
+typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE				hDevHandle,
+													IMG_BOOL				bIdleDevice,
+													PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
+
+
+typedef enum _PVRSRV_PIXEL_FORMAT_ {
+	
+	PVRSRV_PIXEL_FORMAT_UNKNOWN				=  0,
+	PVRSRV_PIXEL_FORMAT_RGB565				=  1,
+	PVRSRV_PIXEL_FORMAT_RGB555				=  2,
+	PVRSRV_PIXEL_FORMAT_RGB888				=  3,	
+	PVRSRV_PIXEL_FORMAT_BGR888				=  4,	
+	PVRSRV_PIXEL_FORMAT_GREY_SCALE			=  8,
+	PVRSRV_PIXEL_FORMAT_PAL12				= 13,
+	PVRSRV_PIXEL_FORMAT_PAL8				= 14,
+	PVRSRV_PIXEL_FORMAT_PAL4				= 15,
+	PVRSRV_PIXEL_FORMAT_PAL2				= 16,
+	PVRSRV_PIXEL_FORMAT_PAL1				= 17,
+	PVRSRV_PIXEL_FORMAT_ARGB1555			= 18,
+	PVRSRV_PIXEL_FORMAT_ARGB4444			= 19,
+	PVRSRV_PIXEL_FORMAT_ARGB8888			= 20,
+	PVRSRV_PIXEL_FORMAT_ABGR8888			= 21,
+	PVRSRV_PIXEL_FORMAT_YV12				= 22,
+	PVRSRV_PIXEL_FORMAT_I420				= 23,
+    PVRSRV_PIXEL_FORMAT_IMC2				= 25,
+	PVRSRV_PIXEL_FORMAT_XRGB8888			= 26,
+	PVRSRV_PIXEL_FORMAT_XBGR8888			= 27,
+	PVRSRV_PIXEL_FORMAT_BGRA8888			= 28,
+	PVRSRV_PIXEL_FORMAT_XRGB4444			= 29,
+	PVRSRV_PIXEL_FORMAT_ARGB8332			= 30,
+	PVRSRV_PIXEL_FORMAT_A2RGB10				= 31,	
+	PVRSRV_PIXEL_FORMAT_A2BGR10				= 32,	
+	PVRSRV_PIXEL_FORMAT_P8					= 33,
+	PVRSRV_PIXEL_FORMAT_L8					= 34,
+	PVRSRV_PIXEL_FORMAT_A8L8				= 35,
+	PVRSRV_PIXEL_FORMAT_A4L4				= 36,
+	PVRSRV_PIXEL_FORMAT_L16					= 37,
+	PVRSRV_PIXEL_FORMAT_L6V5U5				= 38,
+	PVRSRV_PIXEL_FORMAT_V8U8				= 39,
+	PVRSRV_PIXEL_FORMAT_V16U16				= 40,
+	PVRSRV_PIXEL_FORMAT_QWVU8888			= 41,
+	PVRSRV_PIXEL_FORMAT_XLVU8888			= 42,
+	PVRSRV_PIXEL_FORMAT_QWVU16				= 43,
+	PVRSRV_PIXEL_FORMAT_D16					= 44,
+	PVRSRV_PIXEL_FORMAT_D24S8				= 45,
+	PVRSRV_PIXEL_FORMAT_D24X8				= 46,
+
+	
+	PVRSRV_PIXEL_FORMAT_ABGR16				= 47,
+	PVRSRV_PIXEL_FORMAT_ABGR16F				= 48,
+	PVRSRV_PIXEL_FORMAT_ABGR32				= 49,
+	PVRSRV_PIXEL_FORMAT_ABGR32F				= 50,
+	PVRSRV_PIXEL_FORMAT_B10GR11				= 51,
+	PVRSRV_PIXEL_FORMAT_GR88				= 52,
+	PVRSRV_PIXEL_FORMAT_BGR32				= 53,
+	PVRSRV_PIXEL_FORMAT_GR32				= 54,
+	PVRSRV_PIXEL_FORMAT_E5BGR9				= 55,
+
+	
+	PVRSRV_PIXEL_FORMAT_RESERVED1			= 56,
+	PVRSRV_PIXEL_FORMAT_RESERVED2			= 57,
+	PVRSRV_PIXEL_FORMAT_RESERVED3			= 58,
+	PVRSRV_PIXEL_FORMAT_RESERVED4			= 59,
+	PVRSRV_PIXEL_FORMAT_RESERVED5			= 60,
+
+	
+	PVRSRV_PIXEL_FORMAT_R8G8_B8G8			= 61,
+	PVRSRV_PIXEL_FORMAT_G8R8_G8B8			= 62,
+
+	
+	PVRSRV_PIXEL_FORMAT_NV11				= 63,
+	PVRSRV_PIXEL_FORMAT_NV12				= 64,
+
+	
+	PVRSRV_PIXEL_FORMAT_YUY2				= 65,
+	PVRSRV_PIXEL_FORMAT_YUV420				= 66,
+	PVRSRV_PIXEL_FORMAT_YUV444				= 67,
+	PVRSRV_PIXEL_FORMAT_VUY444				= 68,
+	PVRSRV_PIXEL_FORMAT_YUYV				= 69,
+	PVRSRV_PIXEL_FORMAT_YVYU				= 70,
+	PVRSRV_PIXEL_FORMAT_UYVY				= 71,
+	PVRSRV_PIXEL_FORMAT_VYUY				= 72,
+
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY		= 73,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV		= 74,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YVYU		= 75,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_VYUY		= 76,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_AYUV		= 77,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32		= 78,	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32F		= 79,	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32_UINT	= 80,	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32_SINT	= 81,	
+
+	
+	PVRSRV_PIXEL_FORMAT_B32G32R32			= 82,	
+	PVRSRV_PIXEL_FORMAT_B32G32R32F			= 83,	
+	PVRSRV_PIXEL_FORMAT_B32G32R32_UINT		= 84,	
+	PVRSRV_PIXEL_FORMAT_B32G32R32_SINT		= 85,	
+
+	
+	PVRSRV_PIXEL_FORMAT_G32R32				= 86,	
+	PVRSRV_PIXEL_FORMAT_G32R32F				= 87,	
+	PVRSRV_PIXEL_FORMAT_G32R32_UINT			= 88,	
+	PVRSRV_PIXEL_FORMAT_G32R32_SINT			= 89,	
+
+	
+	PVRSRV_PIXEL_FORMAT_D32F				= 90,	
+	PVRSRV_PIXEL_FORMAT_R32					= 91,	
+	PVRSRV_PIXEL_FORMAT_R32F				= 92,	
+	PVRSRV_PIXEL_FORMAT_R32_UINT			= 93,	
+	PVRSRV_PIXEL_FORMAT_R32_SINT			= 94,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16		= 95,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16F		= 96,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_SINT	= 97,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_SNORM	= 98,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_UINT	= 99,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_UNORM	= 100,	
+
+	
+	PVRSRV_PIXEL_FORMAT_G16R16				= 101,	
+	PVRSRV_PIXEL_FORMAT_G16R16F				= 102,	
+	PVRSRV_PIXEL_FORMAT_G16R16_UINT			= 103,	
+	PVRSRV_PIXEL_FORMAT_G16R16_UNORM		= 104,	
+	PVRSRV_PIXEL_FORMAT_G16R16_SINT			= 105,	
+	PVRSRV_PIXEL_FORMAT_G16R16_SNORM		= 106,	
+
+	
+	PVRSRV_PIXEL_FORMAT_R16					= 107,	
+	PVRSRV_PIXEL_FORMAT_R16F				= 108,	
+	PVRSRV_PIXEL_FORMAT_R16_UINT			= 109,	
+	PVRSRV_PIXEL_FORMAT_R16_UNORM			= 110,	
+	PVRSRV_PIXEL_FORMAT_R16_SINT			= 111,	
+	PVRSRV_PIXEL_FORMAT_R16_SNORM			= 112,	
+
+	
+	PVRSRV_PIXEL_FORMAT_X8R8G8B8			= 113,	
+	PVRSRV_PIXEL_FORMAT_X8R8G8B8_UNORM		= 114,	
+	PVRSRV_PIXEL_FORMAT_X8R8G8B8_UNORM_SRGB	= 115,	
+
+	PVRSRV_PIXEL_FORMAT_A8R8G8B8			= 116,	
+	PVRSRV_PIXEL_FORMAT_A8R8G8B8_UNORM		= 117,	
+	PVRSRV_PIXEL_FORMAT_A8R8G8B8_UNORM_SRGB	= 118,	
+
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8			= 119,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UINT		= 120,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UNORM		= 121,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UNORM_SRGB	= 122,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_SINT		= 123,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_SNORM		= 124,	
+
+	
+	PVRSRV_PIXEL_FORMAT_G8R8				= 125,	
+	PVRSRV_PIXEL_FORMAT_G8R8_UINT			= 126,	
+	PVRSRV_PIXEL_FORMAT_G8R8_UNORM			= 127,	
+	PVRSRV_PIXEL_FORMAT_G8R8_SINT			= 128,	
+	PVRSRV_PIXEL_FORMAT_G8R8_SNORM			= 129,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A8					= 130,	
+	PVRSRV_PIXEL_FORMAT_R8					= 131,	
+	PVRSRV_PIXEL_FORMAT_R8_UINT				= 132,	
+	PVRSRV_PIXEL_FORMAT_R8_UNORM			= 133,	
+	PVRSRV_PIXEL_FORMAT_R8_SINT				= 134,	
+	PVRSRV_PIXEL_FORMAT_R8_SNORM			= 135,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10			= 136,	
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10_UNORM	= 137,	
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10_UINT	= 138,	
+
+	
+	PVRSRV_PIXEL_FORMAT_B10G11R11			= 139,	
+	PVRSRV_PIXEL_FORMAT_B10G11R11F			= 140,	
+
+	
+	PVRSRV_PIXEL_FORMAT_X24G8R32			= 141,	
+	PVRSRV_PIXEL_FORMAT_G8R24				= 142,	
+	PVRSRV_PIXEL_FORMAT_X8R24				= 143,
+	PVRSRV_PIXEL_FORMAT_E5B9G9R9			= 144,	
+	PVRSRV_PIXEL_FORMAT_R1					= 145,	
+
+	PVRSRV_PIXEL_FORMAT_RESERVED6			= 146,
+	PVRSRV_PIXEL_FORMAT_RESERVED7			= 147,
+	PVRSRV_PIXEL_FORMAT_RESERVED8			= 148,
+	PVRSRV_PIXEL_FORMAT_RESERVED9			= 149,
+	PVRSRV_PIXEL_FORMAT_RESERVED10			= 150,
+	PVRSRV_PIXEL_FORMAT_RESERVED11			= 151,
+	PVRSRV_PIXEL_FORMAT_RESERVED12			= 152,
+	PVRSRV_PIXEL_FORMAT_RESERVED13			= 153,
+	PVRSRV_PIXEL_FORMAT_RESERVED14			= 154,
+	PVRSRV_PIXEL_FORMAT_RESERVED15			= 155,
+	PVRSRV_PIXEL_FORMAT_RESERVED16			= 156,
+	PVRSRV_PIXEL_FORMAT_RESERVED17			= 157,
+	PVRSRV_PIXEL_FORMAT_RESERVED18			= 158,
+	PVRSRV_PIXEL_FORMAT_RESERVED19			= 159,
+	PVRSRV_PIXEL_FORMAT_RESERVED20			= 160,
+
+	
+	PVRSRV_PIXEL_FORMAT_UBYTE4				= 161,	
+	PVRSRV_PIXEL_FORMAT_SHORT4				= 162,	
+	PVRSRV_PIXEL_FORMAT_SHORT4N				= 163,	
+	PVRSRV_PIXEL_FORMAT_USHORT4N			= 164,	
+	PVRSRV_PIXEL_FORMAT_SHORT2N				= 165,	
+	PVRSRV_PIXEL_FORMAT_SHORT2				= 166,	
+	PVRSRV_PIXEL_FORMAT_USHORT2N			= 167,	
+	PVRSRV_PIXEL_FORMAT_UDEC3				= 168,	
+	PVRSRV_PIXEL_FORMAT_DEC3N				= 169,	
+	PVRSRV_PIXEL_FORMAT_F16_2				= 170,	
+	PVRSRV_PIXEL_FORMAT_F16_4				= 171,	
+
+	
+	PVRSRV_PIXEL_FORMAT_L_F16				= 172,
+	PVRSRV_PIXEL_FORMAT_L_F16_REP			= 173,
+	PVRSRV_PIXEL_FORMAT_L_F16_A_F16			= 174,
+	PVRSRV_PIXEL_FORMAT_A_F16				= 175,
+	PVRSRV_PIXEL_FORMAT_B16G16R16F			= 176,
+
+	PVRSRV_PIXEL_FORMAT_L_F32				= 177,
+	PVRSRV_PIXEL_FORMAT_A_F32				= 178,
+	PVRSRV_PIXEL_FORMAT_L_F32_A_F32			= 179,
+
+	
+	PVRSRV_PIXEL_FORMAT_PVRTC2				= 180,
+	PVRSRV_PIXEL_FORMAT_PVRTC4				= 181,
+	PVRSRV_PIXEL_FORMAT_PVRTCII2			= 182,
+	PVRSRV_PIXEL_FORMAT_PVRTCII4			= 183,
+	PVRSRV_PIXEL_FORMAT_PVRTCIII			= 184,
+	PVRSRV_PIXEL_FORMAT_PVRO8				= 185,
+	PVRSRV_PIXEL_FORMAT_PVRO88				= 186,
+	PVRSRV_PIXEL_FORMAT_PT1					= 187,
+	PVRSRV_PIXEL_FORMAT_PT2					= 188,
+	PVRSRV_PIXEL_FORMAT_PT4					= 189,
+	PVRSRV_PIXEL_FORMAT_PT8					= 190,
+	PVRSRV_PIXEL_FORMAT_PTW					= 191,
+	PVRSRV_PIXEL_FORMAT_PTB					= 192,
+	PVRSRV_PIXEL_FORMAT_MONO8				= 193,
+	PVRSRV_PIXEL_FORMAT_MONO16				= 194,
+
+	
+	PVRSRV_PIXEL_FORMAT_C0_YUYV				= 195,
+	PVRSRV_PIXEL_FORMAT_C0_UYVY				= 196,
+	PVRSRV_PIXEL_FORMAT_C0_YVYU				= 197,
+	PVRSRV_PIXEL_FORMAT_C0_VYUY				= 198,
+	PVRSRV_PIXEL_FORMAT_C1_YUYV				= 199,
+	PVRSRV_PIXEL_FORMAT_C1_UYVY				= 200,
+	PVRSRV_PIXEL_FORMAT_C1_YVYU				= 201,
+	PVRSRV_PIXEL_FORMAT_C1_VYUY				= 202,
+
+	
+	PVRSRV_PIXEL_FORMAT_C0_YUV420_2P_UV		= 203,
+	PVRSRV_PIXEL_FORMAT_C0_YUV420_2P_VU		= 204,
+	PVRSRV_PIXEL_FORMAT_C0_YUV420_3P		= 205,
+	PVRSRV_PIXEL_FORMAT_C1_YUV420_2P_UV		= 206,
+	PVRSRV_PIXEL_FORMAT_C1_YUV420_2P_VU		= 207,
+	PVRSRV_PIXEL_FORMAT_C1_YUV420_3P		= 208,
+
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10F		= 209,
+	PVRSRV_PIXEL_FORMAT_B8G8R8_SINT			= 210,
+	PVRSRV_PIXEL_FORMAT_PVRF32SIGNMASK		= 211,
+	
+	PVRSRV_PIXEL_FORMAT_ABGR4444			= 212,	
+	PVRSRV_PIXEL_FORMAT_ABGR1555			= 213,
+	PVRSRV_PIXEL_FORMAT_BGR565				= 214,			
+
+	PVRSRV_PIXEL_FORMAT_FORCE_I32			= 0x7fffffff
+
+} PVRSRV_PIXEL_FORMAT;
+
+typedef enum _PVRSRV_ALPHA_FORMAT_ {
+	PVRSRV_ALPHA_FORMAT_UNKNOWN		=  0x00000000,
+	PVRSRV_ALPHA_FORMAT_PRE			=  0x00000001,
+	PVRSRV_ALPHA_FORMAT_NONPRE		=  0x00000002,
+	PVRSRV_ALPHA_FORMAT_MASK		=  0x0000000F,
+} PVRSRV_ALPHA_FORMAT;
+
+typedef enum _PVRSRV_COLOURSPACE_FORMAT_ {
+	PVRSRV_COLOURSPACE_FORMAT_UNKNOWN		=  0x00000000,
+	PVRSRV_COLOURSPACE_FORMAT_LINEAR		=  0x00010000,
+	PVRSRV_COLOURSPACE_FORMAT_NONLINEAR		=  0x00020000,
+	PVRSRV_COLOURSPACE_FORMAT_MASK			=  0x000F0000,
+} PVRSRV_COLOURSPACE_FORMAT;
+
+
+typedef enum _PVRSRV_ROTATION_ {
+	PVRSRV_ROTATE_0		=	0,
+	PVRSRV_ROTATE_90	=	1,
+	PVRSRV_ROTATE_180	=	2,
+	PVRSRV_ROTATE_270	=	3,
+	PVRSRV_FLIP_Y
+
+} PVRSRV_ROTATION;
+
+#define PVRSRV_CREATE_SWAPCHAIN_SHARED		(1<<0)
+#define PVRSRV_CREATE_SWAPCHAIN_QUERY		(1<<1)
+#define PVRSRV_CREATE_SWAPCHAIN_OEMOVERLAY	(1<<2)
+
+typedef struct _PVRSRV_SYNC_DATA_
+{
+	
+	IMG_UINT32					ui32WriteOpsPending;
+	volatile IMG_UINT32			ui32WriteOpsComplete;
+
+	
+	IMG_UINT32					ui32ReadOpsPending;
+	volatile IMG_UINT32			ui32ReadOpsComplete;
+
+	
+	IMG_UINT32					ui32LastOpDumpVal;
+	IMG_UINT32					ui32LastReadOpDumpVal;
+
+} PVRSRV_SYNC_DATA;
+
+typedef struct _PVRSRV_CLIENT_SYNC_INFO_
+{
+	
+	PVRSRV_SYNC_DATA			*psSyncData;
+
+	
+
+
+	
+	IMG_DEV_VIRTADDR		sWriteOpsCompleteDevVAddr;
+
+	
+	IMG_DEV_VIRTADDR		sReadOpsCompleteDevVAddr;
+
+	
+	IMG_HANDLE					hMappingInfo;
+
+	
+	IMG_HANDLE					hKernelSyncInfo;
+
+} PVRSRV_CLIENT_SYNC_INFO, *PPVRSRV_CLIENT_SYNC_INFO;
+
+typedef struct PVRSRV_RESOURCE_TAG
+{
+	volatile IMG_UINT32 ui32Lock;
+	IMG_UINT32 			ui32ID;
+}PVRSRV_RESOURCE;
+typedef PVRSRV_RESOURCE PVRSRV_RES_HANDLE;
+
+
+typedef IMG_VOID (*PFN_CMD_COMPLETE) (IMG_HANDLE);
+typedef IMG_VOID (**PPFN_CMD_COMPLETE) (IMG_HANDLE);
+
+typedef IMG_BOOL (*PFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID*);
+typedef IMG_BOOL (**PPFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID*);
+
+
+typedef struct _IMG_RECT_
+{
+	IMG_INT32	x0;
+	IMG_INT32	y0;
+	IMG_INT32	x1;
+	IMG_INT32	y1;
+}IMG_RECT;
+
+typedef struct _IMG_RECT_16_
+{
+	IMG_INT16	x0;
+	IMG_INT16	y0;
+	IMG_INT16	x1;
+	IMG_INT16	y1;
+}IMG_RECT_16;
+
+
+typedef PVRSRV_ERROR (*PFN_GET_BUFFER_ADDR)(IMG_HANDLE,
+											IMG_HANDLE,
+											IMG_SYS_PHYADDR**,
+											IMG_SIZE_T*,
+											IMG_VOID**,
+											IMG_HANDLE*,
+											IMG_BOOL*,
+											IMG_UINT32*);
+
+
+typedef struct DISPLAY_DIMS_TAG
+{
+	IMG_UINT32	ui32ByteStride;
+	IMG_UINT32	ui32Width;
+	IMG_UINT32	ui32Height;
+} DISPLAY_DIMS;
+
+
+typedef struct DISPLAY_FORMAT_TAG
+{
+	
+	PVRSRV_PIXEL_FORMAT		pixelformat;
+} DISPLAY_FORMAT;
+
+typedef struct DISPLAY_SURF_ATTRIBUTES_TAG
+{
+	
+	PVRSRV_PIXEL_FORMAT		pixelformat;
+	
+	DISPLAY_DIMS			sDims;
+} DISPLAY_SURF_ATTRIBUTES;
+
+
+typedef struct DISPLAY_MODE_INFO_TAG
+{
+	
+	PVRSRV_PIXEL_FORMAT		pixelformat;
+	
+	DISPLAY_DIMS			sDims;
+	
+	IMG_UINT32				ui32RefreshHZ;
+	
+	IMG_UINT32				ui32OEMFlags;
+} DISPLAY_MODE_INFO;
+
+
+
+#define MAX_DISPLAY_NAME_SIZE	(50) 
+
+typedef struct DISPLAY_INFO_TAG
+{
+	
+	IMG_UINT32 ui32MaxSwapChains;
+	
+	IMG_UINT32 ui32MaxSwapChainBuffers;
+	
+	IMG_UINT32 ui32MinSwapInterval;
+	
+	IMG_UINT32 ui32MaxSwapInterval;
+	
+	IMG_UINT32 ui32PhysicalWidthmm;
+	IMG_UINT32 ui32PhysicalHeightmm;
+	
+	IMG_CHAR	szDisplayName[MAX_DISPLAY_NAME_SIZE];
+#if defined(SUPPORT_HW_CURSOR)
+	
+	IMG_UINT16	ui32CursorWidth;
+	IMG_UINT16	ui32CursorHeight;
+#endif
+} DISPLAY_INFO;
+
+typedef struct ACCESS_INFO_TAG
+{
+	IMG_UINT32		ui32Size;
+	IMG_UINT32  	ui32FBPhysBaseAddress;
+	IMG_UINT32		ui32FBMemAvailable;			
+	IMG_UINT32  	ui32SysPhysBaseAddress;
+	IMG_UINT32		ui32SysSize;
+	IMG_UINT32		ui32DevIRQ;
+}ACCESS_INFO;
+
+
+typedef struct PVRSRV_CURSOR_SHAPE_TAG
+{
+	IMG_UINT16			ui16Width;
+	IMG_UINT16			ui16Height;
+	IMG_INT16			i16XHot;
+	IMG_INT16			i16YHot;
+
+	
+	IMG_VOID*   		pvMask;
+	IMG_INT16  			i16MaskByteStride;
+
+	
+	IMG_VOID*			pvColour;
+	IMG_INT16			i16ColourByteStride;
+	PVRSRV_PIXEL_FORMAT	eColourPixelFormat;
+} PVRSRV_CURSOR_SHAPE;
+
+#define PVRSRV_SET_CURSOR_VISIBILITY	(1<<0)
+#define PVRSRV_SET_CURSOR_POSITION		(1<<1)
+#define PVRSRV_SET_CURSOR_SHAPE			(1<<2)
+#define PVRSRV_SET_CURSOR_ROTATION		(1<<3)
+
+typedef struct PVRSRV_CURSOR_INFO_TAG
+{
+	
+	IMG_UINT32 ui32Flags;
+
+	
+	IMG_BOOL bVisible;
+
+	
+	IMG_INT16 i16XPos;
+	IMG_INT16 i16YPos;
+
+	
+	PVRSRV_CURSOR_SHAPE sCursorShape;
+
+	
+	IMG_UINT32 ui32Rotation;
+
+} PVRSRV_CURSOR_INFO;
+
+
+typedef struct _PVRSRV_REGISTRY_INFO_
+{
+    IMG_UINT32		ui32DevCookie;
+    IMG_PCHAR		pszKey;
+    IMG_PCHAR		pszValue;
+    IMG_PCHAR		pszBuf;
+    IMG_UINT32		ui32BufSize;
+} PVRSRV_REGISTRY_INFO, *PPVRSRV_REGISTRY_INFO;
+
+
+PVRSRV_ERROR IMG_CALLCONV PVRSRVReadRegistryString (PPVRSRV_REGISTRY_INFO psRegInfo);
+PVRSRV_ERROR IMG_CALLCONV PVRSRVWriteRegistryString (PPVRSRV_REGISTRY_INFO psRegInfo);
+
+
+#define PVRSRV_BC_FLAGS_YUVCSC_CONFORMANT_RANGE	(0 << 0)
+#define PVRSRV_BC_FLAGS_YUVCSC_FULL_RANGE		(1 << 0)
+
+#define PVRSRV_BC_FLAGS_YUVCSC_BT601			(0 << 1)
+#define PVRSRV_BC_FLAGS_YUVCSC_BT709			(1 << 1)
+
+#define MAX_BUFFER_DEVICE_NAME_SIZE	(50) 
+
+typedef struct BUFFER_INFO_TAG
+{
+	IMG_UINT32 			ui32BufferCount;
+	IMG_UINT32			ui32BufferDeviceID;
+	PVRSRV_PIXEL_FORMAT	pixelformat;
+	IMG_UINT32			ui32ByteStride;
+	IMG_UINT32			ui32Width;
+	IMG_UINT32			ui32Height;
+	IMG_UINT32			ui32Flags;
+	IMG_CHAR			szDeviceName[MAX_BUFFER_DEVICE_NAME_SIZE];
+} BUFFER_INFO;
+
+typedef enum _OVERLAY_DEINTERLACE_MODE_
+{
+	WEAVE=0x0,
+	BOB_ODD,
+	BOB_EVEN,
+	BOB_EVEN_NONINTERLEAVED
+} OVERLAY_DEINTERLACE_MODE;
+
+#endif 
-- 
1.7.5.4

