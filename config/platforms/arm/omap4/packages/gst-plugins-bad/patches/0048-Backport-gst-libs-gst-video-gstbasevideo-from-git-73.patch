From 7b2dcb1d1afc0aba82683ed40399d2365efc1067 Mon Sep 17 00:00:00 2001
From: Alessandro Decina <alessandro.decina@collabora.co.uk>
Date: Tue, 18 Oct 2011 11:05:19 +0200
Subject: [PATCH 048/119] Backport gst-libs/gst/video/gstbasevideo* from git
 73d847

---
 gst-libs/gst/video/gstbasevideocodec.c   |  398 +-------
 gst-libs/gst/video/gstbasevideocodec.h   |   46 +-
 gst-libs/gst/video/gstbasevideodecoder.c | 1633 ++++++++++++++++++++----------
 gst-libs/gst/video/gstbasevideodecoder.h |  268 ++++--
 gst-libs/gst/video/gstbasevideoencoder.c |  778 +++++++++++---
 gst-libs/gst/video/gstbasevideoencoder.h |  129 ++-
 gst-libs/gst/video/gstbasevideoutils.c   |   96 ++-
 gst-libs/gst/video/gstbasevideoutils.h   |   46 +
 8 files changed, 2137 insertions(+), 1257 deletions(-)
 create mode 100644 gst-libs/gst/video/gstbasevideoutils.h

diff --git a/gst-libs/gst/video/gstbasevideocodec.c b/gst-libs/gst/video/gstbasevideocodec.c
index 1b7d784..68e203d 100644
--- a/gst-libs/gst/video/gstbasevideocodec.c
+++ b/gst-libs/gst/video/gstbasevideocodec.c
@@ -1,4 +1,4 @@
-/* Schrodinger
+/* GStreamer
  * Copyright (C) 2006 David Schleef <ds@schleef.org>
  *
  * This library is free software; you can redistribute it and/or
@@ -42,15 +42,8 @@ enum
 
 static void gst_base_video_codec_finalize (GObject * object);
 
-//static const GstQueryType *gst_base_video_codec_get_query_types (GstPad *pad);
-//static gboolean gst_base_video_codec_src_query (GstPad *pad, GstQuery *query);
-//static gboolean gst_base_video_codec_sink_query (GstPad *pad, GstQuery *query);
-//static gboolean gst_base_video_codec_src_event (GstPad *pad, GstEvent *event);
-//static gboolean gst_base_video_codec_sink_event (GstPad *pad, GstEvent *event);
 static GstStateChangeReturn gst_base_video_codec_change_state (GstElement *
     element, GstStateChange transition);
-//static GstFlowReturn gst_base_video_codec_push_all (GstBaseVideoCodec *base_video_codec, 
-//    gboolean at_eos);
 
 
 GST_BOILERPLATE (GstBaseVideoCodec, gst_base_video_codec, GstElement,
@@ -84,15 +77,13 @@ gst_base_video_codec_init (GstBaseVideoCodec * base_video_codec,
 {
   GstPadTemplate *pad_template;
 
-  GST_DEBUG ("gst_base_video_codec_init");
+  GST_DEBUG_OBJECT (base_video_codec, "gst_base_video_codec_init");
 
   pad_template =
       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "sink");
   g_return_if_fail (pad_template != NULL);
 
   base_video_codec->sinkpad = gst_pad_new_from_template (pad_template, "sink");
-  //gst_pad_set_query_function (base_video_codec->sinkpad,
-  //    gst_base_video_codec_sink_query);
   gst_element_add_pad (GST_ELEMENT (base_video_codec),
       base_video_codec->sinkpad);
 
@@ -106,6 +97,7 @@ gst_base_video_codec_init (GstBaseVideoCodec * base_video_codec,
 
   gst_segment_init (&base_video_codec->segment, GST_FORMAT_TIME);
 
+  g_static_rec_mutex_init (&base_video_codec->stream_lock);
 }
 
 static void
@@ -113,376 +105,32 @@ gst_base_video_codec_reset (GstBaseVideoCodec * base_video_codec)
 {
   GList *g;
 
-  GST_DEBUG ("reset");
+  GST_DEBUG_OBJECT (base_video_codec, "reset");
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_codec);
   for (g = base_video_codec->frames; g; g = g_list_next (g)) {
     gst_base_video_codec_free_frame ((GstVideoFrame *) g->data);
   }
   g_list_free (base_video_codec->frames);
+  base_video_codec->frames = NULL;
 
-  if (base_video_codec->caps) {
-    gst_caps_unref (base_video_codec->caps);
-    base_video_codec->caps = NULL;
-  }
+  base_video_codec->bytes = 0;
+  base_video_codec->time = 0;
 
+  gst_buffer_replace (&base_video_codec->state.codec_data, NULL);
+  gst_caps_replace (&base_video_codec->state.caps, NULL);
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_codec);
 }
 
 static void
 gst_base_video_codec_finalize (GObject * object)
 {
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-#ifdef unused
-static const GstQueryType *
-gst_base_video_codec_get_query_types (GstPad * pad)
-{
-  static const GstQueryType query_types[] = {
-    GST_QUERY_POSITION,
-    GST_QUERY_DURATION,
-    GST_QUERY_CONVERT,
-    0
-  };
-
-  return query_types;
-}
-#endif
-
-#if 0
-static gboolean
-gst_base_video_codec_src_convert (GstPad * pad,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 * dest_value)
-{
-  gboolean res;
-  GstBaseVideoCodec *dec;
-
-  if (src_format == *dest_format) {
-    *dest_value = src_value;
-    return TRUE;
-  }
-
-  dec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
-
-  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
-    if (dec->fps_d != 0) {
-      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
-          dec->fps_d * GST_SECOND, dec->fps_n);
-      res = TRUE;
-    } else {
-      res = FALSE;
-    }
-  } else {
-    GST_WARNING ("unhandled conversion from %d to %d", src_format,
-        *dest_format);
-    res = FALSE;
-  }
-
-  gst_object_unref (dec);
-
-  return res;
-}
-
-static gboolean
-gst_base_video_codec_sink_convert (GstPad * pad,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 * dest_value)
-{
-  gboolean res = TRUE;
-  GstBaseVideoCodec *dec;
-
-  if (src_format == *dest_format) {
-    *dest_value = src_value;
-    return TRUE;
-  }
-
-  dec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
-
-  /* FIXME: check if we are in a decoding state */
-
-  switch (src_format) {
-    case GST_FORMAT_DEFAULT:
-      switch (*dest_format) {
-        case GST_FORMAT_TIME:
-          *dest_value = gst_util_uint64_scale (src_value,
-              dec->fps_d * GST_SECOND, dec->fps_n);
-          break;
-        default:
-          res = FALSE;
-      }
-      break;
-    case GST_FORMAT_TIME:
-      switch (*dest_format) {
-        case GST_FORMAT_DEFAULT:
-        {
-          *dest_value = gst_util_uint64_scale (src_value,
-              dec->fps_n, dec->fps_d * GST_SECOND);
-          break;
-        }
-        default:
-          res = FALSE;
-          break;
-      }
-      break;
-    default:
-      res = FALSE;
-      break;
-  }
-
-  gst_object_unref (dec);
-
-  return res;
-}
-#endif
-
-#ifdef unused
-static gboolean
-gst_base_video_codec_src_query (GstPad * pad, GstQuery * query)
-{
-  GstBaseVideoCodec *base_codec;
-  gboolean res = FALSE;
-
-  base_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
-
-  switch (GST_QUERY_TYPE (query)) {
-    case GST_QUERY_POSITION:
-    {
-      GstFormat format;
-      gint64 time;
-      gint64 value;
-
-      gst_query_parse_position (query, &format, NULL);
-
-      time = gst_util_uint64_scale (base_codec->system_frame_number,
-          base_codec->state.fps_n, base_codec->state.fps_d);
-      time += base_codec->state.segment.time;
-      GST_DEBUG ("query position %" GST_TIME_FORMAT, GST_TIME_ARGS (time));
-      res = gst_base_video_encoded_video_convert (&base_codec->state,
-          GST_FORMAT_TIME, time, &format, &value);
-      if (!res)
-        goto error;
-
-      gst_query_set_position (query, format, value);
-      break;
-    }
-    case GST_QUERY_DURATION:
-      res = gst_pad_query (GST_PAD_PEER (base_codec->sinkpad), query);
-      if (!res)
-        goto error;
-      break;
-    case GST_QUERY_CONVERT:
-    {
-      GstFormat src_fmt, dest_fmt;
-      gint64 src_val, dest_val;
-
-      GST_DEBUG ("query convert");
-
-      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
-      res = gst_base_video_encoded_video_convert (&base_codec->state,
-          src_fmt, src_val, &dest_fmt, &dest_val);
-      if (!res)
-        goto error;
-      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
-      break;
-    }
-    default:
-      res = gst_pad_query_default (pad, query);
-      break;
-  }
-done:
-  gst_object_unref (base_codec);
-
-  return res;
-error:
-  GST_DEBUG_OBJECT (base_codec, "query failed");
-  goto done;
-}
-#endif
-
-#ifdef unused
-static gboolean
-gst_base_video_codec_sink_query (GstPad * pad, GstQuery * query)
-{
-  GstBaseVideoCodec *base_video_codec;
-  gboolean res = FALSE;
-
-  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
-
-  switch (GST_QUERY_TYPE (query)) {
-    case GST_QUERY_CONVERT:
-    {
-      GstFormat src_fmt, dest_fmt;
-      gint64 src_val, dest_val;
-
-      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
-      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
-          src_fmt, src_val, &dest_fmt, &dest_val);
-      if (!res)
-        goto error;
-      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
-      break;
-    }
-    default:
-      res = gst_pad_query_default (pad, query);
-      break;
-  }
-done:
-  gst_object_unref (base_video_codec);
-
-  return res;
-error:
-  GST_DEBUG_OBJECT (base_video_codec, "query failed");
-  goto done;
-}
-#endif
+  GstBaseVideoCodec *base_video_codec = GST_BASE_VIDEO_CODEC (object);
 
-#ifdef unused
-static gboolean
-gst_base_video_codec_src_event (GstPad * pad, GstEvent * event)
-{
-  GstBaseVideoCodec *base_video_codec;
-  gboolean res = FALSE;
-
-  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_SEEK:
-    {
-      GstFormat format, tformat;
-      gdouble rate;
-      GstEvent *real_seek;
-      GstSeekFlags flags;
-      GstSeekType cur_type, stop_type;
-      gint64 cur, stop;
-      gint64 tcur, tstop;
-
-      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
-          &cur, &stop_type, &stop);
-      gst_event_unref (event);
-
-      tformat = GST_FORMAT_TIME;
-      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
-          format, cur, &tformat, &tcur);
-      if (!res)
-        goto convert_error;
-      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
-          format, stop, &tformat, &tstop);
-      if (!res)
-        goto convert_error;
-
-      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
-          flags, cur_type, tcur, stop_type, tstop);
-
-      res = gst_pad_push_event (base_video_codec->sinkpad, real_seek);
+  g_static_rec_mutex_free (&base_video_codec->stream_lock);
 
-      break;
-    }
-#if 0
-    case GST_EVENT_QOS:
-    {
-      gdouble proportion;
-      GstClockTimeDiff diff;
-      GstClockTime timestamp;
-
-      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
-
-      GST_OBJECT_LOCK (base_video_codec);
-      base_video_codec->proportion = proportion;
-      base_video_codec->earliest_time = timestamp + diff;
-      GST_OBJECT_UNLOCK (base_video_codec);
-
-      GST_DEBUG_OBJECT (base_video_codec,
-          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT,
-          GST_TIME_ARGS (timestamp), diff);
-
-      res = gst_pad_push_event (base_video_codec->sinkpad, event);
-      break;
-    }
-#endif
-    default:
-      res = gst_pad_push_event (base_video_codec->sinkpad, event);
-      break;
-  }
-done:
-  gst_object_unref (base_video_codec);
-  return res;
-
-convert_error:
-  GST_DEBUG_OBJECT (base_video_codec, "could not convert format");
-  goto done;
-}
-#endif
-
-#ifdef unused
-static gboolean
-gst_base_video_codec_sink_event (GstPad * pad, GstEvent * event)
-{
-  GstBaseVideoCodec *base_video_codec;
-  gboolean ret = FALSE;
-
-  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_FLUSH_START:
-      ret = gst_pad_push_event (base_video_codec->srcpad, event);
-      break;
-    case GST_EVENT_FLUSH_STOP:
-      gst_base_video_codec_reset (base_video_codec);
-      ret = gst_pad_push_event (base_video_codec->srcpad, event);
-      break;
-    case GST_EVENT_EOS:
-      if (gst_base_video_codec_push_all (base_video_codec,
-              FALSE) == GST_FLOW_ERROR) {
-        gst_event_unref (event);
-        return FALSE;
-      }
-
-      ret = gst_pad_push_event (base_video_codec->srcpad, event);
-      break;
-    case GST_EVENT_NEWSEGMENT:
-    {
-      gboolean update;
-      GstFormat format;
-      gdouble rate;
-      gint64 start, stop, time;
-
-      gst_event_parse_new_segment (event, &update, &rate, &format, &start,
-          &stop, &time);
-
-      if (format != GST_FORMAT_TIME)
-        goto newseg_wrong_format;
-
-      if (rate <= 0.0)
-        goto newseg_wrong_rate;
-
-      GST_DEBUG ("newsegment %" GST_TIME_FORMAT " %" GST_TIME_FORMAT,
-          GST_TIME_ARGS (start), GST_TIME_ARGS (time));
-      gst_segment_set_newsegment (&base_video_codec->state.segment, update,
-          rate, format, start, stop, time);
-
-      ret = gst_pad_push_event (base_video_codec->srcpad, event);
-      break;
-    }
-    default:
-      ret = gst_pad_push_event (base_video_codec->srcpad, event);
-      break;
-  }
-done:
-  gst_object_unref (base_video_codec);
-  return ret;
-
-newseg_wrong_format:
-  GST_DEBUG_OBJECT (base_video_codec, "received non TIME newsegment");
-  gst_event_unref (event);
-  goto done;
-
-newseg_wrong_rate:
-  GST_DEBUG_OBJECT (base_video_codec, "negative rates not supported");
-  gst_event_unref (event);
-  goto done;
+  G_OBJECT_CLASS (parent_class)->finalize (object);
 }
-#endif
-
 
 static GstStateChangeReturn
 gst_base_video_codec_change_state (GstElement * element,
@@ -525,10 +173,12 @@ gst_base_video_codec_new_frame (GstBaseVideoCodec * base_video_codec)
 {
   GstVideoFrame *frame;
 
-  frame = g_malloc0 (sizeof (GstVideoFrame));
+  frame = g_slice_new0 (GstVideoFrame);
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_codec);
   frame->system_frame_number = base_video_codec->system_frame_number;
   base_video_codec->system_frame_number++;
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_codec);
 
   return frame;
 }
@@ -536,9 +186,21 @@ gst_base_video_codec_new_frame (GstBaseVideoCodec * base_video_codec)
 void
 gst_base_video_codec_free_frame (GstVideoFrame * frame)
 {
+  g_return_if_fail (frame != NULL);
+
   if (frame->sink_buffer) {
     gst_buffer_unref (frame->sink_buffer);
   }
 
-  g_free (frame);
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+
+  g_list_foreach (frame->events, (GFunc) gst_event_unref, NULL);
+  g_list_free (frame->events);
+
+  if (frame->coder_hook_destroy_notify && frame->coder_hook)
+    frame->coder_hook_destroy_notify (frame->coder_hook);
+
+  g_slice_free (GstVideoFrame, frame);
 }
diff --git a/gst-libs/gst/video/gstbasevideocodec.h b/gst-libs/gst/video/gstbasevideocodec.h
index 8ef4893..6471c35 100644
--- a/gst-libs/gst/video/gstbasevideocodec.h
+++ b/gst-libs/gst/video/gstbasevideocodec.h
@@ -79,6 +79,9 @@ G_BEGIN_DECLS
  */
 #define GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
 
+#define GST_BASE_VIDEO_CODEC_STREAM_LOCK(codec) g_static_rec_mutex_lock (&GST_BASE_VIDEO_CODEC (codec)->stream_lock)
+#define GST_BASE_VIDEO_CODEC_STREAM_UNLOCK(codec) g_static_rec_mutex_unlock (&GST_BASE_VIDEO_CODEC (codec)->stream_lock)
+
 typedef struct _GstVideoState GstVideoState;
 typedef struct _GstVideoFrame GstVideoFrame;
 typedef struct _GstBaseVideoCodec GstBaseVideoCodec;
@@ -86,6 +89,7 @@ typedef struct _GstBaseVideoCodecClass GstBaseVideoCodecClass;
 
 struct _GstVideoState
 {
+  GstCaps *caps;
   GstVideoFormat format;
   int width, height;
   int fps_n, fps_d;
@@ -100,9 +104,6 @@ struct _GstVideoState
 
   int bytes_per_picture;
 
-  //GstSegment segment;
-
-  int picture_number;
   GstBuffer *codec_data;
 
 };
@@ -128,9 +129,15 @@ struct _GstVideoFrame
   int n_fields;
 
   void *coder_hook;
+  GDestroyNotify coder_hook_destroy_notify;
+
   GstClockTime deadline;
 
   gboolean force_keyframe;
+
+  /* Events that should be pushed downstream *before*
+   * the next src_buffer */
+  GList *events;
 };
 
 struct _GstBaseVideoCodec
@@ -141,16 +148,23 @@ struct _GstBaseVideoCodec
   GstPad *sinkpad;
   GstPad *srcpad;
 
+  /* protects all data processing, i.e. is locked
+   * in the chain function, finish_frame and when
+   * processing serialized events */
+  GStaticRecMutex stream_lock;
+
   guint64 system_frame_number;
 
-  GList *frames;
+  GList *frames;  /* Protected with OBJECT_LOCK */
   GstVideoState state;
   GstSegment segment;
 
-  GstCaps *caps;
-
   gdouble proportion;
   GstClockTime earliest_time;
+  gboolean discont;
+
+  gint64 bytes;
+  gint64 time;
 
   /* FIXME before moving to base */
   void *padding[GST_PADDING_LARGE];
@@ -160,15 +174,6 @@ struct _GstBaseVideoCodecClass
 {
   GstElementClass element_class;
 
-  gboolean (*start) (GstBaseVideoCodec *codec);
-  gboolean (*stop) (GstBaseVideoCodec *codec);
-  gboolean (*reset) (GstBaseVideoCodec *codec);
-  GstFlowReturn (*parse_data) (GstBaseVideoCodec *codec, gboolean at_eos);
-  int (*scan_for_sync) (GstAdapter *adapter, gboolean at_eos,
-      int offset, int n);
-  GstFlowReturn (*shape_output) (GstBaseVideoCodec *codec, GstVideoFrame *frame);
-  GstCaps *(*get_caps) (GstBaseVideoCodec *codec);
-
   /* FIXME before moving to base */
   void *padding[GST_PADDING_LARGE];
 };
@@ -178,17 +183,6 @@ GType gst_base_video_codec_get_type (void);
 GstVideoFrame * gst_base_video_codec_new_frame (GstBaseVideoCodec *base_video_codec);
 void gst_base_video_codec_free_frame (GstVideoFrame *frame);
 
-
-gboolean gst_base_video_rawvideo_convert (GstVideoState *state,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 *dest_value);
-gboolean gst_base_video_encoded_video_convert (GstVideoState *state,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 *dest_value);
-
-GstClockTime gst_video_state_get_timestamp (const GstVideoState *state,
-    GstSegment *segment, int frame_number);
-
 G_END_DECLS
 
 #endif
diff --git a/gst-libs/gst/video/gstbasevideodecoder.c b/gst-libs/gst/video/gstbasevideodecoder.c
index cf3910f..1b01ed7 100644
--- a/gst-libs/gst/video/gstbasevideodecoder.c
+++ b/gst-libs/gst/video/gstbasevideodecoder.c
@@ -1,5 +1,8 @@
 /* GStreamer
  * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ * Copyright (C) 2011 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>.
+ * Copyright (C) 2011 Nokia Corporation. All rights reserved.
+ *   Contact: Stefan Kost <stefan.kost@nokia.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -17,11 +20,115 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/**
+ * SECTION:gstbasevideodecoder
+ * @short_description: Base class for video decoders
+ * @see_also: #GstBaseTransform
+ *
+ * This base class is for video decoders turning encoded data into raw video
+ * frames.
+ *
+ * GstBaseVideoDecoder and subclass should cooperate as follows.
+ * <orderedlist>
+ * <listitem>
+ *   <itemizedlist><title>Configuration</title>
+ *   <listitem><para>
+ *     Initially, GstBaseVideoDecoder calls @start when the decoder element
+ *     is activated, which allows subclass to perform any global setup.
+ *   </para></listitem>
+ *   <listitem><para>
+ *     GstBaseVideoDecoder calls @set_format to inform subclass of caps
+ *     describing input video data that it is about to receive, including
+ *     possibly configuration data.
+ *     While unlikely, it might be called more than once, if changing input
+ *     parameters require reconfiguration.
+ *   </para></listitem>
+ *   <listitem><para>
+ *     GstBaseVideoDecoder calls @stop at end of all processing.
+ *   </para></listitem>
+ *   </itemizedlist>
+ * </listitem>
+ * <listitem>
+ *   <itemizedlist>
+ *   <title>Data processing</title>
+ *     <listitem><para>
+ *       Base class gathers input data, and optionally allows subclass
+ *       to parse this into subsequently manageable chunks, typically
+ *       corresponding to and referred to as 'frames'.
+ *     </para></listitem>
+ *     <listitem><para>
+ *       Input frame is provided to subclass' @handle_frame.
+ *     </para></listitem>
+ *     <listitem><para>
+ *       If codec processing results in decoded data, subclass should call
+ *       @gst_base_video_decoder_finish_frame to have decoded data pushed
+ *       downstream.
+ *     </para></listitem>
+ *   </itemizedlist>
+ * </listitem>
+ * <listitem>
+ *   <itemizedlist><title>Shutdown phase</title>
+ *   <listitem><para>
+ *     GstBaseVideoDecoder class calls @stop to inform the subclass that data
+ *     parsing will be stopped.
+ *   </para></listitem>
+ *   </itemizedlist>
+ * </listitem>
+ * </orderedlist>
+ *
+ * Subclass is responsible for providing pad template caps for
+ * source and sink pads. The pads need to be named "sink" and "src". It also
+ * needs to set the fixed caps on srcpad, when the format is ensured.  This
+ * is typically when base class calls subclass' @set_format function, though
+ * it might be delayed until calling @gst_base_video_decoder_finish_frame.
+ *
+ * Subclass is also responsible for providing (presentation) timestamps
+ * (likely based on corresponding input ones).  If that is not applicable
+ * or possible, baseclass provides limited framerate based interpolation.
+ *
+ * Similarly, the baseclass provides some limited (legacy) seeking support
+ * (upon explicit subclass request), as full-fledged support
+ * should rather be left to upstream demuxer, parser or alike.  This simple
+ * approach caters for seeking and duration reporting using estimated input
+ * bitrates.
+ *
+ * Baseclass provides some support for reverse playback, in particular
+ * in case incoming data is not packetized or upstream does not provide
+ * fragments on keyframe boundaries.  However, subclass should then be prepared
+ * for the parsing and frame processing stage to occur separately (rather
+ * than otherwise the latter immediately following the former),
+ * and should ensure the parsing stage properly marks keyframes or rely on
+ * upstream to do so properly for incoming data.
+ *
+ * Things that subclass need to take care of:
+ * <itemizedlist>
+ *   <listitem><para>Provide pad templates</para></listitem>
+ *   <listitem><para>
+ *      Set source pad caps when appropriate
+ *   </para></listitem>
+ *   <listitem><para>
+ *      Configure some baseclass behaviour parameters.
+ *   </para></listitem>
+ *   <listitem><para>
+ *      Optionally parse input data, if it is not considered packetized.
+ *      Parse sync is obtained either by providing baseclass with a
+ *      mask and pattern or a custom @scan_for_sync.  When sync is established,
+ *      @parse_data should invoke @gst_base_video_decoder_add_to_frame and
+ *      @gst_base_video_decoder_have_frame as appropriate.
+ *   </para></listitem>
+ *   <listitem><para>
+ *      Accept data in @handle_frame and provide decoded results to
+ *      @gst_base_video_decoder_finish_frame.
+ *   </para></listitem>
+ * </itemizedlist>
+ */
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "gstbasevideodecoder.h"
+#include "gstbasevideoutils.h"
 
 #include <string.h>
 
@@ -40,18 +147,14 @@ static GstFlowReturn gst_base_video_decoder_chain (GstPad * pad,
     GstBuffer * buf);
 static gboolean gst_base_video_decoder_sink_query (GstPad * pad,
     GstQuery * query);
-//static GstFlowReturn gst_base_video_decoder_process (GstBaseVideoDecoder *base_video_decoder);
 static GstStateChangeReturn gst_base_video_decoder_change_state (GstElement *
     element, GstStateChange transition);
 static const GstQueryType *gst_base_video_decoder_get_query_types (GstPad *
     pad);
 static gboolean gst_base_video_decoder_src_query (GstPad * pad,
     GstQuery * query);
-static gboolean gst_base_video_decoder_src_convert (GstPad * pad,
-    GstFormat src_format, gint64 src_value, GstFormat * dest_format,
-    gint64 * dest_value);
 static void gst_base_video_decoder_reset (GstBaseVideoDecoder *
-    base_video_decoder);
+    base_video_decoder, gboolean full);
 
 static GstFlowReturn
 gst_base_video_decoder_have_frame_2 (GstBaseVideoDecoder * base_video_decoder);
@@ -66,7 +169,8 @@ static guint64 gst_base_video_decoder_get_field_duration (GstBaseVideoDecoder *
     base_video_decoder, int n_fields);
 static GstVideoFrame *gst_base_video_decoder_new_frame (GstBaseVideoDecoder *
     base_video_decoder);
-static void gst_base_video_decoder_free_frame (GstVideoFrame * frame);
+
+static void gst_base_video_decoder_clear_queues (GstBaseVideoDecoder * dec);
 
 GST_BOILERPLATE (GstBaseVideoDecoder, gst_base_video_decoder,
     GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC);
@@ -90,9 +194,8 @@ gst_base_video_decoder_class_init (GstBaseVideoDecoderClass * klass)
 
   gobject_class->finalize = gst_base_video_decoder_finalize;
 
-  gstelement_class->change_state = gst_base_video_decoder_change_state;
-
-  parent_class = g_type_class_peek_parent (klass);
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_change_state);
 }
 
 static void
@@ -101,74 +204,127 @@ gst_base_video_decoder_init (GstBaseVideoDecoder * base_video_decoder,
 {
   GstPad *pad;
 
-  GST_DEBUG ("gst_base_video_decoder_init");
+  GST_DEBUG_OBJECT (base_video_decoder, "gst_base_video_decoder_init");
 
   pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_decoder);
 
-  gst_pad_set_chain_function (pad, gst_base_video_decoder_chain);
-  gst_pad_set_event_function (pad, gst_base_video_decoder_sink_event);
-  gst_pad_set_setcaps_function (pad, gst_base_video_decoder_sink_setcaps);
-  gst_pad_set_query_function (pad, gst_base_video_decoder_sink_query);
+  gst_pad_set_chain_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_chain));
+  gst_pad_set_event_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_sink_event));
+  gst_pad_set_setcaps_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_sink_setcaps));
+  gst_pad_set_query_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_sink_query));
 
   pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder);
 
-  gst_pad_set_event_function (pad, gst_base_video_decoder_src_event);
-  gst_pad_set_query_type_function (pad, gst_base_video_decoder_get_query_types);
-  gst_pad_set_query_function (pad, gst_base_video_decoder_src_query);
+  gst_pad_set_event_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_src_event));
+  gst_pad_set_query_type_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_get_query_types));
+  gst_pad_set_query_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_decoder_src_query));
   gst_pad_use_fixed_caps (pad);
 
   base_video_decoder->input_adapter = gst_adapter_new ();
   base_video_decoder->output_adapter = gst_adapter_new ();
 
-  gst_base_video_decoder_reset (base_video_decoder);
-
-  base_video_decoder->current_frame =
-      gst_base_video_decoder_new_frame (base_video_decoder);
+  gst_base_video_decoder_reset (base_video_decoder, TRUE);
 
   base_video_decoder->sink_clipping = TRUE;
 }
 
 static gboolean
+gst_base_video_decoder_push_src_event (GstBaseVideoDecoder * decoder,
+    GstEvent * event)
+{
+  /* Forward non-serialized events and EOS/FLUSH_STOP immediately.
+   * For EOS this is required because no buffer or serialized event
+   * will come after EOS and nothing could trigger another
+   * _finish_frame() call.   *
+   * If the subclass handles sending of EOS manually it can return
+   * _DROPPED from ::finish() and all other subclasses should have
+   * decoded/flushed all remaining data before this
+   *
+   * For FLUSH_STOP this is required because it is expected
+   * to be forwarded immediately and no buffers are queued anyway.
+   */
+  if (!GST_EVENT_IS_SERIALIZED (event)
+      || GST_EVENT_TYPE (event) == GST_EVENT_EOS
+      || GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_STOP)
+    return gst_pad_push_event (decoder->base_video_codec.srcpad, event);
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (decoder);
+  decoder->current_frame_events =
+      g_list_prepend (decoder->current_frame_events, event);
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (decoder);
+
+  return TRUE;
+}
+
+static gboolean
 gst_base_video_decoder_sink_setcaps (GstPad * pad, GstCaps * caps)
 {
   GstBaseVideoDecoder *base_video_decoder;
   GstBaseVideoDecoderClass *base_video_decoder_class;
   GstStructure *structure;
   const GValue *codec_data;
-  GstVideoState *state;
+  GstVideoState state;
   gboolean ret = TRUE;
 
   base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
   base_video_decoder_class =
       GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
 
-  GST_DEBUG ("setcaps %" GST_PTR_FORMAT, caps);
+  GST_DEBUG_OBJECT (base_video_decoder, "setcaps %" GST_PTR_FORMAT, caps);
 
-  state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
 
-  if (state->codec_data) {
-    gst_buffer_unref (state->codec_data);
-  }
-  memset (state, 0, sizeof (GstVideoState));
+  memset (&state, 0, sizeof (state));
+
+  state.caps = gst_caps_ref (caps);
 
   structure = gst_caps_get_structure (caps, 0);
 
-  gst_video_format_parse_caps (caps, NULL, &state->width, &state->height);
-  gst_video_parse_caps_framerate (caps, &state->fps_n, &state->fps_d);
-  gst_video_parse_caps_pixel_aspect_ratio (caps, &state->par_n, &state->par_d);
+  gst_video_format_parse_caps (caps, NULL, &state.width, &state.height);
+  /* this one fails if no framerate in caps */
+  if (!gst_video_parse_caps_framerate (caps, &state.fps_n, &state.fps_d)) {
+    state.fps_n = 0;
+    state.fps_d = 1;
+  }
+  /* but the p-a-r sets 1/1 instead, which is not quite informative ... */
+  if (!gst_structure_has_field (structure, "pixel-aspect-ratio") ||
+      !gst_video_parse_caps_pixel_aspect_ratio (caps,
+          &state.par_n, &state.par_d)) {
+    state.par_n = 0;
+    state.par_d = 1;
+  }
 
-  state->have_interlaced =
-      gst_video_format_parse_caps_interlaced (caps, &state->interlaced);
+  state.have_interlaced =
+      gst_video_format_parse_caps_interlaced (caps, &state.interlaced);
 
   codec_data = gst_structure_get_value (structure, "codec_data");
   if (codec_data && G_VALUE_TYPE (codec_data) == GST_TYPE_BUFFER) {
-    state->codec_data = gst_value_get_buffer (codec_data);
+    state.codec_data = GST_BUFFER (gst_value_dup_mini_object (codec_data));
   }
 
-  if (base_video_decoder_class->start) {
-    ret = base_video_decoder_class->start (base_video_decoder);
+  if (base_video_decoder_class->set_format) {
+    ret = base_video_decoder_class->set_format (base_video_decoder, &state);
   }
 
+  if (ret) {
+    gst_buffer_replace (&GST_BASE_VIDEO_CODEC (base_video_decoder)->
+        state.codec_data, NULL);
+    gst_caps_replace (&GST_BASE_VIDEO_CODEC (base_video_decoder)->state.caps,
+        NULL);
+    GST_BASE_VIDEO_CODEC (base_video_decoder)->state = state;
+  } else {
+    gst_buffer_replace (&state.codec_data, NULL);
+    gst_caps_replace (&state.caps, NULL);
+  }
+
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
   g_object_unref (base_video_decoder);
 
   return ret;
@@ -181,7 +337,7 @@ gst_base_video_decoder_finalize (GObject * object)
 
   base_video_decoder = GST_BASE_VIDEO_DECODER (object);
 
-  gst_base_video_decoder_reset (base_video_decoder);
+  GST_DEBUG_OBJECT (object, "finalize");
 
   if (base_video_decoder->input_adapter) {
     g_object_unref (base_video_decoder->input_adapter);
@@ -192,11 +348,46 @@ gst_base_video_decoder_finalize (GObject * object)
     base_video_decoder->output_adapter = NULL;
   }
 
-  GST_DEBUG_OBJECT (object, "finalize");
-
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
+/* hard == FLUSH, otherwise discont */
+static GstFlowReturn
+gst_base_video_decoder_flush (GstBaseVideoDecoder * dec, gboolean hard)
+{
+  GstBaseVideoDecoderClass *klass;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  klass = GST_BASE_VIDEO_DECODER_GET_CLASS (dec);
+
+  GST_LOG_OBJECT (dec, "flush hard %d", hard);
+
+  /* Inform subclass */
+  /* FIXME ? only if hard, or tell it if hard ? */
+  if (klass->reset)
+    klass->reset (dec);
+
+  /* FIXME make some more distinction between hard and soft,
+   * but subclass may not be prepared for that */
+  /* FIXME perhaps also clear pending frames ?,
+   * but again, subclass may still come up with one of those */
+  if (!hard) {
+    /* TODO ? finish/drain some stuff */
+  } else {
+    gst_segment_init (&GST_BASE_VIDEO_CODEC (dec)->segment,
+        GST_FORMAT_UNDEFINED);
+    gst_base_video_decoder_clear_queues (dec);
+    dec->error_count = 0;
+    g_list_foreach (dec->current_frame_events, (GFunc) gst_event_unref, NULL);
+    g_list_free (dec->current_frame_events);
+    dec->current_frame_events = NULL;
+  }
+  /* and get (re)set for the sequel */
+  gst_base_video_decoder_reset (dec, FALSE);
+
+  return ret;
+}
+
 static gboolean
 gst_base_video_decoder_sink_event (GstPad * pad, GstEvent * event)
 {
@@ -208,12 +399,17 @@ gst_base_video_decoder_sink_event (GstPad * pad, GstEvent * event)
   base_video_decoder_class =
       GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
 
+  GST_DEBUG_OBJECT (base_video_decoder,
+      "received event %d, %s", GST_EVENT_TYPE (event),
+      GST_EVENT_TYPE_NAME (event));
+
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_EOS:
     {
-      if (!base_video_decoder->packetized) {
-        GstFlowReturn flow_ret;
+      GstFlowReturn flow_ret;
 
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+      if (!base_video_decoder->packetized) {
         do {
           flow_ret =
               base_video_decoder_class->parse_data (base_video_decoder, TRUE);
@@ -221,69 +417,91 @@ gst_base_video_decoder_sink_event (GstPad * pad, GstEvent * event)
       }
 
       if (base_video_decoder_class->finish) {
-        base_video_decoder_class->finish (base_video_decoder);
+        flow_ret = base_video_decoder_class->finish (base_video_decoder);
+      } else {
+        flow_ret = GST_FLOW_OK;
       }
 
-      ret =
-          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
-          event);
-    }
+      if (flow_ret == GST_FLOW_OK)
+        ret = gst_base_video_decoder_push_src_event (base_video_decoder, event);
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
       break;
+    }
     case GST_EVENT_NEWSEGMENT:
     {
       gboolean update;
-      double rate;
-      double applied_rate;
+      double rate, arate;
       GstFormat format;
       gint64 start;
       gint64 stop;
-      gint64 position;
+      gint64 pos;
       GstSegment *segment = &GST_BASE_VIDEO_CODEC (base_video_decoder)->segment;
 
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
       gst_event_parse_new_segment_full (event, &update, &rate,
-          &applied_rate, &format, &start, &stop, &position);
-
-      if (format != GST_FORMAT_TIME)
-        goto newseg_wrong_format;
+          &arate, &format, &start, &stop, &pos);
+
+      if (format == GST_FORMAT_TIME) {
+        GST_DEBUG_OBJECT (base_video_decoder,
+            "received TIME NEW_SEGMENT %" GST_TIME_FORMAT
+            " -- %" GST_TIME_FORMAT ", pos %" GST_TIME_FORMAT
+            ", rate %g, applied_rate %g",
+            GST_TIME_ARGS (start), GST_TIME_ARGS (stop), GST_TIME_ARGS (pos),
+            rate, arate);
+      } else {
+        GstFormat dformat = GST_FORMAT_TIME;
+
+        GST_DEBUG_OBJECT (base_video_decoder,
+            "received NEW_SEGMENT %" G_GINT64_FORMAT
+            " -- %" G_GINT64_FORMAT ", time %" G_GINT64_FORMAT
+            ", rate %g, applied_rate %g", start, stop, pos, rate, arate);
+        /* handle newsegment as a result from our legacy simple seeking */
+        /* note that initial 0 should convert to 0 in any case */
+        if (base_video_decoder->do_byte_time &&
+            gst_pad_query_convert (GST_BASE_VIDEO_CODEC_SINK_PAD
+                (base_video_decoder), GST_FORMAT_BYTES, start, &dformat,
+                &start)) {
+          /* best attempt convert */
+          /* as these are only estimates, stop is kept open-ended to avoid
+           * premature cutting */
+          GST_DEBUG_OBJECT (base_video_decoder,
+              "converted to TIME start %" GST_TIME_FORMAT,
+              GST_TIME_ARGS (start));
+          pos = start;
+          stop = GST_CLOCK_TIME_NONE;
+          /* replace event */
+          gst_event_unref (event);
+          event = gst_event_new_new_segment_full (update, rate, arate,
+              GST_FORMAT_TIME, start, stop, pos);
+        } else {
+          GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
+          goto newseg_wrong_format;
+        }
+      }
 
       if (!update) {
-        gst_base_video_decoder_reset (base_video_decoder);
+        gst_base_video_decoder_flush (base_video_decoder, FALSE);
       }
 
       base_video_decoder->timestamp_offset = start;
 
       gst_segment_set_newsegment_full (segment,
-          update, rate, applied_rate, format, start, stop, position);
-      base_video_decoder->have_segment = TRUE;
+          update, rate, arate, format, start, stop, pos);
 
-      GST_DEBUG_OBJECT (base_video_decoder,
-          "new segment: format %d rate %g start %" GST_TIME_FORMAT
-          " stop %" GST_TIME_FORMAT
-          " position %" GST_TIME_FORMAT
-          " update %d",
-          format, rate,
-          GST_TIME_ARGS (segment->start),
-          GST_TIME_ARGS (segment->stop), GST_TIME_ARGS (segment->time), update);
-
-      ret =
-          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
-          event);
-    }
+      ret = gst_base_video_decoder_push_src_event (base_video_decoder, event);
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
       break;
-    case GST_EVENT_FLUSH_STOP:{
-      GST_OBJECT_LOCK (base_video_decoder);
-      GST_BASE_VIDEO_CODEC (base_video_decoder)->earliest_time =
-          GST_CLOCK_TIME_NONE;
-      GST_BASE_VIDEO_CODEC (base_video_decoder)->proportion = 0.5;
-      gst_segment_init (&GST_BASE_VIDEO_CODEC (base_video_decoder)->segment,
-          GST_FORMAT_TIME);
-      GST_OBJECT_UNLOCK (base_video_decoder);
+    }
+    case GST_EVENT_FLUSH_STOP:
+    {
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+      /* well, this is kind of worse than a DISCONT */
+      gst_base_video_decoder_flush (base_video_decoder, TRUE);
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
     }
     default:
       /* FIXME this changes the order of events */
-      ret =
-          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
-          event);
+      ret = gst_base_video_decoder_push_src_event (base_video_decoder, event);
       break;
   }
 
@@ -299,6 +517,76 @@ newseg_wrong_format:
   }
 }
 
+/* perform upstream byte <-> time conversion (duration, seeking)
+ * if subclass allows and if enough data for moderately decent conversion */
+static inline gboolean
+gst_base_video_decoder_do_byte (GstBaseVideoDecoder * dec)
+{
+  GstBaseVideoCodec *codec = GST_BASE_VIDEO_CODEC (dec);
+
+  return dec->do_byte_time && (codec->bytes > 0) && (codec->time > GST_SECOND);
+}
+
+static gboolean
+gst_base_video_decoder_do_seek (GstBaseVideoDecoder * dec, GstEvent * event)
+{
+  GstBaseVideoCodec *codec = GST_BASE_VIDEO_CODEC (dec);
+  GstSeekFlags flags;
+  GstSeekType start_type, end_type;
+  GstFormat format;
+  gdouble rate;
+  gint64 start, start_time, end_time;
+  GstSegment seek_segment;
+  guint32 seqnum;
+
+  gst_event_parse_seek (event, &rate, &format, &flags, &start_type,
+      &start_time, &end_type, &end_time);
+
+  /* we'll handle plain open-ended flushing seeks with the simple approach */
+  if (rate != 1.0) {
+    GST_DEBUG_OBJECT (dec, "unsupported seek: rate");
+    return FALSE;
+  }
+
+  if (start_type != GST_SEEK_TYPE_SET) {
+    GST_DEBUG_OBJECT (dec, "unsupported seek: start time");
+    return FALSE;
+  }
+
+  if (end_type != GST_SEEK_TYPE_NONE ||
+      (end_type == GST_SEEK_TYPE_SET && end_time != GST_CLOCK_TIME_NONE)) {
+    GST_DEBUG_OBJECT (dec, "unsupported seek: end time");
+    return FALSE;
+  }
+
+  if (!(flags & GST_SEEK_FLAG_FLUSH)) {
+    GST_DEBUG_OBJECT (dec, "unsupported seek: not flushing");
+    return FALSE;
+  }
+
+  memcpy (&seek_segment, &codec->segment, sizeof (seek_segment));
+  gst_segment_set_seek (&seek_segment, rate, format, flags, start_type,
+      start_time, end_type, end_time, NULL);
+  start_time = seek_segment.last_stop;
+
+  format = GST_FORMAT_BYTES;
+  if (!gst_pad_query_convert (codec->sinkpad, GST_FORMAT_TIME, start_time,
+          &format, &start)) {
+    GST_DEBUG_OBJECT (dec, "conversion failed");
+    return FALSE;
+  }
+
+  seqnum = gst_event_get_seqnum (event);
+  event = gst_event_new_seek (1.0, GST_FORMAT_BYTES, flags,
+      GST_SEEK_TYPE_SET, start, GST_SEEK_TYPE_NONE, -1);
+  gst_event_set_seqnum (event, seqnum);
+
+  GST_DEBUG_OBJECT (dec, "seeking to %" GST_TIME_FORMAT " at byte offset %"
+      G_GINT64_FORMAT, GST_TIME_ARGS (start_time), start);
+
+  return gst_pad_push_event (codec->sinkpad, event);
+}
+
 static gboolean
 gst_base_video_decoder_src_event (GstPad * pad, GstEvent * event)
 {
@@ -307,42 +595,54 @@ gst_base_video_decoder_src_event (GstPad * pad, GstEvent * event)
 
   base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
 
+  GST_DEBUG_OBJECT (base_video_decoder,
+      "received event %d, %s", GST_EVENT_TYPE (event),
+      GST_EVENT_TYPE_NAME (event));
+
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_SEEK:
     {
       GstFormat format, tformat;
       gdouble rate;
-      GstEvent *real_seek;
       GstSeekFlags flags;
       GstSeekType cur_type, stop_type;
       gint64 cur, stop;
-      gint64 tcur = -1, tstop = -1;
-
-      GST_DEBUG ("seek event");
-
-      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
-          &cur, &stop_type, &stop);
-      gst_event_unref (event);
+      gint64 tcur, tstop;
+      guint32 seqnum;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type, &cur,
+          &stop_type, &stop);
+      seqnum = gst_event_get_seqnum (event);
+
+      /* upstream gets a chance first */
+      if ((res =
+              gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+                  (base_video_decoder), event)))
+        break;
+
+      /* if upstream fails for a time seek, maybe we can help if allowed */
+      if (format == GST_FORMAT_TIME) {
+        if (gst_base_video_decoder_do_byte (base_video_decoder))
+          res = gst_base_video_decoder_do_seek (base_video_decoder, event);
+        break;
+      }
 
+      /* ... though a non-time seek can be aided as well */
+      /* First bring the requested format to time */
       tformat = GST_FORMAT_TIME;
-      res =
-          gst_base_video_decoder_src_convert (pad, format, cur, &tformat,
-          &tcur);
-      if (!res)
+      if (!(res = gst_pad_query_convert (pad, format, cur, &tformat, &tcur)))
         goto convert_error;
-      res =
-          gst_base_video_decoder_src_convert (pad, format, stop, &tformat,
-          &tstop);
-      if (!res)
+      if (!(res = gst_pad_query_convert (pad, format, stop, &tformat, &tstop)))
         goto convert_error;
 
-      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+      /* then seek with time on the peer */
+      event = gst_event_new_seek (rate, GST_FORMAT_TIME,
           flags, cur_type, tcur, stop_type, tstop);
+      gst_event_set_seqnum (event, seqnum);
 
       res =
           gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
-          (base_video_decoder), real_seek);
-
+          (base_video_decoder), event);
       break;
     }
     case GST_EVENT_QOS:
@@ -401,117 +701,6 @@ convert_error:
   goto done;
 }
 
-
-#if 0
-static gboolean
-gst_base_video_decoder_sink_convert (GstPad * pad,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 * dest_value)
-{
-  gboolean res = TRUE;
-  GstBaseVideoDecoder *enc;
-
-  if (src_format == *dest_format) {
-    *dest_value = src_value;
-    return TRUE;
-  }
-
-  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
-
-  /* FIXME: check if we are in a decoding state */
-
-  switch (src_format) {
-    case GST_FORMAT_BYTES:
-      switch (*dest_format) {
-#if 0
-        case GST_FORMAT_DEFAULT:
-          *dest_value = gst_util_uint64_scale_int (src_value, 1,
-              enc->bytes_per_picture);
-          break;
-#endif
-        case GST_FORMAT_TIME:
-          /* seems like a rather silly conversion, implement me if you like */
-        default:
-          res = FALSE;
-      }
-      break;
-    case GST_FORMAT_DEFAULT:
-      switch (*dest_format) {
-        case GST_FORMAT_TIME:
-          *dest_value = gst_util_uint64_scale (src_value,
-              GST_SECOND * enc->fps_d, enc->fps_n);
-          break;
-#if 0
-        case GST_FORMAT_BYTES:
-          *dest_value = gst_util_uint64_scale_int (src_value,
-              enc->bytes_per_picture, 1);
-          break;
-#endif
-        default:
-          res = FALSE;
-      }
-      break;
-    default:
-      res = FALSE;
-      break;
-  }
-}
-#endif
-
-static gboolean
-gst_base_video_decoder_src_convert (GstPad * pad,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 * dest_value)
-{
-  gboolean res = TRUE;
-  GstBaseVideoDecoder *enc;
-
-  if (src_format == *dest_format) {
-    *dest_value = src_value;
-    return TRUE;
-  }
-
-  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
-
-  /* FIXME: check if we are in a encoding state */
-
-  GST_DEBUG ("src convert");
-  switch (src_format) {
-#if 0
-    case GST_FORMAT_DEFAULT:
-      switch (*dest_format) {
-        case GST_FORMAT_TIME:
-          *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
-              enc->fps_d * GST_SECOND, enc->fps_n);
-          break;
-        default:
-          res = FALSE;
-      }
-      break;
-    case GST_FORMAT_TIME:
-      switch (*dest_format) {
-        case GST_FORMAT_DEFAULT:
-        {
-          *dest_value = gst_util_uint64_scale (src_value,
-              enc->fps_n, enc->fps_d * GST_SECOND);
-          break;
-        }
-        default:
-          res = FALSE;
-          break;
-      }
-      break;
-#endif
-    default:
-      res = FALSE;
-      break;
-  }
-
-  gst_object_unref (enc);
-
-  return res;
-}
-
 static const GstQueryType *
 gst_base_video_decoder_get_query_types (GstPad * pad)
 {
@@ -528,39 +717,74 @@ gst_base_video_decoder_get_query_types (GstPad * pad)
 static gboolean
 gst_base_video_decoder_src_query (GstPad * pad, GstQuery * query)
 {
-  GstBaseVideoDecoder *enc;
+  GstBaseVideoDecoder *dec;
   gboolean res = TRUE;
 
-  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  dec = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
 
-  switch GST_QUERY_TYPE
-    (query) {
+  GST_LOG_OBJECT (dec, "handling query: %" GST_PTR_FORMAT, query);
+
+  switch (GST_QUERY_TYPE (query)) {
     case GST_QUERY_POSITION:
     {
       GstFormat format;
-      gint64 time;
-
-      gst_query_parse_position (query, &format, NULL);
-      GST_DEBUG ("query in format %d", format);
-
-      if (format != GST_FORMAT_TIME) {
-        goto error;
+      gint64 time, value;
+
+      /* upstream gets a chance first */
+      if ((res =
+              gst_pad_peer_query (GST_BASE_VIDEO_CODEC_SINK_PAD (dec),
+                  query))) {
+        GST_LOG_OBJECT (dec, "returning peer response");
+        break;
       }
 
-      time = enc->last_timestamp;
-      time =
-          gst_segment_to_stream_time (&GST_BASE_VIDEO_CODEC (enc)->segment,
+      /* we start from the last seen time */
+      time = dec->last_timestamp;
+      /* correct for the segment values */
+      time = gst_segment_to_stream_time (&GST_BASE_VIDEO_CODEC (dec)->segment,
           GST_FORMAT_TIME, time);
 
-      gst_query_set_position (query, format, time);
+      GST_LOG_OBJECT (dec,
+          "query %p: our time: %" GST_TIME_FORMAT, query, GST_TIME_ARGS (time));
 
-      res = TRUE;
+      /* and convert to the final format */
+      gst_query_parse_position (query, &format, NULL);
+      if (!(res = gst_pad_query_convert (pad, GST_FORMAT_TIME, time,
+                  &format, &value)))
+        break;
+
+      gst_query_set_position (query, format, value);
 
+      GST_LOG_OBJECT (dec,
+          "query %p: we return %" G_GINT64_FORMAT " (format %u)", query, value,
+          format);
       break;
     }
     case GST_QUERY_DURATION:
     {
-      res = gst_pad_peer_query (enc->base_video_codec.sinkpad, query);
+      GstFormat format;
+
+      /* upstream in any case */
+      if ((res = gst_pad_query_default (pad, query)))
+        break;
+
+      gst_query_parse_duration (query, &format, NULL);
+      /* try answering TIME by converting from BYTE if subclass allows  */
+      if (format == GST_FORMAT_TIME && gst_base_video_decoder_do_byte (dec)) {
+        gint64 value;
+
+        format = GST_FORMAT_BYTES;
+        if (gst_pad_query_peer_duration (GST_BASE_VIDEO_CODEC_SINK_PAD (dec),
+                &format, &value)) {
+          GST_LOG_OBJECT (dec, "upstream size %" G_GINT64_FORMAT, value);
+          format = GST_FORMAT_TIME;
+          if (gst_pad_query_convert (GST_BASE_VIDEO_CODEC_SINK_PAD (dec),
+                  GST_FORMAT_BYTES, value, &format, &value)) {
+            gst_query_set_duration (query, GST_FORMAT_TIME, value);
+            res = TRUE;
+          }
+        }
+      }
       break;
     }
     case GST_QUERY_CONVERT:
@@ -568,12 +792,11 @@ gst_base_video_decoder_src_query (GstPad * pad, GstQuery * query)
       GstFormat src_fmt, dest_fmt;
       gint64 src_val, dest_val;
 
-      GST_DEBUG ("convert query");
+      GST_DEBUG_OBJECT (dec, "convert query");
 
       gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
-      res =
-          gst_base_video_decoder_src_convert (pad, src_fmt, src_val, &dest_fmt,
-          &dest_val);
+      res = gst_base_video_rawvideo_convert (&GST_BASE_VIDEO_CODEC (dec)->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
       if (!res)
         goto error;
       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
@@ -581,13 +804,13 @@ gst_base_video_decoder_src_query (GstPad * pad, GstQuery * query)
     }
     default:
       res = gst_pad_query_default (pad, query);
-    }
-  gst_object_unref (enc);
+  }
+  gst_object_unref (dec);
   return res;
 
 error:
-  GST_ERROR_OBJECT (enc, "query failed");
-  gst_object_unref (enc);
+  GST_ERROR_OBJECT (dec, "query failed");
+  gst_object_unref (dec);
   return res;
 }
 
@@ -599,19 +822,19 @@ gst_base_video_decoder_sink_query (GstPad * pad, GstQuery * query)
 
   base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
 
-  GST_DEBUG_OBJECT (base_video_decoder, "sink query fps=%d/%d",
-      GST_BASE_VIDEO_CODEC (base_video_decoder)->state.fps_n,
-      GST_BASE_VIDEO_CODEC (base_video_decoder)->state.fps_d);
+  GST_LOG_OBJECT (base_video_decoder, "handling query: %" GST_PTR_FORMAT,
+      query);
+
   switch (GST_QUERY_TYPE (query)) {
     case GST_QUERY_CONVERT:
     {
+      GstBaseVideoCodec *codec = GST_BASE_VIDEO_CODEC (base_video_decoder);
       GstFormat src_fmt, dest_fmt;
       gint64 src_val, dest_val;
 
       gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
-      res =
-          gst_base_video_rawvideo_convert (&GST_BASE_VIDEO_CODEC
-          (base_video_decoder)->state, src_fmt, src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&codec->state, codec->bytes,
+          codec->time, src_fmt, src_val, &dest_fmt, &dest_val);
       if (!res)
         goto error;
       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
@@ -630,25 +853,6 @@ error:
   goto done;
 }
 
-
-#if 0
-static gboolean
-gst_pad_is_negotiated (GstPad * pad)
-{
-  GstCaps *caps;
-
-  g_return_val_if_fail (pad != NULL, FALSE);
-
-  caps = gst_pad_get_negotiated_caps (pad);
-  if (caps) {
-    gst_caps_unref (caps);
-    return TRUE;
-  }
-
-  return FALSE;
-}
-#endif
-
 typedef struct _Timestamp Timestamp;
 struct _Timestamp
 {
@@ -665,7 +869,8 @@ gst_base_video_decoder_add_timestamp (GstBaseVideoDecoder * base_video_decoder,
 
   ts = g_malloc (sizeof (Timestamp));
 
-  GST_DEBUG ("adding timestamp %" GST_TIME_FORMAT " %" GST_TIME_FORMAT,
+  GST_LOG_OBJECT (base_video_decoder,
+      "adding timestamp %" GST_TIME_FORMAT " %" GST_TIME_FORMAT,
       GST_TIME_ARGS (base_video_decoder->input_offset),
       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)));
 
@@ -703,120 +908,89 @@ gst_base_video_decoder_get_timestamp_at_offset (GstBaseVideoDecoder *
     }
   }
 
-  GST_DEBUG ("got timestamp %" GST_TIME_FORMAT " %" GST_TIME_FORMAT,
+  GST_LOG_OBJECT (base_video_decoder,
+      "got timestamp %" GST_TIME_FORMAT " %" GST_TIME_FORMAT,
       GST_TIME_ARGS (offset), GST_TIME_ARGS (*timestamp));
 }
 
 static void
-gst_base_video_decoder_reset (GstBaseVideoDecoder * base_video_decoder)
+gst_base_video_decoder_clear_queues (GstBaseVideoDecoder * dec)
 {
-  GstBaseVideoDecoderClass *base_video_decoder_class;
+  g_list_foreach (dec->queued, (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (dec->queued);
+  dec->queued = NULL;
+  g_list_foreach (dec->gather, (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (dec->gather);
+  dec->gather = NULL;
+  g_list_foreach (dec->decode, (GFunc) gst_base_video_codec_free_frame, NULL);
+  g_list_free (dec->decode);
+  dec->decode = NULL;
+  g_list_foreach (dec->parse, (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (dec->parse);
+  dec->parse = NULL;
+  g_list_foreach (dec->parse_gather, (GFunc) gst_base_video_codec_free_frame,
+      NULL);
+  g_list_free (dec->parse_gather);
+  dec->parse_gather = NULL;
+}
 
-  base_video_decoder_class =
-      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+static void
+gst_base_video_decoder_reset (GstBaseVideoDecoder * base_video_decoder,
+    gboolean full)
+{
+  GST_DEBUG_OBJECT (base_video_decoder, "reset full %d", full);
 
-  GST_DEBUG ("reset");
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
 
-  base_video_decoder->started = FALSE;
+  if (full) {
+    gst_segment_init (&GST_BASE_VIDEO_CODEC (base_video_decoder)->segment,
+        GST_FORMAT_UNDEFINED);
+    gst_base_video_decoder_clear_queues (base_video_decoder);
+    base_video_decoder->error_count = 0;
+  }
 
-  base_video_decoder->discont = TRUE;
+  GST_BASE_VIDEO_CODEC (base_video_decoder)->discont = TRUE;
   base_video_decoder->have_sync = FALSE;
 
   base_video_decoder->timestamp_offset = GST_CLOCK_TIME_NONE;
-  GST_BASE_VIDEO_CODEC (base_video_decoder)->system_frame_number = 0;
-  base_video_decoder->presentation_frame_number = 0;
-  base_video_decoder->base_picture_number = 0;
+  base_video_decoder->field_index = 0;
   base_video_decoder->last_timestamp = GST_CLOCK_TIME_NONE;
 
   base_video_decoder->input_offset = 0;
   base_video_decoder->frame_offset = 0;
-
-  /* This function could be called from finalize() */
-  if (base_video_decoder->input_adapter) {
-    gst_adapter_clear (base_video_decoder->input_adapter);
-  }
-  if (base_video_decoder->output_adapter) {
-    gst_adapter_clear (base_video_decoder->output_adapter);
-  }
-  //gst_segment_init (&base_video_decoder->segment, GST_FORMAT_TIME);
+  gst_adapter_clear (base_video_decoder->input_adapter);
+  gst_adapter_clear (base_video_decoder->output_adapter);
+  g_list_foreach (base_video_decoder->timestamps, (GFunc) g_free, NULL);
+  g_list_free (base_video_decoder->timestamps);
+  base_video_decoder->timestamps = NULL;
 
   if (base_video_decoder->current_frame) {
-    gst_base_video_decoder_free_frame (base_video_decoder->current_frame);
+    gst_base_video_codec_free_frame (base_video_decoder->current_frame);
     base_video_decoder->current_frame = NULL;
   }
 
+  GST_BASE_VIDEO_CODEC (base_video_decoder)->system_frame_number = 0;
+  base_video_decoder->base_picture_number = 0;
+
   GST_OBJECT_LOCK (base_video_decoder);
   GST_BASE_VIDEO_CODEC (base_video_decoder)->earliest_time =
       GST_CLOCK_TIME_NONE;
   GST_BASE_VIDEO_CODEC (base_video_decoder)->proportion = 0.5;
   GST_OBJECT_UNLOCK (base_video_decoder);
-
-  if (base_video_decoder_class->reset) {
-    base_video_decoder_class->reset (base_video_decoder);
-  }
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 }
 
 static GstFlowReturn
-gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
+gst_base_video_decoder_chain_forward (GstBaseVideoDecoder * base_video_decoder,
+    GstBuffer * buf)
 {
-  GstBaseVideoDecoder *base_video_decoder;
   GstBaseVideoDecoderClass *klass;
   GstFlowReturn ret;
 
-  GST_DEBUG ("chain %" GST_TIME_FORMAT " duration %" GST_TIME_FORMAT " size %d",
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
-      GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_BUFFER_SIZE (buf));
-
-#if 0
-  /* requiring the pad to be negotiated makes it impossible to use
-   * oggdemux or filesrc ! decoder */
-  if (!gst_pad_is_negotiated (pad)) {
-    GST_DEBUG ("not negotiated");
-    return GST_FLOW_NOT_NEGOTIATED;
-  }
-#endif
-
-  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
   klass = GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
 
-  GST_DEBUG_OBJECT (base_video_decoder, "chain");
-
-  if (!base_video_decoder->have_segment) {
-    GstEvent *event;
-    GstFlowReturn ret;
-
-    GST_WARNING_OBJECT (base_video_decoder,
-        "Received buffer without a new-segment. Assuming timestamps start from 0.");
-
-    gst_segment_set_newsegment_full (&GST_BASE_VIDEO_CODEC
-        (base_video_decoder)->segment, FALSE, 1.0, 1.0, GST_FORMAT_TIME, 0,
-        GST_CLOCK_TIME_NONE, 0);
-    base_video_decoder->have_segment = TRUE;
-
-    event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, 0,
-        GST_CLOCK_TIME_NONE, 0);
-
-    ret =
-        gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
-        event);
-    if (!ret) {
-#if 0
-      /* Other base classes tend to ignore the return value */
-      GST_ERROR ("new segment event ret=%d", ret);
-      return GST_FLOW_ERROR;
-#endif
-    }
-  }
-
-  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
-    GST_DEBUG_OBJECT (base_video_decoder, "received DISCONT buffer");
-    gst_base_video_decoder_reset (base_video_decoder);
-  }
-
-  if (!base_video_decoder->started) {
-    klass->start (base_video_decoder);
-    base_video_decoder->started = TRUE;
-  }
+  g_return_val_if_fail (base_video_decoder->packetized || klass->parse_data,
+      GST_FLOW_ERROR);
 
   if (base_video_decoder->current_frame == NULL) {
     base_video_decoder->current_frame =
@@ -828,18 +1002,12 @@ gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
   }
   base_video_decoder->input_offset += GST_BUFFER_SIZE (buf);
 
-#if 0
-  if (base_video_decoder->timestamp_offset == GST_CLOCK_TIME_NONE &&
-      GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
-    GST_DEBUG ("got new offset %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
-    base_video_decoder->timestamp_offset = GST_BUFFER_TIMESTAMP (buf);
-  }
-#endif
-
   if (base_video_decoder->packetized) {
     base_video_decoder->current_frame->sink_buffer = buf;
 
+    if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT))
+      base_video_decoder->current_frame->is_sync_point = TRUE;
+
     ret = gst_base_video_decoder_have_frame_2 (base_video_decoder);
   } else {
 
@@ -848,7 +1016,7 @@ gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
     if (!base_video_decoder->have_sync) {
       int n, m;
 
-      GST_DEBUG ("no sync, scanning");
+      GST_DEBUG_OBJECT (base_video_decoder, "no sync, scanning");
 
       n = gst_adapter_available (base_video_decoder->input_adapter);
       if (klass->capture_mask != 0) {
@@ -860,21 +1028,22 @@ gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
         m = 0;
       }
       if (m == -1) {
-        GST_ERROR ("scan returned no sync");
+        GST_ERROR_OBJECT (base_video_decoder, "scan returned no sync");
         gst_adapter_flush (base_video_decoder->input_adapter, n - 3);
 
-        gst_object_unref (base_video_decoder);
         return GST_FLOW_OK;
       } else {
         if (m > 0) {
           if (m >= n) {
-            GST_ERROR ("subclass scanned past end %d >= %d", m, n);
+            GST_ERROR_OBJECT (base_video_decoder,
+                "subclass scanned past end %d >= %d", m, n);
           }
 
           gst_adapter_flush (base_video_decoder->input_adapter, m);
 
           if (m < n) {
-            GST_DEBUG ("found possible sync after %d bytes (of %d)", m, n);
+            GST_DEBUG_OBJECT (base_video_decoder,
+                "found possible sync after %d bytes (of %d)", m, n);
 
             /* this is only "maybe" sync */
             base_video_decoder->have_sync = TRUE;
@@ -889,12 +1058,241 @@ gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
     } while (ret == GST_FLOW_OK);
 
     if (ret == GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA) {
-      gst_object_unref (base_video_decoder);
       return GST_FLOW_OK;
     }
   }
 
-  gst_object_unref (base_video_decoder);
+  return ret;
+}
+
+static GstFlowReturn
+gst_base_video_decoder_flush_decode (GstBaseVideoDecoder * dec)
+{
+  GstFlowReturn res = GST_FLOW_OK;
+  GList *walk;
+
+  walk = dec->decode;
+
+  GST_DEBUG_OBJECT (dec, "flushing buffers to decode");
+
+  /* clear buffer and decoder state */
+  gst_base_video_decoder_flush (dec, FALSE);
+
+  /* signal have_frame it should not capture frames */
+  dec->process = TRUE;
+
+  while (walk) {
+    GList *next;
+    GstVideoFrame *frame = (GstVideoFrame *) (walk->data);
+    GstBuffer *buf = frame->sink_buffer;
+
+    GST_DEBUG_OBJECT (dec, "decoding frame %p, ts %" GST_TIME_FORMAT,
+        buf, GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
+
+    next = g_list_next (walk);
+    if (dec->current_frame)
+      gst_base_video_codec_free_frame (dec->current_frame);
+    dec->current_frame = frame;
+    /* decode buffer, resulting data prepended to queue */
+    res = gst_base_video_decoder_have_frame_2 (dec);
+
+    walk = next;
+  }
+
+  dec->process = FALSE;
+
+  return res;
+}
+
+static GstFlowReturn
+gst_base_video_decoder_flush_parse (GstBaseVideoDecoder * dec)
+{
+  GstFlowReturn res = GST_FLOW_OK;
+  GList *walk;
+
+  walk = dec->parse;
+
+  GST_DEBUG_OBJECT (dec, "flushing buffers to parsing");
+
+  /* clear buffer and decoder state */
+  gst_base_video_decoder_flush (dec, FALSE);
+
+  while (walk) {
+    GList *next;
+    GstBuffer *buf = GST_BUFFER_CAST (walk->data);
+
+    GST_DEBUG_OBJECT (dec, "parsing buffer %p, ts %" GST_TIME_FORMAT,
+        buf, GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
+
+    next = g_list_next (walk);
+    /* parse buffer, resulting frames prepended to parse_gather queue */
+    gst_buffer_ref (buf);
+    res = gst_base_video_decoder_chain_forward (dec, buf);
+
+    /* if we generated output, we can discard the buffer, else we
+     * keep it in the queue */
+    if (dec->parse_gather) {
+      GST_DEBUG_OBJECT (dec, "parsed buffer to %p", dec->parse_gather->data);
+      dec->parse = g_list_delete_link (dec->parse, walk);
+      gst_buffer_unref (buf);
+    } else {
+      GST_DEBUG_OBJECT (dec, "buffer did not decode, keeping");
+    }
+    walk = next;
+  }
+
+  /* now we can process frames */
+  GST_DEBUG_OBJECT (dec, "checking frames");
+  while (dec->parse_gather) {
+    GstVideoFrame *frame;
+
+    frame = (GstVideoFrame *) (dec->parse_gather->data);
+    /* remove from the gather list */
+    dec->parse_gather =
+        g_list_delete_link (dec->parse_gather, dec->parse_gather);
+    /* copy to decode queue */
+    dec->decode = g_list_prepend (dec->decode, frame);
+
+    /* if we copied a keyframe, flush and decode the decode queue */
+    if (frame->is_sync_point) {
+      GST_DEBUG_OBJECT (dec, "copied keyframe");
+      res = gst_base_video_decoder_flush_decode (dec);
+    }
+  }
+
+  /* now send queued data downstream */
+  while (dec->queued) {
+    GstBuffer *buf = GST_BUFFER_CAST (dec->queued->data);
+
+    if (G_LIKELY (res == GST_FLOW_OK)) {
+      GST_DEBUG_OBJECT (dec, "pushing buffer %p of size %u, "
+          "time %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT, buf,
+          GST_BUFFER_SIZE (buf), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+          GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
+      /* should be already, but let's be sure */
+      buf = gst_buffer_make_metadata_writable (buf);
+      /* avoid stray DISCONT from forward processing,
+       * which have no meaning in reverse pushing */
+      GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);
+      res = gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (dec), buf);
+    } else {
+      gst_buffer_unref (buf);
+    }
+
+    dec->queued = g_list_delete_link (dec->queued, dec->queued);
+  }
+
+  return res;
+}
+
+static GstFlowReturn
+gst_base_video_decoder_chain_reverse (GstBaseVideoDecoder * dec,
+    GstBuffer * buf)
+{
+  GstFlowReturn result = GST_FLOW_OK;
+
+  /* if we have a discont, move buffers to the decode list */
+  if (!buf || GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT)) {
+    GST_DEBUG_OBJECT (dec, "received discont");
+    while (dec->gather) {
+      GstBuffer *gbuf;
+
+      gbuf = GST_BUFFER_CAST (dec->gather->data);
+      /* remove from the gather list */
+      dec->gather = g_list_delete_link (dec->gather, dec->gather);
+      /* copy to parse queue */
+      dec->parse = g_list_prepend (dec->parse, gbuf);
+    }
+    /* parse and decode stuff in the parse queue */
+    gst_base_video_decoder_flush_parse (dec);
+  }
+
+  if (G_LIKELY (buf)) {
+    GST_DEBUG_OBJECT (dec, "gathering buffer %p of size %u, "
+        "time %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT, buf,
+        GST_BUFFER_SIZE (buf), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+        GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
+
+    /* add buffer to gather queue */
+    dec->gather = g_list_prepend (dec->gather, buf);
+  }
+
+  return result;
+}
+
+static GstFlowReturn
+gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (GST_PAD_PARENT (pad));
+
+  GST_LOG_OBJECT (base_video_decoder,
+      "chain %" GST_TIME_FORMAT " duration %" GST_TIME_FORMAT " size %d",
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+      GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_BUFFER_SIZE (buf));
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+
+  /* NOTE:
+   * requiring the pad to be negotiated makes it impossible to use
+   * oggdemux or filesrc ! decoder */
+
+  if (GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.format ==
+      GST_FORMAT_UNDEFINED) {
+    GstEvent *event;
+    GstFlowReturn ret;
+
+    GST_WARNING_OBJECT (base_video_decoder,
+        "Received buffer without a new-segment. "
+        "Assuming timestamps start from 0.");
+
+    gst_segment_set_newsegment_full (&GST_BASE_VIDEO_CODEC
+        (base_video_decoder)->segment, FALSE, 1.0, 1.0, GST_FORMAT_TIME, 0,
+        GST_CLOCK_TIME_NONE, 0);
+
+    event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, 0,
+        GST_CLOCK_TIME_NONE, 0);
+
+    ret = gst_base_video_decoder_push_src_event (base_video_decoder, event);
+    if (!ret) {
+      GST_ERROR_OBJECT (base_video_decoder, "new segment event ret=%d", ret);
+      ret = GST_FLOW_ERROR;
+      goto done;
+    }
+  }
+
+  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
+    gint64 ts, index;
+
+    GST_DEBUG_OBJECT (base_video_decoder, "received DISCONT buffer");
+
+    /* track present position */
+    ts = base_video_decoder->timestamp_offset;
+    index = base_video_decoder->field_index;
+
+    gst_base_video_decoder_flush (base_video_decoder, FALSE);
+
+    /* buffer may claim DISCONT loudly, if it can't tell us where we are now,
+     * we'll stick to where we were ...
+     * Particularly useful/needed for upstream BYTE based */
+    if (GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.rate > 0.0 &&
+        !GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
+      GST_DEBUG_OBJECT (base_video_decoder,
+          "... but restoring previous ts tracking");
+      base_video_decoder->timestamp_offset = ts;
+      base_video_decoder->field_index = index & ~1;
+    }
+  }
+
+  if (GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.rate > 0.0)
+    ret = gst_base_video_decoder_chain_forward (base_video_decoder, buf);
+  else
+    ret = gst_base_video_decoder_chain_reverse (base_video_decoder, buf);
+
+done:
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
   return ret;
 }
 
@@ -910,6 +1308,10 @@ gst_base_video_decoder_change_state (GstElement * element,
   base_video_decoder_class = GST_BASE_VIDEO_DECODER_GET_CLASS (element);
 
   switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (base_video_decoder_class->start) {
+        base_video_decoder_class->start (base_video_decoder);
+      }
     default:
       break;
   }
@@ -921,11 +1323,14 @@ gst_base_video_decoder_change_state (GstElement * element,
       if (base_video_decoder_class->stop) {
         base_video_decoder_class->stop (base_video_decoder);
       }
-      gst_segment_init (&GST_BASE_VIDEO_CODEC (base_video_decoder)->segment,
-          GST_FORMAT_TIME);
-      g_list_foreach (base_video_decoder->timestamps, (GFunc) g_free, NULL);
-      g_list_free (base_video_decoder->timestamps);
-      base_video_decoder->timestamps = NULL;
+
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+      gst_base_video_decoder_reset (base_video_decoder, TRUE);
+      g_list_foreach (base_video_decoder->current_frame_events,
+          (GFunc) gst_event_unref, NULL);
+      g_list_free (base_video_decoder->current_frame_events);
+      base_video_decoder->current_frame_events = NULL;
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
       break;
     default:
       break;
@@ -934,31 +1339,15 @@ gst_base_video_decoder_change_state (GstElement * element,
   return ret;
 }
 
-static void
-gst_base_video_decoder_free_frame (GstVideoFrame * frame)
-{
-  g_return_if_fail (frame != NULL);
-
-  if (frame->sink_buffer) {
-    gst_buffer_unref (frame->sink_buffer);
-  }
-  if (frame->src_buffer) {
-    gst_buffer_unref (frame->src_buffer);
-  }
-
-  g_free (frame);
-}
-
 static GstVideoFrame *
 gst_base_video_decoder_new_frame (GstBaseVideoDecoder * base_video_decoder)
 {
   GstVideoFrame *frame;
 
-  frame = g_malloc0 (sizeof (GstVideoFrame));
-
-  frame->system_frame_number =
-      GST_BASE_VIDEO_CODEC (base_video_decoder)->system_frame_number;
-  GST_BASE_VIDEO_CODEC (base_video_decoder)->system_frame_number++;
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+  frame =
+      gst_base_video_codec_new_frame (GST_BASE_VIDEO_CODEC
+      (base_video_decoder));
 
   frame->decode_frame_number = frame->system_frame_number -
       base_video_decoder->reorder_depth;
@@ -968,28 +1357,75 @@ gst_base_video_decoder_new_frame (GstBaseVideoDecoder * base_video_decoder)
   frame->presentation_duration = GST_CLOCK_TIME_NONE;
   frame->n_fields = 2;
 
+  frame->events = base_video_decoder->current_frame_events;
+  base_video_decoder->current_frame_events = NULL;
+
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
+
   return frame;
 }
 
+/**
+ * gst_base_video_decoder_finish_frame:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ * @frame: a decoded #GstVideoFrame
+ *
+ * @frame should have a valid decoded data buffer, whose metadata fields
+ * are then appropriately set according to frame data and pushed downstream.
+ * If no output data is provided, @frame is considered skipped.
+ * In any case, the frame is considered finished and released.
+ *
+ * Returns: a #GstFlowReturn resulting from sending data downstream
+ */
 GstFlowReturn
 gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
     GstVideoFrame * frame)
 {
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
   GstBuffer *src_buffer;
+  GstFlowReturn ret = GST_FLOW_OK;
+  GList *l, *events = NULL;
+
+  GST_LOG_OBJECT (base_video_decoder, "finish frame");
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
 
-  GST_DEBUG ("finish frame");
-  GST_DEBUG ("n %d in %d out %d",
+#ifndef GST_DISABLE_GST_DEBUG
+  GST_LOG_OBJECT (base_video_decoder, "n %d in %d out %d",
       g_list_length (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames),
       gst_adapter_available (base_video_decoder->input_adapter),
       gst_adapter_available (base_video_decoder->output_adapter));
+#endif
 
-  GST_DEBUG ("finish frame sync=%d pts=%" GST_TIME_FORMAT, frame->is_sync_point,
+  GST_LOG_OBJECT (base_video_decoder,
+      "finish frame sync=%d pts=%" GST_TIME_FORMAT, frame->is_sync_point,
       GST_TIME_ARGS (frame->presentation_timestamp));
 
+  /* Push all pending events that arrived before this frame */
+  for (l = base_video_decoder->base_video_codec.frames; l; l = l->next) {
+    GstVideoFrame *tmp = l->data;
+
+    if (tmp->events) {
+      GList *k;
+
+      for (k = g_list_last (tmp->events); k; k = k->prev)
+        events = g_list_prepend (events, k->data);
+      g_list_free (tmp->events);
+      tmp->events = NULL;
+    }
+
+    if (tmp == frame)
+      break;
+  }
+
+  for (l = g_list_last (events); l; l = l->next)
+    gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+        l->data);
+  g_list_free (events);
+
   if (GST_CLOCK_TIME_IS_VALID (frame->presentation_timestamp)) {
     if (frame->presentation_timestamp != base_video_decoder->timestamp_offset) {
-      GST_DEBUG ("sync timestamp %" GST_TIME_FORMAT " diff %" GST_TIME_FORMAT,
+      GST_DEBUG_OBJECT (base_video_decoder,
+          "sync timestamp %" GST_TIME_FORMAT " diff %" GST_TIME_FORMAT,
           GST_TIME_ARGS (frame->presentation_timestamp),
           GST_TIME_ARGS (frame->presentation_timestamp -
               GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.start));
@@ -998,15 +1434,17 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
     } else {
       /* This case is for one initial timestamp and no others, e.g.,
        * filesrc ! decoder ! xvimagesink */
-      GST_WARNING ("sync timestamp didn't change, ignoring");
+      GST_WARNING_OBJECT (base_video_decoder,
+          "sync timestamp didn't change, ignoring");
       frame->presentation_timestamp = GST_CLOCK_TIME_NONE;
     }
   } else {
     if (frame->is_sync_point) {
-      GST_WARNING ("sync point doesn't have timestamp");
+      GST_WARNING_OBJECT (base_video_decoder,
+          "sync point doesn't have timestamp");
       if (!GST_CLOCK_TIME_IS_VALID (base_video_decoder->timestamp_offset)) {
-        GST_WARNING
-            ("No base timestamp.  Assuming frames start at segment start");
+        GST_WARNING_OBJECT (base_video_decoder,
+            "No base timestamp.  Assuming frames start at segment start");
         base_video_decoder->timestamp_offset =
             GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.start;
         base_video_decoder->field_index &= 1;
@@ -1033,13 +1471,21 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
 
   if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->last_timestamp)) {
     if (frame->presentation_timestamp < base_video_decoder->last_timestamp) {
-      GST_WARNING ("decreasing timestamp (%" GST_TIME_FORMAT " < %"
+      GST_WARNING_OBJECT (base_video_decoder,
+          "decreasing timestamp (%" GST_TIME_FORMAT " < %"
           GST_TIME_FORMAT ")", GST_TIME_ARGS (frame->presentation_timestamp),
           GST_TIME_ARGS (base_video_decoder->last_timestamp));
     }
   }
   base_video_decoder->last_timestamp = frame->presentation_timestamp;
 
+  /* no buffer data means this frame is skipped/dropped */
+  if (!frame->src_buffer) {
+    GST_DEBUG_OBJECT (base_video_decoder, "skipping frame %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (frame->presentation_timestamp));
+    goto done;
+  }
+
   src_buffer = gst_buffer_make_metadata_writable (frame->src_buffer);
   frame->src_buffer = NULL;
 
@@ -1063,9 +1509,9 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
       GST_BUFFER_FLAG_SET (src_buffer, GST_VIDEO_BUFFER_ONEFIELD);
     }
   }
-  if (base_video_decoder->discont) {
+  if (GST_BASE_VIDEO_CODEC (base_video_decoder)->discont) {
     GST_BUFFER_FLAG_SET (src_buffer, GST_BUFFER_FLAG_DISCONT);
-    base_video_decoder->discont = FALSE;
+    GST_BASE_VIDEO_CODEC (base_video_decoder)->discont = FALSE;
   }
 
   GST_BUFFER_TIMESTAMP (src_buffer) = frame->presentation_timestamp;
@@ -1073,17 +1519,24 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
   GST_BUFFER_OFFSET (src_buffer) = GST_BUFFER_OFFSET_NONE;
   GST_BUFFER_OFFSET_END (src_buffer) = GST_BUFFER_OFFSET_NONE;
 
-  GST_DEBUG ("pushing frame %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (frame->presentation_timestamp));
-
-  GST_BASE_VIDEO_CODEC (base_video_decoder)->frames =
-      g_list_remove (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames, frame);
+  /* update rate estimate */
+  GST_BASE_VIDEO_CODEC (base_video_decoder)->bytes +=
+      GST_BUFFER_SIZE (src_buffer);
+  if (GST_CLOCK_TIME_IS_VALID (frame->presentation_duration)) {
+    GST_BASE_VIDEO_CODEC (base_video_decoder)->time +=
+        frame->presentation_duration;
+  } else {
+    /* better none than nothing valid */
+    GST_BASE_VIDEO_CODEC (base_video_decoder)->time = GST_CLOCK_TIME_NONE;
+  }
 
-  gst_base_video_decoder_set_src_caps (base_video_decoder);
   gst_buffer_set_caps (src_buffer,
       GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder)));
 
-  gst_base_video_decoder_free_frame (frame);
+  GST_LOG_OBJECT (base_video_decoder, "pushing frame ts %" GST_TIME_FORMAT
+      ", duration %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (src_buffer)),
+      GST_TIME_ARGS (GST_BUFFER_DURATION (src_buffer)));
 
   if (base_video_decoder->sink_clipping) {
     gint64 start = GST_BUFFER_TIMESTAMP (src_buffer);
@@ -1094,7 +1547,8 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
     if (gst_segment_clip (segment, GST_FORMAT_TIME, start, stop, &start, &stop)) {
       GST_BUFFER_TIMESTAMP (src_buffer) = start;
       GST_BUFFER_DURATION (src_buffer) = stop - start;
-      GST_DEBUG ("accepting buffer inside segment: %" GST_TIME_FORMAT
+      GST_LOG_OBJECT (base_video_decoder,
+          "accepting buffer inside segment: %" GST_TIME_FORMAT
           " %" GST_TIME_FORMAT
           " seg %" GST_TIME_FORMAT " to %" GST_TIME_FORMAT
           " time %" GST_TIME_FORMAT,
@@ -1104,7 +1558,8 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
           GST_TIME_ARGS (segment->start),
           GST_TIME_ARGS (segment->stop), GST_TIME_ARGS (segment->time));
     } else {
-      GST_DEBUG ("dropping buffer outside segment: %" GST_TIME_FORMAT
+      GST_LOG_OBJECT (base_video_decoder,
+          "dropping buffer outside segment: %" GST_TIME_FORMAT
           " %" GST_TIME_FORMAT
           " seg %" GST_TIME_FORMAT " to %" GST_TIME_FORMAT
           " time %" GST_TIME_FORMAT,
@@ -1114,119 +1569,53 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
           GST_TIME_ARGS (segment->start),
           GST_TIME_ARGS (segment->stop), GST_TIME_ARGS (segment->time));
       gst_buffer_unref (src_buffer);
-      return GST_FLOW_OK;
+      ret = GST_FLOW_OK;
+      goto done;
     }
   }
 
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
-      src_buffer);
-}
+  /* we got data, so note things are looking up again */
+  if (G_UNLIKELY (base_video_decoder->error_count))
+    base_video_decoder->error_count--;
 
-GstFlowReturn
-gst_base_video_decoder_skip_frame (GstBaseVideoDecoder * base_video_decoder,
-    GstVideoFrame * frame)
-{
-  GST_DEBUG ("finish frame");
-  GST_DEBUG ("finish frame sync=%d pts=%" GST_TIME_FORMAT, frame->is_sync_point,
-      GST_TIME_ARGS (frame->presentation_timestamp));
-
-  if (GST_CLOCK_TIME_IS_VALID (frame->presentation_timestamp)) {
-    if (frame->presentation_timestamp != base_video_decoder->timestamp_offset) {
-      GST_DEBUG ("sync timestamp %" GST_TIME_FORMAT " diff %" GST_TIME_FORMAT,
-          GST_TIME_ARGS (frame->presentation_timestamp),
-          GST_TIME_ARGS (frame->presentation_timestamp -
-              GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.start));
-      base_video_decoder->timestamp_offset = frame->presentation_timestamp;
-      base_video_decoder->field_index = 0;
-    } else {
-      /* This case is for one initial timestamp and no others, e.g.,
-       * filesrc ! decoder ! xvimagesink */
-      GST_WARNING ("sync timestamp didn't change, ignoring");
-      frame->presentation_timestamp = GST_CLOCK_TIME_NONE;
-    }
+  if (GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.rate < 0.0) {
+    GST_LOG_OBJECT (base_video_decoder, "queued buffer");
+    base_video_decoder->queued =
+        g_list_prepend (base_video_decoder->queued, src_buffer);
   } else {
-    if (frame->is_sync_point) {
-      GST_WARNING ("sync point doesn't have timestamp");
-      if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->timestamp_offset)) {
-        GST_WARNING
-            ("No base timestamp.  Assuming frames start at segment start");
-        base_video_decoder->timestamp_offset =
-            GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.start;
-        base_video_decoder->field_index = 0;
-      }
-    }
+    ret = gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+        src_buffer);
   }
-  frame->field_index = base_video_decoder->field_index;
-  base_video_decoder->field_index += frame->n_fields;
-
-  if (frame->presentation_timestamp == GST_CLOCK_TIME_NONE) {
-    frame->presentation_timestamp =
-        gst_base_video_decoder_get_field_timestamp (base_video_decoder,
-        frame->field_index);
-    frame->presentation_duration = GST_CLOCK_TIME_NONE;
-    frame->decode_timestamp =
-        gst_base_video_decoder_get_timestamp (base_video_decoder,
-        frame->decode_frame_number);
-  }
-  if (frame->presentation_duration == GST_CLOCK_TIME_NONE) {
-    frame->presentation_duration =
-        gst_base_video_decoder_get_field_duration (base_video_decoder,
-        frame->n_fields);
-  }
-
-  base_video_decoder->last_timestamp = frame->presentation_timestamp;
-
-  GST_DEBUG ("skipping frame %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (frame->presentation_timestamp));
 
+done:
   GST_BASE_VIDEO_CODEC (base_video_decoder)->frames =
       g_list_remove (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames, frame);
+  gst_base_video_codec_free_frame (frame);
 
-  gst_base_video_decoder_free_frame (frame);
-
-  return GST_FLOW_OK;
-}
-
-int
-gst_base_video_decoder_get_height (GstBaseVideoDecoder * base_video_decoder)
-{
-  GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
-
-  return state->height;
-}
-
-int
-gst_base_video_decoder_get_width (GstBaseVideoDecoder * base_video_decoder)
-{
-  GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
-
-  return state->width;
-}
-
-GstFlowReturn
-gst_base_video_decoder_end_of_stream (GstBaseVideoDecoder * base_video_decoder,
-    GstBuffer * buffer)
-{
-
-  if (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames) {
-    GST_DEBUG ("EOS with frames left over");
-  }
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
-      buffer);
+  return ret;
 }
 
+/**
+ * gst_base_video_decoder_finish_frame:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ * @n_bytes: an encoded #GstVideoFrame
+ *
+ * Removes next @n_bytes of input data and adds it to currently parsed frame.
+ */
 void
 gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder * base_video_decoder,
     int n_bytes)
 {
   GstBuffer *buf;
 
-  GST_DEBUG ("add to frame");
+  GST_LOG_OBJECT (base_video_decoder, "add %d bytes to frame", n_bytes);
 
   if (n_bytes == 0)
     return;
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
   if (gst_adapter_available (base_video_decoder->output_adapter) == 0) {
     base_video_decoder->frame_offset = base_video_decoder->input_offset -
         gst_adapter_available (base_video_decoder->input_adapter);
@@ -1234,6 +1623,7 @@ gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder * base_video_decoder,
   buf = gst_adapter_take_buffer (base_video_decoder->input_adapter, n_bytes);
 
   gst_adapter_push (base_video_decoder->output_adapter, buf);
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 }
 
 static guint64
@@ -1242,7 +1632,7 @@ gst_base_video_decoder_get_timestamp (GstBaseVideoDecoder * base_video_decoder,
 {
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
 
-  if (state->fps_d == 0) {
+  if (state->fps_d == 0 || state->fps_n == 0) {
     return -1;
   }
   if (picture_number < base_video_decoder->base_picture_number) {
@@ -1263,11 +1653,11 @@ gst_base_video_decoder_get_field_timestamp (GstBaseVideoDecoder *
 {
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
 
-  if (state->fps_d == 0) {
+  if (state->fps_d == 0 || state->fps_n == 0) {
     return GST_CLOCK_TIME_NONE;
   }
   if (field_offset < 0) {
-    GST_WARNING ("field offset < 0");
+    GST_WARNING_OBJECT (base_video_decoder, "field offset < 0");
     return GST_CLOCK_TIME_NONE;
   }
   return base_video_decoder->timestamp_offset +
@@ -1281,18 +1671,26 @@ gst_base_video_decoder_get_field_duration (GstBaseVideoDecoder *
 {
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
 
-  if (state->fps_d == 0) {
+  if (state->fps_d == 0 || state->fps_n == 0) {
     return GST_CLOCK_TIME_NONE;
   }
   if (n_fields < 0) {
-    GST_WARNING ("n_fields < 0");
+    GST_WARNING_OBJECT (base_video_decoder, "n_fields < 0");
     return GST_CLOCK_TIME_NONE;
   }
   return gst_util_uint64_scale (n_fields, state->fps_d * GST_SECOND,
       state->fps_n * 2);
 }
 
-
+/**
+ * gst_base_video_decoder_have_frame:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Gathers all data collected for currently parsed frame, gathers corresponding
+ * metadata and passes it along for further processing, i.e. @handle_frame.
+ *
+ * Returns: a #GstFlowReturn
+ */
 GstFlowReturn
 gst_base_video_decoder_have_frame (GstBaseVideoDecoder * base_video_decoder)
 {
@@ -1300,8 +1698,11 @@ gst_base_video_decoder_have_frame (GstBaseVideoDecoder * base_video_decoder)
   int n_available;
   GstClockTime timestamp;
   GstClockTime duration;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  GST_LOG_OBJECT (base_video_decoder, "have_frame");
 
-  GST_DEBUG ("have_frame");
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
 
   n_available = gst_adapter_available (base_video_decoder->output_adapter);
   if (n_available) {
@@ -1319,7 +1720,15 @@ gst_base_video_decoder_have_frame (GstBaseVideoDecoder * base_video_decoder)
   GST_BUFFER_TIMESTAMP (buffer) = timestamp;
   GST_BUFFER_DURATION (buffer) = duration;
 
-  return gst_base_video_decoder_have_frame_2 (base_video_decoder);
+  GST_LOG_OBJECT (base_video_decoder, "collected frame size %d, "
+      "ts %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT,
+      n_available, GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));
+
+  ret = gst_base_video_decoder_have_frame_2 (base_video_decoder);
+
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
+
+  return ret;
 }
 
 static GstFlowReturn
@@ -1332,16 +1741,28 @@ gst_base_video_decoder_have_frame_2 (GstBaseVideoDecoder * base_video_decoder)
   base_video_decoder_class =
       GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
 
+  g_return_val_if_fail (base_video_decoder_class->handle_frame != NULL,
+      GST_FLOW_ERROR);
+
+  /* capture frames and queue for later processing */
+  if (GST_BASE_VIDEO_CODEC (base_video_decoder)->segment.rate < 0.0 &&
+      !base_video_decoder->process) {
+    base_video_decoder->parse_gather =
+        g_list_prepend (base_video_decoder->parse_gather, frame);
+    goto exit;
+  }
+
   frame->distance_from_sync = base_video_decoder->distance_from_sync;
   base_video_decoder->distance_from_sync++;
 
   frame->presentation_timestamp = GST_BUFFER_TIMESTAMP (frame->sink_buffer);
   frame->presentation_duration = GST_BUFFER_DURATION (frame->sink_buffer);
 
-  GST_DEBUG ("pts %" GST_TIME_FORMAT,
+  GST_LOG_OBJECT (base_video_decoder, "pts %" GST_TIME_FORMAT,
       GST_TIME_ARGS (frame->presentation_timestamp));
-  GST_DEBUG ("dts %" GST_TIME_FORMAT, GST_TIME_ARGS (frame->decode_timestamp));
-  GST_DEBUG ("dist %d", frame->distance_from_sync);
+  GST_LOG_OBJECT (base_video_decoder, "dts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (frame->decode_timestamp));
+  GST_LOG_OBJECT (base_video_decoder, "dist %d", frame->distance_from_sync);
 
   GST_BASE_VIDEO_CODEC (base_video_decoder)->frames =
       g_list_append (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames, frame);
@@ -1354,9 +1775,11 @@ gst_base_video_decoder_have_frame_2 (GstBaseVideoDecoder * base_video_decoder)
   /* do something with frame */
   ret = base_video_decoder_class->handle_frame (base_video_decoder, frame);
   if (ret != GST_FLOW_OK) {
-    GST_DEBUG ("flow error!");
+    GST_DEBUG_OBJECT (base_video_decoder, "flow error %s",
+        gst_flow_get_name (ret));
   }
 
+exit:
   /* create new frame */
   base_video_decoder->current_frame =
       gst_base_video_decoder_new_frame (base_video_decoder);
@@ -1364,84 +1787,139 @@ gst_base_video_decoder_have_frame_2 (GstBaseVideoDecoder * base_video_decoder)
   return ret;
 }
 
+/**
+ * gst_base_video_decoder_get_state:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Returns: #GstVideoState describing format of video data.
+ */
 GstVideoState *
 gst_base_video_decoder_get_state (GstBaseVideoDecoder * base_video_decoder)
 {
   return &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
-
-}
-
-void
-gst_base_video_decoder_set_state (GstBaseVideoDecoder * base_video_decoder,
-    GstVideoState * state)
-{
-  memcpy (&GST_BASE_VIDEO_CODEC (base_video_decoder)->state,
-      state, sizeof (*state));
-
 }
 
+/**
+ * gst_base_video_decoder_lost_sync:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Advances out-of-sync input data by 1 byte and marks it accordingly.
+ */
 void
 gst_base_video_decoder_lost_sync (GstBaseVideoDecoder * base_video_decoder)
 {
   g_return_if_fail (GST_IS_BASE_VIDEO_DECODER (base_video_decoder));
 
-  GST_DEBUG ("lost_sync");
+  GST_DEBUG_OBJECT (base_video_decoder, "lost_sync");
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
 
   if (gst_adapter_available (base_video_decoder->input_adapter) >= 1) {
     gst_adapter_flush (base_video_decoder->input_adapter, 1);
   }
 
   base_video_decoder->have_sync = FALSE;
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 }
 
+/* FIXME not quite exciting; get rid of this ? */
+/**
+ * gst_base_video_decoder_set_sync_point:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Marks current frame as a sync point, i.e. keyframe.
+ */
 void
 gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder * base_video_decoder)
 {
-  GST_DEBUG ("set_sync_point");
+  GST_DEBUG_OBJECT (base_video_decoder, "set_sync_point");
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
   base_video_decoder->current_frame->is_sync_point = TRUE;
   base_video_decoder->distance_from_sync = 0;
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 }
 
+/**
+ * gst_base_video_decoder_get_oldest_frame:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Returns: oldest pending unfinished #GstVideoFrame.
+ */
 GstVideoFrame *
 gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *
     base_video_decoder)
 {
   GList *g;
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
   g = g_list_first (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames);
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 
   if (g == NULL)
     return NULL;
   return (GstVideoFrame *) (g->data);
 }
 
+/**
+ * gst_base_video_decoder_get_frame:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ * @frame_number: system_frame_number of a frame
+ *
+ * Returns: pending unfinished #GstVideoFrame identified by @frame_number.
+ */
 GstVideoFrame *
 gst_base_video_decoder_get_frame (GstBaseVideoDecoder * base_video_decoder,
     int frame_number)
 {
   GList *g;
+  GstVideoFrame *frame = NULL;
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
   for (g = g_list_first (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames);
       g; g = g_list_next (g)) {
-    GstVideoFrame *frame = g->data;
+    GstVideoFrame *tmp = g->data;
 
     if (frame->system_frame_number == frame_number) {
-      return frame;
+      frame = tmp;
+      break;
     }
   }
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
 
-  return NULL;
+  return frame;
 }
 
-void
+/**
+ * gst_base_video_decoder_set_src_caps:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Sets src pad caps according to currently configured #GstVideoState.
+ *
+ */
+gboolean
 gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder * base_video_decoder)
 {
   GstCaps *caps;
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
+  gboolean ret;
 
-  if (GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder)) != NULL)
-    return;
+  /* minimum sense */
+  g_return_val_if_fail (state->format != GST_VIDEO_FORMAT_UNKNOWN, FALSE);
+  g_return_val_if_fail (state->width != 0, FALSE);
+  g_return_val_if_fail (state->height != 0, FALSE);
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+
+  /* sanitize */
+  if (state->fps_n == 0 || state->fps_d == 0) {
+    state->fps_n = 0;
+    state->fps_d = 1;
+  }
+  if (state->par_n == 0 || state->par_d == 0) {
+    state->par_n = 1;
+    state->par_d = 1;
+  }
 
   caps = gst_video_format_new_caps (state->format,
       state->width, state->height,
@@ -1449,28 +1927,46 @@ gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder * base_video_decoder)
   gst_caps_set_simple (caps, "interlaced",
       G_TYPE_BOOLEAN, state->interlaced, NULL);
 
-  GST_DEBUG ("setting caps %" GST_PTR_FORMAT, caps);
-
-  gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder), caps);
+  GST_DEBUG_OBJECT (base_video_decoder, "setting caps %" GST_PTR_FORMAT, caps);
 
+  ret =
+      gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+      caps);
   gst_caps_unref (caps);
+
+  /* arrange for derived info */
+  state->bytes_per_picture =
+      gst_video_format_get_size (state->format, state->width, state->height);
+
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
+
+  return ret;
 }
 
+/**
+ * gst_base_video_decoder_alloc_src_buffer:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ *
+ * Helper function that uses gst_pad_alloc_buffer_and_set_caps
+ * to allocate a buffer to hold a video frame for @base_video_decoder's
+ * current #GstVideoState.
+ *
+ * Returns: allocated buffer
+ */
 GstBuffer *
 gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder *
     base_video_decoder)
 {
   GstBuffer *buffer;
   GstFlowReturn flow_ret;
-  int num_bytes;
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
+  int num_bytes = state->bytes_per_picture;
 
-  gst_base_video_decoder_set_src_caps (base_video_decoder);
-
-  num_bytes = gst_video_format_get_size (state->format, state->width,
-      state->height);
   GST_DEBUG ("alloc src buffer caps=%" GST_PTR_FORMAT,
       GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder)));
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
+
   flow_ret =
       gst_pad_alloc_buffer_and_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
       (base_video_decoder), GST_BUFFER_OFFSET_NONE, num_bytes,
@@ -1483,21 +1979,37 @@ gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder *
         GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder)));
   }
 
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
   return buffer;
 }
 
+/**
+ * gst_base_video_decoder_alloc_src_frame:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ * @frame: a #GstVideoFrame
+ *
+ * Helper function that uses gst_pad_alloc_buffer_and_set_caps
+ * to allocate a buffer to hold a video frame for @base_video_decoder's
+ * current #GstVideoState.  Subclass should already have configured video state
+ * and set src pad caps.
+ *
+ * Returns: result from pad alloc call
+ */
 GstFlowReturn
 gst_base_video_decoder_alloc_src_frame (GstBaseVideoDecoder *
     base_video_decoder, GstVideoFrame * frame)
 {
   GstFlowReturn flow_ret;
-  int num_bytes;
   GstVideoState *state = &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
+  int num_bytes = state->bytes_per_picture;
+
+  g_return_val_if_fail (state->bytes_per_picture != 0, GST_FLOW_ERROR);
+  g_return_val_if_fail (GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD
+          (base_video_decoder)) != NULL, GST_FLOW_ERROR);
 
-  gst_base_video_decoder_set_src_caps (base_video_decoder);
+  GST_LOG_OBJECT (base_video_decoder, "alloc buffer size %d", num_bytes);
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
 
-  num_bytes = gst_video_format_get_size (state->format, state->width,
-      state->height);
   flow_ret =
       gst_pad_alloc_buffer_and_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
       (base_video_decoder), GST_BUFFER_OFFSET_NONE, num_bytes,
@@ -1505,12 +2017,27 @@ gst_base_video_decoder_alloc_src_frame (GstBaseVideoDecoder *
       &frame->src_buffer);
 
   if (flow_ret != GST_FLOW_OK) {
-    GST_WARNING ("failed to get buffer");
+    GST_WARNING_OBJECT (base_video_decoder, "failed to get buffer %s",
+        gst_flow_get_name (flow_ret));
   }
 
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
+
   return flow_ret;
 }
 
+/**
+ * gst_base_video_decoder_get_max_decode_time:
+ * @base_video_decoder: a #GstBaseVideoDecoder
+ * @frame: a #GstVideoFrame
+ *
+ * Determines maximum possible decoding time for @frame that will
+ * allow it to decode and arrive in time (as determined by QoS messages).
+ * In particular, a negative result means decoding in time is no longer possible
+ * and should therefore occur as soon/skippy as possible.
+ *
+ * Returns: max decoding time.
+ */
 GstClockTimeDiff
 gst_base_video_decoder_get_max_decode_time (GstBaseVideoDecoder *
     base_video_decoder, GstVideoFrame * frame)
@@ -1518,21 +2045,59 @@ gst_base_video_decoder_get_max_decode_time (GstBaseVideoDecoder *
   GstClockTimeDiff deadline;
   GstClockTime earliest_time;
 
+  GST_OBJECT_LOCK (base_video_decoder);
   earliest_time = GST_BASE_VIDEO_CODEC (base_video_decoder)->earliest_time;
   if (GST_CLOCK_TIME_IS_VALID (earliest_time))
     deadline = GST_CLOCK_DIFF (earliest_time, frame->deadline);
   else
     deadline = G_MAXINT64;
 
+  GST_LOG_OBJECT (base_video_decoder, "earliest %" GST_TIME_FORMAT
+      ", frame deadline %" GST_TIME_FORMAT ", deadline %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (earliest_time), GST_TIME_ARGS (frame->deadline),
+      GST_TIME_ARGS (deadline));
+
+  GST_OBJECT_UNLOCK (base_video_decoder);
+
   return deadline;
 }
 
+/**
+ * gst_base_video_decoder_get_oldest_frame:
+ * @base_video_decoder_class: a #GstBaseVideoDecoderClass
+ *
+ * Sets the mask and pattern that will be scanned for to obtain parse sync.
+ * Note that a non-zero @mask implies that @scan_for_sync will be ignored.
+ *
+ */
 void
 gst_base_video_decoder_class_set_capture_pattern (GstBaseVideoDecoderClass *
     base_video_decoder_class, guint32 mask, guint32 pattern)
 {
   g_return_if_fail (((~mask) & pattern) == 0);
 
+  GST_DEBUG ("capture mask %08x, pattern %08x", mask, pattern);
+
   base_video_decoder_class->capture_mask = mask;
   base_video_decoder_class->capture_pattern = pattern;
 }
+
+GstFlowReturn
+_gst_base_video_decoder_error (GstBaseVideoDecoder * dec, gint weight,
+    GQuark domain, gint code, gchar * txt, gchar * dbg, const gchar * file,
+    const gchar * function, gint line)
+{
+  if (txt)
+    GST_WARNING_OBJECT (dec, "error: %s", txt);
+  if (dbg)
+    GST_WARNING_OBJECT (dec, "error: %s", dbg);
+  dec->error_count += weight;
+  GST_BASE_VIDEO_CODEC (dec)->discont = TRUE;
+  if (dec->max_errors < dec->error_count) {
+    gst_element_message_full (GST_ELEMENT (dec), GST_MESSAGE_ERROR,
+        domain, code, txt, dbg, file, function, line);
+    return GST_FLOW_ERROR;
+  } else {
+    return GST_FLOW_OK;
+  }
+}
diff --git a/gst-libs/gst/video/gstbasevideodecoder.h b/gst-libs/gst/video/gstbasevideodecoder.h
index ff3f9fe..98c29e5 100644
--- a/gst-libs/gst/video/gstbasevideodecoder.h
+++ b/gst-libs/gst/video/gstbasevideodecoder.h
@@ -1,5 +1,8 @@
 /* GStreamer
  * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ * Copyright (C) 2011 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>.
+ * Copyright (C) 2011 Nokia Corporation. All rights reserved.
+ *   Contact: Stefan Kost <stefan.kost@nokia.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -56,125 +59,216 @@ G_BEGIN_DECLS
 #define GST_BASE_VIDEO_DECODER_SRC_NAME     "src"
 
 /**
- *  * GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA:
- *   *
- *    */
+ * GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA:
+ *
+ * Returned while parsing to indicate more data is needed.
+ **/
 #define GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
 
+/**
+ * GST_BASE_VIDEO_DECODER_FLOW_DROPPED:
+ *
+ * Returned when the event/buffer should be dropped.
+ */
+#define GST_BASE_VIDEO_DECODER_FLOW_DROPPED GST_FLOW_CUSTOM_SUCCESS_1
 
 typedef struct _GstBaseVideoDecoder GstBaseVideoDecoder;
 typedef struct _GstBaseVideoDecoderClass GstBaseVideoDecoderClass;
 
+
+/* do not use this one, use macro below */
+GstFlowReturn _gst_base_video_decoder_error (GstBaseVideoDecoder *dec, gint weight,
+                                             GQuark domain, gint code,
+                                             gchar *txt, gchar *debug,
+                                             const gchar *file, const gchar *function,
+                                             gint line);
+
+/**
+ * GST_BASE_VIDEO_DECODER_ERROR:
+ * @el:     the base video decoder element that generates the error
+ * @weight: element defined weight of the error, added to error count
+ * @domain: like CORE, LIBRARY, RESOURCE or STREAM (see #gstreamer-GstGError)
+ * @code:   error code defined for that domain (see #gstreamer-GstGError)
+ * @text:   the message to display (format string and args enclosed in
+ *          parentheses)
+ * @debug:  debugging information for the message (format string and args
+ *          enclosed in parentheses)
+ * @ret:    variable to receive return value
+ *
+ * Utility function that audio decoder elements can use in case they encountered
+ * a data processing error that may be fatal for the current "data unit" but
+ * need not prevent subsequent decoding.  Such errors are counted and if there
+ * are too many, as configured in the context's max_errors, the pipeline will
+ * post an error message and the application will be requested to stop further
+ * media processing.  Otherwise, it is considered a "glitch" and only a warning
+ * is logged. In either case, @ret is set to the proper value to
+ * return to upstream/caller (indicating either GST_FLOW_ERROR or GST_FLOW_OK).
+ */
+#define GST_BASE_AUDIO_DECODER_ERROR(el, w, domain, code, text, debug, ret) \
+G_STMT_START {                                                              \
+  gchar *__txt = _gst_element_error_printf text;                            \
+  gchar *__dbg = _gst_element_error_printf debug;                           \
+  GstBaseVideoDecoder *dec = GST_BASE_VIDEO_DECODER (el);                   \
+  ret = _gst_base_video_decoder_error (dec, w, GST_ ## domain ## _ERROR,    \
+      GST_ ## domain ## _ERROR_ ## code, __txt, __dbg, __FILE__,            \
+      GST_FUNCTION, __LINE__);                                              \
+} G_STMT_END
+
+
+/**
+ * GstBaseVideoDecoder:
+ *
+ * The opaque #GstBaseVideoDecoder data structure.
+ */
 struct _GstBaseVideoDecoder
 {
   GstBaseVideoCodec base_video_codec;
 
-  /*< private >*/
-  GstAdapter *input_adapter;
-  GstAdapter *output_adapter;
+  /*< protected >*/
+  gboolean          sink_clipping;
+  gboolean          do_byte_time;
+  gboolean          packetized;
+  gint              max_errors;
 
-  gboolean have_sync;
-  gboolean discont;
-  gboolean started;
+  /* parse tracking */
+  /* input data */
+  GstAdapter       *input_adapter;
+  /* assembles current frame */
+  GstAdapter       *output_adapter;
 
-  gboolean sink_clipping;
+  /*< private >*/
+  /* FIXME move to real private part ?
+   * (and introduce a context ?) */
+  /* ... being tracked here;
+   * only available during parsing */
+  /* FIXME remove and add parameter to method */
+  GstVideoFrame    *current_frame;
+  /* events that should apply to the current frame */
+  GList            *current_frame_events;
+  /* relative offset of input data */
+  guint64           input_offset;
+  /* relative offset of frame */
+  guint64           frame_offset;
+  /* tracking ts and offsets */
+  GList            *timestamps;
+  /* whether parsing is in sync */
+  gboolean          have_sync;
+
+  /* maybe sort-of protected ? */
+
+  /* combine to yield (presentation) ts */
+  GstClockTime      timestamp_offset;
+  int               field_index;
+
+  /* last outgoing ts */
+  GstClockTime      last_timestamp;
+  gint              error_count;
+
+  /* reverse playback */
+  /* collect input */
+  GList            *gather;
+  /* to-be-parsed */
+  GList            *parse;
+  /* collected parsed frames */
+  GList            *parse_gather;
+  /* frames to be handled == decoded */
+  GList            *decode;
+  /* collected output */
+  GList            *queued;
+  gboolean          process;
+
+  /* no comment ... */
+  guint64           base_picture_number;
+  int               reorder_depth;
+  int               distance_from_sync;
 
-  guint64 presentation_frame_number;
+  /* FIXME before moving to base */
+  void             *padding[GST_PADDING_LARGE];
+};
 
-  gboolean have_src_caps;
+/**
+ * GstBaseAudioDecoderClass:
+ * @start:          Optional.
+ *                  Called when the element starts processing.
+ *                  Allows opening external resources.
+ * @stop:           Optional.
+ *                  Called when the element stops processing.
+ *                  Allows closing external resources.
+ * @set_format:     Notifies subclass of incoming data format (caps).
+ * @scan_for_sync:  Optional.
+ *                  Allows subclass to obtain sync for subsequent parsing
+ *                  by custom means (above an beyond scanning for specific
+ *                  marker and mask).
+ * @parse_data:     Required for non-packetized input.
+ *                  Allows chopping incoming data into manageable units (frames)
+ *                  for subsequent decoding.
+ * @reset:          Optional.
+ *                  Allows subclass (codec) to perform post-seek semantics reset.
+ * @handle_frame:   Provides input data frame to subclass.
+ * @finish:         Optional.
+ *                  Called to request subclass to dispatch any pending remaining
+ *                  data (e.g. at EOS).
+ *
+ * Subclasses can override any of the available virtual methods or not, as
+ * needed. At minimum @handle_frame needs to be overridden, and @set_format
+ * and likely as well.  If non-packetized input is supported or expected,
+ * @parse needs to be overridden as well.
+ */
+struct _GstBaseVideoDecoderClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
 
-  GstVideoFrame *current_frame;
+  gboolean      (*start)          (GstBaseVideoDecoder *coder);
 
-  int distance_from_sync;
-  int reorder_depth;
+  gboolean      (*stop)           (GstBaseVideoDecoder *coder);
 
-  GstClockTime buffer_timestamp;
+  int           (*scan_for_sync)  (GstBaseVideoDecoder *decoder, gboolean at_eos,
+                                   int offset, int n);
 
-  GstClockTime timestamp_offset;
+  GstFlowReturn (*parse_data)     (GstBaseVideoDecoder *decoder, gboolean at_eos);
 
-  //GstBuffer *codec_data;
+  gboolean      (*set_format)     (GstBaseVideoDecoder *coder, GstVideoState * state);
 
-  guint64 input_offset;
-  guint64 frame_offset;
-  GstClockTime last_timestamp;
+  gboolean      (*reset)          (GstBaseVideoDecoder *coder);
 
-  guint64 base_picture_number;
+  GstFlowReturn (*finish)         (GstBaseVideoDecoder *coder);
 
-  int field_index;
+  GstFlowReturn (*handle_frame)   (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
 
-  gboolean is_delta_unit;
-  gboolean packetized;
 
-  GList *timestamps;
-  gboolean have_segment;
+  /*< private >*/
+  guint32       capture_mask;
+  guint32       capture_pattern;
 
   /* FIXME before moving to base */
-  void *padding[GST_PADDING_LARGE];
+  void         *padding[GST_PADDING_LARGE];
 };
 
-struct _GstBaseVideoDecoderClass
-{
-  GstBaseVideoCodecClass base_video_codec_class;
-
-  gboolean (*set_format) (GstBaseVideoDecoder *coder, GstVideoFormat,
-      int width, int height, int fps_n, int fps_d,
-      int par_n, int par_d);
-  gboolean (*start) (GstBaseVideoDecoder *coder);
-  gboolean (*stop) (GstBaseVideoDecoder *coder);
-  gboolean (*reset) (GstBaseVideoDecoder *coder);
-  int (*scan_for_sync) (GstBaseVideoDecoder *decoder, gboolean at_eos,
-      int offset, int n);
-  GstFlowReturn (*parse_data) (GstBaseVideoDecoder *decoder, gboolean at_eos);
-  GstFlowReturn (*finish) (GstBaseVideoDecoder *coder);
-  GstFlowReturn (*handle_frame) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
-  GstFlowReturn (*shape_output) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
-  GstCaps *(*get_caps) (GstBaseVideoDecoder *coder);
-
-  guint32 capture_mask;
-  guint32 capture_pattern;
+void             gst_base_video_decoder_class_set_capture_pattern (GstBaseVideoDecoderClass *klass,
+                                    guint32 mask, guint32 pattern);
 
-  /* FIXME before moving to base */
-  void *padding[GST_PADDING_LARGE];
-};
+GstVideoFrame   *gst_base_video_decoder_get_frame (GstBaseVideoDecoder *coder,
+                                    int frame_number);
+GstVideoFrame   *gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *coder);
 
-GType gst_base_video_decoder_get_type (void);
-
-void gst_base_video_decoder_class_set_capture_pattern (GstBaseVideoDecoderClass *klass,
-    guint32 mask, guint32 pattern);
-
-int gst_base_video_decoder_get_width (GstBaseVideoDecoder *coder);
-int gst_base_video_decoder_get_height (GstBaseVideoDecoder *coder);
-
-guint64 gst_base_video_decoder_get_timestamp_offset (GstBaseVideoDecoder *coder);
-
-GstVideoFrame *gst_base_video_decoder_get_frame (GstBaseVideoDecoder *coder,
-    int frame_number);
-GstVideoFrame *gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *coder);
-void gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder *base_video_decoder,
-    int n_bytes);
-GstFlowReturn gst_base_video_decoder_finish_frame (GstBaseVideoDecoder *base_video_decoder,
-    GstVideoFrame *frame);
-GstFlowReturn gst_base_video_decoder_skip_frame (GstBaseVideoDecoder * base_video_decoder,
-    GstVideoFrame * frame);
-GstFlowReturn gst_base_video_decoder_end_of_stream (GstBaseVideoDecoder *base_video_decoder,
-    GstBuffer *buffer);
-GstFlowReturn
-gst_base_video_decoder_have_frame (GstBaseVideoDecoder *base_video_decoder);
-GstVideoState * gst_base_video_decoder_get_state (GstBaseVideoDecoder *base_video_decoder);
-void gst_base_video_decoder_set_state (GstBaseVideoDecoder *base_video_decoder,
-    GstVideoState *state);
-void gst_base_video_decoder_lost_sync (GstBaseVideoDecoder *base_video_decoder);
-void gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder *base_video_decoder);
-
-void gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder *base_video_decoder);
-
-GstBuffer * gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder *
-    base_video_decoder);
-GstFlowReturn gst_base_video_decoder_alloc_src_frame (GstBaseVideoDecoder *base_video_decoder,
-    GstVideoFrame *frame);
+void             gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder *base_video_decoder,
+                                    int n_bytes);
+void             gst_base_video_decoder_lost_sync (GstBaseVideoDecoder *base_video_decoder);
+GstFlowReturn    gst_base_video_decoder_have_frame (GstBaseVideoDecoder *base_video_decoder);
 
+void             gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder *base_video_decoder);
+gboolean         gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder *base_video_decoder);
+GstBuffer       *gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder * base_video_decoder);
+GstFlowReturn    gst_base_video_decoder_alloc_src_frame (GstBaseVideoDecoder *base_video_decoder,
+                                    GstVideoFrame *frame);
+GstVideoState   *gst_base_video_decoder_get_state (GstBaseVideoDecoder *base_video_decoder);
 GstClockTimeDiff gst_base_video_decoder_get_max_decode_time (
-    GstBaseVideoDecoder *base_video_decoder, GstVideoFrame *frame);
+                                    GstBaseVideoDecoder *base_video_decoder,
+                                    GstVideoFrame *frame);
+GstFlowReturn    gst_base_video_decoder_finish_frame (GstBaseVideoDecoder *base_video_decoder,
+                                    GstVideoFrame *frame);
+
+GType            gst_base_video_decoder_get_type (void);
 
 G_END_DECLS
 
diff --git a/gst-libs/gst/video/gstbasevideoencoder.c b/gst-libs/gst/video/gstbasevideoencoder.c
index 7926f53..b04cf77 100644
--- a/gst-libs/gst/video/gstbasevideoencoder.c
+++ b/gst-libs/gst/video/gstbasevideoencoder.c
@@ -1,5 +1,8 @@
 /* GStreamer
  * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ * Copyright (C) 2011 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>.
+ * Copyright (C) 2011 Nokia Corporation. All rights reserved.
+ *   Contact: Stefan Kost <stefan.kost@nokia.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -17,11 +20,95 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/**
+ * SECTION:gstbasevideoencoder
+ * @short_description: Base class for video encoders
+ * @see_also: #GstBaseTransform
+ *
+ * This base class is for video encoders turning raw video into
+ * encoded video data.
+ *
+ * GstBaseVideoEncoder and subclass should cooperate as follows.
+ * <orderedlist>
+ * <listitem>
+ *   <itemizedlist><title>Configuration</title>
+ *   <listitem><para>
+ *     Initially, GstBaseVideoEncoder calls @start when the encoder element
+ *     is activated, which allows subclass to perform any global setup.
+ *   </para></listitem>
+ *   <listitem><para>
+ *     GstBaseVideoEncoder calls @set_format to inform subclass of the format
+ *     of input video data that it is about to receive.  Subclass should
+ *     setup for encoding and configure base class as appropriate
+ *     (e.g. latency). While unlikely, it might be called more than once,
+ *     if changing input parameters require reconfiguration.  Baseclass
+ *     will ensure that processing of current configuration is finished.
+ *   </para></listitem>
+ *   <listitem><para>
+ *     GstBaseVideoEncoder calls @stop at end of all processing.
+ *   </para></listitem>
+ *   </itemizedlist>
+ * </listitem>
+ * <listitem>
+ *   <itemizedlist>
+ *   <title>Data processing</title>
+ *     <listitem><para>
+ *       Base class collects input data and metadata into a frame and hands
+ *       this to subclass' @handle_frame.
+ *     </para></listitem>
+ *     <listitem><para>
+ *       If codec processing results in encoded data, subclass should call
+ *       @gst_base_video_encoder_finish_frame to have encoded data pushed
+ *       downstream.
+ *     </para></listitem>
+ *     <listitem><para>
+ *       If implemented, baseclass calls subclass @shape_output which then sends
+ *       data downstream in desired form.  Otherwise, it is sent as-is.
+ *     </para></listitem>
+ *     <listitem><para>
+ *       GstBaseVideoEncoderClass will handle both srcpad and sinkpad events.
+ *       Sink events will be passed to subclass if @event callback has been
+ *       provided.
+ *     </para></listitem>
+ *   </itemizedlist>
+ * </listitem>
+ * <listitem>
+ *   <itemizedlist><title>Shutdown phase</title>
+ *   <listitem><para>
+ *     GstBaseVideoEncoder class calls @stop to inform the subclass that data
+ *     parsing will be stopped.
+ *   </para></listitem>
+ *   </itemizedlist>
+ * </listitem>
+ * </orderedlist>
+ *
+ * Subclass is responsible for providing pad template caps for
+ * source and sink pads. The pads need to be named "sink" and "src". It should
+ * also be able to provide fixed src pad caps in @getcaps by the time it calls
+ * @gst_base_video_encoder_finish_frame.
+ *
+ * Things that subclass need to take care of:
+ * <itemizedlist>
+ *   <listitem><para>Provide pad templates</para></listitem>
+ *   <listitem><para>
+ *      Provide source pad caps before pushing the first buffer
+ *   </para></listitem>
+ *   <listitem><para>
+ *      Accept data in @handle_frame and provide encoded results to
+ *      @gst_base_video_encoder_finish_frame.
+ *   </para></listitem>
+ * </itemizedlist>
+ *
+ */
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "gstbasevideoencoder.h"
+#include "gstbasevideoutils.h"
+
+#include <string.h>
 
 GST_DEBUG_CATEGORY (basevideoencoder_debug);
 #define GST_CAT_DEFAULT basevideoencoder_debug
@@ -30,13 +117,13 @@ static void gst_base_video_encoder_finalize (GObject * object);
 
 static gboolean gst_base_video_encoder_sink_setcaps (GstPad * pad,
     GstCaps * caps);
+static GstCaps *gst_base_video_encoder_sink_getcaps (GstPad * pad);
 static gboolean gst_base_video_encoder_src_event (GstPad * pad,
     GstEvent * event);
 static gboolean gst_base_video_encoder_sink_event (GstPad * pad,
     GstEvent * event);
 static GstFlowReturn gst_base_video_encoder_chain (GstPad * pad,
     GstBuffer * buf);
-//static GstFlowReturn gst_base_video_encoder_process (GstBaseVideoEncoder *base_video_encoder);
 static GstStateChangeReturn gst_base_video_encoder_change_state (GstElement *
     element, GstStateChange transition);
 static const GstQueryType *gst_base_video_encoder_get_query_types (GstPad *
@@ -45,8 +132,21 @@ static gboolean gst_base_video_encoder_src_query (GstPad * pad,
     GstQuery * query);
 
 
-GST_BOILERPLATE (GstBaseVideoEncoder, gst_base_video_encoder, GstBaseVideoCodec,
-    GST_TYPE_BASE_VIDEO_CODEC);
+static void
+_do_init (GType object_type)
+{
+  const GInterfaceInfo preset_interface_info = {
+    NULL,                       /* interface_init */
+    NULL,                       /* interface_finalize */
+    NULL                        /* interface_data */
+  };
+
+  g_type_add_interface_static (object_type, GST_TYPE_PRESET,
+      &preset_interface_info);
+}
+
+GST_BOILERPLATE_FULL (GstBaseVideoEncoder, gst_base_video_encoder,
+    GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC, _do_init);
 
 static void
 gst_base_video_encoder_base_init (gpointer g_class)
@@ -67,9 +167,34 @@ gst_base_video_encoder_class_init (GstBaseVideoEncoderClass * klass)
 
   gobject_class->finalize = gst_base_video_encoder_finalize;
 
-  gstelement_class->change_state = gst_base_video_encoder_change_state;
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_change_state);
+}
+
+static void
+gst_base_video_encoder_reset (GstBaseVideoEncoder * base_video_encoder)
+{
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
+
+  base_video_encoder->presentation_frame_number = 0;
+  base_video_encoder->distance_from_sync = 0;
+  base_video_encoder->force_keyframe = FALSE;
+
+  base_video_encoder->drained = TRUE;
+  base_video_encoder->min_latency = 0;
+  base_video_encoder->max_latency = 0;
+
+  if (base_video_encoder->force_keyunit_event) {
+    gst_event_unref (base_video_encoder->force_keyunit_event);
+    base_video_encoder->force_keyunit_event = NULL;
+  }
+
+  g_list_foreach (base_video_encoder->current_frame_events,
+      (GFunc) gst_event_unref, NULL);
+  g_list_free (base_video_encoder->current_frame_events);
+  base_video_encoder->current_frame_events = NULL;
 
-  parent_class = g_type_class_peek_parent (klass);
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
 }
 
 static void
@@ -78,22 +203,69 @@ gst_base_video_encoder_init (GstBaseVideoEncoder * base_video_encoder,
 {
   GstPad *pad;
 
-  GST_DEBUG ("gst_base_video_encoder_init");
+  GST_DEBUG_OBJECT (base_video_encoder, "gst_base_video_encoder_init");
 
   pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_encoder);
 
-  gst_pad_set_chain_function (pad, gst_base_video_encoder_chain);
-  gst_pad_set_event_function (pad, gst_base_video_encoder_sink_event);
-  gst_pad_set_setcaps_function (pad, gst_base_video_encoder_sink_setcaps);
-  //gst_pad_set_query_function (pad, gst_base_video_encoder_sink_query);
+  gst_pad_set_chain_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_chain));
+  gst_pad_set_event_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_sink_event));
+  gst_pad_set_setcaps_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_sink_setcaps));
+  gst_pad_set_getcaps_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_sink_getcaps));
 
   pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder);
 
-  gst_pad_set_query_type_function (pad, gst_base_video_encoder_get_query_types);
-  gst_pad_set_query_function (pad, gst_base_video_encoder_src_query);
-  gst_pad_set_event_function (pad, gst_base_video_encoder_src_event);
+  gst_pad_set_query_type_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_get_query_types));
+  gst_pad_set_query_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_src_query));
+  gst_pad_set_event_function (pad,
+      GST_DEBUG_FUNCPTR (gst_base_video_encoder_src_event));
 
   base_video_encoder->a.at_eos = FALSE;
+
+  /* encoder is expected to do so */
+  base_video_encoder->sink_clipping = TRUE;
+}
+
+static gboolean
+gst_base_video_encoder_drain (GstBaseVideoEncoder * enc)
+{
+  GstBaseVideoCodec *codec;
+  GstBaseVideoEncoderClass *enc_class;
+  gboolean ret = TRUE;
+
+  codec = GST_BASE_VIDEO_CODEC (enc);
+  enc_class = GST_BASE_VIDEO_ENCODER_GET_CLASS (enc);
+
+  GST_DEBUG_OBJECT (enc, "draining");
+
+  if (enc->drained) {
+    GST_DEBUG_OBJECT (enc, "already drained");
+    return TRUE;
+  }
+
+  if (enc_class->reset) {
+    GST_DEBUG_OBJECT (enc, "requesting subclass to finish");
+    ret = enc_class->reset (enc);
+  }
+  /* everything should be away now */
+  if (codec->frames) {
+    /* not fatal/impossible though if subclass/codec eats stuff */
+    GST_WARNING_OBJECT (enc, "still %d frames left after draining",
+        g_list_length (codec->frames));
+#if 0
+    /* FIXME should do this, but subclass may come up with it later on ?
+     * and would then need refcounting or so on frames */
+    g_list_foreach (codec->frames,
+        (GFunc) gst_base_video_codec_free_frame, NULL);
+#endif
+  }
+
+  return ret;
 }
 
 static gboolean
@@ -102,45 +274,92 @@ gst_base_video_encoder_sink_setcaps (GstPad * pad, GstCaps * caps)
   GstBaseVideoEncoder *base_video_encoder;
   GstBaseVideoEncoderClass *base_video_encoder_class;
   GstStructure *structure;
-  GstVideoState *state;
+  GstVideoState *state, tmp_state;
   gboolean ret;
+  gboolean changed = FALSE;
 
   base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
   base_video_encoder_class =
       GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
 
-  GST_DEBUG ("setcaps");
+  /* subclass should do something here ... */
+  g_return_val_if_fail (base_video_encoder_class->set_format != NULL, FALSE);
+
+  GST_DEBUG_OBJECT (base_video_encoder, "setcaps %" GST_PTR_FORMAT, caps);
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
 
   state = &GST_BASE_VIDEO_CODEC (base_video_encoder)->state;
+  memset (&tmp_state, 0, sizeof (tmp_state));
+
+  tmp_state.caps = gst_caps_ref (caps);
   structure = gst_caps_get_structure (caps, 0);
 
-  gst_video_format_parse_caps (caps, &state->format,
-      &state->width, &state->height);
+  ret =
+      gst_video_format_parse_caps (caps, &tmp_state.format, &tmp_state.width,
+      &tmp_state.height);
+  if (!ret)
+    goto exit;
 
-  state->fps_n = 0;
-  state->fps_d = 1;
-  gst_video_parse_caps_framerate (caps, &state->fps_n, &state->fps_d);
-  if (state->fps_d == 0) {
-    state->fps_n = 0;
-    state->fps_d = 1;
-  }
+  changed = (tmp_state.format != state->format
+      || tmp_state.width != state->width || tmp_state.height != state->height);
 
-  state->par_n = 1;
-  state->par_d = 1;
-  gst_video_parse_caps_pixel_aspect_ratio (caps, &state->par_n, &state->par_d);
+  if (!gst_video_parse_caps_framerate (caps, &tmp_state.fps_n,
+          &tmp_state.fps_d)) {
+    tmp_state.fps_n = 0;
+    tmp_state.fps_d = 1;
+  }
+  changed = changed || (tmp_state.fps_n != state->fps_n
+      || tmp_state.fps_d != state->fps_d);
 
-  state->have_interlaced = gst_structure_get_boolean (structure,
-      "interlaced", &state->interlaced);
+  if (!gst_video_parse_caps_pixel_aspect_ratio (caps, &tmp_state.par_n,
+          &tmp_state.par_d)) {
+    tmp_state.par_n = 1;
+    tmp_state.par_d = 1;
+  }
+  changed = changed || (tmp_state.par_n != state->par_n
+      || tmp_state.par_d != state->par_d);
+
+  tmp_state.have_interlaced =
+      gst_structure_get_boolean (structure, "interlaced",
+      &tmp_state.interlaced);
+  changed = changed || (tmp_state.have_interlaced != state->have_interlaced
+      || tmp_state.interlaced != state->interlaced);
+
+  tmp_state.bytes_per_picture =
+      gst_video_format_get_size (tmp_state.format, tmp_state.width,
+      tmp_state.height);
+  tmp_state.clean_width = tmp_state.width;
+  tmp_state.clean_height = tmp_state.height;
+  tmp_state.clean_offset_left = 0;
+  tmp_state.clean_offset_top = 0;
+
+  if (changed) {
+    /* arrange draining pending frames */
+    gst_base_video_encoder_drain (base_video_encoder);
+
+    /* and subclass should be ready to configure format at any time around */
+    if (base_video_encoder_class->set_format)
+      ret =
+          base_video_encoder_class->set_format (base_video_encoder, &tmp_state);
+    if (ret) {
+      gst_caps_replace (&state->caps, NULL);
+      *state = tmp_state;
+    }
+  } else {
+    /* no need to stir things up */
+    GST_DEBUG_OBJECT (base_video_encoder,
+        "new video format identical to configured format");
+    gst_caps_unref (tmp_state.caps);
+    ret = TRUE;
+  }
 
-  state->clean_width = state->width;
-  state->clean_height = state->height;
-  state->clean_offset_left = 0;
-  state->clean_offset_top = 0;
+exit:
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
 
-  ret = base_video_encoder_class->set_format (base_video_encoder,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->state);
-  if (ret) {
-    ret = base_video_encoder_class->start (base_video_encoder);
+  if (!ret) {
+    GST_WARNING_OBJECT (base_video_encoder, "rejected caps %" GST_PTR_FORMAT,
+        caps);
   }
 
   g_object_unref (base_video_encoder);
@@ -148,6 +367,75 @@ gst_base_video_encoder_sink_setcaps (GstPad * pad, GstCaps * caps)
   return ret;
 }
 
+static GstCaps *
+gst_base_video_encoder_sink_getcaps (GstPad * pad)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  const GstCaps *templ_caps;
+  GstCaps *allowed;
+  GstCaps *fcaps, *filter_caps;
+  gint i, j;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+
+  /* FIXME: Allow subclass to override this? */
+
+  /* Allow downstream to specify width/height/framerate/PAR constraints
+   * and forward them upstream for video converters to handle
+   */
+  templ_caps =
+      gst_pad_get_pad_template_caps (GST_BASE_VIDEO_CODEC_SINK_PAD
+      (base_video_encoder));
+  allowed =
+      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+      (base_video_encoder));
+  if (!allowed || gst_caps_is_empty (allowed) || gst_caps_is_any (allowed)) {
+    fcaps = gst_caps_copy (templ_caps);
+    goto done;
+  }
+
+  GST_LOG_OBJECT (base_video_encoder, "template caps %" GST_PTR_FORMAT,
+      templ_caps);
+  GST_LOG_OBJECT (base_video_encoder, "allowed caps %" GST_PTR_FORMAT, allowed);
+
+  filter_caps = gst_caps_new_empty ();
+
+  for (i = 0; i < gst_caps_get_size (templ_caps); i++) {
+    GQuark q_name =
+        gst_structure_get_name_id (gst_caps_get_structure (templ_caps, i));
+
+    for (j = 0; j < gst_caps_get_size (allowed); j++) {
+      const GstStructure *allowed_s = gst_caps_get_structure (allowed, j);
+      const GValue *val;
+      GstStructure *s;
+
+      s = gst_structure_id_empty_new (q_name);
+      if ((val = gst_structure_get_value (allowed_s, "width")))
+        gst_structure_set_value (s, "width", val);
+      if ((val = gst_structure_get_value (allowed_s, "height")))
+        gst_structure_set_value (s, "height", val);
+      if ((val = gst_structure_get_value (allowed_s, "framerate")))
+        gst_structure_set_value (s, "framerate", val);
+      if ((val = gst_structure_get_value (allowed_s, "pixel-aspect-ratio")))
+        gst_structure_set_value (s, "pixel-aspect-ratio", val);
+
+      gst_caps_merge_structure (filter_caps, s);
+    }
+  }
+
+  fcaps = gst_caps_intersect (filter_caps, templ_caps);
+  gst_caps_unref (filter_caps);
+
+done:
+
+  gst_caps_replace (&allowed, NULL);
+
+  GST_LOG_OBJECT (base_video_encoder, "Returning caps %" GST_PTR_FORMAT, fcaps);
+
+  g_object_unref (base_video_encoder);
+  return fcaps;
+}
+
 static void
 gst_base_video_encoder_finalize (GObject * object)
 {
@@ -157,29 +445,33 @@ gst_base_video_encoder_finalize (GObject * object)
 }
 
 static gboolean
-gst_base_video_encoder_sink_event (GstPad * pad, GstEvent * event)
+gst_base_video_encoder_sink_eventfunc (GstBaseVideoEncoder * base_video_encoder,
+    GstEvent * event)
 {
-  GstBaseVideoEncoder *base_video_encoder;
   GstBaseVideoEncoderClass *base_video_encoder_class;
   gboolean ret = FALSE;
 
-  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
   base_video_encoder_class =
       GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_EOS:
     {
+      GstFlowReturn flow_ret;
+
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
       base_video_encoder->a.at_eos = TRUE;
+
       if (base_video_encoder_class->finish) {
-        base_video_encoder_class->finish (base_video_encoder);
+        flow_ret = base_video_encoder_class->finish (base_video_encoder);
+      } else {
+        flow_ret = GST_FLOW_OK;
       }
 
-      ret =
-          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
-          event);
-    }
+      ret = (flow_ret == GST_BASE_VIDEO_ENCODER_FLOW_DROPPED);
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
       break;
+    }
     case GST_EVENT_NEWSEGMENT:
     {
       gboolean update;
@@ -190,25 +482,30 @@ gst_base_video_encoder_sink_event (GstPad * pad, GstEvent * event)
       gint64 stop;
       gint64 position;
 
-      gst_event_parse_new_segment_full (event, &update, &rate,
-          &applied_rate, &format, &start, &stop, &position);
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
+      gst_event_parse_new_segment_full (event, &update, &rate, &applied_rate,
+          &format, &start, &stop, &position);
 
-      if (format != GST_FORMAT_TIME)
-        goto newseg_wrong_format;
+      GST_DEBUG_OBJECT (base_video_encoder, "newseg rate %g, applied rate %g, "
+          "format %d, start = %" GST_TIME_FORMAT ", stop = %" GST_TIME_FORMAT
+          ", pos = %" GST_TIME_FORMAT, rate, applied_rate, format,
+          GST_TIME_ARGS (start), GST_TIME_ARGS (stop),
+          GST_TIME_ARGS (position));
 
-      GST_DEBUG ("new segment %" GST_TIME_FORMAT " %" GST_TIME_FORMAT,
-          GST_TIME_ARGS (start), GST_TIME_ARGS (position));
+      if (format != GST_FORMAT_TIME) {
+        GST_DEBUG_OBJECT (base_video_encoder, "received non TIME newsegment");
+        GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
+        break;
+      }
 
       base_video_encoder->a.at_eos = FALSE;
+
       gst_segment_set_newsegment_full (&GST_BASE_VIDEO_CODEC
           (base_video_encoder)->segment, update, rate, applied_rate, format,
           start, stop, position);
-
-      ret =
-          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
-          event);
-    }
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
       break;
+    }
     case GST_EVENT_CUSTOM_DOWNSTREAM:
     {
       const GstStructure *s;
@@ -218,34 +515,70 @@ gst_base_video_encoder_sink_event (GstPad * pad, GstEvent * event)
       if (gst_structure_has_name (s, "GstForceKeyUnit")) {
         GST_OBJECT_LOCK (base_video_encoder);
         base_video_encoder->force_keyframe = TRUE;
+        if (base_video_encoder->force_keyunit_event)
+          gst_event_unref (base_video_encoder->force_keyunit_event);
+        base_video_encoder->force_keyunit_event = gst_event_copy (event);
         GST_OBJECT_UNLOCK (base_video_encoder);
         gst_event_unref (event);
-        ret = GST_FLOW_OK;
-      } else {
-        ret =
-            gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD
-            (base_video_encoder), event);
+        ret = TRUE;
       }
       break;
     }
     default:
-      /* FIXME this changes the order of events */
-      ret =
-          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
-          event);
       break;
   }
 
-done:
-  gst_object_unref (base_video_encoder);
   return ret;
+}
 
-newseg_wrong_format:
-  {
-    GST_DEBUG_OBJECT (base_video_encoder, "received non TIME newsegment");
-    gst_event_unref (event);
-    goto done;
+static gboolean
+gst_base_video_encoder_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoEncoder *enc;
+  GstBaseVideoEncoderClass *klass;
+  gboolean handled = FALSE;
+  gboolean ret = TRUE;
+
+  enc = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  klass = GST_BASE_VIDEO_ENCODER_GET_CLASS (enc);
+
+  GST_DEBUG_OBJECT (enc, "received event %d, %s", GST_EVENT_TYPE (event),
+      GST_EVENT_TYPE_NAME (event));
+
+  if (klass->event)
+    handled = klass->event (enc, event);
+
+  if (!handled)
+    handled = gst_base_video_encoder_sink_eventfunc (enc, event);
+
+  if (!handled) {
+    /* Forward non-serialized events and EOS/FLUSH_STOP immediately.
+     * For EOS this is required because no buffer or serialized event
+     * will come after EOS and nothing could trigger another
+     * _finish_frame() call.   *
+     * If the subclass handles sending of EOS manually it can return
+     * _DROPPED from ::finish() and all other subclasses should have
+     * decoded/flushed all remaining data before this
+     *
+     * For FLUSH_STOP this is required because it is expected
+     * to be forwarded immediately and no buffers are queued anyway.
+     */
+    if (!GST_EVENT_IS_SERIALIZED (event)
+        || GST_EVENT_TYPE (event) == GST_EVENT_EOS
+        || GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_STOP) {
+      ret = gst_pad_push_event (enc->base_video_codec.srcpad, event);
+    } else {
+      GST_BASE_VIDEO_CODEC_STREAM_LOCK (enc);
+      enc->current_frame_events =
+          g_list_prepend (enc->current_frame_events, event);
+      GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (enc);
+    }
   }
+
+  GST_DEBUG_OBJECT (enc, "event handled");
+
+  gst_object_unref (enc);
+  return ret;
 }
 
 static gboolean
@@ -256,6 +589,9 @@ gst_base_video_encoder_src_event (GstPad * pad, GstEvent * event)
 
   base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
 
+  GST_LOG_OBJECT (base_video_encoder, "handling event: %" GST_PTR_FORMAT,
+      event);
+
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_CUSTOM_UPSTREAM:
     {
@@ -292,8 +628,6 @@ static const GstQueryType *
 gst_base_video_encoder_get_query_types (GstPad * pad)
 {
   static const GstQueryType query_types[] = {
-    //GST_QUERY_POSITION,
-    //GST_QUERY_DURATION,
     GST_QUERY_CONVERT,
     GST_QUERY_LATENCY,
     0
@@ -312,17 +646,18 @@ gst_base_video_encoder_src_query (GstPad * pad, GstQuery * query)
   enc = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
   peerpad = gst_pad_get_peer (GST_BASE_VIDEO_CODEC_SINK_PAD (enc));
 
-  switch GST_QUERY_TYPE
-    (query) {
+  GST_LOG_OBJECT (enc, "handling query: %" GST_PTR_FORMAT, query);
+
+  switch (GST_QUERY_TYPE (query)) {
     case GST_QUERY_CONVERT:
     {
+      GstBaseVideoCodec *codec = GST_BASE_VIDEO_CODEC (enc);
       GstFormat src_fmt, dest_fmt;
       gint64 src_val, dest_val;
 
       gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
-      res =
-          gst_base_video_encoded_video_convert (&GST_BASE_VIDEO_CODEC
-          (enc)->state, src_fmt, src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&codec->state,
+          codec->bytes, codec->time, src_fmt, src_val, &dest_fmt, &dest_val);
       if (!res)
         goto error;
       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
@@ -336,11 +671,16 @@ gst_base_video_encoder_src_query (GstPad * pad, GstQuery * query)
       res = gst_pad_query (peerpad, query);
       if (res) {
         gst_query_parse_latency (query, &live, &min_latency, &max_latency);
+        GST_DEBUG_OBJECT (enc, "Peer latency: live %d, min %"
+            GST_TIME_FORMAT " max %" GST_TIME_FORMAT, live,
+            GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
 
+        GST_OBJECT_LOCK (enc);
         min_latency += enc->min_latency;
         if (max_latency != GST_CLOCK_TIME_NONE) {
           max_latency += enc->max_latency;
         }
+        GST_OBJECT_UNLOCK (enc);
 
         gst_query_set_latency (query, live, min_latency, max_latency);
       }
@@ -348,7 +688,7 @@ gst_base_video_encoder_src_query (GstPad * pad, GstQuery * query)
       break;
     default:
       res = gst_pad_query_default (pad, query);
-    }
+  }
   gst_object_unref (peerpad);
   gst_object_unref (enc);
   return res;
@@ -360,38 +700,35 @@ error:
   return res;
 }
 
-static gboolean
-gst_pad_is_negotiated (GstPad * pad)
-{
-  GstCaps *caps;
-
-  g_return_val_if_fail (pad != NULL, FALSE);
-
-  caps = gst_pad_get_negotiated_caps (pad);
-  if (caps) {
-    gst_caps_unref (caps);
-    return TRUE;
-  }
-
-  return FALSE;
-}
-
 static GstFlowReturn
 gst_base_video_encoder_chain (GstPad * pad, GstBuffer * buf)
 {
   GstBaseVideoEncoder *base_video_encoder;
   GstBaseVideoEncoderClass *klass;
   GstVideoFrame *frame;
-
-  if (!gst_pad_is_negotiated (pad)) {
-    return GST_FLOW_NOT_NEGOTIATED;
-  }
+  GstFlowReturn ret = GST_FLOW_OK;
 
   base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
   klass = GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
 
+  g_return_val_if_fail (klass->handle_frame != NULL, GST_FLOW_ERROR);
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
+
+  if (!GST_PAD_CAPS (pad)) {
+    ret = GST_FLOW_NOT_NEGOTIATED;
+    goto done;
+  }
+
+  GST_LOG_OBJECT (base_video_encoder,
+      "received buffer of size %d with ts %" GST_TIME_FORMAT
+      ", duration %" GST_TIME_FORMAT, GST_BUFFER_SIZE (buf),
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+      GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
+
   if (base_video_encoder->a.at_eos) {
-    return GST_FLOW_UNEXPECTED;
+    ret = GST_FLOW_UNEXPECTED;
+    goto done;
   }
 
   if (base_video_encoder->sink_clipping) {
@@ -402,30 +739,48 @@ gst_base_video_encoder_chain (GstPad * pad, GstBuffer * buf)
 
     if (!gst_segment_clip (&GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
             GST_FORMAT_TIME, start, stop, &clip_start, &clip_stop)) {
-      GST_DEBUG ("clipping to segment dropped frame");
+      GST_DEBUG_OBJECT (base_video_encoder,
+          "clipping to segment dropped frame");
       goto done;
     }
   }
 
+  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
+    GST_LOG_OBJECT (base_video_encoder, "marked discont");
+    GST_BASE_VIDEO_CODEC (base_video_encoder)->discont = TRUE;
+  }
+
   frame =
       gst_base_video_codec_new_frame (GST_BASE_VIDEO_CODEC
       (base_video_encoder));
+  frame->events = base_video_encoder->current_frame_events;
+  base_video_encoder->current_frame_events = NULL;
   frame->sink_buffer = buf;
   frame->presentation_timestamp = GST_BUFFER_TIMESTAMP (buf);
   frame->presentation_duration = GST_BUFFER_DURATION (buf);
   frame->presentation_frame_number =
       base_video_encoder->presentation_frame_number;
   base_video_encoder->presentation_frame_number++;
+  frame->force_keyframe = base_video_encoder->force_keyframe;
+  base_video_encoder->force_keyframe = FALSE;
 
   GST_BASE_VIDEO_CODEC (base_video_encoder)->frames =
       g_list_append (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames, frame);
 
-  klass->handle_frame (base_video_encoder, frame);
+  /* new data, more finish needed */
+  base_video_encoder->drained = FALSE;
+
+  GST_LOG_OBJECT (base_video_encoder, "passing frame pfn %d to subclass",
+      frame->presentation_frame_number);
+
+  ret = klass->handle_frame (base_video_encoder, frame);
 
 done:
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
+
   g_object_unref (base_video_encoder);
 
-  return GST_FLOW_OK;
+  return ret;
 }
 
 static GstStateChangeReturn
@@ -440,6 +795,13 @@ gst_base_video_encoder_change_state (GstElement * element,
   base_video_encoder_class = GST_BASE_VIDEO_ENCODER_GET_CLASS (element);
 
   switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_base_video_encoder_reset (base_video_encoder);
+      gst_base_video_encoder_reset (base_video_encoder);
+      if (base_video_encoder_class->start) {
+        base_video_encoder_class->start (base_video_encoder);
+      }
+      break;
     default:
       break;
   }
@@ -448,6 +810,7 @@ gst_base_video_encoder_change_state (GstElement * element,
 
   switch (transition) {
     case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_base_video_encoder_reset (base_video_encoder);
       if (base_video_encoder_class->stop) {
         base_video_encoder_class->stop (base_video_encoder);
       }
@@ -459,17 +822,96 @@ gst_base_video_encoder_change_state (GstElement * element,
   return ret;
 }
 
+/**
+ * gst_base_video_encoder_finish_frame:
+ * @base_video_encoder: a #GstBaseVideoEncoder
+ * @frame: an encoded #GstVideoFrame 
+ *
+ * @frame must have a valid encoded data buffer, whose metadata fields
+ * are then appropriately set according to frame data or no buffer at
+ * all if the frame should be dropped.
+ * It is subsequently pushed downstream or provided to @shape_output.
+ * In any case, the frame is considered finished and released.
+ *
+ * Returns: a #GstFlowReturn resulting from sending data downstream
+ */
 GstFlowReturn
 gst_base_video_encoder_finish_frame (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
 {
-  GstFlowReturn ret;
+  GstFlowReturn ret = GST_FLOW_OK;
   GstBaseVideoEncoderClass *base_video_encoder_class;
+  GList *l;
 
   base_video_encoder_class =
       GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
 
+  GST_LOG_OBJECT (base_video_encoder,
+      "finish frame fpn %d", frame->presentation_frame_number);
+
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
+
+  /* Push all pending events that arrived before this frame */
+  for (l = base_video_encoder->base_video_codec.frames; l; l = l->next) {
+    GstVideoFrame *tmp = l->data;
+
+    if (tmp->events) {
+      GList *k;
+
+      for (k = g_list_last (tmp->events); k; k = k->prev)
+        gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+            k->data);
+      g_list_free (tmp->events);
+      tmp->events = NULL;
+    }
+
+    if (tmp == frame)
+      break;
+  }
+
+  if (frame->force_keyframe) {
+    GstClockTime stream_time;
+    GstClockTime running_time;
+    GstEvent *ev;
+
+    running_time =
+        gst_segment_to_running_time (&GST_BASE_VIDEO_CODEC
+        (base_video_encoder)->segment, GST_FORMAT_TIME,
+        frame->presentation_timestamp);
+    stream_time =
+        gst_segment_to_stream_time (&GST_BASE_VIDEO_CODEC
+        (base_video_encoder)->segment, GST_FORMAT_TIME,
+        frame->presentation_timestamp);
+
+    /* re-use upstream event if any so it also conveys any additional
+     * info upstream arranged in there */
+    GST_OBJECT_LOCK (base_video_encoder);
+    if (base_video_encoder->force_keyunit_event) {
+      ev = base_video_encoder->force_keyunit_event;
+      base_video_encoder->force_keyunit_event = NULL;
+    } else {
+      ev = gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM,
+          gst_structure_new ("GstForceKeyUnit", NULL));
+    }
+    GST_OBJECT_UNLOCK (base_video_encoder);
+
+    gst_structure_set (ev->structure,
+        "timestamp", G_TYPE_UINT64, frame->presentation_timestamp,
+        "stream-time", G_TYPE_UINT64, stream_time,
+        "running-time", G_TYPE_UINT64, running_time, NULL);
+
+    gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), ev);
+  }
+
+  /* no buffer data means this frame is skipped/dropped */
+  if (!frame->src_buffer) {
+    GST_DEBUG_OBJECT (base_video_encoder, "skipping frame %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (frame->presentation_timestamp));
+    goto done;
+  }
+
   if (frame->is_sync_point) {
+    GST_LOG_OBJECT (base_video_encoder, "key frame");
     base_video_encoder->distance_from_sync = 0;
     GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
   } else {
@@ -492,49 +934,25 @@ gst_base_video_encoder_finish_frame (GstBaseVideoEncoder * base_video_encoder,
   GST_BUFFER_DURATION (frame->src_buffer) = frame->presentation_duration;
   GST_BUFFER_OFFSET (frame->src_buffer) = frame->decode_timestamp;
 
-  GST_BASE_VIDEO_CODEC (base_video_encoder)->frames =
-      g_list_remove (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames, frame);
+  /* update rate estimate */
+  GST_BASE_VIDEO_CODEC (base_video_encoder)->bytes +=
+      GST_BUFFER_SIZE (frame->src_buffer);
+  if (GST_CLOCK_TIME_IS_VALID (frame->presentation_duration)) {
+    GST_BASE_VIDEO_CODEC (base_video_encoder)->time +=
+        frame->presentation_duration;
+  } else {
+    /* better none than nothing valid */
+    GST_BASE_VIDEO_CODEC (base_video_encoder)->time = GST_CLOCK_TIME_NONE;
+  }
 
-  if (!base_video_encoder->set_output_caps) {
-    if (base_video_encoder_class->get_caps) {
-      GST_BASE_VIDEO_CODEC (base_video_encoder)->caps =
-          base_video_encoder_class->get_caps (base_video_encoder);
-    } else {
-      GST_BASE_VIDEO_CODEC (base_video_encoder)->caps =
-          gst_caps_new_simple ("video/unknown", NULL);
-    }
-    gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
-        GST_BASE_VIDEO_CODEC (base_video_encoder)->caps);
-    base_video_encoder->set_output_caps = TRUE;
+  if (G_UNLIKELY (GST_BASE_VIDEO_CODEC (base_video_encoder)->discont)) {
+    GST_LOG_OBJECT (base_video_encoder, "marking discont");
+    GST_BUFFER_FLAG_SET (frame->src_buffer, GST_BUFFER_FLAG_DISCONT);
+    GST_BASE_VIDEO_CODEC (base_video_encoder)->discont = FALSE;
   }
 
   gst_buffer_set_caps (GST_BUFFER (frame->src_buffer),
-      GST_BASE_VIDEO_CODEC (base_video_encoder)->caps);
-
-  if (frame->force_keyframe) {
-    GstClockTime stream_time;
-    GstClockTime running_time;
-    GstStructure *s;
-
-    running_time =
-        gst_segment_to_running_time (&GST_BASE_VIDEO_CODEC
-        (base_video_encoder)->segment, GST_FORMAT_TIME,
-        frame->presentation_timestamp);
-    stream_time =
-        gst_segment_to_stream_time (&GST_BASE_VIDEO_CODEC
-        (base_video_encoder)->segment, GST_FORMAT_TIME,
-        frame->presentation_timestamp);
-
-    /* FIXME this should send the event that we got on the sink pad
-       instead of creating a new one */
-    s = gst_structure_new ("GstForceKeyUnit",
-        "timestamp", G_TYPE_UINT64, frame->presentation_timestamp,
-        "stream-time", G_TYPE_UINT64, stream_time,
-        "running-time", G_TYPE_UINT64, running_time, NULL);
-
-    gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
-        gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM, s));
-  }
+      GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
 
   if (base_video_encoder_class->shape_output) {
     ret = base_video_encoder_class->shape_output (base_video_encoder, frame);
@@ -543,43 +961,40 @@ gst_base_video_encoder_finish_frame (GstBaseVideoEncoder * base_video_encoder,
         gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
         frame->src_buffer);
   }
+  frame->src_buffer = NULL;
+
+done:
+  /* handed out */
+  GST_BASE_VIDEO_CODEC (base_video_encoder)->frames =
+      g_list_remove (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames, frame);
 
   gst_base_video_codec_free_frame (frame);
 
-  return ret;
-}
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
 
-int
-gst_base_video_encoder_get_height (GstBaseVideoEncoder * base_video_encoder)
-{
-  return GST_BASE_VIDEO_CODEC (base_video_encoder)->state.height;
-}
-
-int
-gst_base_video_encoder_get_width (GstBaseVideoEncoder * base_video_encoder)
-{
-  return GST_BASE_VIDEO_CODEC (base_video_encoder)->state.width;
+  return ret;
 }
 
+/**
+ * gst_base_video_encoder_get_state:
+ * @base_video_encoder: a #GstBaseVideoEncoder
+ *
+ * Returns: #GstVideoState describing format of video data.
+ */
 const GstVideoState *
 gst_base_video_encoder_get_state (GstBaseVideoEncoder * base_video_encoder)
 {
   return &GST_BASE_VIDEO_CODEC (base_video_encoder)->state;
 }
 
-GstFlowReturn
-gst_base_video_encoder_end_of_stream (GstBaseVideoEncoder * base_video_encoder,
-    GstBuffer * buffer)
-{
-
-  if (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames) {
-    GST_WARNING ("EOS with frames left over");
-  }
-
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
-      buffer);
-}
-
+/**
+ * gst_base_video_encoder_set_latency:
+ * @base_video_encoder: a #GstBaseVideoEncoder
+ * @min_latency: minimum latency
+ * @max_latency: maximum latency
+ *
+ * Informs baseclass of encoding latency.
+ */
 void
 gst_base_video_encoder_set_latency (GstBaseVideoEncoder * base_video_encoder,
     GstClockTime min_latency, GstClockTime max_latency)
@@ -587,19 +1002,33 @@ gst_base_video_encoder_set_latency (GstBaseVideoEncoder * base_video_encoder,
   g_return_if_fail (min_latency >= 0);
   g_return_if_fail (max_latency >= min_latency);
 
+  GST_OBJECT_LOCK (base_video_encoder);
   base_video_encoder->min_latency = min_latency;
   base_video_encoder->max_latency = max_latency;
+  GST_OBJECT_UNLOCK (base_video_encoder);
 
   gst_element_post_message (GST_ELEMENT_CAST (base_video_encoder),
       gst_message_new_latency (GST_OBJECT_CAST (base_video_encoder)));
 }
 
+/**
+ * gst_base_video_encoder_set_latency_fields:
+ * @base_video_encoder: a #GstBaseVideoEncoder
+ * @fields: latency in fields
+ *
+ * Informs baseclass of encoding latency in terms of fields (both min
+ * and max latency).
+ */
 void
 gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *
     base_video_encoder, int n_fields)
 {
   gint64 latency;
 
+  /* 0 numerator is used for "don't know" */
+  if (GST_BASE_VIDEO_CODEC (base_video_encoder)->state.fps_n == 0)
+    return;
+
   latency = gst_util_uint64_scale (n_fields,
       GST_BASE_VIDEO_CODEC (base_video_encoder)->state.fps_d * GST_SECOND,
       2 * GST_BASE_VIDEO_CODEC (base_video_encoder)->state.fps_n);
@@ -608,15 +1037,26 @@ gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *
 
 }
 
+/**
+ * gst_base_video_encoder_get_oldest_frame:
+ * @base_video_encoder: a #GstBaseVideoEncoder
+ *
+ * Returns: oldest unfinished pending #GstVideoFrame
+ */
 GstVideoFrame *
 gst_base_video_encoder_get_oldest_frame (GstBaseVideoEncoder *
     base_video_encoder)
 {
   GList *g;
 
+  GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
   g = g_list_first (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames);
+  GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
 
   if (g == NULL)
     return NULL;
   return (GstVideoFrame *) (g->data);
 }
+
+/* FIXME there could probably be more of these;
+ * get by presentation_number, by presentation_time ? */
diff --git a/gst-libs/gst/video/gstbasevideoencoder.h b/gst-libs/gst/video/gstbasevideoencoder.h
index 228c517..c712fe8 100644
--- a/gst-libs/gst/video/gstbasevideoencoder.h
+++ b/gst-libs/gst/video/gstbasevideoencoder.h
@@ -1,5 +1,8 @@
 /* GStreamer
  * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ * Copyright (C) 2011 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>.
+ * Copyright (C) 2011 Nokia Corporation. All rights reserved.
+ *   Contact: Stefan Kost <stefan.kost@nokia.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -55,72 +58,126 @@ G_BEGIN_DECLS
  */
 #define GST_BASE_VIDEO_ENCODER_SRC_NAME     "src"
 
+/**
+ * GST_BASE_VIDEO_ENCODER_FLOW_DROPPED:
+ *
+ * Returned when the event/buffer should be dropped.
+ */
+#define GST_BASE_VIDEO_ENCODER_FLOW_DROPPED GST_FLOW_CUSTOM_SUCCESS_1
 
 typedef struct _GstBaseVideoEncoder GstBaseVideoEncoder;
 typedef struct _GstBaseVideoEncoderClass GstBaseVideoEncoderClass;
 
+/**
+ * GstBaseVideoEncoder:
+ * @element: the parent element.
+ *
+ * The opaque #GstBaseVideoEncoder data structure.
+ */
 struct _GstBaseVideoEncoder
 {
   GstBaseVideoCodec base_video_codec;
 
-  /*< private >*/
-  gboolean sink_clipping;
+  /*< protected >*/
+  gboolean          sink_clipping;
+
+  guint64           presentation_frame_number;
+  int               distance_from_sync;
+
+  gboolean          force_keyframe;
 
-  guint64 presentation_frame_number;
-  int distance_from_sync;
+  /*< private >*/
+  /* FIXME move to real private part ?
+   * (and introduce a context ?) */
+  gboolean          drained;
 
-  gboolean set_output_caps;
+  gint64            min_latency;
+  gint64            max_latency;
 
-  gint64 min_latency;
-  gint64 max_latency;
+  GstEvent         *force_keyunit_event;
+  GList            *current_frame_events;
 
-  gboolean force_keyframe;
   union {
     void *padding;
     gboolean at_eos;
   } a;
 
   /* FIXME before moving to base */
-  void *padding[GST_PADDING_LARGE-1];
+  void             *padding[GST_PADDING_LARGE-1];
 };
 
+/**
+ * GstBaseVideoEncoderClass:
+ * @start:          Optional.
+ *                  Called when the element starts processing.
+ *                  Allows opening external resources.
+ * @stop:           Optional.
+ *                  Called when the element stops processing.
+ *                  Allows closing external resources.
+ * @set_format:     Optional.
+ *                  Notifies subclass of incoming data format.
+ *                  GstVideoState fields have already been
+ *                  set according to provided caps.
+ * @handle_frame:   Provides input frame to subclass.
+ * @finish:         Optional.
+ *                  Called to request subclass to dispatch any pending remaining
+ *                  data (e.g. at EOS).
+ * @shape_output:   Optional.
+ *                  Allows subclass to push frame downstream in whatever
+ *                  shape or form it deems appropriate.  If not provided,
+ *                  provided encoded frame data is simply pushed downstream.
+ * @event:          Optional.
+ *                  Event handler on the sink pad. This function should return
+ *                  TRUE if the event was handled and should be discarded
+ *                  (i.e. not unref'ed).
+ *
+ * Subclasses can override any of the available virtual methods or not, as
+ * needed. At minimum @handle_frame needs to be overridden, and @set_format
+ * and @get_caps are likely needed as well.
+ */
 struct _GstBaseVideoEncoderClass
 {
-  GstBaseVideoCodecClass base_video_codec_class;
+  GstBaseVideoCodecClass              base_video_codec_class;
 
-  gboolean (*set_format) (GstBaseVideoEncoder *coder, GstVideoState *state);
-  gboolean (*start) (GstBaseVideoEncoder *coder);
-  gboolean (*stop) (GstBaseVideoEncoder *coder);
-  gboolean (*finish) (GstBaseVideoEncoder *coder);
-  gboolean (*handle_frame) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
-  GstFlowReturn (*shape_output) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
-  GstCaps *(*get_caps) (GstBaseVideoEncoder *coder);
+  /*< public >*/
+  /* virtual methods for subclasses */
 
-  /* FIXME before moving to base */
-  void *padding[GST_PADDING_LARGE];
-};
+  gboolean      (*start)              (GstBaseVideoEncoder *coder);
+
+  gboolean      (*stop)               (GstBaseVideoEncoder *coder);
+
+  gboolean      (*set_format)         (GstBaseVideoEncoder *coder,
+                                       GstVideoState *state);
+
+  GstFlowReturn (*handle_frame)       (GstBaseVideoEncoder *coder,
+                                       GstVideoFrame *frame);
 
-GType gst_base_video_encoder_get_type (void);
+  gboolean      (*reset)              (GstBaseVideoEncoder *coder);
+  GstFlowReturn (*finish)             (GstBaseVideoEncoder *coder);
 
-int gst_base_video_encoder_get_width (GstBaseVideoEncoder *coder);
-int gst_base_video_encoder_get_height (GstBaseVideoEncoder *coder);
-const GstVideoState *gst_base_video_encoder_get_state (GstBaseVideoEncoder *coder);
+  GstFlowReturn (*shape_output)       (GstBaseVideoEncoder *coder,
+                                       GstVideoFrame *frame);
+
+  gboolean      (*event)              (GstBaseVideoEncoder *coder,
+                                       GstEvent *event);
+
+  /*< private >*/
+  /* FIXME before moving to base */
+  gpointer       _gst_reserved[GST_PADDING_LARGE];
+};
 
-guint64 gst_base_video_encoder_get_timestamp_offset (GstBaseVideoEncoder *coder);
+GType                  gst_base_video_encoder_get_type (void);
 
-GstVideoFrame *gst_base_video_encoder_get_frame (GstBaseVideoEncoder *coder,
-    int frame_number);
-GstVideoFrame *gst_base_video_encoder_get_oldest_frame (GstBaseVideoEncoder *coder);
-GstFlowReturn gst_base_video_encoder_finish_frame (GstBaseVideoEncoder *base_video_encoder,
-    GstVideoFrame *frame);
-GstFlowReturn gst_base_video_encoder_end_of_stream (GstBaseVideoEncoder *base_video_encoder,
-    GstBuffer *buffer);
+const GstVideoState*   gst_base_video_encoder_get_state (GstBaseVideoEncoder *coder);
 
-void gst_base_video_encoder_set_latency (GstBaseVideoEncoder *base_video_encoder,
-    GstClockTime min_latency, GstClockTime max_latency);
-void gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *base_video_encoder,
-    int n_fields);
+GstVideoFrame*         gst_base_video_encoder_get_oldest_frame (GstBaseVideoEncoder *coder);
+GstFlowReturn          gst_base_video_encoder_finish_frame (GstBaseVideoEncoder *base_video_encoder,
+                                                            GstVideoFrame *frame);
 
+void                   gst_base_video_encoder_set_latency (GstBaseVideoEncoder *base_video_encoder,
+                                                           GstClockTime min_latency, GstClockTime max_latency);
+void                   gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *base_video_encoder,
+                                                                  int n_fields);
 
 G_END_DECLS
 
diff --git a/gst-libs/gst/video/gstbasevideoutils.c b/gst-libs/gst/video/gstbasevideoutils.c
index d706394..507ad07 100644
--- a/gst-libs/gst/video/gstbasevideoutils.c
+++ b/gst-libs/gst/video/gstbasevideoutils.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "gstbasevideocodec.h"
+#include "gstbasevideoutils.h"
 
 #include <string.h>
 
@@ -29,21 +29,6 @@ GST_DEBUG_CATEGORY_EXTERN (basevideocodec_debug);
 #define GST_CAT_DEFAULT basevideocodec_debug
 
 
-#if 0
-guint64
-gst_base_video_convert_bytes_to_frames (GstVideoState * state, guint64 bytes)
-{
-  return gst_util_uint64_scale_int (bytes, 1, state->bytes_per_picture);
-}
-
-guint64
-gst_base_video_convert_frames_to_bytes (GstVideoState * state, guint64 frames)
-{
-  return frames * state->bytes_per_picture;
-}
-#endif
-
-
 gboolean
 gst_base_video_rawvideo_convert (GstVideoState * state,
     GstFormat src_format, gint64 src_value,
@@ -51,7 +36,10 @@ gst_base_video_rawvideo_convert (GstVideoState * state,
 {
   gboolean res = FALSE;
 
-  if (src_format == *dest_format) {
+  g_return_val_if_fail (dest_format != NULL, FALSE);
+  g_return_val_if_fail (dest_value != NULL, FALSE);
+
+  if (src_format == *dest_format || src_value == 0 || src_value == -1) {
     *dest_value = src_value;
     return TRUE;
   }
@@ -81,43 +69,77 @@ gst_base_video_rawvideo_convert (GstVideoState * state,
     *dest_value = gst_util_uint64_scale (src_value, state->fps_n,
         GST_SECOND * state->fps_d);
     res = TRUE;
+  } else if (src_format == GST_FORMAT_TIME &&
+      *dest_format == GST_FORMAT_BYTES && state->fps_d != 0 &&
+      state->bytes_per_picture != 0) {
+    /* convert time to frames */
+    /* FIXME subtract segment time? */
+    *dest_value = gst_util_uint64_scale (src_value,
+        state->fps_n * state->bytes_per_picture, GST_SECOND * state->fps_d);
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_BYTES &&
+      *dest_format == GST_FORMAT_TIME && state->fps_n != 0 &&
+      state->bytes_per_picture != 0) {
+    /* convert frames to time */
+    /* FIXME add segment time? */
+    *dest_value = gst_util_uint64_scale (src_value,
+        GST_SECOND * state->fps_d, state->fps_n * state->bytes_per_picture);
+    res = TRUE;
   }
 
-  /* FIXME add bytes <--> time */
-
   return res;
 }
 
 gboolean
 gst_base_video_encoded_video_convert (GstVideoState * state,
-    GstFormat src_format, gint64 src_value,
-    GstFormat * dest_format, gint64 * dest_value)
+    gint64 bytes, gint64 time, GstFormat src_format,
+    gint64 src_value, GstFormat * dest_format, gint64 * dest_value)
 {
   gboolean res = FALSE;
 
-  if (src_format == *dest_format) {
-    *dest_value = src_value;
+  g_return_val_if_fail (dest_format != NULL, FALSE);
+  g_return_val_if_fail (dest_value != NULL, FALSE);
+
+  if (G_UNLIKELY (src_format == *dest_format || src_value == 0 ||
+          src_value == -1)) {
+    if (dest_value)
+      *dest_value = src_value;
     return TRUE;
   }
 
-  GST_DEBUG ("src convert");
+  if (bytes <= 0 || time <= 0) {
+    GST_DEBUG ("not enough metadata yet to convert");
+    goto exit;
+  }
 
-#if 0
-  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
-    if (dec->fps_d != 0) {
-      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
-          dec->fps_d * GST_SECOND, dec->fps_n);
-      res = TRUE;
-    } else {
+  switch (src_format) {
+    case GST_FORMAT_BYTES:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value, time, bytes);
+          res = TRUE;
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_BYTES:
+          *dest_value = gst_util_uint64_scale (src_value, bytes, time);
+          res = TRUE;
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    default:
+      GST_DEBUG ("unhandled conversion from %d to %d", src_format,
+          *dest_format);
       res = FALSE;
-    }
-  } else {
-    GST_WARNING ("unhandled conversion from %d to %d", src_format,
-        *dest_format);
-    res = FALSE;
   }
-#endif
 
+exit:
   return res;
 }
 
diff --git a/gst-libs/gst/video/gstbasevideoutils.h b/gst-libs/gst/video/gstbasevideoutils.h
new file mode 100644
index 0000000..aeca2d1
--- /dev/null
+++ b/gst-libs/gst/video/gstbasevideoutils.h
@@ -0,0 +1,46 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_UTILS_H_
+#define _GST_BASE_VIDEO_UTILS_H_
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "GstBaseVideoCodec is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include "gstbasevideocodec.h"
+
+G_BEGIN_DECLS
+
+gboolean gst_base_video_rawvideo_convert (GstVideoState *state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 *dest_value);
+gboolean gst_base_video_encoded_video_convert (GstVideoState * state,
+    gint64 bytes, gint64 time, GstFormat src_format,
+    gint64 src_value, GstFormat * dest_format, gint64 * dest_value);
+
+GstClockTime gst_video_state_get_timestamp (const GstVideoState *state,
+    GstSegment *segment, int frame_number);
+
+G_END_DECLS
+
+#endif
-- 
1.7.5.4

