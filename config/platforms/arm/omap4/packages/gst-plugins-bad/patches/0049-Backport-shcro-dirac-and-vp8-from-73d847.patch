From 24cac90e78fc3704443f2b6886d2eea333bc6d4c Mon Sep 17 00:00:00 2001
From: Alessandro Decina <alessandro.decina@collabora.co.uk>
Date: Tue, 18 Oct 2011 15:42:03 +0200
Subject: [PATCH 049/119] Backport shcro, dirac and vp8 from 73d847

...so they build after the basevideo* backport
---
 ext/dirac/gstdiracenc.cc       |  264 +++-----------
 ext/schroedinger/gstschrodec.c |   60 +---
 ext/schroedinger/gstschroenc.c |  343 +++--------------
 ext/vp8/gstvp8dec.c            |   58 ++--
 ext/vp8/gstvp8enc.c            |  812 +++++++++++++++++++++++++---------------
 ext/vp8/gstvp8enc.h            |   20 +-
 6 files changed, 679 insertions(+), 878 deletions(-)

diff --git a/ext/dirac/gstdiracenc.cc b/ext/dirac/gstdiracenc.cc
index 6e3129a..eb19d78 100644
--- a/ext/dirac/gstdiracenc.cc
+++ b/ext/dirac/gstdiracenc.cc
@@ -24,6 +24,7 @@
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <gst/video/gstbasevideoencoder.h>
+#include <gst/video/gstbasevideoutils.h>
 #include <string.h>
 #include <libdirac_encoder/dirac_encoder.h>
 #include <math.h>
@@ -45,15 +46,6 @@ GST_DEBUG_CATEGORY_EXTERN (dirac_debug);
 typedef struct _GstDiracEnc GstDiracEnc;
 typedef struct _GstDiracEncClass GstDiracEncClass;
 
-typedef enum
-{
-  GST_DIRAC_ENC_OUTPUT_OGG,
-  GST_DIRAC_ENC_OUTPUT_QUICKTIME,
-  GST_DIRAC_ENC_OUTPUT_AVI,
-  GST_DIRAC_ENC_OUTPUT_MPEG_TS,
-  GST_DIRAC_ENC_OUTPUT_MP4
-} GstDiracEncOutputType;
-
 struct _GstDiracEnc
 {
   GstBaseVideoEncoder base_encoder;
@@ -90,7 +82,6 @@ struct _GstDiracEnc
   dirac_encoder_t *encoder;
   dirac_sourceparams_t *src_params;
   GstBuffer *seq_header_buffer;
-  GstDiracEncOutputType output_format;
   guint64 last_granulepos;
   guint64 granule_offset;
 
@@ -149,13 +140,11 @@ static gboolean gst_dirac_enc_set_format (GstBaseVideoEncoder *
     base_video_encoder, GstVideoState * state);
 static gboolean gst_dirac_enc_start (GstBaseVideoEncoder * base_video_encoder);
 static gboolean gst_dirac_enc_stop (GstBaseVideoEncoder * base_video_encoder);
-static gboolean gst_dirac_enc_finish (GstBaseVideoEncoder * base_video_encoder);
-static gboolean gst_dirac_enc_handle_frame (GstBaseVideoEncoder *
+static GstFlowReturn gst_dirac_enc_finish (GstBaseVideoEncoder * base_video_encoder);
+static GstFlowReturn gst_dirac_enc_handle_frame (GstBaseVideoEncoder *
     base_video_encoder, GstVideoFrame * frame);
 static GstFlowReturn gst_dirac_enc_shape_output (GstBaseVideoEncoder *
     base_video_encoder, GstVideoFrame * frame);
-static GstCaps *gst_dirac_enc_get_caps (GstBaseVideoEncoder *
-    base_video_encoder);
 static void gst_dirac_enc_create_codec_data (GstDiracEnc * dirac_enc,
     GstBuffer * seq_header);
 
@@ -223,13 +212,11 @@ static void
 gst_dirac_enc_class_init (GstDiracEncClass * klass)
 {
   GObjectClass *gobject_class;
-  GstElementClass *gstelement_class;
   GstBaseVideoEncoderClass *basevideoencoder_class;
 
   //int i;
 
   gobject_class = G_OBJECT_CLASS (klass);
-  gstelement_class = GST_ELEMENT_CLASS (klass);
   basevideoencoder_class = GST_BASE_VIDEO_ENCODER_CLASS (klass);
 
   gobject_class->set_property = gst_dirac_enc_set_property;
@@ -325,7 +312,6 @@ gst_dirac_enc_class_init (GstDiracEncClass * klass)
       GST_DEBUG_FUNCPTR (gst_dirac_enc_handle_frame);
   basevideoencoder_class->shape_output =
       GST_DEBUG_FUNCPTR (gst_dirac_enc_shape_output);
-  basevideoencoder_class->get_caps = GST_DEBUG_FUNCPTR (gst_dirac_enc_get_caps);
 }
 
 static void
@@ -342,41 +328,10 @@ gst_dirac_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
 {
   GstDiracEnc *dirac_enc = GST_DIRAC_ENC (base_video_encoder);
   GstCaps *caps;
-  GstStructure *structure;
+  gboolean ret;
 
   GST_DEBUG ("set_format");
 
-  caps =
-      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
-      (base_video_encoder));
-
-  if (caps == NULL) {
-    caps =
-        gst_caps_copy (gst_pad_get_pad_template_caps
-        (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
-  }
-
-  if (gst_caps_is_empty (caps)) {
-    gst_caps_unref (caps);
-    return FALSE;
-  }
-
-  structure = gst_caps_get_structure (caps, 0);
-
-  if (gst_structure_has_name (structure, "video/x-dirac")) {
-    dirac_enc->output_format = GST_DIRAC_ENC_OUTPUT_OGG;
-  } else if (gst_structure_has_name (structure, "video/x-qt-part")) {
-    dirac_enc->output_format = GST_DIRAC_ENC_OUTPUT_QUICKTIME;
-  } else if (gst_structure_has_name (structure, "video/x-avi-part")) {
-    dirac_enc->output_format = GST_DIRAC_ENC_OUTPUT_AVI;
-  } else if (gst_structure_has_name (structure, "video/x-mp4-part")) {
-    dirac_enc->output_format = GST_DIRAC_ENC_OUTPUT_MP4;
-  } else {
-    return FALSE;
-  }
-
-  gst_caps_unref (caps);
-
   gst_base_video_encoder_set_latency_fields (base_video_encoder, 2 * 2);
 
   switch (state->format) {
@@ -421,7 +376,22 @@ gst_dirac_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
   dirac_enc->enc_ctx.decode_flag = 0;
   dirac_enc->enc_ctx.instr_flag = 0;
 
-  return TRUE;
+  dirac_enc->granule_offset = ~0;
+
+  dirac_enc->encoder = dirac_encoder_init (&dirac_enc->enc_ctx, FALSE);
+
+  caps = gst_caps_new_simple ("video/x-dirac",
+      "width", G_TYPE_INT, state->width,
+      "height", G_TYPE_INT, state->height,
+      "framerate", GST_TYPE_FRACTION, state->fps_n,
+      state->fps_d,
+      "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+      state->par_d, NULL);
+
+  ret = gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (dirac_enc), caps);
+  gst_caps_unref (caps);
+
+  return ret;
 }
 
 static void
@@ -821,12 +791,6 @@ error:
 static gboolean
 gst_dirac_enc_start (GstBaseVideoEncoder * base_video_encoder)
 {
-  GstDiracEnc *dirac_enc = GST_DIRAC_ENC (base_video_encoder);
-
-  dirac_enc->granule_offset = ~0;
-
-  dirac_enc->encoder = dirac_encoder_init (&dirac_enc->enc_ctx, FALSE);
-
   return TRUE;
 }
 
@@ -845,7 +809,7 @@ gst_dirac_enc_stop (GstBaseVideoEncoder * base_video_encoder)
   return TRUE;
 }
 
-static gboolean
+static GstFlowReturn
 gst_dirac_enc_finish (GstBaseVideoEncoder * base_video_encoder)
 {
   GstDiracEnc *dirac_enc = GST_DIRAC_ENC (base_video_encoder);
@@ -854,15 +818,15 @@ gst_dirac_enc_finish (GstBaseVideoEncoder * base_video_encoder)
 
   gst_dirac_enc_process (dirac_enc, TRUE);
 
-  return TRUE;
+  return GST_FLOW_OK;
 }
 
-static gboolean
+static GstFlowReturn
 gst_dirac_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
 {
   GstDiracEnc *dirac_enc = GST_DIRAC_ENC (base_video_encoder);
-  gboolean ret;
+  GstFlowReturn ret;
   int r;
   const GstVideoState *state;
   uint8_t *data;
@@ -965,7 +929,7 @@ gst_dirac_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
   }
   if (r != (int) GST_BUFFER_SIZE (frame->sink_buffer)) {
     GST_ERROR ("failed to push picture");
-    return FALSE;
+    return GST_FLOW_ERROR;
   }
 
   GST_DEBUG ("handle frame");
@@ -978,7 +942,7 @@ gst_dirac_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
 
   ret = gst_dirac_enc_process (dirac_enc, FALSE);
 
-  return (ret == GST_FLOW_OK);
+  return ret;
 }
 
 #if 0
@@ -1137,8 +1101,7 @@ static GstFlowReturn
 gst_dirac_enc_process (GstDiracEnc * dirac_enc, gboolean end_sequence)
 {
   GstBuffer *outbuf;
-  GstFlowReturn ret;
-  int presentation_frame;
+  GstFlowReturn ret = GST_FLOW_OK;
   int parse_code;
   int state;
   GstVideoFrame *frame;
@@ -1194,15 +1157,34 @@ gst_dirac_enc_process (GstDiracEnc * dirac_enc, gboolean end_sequence)
         dirac_enc->pull_frame_num++;
 
         parse_code = ((guint8 *) GST_BUFFER_DATA (outbuf))[4];
-        /* FIXME */
-        presentation_frame = 0;
 
         if (DIRAC_PARSE_CODE_IS_SEQ_HEADER (parse_code)) {
           frame->is_sync_point = TRUE;
         }
 
         if (!dirac_enc->codec_data) {
+          GstCaps *caps;
+          const GstVideoState *state = gst_base_video_encoder_get_state (GST_BASE_VIDEO_ENCODER (dirac_enc));
+
           gst_dirac_enc_create_codec_data (dirac_enc, outbuf);
+          
+          caps = gst_caps_new_simple ("video/x-dirac",
+              "width", G_TYPE_INT, state->width,
+              "height", G_TYPE_INT, state->height,
+              "framerate", GST_TYPE_FRACTION, state->fps_n,
+              state->fps_d,
+              "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+              state->par_d, "streamheader", GST_TYPE_BUFFER, dirac_enc->codec_data,
+              NULL);
+          if (!gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (dirac_enc), caps))
+            ret = GST_FLOW_NOT_NEGOTIATED;
+          gst_caps_unref (caps);
+
+          if (ret != GST_FLOW_OK) {
+            GST_ERROR ("Failed to set srcpad caps");
+            gst_buffer_unref (outbuf);
+            return ret;
+          }
         }
 
         frame->src_buffer = outbuf;
@@ -1232,7 +1214,6 @@ gst_dirac_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
 {
   GstDiracEnc *dirac_enc;
-  int dpn;
   int delay;
   int dist;
   int pt;
@@ -1243,8 +1224,6 @@ gst_dirac_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
 
   dirac_enc = GST_DIRAC_ENC (base_video_encoder);
 
-  dpn = frame->decode_frame_number;
-
   pt = frame->presentation_frame_number * 2 + dirac_enc->granule_offset;
   dt = frame->decode_frame_number * 2 + dirac_enc->granule_offset;
   delay = pt - dt;
@@ -1266,74 +1245,8 @@ gst_dirac_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
     GST_BUFFER_OFFSET_END (buf) = dirac_enc->last_granulepos;
   }
 
-  gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC(base_video_encoder)->caps);
-
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
-}
-
-static GstFlowReturn
-gst_dirac_enc_shape_output_quicktime (GstBaseVideoEncoder * base_video_encoder,
-    GstVideoFrame * frame)
-{
-  GstBuffer *buf = frame->src_buffer;
-  const GstVideoState *state;
-
-  state = gst_base_video_encoder_get_state (base_video_encoder);
-
-  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment, frame->presentation_frame_number);
-  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment,
-      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
-  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment,
-      frame->system_frame_number);
-  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
-
-  if (frame->is_sync_point &&
-      frame->presentation_frame_number == frame->system_frame_number) {
-    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  } else {
-    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  }
-
-  gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC(base_video_encoder)->caps);
-
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
-}
-
-static GstFlowReturn
-gst_dirac_enc_shape_output_mp4 (GstBaseVideoEncoder * base_video_encoder,
-    GstVideoFrame * frame)
-{
-  GstBuffer *buf = frame->src_buffer;
-  const GstVideoState *state;
-
-  state = gst_base_video_encoder_get_state (base_video_encoder);
-
-  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment,
-      frame->presentation_frame_number);
-  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment,
-      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
-  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment,
-      frame->decode_frame_number);
-  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
-
-  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC(base_video_encoder)->segment,
-      frame->system_frame_number);
-
-  if (frame->is_sync_point &&
-      frame->presentation_frame_number == frame->system_frame_number) {
-    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  } else {
-    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  }
-
-  gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC(base_video_encoder)->caps);
+  gst_buffer_set_caps (buf,
+      GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
 
   return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
 }
@@ -1342,21 +1255,7 @@ static GstFlowReturn
 gst_dirac_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
 {
-  GstDiracEnc *dirac_enc;
-
-  dirac_enc = GST_DIRAC_ENC (base_video_encoder);
-
-  switch (dirac_enc->output_format) {
-    case GST_DIRAC_ENC_OUTPUT_OGG:
-      return gst_dirac_enc_shape_output_ogg (base_video_encoder, frame);
-    case GST_DIRAC_ENC_OUTPUT_QUICKTIME:
-      return gst_dirac_enc_shape_output_quicktime (base_video_encoder, frame);
-    case GST_DIRAC_ENC_OUTPUT_MP4:
-      return gst_dirac_enc_shape_output_mp4 (base_video_encoder, frame);
-    default:
-      g_assert_not_reached ();
-      break;
-  }
+  gst_dirac_enc_shape_output_ogg (base_video_encoder, frame);
 
   return GST_FLOW_ERROR;
 }
@@ -1393,65 +1292,4 @@ gst_dirac_enc_create_codec_data (GstDiracEnc * dirac_enc,
   dirac_enc->codec_data = buf;
 }
 
-static GstCaps *
-gst_dirac_enc_get_caps (GstBaseVideoEncoder * base_video_encoder)
-{
-  GstCaps *caps;
-  const GstVideoState *state;
-  GstDiracEnc *dirac_enc;
-
-  dirac_enc = GST_DIRAC_ENC (base_video_encoder);
 
-  state = gst_base_video_encoder_get_state (base_video_encoder);
-
-  if (dirac_enc->output_format == GST_DIRAC_ENC_OUTPUT_OGG) {
-    caps = gst_caps_new_simple ("video/x-dirac",
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d,
-        "streamheader", GST_TYPE_BUFFER, dirac_enc->codec_data, NULL);
-  } else if (dirac_enc->output_format == GST_DIRAC_ENC_OUTPUT_QUICKTIME) {
-    caps = gst_caps_new_simple ("video/x-qt-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else if (dirac_enc->output_format == GST_DIRAC_ENC_OUTPUT_AVI) {
-    caps = gst_caps_new_simple ("video/x-avi-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else if (dirac_enc->output_format == GST_DIRAC_ENC_OUTPUT_MPEG_TS) {
-    caps = gst_caps_new_simple ("video/x-mpegts-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else if (dirac_enc->output_format == GST_DIRAC_ENC_OUTPUT_MP4) {
-    caps = gst_caps_new_simple ("video/x-mp4-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else {
-    g_assert_not_reached ();
-  }
-
-  return caps;
-}
diff --git a/ext/schroedinger/gstschrodec.c b/ext/schroedinger/gstschrodec.c
index 7917226..126ef1f 100644
--- a/ext/schroedinger/gstschrodec.c
+++ b/ext/schroedinger/gstschrodec.c
@@ -78,10 +78,6 @@ enum
 };
 
 static void gst_schro_dec_finalize (GObject * object);
-static void gst_schro_dec_set_property (GObject * object, guint prop_id,
-    const GValue * value, GParamSpec * pspec);
-static void gst_schro_dec_get_property (GObject * object, guint prop_id,
-    GValue * value, GParamSpec * pspec);
 
 static gboolean gst_schro_dec_sink_query (GstPad * pad, GstQuery * query);
 
@@ -137,8 +133,6 @@ gst_schro_dec_class_init (GstSchroDecClass * klass)
   gobject_class = G_OBJECT_CLASS (klass);
   base_video_decoder_class = GST_BASE_VIDEO_DECODER_CLASS (klass);
 
-  gobject_class->set_property = gst_schro_dec_set_property;
-  gobject_class->get_property = gst_schro_dec_get_property;
   gobject_class->finalize = gst_schro_dec_finalize;
 
   base_video_decoder_class->start = GST_DEBUG_FUNCPTR (gst_schro_dec_start);
@@ -172,21 +166,16 @@ static gint64
 granulepos_to_frame (gint64 granulepos)
 {
   guint64 pt;
-  int dist_h;
-  int dist_l;
-  int dist;
-  int delay;
-  guint64 dt;
 
   if (granulepos == -1)
     return -1;
 
   pt = ((granulepos >> 22) + (granulepos & OGG_DIRAC_GRANULE_LOW_MASK)) >> 9;
-  dist_h = (granulepos >> 22) & 0xff;
-  dist_l = granulepos & 0xff;
-  dist = (dist_h << 8) | dist_l;
-  delay = (granulepos >> 9) & 0x1fff;
-  dt = pt - delay;
+  /* dist_h = (granulepos >> 22) & 0xff;
+   * dist_l = granulepos & 0xff;
+   * dist = (dist_h << 8) | dist_l;
+   * delay = (granulepos >> 9) & 0x1fff;
+   * dt = pt - delay; */
 
   return pt >> 1;
 }
@@ -309,38 +298,6 @@ gst_schro_dec_finalize (GObject * object)
 }
 
 static void
-gst_schro_dec_set_property (GObject * object, guint prop_id,
-    const GValue * value, GParamSpec * pspec)
-{
-  GstSchroDec *src;
-
-  g_return_if_fail (GST_IS_SCHRO_DEC (object));
-  src = GST_SCHRO_DEC (object);
-
-  GST_DEBUG ("gst_schro_dec_set_property");
-  switch (prop_id) {
-    default:
-      break;
-  }
-}
-
-static void
-gst_schro_dec_get_property (GObject * object, guint prop_id, GValue * value,
-    GParamSpec * pspec)
-{
-  GstSchroDec *src;
-
-  g_return_if_fail (GST_IS_SCHRO_DEC (object));
-  src = GST_SCHRO_DEC (object);
-
-  switch (prop_id) {
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-  }
-}
-
-static void
 parse_sequence_header (GstSchroDec * schro_dec, guint8 * data, int size)
 {
   SchroVideoFormat video_format;
@@ -382,9 +339,7 @@ parse_sequence_header (GstSchroDec * schro_dec, guint8 * data, int size)
     state->par_d = video_format.aspect_ratio_denominator;
     GST_DEBUG ("Pixel aspect ratio is %d/%d", state->par_n, state->par_d);
 
-    /* FIXME state points to what is actually in the decoder */
-    //gst_base_video_decoder_set_state (GST_BASE_VIDEO_DECODER (schro_dec),
-    //    state);
+    gst_base_video_decoder_set_src_caps (GST_BASE_VIDEO_DECODER (schro_dec));
   } else {
     GST_WARNING ("Failed to get frame rate from sequence header");
   }
@@ -644,7 +599,6 @@ gst_schro_dec_handle_frame (GstBaseVideoDecoder * base_video_decoder,
     GstVideoFrame * frame)
 {
   GstSchroDec *schro_dec;
-  int schro_ret;
   SchroBuffer *input_buffer;
 
   schro_dec = GST_SCHRO_DEC (base_video_decoder);
@@ -656,7 +610,7 @@ gst_schro_dec_handle_frame (GstBaseVideoDecoder * base_video_decoder,
 
   input_buffer->tag = schro_tag_new (frame, NULL);
 
-  schro_ret = schro_decoder_autoparse_push (schro_dec->decoder, input_buffer);
+  schro_decoder_autoparse_push (schro_dec->decoder, input_buffer);
 
   return gst_schro_dec_process (schro_dec, FALSE);
 }
diff --git a/ext/schroedinger/gstschroenc.c b/ext/schroedinger/gstschroenc.c
index faf5a7f..beda4ea 100644
--- a/ext/schroedinger/gstschroenc.c
+++ b/ext/schroedinger/gstschroenc.c
@@ -24,6 +24,7 @@
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <gst/video/gstbasevideoencoder.h>
+#include <gst/video/gstbasevideoutils.h>
 #include <string.h>
 
 #include <schroedinger/schro.h>
@@ -49,15 +50,6 @@ GST_DEBUG_CATEGORY_EXTERN (schro_debug);
 typedef struct _GstSchroEnc GstSchroEnc;
 typedef struct _GstSchroEncClass GstSchroEncClass;
 
-typedef enum
-{
-  GST_SCHRO_ENC_OUTPUT_OGG,
-  GST_SCHRO_ENC_OUTPUT_QUICKTIME,
-  GST_SCHRO_ENC_OUTPUT_AVI,
-  GST_SCHRO_ENC_OUTPUT_MPEG_TS,
-  GST_SCHRO_ENC_OUTPUT_MP4
-} GstSchroEncOutputType;
-
 struct _GstSchroEnc
 {
   GstBaseVideoEncoder base_encoder;
@@ -65,13 +57,9 @@ struct _GstSchroEnc
   GstPad *sinkpad;
   GstPad *srcpad;
 
-  /* video properties */
-  GstSchroEncOutputType output_format;
-
   /* state */
   SchroEncoder *encoder;
   SchroVideoFormat *video_format;
-  GstBuffer *seq_header_buffer;
 
   guint64 last_granulepos;
   guint64 granule_offset;
@@ -107,13 +95,12 @@ static gboolean gst_schro_enc_set_format (GstBaseVideoEncoder *
     base_video_encoder, GstVideoState * state);
 static gboolean gst_schro_enc_start (GstBaseVideoEncoder * base_video_encoder);
 static gboolean gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder);
-static gboolean gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder);
+static GstFlowReturn gst_schro_enc_finish (GstBaseVideoEncoder *
+    base_video_encoder);
 static GstFlowReturn gst_schro_enc_handle_frame (GstBaseVideoEncoder *
     base_video_encoder, GstVideoFrame * frame);
 static GstFlowReturn gst_schro_enc_shape_output (GstBaseVideoEncoder *
     base_video_encoder, GstVideoFrame * frame);
-static GstCaps *gst_schro_enc_get_caps (GstBaseVideoEncoder *
-    base_video_encoder);
 
 static GstStaticPadTemplate gst_schro_enc_sink_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
@@ -229,7 +216,6 @@ gst_schro_enc_class_init (GstSchroEncClass * klass)
       GST_DEBUG_FUNCPTR (gst_schro_enc_handle_frame);
   basevideocoder_class->shape_output =
       GST_DEBUG_FUNCPTR (gst_schro_enc_shape_output);
-  basevideocoder_class->get_caps = GST_DEBUG_FUNCPTR (gst_schro_enc_get_caps);
 }
 
 static void
@@ -251,41 +237,12 @@ static gboolean
 gst_schro_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
     GstVideoState * state)
 {
-  GstCaps *caps;
-  GstStructure *structure;
   GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+  GstCaps *caps;
+  GstBuffer *seq_header_buffer;
+  gboolean ret;
 
   GST_DEBUG ("set_output_caps");
-  caps =
-      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
-      (base_video_encoder));
-  if (caps == NULL) {
-    caps =
-        gst_caps_copy (gst_pad_get_pad_template_caps
-        (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
-  }
-
-  if (gst_caps_is_empty (caps)) {
-    gst_caps_unref (caps);
-    return FALSE;
-  }
-
-  structure = gst_caps_get_structure (caps, 0);
-
-  if (gst_structure_has_name (structure, "video/x-dirac")) {
-    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_OGG;
-  } else if (gst_structure_has_name (structure, "video/x-qt-part")) {
-    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_QUICKTIME;
-  } else if (gst_structure_has_name (structure, "video/x-avi-part")) {
-    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_AVI;
-  } else if (gst_structure_has_name (structure, "video/x-mp4-part")) {
-    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_MP4;
-  } else {
-    gst_caps_unref (caps);
-    return FALSE;
-  }
-
-  gst_caps_unref (caps);
 
   gst_base_video_encoder_set_latency_fields (base_video_encoder,
       2 * (int) schro_encoder_setting_get_double (schro_enc->encoder,
@@ -334,11 +291,58 @@ gst_schro_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
   schro_encoder_set_video_format (schro_enc->encoder, schro_enc->video_format);
   schro_encoder_start (schro_enc->encoder);
 
-  schro_enc->seq_header_buffer =
+  seq_header_buffer =
       gst_schro_wrap_schro_buffer (schro_encoder_encode_sequence_header
       (schro_enc->encoder));
 
-  return TRUE;
+  schro_enc->granule_offset = ~0;
+
+  caps = gst_caps_new_simple ("video/x-dirac",
+      "width", G_TYPE_INT, state->width,
+      "height", G_TYPE_INT, state->height,
+      "framerate", GST_TYPE_FRACTION, state->fps_n,
+      state->fps_d,
+      "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+      state->par_d, NULL);
+
+  GST_BUFFER_FLAG_SET (seq_header_buffer, GST_BUFFER_FLAG_IN_CAPS);
+  {
+    GValue array = { 0 };
+    GValue value = { 0 };
+    GstBuffer *buf;
+    int size;
+
+    g_value_init (&array, GST_TYPE_ARRAY);
+    g_value_init (&value, GST_TYPE_BUFFER);
+    size = GST_BUFFER_SIZE (seq_header_buffer);
+    buf = gst_buffer_new_and_alloc (size + SCHRO_PARSE_HEADER_SIZE);
+
+    /* ogg(mux) expects the header buffers to have 0 timestamps -
+       set OFFSET and OFFSET_END accordingly */
+    GST_BUFFER_OFFSET (buf) = 0;
+    GST_BUFFER_OFFSET_END (buf) = 0;
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_IN_CAPS);
+
+    memcpy (GST_BUFFER_DATA (buf), GST_BUFFER_DATA (seq_header_buffer), size);
+    GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 0, 0x42424344);
+    GST_WRITE_UINT8 (GST_BUFFER_DATA (buf) + size + 4,
+        SCHRO_PARSE_CODE_END_OF_SEQUENCE);
+    GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 5, 0);
+    GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 9, size);
+    gst_value_set_buffer (&value, buf);
+    gst_buffer_unref (buf);
+    gst_value_array_append_value (&array, &value);
+    gst_structure_set_value (gst_caps_get_structure (caps, 0),
+        "streamheader", &array);
+    g_value_unset (&value);
+    g_value_unset (&array);
+  }
+  gst_buffer_unref (seq_header_buffer);
+
+  ret = gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (schro_enc), caps);
+  gst_caps_unref (caps);
+
+  return ret;
 }
 
 static void
@@ -413,10 +417,6 @@ gst_schro_enc_get_property (GObject * object, guint prop_id, GValue * value,
 static gboolean
 gst_schro_enc_start (GstBaseVideoEncoder * base_video_encoder)
 {
-  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
-
-  schro_enc->granule_offset = ~0;
-
   return TRUE;
 }
 
@@ -429,10 +429,6 @@ gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder)
     schro_encoder_free (schro_enc->encoder);
     schro_enc->encoder = NULL;
   }
-  if (schro_enc->seq_header_buffer) {
-    gst_buffer_unref (schro_enc->seq_header_buffer);
-    schro_enc->seq_header_buffer = NULL;
-  }
   if (schro_enc->video_format) {
     g_free (schro_enc->video_format);
     schro_enc->video_format = NULL;
@@ -441,7 +437,7 @@ gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder)
   return TRUE;
 }
 
-static gboolean
+static GstFlowReturn
 gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder)
 {
   GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
@@ -451,7 +447,7 @@ gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder)
   schro_encoder_end_of_stream (schro_enc->encoder);
   gst_schro_enc_process (schro_enc);
 
-  return TRUE;
+  return GST_FLOW_OK;
 }
 
 static GstFlowReturn
@@ -483,138 +479,11 @@ gst_schro_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
   return ret;
 }
 
-#if 0
-static void
-gst_caps_add_streamheader (GstCaps * caps, GList * list)
-{
-  GValue array = { 0 };
-  GValue value = { 0 };
-  GstBuffer *buf;
-  GList *g;
-
-  g_value_init (&array, GST_TYPE_ARRAY);
-
-  for (g = g_list_first (list); g; g = g_list_next (list)) {
-    g_value_init (&value, GST_TYPE_BUFFER);
-    buf = gst_buffer_copy (GST_BUFFER (g->data));
-    gst_value_set_buffer (&value, buf);
-    gst_buffer_unref (buf);
-    gst_value_array_append_value (&array, &value);
-    g_value_unset (&value);
-  }
-  gst_structure_set_value (gst_caps_get_structure (caps, 0),
-      "streamheader", &array);
-  g_value_unset (&array);
-}
-#endif
-
-static GstCaps *
-gst_schro_enc_get_caps (GstBaseVideoEncoder * base_video_encoder)
-{
-  GstCaps *caps;
-  const GstVideoState *state;
-  GstSchroEnc *schro_enc;
-
-  schro_enc = GST_SCHRO_ENC (base_video_encoder);
-
-  state = gst_base_video_encoder_get_state (base_video_encoder);
-
-  if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_OGG) {
-    caps = gst_caps_new_simple ("video/x-dirac",
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-
-    GST_BUFFER_FLAG_SET (schro_enc->seq_header_buffer, GST_BUFFER_FLAG_IN_CAPS);
-
-    {
-      GValue array = { 0 };
-      GValue value = { 0 };
-      GstBuffer *buf;
-      int size;
-
-      g_value_init (&array, GST_TYPE_ARRAY);
-      g_value_init (&value, GST_TYPE_BUFFER);
-      size = GST_BUFFER_SIZE (schro_enc->seq_header_buffer);
-      buf = gst_buffer_new_and_alloc (size + SCHRO_PARSE_HEADER_SIZE);
-
-      /* ogg(mux) expects the header buffers to have 0 timestamps -
-         set OFFSET and OFFSET_END accordingly */
-      GST_BUFFER_OFFSET (buf) = 0;
-      GST_BUFFER_OFFSET_END (buf) = 0;
-      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_IN_CAPS);
-
-      memcpy (GST_BUFFER_DATA (buf),
-          GST_BUFFER_DATA (schro_enc->seq_header_buffer), size);
-      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 0, 0x42424344);
-      GST_WRITE_UINT8 (GST_BUFFER_DATA (buf) + size + 4,
-          SCHRO_PARSE_CODE_END_OF_SEQUENCE);
-      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 5, 0);
-      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 9, size);
-      gst_value_set_buffer (&value, buf);
-      gst_buffer_unref (buf);
-      gst_value_array_append_value (&array, &value);
-      gst_structure_set_value (gst_caps_get_structure (caps, 0),
-          "streamheader", &array);
-      g_value_unset (&value);
-      g_value_unset (&array);
-    }
-  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_QUICKTIME) {
-    caps = gst_caps_new_simple ("video/x-qt-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_AVI) {
-    caps = gst_caps_new_simple ("video/x-avi-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_MPEG_TS) {
-    caps = gst_caps_new_simple ("video/x-mpegts-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_MP4) {
-    caps = gst_caps_new_simple ("video/x-mp4-part",
-        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
-        "width", G_TYPE_INT, state->width,
-        "height", G_TYPE_INT, state->height,
-        "framerate", GST_TYPE_FRACTION, state->fps_n,
-        state->fps_d,
-        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
-        state->par_d, NULL);
-  } else {
-    g_assert_not_reached ();
-    caps = NULL;
-  }
-
-  return caps;
-}
-
-
-
-
 static GstFlowReturn
-gst_schro_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
+gst_schro_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
 {
   GstSchroEnc *schro_enc;
-  int dpn;
   int delay;
   int dist;
   int pt;
@@ -625,8 +494,6 @@ gst_schro_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
 
   schro_enc = GST_SCHRO_ENC (base_video_encoder);
 
-  dpn = frame->decode_frame_number;
-
   pt = frame->presentation_frame_number * 2 + schro_enc->granule_offset;
   dt = frame->decode_frame_number * 2 + schro_enc->granule_offset;
   delay = pt - dt;
@@ -648,103 +515,13 @@ gst_schro_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
     GST_BUFFER_OFFSET_END (buf) = schro_enc->last_granulepos;
   }
 
-  gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC (base_video_encoder)->caps);
-
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
-}
-
-static GstFlowReturn
-gst_schro_enc_shape_output_quicktime (GstBaseVideoEncoder * base_video_encoder,
-    GstVideoFrame * frame)
-{
-  GstBuffer *buf = frame->src_buffer;
-  const GstVideoState *state;
-
-  state = gst_base_video_encoder_get_state (base_video_encoder);
-
-  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->presentation_frame_number);
-  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
-  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->system_frame_number);
-  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
-
-  if (frame->is_sync_point &&
-      frame->presentation_frame_number == frame->system_frame_number) {
-    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  } else {
-    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  }
-
-  gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC (base_video_encoder)->caps);
+  gst_buffer_set_caps (buf,
+      GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
 
   return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
 }
 
 static GstFlowReturn
-gst_schro_enc_shape_output_mp4 (GstBaseVideoEncoder * base_video_encoder,
-    GstVideoFrame * frame)
-{
-  GstBuffer *buf = frame->src_buffer;
-  const GstVideoState *state;
-
-  state = gst_base_video_encoder_get_state (base_video_encoder);
-
-  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->presentation_frame_number);
-  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
-  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->decode_frame_number);
-  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
-
-  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
-      &GST_BASE_VIDEO_CODEC (base_video_encoder)->segment,
-      frame->system_frame_number);
-
-  if (frame->is_sync_point &&
-      frame->presentation_frame_number == frame->system_frame_number) {
-    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  } else {
-    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
-  }
-
-  gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC (base_video_encoder)->caps);
-
-  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
-}
-
-static GstFlowReturn
-gst_schro_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
-    GstVideoFrame * frame)
-{
-  GstSchroEnc *schro_enc;
-
-  schro_enc = GST_SCHRO_ENC (base_video_encoder);
-
-  switch (schro_enc->output_format) {
-    case GST_SCHRO_ENC_OUTPUT_OGG:
-      return gst_schro_enc_shape_output_ogg (base_video_encoder, frame);
-    case GST_SCHRO_ENC_OUTPUT_QUICKTIME:
-      return gst_schro_enc_shape_output_quicktime (base_video_encoder, frame);
-    case GST_SCHRO_ENC_OUTPUT_MP4:
-      return gst_schro_enc_shape_output_mp4 (base_video_encoder, frame);
-    default:
-      g_assert_not_reached ();
-      break;
-  }
-
-  return GST_FLOW_ERROR;
-}
-
-static GstFlowReturn
 gst_schro_enc_process (GstSchroEnc * schro_enc)
 {
   SchroBuffer *encoded_buffer;
diff --git a/ext/vp8/gstvp8dec.c b/ext/vp8/gstvp8dec.c
index 3d8567f..4376f4b 100644
--- a/ext/vp8/gstvp8dec.c
+++ b/ext/vp8/gstvp8dec.c
@@ -98,6 +98,8 @@ static void gst_vp8_dec_get_property (GObject * object, guint prop_id,
 
 static gboolean gst_vp8_dec_start (GstBaseVideoDecoder * decoder);
 static gboolean gst_vp8_dec_stop (GstBaseVideoDecoder * decoder);
+static gboolean gst_vp8_dec_set_format (GstBaseVideoDecoder * decoder,
+    GstVideoState * state);
 static gboolean gst_vp8_dec_reset (GstBaseVideoDecoder * decoder);
 static GstFlowReturn gst_vp8_dec_parse_data (GstBaseVideoDecoder * decoder,
     gboolean at_eos);
@@ -172,11 +174,15 @@ gst_vp8_dec_class_init (GstVP8DecClass * klass)
           0, 16, DEFAULT_NOISE_LEVEL,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  base_video_decoder_class->start = gst_vp8_dec_start;
-  base_video_decoder_class->stop = gst_vp8_dec_stop;
-  base_video_decoder_class->reset = gst_vp8_dec_reset;
-  base_video_decoder_class->parse_data = gst_vp8_dec_parse_data;
-  base_video_decoder_class->handle_frame = gst_vp8_dec_handle_frame;
+  base_video_decoder_class->start = GST_DEBUG_FUNCPTR (gst_vp8_dec_start);
+  base_video_decoder_class->stop = GST_DEBUG_FUNCPTR (gst_vp8_dec_stop);
+  base_video_decoder_class->reset = GST_DEBUG_FUNCPTR (gst_vp8_dec_reset);
+  base_video_decoder_class->set_format =
+      GST_DEBUG_FUNCPTR (gst_vp8_dec_set_format);
+  base_video_decoder_class->parse_data =
+      GST_DEBUG_FUNCPTR (gst_vp8_dec_parse_data);
+  base_video_decoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_vp8_dec_handle_frame);
 
   GST_DEBUG_CATEGORY_INIT (gst_vp8dec_debug, "vp8dec", 0, "VP8 Decoder");
 }
@@ -275,6 +281,17 @@ gst_vp8_dec_stop (GstBaseVideoDecoder * base_video_decoder)
 }
 
 static gboolean
+gst_vp8_dec_set_format (GstBaseVideoDecoder * decoder, GstVideoState * state)
+{
+  GstVP8Dec *gst_vp8_dec = GST_VP8_DEC (decoder);
+
+  GST_DEBUG_OBJECT (gst_vp8_dec, "set_format");
+  gst_vp8_dec->decoder_inited = FALSE;
+
+  return TRUE;
+}
+
+static gboolean
 gst_vp8_dec_reset (GstBaseVideoDecoder * base_video_decoder)
 {
   GstVP8Dec *decoder;
@@ -381,15 +398,19 @@ gst_vp8_dec_handle_frame (GstBaseVideoDecoder * decoder, GstVideoFrame * frame)
 
     if (status != VPX_CODEC_OK || !stream_info.is_kf) {
       GST_WARNING_OBJECT (decoder, "No keyframe, skipping");
-      gst_base_video_decoder_skip_frame (decoder, frame);
+      gst_base_video_decoder_finish_frame (decoder, frame);
       return GST_FLOW_OK;
     }
 
-    /* should set size here */
     state->width = stream_info.w;
     state->height = stream_info.h;
     state->format = GST_VIDEO_FORMAT_I420;
+    if (state->par_n == 0 || state->par_d == 0) {
+      state->par_n = 1;
+      state->par_d = 1;
+    }
     gst_vp8_dec_send_tags (dec);
+    gst_base_video_decoder_set_src_caps (decoder);
 
     caps = vpx_codec_get_caps (&vpx_codec_vp8_dx_algo);
 
@@ -431,21 +452,6 @@ gst_vp8_dec_handle_frame (GstBaseVideoDecoder * decoder, GstVideoFrame * frame)
   if (!GST_BUFFER_FLAG_IS_SET (frame->sink_buffer, GST_BUFFER_FLAG_DELTA_UNIT))
     gst_base_video_decoder_set_sync_point (decoder);
 
-#if 0
-  if (GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (decoder)) == NULL) {
-    GstCaps *caps;
-
-    caps = gst_video_format_new_caps (decoder->state.format,
-        decoder->state.width, decoder->state.height,
-        decoder->state.fps_n, decoder->state.fps_d,
-        decoder->state.par_n, decoder->state.par_d);
-
-    GST_DEBUG ("setting caps %" GST_PTR_FORMAT, caps);
-
-    gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (decoder), caps);
-  }
-#endif
-
   deadline = gst_base_video_decoder_get_max_decode_time (decoder, frame);
   if (deadline < 0) {
     decoder_deadline = 1;
@@ -469,15 +475,15 @@ gst_vp8_dec_handle_frame (GstBaseVideoDecoder * decoder, GstVideoFrame * frame)
     if (deadline < 0) {
       GST_LOG_OBJECT (dec, "Skipping late frame (%f s past deadline)",
           (double) -deadline / GST_SECOND);
-      gst_base_video_decoder_skip_frame (decoder, frame);
+      gst_base_video_decoder_finish_frame (decoder, frame);
     } else {
       ret = gst_base_video_decoder_alloc_src_frame (decoder, frame);
 
       if (ret == GST_FLOW_OK) {
         gst_vp8_dec_image_to_buffer (dec, img, frame->src_buffer);
-        gst_base_video_decoder_finish_frame (decoder, frame);
+        ret = gst_base_video_decoder_finish_frame (decoder, frame);
       } else {
-        gst_base_video_decoder_skip_frame (decoder, frame);
+        gst_base_video_decoder_finish_frame (decoder, frame);
       }
     }
 
@@ -489,7 +495,7 @@ gst_vp8_dec_handle_frame (GstBaseVideoDecoder * decoder, GstVideoFrame * frame)
     }
   } else {
     /* Invisible frame */
-    gst_base_video_decoder_skip_frame (decoder, frame);
+    gst_base_video_decoder_finish_frame (decoder, frame);
   }
 
   return ret;
diff --git a/ext/vp8/gstvp8enc.c b/ext/vp8/gstvp8enc.c
index 17b316a..e832975 100644
--- a/ext/vp8/gstvp8enc.c
+++ b/ext/vp8/gstvp8enc.c
@@ -65,8 +65,30 @@ typedef struct
   GList *invisible;
 } GstVP8EncCoderHook;
 
+static void
+_gst_mini_object_unref0 (GstMiniObject * obj)
+{
+  if (obj)
+    gst_mini_object_unref (obj);
+}
+
+static void
+gst_vp8_enc_coder_hook_free (GstVP8EncCoderHook * hook)
+{
+  if (hook->image)
+    g_slice_free (vpx_image_t, hook->image);
+
+  g_list_foreach (hook->invisible, (GFunc) _gst_mini_object_unref0, NULL);
+  g_list_free (hook->invisible);
+  g_slice_free (GstVP8EncCoderHook, hook);
+}
+
 #define DEFAULT_BITRATE 0
 #define DEFAULT_MODE VPX_VBR
+#define DEFAULT_MINSECTION_PCT 5
+#define DEFAULT_MAXSECTION_PCT 800
+#define DEFAULT_MIN_QUANTIZER 0
+#define DEFAULT_MAX_QUANTIZER 63
 #define DEFAULT_QUALITY 5
 #define DEFAULT_ERROR_RESILIENT FALSE
 #define DEFAULT_MAX_LATENCY 10
@@ -74,14 +96,33 @@ typedef struct
 #define DEFAULT_SPEED 0
 #define DEFAULT_THREADS 1
 #define DEFAULT_MULTIPASS_MODE VPX_RC_ONE_PASS
-#define DEFAULT_MULTIPASS_CACHE_FILE NULL
+#define DEFAULT_MULTIPASS_CACHE_FILE "multipass.cache"
 #define DEFAULT_AUTO_ALT_REF_FRAMES FALSE
+#define DEFAULT_LAG_IN_FRAMES 0
+#define DEFAULT_SHARPNESS 0
+#define DEFAULT_NOISE_SENSITIVITY 0
+#ifdef HAVE_VP8ENC_TUNING
+#define DEFAULT_TUNE VP8_TUNE_PSNR
+#else
+typedef enum
+{ VP8_TUNE_NONE } vp8e_tuning;
+#define DEFAULT_TUNE VP8_TUNE_NONE
+#endif
+#define DEFAULT_STATIC_THRESHOLD 0
+#define DEFAULT_DROP_FRAME 0
+#define DEFAULT_RESIZE_ALLOWED TRUE
+#define DEFAULT_TOKEN_PARTS 0
+
 
 enum
 {
   PROP_0,
   PROP_BITRATE,
   PROP_MODE,
+  PROP_MINSECTION_PCT,
+  PROP_MAXSECTION_PCT,
+  PROP_MIN_QUANTIZER,
+  PROP_MAX_QUANTIZER,
   PROP_QUALITY,
   PROP_ERROR_RESILIENT,
   PROP_MAX_LATENCY,
@@ -90,7 +131,15 @@ enum
   PROP_THREADS,
   PROP_MULTIPASS_MODE,
   PROP_MULTIPASS_CACHE_FILE,
-  PROP_AUTO_ALT_REF_FRAMES
+  PROP_AUTO_ALT_REF_FRAMES,
+  PROP_LAG_IN_FRAMES,
+  PROP_SHARPNESS,
+  PROP_NOISE_SENSITIVITY,
+  PROP_TUNE,
+  PROP_STATIC_THRESHOLD,
+  PROP_DROP_FRAME,
+  PROP_RESIZE_ALLOWED,
+  PROP_TOKEN_PARTS
 };
 
 #define GST_VP8_ENC_MODE_TYPE (gst_vp8_enc_mode_get_type())
@@ -138,6 +187,32 @@ gst_vp8_enc_multipass_mode_get_type (void)
   return id;
 }
 
+#define GST_VP8_ENC_TUNE_TYPE (gst_vp8_enc_tune_get_type())
+static GType
+gst_vp8_enc_tune_get_type (void)
+{
+  static const GEnumValue values[] = {
+#ifdef HAVE_VP8ENC_TUNING
+    {VP8_TUNE_PSNR, "Tune for PSNR", "psnr"},
+    {VP8_TUNE_SSIM, "Tune for SSIM", "ssim"},
+#else
+    {VP8_TUNE_NONE, "none", "none"},
+#endif
+    {0, NULL, NULL}
+  };
+  static volatile GType id = 0;
+
+  if (g_once_init_enter ((gsize *) & id)) {
+    GType _id;
+
+    _id = g_enum_register_static ("GstVP8EncTune", values);
+
+    g_once_init_leave ((gsize *) & id, _id);
+  }
+
+  return id;
+}
+
 static void gst_vp8_enc_finalize (GObject * object);
 static void gst_vp8_enc_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
@@ -149,13 +224,12 @@ static gboolean gst_vp8_enc_stop (GstBaseVideoEncoder * encoder);
 static gboolean gst_vp8_enc_set_format (GstBaseVideoEncoder *
     base_video_encoder, GstVideoState * state);
 static gboolean gst_vp8_enc_finish (GstBaseVideoEncoder * base_video_encoder);
-static gboolean gst_vp8_enc_handle_frame (GstBaseVideoEncoder *
+static GstFlowReturn gst_vp8_enc_handle_frame (GstBaseVideoEncoder *
     base_video_encoder, GstVideoFrame * frame);
 static GstFlowReturn gst_vp8_enc_shape_output (GstBaseVideoEncoder * encoder,
     GstVideoFrame * frame);
-static GstCaps *gst_vp8_enc_get_caps (GstBaseVideoEncoder * base_video_encoder);
-
-static gboolean gst_vp8_enc_sink_event (GstPad * pad, GstEvent * event);
+static gboolean gst_vp8_enc_sink_event (GstBaseVideoEncoder *
+    base_video_encoder, GstEvent * event);
 
 static GstStaticPadTemplate gst_vp8_enc_sink_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
@@ -225,7 +299,7 @@ gst_vp8_enc_class_init (GstVP8EncClass * klass)
   base_video_encoder_class->set_format = gst_vp8_enc_set_format;
   base_video_encoder_class->finish = gst_vp8_enc_finish;
   base_video_encoder_class->shape_output = gst_vp8_enc_shape_output;
-  base_video_encoder_class->get_caps = gst_vp8_enc_get_caps;
+  base_video_encoder_class->event = gst_vp8_enc_sink_event;
 
   g_object_class_install_property (gobject_class, PROP_BITRATE,
       g_param_spec_int ("bitrate", "Bit rate",
@@ -239,9 +313,35 @@ gst_vp8_enc_class_init (GstVP8EncClass * klass)
           GST_VP8_ENC_MODE_TYPE, DEFAULT_MODE,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
 
+  g_object_class_install_property (gobject_class, PROP_MINSECTION_PCT,
+      g_param_spec_uint ("minsection-pct",
+          "minimum percentage allocation per section",
+          "The numbers represent a percentage of the average allocation per section (frame)",
+          0, 20, DEFAULT_MINSECTION_PCT,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_MAXSECTION_PCT,
+      g_param_spec_uint ("maxsection-pct",
+          "maximum percentage allocation per section",
+          "The numbers represent a percentage of the average allocation per section (frame)",
+          200, 800, DEFAULT_MAXSECTION_PCT,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_MIN_QUANTIZER,
+      g_param_spec_int ("min-quantizer", "Minimum quantizer",
+          "Minimum (best) quantizer",
+          0, 63, DEFAULT_MIN_QUANTIZER,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_MAX_QUANTIZER,
+      g_param_spec_int ("max-quantizer", "Maximum quantizer",
+          "Maximum (worst) quantizer",
+          0, 63, DEFAULT_MAX_QUANTIZER,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
   g_object_class_install_property (gobject_class, PROP_QUALITY,
       g_param_spec_double ("quality", "Quality",
-          "Quality",
+          "Quality. This parameter sets a constant quantizer.",
           0, 10.0, DEFAULT_QUALITY,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
 
@@ -266,7 +366,7 @@ gst_vp8_enc_class_init (GstVP8EncClass * klass)
   g_object_class_install_property (gobject_class, PROP_SPEED,
       g_param_spec_int ("speed", "Speed",
           "Speed",
-          0, 2, DEFAULT_SPEED,
+          0, 7, DEFAULT_SPEED,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
 
   g_object_class_install_property (gobject_class, PROP_THREADS,
@@ -293,6 +393,54 @@ gst_vp8_enc_class_init (GstVP8EncClass * klass)
           DEFAULT_AUTO_ALT_REF_FRAMES,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
 
+  g_object_class_install_property (gobject_class, PROP_LAG_IN_FRAMES,
+      g_param_spec_uint ("lag-in-frames", "Max number of frames to lag",
+          "If set, this value allows the encoder to consume a number of input "
+          "frames before producing output frames.",
+          0, 64, DEFAULT_LAG_IN_FRAMES,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_SHARPNESS,
+      g_param_spec_int ("sharpness", "Sharpness",
+          "Sharpness",
+          0, 7, DEFAULT_SHARPNESS,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_NOISE_SENSITIVITY,
+      g_param_spec_int ("noise-sensitivity", "Noise Sensitivity",
+          "Noise Sensitivity",
+          0, 6, DEFAULT_NOISE_SENSITIVITY,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_TUNE,
+      g_param_spec_enum ("tune", "Tune",
+          "Tune",
+          GST_VP8_ENC_TUNE_TYPE, DEFAULT_TUNE,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_STATIC_THRESHOLD,
+      g_param_spec_int ("static-threshold", "Static Threshold",
+          "Static Threshold",
+          0, 1000, DEFAULT_STATIC_THRESHOLD,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_DROP_FRAME,
+      g_param_spec_int ("drop-frame", "Drop Frame",
+          "Drop Frame",
+          0, 100, DEFAULT_DROP_FRAME,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_RESIZE_ALLOWED,
+      g_param_spec_boolean ("resize-allowed", "Resize Allowed",
+          "Resize Allowed",
+          DEFAULT_RESIZE_ALLOWED,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_TOKEN_PARTS,
+      g_param_spec_int ("token-parts", "Token Parts",
+          "Token Parts",
+          0, 3, DEFAULT_TOKEN_PARTS,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
 
   GST_DEBUG_CATEGORY_INIT (gst_vp8enc_debug, "vp8enc", 0, "VP8 Encoder");
 }
@@ -304,20 +452,19 @@ gst_vp8_enc_init (GstVP8Enc * gst_vp8_enc, GstVP8EncClass * klass)
   GST_DEBUG_OBJECT (gst_vp8_enc, "init");
 
   gst_vp8_enc->bitrate = DEFAULT_BITRATE;
+  gst_vp8_enc->minsection_pct = DEFAULT_MINSECTION_PCT;
+  gst_vp8_enc->maxsection_pct = DEFAULT_MAXSECTION_PCT;
+  gst_vp8_enc->min_quantizer = DEFAULT_MIN_QUANTIZER;
+  gst_vp8_enc->max_quantizer = DEFAULT_MAX_QUANTIZER;
   gst_vp8_enc->mode = DEFAULT_MODE;
   gst_vp8_enc->quality = DEFAULT_QUALITY;
   gst_vp8_enc->error_resilient = DEFAULT_ERROR_RESILIENT;
   gst_vp8_enc->max_latency = DEFAULT_MAX_LATENCY;
   gst_vp8_enc->max_keyframe_distance = DEFAULT_MAX_KEYFRAME_DISTANCE;
   gst_vp8_enc->multipass_mode = DEFAULT_MULTIPASS_MODE;
-  gst_vp8_enc->multipass_cache_file = DEFAULT_MULTIPASS_CACHE_FILE;
+  gst_vp8_enc->multipass_cache_file = g_strdup (DEFAULT_MULTIPASS_CACHE_FILE);
   gst_vp8_enc->auto_alt_ref_frames = DEFAULT_AUTO_ALT_REF_FRAMES;
-
-  /* FIXME: Add sink/src event vmethods */
-  gst_vp8_enc->base_sink_event_func =
-      GST_PAD_EVENTFUNC (GST_BASE_VIDEO_CODEC_SINK_PAD (gst_vp8_enc));
-  gst_pad_set_event_function (GST_BASE_VIDEO_CODEC_SINK_PAD (gst_vp8_enc),
-      gst_vp8_enc_sink_event);
+  gst_vp8_enc->lag_in_frames = DEFAULT_LAG_IN_FRAMES;
 }
 
 static void
@@ -354,6 +501,18 @@ gst_vp8_enc_set_property (GObject * object, guint prop_id,
     case PROP_MODE:
       gst_vp8_enc->mode = g_value_get_enum (value);
       break;
+    case PROP_MINSECTION_PCT:
+      gst_vp8_enc->minsection_pct = g_value_get_uint (value);
+      break;
+    case PROP_MAXSECTION_PCT:
+      gst_vp8_enc->maxsection_pct = g_value_get_uint (value);
+      break;
+    case PROP_MIN_QUANTIZER:
+      gst_vp8_enc->min_quantizer = g_value_get_int (value);
+      break;
+    case PROP_MAX_QUANTIZER:
+      gst_vp8_enc->max_quantizer = g_value_get_int (value);
+      break;
     case PROP_QUALITY:
       gst_vp8_enc->quality = g_value_get_double (value);
       break;
@@ -383,6 +542,35 @@ gst_vp8_enc_set_property (GObject * object, guint prop_id,
     case PROP_AUTO_ALT_REF_FRAMES:
       gst_vp8_enc->auto_alt_ref_frames = g_value_get_boolean (value);
       break;
+    case PROP_LAG_IN_FRAMES:
+      gst_vp8_enc->lag_in_frames = g_value_get_uint (value);
+      break;
+    case PROP_SHARPNESS:
+      gst_vp8_enc->sharpness = g_value_get_int (value);
+      break;
+    case PROP_NOISE_SENSITIVITY:
+      gst_vp8_enc->noise_sensitivity = g_value_get_int (value);
+      break;
+    case PROP_TUNE:
+#ifdef HAVE_VP8ENC_TUNING
+      gst_vp8_enc->tuning = g_value_get_enum (value);
+#else
+      GST_WARNING_OBJECT (gst_vp8_enc,
+          "The tuning property is unsupported by this libvpx");
+#endif
+      break;
+    case PROP_STATIC_THRESHOLD:
+      gst_vp8_enc->static_threshold = g_value_get_int (value);
+      break;
+    case PROP_DROP_FRAME:
+      gst_vp8_enc->drop_frame = g_value_get_int (value);
+      break;
+    case PROP_RESIZE_ALLOWED:
+      gst_vp8_enc->resize_allowed = g_value_get_boolean (value);
+      break;
+    case PROP_TOKEN_PARTS:
+      gst_vp8_enc->partitions = g_value_get_int (value);
+      break;
     default:
       break;
   }
@@ -404,6 +592,18 @@ gst_vp8_enc_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_MODE:
       g_value_set_enum (value, gst_vp8_enc->mode);
       break;
+    case PROP_MINSECTION_PCT:
+      g_value_set_uint (value, gst_vp8_enc->minsection_pct);
+      break;
+    case PROP_MAXSECTION_PCT:
+      g_value_set_uint (value, gst_vp8_enc->maxsection_pct);
+      break;
+    case PROP_MIN_QUANTIZER:
+      g_value_set_int (value, gst_vp8_enc->min_quantizer);
+      break;
+    case PROP_MAX_QUANTIZER:
+      g_value_set_int (value, gst_vp8_enc->max_quantizer);
+      break;
     case PROP_QUALITY:
       g_value_set_double (value, gst_vp8_enc->quality);
       break;
@@ -431,6 +631,35 @@ gst_vp8_enc_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_AUTO_ALT_REF_FRAMES:
       g_value_set_boolean (value, gst_vp8_enc->auto_alt_ref_frames);
       break;
+    case PROP_LAG_IN_FRAMES:
+      g_value_set_uint (value, gst_vp8_enc->lag_in_frames);
+      break;
+    case PROP_SHARPNESS:
+      g_value_set_int (value, gst_vp8_enc->sharpness);
+      break;
+    case PROP_NOISE_SENSITIVITY:
+      g_value_set_int (value, gst_vp8_enc->noise_sensitivity);
+      break;
+    case PROP_TUNE:
+#ifdef HAVE_VP8ENC_TUNING
+      g_value_set_enum (value, gst_vp8_enc->tuning);
+#else
+      GST_WARNING_OBJECT (gst_vp8_enc,
+          "The tuning property is unsupported by this libvpx");
+#endif
+      break;
+    case PROP_STATIC_THRESHOLD:
+      g_value_set_int (value, gst_vp8_enc->static_threshold);
+      break;
+    case PROP_DROP_FRAME:
+      g_value_set_int (value, gst_vp8_enc->drop_frame);
+      break;
+    case PROP_RESIZE_ALLOWED:
+      g_value_set_boolean (value, gst_vp8_enc->resize_allowed);
+      break;
+    case PROP_TOKEN_PARTS:
+      g_value_set_int (value, gst_vp8_enc->partitions);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -479,25 +708,165 @@ static gboolean
 gst_vp8_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
     GstVideoState * state)
 {
+  GstVP8Enc *encoder;
+  vpx_codec_enc_cfg_t cfg;
+  vpx_codec_err_t status;
+  vpx_image_t *image;
+  guint8 *data = NULL;
+  GstCaps *caps;
+  gboolean ret;
+
+  encoder = GST_VP8_ENC (base_video_encoder);
   GST_DEBUG_OBJECT (base_video_encoder, "set_format");
 
-  return TRUE;
-}
+  if (encoder->inited) {
+    GST_DEBUG_OBJECT (base_video_encoder, "refusing renegotiation");
+    return FALSE;
+  }
 
-static GstCaps *
-gst_vp8_enc_get_caps (GstBaseVideoEncoder * base_video_encoder)
-{
-  GstCaps *caps;
-  const GstVideoState *state;
-  GstTagList *tags = NULL;
-  const GstTagList *iface_tags;
-  GstBuffer *stream_hdr, *vorbiscomment;
-  guint8 *data;
-  GstStructure *s;
-  GValue array = { 0 };
-  GValue value = { 0 };
+  status = vpx_codec_enc_config_default (&vpx_codec_vp8_cx_algo, &cfg, 0);
+  if (status != VPX_CODEC_OK) {
+    GST_ELEMENT_ERROR (encoder, LIBRARY, INIT,
+        ("Failed to get default encoder configuration"), ("%s",
+            gst_vpx_error_name (status)));
+    return FALSE;
+  }
+
+  cfg.g_w = state->width;
+  cfg.g_h = state->height;
+  cfg.g_timebase.num = state->fps_d;
+  cfg.g_timebase.den = state->fps_n;
+
+  cfg.g_error_resilient = encoder->error_resilient;
+  cfg.g_lag_in_frames = encoder->max_latency;
+  cfg.g_threads = encoder->threads;
+  cfg.rc_end_usage = encoder->mode;
+  cfg.rc_2pass_vbr_minsection_pct = encoder->minsection_pct;
+  cfg.rc_2pass_vbr_maxsection_pct = encoder->maxsection_pct;
+  /* Standalone qp-min do not make any sence, with bitrate=0 and qp-min=1
+   * encoder will use only default qp-max=63. Also this will make
+   * worst possbile quality.
+   */
+  if (encoder->bitrate != DEFAULT_BITRATE ||
+      encoder->max_quantizer != DEFAULT_MAX_QUANTIZER) {
+    cfg.rc_target_bitrate = encoder->bitrate / 1000;
+    cfg.rc_min_quantizer = encoder->min_quantizer;
+    cfg.rc_max_quantizer = encoder->max_quantizer;
+  } else {
+    cfg.rc_min_quantizer = (gint) (63 - encoder->quality * 6.2);
+    cfg.rc_max_quantizer = (gint) (63 - encoder->quality * 6.2);
+    cfg.rc_target_bitrate = encoder->bitrate;
+  }
+  cfg.rc_dropframe_thresh = encoder->drop_frame;
+  cfg.rc_resize_allowed = encoder->resize_allowed;
+
+  cfg.kf_mode = VPX_KF_AUTO;
+  cfg.kf_min_dist = 0;
+  cfg.kf_max_dist = encoder->max_keyframe_distance;
+
+  cfg.g_pass = encoder->multipass_mode;
+  if (encoder->multipass_mode == VPX_RC_FIRST_PASS) {
+    encoder->first_pass_cache_content = g_byte_array_sized_new (4096);
+  } else if (encoder->multipass_mode == VPX_RC_LAST_PASS) {
+    GError *err = NULL;
+
+    if (!encoder->multipass_cache_file) {
+      GST_ELEMENT_ERROR (encoder, RESOURCE, OPEN_READ,
+          ("No multipass cache file provided"), (NULL));
+      return FALSE;
+    }
+
+    if (!g_file_get_contents (encoder->multipass_cache_file,
+            (gchar **) & encoder->last_pass_cache_content.buf,
+            &encoder->last_pass_cache_content.sz, &err)) {
+      GST_ELEMENT_ERROR (encoder, RESOURCE, OPEN_READ,
+          ("Failed to read multipass cache file provided"), ("%s",
+              err->message));
+      g_error_free (err);
+      return FALSE;
+    }
+    cfg.rc_twopass_stats_in = encoder->last_pass_cache_content;
+  }
+
+  status = vpx_codec_enc_init (&encoder->encoder, &vpx_codec_vp8_cx_algo,
+      &cfg, 0);
+  if (status != VPX_CODEC_OK) {
+    GST_ELEMENT_ERROR (encoder, LIBRARY, INIT,
+        ("Failed to initialize encoder"), ("%s", gst_vpx_error_name (status)));
+    return FALSE;
+  }
+
+  /* FIXME move this to a set_speed() function */
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_CPUUSED,
+      (encoder->speed == 0) ? 0 : (encoder->speed - 1));
+  if (status != VPX_CODEC_OK) {
+    GST_WARNING_OBJECT (encoder, "Failed to set VP8E_SET_CPUUSED to 0: %s",
+        gst_vpx_error_name (status));
+  }
+
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_NOISE_SENSITIVITY,
+      encoder->noise_sensitivity);
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_SHARPNESS,
+      encoder->sharpness);
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_STATIC_THRESHOLD,
+      encoder->static_threshold);
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_TOKEN_PARTITIONS,
+      encoder->partitions);
+#if 0
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_ARNR_MAXFRAMES,
+      encoder->arnr_maxframes);
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_ARNR_STRENGTH,
+      encoder->arnr_strength);
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_ARNR_TYPE,
+      encoder->arnr_type);
+#endif
+#ifdef HAVE_VP8ENC_TUNING
+  status = vpx_codec_control (&encoder->encoder, VP8E_SET_TUNING,
+      encoder->tuning);
+#endif
+
+  status =
+      vpx_codec_control (&encoder->encoder, VP8E_SET_ENABLEAUTOALTREF,
+      (encoder->auto_alt_ref_frames ? 1 : 0));
+  if (status != VPX_CODEC_OK) {
+    GST_WARNING_OBJECT (encoder,
+        "Failed to set VP8E_ENABLEAUTOALTREF to %d: %s",
+        (encoder->auto_alt_ref_frames ? 1 : 0), gst_vpx_error_name (status));
+  }
+
+  cfg.g_lag_in_frames = encoder->lag_in_frames;
+
+  gst_base_video_encoder_set_latency (base_video_encoder, 0,
+      gst_util_uint64_scale (encoder->max_latency,
+          state->fps_d * GST_SECOND, state->fps_n));
+  encoder->inited = TRUE;
+
+  /* prepare cached image buffer setup */
+  image = &encoder->image;
+  memset (image, 0, sizeof (image));
+
+  image->fmt = VPX_IMG_FMT_I420;
+  image->bps = 12;
+  image->x_chroma_shift = image->y_chroma_shift = 1;
+  image->w = image->d_w = state->width;
+  image->h = image->d_h = state->height;
+
+  image->stride[VPX_PLANE_Y] =
+      gst_video_format_get_row_stride (state->format, 0, state->width);
+  image->stride[VPX_PLANE_U] =
+      gst_video_format_get_row_stride (state->format, 1, state->width);
+  image->stride[VPX_PLANE_V] =
+      gst_video_format_get_row_stride (state->format, 2, state->width);
+  image->planes[VPX_PLANE_Y] =
+      data + gst_video_format_get_component_offset (state->format, 0,
+      state->width, state->height);
+  image->planes[VPX_PLANE_U] =
+      data + gst_video_format_get_component_offset (state->format, 1,
+      state->width, state->height);
+  image->planes[VPX_PLANE_V] =
+      data + gst_video_format_get_component_offset (state->format, 2,
+      state->width, state->height);
 
-  state = gst_base_video_encoder_get_state (base_video_encoder);
 
   caps = gst_caps_new_simple ("video/x-vp8",
       "width", G_TYPE_INT, state->width,
@@ -506,86 +875,83 @@ gst_vp8_enc_get_caps (GstBaseVideoEncoder * base_video_encoder)
       state->fps_d,
       "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
       state->par_d, NULL);
-
-  s = gst_caps_get_structure (caps, 0);
-
-  /* put buffers in a fixed list */
-  g_value_init (&array, GST_TYPE_ARRAY);
-  g_value_init (&value, GST_TYPE_BUFFER);
-
-  /* Create Ogg stream-info */
-  stream_hdr = gst_buffer_new_and_alloc (26);
-  data = GST_BUFFER_DATA (stream_hdr);
-
-  GST_WRITE_UINT8 (data, 0x4F);
-  GST_WRITE_UINT32_BE (data + 1, 0x56503830);   /* "VP80" */
-  GST_WRITE_UINT8 (data + 5, 0x01);     /* stream info header */
-  GST_WRITE_UINT8 (data + 6, 1);        /* Major version 1 */
-  GST_WRITE_UINT8 (data + 7, 0);        /* Minor version 0 */
-  GST_WRITE_UINT16_BE (data + 8, state->width);
-  GST_WRITE_UINT16_BE (data + 10, state->height);
-  GST_WRITE_UINT24_BE (data + 12, state->par_n);
-  GST_WRITE_UINT24_BE (data + 15, state->par_d);
-  GST_WRITE_UINT32_BE (data + 18, state->fps_n);
-  GST_WRITE_UINT32_BE (data + 22, state->fps_d);
-
-  GST_BUFFER_FLAG_SET (stream_hdr, GST_BUFFER_FLAG_IN_CAPS);
-  gst_value_set_buffer (&value, stream_hdr);
-  gst_value_array_append_value (&array, &value);
-  g_value_unset (&value);
-  gst_buffer_unref (stream_hdr);
-
-  iface_tags =
-      gst_tag_setter_get_tag_list (GST_TAG_SETTER (base_video_encoder));
-  if (iface_tags) {
-    vorbiscomment =
-        gst_tag_list_to_vorbiscomment_buffer ((iface_tags) ? iface_tags : tags,
-        (const guint8 *) "OVP80\2 ", 7,
-        "Encoded with GStreamer vp8enc " PACKAGE_VERSION);
-
-    GST_BUFFER_FLAG_SET (vorbiscomment, GST_BUFFER_FLAG_IN_CAPS);
-
+  {
+    GstStructure *s;
+    GstBuffer *stream_hdr, *vorbiscomment;
+    const GstTagList *iface_tags;
+    GValue array = { 0, };
+    GValue value = { 0, };
+    s = gst_caps_get_structure (caps, 0);
+
+    /* put buffers in a fixed list */
+    g_value_init (&array, GST_TYPE_ARRAY);
     g_value_init (&value, GST_TYPE_BUFFER);
-    gst_value_set_buffer (&value, vorbiscomment);
+
+    /* Create Ogg stream-info */
+    stream_hdr = gst_buffer_new_and_alloc (26);
+    data = GST_BUFFER_DATA (stream_hdr);
+
+    GST_WRITE_UINT8 (data, 0x4F);
+    GST_WRITE_UINT32_BE (data + 1, 0x56503830); /* "VP80" */
+    GST_WRITE_UINT8 (data + 5, 0x01);   /* stream info header */
+    GST_WRITE_UINT8 (data + 6, 1);      /* Major version 1 */
+    GST_WRITE_UINT8 (data + 7, 0);      /* Minor version 0 */
+    GST_WRITE_UINT16_BE (data + 8, state->width);
+    GST_WRITE_UINT16_BE (data + 10, state->height);
+    GST_WRITE_UINT24_BE (data + 12, state->par_n);
+    GST_WRITE_UINT24_BE (data + 15, state->par_d);
+    GST_WRITE_UINT32_BE (data + 18, state->fps_n);
+    GST_WRITE_UINT32_BE (data + 22, state->fps_d);
+
+    GST_BUFFER_FLAG_SET (stream_hdr, GST_BUFFER_FLAG_IN_CAPS);
+    gst_value_set_buffer (&value, stream_hdr);
     gst_value_array_append_value (&array, &value);
     g_value_unset (&value);
-    gst_buffer_unref (vorbiscomment);
+    gst_buffer_unref (stream_hdr);
+
+    iface_tags =
+        gst_tag_setter_get_tag_list (GST_TAG_SETTER (base_video_encoder));
+    if (iface_tags) {
+      vorbiscomment =
+          gst_tag_list_to_vorbiscomment_buffer (iface_tags,
+          (const guint8 *) "OVP80\2 ", 7,
+          "Encoded with GStreamer vp8enc " PACKAGE_VERSION);
+
+      GST_BUFFER_FLAG_SET (vorbiscomment, GST_BUFFER_FLAG_IN_CAPS);
+
+      g_value_init (&value, GST_TYPE_BUFFER);
+      gst_value_set_buffer (&value, vorbiscomment);
+      gst_value_array_append_value (&array, &value);
+      g_value_unset (&value);
+      gst_buffer_unref (vorbiscomment);
+    }
+
+    gst_structure_set_value (s, "streamheader", &array);
+    g_value_unset (&array);
   }
 
-  gst_structure_set_value (s, "streamheader", &array);
-  g_value_unset (&array);
+  ret = gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (encoder), caps);
+  gst_caps_unref (caps);
 
-  return caps;
+  return ret;
 }
 
-static gboolean
-gst_vp8_enc_finish (GstBaseVideoEncoder * base_video_encoder)
+static GstFlowReturn
+gst_vp8_enc_process (GstVP8Enc * encoder)
 {
-  GstVP8Enc *encoder;
-  GstVideoFrame *frame;
-  int flags = 0;
-  vpx_codec_err_t status;
   vpx_codec_iter_t iter = NULL;
   const vpx_codec_cx_pkt_t *pkt;
+  GstBaseVideoEncoder *base_video_encoder;
+  GstVP8EncCoderHook *hook;
+  GstVideoFrame *frame;
+  GstFlowReturn ret = GST_FLOW_OK;
 
-  GST_DEBUG_OBJECT (base_video_encoder, "finish");
-
-  encoder = GST_VP8_ENC (base_video_encoder);
-
-  status =
-      vpx_codec_encode (&encoder->encoder, NULL, encoder->n_frames, 1, flags,
-      0);
-  if (status != 0) {
-    GST_ERROR_OBJECT (encoder, "encode returned %d %s", status,
-        gst_vpx_error_name (status));
-    return FALSE;
-  }
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (encoder);
 
   pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
   while (pkt != NULL) {
     GstBuffer *buffer;
-    GstVP8EncCoderHook *hook;
-    gboolean invisible, keyframe;
+    gboolean invisible;
 
     GST_DEBUG_OBJECT (encoder, "packet %u type %d", (guint) pkt->data.frame.sz,
         pkt->kind);
@@ -614,15 +980,14 @@ gst_vp8_enc_finish (GstBaseVideoEncoder * base_video_encoder)
     }
 
     invisible = (pkt->data.frame.flags & VPX_FRAME_IS_INVISIBLE) != 0;
-    keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
     frame = gst_base_video_encoder_get_oldest_frame (base_video_encoder);
     g_assert (frame != NULL);
+    frame->is_sync_point = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
     hook = frame->coder_hook;
 
     buffer = gst_buffer_new_and_alloc (pkt->data.frame.sz);
 
     memcpy (GST_BUFFER_DATA (buffer), pkt->data.frame.buf, pkt->data.frame.sz);
-    frame->is_sync_point = frame->is_sync_point || keyframe;
 
     if (hook->image)
       g_slice_free (vpx_image_t, hook->image);
@@ -632,13 +997,38 @@ gst_vp8_enc_finish (GstBaseVideoEncoder * base_video_encoder)
       hook->invisible = g_list_append (hook->invisible, buffer);
     } else {
       frame->src_buffer = buffer;
-      gst_base_video_encoder_finish_frame (base_video_encoder, frame);
-      frame = NULL;
+      ret = gst_base_video_encoder_finish_frame (base_video_encoder, frame);
     }
 
     pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
   }
 
+  return ret;
+}
+
+static GstFlowReturn
+gst_vp8_enc_finish (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstVP8Enc *encoder;
+  int flags = 0;
+  vpx_codec_err_t status;
+
+  GST_DEBUG_OBJECT (base_video_encoder, "finish");
+
+  encoder = GST_VP8_ENC (base_video_encoder);
+
+  status =
+      vpx_codec_encode (&encoder->encoder, NULL, encoder->n_frames, 1, flags,
+      0);
+  if (status != 0) {
+    GST_ERROR_OBJECT (encoder, "encode returned %d %s", status,
+        gst_vpx_error_name (status));
+    return GST_FLOW_ERROR;
+  }
+
+  /* dispatch remaining frames */
+  gst_vp8_enc_process (encoder);
+
   if (encoder->multipass_mode == VPX_RC_FIRST_PASS
       && encoder->multipass_cache_file) {
     GError *err = NULL;
@@ -652,49 +1042,26 @@ gst_vp8_enc_finish (GstBaseVideoEncoder * base_video_encoder)
     }
   }
 
-  return TRUE;
+  return GST_FLOW_OK;
 }
 
 static vpx_image_t *
 gst_vp8_enc_buffer_to_image (GstVP8Enc * enc, GstBuffer * buffer)
 {
-  vpx_image_t *image = g_slice_new0 (vpx_image_t);
+  vpx_image_t *image = g_slice_new (vpx_image_t);
   guint8 *data = GST_BUFFER_DATA (buffer);
-  GstVideoState *state = &GST_BASE_VIDEO_CODEC (enc)->state;
 
-  image->fmt = VPX_IMG_FMT_I420;
-  image->bps = 12;
-  image->x_chroma_shift = image->y_chroma_shift = 1;
-  image->img_data = data;
-  image->w = image->d_w = state->width;
-  image->h = image->d_h = state->height;
+  memcpy (image, &enc->image, sizeof (*image));
 
-  image->stride[VPX_PLANE_Y] =
-      gst_video_format_get_row_stride (state->format, 0, state->width);
-  image->stride[VPX_PLANE_U] =
-      gst_video_format_get_row_stride (state->format, 1, state->width);
-  image->stride[VPX_PLANE_V] =
-      gst_video_format_get_row_stride (state->format, 2, state->width);
-  image->planes[VPX_PLANE_Y] =
-      data + gst_video_format_get_component_offset (state->format, 0,
-      state->width, state->height);
-  image->planes[VPX_PLANE_U] =
-      data + gst_video_format_get_component_offset (state->format, 1,
-      state->width, state->height);
-  image->planes[VPX_PLANE_V] =
-      data + gst_video_format_get_component_offset (state->format, 2,
-      state->width, state->height);
+  image->img_data = data;
+  image->planes[VPX_PLANE_Y] += (data - (guint8 *) NULL);
+  image->planes[VPX_PLANE_U] += (data - (guint8 *) NULL);
+  image->planes[VPX_PLANE_V] += (data - (guint8 *) NULL);
 
   return image;
 }
 
-static const int speed_table[] = {
-  VPX_DL_BEST_QUALITY,
-  VPX_DL_GOOD_QUALITY,
-  VPX_DL_REALTIME,
-};
-
-static gboolean
+static GstFlowReturn
 gst_vp8_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
 {
@@ -702,10 +1069,9 @@ gst_vp8_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
   const GstVideoState *state;
   vpx_codec_err_t status;
   int flags = 0;
-  vpx_codec_iter_t iter = NULL;
-  const vpx_codec_cx_pkt_t *pkt;
   vpx_image_t *image;
   GstVP8EncCoderHook *hook;
+  int quality;
 
   GST_DEBUG_OBJECT (base_video_encoder, "handle_frame");
 
@@ -717,105 +1083,22 @@ gst_vp8_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
   GST_DEBUG_OBJECT (base_video_encoder, "size %d %d", state->width,
       state->height);
 
-  if (!encoder->inited) {
-    vpx_codec_enc_cfg_t cfg;
-
-    status = vpx_codec_enc_config_default (&vpx_codec_vp8_cx_algo, &cfg, 0);
-    if (status != VPX_CODEC_OK) {
-      GST_ELEMENT_ERROR (encoder, LIBRARY, INIT,
-          ("Failed to get default encoder configuration"), ("%s",
-              gst_vpx_error_name (status)));
-      return FALSE;
-    }
-
-    cfg.g_w = state->width;
-    cfg.g_h = state->height;
-    cfg.g_timebase.num = state->fps_d;
-    cfg.g_timebase.den = state->fps_n;
-
-    cfg.g_error_resilient = encoder->error_resilient;
-    cfg.g_lag_in_frames = encoder->max_latency;
-    cfg.g_threads = encoder->threads;
-    cfg.rc_end_usage = encoder->mode;
-    if (encoder->bitrate) {
-      cfg.rc_target_bitrate = encoder->bitrate / 1000;
-    } else {
-      cfg.rc_min_quantizer = 63 - encoder->quality * 5.0;
-      cfg.rc_max_quantizer = 63 - encoder->quality * 5.0;
-      cfg.rc_target_bitrate = encoder->bitrate;
-    }
-
-    cfg.kf_mode = VPX_KF_AUTO;
-    cfg.kf_min_dist = 0;
-    cfg.kf_max_dist = encoder->max_keyframe_distance;
-
-    cfg.g_pass = encoder->multipass_mode;
-    if (encoder->multipass_mode == VPX_RC_FIRST_PASS) {
-      encoder->first_pass_cache_content = g_byte_array_sized_new (4096);
-    } else if (encoder->multipass_mode == VPX_RC_LAST_PASS) {
-      GError *err = NULL;
-
-
-      if (!encoder->multipass_cache_file) {
-        GST_ELEMENT_ERROR (encoder, RESOURCE, OPEN_READ,
-            ("No multipass cache file provided"), (NULL));
-        return GST_FLOW_ERROR;
-      }
-
-      if (!g_file_get_contents (encoder->multipass_cache_file,
-              (gchar **) & encoder->last_pass_cache_content.buf,
-              &encoder->last_pass_cache_content.sz, &err)) {
-        GST_ELEMENT_ERROR (encoder, RESOURCE, OPEN_READ,
-            ("Failed to read multipass cache file provided"), ("%s",
-                err->message));
-        g_error_free (err);
-        return GST_FLOW_ERROR;
-      }
-      cfg.rc_twopass_stats_in = encoder->last_pass_cache_content;
-    }
-
-    status = vpx_codec_enc_init (&encoder->encoder, &vpx_codec_vp8_cx_algo,
-        &cfg, 0);
-    if (status != VPX_CODEC_OK) {
-      GST_ELEMENT_ERROR (encoder, LIBRARY, INIT,
-          ("Failed to initialize encoder"), ("%s",
-              gst_vpx_error_name (status)));
-      return GST_FLOW_ERROR;
-    }
-
-    status = vpx_codec_control (&encoder->encoder, VP8E_SET_CPUUSED, 0);
-    if (status != VPX_CODEC_OK) {
-      GST_WARNING_OBJECT (encoder, "Failed to set VP8E_SET_CPUUSED to 0: %s",
-          gst_vpx_error_name (status));
-    }
-
-    status =
-        vpx_codec_control (&encoder->encoder, VP8E_SET_ENABLEAUTOALTREF,
-        (encoder->auto_alt_ref_frames ? 1 : 0));
-    if (status != VPX_CODEC_OK) {
-      GST_WARNING_OBJECT (encoder,
-          "Failed to set VP8E_ENABLEAUTOALTREF to %d: %s",
-          (encoder->auto_alt_ref_frames ? 1 : 0), gst_vpx_error_name (status));
-    }
-
-    gst_base_video_encoder_set_latency (base_video_encoder, 0,
-        gst_util_uint64_scale (encoder->max_latency,
-            state->fps_d * GST_SECOND, state->fps_n));
-    encoder->inited = TRUE;
-  }
-
   image = gst_vp8_enc_buffer_to_image (encoder, frame->sink_buffer);
 
   hook = g_slice_new0 (GstVP8EncCoderHook);
   hook->image = image;
   frame->coder_hook = hook;
+  frame->coder_hook_destroy_notify =
+      (GDestroyNotify) gst_vp8_enc_coder_hook_free;
 
-  if (encoder->force_keyframe) {
+  if (frame->force_keyframe) {
     flags |= VPX_EFLAG_FORCE_KF;
   }
 
+  quality = (encoder->speed == 0) ? VPX_DL_BEST_QUALITY : VPX_DL_GOOD_QUALITY;
+
   status = vpx_codec_encode (&encoder->encoder, image,
-      encoder->n_frames, 1, flags, speed_table[encoder->speed]);
+      encoder->n_frames, 1, flags, quality);
   if (status != 0) {
     GST_ELEMENT_ERROR (encoder, LIBRARY, ENCODE,
         ("Failed to encode frame"), ("%s", gst_vpx_error_name (status)));
@@ -825,62 +1108,7 @@ gst_vp8_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
     return FALSE;
   }
 
-  pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
-  while (pkt != NULL) {
-    GstBuffer *buffer;
-    gboolean invisible;
-
-    GST_DEBUG_OBJECT (encoder, "packet %u type %d", (guint) pkt->data.frame.sz,
-        pkt->kind);
-
-    if (pkt->kind == VPX_CODEC_STATS_PKT
-        && encoder->multipass_mode == VPX_RC_FIRST_PASS) {
-      GST_LOG_OBJECT (encoder, "handling STATS packet");
-
-      g_byte_array_append (encoder->first_pass_cache_content,
-          pkt->data.twopass_stats.buf, pkt->data.twopass_stats.sz);
-
-      frame = gst_base_video_encoder_get_oldest_frame (base_video_encoder);
-      if (frame != NULL) {
-        buffer = gst_buffer_new ();
-        GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_PREROLL);
-        frame->src_buffer = buffer;
-        gst_base_video_encoder_finish_frame (base_video_encoder, frame);
-      }
-
-      pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
-      continue;
-    } else if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) {
-      GST_LOG_OBJECT (encoder, "non frame pkt: %d", pkt->kind);
-      pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
-      continue;
-    }
-
-    invisible = (pkt->data.frame.flags & VPX_FRAME_IS_INVISIBLE) != 0;
-    frame = gst_base_video_encoder_get_oldest_frame (base_video_encoder);
-    g_assert (frame != NULL);
-    frame->is_sync_point = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
-    hook = frame->coder_hook;
-
-    buffer = gst_buffer_new_and_alloc (pkt->data.frame.sz);
-
-    memcpy (GST_BUFFER_DATA (buffer), pkt->data.frame.buf, pkt->data.frame.sz);
-
-    if (hook->image)
-      g_slice_free (vpx_image_t, hook->image);
-    hook->image = NULL;
-
-    if (invisible) {
-      hook->invisible = g_list_append (hook->invisible, buffer);
-    } else {
-      frame->src_buffer = buffer;
-      gst_base_video_encoder_finish_frame (base_video_encoder, frame);
-    }
-
-    pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
-  }
-
-  return TRUE;
+  return gst_vp8_enc_process (encoder);
 }
 
 static guint64
@@ -895,13 +1123,6 @@ _to_granulepos (guint64 frame_end_number, guint inv_count, guint keyframe_dist)
   return granulepos;
 }
 
-static void
-_gst_mini_object_unref0 (GstMiniObject * obj)
-{
-  if (obj)
-    gst_mini_object_unref (obj);
-}
-
 static GstFlowReturn
 gst_vp8_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
     GstVideoFrame * frame)
@@ -934,6 +1155,8 @@ gst_vp8_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
       encoder->keyframe_distance++;
     }
 
+    GST_BUFFER_TIMESTAMP (buf) = GST_BUFFER_TIMESTAMP (frame->src_buffer);
+    GST_BUFFER_DURATION (buf) = 0;
     GST_BUFFER_OFFSET_END (buf) =
         _to_granulepos (frame->presentation_frame_number + 1,
         inv_count, encoder->keyframe_distance);
@@ -941,7 +1164,8 @@ gst_vp8_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
         gst_util_uint64_scale (frame->presentation_frame_number + 1,
         GST_SECOND * state->fps_d, state->fps_n);
 
-    gst_buffer_set_caps (buf, GST_BASE_VIDEO_CODEC (base_video_encoder)->caps);
+    gst_buffer_set_caps (buf,
+        GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
     ret = gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
 
     if (ret != GST_FLOW_OK) {
@@ -974,21 +1198,13 @@ gst_vp8_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
   }
 
 done:
-  if (hook) {
-    g_list_foreach (hook->invisible, (GFunc) _gst_mini_object_unref0, NULL);
-    g_list_free (hook->invisible);
-    g_slice_free (GstVP8EncCoderHook, hook);
-    frame->coder_hook = NULL;
-  }
-
   return ret;
 }
 
 static gboolean
-gst_vp8_enc_sink_event (GstPad * pad, GstEvent * event)
+gst_vp8_enc_sink_event (GstBaseVideoEncoder * benc, GstEvent * event)
 {
-  GstVP8Enc *enc = GST_VP8_ENC (gst_pad_get_parent (pad));
-  gboolean ret;
+  GstVP8Enc *enc = GST_VP8_ENC (benc);
 
   if (GST_EVENT_TYPE (event) == GST_EVENT_TAG) {
     GstTagList *list;
@@ -999,10 +1215,8 @@ gst_vp8_enc_sink_event (GstPad * pad, GstEvent * event)
     gst_tag_setter_merge_tags (setter, list, mode);
   }
 
-  ret = enc->base_sink_event_func (pad, event);
-  gst_object_unref (enc);
-
-  return ret;
+  /* just peeked, baseclass handles the rest */
+  return FALSE;
 }
 
 #endif /* HAVE_VP8_ENCODER */
diff --git a/ext/vp8/gstvp8enc.h b/ext/vp8/gstvp8enc.h
index 0a21647..3b01512 100644
--- a/ext/vp8/gstvp8enc.h
+++ b/ext/vp8/gstvp8enc.h
@@ -60,6 +60,10 @@ struct _GstVP8Enc
   /* properties */
   int bitrate;
   enum vpx_rc_mode mode;
+  unsigned int minsection_pct;
+  unsigned int maxsection_pct;
+  int min_quantizer;
+  int max_quantizer;
   double quality;
   gboolean error_resilient;
   int max_latency;
@@ -71,16 +75,24 @@ struct _GstVP8Enc
   GByteArray *first_pass_cache_content;
   vpx_fixed_buf_t last_pass_cache_content;
   gboolean auto_alt_ref_frames;
+  unsigned int lag_in_frames;
+  int sharpness;
+  int noise_sensitivity;
+#ifdef HAVE_VP8ENC_TUNING
+  vp8e_tuning tuning;
+#endif
+  int static_threshold;
+  gboolean drop_frame;
+  gboolean resize_allowed;
+  gboolean partitions;
 
   /* state */
-  gboolean force_keyframe;
   gboolean inited;
 
+  vpx_image_t image;
+
   int n_frames;
   int keyframe_distance;
-
-  /* FIXME: Get a event vfunc in BaseVideoEncoder */
-  GstPadEventFunction base_sink_event_func;
 };
 
 struct _GstVP8EncClass
-- 
1.7.5.4

