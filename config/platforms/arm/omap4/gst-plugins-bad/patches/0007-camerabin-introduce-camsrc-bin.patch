From e6f36bbb5e85d8bcbeac4efe94c35f573a33ec0b Mon Sep 17 00:00:00 2001
From: Rob Clark <rob@ti.com>
Date: Sun, 11 Jul 2010 17:58:39 -0500
Subject: [PATCH 7/8] camerabin: introduce camsrc bin

Introduce camsrc bin with different src pads for viewfinder, video capture,
and image capture.  All the input-selects/output-selects/tees for buffer
routing in various camera modes are instead replaced with a single srcbin.
A base class (GstBaseCameraSrc) in gst-libs provides an easier way to
plugin different camera elements, such as camera elements that can already
provide multiple outputs at different resolutions (for example, high mpix
still image capture in parallel with downscaled viewfinder buffer).  A
subclass for v4l2src (GstV4l2CameraSrc) is provided for compatibility with
standard v4l2 cameras.

See: http://gstreamer.freedesktop.org/wiki/CameraBin
---
 configure.ac                               |    1 +
 gst-libs/gst/Makefile.am                   |    4 +-
 gst-libs/gst/camerasrc/Makefile.am         |   22 +
 gst-libs/gst/camerasrc/README              |    8 +
 gst-libs/gst/camerasrc/gstbasecamerasrc.c  |  509 +++++++++++
 gst-libs/gst/camerasrc/gstbasecamerasrc.h  |  146 ++++
 gst-libs/gst/camerasrc/gstcamerabin-enum.c |   78 ++
 gst-libs/gst/camerasrc/gstcamerabin-enum.h |  140 +++
 gst/camerabin/Makefile.am                  |    6 +-
 gst/camerabin/camerabingeneral.c           |   33 +-
 gst/camerabin/camerabingeneral.h           |    4 +-
 gst/camerabin/camerabinimage.c             |    1 -
 gst/camerabin/camerabinimage.h             |    2 +-
 gst/camerabin/camerabinvideo.c             |   89 +--
 gst/camerabin/camerabinvideo.h             |   12 +-
 gst/camerabin/gstcamerabin-enum.c          |   59 --
 gst/camerabin/gstcamerabin-enum.h          |  105 ---
 gst/camerabin/gstcamerabin.c               | 1304 +++-------------------------
 gst/camerabin/gstcamerabin.h               |   71 +--
 gst/camerabin/gstcamerabincolorbalance.c   |   19 +-
 gst/camerabin/gstcamerabinphotography.c    |  227 +++--
 gst/camerabin/gstv4l2camerasrc.c           | 1073 +++++++++++++++++++++++
 gst/camerabin/gstv4l2camerasrc.h           |  113 +++
 23 files changed, 2423 insertions(+), 1603 deletions(-)
 create mode 100644 gst-libs/gst/camerasrc/Makefile.am
 create mode 100644 gst-libs/gst/camerasrc/README
 create mode 100644 gst-libs/gst/camerasrc/gstbasecamerasrc.c
 create mode 100644 gst-libs/gst/camerasrc/gstbasecamerasrc.h
 create mode 100644 gst-libs/gst/camerasrc/gstcamerabin-enum.c
 create mode 100644 gst-libs/gst/camerasrc/gstcamerabin-enum.h
 delete mode 100644 gst/camerabin/gstcamerabin-enum.c
 delete mode 100644 gst/camerabin/gstcamerabin-enum.h
 create mode 100644 gst/camerabin/gstv4l2camerasrc.c
 create mode 100644 gst/camerabin/gstv4l2camerasrc.h

diff --git a/configure.ac b/configure.ac
index 10fb2c8..b5ded86 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1739,6 +1739,7 @@ gst-libs/gst/Makefile
 gst-libs/gst/interfaces/Makefile
 gst-libs/gst/signalprocessor/Makefile
 gst-libs/gst/video/Makefile
+gst-libs/gst/camerasrc/Makefile
 sys/Makefile
 sys/dshowdecwrapper/Makefile
 sys/acmenc/Makefile
diff --git a/gst-libs/gst/Makefile.am b/gst-libs/gst/Makefile.am
index e48cdd8..75e73a5 100644
--- a/gst-libs/gst/Makefile.am
+++ b/gst-libs/gst/Makefile.am
@@ -1,5 +1,5 @@
 
-SUBDIRS = interfaces signalprocessor video
+SUBDIRS = interfaces signalprocessor video camerasrc
 
 noinst_HEADERS = gst-i18n-plugin.h gettext.h
-DIST_SUBDIRS = interfaces signalprocessor video
+DIST_SUBDIRS = interfaces signalprocessor video camerasrc
diff --git a/gst-libs/gst/camerasrc/Makefile.am b/gst-libs/gst/camerasrc/Makefile.am
new file mode 100644
index 0000000..6d5e0fe
--- /dev/null
+++ b/gst-libs/gst/camerasrc/Makefile.am
@@ -0,0 +1,22 @@
+
+lib_LTLIBRARIES = libgstcamerasrc-@GST_MAJORMINOR@.la
+
+CLEANFILES = $(BUILT_SOURCES)
+
+libgstcamerasrc_@GST_MAJORMINOR@_la_SOURCES = \
+	gstcamerabin-enum.c \
+	gstbasecamerasrc.c
+
+libgstcamerasrc_@GST_MAJORMINOR@includedir = $(includedir)/gstreamer-@GST_MAJORMINOR@/gst/camerasrc
+libgstcamerasrc_@GST_MAJORMINOR@include_HEADERS = \
+	gstcamerabin-enum.h \
+	gstbasecamerasrc.h
+
+libgstcamerasrc_@GST_MAJORMINOR@_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) -DGST_USE_UNSTABLE_API
+libgstcamerasrc_@GST_MAJORMINOR@_la_LIBADD = \
+	$(top_builddir)/gst-libs/gst/interfaces/libgstphotography-$(GST_MAJORMINOR).la \
+	$(GST_LIBS) $(GST_BASE_LIBS) $(GST_PLUGINS_BASE_LIBS) \
+	-lgstinterfaces-$(GST_MAJORMINOR)
+
+libgstcamerasrc_@GST_MAJORMINOR@_la_LDFLAGS = $(GST_LIB_LDFLAGS) $(GST_ALL_LDFLAGS) $(GST_LT_LDFLAGS)
+
diff --git a/gst-libs/gst/camerasrc/README b/gst-libs/gst/camerasrc/README
new file mode 100644
index 0000000..7c76df6
--- /dev/null
+++ b/gst-libs/gst/camerasrc/README
@@ -0,0 +1,8 @@
+This directory contains GstBaseCameraSrc element used by camerabin, as well
+as a default implementation of GstSimpleV4l2CameraSrc
+
+(or should GstSimpleV4l2CameraSrc go in camerabin?  I don't quite see the
+use case to further subclass GstSimpleV4l2CameraSrc, although that doesn't
+necessarily mean that there isn't one..)
+
+See http://gstreamer.freedesktop.org/wiki/CameraBin
diff --git a/gst-libs/gst/camerasrc/gstbasecamerasrc.c b/gst-libs/gst/camerasrc/gstbasecamerasrc.c
new file mode 100644
index 0000000..aba756e
--- /dev/null
+++ b/gst-libs/gst/camerasrc/gstbasecamerasrc.c
@@ -0,0 +1,509 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+
+/**
+ * SECTION:element-basecamerasrc
+ *
+ * Base class for the camera src bin used by camerabin.  Indented to be
+ * subclassed when plugging in more sophisticated cameras.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include "gstbasecamerasrc.h"
+
+GST_DEBUG_CATEGORY (base_camera_src_debug);
+#define GST_CAT_DEFAULT base_camera_src_debug
+
+GST_BOILERPLATE (GstBaseCameraSrc, gst_base_camera_src, GstBin, GST_TYPE_BIN);
+
+static GstStaticPadTemplate vfsrc_template = GST_STATIC_PAD_TEMPLATE ("vfsrc",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate imgsrc_template = GST_STATIC_PAD_TEMPLATE ("imgsrc",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate vidsrc_template = GST_STATIC_PAD_TEMPLATE ("vidsrc",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+/* note: we could provide a vmethod for derived class to overload to provide
+ * it's own implementation of interface..  but in all cases I can think of at
+ * moment, either the camerasrc itself, or some element within the bin, will
+ * be implementing the interface..
+ */
+
+/**
+ * gst_base_camera_src_get_photography:
+ * @self: the camerasrc bin
+ *
+ * Get object implementing photography interface, if there is one.  Otherwise
+ * returns NULL.
+ */
+GstPhotography *
+gst_base_camera_src_get_photography (GstBaseCameraSrc * self)
+{
+  GstElement *elem;
+
+  if (GST_IS_PHOTOGRAPHY (self)) {
+    elem = GST_ELEMENT (self);
+  } else {
+    elem = gst_bin_get_by_interface (GST_BIN (self), GST_TYPE_PHOTOGRAPHY);
+  }
+
+  if (elem) {
+    return GST_PHOTOGRAPHY (self);
+  }
+
+  return NULL;
+}
+
+
+/**
+ * gst_base_camera_src_get_colorbalance:
+ * @self: the camerasrc bin
+ *
+ * Get object implementing colorbalance interface, if there is one.  Otherwise
+ * returns NULL.
+ */
+GstColorBalance *
+gst_base_camera_src_get_color_balance (GstBaseCameraSrc * self)
+{
+  GstElement *elem;
+
+  if (GST_IS_COLOR_BALANCE (self)) {
+    elem = GST_ELEMENT (self);
+  } else {
+    elem = gst_bin_get_by_interface (GST_BIN (self), GST_TYPE_COLOR_BALANCE);
+  }
+
+  if (elem) {
+    return GST_COLOR_BALANCE (self);
+  }
+
+  return NULL;
+}
+
+/**
+ * gst_base_camera_src_set_mode:
+ * @self: the camerasrc bin
+ * @mode: the mode
+ *
+ * XXX
+ */
+gboolean
+gst_base_camera_src_set_mode (GstBaseCameraSrc * self, GstCameraBinMode mode)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  g_return_val_if_fail (bclass->set_mode, FALSE);
+
+  return bclass->set_mode (self, mode);
+}
+
+/**
+ * gst_base_camera_src_setup_zoom:
+ * @self: camerasrc object
+ *
+ * Apply zoom configured to camerabin to capture.
+ */
+void
+gst_base_camera_src_setup_zoom (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+  gint zoom;
+
+  zoom = g_atomic_int_get (&self->zoom);
+
+  g_return_if_fail (zoom);
+  g_return_if_fail (bclass->set_zoom);
+
+  bclass->set_zoom (self, zoom);
+}
+
+
+/**
+ * gst_base_camera_src_get_allowed_input_caps:
+ * @self: the camerasrc bin
+ *
+ * Retrieve caps from videosrc describing formats it supports
+ *
+ * Returns: caps object from videosrc
+ */
+GstCaps *
+gst_base_camera_src_get_allowed_input_caps (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  g_return_val_if_fail (bclass->get_allowed_input_caps, NULL);
+
+  return bclass->get_allowed_input_caps (self);
+}
+
+/**
+ * gst_base_camera_src_finish_image_capture:
+ * @self: camerasrc object
+ *
+ * Perform finishing operations after image capture is done and
+ * returning back to view finder mode.
+ */
+void
+gst_base_camera_src_finish_image_capture (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  if (bclass->finish_image_capture) {
+    bclass->finish_image_capture (self);
+  }
+}
+
+/**
+ * gst_base_camera_src_find_better_framerate:
+ * @self: camerasrc object
+ * @st: structure that contains framerate candidates
+ * @orig_framerate: best framerate so far
+ *
+ * Looks for framerate better than @orig_framerate from @st structure.
+ * In night mode lowest framerate is considered best, otherwise highest is
+ * best.
+ *
+ * Returns: @orig_framerate or better if found
+ */
+const GValue *
+gst_base_camera_src_find_better_framerate (GstBaseCameraSrc * self,
+    GstStructure * st, const GValue * orig_framerate)
+{
+  const GValue *framerate = NULL;
+  guint i, i_best, list_size;
+  gint res, comparison;
+
+  if (self->night_mode) {
+    GST_LOG_OBJECT (self, "finding min framerate in %" GST_PTR_FORMAT, st);
+    comparison = GST_VALUE_LESS_THAN;
+  } else {
+    GST_LOG_OBJECT (self, "finding max framerate in %" GST_PTR_FORMAT, st);
+    comparison = GST_VALUE_GREATER_THAN;
+  }
+
+  if (gst_structure_has_field (st, "framerate")) {
+    framerate = gst_structure_get_value (st, "framerate");
+    /* Handle framerate lists */
+    if (GST_VALUE_HOLDS_LIST (framerate)) {
+      list_size = gst_value_list_get_size (framerate);
+      GST_LOG_OBJECT (self, "finding framerate from list");
+      for (i = 0, i_best = 0; i < list_size; i++) {
+        res = gst_value_compare (gst_value_list_get_value (framerate, i),
+            gst_value_list_get_value (framerate, i_best));
+        if (comparison == res) {
+          i_best = i;
+        }
+      }
+      GST_LOG_OBJECT (self, "found best framerate from index %d", i_best);
+      framerate = gst_value_list_get_value (framerate, i_best);
+    }
+    /* Handle framerate ranges */
+    if (GST_VALUE_HOLDS_FRACTION_RANGE (framerate)) {
+      if (self->night_mode) {
+        GST_LOG_OBJECT (self, "getting min framerate from range");
+        framerate = gst_value_get_fraction_range_min (framerate);
+      } else {
+        GST_LOG_OBJECT (self, "getting max framerate from range");
+        framerate = gst_value_get_fraction_range_max (framerate);
+      }
+    }
+  }
+
+  /* Check if we found better framerate */
+  if (orig_framerate && framerate) {
+    res = gst_value_compare (orig_framerate, framerate);
+    if (comparison == res) {
+      GST_LOG_OBJECT (self, "original framerate was the best");
+      framerate = orig_framerate;
+    }
+  }
+
+  return framerate;
+}
+
+/**
+ *
+ */
+static void
+gst_base_camera_src_dispose (GObject * object)
+{
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gst_base_camera_src_finalize (GstBaseCameraSrc * self)
+{
+  G_OBJECT_CLASS (parent_class)->finalize ((GObject *) (self));
+}
+
+static void
+gst_base_camera_src_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstBaseCameraSrc *self = GST_BASE_CAMERA_SRC (object);
+
+  switch (prop_id) {
+    case ARG_ZOOM:{
+      g_atomic_int_set (&self->zoom, g_value_get_int (value));
+      /* does not set it if in NULL, the src is not created yet */
+      if (GST_STATE (self) != GST_STATE_NULL)
+        gst_base_camera_src_setup_zoom (self);
+      break;
+    }
+    case ARG_IMAGE_CAPTURE_WIDTH:{
+      gint width = g_value_get_int (value);
+
+      if (width != self->image_capture_width) {
+        self->image_capture_width = width;
+//XXX        self->image_capture_caps_update = TRUE;
+      }
+      break;
+    }
+    case ARG_IMAGE_CAPTURE_HEIGHT:{
+      gint height = g_value_get_int (value);
+
+      if (height != self->image_capture_height) {
+        self->image_capture_height = height;
+//XXX        self->image_capture_caps_update = TRUE;
+      }
+      break;
+    }
+    case ARG_VIDEO_CAPTURE_WIDTH:{
+      gint width = g_value_get_int (value);
+
+      if (width != self->width) {
+        self->width = width;
+//XXX        self->video_capture_caps_update = TRUE;
+      }
+      break;
+    }
+    case ARG_VIDEO_CAPTURE_HEIGHT:{
+      gint height = g_value_get_int (value);
+
+      if (height != self->height) {
+        self->height = height;
+//XXX        self->video_capture_caps_update = TRUE;
+      }
+      break;
+    }
+    case ARG_VIDEO_CAPTURE_FRAMERATE:{
+      gint fps_n, fps_d;
+
+      fps_n = gst_value_get_fraction_numerator (value);
+      fps_d = gst_value_get_fraction_denominator (value);
+
+      if (fps_n != self->fps_n || fps_d != self->fps_d) {
+        self->fps_n = fps_n;
+        self->fps_d = fps_d;
+//XXX        self->video_capture_caps_update = TRUE;
+      }
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_base_camera_src_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstBaseCameraSrc *self = GST_BASE_CAMERA_SRC (object);
+
+  switch (prop_id) {
+    case ARG_ZOOM:
+      g_value_set_int (value, g_atomic_int_get (&self->zoom));
+      break;
+    case ARG_IMAGE_CAPTURE_WIDTH:
+      g_value_set_int (value, self->image_capture_width);
+      break;
+    case ARG_IMAGE_CAPTURE_HEIGHT:
+      g_value_set_int (value, self->image_capture_height);
+      break;
+    case ARG_VIDEO_CAPTURE_WIDTH:
+      g_value_set_int (value, self->width);
+      break;
+    case ARG_VIDEO_CAPTURE_HEIGHT:
+      g_value_set_int (value, self->height);
+      break;
+    case ARG_VIDEO_CAPTURE_FRAMERATE:
+      gst_value_set_fraction (value, self->fps_n, self->fps_d);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+construct_pipeline (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+  GstPad *vfsrc = NULL;
+  GstPad *imgsrc = NULL;
+  GstPad *vidsrc = NULL;
+
+  g_return_val_if_fail (bclass->construct_pipeline, FALSE);
+
+  if (!bclass->construct_pipeline (self, &vfsrc, &imgsrc, &vidsrc)) {
+    GST_ERROR_OBJECT (self, "pipeline construction failed");
+    return FALSE;
+  }
+
+  if (!vfsrc || !imgsrc || !vidsrc) {
+    GST_ERROR_OBJECT (self, "derived class must return src pads");
+    return FALSE;
+  }
+
+  GST_DEBUG_OBJECT (self, "vfsrc:  %" GST_PTR_FORMAT, vfsrc);
+  GST_DEBUG_OBJECT (self, "imgsrc: %" GST_PTR_FORMAT, imgsrc);
+  GST_DEBUG_OBJECT (self, "vidsrc: %" GST_PTR_FORMAT, vidsrc);
+
+  /* hook-up the ghostpads */
+  gst_ghost_pad_set_target (GST_GHOST_PAD (self->vfsrc), vfsrc);
+  gst_ghost_pad_set_target (GST_GHOST_PAD (self->imgsrc), imgsrc);
+  gst_ghost_pad_set_target (GST_GHOST_PAD (self->vidsrc), vidsrc);
+
+  gst_pad_set_active (self->vfsrc, TRUE);
+  gst_pad_set_active (self->imgsrc, TRUE);      /* XXX ??? */
+  gst_pad_set_active (self->vidsrc, TRUE);      /* XXX ??? */
+
+  return TRUE;
+}
+
+static gboolean
+setup_pipeline (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+  if (bclass->setup_pipeline)
+    return bclass->setup_pipeline (self);
+  return TRUE;
+}
+
+static GstStateChangeReturn
+gst_base_camera_src_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstBaseCameraSrc *self = GST_BASE_CAMERA_SRC (element);
+
+  GST_DEBUG_OBJECT (self, "%d -> %d",
+      GST_STATE_TRANSITION_CURRENT (transition),
+      GST_STATE_TRANSITION_NEXT (transition));
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!construct_pipeline (self))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (!setup_pipeline (self))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return ret;
+}
+
+static void
+gst_base_camera_src_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  GST_DEBUG_CATEGORY_INIT (base_camera_src_debug, "base_camera_src", 0,
+      "Base camera src");
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "Base class for camerabin src bin", "Source/Video",
+      "Abstracts capture device for camerabin", "Rob Clark <rob@ti.com>");
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&vfsrc_template));
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&imgsrc_template));
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&vidsrc_template));
+}
+
+static void
+gst_base_camera_src_class_init (GstBaseCameraSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->dispose = gst_base_camera_src_dispose;
+  gobject_class->finalize = (GObjectFinalizeFunc) gst_base_camera_src_finalize;
+  gobject_class->set_property = gst_base_camera_src_set_property;
+  gobject_class->get_property = gst_base_camera_src_get_property;
+
+  // g_object_class_install_property ....
+
+  gstelement_class->change_state = gst_base_camera_src_change_state;
+
+}
+
+static void
+gst_base_camera_src_init (GstBaseCameraSrc * self,
+    GstBaseCameraSrcClass * klass)
+{
+  self->vfsrc = gst_ghost_pad_new_no_target ("vfsrc", GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->vfsrc);
+
+  self->imgsrc = gst_ghost_pad_new_no_target ("imgsrc", GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->imgsrc);
+
+  self->vidsrc = gst_ghost_pad_new_no_target ("vidsrc", GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->vidsrc);
+
+  self->width = DEFAULT_WIDTH;
+  self->height = DEFAULT_HEIGHT;
+  self->zoom = DEFAULT_ZOOM;
+  self->image_capture_width = 0;
+  self->image_capture_height = 0;
+
+  self->night_mode = FALSE;
+
+  self->fps_n = DEFAULT_FPS_N;
+  self->fps_d = DEFAULT_FPS_D;
+}
diff --git a/gst-libs/gst/camerasrc/gstbasecamerasrc.h b/gst-libs/gst/camerasrc/gstbasecamerasrc.h
new file mode 100644
index 0000000..12b91dd
--- /dev/null
+++ b/gst-libs/gst/camerasrc/gstbasecamerasrc.h
@@ -0,0 +1,146 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef __GST_BASE_CAMERA_SRC_H__
+#define __GST_BASE_CAMERA_SRC_H__
+
+#include <gst/gst.h>
+#include <gst/gstbin.h>
+#include "gstcamerabin-enum.h"
+#include <gst/interfaces/photography.h>
+#include <gst/interfaces/colorbalance.h>
+
+G_BEGIN_DECLS
+#define GST_TYPE_BASE_CAMERA_SRC \
+  (gst_base_camera_src_get_type())
+#define GST_BASE_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_CAMERA_SRC,GstBaseCameraSrc))
+#define GST_BASE_CAMERA_SRC_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_BASE_CAMERA_SRC, GstBaseCameraSrcClass))
+#define GST_BASE_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_CAMERA_SRC,GstBaseCameraSrcClass))
+#define GST_IS_BASE_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_CAMERA_SRC))
+#define GST_IS_BASE_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_CAMERA_SRC))
+    GType gst_base_camera_src_get_type (void);
+
+typedef struct _GstBaseCameraSrc GstBaseCameraSrc;
+typedef struct _GstBaseCameraSrcClass GstBaseCameraSrcClass;
+
+
+/**
+ * GstBaseCameraSrc:
+ */
+struct _GstBaseCameraSrc
+{
+  GstBin parent;
+
+  GstPad *vfsrc;
+  GstPad *imgsrc;
+  GstPad *vidsrc;
+
+  /* XXX preview pads? */
+
+  /* Resolution of the buffers configured to camerabin */
+  gint width;
+  gint height;
+
+  /* The digital zoom (from 100% to 1000%) */
+  gint zoom;
+
+  /* Image capture resolution */
+  gint image_capture_width;
+  gint image_capture_height;
+
+  /* Frames per second configured to camerabin */
+  gint fps_n;
+  gint fps_d;
+
+  /* Night mode handling */
+  gboolean night_mode;
+  gint pre_night_fps_n;
+  gint pre_night_fps_d;
+
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+
+/**
+ * GstBaseCameraSrcClass:
+ * @construct_pipeline: construct pipeline must be implemented by derived
+ *    class, and return by reference vfsrc, imgsrc, and vidsrc pads of the
+ *    contained pipeline, which will be ghosted to the src pads of the
+ *    camerasrc bin (and optionally the preview src pads?)
+ * @setup_pipeline:
+ * @set_zoom: set the zoom
+ * @set_mode: set the mode
+ */
+struct _GstBaseCameraSrcClass
+{
+  GstBinClass parent;
+
+  /* construct pipeline must be implemented by derived class, and return by
+   * reference vfsrc, imgsrc, and vidsrc pads of the contained pipeline, which
+   * will be ghosted to the src pads of the camerasrc bin (and optionally the
+   * preview src pads?) */
+  gboolean    (*construct_pipeline)  (GstBaseCameraSrc *self,
+                                      GstPad **vfsrc, GstPad **imgsrc,
+                                      GstPad **vidsrc);
+
+  /* optional */
+  gboolean    (*setup_pipeline)      (GstBaseCameraSrc *self);
+
+  /* set the zoom */
+  void        (*set_zoom)            (GstBaseCameraSrc *self, gint zoom);
+
+  /* set the mode */
+  gboolean    (*set_mode)            (GstBaseCameraSrc *self,
+                                      GstCameraBinMode mode);
+
+  /* */
+  GstCaps *   (*get_allowed_input_caps) (GstBaseCameraSrc * self);
+
+  /* optional */
+  void        (*finish_image_capture) (GstBaseCameraSrc * self);
+
+
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+
+#define MIN_ZOOM 100
+#define MAX_ZOOM 1000
+#define ZOOM_1X MIN_ZOOM
+
+GstPhotography * gst_base_camera_src_get_photography (GstBaseCameraSrc *self);
+GstColorBalance * gst_base_camera_src_get_color_balance (GstBaseCameraSrc *self);
+
+gboolean gst_base_camera_src_set_mode (GstBaseCameraSrc *self, GstCameraBinMode mode);
+void gst_base_camera_src_setup_zoom (GstBaseCameraSrc * self);
+GstCaps * gst_base_camera_src_get_allowed_input_caps (GstBaseCameraSrc * self);
+void gst_base_camera_src_finish_image_capture (GstBaseCameraSrc * self);
+const GValue * gst_base_camera_src_find_better_framerate (
+    GstBaseCameraSrc * self, GstStructure * st, const GValue * orig_framerate);
+
+// XXX add methods to get/set img capture and vid capture caps..
+
+#endif /* __GST_BASE_CAMERA_SRC_H__ */
diff --git a/gst-libs/gst/camerasrc/gstcamerabin-enum.c b/gst-libs/gst/camerasrc/gstcamerabin-enum.c
new file mode 100644
index 0000000..8d1d0c9
--- /dev/null
+++ b/gst-libs/gst/camerasrc/gstcamerabin-enum.c
@@ -0,0 +1,78 @@
+/*
+ * GStreamer
+ * Copyright (C) 2009 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "gstcamerabin-enum.h"
+
+#define C_FLAGS(v) ((guint) v)
+
+static void
+register_gst_camerabin_flags (GType * id)
+{
+  static const GFlagsValue values[] = {
+    {C_FLAGS (GST_CAMERABIN_FLAG_SOURCE_RESIZE),
+        "Enable source crop and scale", "source-resize"},
+    {C_FLAGS (GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION),
+          "Enable colorspace conversion for video source",
+        "source-colorspace-conversion"},
+    {C_FLAGS (GST_CAMERABIN_FLAG_VIEWFINDER_COLOR_CONVERSION),
+          "Enable colorspace conversion for viewfinder",
+        "viewfinder-colorspace-conversion"},
+    {C_FLAGS (GST_CAMERABIN_FLAG_VIEWFINDER_SCALE),
+        "Enable scale for viewfinder", "viewfinder-scale"},
+    {C_FLAGS (GST_CAMERABIN_FLAG_AUDIO_CONVERSION),
+        "Enable audio conversion for video capture", "audio-conversion"},
+    {C_FLAGS (GST_CAMERABIN_FLAG_DISABLE_AUDIO),
+        "Disable audio elements for video capture", "disable-audio"},
+    {C_FLAGS (GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION),
+          "Enable colorspace conversion for still image",
+        "image-colorspace-conversion"},
+    {0, NULL, NULL}
+  };
+  *id = g_flags_register_static ("GstCameraBinFlags", values);
+}
+
+GType
+gst_camerabin_flags_get_type (void)
+{
+  static GType id;
+  static GOnce once = G_ONCE_INIT;
+
+  g_once (&once, (GThreadFunc) register_gst_camerabin_flags, &id);
+  return id;
+}
+
+
+GType
+gst_camerabin_mode_get_type (void)
+{
+  static GType gtype = 0;
+
+  if (gtype == 0) {
+    static const GEnumValue values[] = {
+      {MODE_PREVIEW, "Preview mode (should be default?)", "mode-preview"},
+      {MODE_IMAGE, "Still image capture (default)", "mode-image"},
+      {MODE_VIDEO, "Video recording", "mode-video"},
+      {0, NULL, NULL}
+    };
+
+    gtype = g_enum_register_static ("GstCameraBinMode", values);
+  }
+  return gtype;
+}
diff --git a/gst-libs/gst/camerasrc/gstcamerabin-enum.h b/gst-libs/gst/camerasrc/gstcamerabin-enum.h
new file mode 100644
index 0000000..cd1707d
--- /dev/null
+++ b/gst-libs/gst/camerasrc/gstcamerabin-enum.h
@@ -0,0 +1,140 @@
+/*
+ * GStreamer
+ * Copyright (C) 2009 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_CAMERABIN_ENUM_H__
+#define __GST_CAMERABIN_ENUM_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+/* XXX find better place for property related enum/defaults */
+enum
+{
+  ARG_0,
+  ARG_FILENAME,
+  ARG_MODE,
+  ARG_FLAGS,
+  ARG_MUTE,
+  ARG_ZOOM,
+  ARG_IMAGE_POST,
+  ARG_IMAGE_ENC,
+  ARG_VIDEO_POST,
+  ARG_VIDEO_ENC,
+  ARG_AUDIO_ENC,
+  ARG_VIDEO_MUX,
+  ARG_VF_SINK,
+  ARG_VIDEO_SRC,
+  ARG_AUDIO_SRC,
+  ARG_INPUT_CAPS,
+  ARG_FILTER_CAPS,
+  ARG_PREVIEW_CAPS,
+  ARG_WB_MODE,
+  ARG_COLOUR_TONE,
+  ARG_SCENE_MODE,
+  ARG_FLASH_MODE,
+  ARG_FOCUS_STATUS,
+  ARG_CAPABILITIES,
+  ARG_SHAKE_RISK,
+  ARG_EV_COMP,
+  ARG_ISO_SPEED,
+  ARG_APERTURE,
+  ARG_EXPOSURE,
+  ARG_VIDEO_SOURCE_FILTER,
+  ARG_IMAGE_CAPTURE_SUPPORTED_CAPS,
+  ARG_VIEWFINDER_FILTER,
+  ARG_FLICKER_MODE,
+  ARG_FOCUS_MODE,
+  ARG_BLOCK_VIEWFINDER,
+  ARG_IMAGE_CAPTURE_WIDTH,
+  ARG_IMAGE_CAPTURE_HEIGHT,
+  ARG_VIDEO_CAPTURE_WIDTH,
+  ARG_VIDEO_CAPTURE_HEIGHT,
+  ARG_VIDEO_CAPTURE_FRAMERATE
+};
+
+#define DEFAULT_WIDTH 640
+#define DEFAULT_HEIGHT 480
+#define DEFAULT_CAPTURE_WIDTH 800
+#define DEFAULT_CAPTURE_HEIGHT 600
+#define DEFAULT_FPS_N 0         /* makes it use the default */
+#define DEFAULT_FPS_D 1
+#define DEFAULT_ZOOM MIN_ZOOM
+
+
+/**
+ * GstCameraBinFlags:
+ * @GST_CAMERABIN_FLAG_SOURCE_RESIZE: enable video crop and scale
+ *   after capture
+ * @GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION: enable conversion
+ *   of native video format by enabling ffmpegcolorspace
+ * @GST_CAMERABIN_FLAG_VIEWFINDER_COLOR_CONVERSION: enable color
+ *   conversion for viewfinder element
+ * @GST_CAMERABIN_FLAG_VIEWFINDER_SCALE: enable scaling in
+ *   viewfinder element retaining aspect ratio
+ * @GST_CAMERABIN_FLAG_AUDIO_CONVERSION:  enable audioconvert and
+ *   audioresample elements
+ * @GST_CAMERABIN_FLAG_DISABLE_AUDIO:  disable audio elements
+ * @GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION:  enable color
+ *   conversion for image output element
+ *
+ * Extra flags to configure the behaviour of the sinks.
+ */
+typedef enum {
+  GST_CAMERABIN_FLAG_SOURCE_RESIZE               = (1 << 0),
+  GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION     = (1 << 1),
+  GST_CAMERABIN_FLAG_VIEWFINDER_COLOR_CONVERSION = (1 << 2),
+  GST_CAMERABIN_FLAG_VIEWFINDER_SCALE            = (1 << 3),
+  GST_CAMERABIN_FLAG_AUDIO_CONVERSION            = (1 << 4),
+  GST_CAMERABIN_FLAG_DISABLE_AUDIO               = (1 << 5),
+  GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION      = (1 << 6)
+} GstCameraBinFlags;
+
+#define GST_TYPE_CAMERABIN_FLAGS (gst_camerabin_flags_get_type())
+GType gst_camerabin_flags_get_type (void);
+
+
+/**
+ * GstCameraBinMode:
+ * @MODE_PREVIEW: preview only (no capture) mode
+ * @MODE_IMAGE: image capture
+ * @MODE_VIDEO: video capture
+ *
+ * Capture mode to use.
+ */
+typedef enum
+{
+  /* note:  changed to align with 'capture-mode' property (even though
+   * I have no idea where this property comes from..)  But it somehow
+   * seems more logical for preview to be mode==0 even if it is an ABI
+   * break..
+   */
+  MODE_PREVIEW = 0,
+  MODE_IMAGE = 1,
+  MODE_VIDEO = 2,
+} GstCameraBinMode;
+
+
+#define GST_TYPE_CAMERABIN_MODE (gst_camerabin_mode_get_type ())
+GType gst_camerabin_mode_get_type (void);
+
+G_END_DECLS
+
+#endif                          /* #ifndef __GST_CAMERABIN_ENUM_H__ */
diff --git a/gst/camerabin/Makefile.am b/gst/camerabin/Makefile.am
index e4563f5..79aa3e2 100644
--- a/gst/camerabin/Makefile.am
+++ b/gst/camerabin/Makefile.am
@@ -21,15 +21,17 @@ libgstcamerabin_la_SOURCES = gstcamerabin.c             \
 			  camerabingeneral.c         \
 			  camerabinpreview.c         \
 			  gstcamerabinphotography.c  \
-			  gstcamerabin-enum.c
+			  gstv4l2camerasrc.c
 
 nodist_libgstcamerabin_la_SOURCES = $(built_sources)
 libgstcamerabin_la_CFLAGS = \
 	$(GST_PLUGINS_BAD_CFLAGS) \
+	-I$(top_srcdir)/gst-libs \
 	$(GST_CFLAGS) $(GST_BASE_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) \
 	-DGST_USE_UNSTABLE_API
 libgstcamerabin_la_LIBADD = \
 	$(top_builddir)/gst-libs/gst/interfaces/libgstphotography-$(GST_MAJORMINOR).la \
+	$(top_builddir)/gst-libs/gst/camerasrc/libgstcamerasrc-@GST_MAJORMINOR@.la \
 	$(GST_LIBS) $(GST_BASE_LIBS) $(GST_PLUGINS_BASE_LIBS) \
 	-lgstinterfaces-$(GST_MAJORMINOR)
 
@@ -44,4 +46,4 @@ noinst_HEADERS = gstcamerabin.h             \
 		 camerabingeneral.h         \
 		 camerabinpreview.h         \
 		 gstcamerabinphotography.h  \
-		 gstcamerabin-enum.h
+		 gstv4l2camerasrc.h
diff --git a/gst/camerabin/camerabingeneral.c b/gst/camerabin/camerabingeneral.c
index 5b4df17..2a50d9e 100644
--- a/gst/camerabin/camerabingeneral.c
+++ b/gst/camerabin/camerabingeneral.c
@@ -47,12 +47,33 @@ GST_DEBUG_CATEGORY (gst_camerabin_debug);
 gboolean
 gst_camerabin_add_element (GstBin * bin, GstElement * new_elem)
 {
+  return gst_camerabin_add_element_full (bin, NULL, new_elem, NULL);
+}
+
+/**
+ * gst_camerabin_add_element_full:
+ * @bin: add an element to this bin
+ * @srcpad:  src pad name, or NULL for any
+ * @new_elem: new element to be added
+ * @dstpad:  dst pad name, or NULL for any
+ *
+ * Adds given element to given @bin. Looks for an unconnected src pad
+ * (with name @srcpad, if specified) from the @bin and links the element
+ * to it.  Raises an error if adding or linking failed. Unrefs the element
+ * in the case of an error.
+ *
+ * Returns: %TRUE if adding and linking succeeded, %FALSE otherwise.
+ */
+gboolean
+gst_camerabin_add_element_full (GstBin * bin, const gchar * srcpad,
+    GstElement * new_elem, const gchar * dstpad)
+{
   gboolean ret;
 
   g_return_val_if_fail (bin, FALSE);
   g_return_val_if_fail (new_elem, FALSE);
 
-  ret = gst_camerabin_try_add_element (bin, new_elem);
+  ret = gst_camerabin_try_add_element (bin, srcpad, new_elem, dstpad);
 
   if (!ret) {
     gchar *elem_name = gst_element_get_name (new_elem);
@@ -68,15 +89,19 @@ gst_camerabin_add_element (GstBin * bin, GstElement * new_elem)
 /**
  * gst_camerabin_try_add_element:
  * @bin: tries adding an element to this bin
+ * @srcpad:  src pad name, or NULL for any
  * @new_elem: new element to be added
+ * @dstpad:  dst pad name, or NULL for any
  *
  * Adds given element to given @bin. Looks for an unconnected src pad
- * from the @bin and links the element to it.
+ * (with name @srcpad, if specified) from the @bin and links the element to
+ * it.
  *
  * Returns: %TRUE if adding and linking succeeded, %FALSE otherwise.
  */
 gboolean
-gst_camerabin_try_add_element (GstBin * bin, GstElement * new_elem)
+gst_camerabin_try_add_element (GstBin * bin, const gchar * srcpad,
+    GstElement * new_elem, const gchar * dstpad)
 {
   GstPad *bin_pad;
   GstElement *bin_elem;
@@ -95,7 +120,7 @@ gst_camerabin_try_add_element (GstBin * bin, GstElement * new_elem)
         GST_DEBUG_PAD_NAME (bin_pad));
     bin_elem = gst_pad_get_parent_element (bin_pad);
     gst_object_unref (bin_pad);
-    if (!gst_element_link (bin_elem, new_elem)) {
+    if (!gst_element_link_pads (bin_elem, srcpad, new_elem, dstpad)) {
       gst_object_ref (new_elem);
       gst_bin_remove (bin, new_elem);
       ret = FALSE;
diff --git a/gst/camerabin/camerabingeneral.h b/gst/camerabin/camerabingeneral.h
index 0e84e4a..7f453ac 100644
--- a/gst/camerabin/camerabingeneral.h
+++ b/gst/camerabin/camerabingeneral.h
@@ -23,8 +23,10 @@
 
 #include <gst/gst.h>
 
-gboolean gst_camerabin_try_add_element (GstBin * bin, GstElement * new_elem);
+gboolean gst_camerabin_try_add_element (GstBin * bin, const gchar * srcpad, GstElement * new_elem, const gchar * dstpad);
 gboolean gst_camerabin_add_element (GstBin * bin, GstElement * new_elem);
+gboolean gst_camerabin_add_element_full (GstBin * bin, const gchar * srcpad, GstElement * new_elem, const gchar * dstpad);
+
 GstElement *gst_camerabin_create_and_add_element (GstBin * bin, const gchar * elem_name);
 
 GstElement * gst_camerabin_setup_default_element (GstBin * bin, GstElement *user_elem, const gchar *auto_elem_name, const gchar *default_elem_name);
diff --git a/gst/camerabin/camerabinimage.c b/gst/camerabin/camerabinimage.c
index 25ca8f8..9debf1a 100644
--- a/gst/camerabin/camerabinimage.c
+++ b/gst/camerabin/camerabinimage.c
@@ -53,7 +53,6 @@
 #include "camerabinimage.h"
 #include "camerabindebug.h"
 #include "camerabingeneral.h"
-#include "gstcamerabin-enum.h"
 
 #include "string.h"
 
diff --git a/gst/camerabin/camerabinimage.h b/gst/camerabin/camerabinimage.h
index 25a258c..594c094 100644
--- a/gst/camerabin/camerabinimage.h
+++ b/gst/camerabin/camerabinimage.h
@@ -23,7 +23,7 @@
 
 #include <gst/gstbin.h>
 
-#include "gstcamerabin-enum.h"
+#include <gst/camerasrc/gstcamerabin-enum.h>
 
 G_BEGIN_DECLS
 #define GST_TYPE_CAMERABIN_IMAGE             (gst_camerabin_image_get_type())
diff --git a/gst/camerabin/camerabinvideo.c b/gst/camerabin/camerabinvideo.c
index b2715e7..b5a89b6 100644
--- a/gst/camerabin/camerabinvideo.c
+++ b/gst/camerabin/camerabinvideo.c
@@ -175,12 +175,10 @@ gst_camerabin_video_init (GstCameraBinVideo * vid,
 
   vid->aud_src = NULL;
   vid->sink = NULL;
-  vid->tee = NULL;
   vid->volume = NULL;
   vid->video_queue = NULL;
 
-  vid->tee_video_srcpad = NULL;
-  vid->tee_vf_srcpad = NULL;
+  vid->queue_video_srcpad = NULL;
 
   vid->pending_eos = NULL;
 
@@ -188,17 +186,13 @@ gst_camerabin_video_init (GstCameraBinVideo * vid,
   vid->flags = DEFAULT_FLAGS;
 
   vid->aud_src_probe_id = 0;
-  vid->vid_src_probe_id = 0;
-  vid->vid_tee_probe_id = 0;
+  vid->vid_queue_probe_id = 0;
   vid->vid_sink_probe_id = 0;
 
-  /* Create src and sink ghost pads */
+  /* Create sink ghost pad */
   vid->sinkpad = gst_ghost_pad_new_no_target ("sink", GST_PAD_SINK);
   gst_element_add_pad (GST_ELEMENT (vid), vid->sinkpad);
 
-  vid->srcpad = gst_ghost_pad_new_no_target ("src", GST_PAD_SRC);
-  gst_element_add_pad (GST_ELEMENT (vid), vid->srcpad);
-
   /* Add probe for handling eos when stopping recording */
   vid->vid_sink_probe_id = gst_pad_add_event_probe (vid->sinkpad,
       G_CALLBACK (camerabin_video_sink_have_event), vid);
@@ -351,7 +345,7 @@ gst_camerabin_video_change_state (GstElement * element,
       if (vid->pending_eos) {
         /* Video bin is still paused, so push eos directly to video queue */
         GST_DEBUG_OBJECT (vid, "pushing pending eos");
-        gst_pad_push_event (vid->tee_video_srcpad, vid->pending_eos);
+        gst_pad_push_event (vid->queue_video_srcpad, vid->pending_eos);
         vid->pending_eos = NULL;
       }
       break;
@@ -536,7 +530,7 @@ camerabin_video_sink_have_event (GstPad * pad, GstEvent * event,
 static gboolean
 gst_camerabin_video_create_elements (GstCameraBinVideo * vid)
 {
-  GstPad *pad = NULL, *vid_sinkpad = NULL, *vid_srcpad = NULL;
+  GstPad *pad = NULL, *vid_sinkpad = NULL;
   GstBin *vidbin = GST_BIN (vid);
   GstElement *queue = NULL;
 
@@ -556,28 +550,24 @@ gst_camerabin_video_create_elements (GstCameraBinVideo * vid)
     vid_sinkpad = gst_element_get_static_pad (vid->app_post, "sink");
   }
 
-  /* Add tee element */
-  if (!(vid->tee = gst_camerabin_create_and_add_element (vidbin, "tee"))) {
+  /* Add queue element for video */
+  vid->video_queue = gst_element_factory_make ("queue", "video-queue");
+  if (!gst_camerabin_add_element (vidbin, vid->video_queue)) {
     goto error;
   }
 
   /* Set up sink ghost pad for video bin */
   if (!vid_sinkpad) {
-    vid_sinkpad = gst_element_get_static_pad (vid->tee, "sink");
+    vid_sinkpad = gst_element_get_static_pad (vid->video_queue, "sink");
   }
   gst_ghost_pad_set_target (GST_GHOST_PAD (vid->sinkpad), vid_sinkpad);
   gst_object_unref (vid_sinkpad);
 
-  /* Add queue element for video */
-  vid->tee_video_srcpad = gst_element_get_request_pad (vid->tee, "src%d");
-
-  vid->video_queue = gst_element_factory_make ("queue", "video-queue");
-  if (!gst_camerabin_add_element (vidbin, vid->video_queue)) {
-    goto error;
-  }
+  vid->queue_video_srcpad =
+      gst_element_get_static_pad (vid->video_queue, "src");
 
   /* Add probe for rewriting video timestamps */
-  vid->vid_tee_probe_id = gst_pad_add_buffer_probe (vid->tee_video_srcpad,
+  vid->vid_queue_probe_id = gst_pad_add_buffer_probe (vid->queue_video_srcpad,
       G_CALLBACK (camerabin_video_pad_tee_src0_have_buffer), vid);
 
   /* Add user set or default video encoder element */
@@ -630,15 +620,15 @@ gst_camerabin_video_create_elements (GstCameraBinVideo * vid)
     /* Add optional audio conversion and volume elements and
        raise no errors if adding them fails */
     if (vid->flags & GST_CAMERABIN_FLAG_AUDIO_CONVERSION) {
-      if (!gst_camerabin_try_add_element (vidbin,
-              gst_element_factory_make ("audioconvert", NULL))) {
+      if (!gst_camerabin_try_add_element (vidbin, NULL,
+              gst_element_factory_make ("audioconvert", NULL), NULL)) {
         GST_WARNING_OBJECT (vid, "unable to add audio conversion element");
         /* gst_camerabin_try_add_element() destroyed the element */
       }
     }
 
     vid->volume = gst_element_factory_make ("volume", NULL);
-    if (!gst_camerabin_try_add_element (vidbin, vid->volume)) {
+    if (!gst_camerabin_try_add_element (vidbin, NULL, vid->volume, NULL)) {
       GST_WARNING_OBJECT (vid, "unable to add volume element");
       /* gst_camerabin_try_add_element() destroyed the element */
       vid->volume = NULL;
@@ -664,23 +654,6 @@ gst_camerabin_video_create_elements (GstCameraBinVideo * vid)
       goto error;
     }
   }
-  /* Add queue leading out of the video bin and to view finder */
-  vid->tee_vf_srcpad = gst_element_get_request_pad (vid->tee, "src%d");
-  queue = gst_element_factory_make ("queue", "viewfinder-queue");
-  if (!gst_camerabin_add_element (vidbin, queue)) {
-    goto error;
-  }
-  /* Set queue leaky, we don't want to block video encoder feed, but
-     prefer leaking view finder buffers instead. */
-  g_object_set (G_OBJECT (queue), "leaky", 2, "max-size-buffers", 1, NULL);
-
-  /* Set up src ghost pad for video bin */
-  vid_srcpad = gst_element_get_static_pad (queue, "src");
-  gst_ghost_pad_set_target (GST_GHOST_PAD (vid->srcpad), vid_srcpad);
-  /* Never let video bin eos events reach view finder */
-  vid->vid_src_probe_id = gst_pad_add_event_probe (vid_srcpad,
-      G_CALLBACK (gst_camerabin_drop_eos_probe), vid);
-  gst_object_unref (vid_srcpad);
 
   if (!(vid->flags & GST_CAMERABIN_FLAG_DISABLE_AUDIO)) {
     pad = gst_element_get_static_pad (vid->aud_src, "src");
@@ -723,42 +696,22 @@ gst_camerabin_video_destroy_elements (GstCameraBinVideo * vid)
     vid->aud_src_probe_id = 0;
   }
 
-  /* Remove EOS event probe from videobin srcpad (queue's srcpad) */
-  if (vid->vid_src_probe_id) {
-    GstPad *pad = gst_ghost_pad_get_target (GST_GHOST_PAD (vid->srcpad));
-    if (pad) {
-      gst_pad_remove_event_probe (pad, vid->vid_src_probe_id);
-      gst_object_unref (pad);
-    }
-    vid->vid_src_probe_id = 0;
-  }
-
   /* Remove buffer probe from video tee srcpad */
-  if (vid->vid_tee_probe_id) {
-    gst_pad_remove_buffer_probe (vid->tee_video_srcpad, vid->vid_tee_probe_id);
-    vid->vid_tee_probe_id = 0;
+  if (vid->vid_queue_probe_id) {
+    gst_pad_remove_buffer_probe (vid->queue_video_srcpad,
+        vid->vid_queue_probe_id);
+    vid->vid_queue_probe_id = 0;
   }
 
-  /* Release tee request pads */
-  if (vid->tee_video_srcpad) {
-    gst_element_release_request_pad (vid->tee, vid->tee_video_srcpad);
-    gst_object_unref (vid->tee_video_srcpad);
-    vid->tee_video_srcpad = NULL;
-  }
-  if (vid->tee_vf_srcpad) {
-    gst_element_release_request_pad (vid->tee, vid->tee_vf_srcpad);
-    gst_object_unref (vid->tee_vf_srcpad);
-    vid->tee_vf_srcpad = NULL;
-  }
+  gst_object_unref (vid->queue_video_srcpad);
+  vid->queue_video_srcpad = NULL;
 
   gst_ghost_pad_set_target (GST_GHOST_PAD (vid->sinkpad), NULL);
-  gst_ghost_pad_set_target (GST_GHOST_PAD (vid->srcpad), NULL);
 
   gst_camerabin_remove_elements_from_bin (GST_BIN (vid));
 
   vid->aud_src = NULL;
   vid->sink = NULL;
-  vid->tee = NULL;
   vid->volume = NULL;
   vid->video_queue = NULL;
   vid->vid_enc = NULL;
diff --git a/gst/camerabin/camerabinvideo.h b/gst/camerabin/camerabinvideo.h
index 74b41ef..e5ae847 100644
--- a/gst/camerabin/camerabinvideo.h
+++ b/gst/camerabin/camerabinvideo.h
@@ -23,7 +23,7 @@
 
 #include <gst/gstbin.h>
 
-#include "gstcamerabin-enum.h"
+#include <gst/camerasrc/gstcamerabin-enum.h>
 
 G_BEGIN_DECLS
 #define ARG_DEFAULT_MUTE FALSE
@@ -58,11 +58,9 @@ struct _GstCameraBinVideo
 
   /* Sink and src pads of video bin */
   GstPad *sinkpad;
-  GstPad *srcpad;
 
-  /* Tee src pads leading to video encoder and view finder */
-  GstPad *tee_video_srcpad;
-  GstPad *tee_vf_srcpad;
+  /* srcpad out of queue at head of video-bin */
+  GstPad *queue_video_srcpad;
 
   /* Application set elements */
   GstElement *app_post;         /* Video post processing */
@@ -74,7 +72,6 @@ struct _GstCameraBinVideo
   /* Other elements */
   GstElement *aud_src;          /* Audio source */
   GstElement *sink;             /* Sink for recorded video */
-  GstElement *tee;              /* Split output to view finder and recording sink */
   GstElement *volume;           /* Volume for muting */
   GstElement *video_queue;      /* Buffer for raw video frames */
   GstElement *vid_enc;          /* Video encoder */
@@ -85,8 +82,7 @@ struct _GstCameraBinVideo
 
   /* Probe IDs */
   gulong aud_src_probe_id;
-  gulong vid_src_probe_id;
-  gulong vid_tee_probe_id;
+  gulong vid_queue_probe_id;
   gulong vid_sink_probe_id;
 
   gboolean mute;
diff --git a/gst/camerabin/gstcamerabin-enum.c b/gst/camerabin/gstcamerabin-enum.c
deleted file mode 100644
index a116a00..0000000
--- a/gst/camerabin/gstcamerabin-enum.c
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * GStreamer
- * Copyright (C) 2009 Nokia Corporation <multimedia@maemo.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "gstcamerabin-enum.h"
-
-#define C_FLAGS(v) ((guint) v)
-
-static void
-register_gst_camerabin_flags (GType * id)
-{
-  static const GFlagsValue values[] = {
-    {C_FLAGS (GST_CAMERABIN_FLAG_SOURCE_RESIZE),
-        "Enable source crop and scale", "source-resize"},
-    {C_FLAGS (GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION),
-          "Enable colorspace conversion for video source",
-        "source-colorspace-conversion"},
-    {C_FLAGS (GST_CAMERABIN_FLAG_VIEWFINDER_COLOR_CONVERSION),
-          "Enable colorspace conversion for viewfinder",
-        "viewfinder-colorspace-conversion"},
-    {C_FLAGS (GST_CAMERABIN_FLAG_VIEWFINDER_SCALE),
-        "Enable scale for viewfinder", "viewfinder-scale"},
-    {C_FLAGS (GST_CAMERABIN_FLAG_AUDIO_CONVERSION),
-        "Enable audio conversion for video capture", "audio-conversion"},
-    {C_FLAGS (GST_CAMERABIN_FLAG_DISABLE_AUDIO),
-        "Disable audio elements for video capture", "disable-audio"},
-    {C_FLAGS (GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION),
-          "Enable colorspace conversion for still image",
-        "image-colorspace-conversion"},
-    {0, NULL, NULL}
-  };
-  *id = g_flags_register_static ("GstCameraBinFlags", values);
-}
-
-GType
-gst_camerabin_flags_get_type (void)
-{
-  static GType id;
-  static GOnce once = G_ONCE_INIT;
-
-  g_once (&once, (GThreadFunc) register_gst_camerabin_flags, &id);
-  return id;
-}
diff --git a/gst/camerabin/gstcamerabin-enum.h b/gst/camerabin/gstcamerabin-enum.h
deleted file mode 100644
index d169559..0000000
--- a/gst/camerabin/gstcamerabin-enum.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * GStreamer
- * Copyright (C) 2009 Nokia Corporation <multimedia@maemo.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GST_CAMERABIN_ENUM_H__
-#define __GST_CAMERABIN_ENUM_H__
-
-#include <gst/gst.h>
-
-G_BEGIN_DECLS
-
-enum
-{
-  ARG_0,
-  ARG_FILENAME,
-  ARG_MODE,
-  ARG_FLAGS,
-  ARG_MUTE,
-  ARG_ZOOM,
-  ARG_IMAGE_POST,
-  ARG_IMAGE_ENC,
-  ARG_VIDEO_POST,
-  ARG_VIDEO_ENC,
-  ARG_AUDIO_ENC,
-  ARG_VIDEO_MUX,
-  ARG_VF_SINK,
-  ARG_VIDEO_SRC,
-  ARG_AUDIO_SRC,
-  ARG_INPUT_CAPS,
-  ARG_FILTER_CAPS,
-  ARG_PREVIEW_CAPS,
-  ARG_WB_MODE,
-  ARG_COLOUR_TONE,
-  ARG_SCENE_MODE,
-  ARG_FLASH_MODE,
-  ARG_FOCUS_STATUS,
-  ARG_CAPABILITIES,
-  ARG_SHAKE_RISK,
-  ARG_EV_COMP,
-  ARG_ISO_SPEED,
-  ARG_APERTURE,
-  ARG_EXPOSURE,
-  ARG_VIDEO_SOURCE_FILTER,
-  ARG_IMAGE_CAPTURE_SUPPORTED_CAPS,
-  ARG_VIEWFINDER_FILTER,
-  ARG_FLICKER_MODE,
-  ARG_FOCUS_MODE,
-  ARG_BLOCK_VIEWFINDER,
-  ARG_IMAGE_CAPTURE_WIDTH,
-  ARG_IMAGE_CAPTURE_HEIGHT,
-  ARG_VIDEO_CAPTURE_WIDTH,
-  ARG_VIDEO_CAPTURE_HEIGHT,
-  ARG_VIDEO_CAPTURE_FRAMERATE
-};
-
-/**
- * GstCameraBinFlags:
- * @GST_CAMERABIN_FLAG_SOURCE_RESIZE: enable video crop and scale
- *   after capture
- * @GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION: enable conversion
- *   of native video format by enabling ffmpegcolorspace
- * @GST_CAMERABIN_FLAG_VIEWFINDER_COLOR_CONVERSION: enable color
- *   conversion for viewfinder element
- * @GST_CAMERABIN_FLAG_VIEWFINDER_SCALE: enable scaling in
- *   viewfinder element retaining aspect ratio
- * @GST_CAMERABIN_FLAG_AUDIO_CONVERSION:  enable audioconvert and
- *   audioresample elements
- * @GST_CAMERABIN_FLAG_DISABLE_AUDIO:  disable audio elements
- * @GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION:  enable color
- *   conversion for image output element
- *
- * Extra flags to configure the behaviour of the sinks.
- */
-typedef enum {
-  GST_CAMERABIN_FLAG_SOURCE_RESIZE               = (1 << 0),
-  GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION     = (1 << 1),
-  GST_CAMERABIN_FLAG_VIEWFINDER_COLOR_CONVERSION = (1 << 2),
-  GST_CAMERABIN_FLAG_VIEWFINDER_SCALE            = (1 << 3),
-  GST_CAMERABIN_FLAG_AUDIO_CONVERSION            = (1 << 4),
-  GST_CAMERABIN_FLAG_DISABLE_AUDIO               = (1 << 5),
-  GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION      = (1 << 6)
-} GstCameraBinFlags;
-
-#define GST_TYPE_CAMERABIN_FLAGS (gst_camerabin_flags_get_type())
-GType gst_camerabin_flags_get_type (void);
-
-G_END_DECLS
-
-#endif                          /* #ifndef __GST_CAMERABIN_ENUM_H__ */
diff --git a/gst/camerabin/gstcamerabin.c b/gst/camerabin/gstcamerabin.c
index 6d023d3..6e5604b 100644
--- a/gst/camerabin/gstcamerabin.c
+++ b/gst/camerabin/gstcamerabin.c
@@ -157,6 +157,8 @@
 #include <stdlib.h>
 
 #include <gst/gst.h>
+#include <gst/camerasrc/gstbasecamerasrc.h>
+#include "gstv4l2camerasrc.h"
 /* FIXME: include #include <gst/gst-i18n-plugin.h> and use _(" ") */
 
 #include "gstcamerabin.h"
@@ -193,37 +195,14 @@ enum
 
 static guint camerabin_signals[LAST_SIGNAL];
 
-#define GST_TYPE_CAMERABIN_MODE (gst_camerabin_mode_get_type ())
-
 /* default and range values for args */
 
-#define DEFAULT_MODE MODE_IMAGE
-#define DEFAULT_ZOOM 100
-#define DEFAULT_WIDTH 640
-#define DEFAULT_HEIGHT 480
-#define DEFAULT_CAPTURE_WIDTH 800
-#define DEFAULT_CAPTURE_HEIGHT 600
-#define DEFAULT_FPS_N 0         /* makes it use the default */
-#define DEFAULT_FPS_D 1
-
-#define CAMERABIN_DEFAULT_VF_CAPS "video/x-raw-yuv,format=(fourcc)I420"
-#define CAMERABIN_MAX_VF_WIDTH 848
-#define CAMERABIN_MAX_VF_HEIGHT 848
+#define DEFAULT_MODE MODE_PREVIEW
 
 #define DEFAULT_FLAGS GST_CAMERABIN_FLAG_SOURCE_RESIZE | \
   GST_CAMERABIN_FLAG_VIEWFINDER_SCALE | \
   GST_CAMERABIN_FLAG_IMAGE_COLOR_CONVERSION
 
-/* Using "bilinear" as default zoom method */
-#define CAMERABIN_DEFAULT_ZOOM_METHOD 1
-
-#define MIN_ZOOM 100
-#define MAX_ZOOM 1000
-#define ZOOM_1X MIN_ZOOM
-
-/* FIXME: this is v4l2camsrc specific */
-#define DEFAULT_V4L2CAMSRC_DRIVER_NAME "omap3cam"
-
 #define DEFAULT_BLOCK_VIEWFINDER FALSE
 
 /* message names */
@@ -236,8 +215,6 @@ static guint camerabin_signals[LAST_SIGNAL];
 
 static void camerabin_setup_src_elements (GstCameraBin * camera);
 
-static gboolean camerabin_create_src_elements (GstCameraBin * camera);
-
 static void camerabin_setup_view_elements (GstCameraBin * camera);
 
 static gboolean camerabin_create_view_elements (GstCameraBin * camera);
@@ -256,15 +233,8 @@ gst_camerabin_set_flags (GstCameraBin * camera, GstCameraBinFlags flags);
 static void
 gst_camerabin_change_filename (GstCameraBin * camera, const gchar * name);
 
-static void gst_camerabin_setup_zoom (GstCameraBin * camera);
-
-static GstCaps *gst_camerabin_get_allowed_input_caps (GstCameraBin * camera);
-
 static void gst_camerabin_rewrite_tags (GstCameraBin * camera);
 
-static void
-gst_camerabin_set_capsfilter_caps (GstCameraBin * camera, GstCaps * new_caps);
-
 static void gst_camerabin_start_image_capture (GstCameraBin * camera);
 
 static void gst_camerabin_start_video_recording (GstCameraBin * camera);
@@ -289,29 +259,10 @@ static void gst_camerabin_reset_to_view_finder (GstCameraBin * camera);
 
 static void gst_camerabin_do_stop (GstCameraBin * camera);
 
-static void
-gst_camerabin_set_allowed_framerate (GstCameraBin * camera,
-    GstCaps * filter_caps);
-
-static guint32 get_srcpad_current_format (GstElement * element);
-
-static const GValue *gst_camerabin_find_better_framerate (GstCameraBin * camera,
-    GstStructure * st, const GValue * orig_framerate);
-
-static void
-gst_camerabin_update_aspect_filter (GstCameraBin * camera, GstCaps * new_caps);
-
-static void gst_camerabin_finish_image_capture (GstCameraBin * camera);
-static void gst_camerabin_adapt_image_capture (GstCameraBin * camera,
-    GstCaps * new_caps);
 static void gst_camerabin_proxy_notify_cb (GObject * video_source,
     GParamSpec * pspec, gpointer user_data);
 static void gst_camerabin_monitor_video_source_properties (GstCameraBin *
     camera);
-static void gst_camerabin_configure_format (GstCameraBin * camera,
-    GstCaps * caps);
-static gboolean
-copy_missing_fields (GQuark field_id, const GValue * value, gpointer user_data);
 
 /*
  * GObject callback functions declaration
@@ -356,10 +307,6 @@ static void gst_camerabin_capture_stop (GstCameraBin * camera);
 static void gst_camerabin_capture_pause (GstCameraBin * camera);
 
 static void
-gst_camerabin_set_image_capture_caps (GstCameraBin * camera, gint width,
-    gint height);
-
-static void
 gst_camerabin_set_video_resolution_fps (GstCameraBin * camera, gint width,
     gint height, gint fps_n, gint fps_d);
 
@@ -372,33 +319,15 @@ gst_camerabin_set_image_resolution (GstCameraBin * camera, gint width,
  * GST BOILERPLATE and GObject types
  */
 
-static GType
-gst_camerabin_mode_get_type (void)
-{
-  static GType gtype = 0;
-
-  if (gtype == 0) {
-    static const GEnumValue values[] = {
-      {MODE_IMAGE, "Still image capture (default)", "mode-image"},
-      {MODE_VIDEO, "Video recording", "mode-video"},
-      {0, NULL, NULL}
-    };
-
-    gtype = g_enum_register_static ("GstCameraBinMode", values);
-  }
-  return gtype;
-}
-
-
 static gboolean
 gst_camerabin_iface_supported (GstImplementsInterface * iface, GType iface_type)
 {
   GstCameraBin *camera = GST_CAMERABIN (iface);
 
   if (iface_type == GST_TYPE_COLOR_BALANCE) {
-    if (camera->src_vid_src) {
-      return GST_IS_COLOR_BALANCE (camera->src_vid_src);
-    }
+    return
+        gst_base_camera_src_get_color_balance (GST_BASE_CAMERA_SRC
+        (camera->srcbin)) != NULL;
   } else if (iface_type == GST_TYPE_TAG_SETTER) {
     /* Note: Tag setter elements aren't
        present when image and video bin in NULL */
@@ -485,145 +414,16 @@ GST_BOILERPLATE_FULL (GstCameraBin, gst_camerabin, GstPipeline,
 static void
 camerabin_setup_src_elements (GstCameraBin * camera)
 {
-  GstStructure *st;
-  GstCaps *new_caps;
-  gboolean detect_framerate = FALSE;
-
-  /* clear video update status */
-  camera->video_capture_caps_update = FALSE;
-
-  if (!camera->view_finder_caps) {
-    st = gst_structure_from_string (CAMERABIN_DEFAULT_VF_CAPS, NULL);
-  } else {
-    st = gst_structure_copy (gst_caps_get_structure (camera->view_finder_caps,
-            0));
-  }
+  GstBaseCameraSrc *srcbin = GST_BASE_CAMERA_SRC (camera->srcbin);
+  GstPhotography *photography;
 
   gst_camerabin_monitor_video_source_properties (camera);
 
   /* Update photography interface settings */
-  if (GST_IS_ELEMENT (camera->src_vid_src) &&
-      gst_element_implements_interface (camera->src_vid_src,
-          GST_TYPE_PHOTOGRAPHY)) {
-    gst_photography_set_config (GST_PHOTOGRAPHY (camera->src_vid_src),
-        &camera->photo_settings);
-  }
-
-  if (camera->width > 0 && camera->height > 0) {
-    gst_structure_set (st,
-        "width", G_TYPE_INT, camera->width,
-        "height", G_TYPE_INT, camera->height, NULL);
-  }
-
-  if (camera->fps_n > 0 && camera->fps_d > 0) {
-    if (camera->night_mode) {
-      GST_INFO_OBJECT (camera, "night mode, lowest allowed fps will be forced");
-      camera->pre_night_fps_n = camera->fps_n;
-      camera->pre_night_fps_d = camera->fps_d;
-      detect_framerate = TRUE;
-    } else {
-      gst_structure_set (st,
-          "framerate", GST_TYPE_FRACTION, camera->fps_n, camera->fps_d, NULL);
-      new_caps = gst_caps_new_full (st, NULL);
-    }
-  } else {
-    GST_DEBUG_OBJECT (camera, "no framerate specified");
-    detect_framerate = TRUE;
-  }
-
-  if (detect_framerate) {
-    GST_DEBUG_OBJECT (camera, "detecting allowed framerate");
-    /* Remove old framerate if any */
-    if (gst_structure_has_field (st, "framerate")) {
-      gst_structure_remove_field (st, "framerate");
-    }
-    new_caps = gst_caps_new_full (st, NULL);
-
-    /* Set allowed framerate for the resolution */
-    gst_camerabin_set_allowed_framerate (camera, new_caps);
-  }
-
-  /* Set default zoom method */
-  if (camera->src_zoom_scale) {
-    g_object_set (camera->src_zoom_scale, "method",
-        CAMERABIN_DEFAULT_ZOOM_METHOD, NULL);
-  }
-  /* we create new caps in any way and they take ownership of the structure st */
-  gst_caps_replace (&camera->view_finder_caps, new_caps);
-  gst_caps_unref (new_caps);
-
-  /* Set caps for view finder mode */
-  /* This also sets zoom */
-  gst_camerabin_set_capsfilter_caps (camera, camera->view_finder_caps);
-}
-
-/*
- * camerabin_create_src_elements:
- * @camera: camerabin object
- *
- * This function creates and links upstream side elements for camerabin.
- * videosrc ! cspconv ! capsfilter ! crop ! scale ! capsfilter ! out-sel !
- *
- * Returns: TRUE, if elements were successfully created, FALSE otherwise
- */
-static gboolean
-camerabin_create_src_elements (GstCameraBin * camera)
-{
-  gboolean ret = FALSE;
-  GstBin *cbin = GST_BIN (camera);
-  gchar *driver_name = NULL;
-
-  /* Add application set or default video src element */
-  if (!(camera->src_vid_src = gst_camerabin_setup_default_element (cbin,
-              camera->app_vid_src, "autovideosrc", DEFAULT_VIDEOSRC))) {
-    camera->src_vid_src = NULL;
-    goto done;
-  } else {
-    if (!gst_camerabin_add_element (cbin, camera->src_vid_src))
-      goto done;
-  }
-  if (camera->flags & GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION) {
-    if (!gst_camerabin_create_and_add_element (cbin, "ffmpegcolorspace"))
-      goto done;
-  }
-  if (!(camera->src_filter =
-          gst_camerabin_create_and_add_element (cbin, "capsfilter")))
-    goto done;
-  if (camera->flags & GST_CAMERABIN_FLAG_SOURCE_RESIZE) {
-    if (!(camera->src_zoom_crop =
-            gst_camerabin_create_and_add_element (cbin, "videocrop")))
-      goto done;
-    if (!(camera->src_zoom_scale =
-            gst_camerabin_create_and_add_element (cbin, "videoscale")))
-      goto done;
-    if (!(camera->src_zoom_filter =
-            gst_camerabin_create_and_add_element (cbin, "capsfilter")))
-      goto done;
-  }
-  if (camera->app_video_filter) {
-    if (!gst_camerabin_add_element (cbin, camera->app_video_filter)) {
-      goto done;
-    }
-  }
-  if (!(camera->src_out_sel =
-          gst_camerabin_create_and_add_element (cbin, "output-selector")))
-    goto done;
-
-  /* Set default "driver-name" for v4l2camsrc if not set */
-  /* FIXME: v4l2camsrc specific */
-  if (g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src_vid_src),
-          "driver-name")) {
-    g_object_get (G_OBJECT (camera->src_vid_src), "driver-name",
-        &driver_name, NULL);
-    if (!driver_name) {
-      g_object_set (G_OBJECT (camera->src_vid_src), "driver-name",
-          DEFAULT_V4L2CAMSRC_DRIVER_NAME, NULL);
-    }
+  photography = gst_base_camera_src_get_photography (srcbin);
+  if (photography) {
+    gst_photography_set_config (photography, &camera->photo_settings);
   }
-
-  ret = TRUE;
-done:
-  return ret;
 }
 
 /*
@@ -636,7 +436,6 @@ static void
 camerabin_setup_view_elements (GstCameraBin * camera)
 {
   GST_DEBUG_OBJECT (camera, "setting view finder properties");
-  g_object_set (G_OBJECT (camera->view_in_sel), "select-all", TRUE, NULL);
   /* Set properties for view finder sink */
   /* Find the actual sink if using bin like autovideosink */
   if (GST_IS_BIN (camera->view_sink)) {
@@ -666,21 +465,19 @@ camerabin_setup_view_elements (GstCameraBin * camera)
 static gboolean
 camerabin_create_view_elements (GstCameraBin * camera)
 {
-  const GList *pads;
   GstBin *cbin = GST_BIN (camera);
+  GstElement *queue = NULL;
 
-  if (!(camera->view_in_sel =
-          gst_camerabin_create_and_add_element (cbin, "input-selector"))) {
+  /* Add queue leading to view finder */
+  if (!(queue = gst_camerabin_create_and_add_element (cbin, "queue"))) {
     goto error;
   }
 
-  /* Look for recently added input selector sink pad, we need to release it later */
-  pads = GST_ELEMENT_PADS (camera->view_in_sel);
-  while (pads != NULL
-      && (GST_PAD_DIRECTION (GST_PAD (pads->data)) != GST_PAD_SINK)) {
-    pads = g_list_next (pads);
-  }
-  camera->pad_view_src = GST_PAD (pads->data);
+  /* Set queue leaky, we don't want to block video encoder feed, but
+   * prefer leaking view finder buffers instead, in case srcbin is pushing
+   * down both paths in same thread.
+   */
+  g_object_set (G_OBJECT (queue), "leaky", 2, "max-size-buffers", 1, NULL);
 
   /* Add videoscale in case we need to downscale frame for view finder */
   if (camera->flags & GST_CAMERABIN_FLAG_VIEWFINDER_SCALE) {
@@ -735,25 +532,26 @@ static gboolean
 camerabin_create_elements (GstCameraBin * camera)
 {
   gboolean ret = FALSE;
-  GstPadLinkReturn link_ret = GST_PAD_LINK_REFUSED;
-  GstPad *unconnected_pad;
 
   GST_LOG_OBJECT (camera, "creating elements");
 
-  /* Create "src" elements */
-  if (!camerabin_create_src_elements (camera)) {
+  /* Add camera src bin */
+  if (!gst_camerabin_add_element (GST_BIN (camera), camera->srcbin)) {
     goto done;
   }
 
-  camera->pad_src_img =
-      gst_element_get_request_pad (camera->src_out_sel, "src%d");
+  camera->pad_src_img = gst_element_get_static_pad (camera->srcbin, "imgsrc");
+
+  GST_DEBUG_OBJECT (camera, "pad_src_img: %" GST_PTR_FORMAT,
+      camera->pad_src_img);
 
   gst_pad_add_buffer_probe (camera->pad_src_img,
       G_CALLBACK (gst_camerabin_have_img_buffer), camera);
 
   /* Add queue leading to image bin */
   camera->img_queue = gst_element_factory_make ("queue", "image-queue");
-  if (!gst_camerabin_add_element (GST_BIN (camera), camera->img_queue)) {
+  if (!gst_camerabin_add_element_full (GST_BIN (camera), "imgsrc",
+          camera->img_queue, NULL)) {
     goto done;
   }
 
@@ -773,40 +571,27 @@ camerabin_create_elements (GstCameraBin * camera)
     goto done;
   }
 
-  camera->pad_src_view =
-      gst_element_get_request_pad (camera->src_out_sel, "src%d");
-
-  /* Create view finder elements */
-  if (!camerabin_create_view_elements (camera)) {
-    GST_WARNING_OBJECT (camera, "creating view finder elements failed");
-    goto done;
-  }
-
-  /* Set view finder active as default */
-  g_object_set (G_OBJECT (camera->src_out_sel), "active-pad",
-      camera->pad_src_view, NULL);
+  camera->pad_src_view = gst_element_get_static_pad (camera->srcbin, "vfsrc");
 
   /* Add video bin */
-  camera->pad_src_vid =
-      gst_element_get_request_pad (camera->src_out_sel, "src%d");
-  if (!gst_camerabin_add_element (GST_BIN (camera), camera->vidbin)) {
+  camera->pad_src_vid = gst_element_get_static_pad (camera->srcbin, "vidsrc");
+  if (!gst_camerabin_add_element_full (GST_BIN (camera), "vidsrc",
+          camera->vidbin, NULL)) {
     goto done;
   }
   gst_pad_add_buffer_probe (camera->pad_src_vid,
       G_CALLBACK (gst_camerabin_have_vid_buffer), camera);
 
-  /* Link video bin ! view finder */
-  unconnected_pad = gst_bin_find_unlinked_pad (GST_BIN (camera), GST_PAD_SRC);
-  camera->pad_view_vid =
-      gst_element_get_request_pad (camera->view_in_sel, "sink%d");
-  link_ret = gst_pad_link (unconnected_pad, camera->pad_view_vid);
-  gst_object_unref (unconnected_pad);
-  if (GST_PAD_LINK_FAILED (link_ret)) {
-    GST_ELEMENT_ERROR (camera, CORE, NEGOTIATION, (NULL),
-        ("linking video bin and view finder failed"));
+  /* Create view finder elements */
+  if (!camerabin_create_view_elements (camera)) {
+    GST_WARNING_OBJECT (camera, "creating view finder elements failed");
     goto done;
   }
 
+  /* Set view finder active as default */
+  gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (camera->srcbin),
+      MODE_PREVIEW);
+
   ret = TRUE;
 
 done:
@@ -829,28 +614,15 @@ camerabin_destroy_elements (GstCameraBin * camera)
   GST_DEBUG_OBJECT (camera, "destroying elements");
 
   /* Release request pads */
-  if (camera->pad_view_vid) {
-    gst_element_release_request_pad (camera->view_in_sel, camera->pad_view_vid);
-    gst_object_unref (camera->pad_view_vid);
-    camera->pad_view_vid = NULL;
-  }
   if (camera->pad_src_vid) {
-    gst_element_release_request_pad (camera->src_out_sel, camera->pad_src_vid);
     gst_object_unref (camera->pad_src_vid);
     camera->pad_src_vid = NULL;
   }
   if (camera->pad_src_img) {
-    gst_element_release_request_pad (camera->src_out_sel, camera->pad_src_img);
     gst_object_unref (camera->pad_src_img);
     camera->pad_src_img = NULL;
   }
-  if (camera->pad_view_src) {
-    gst_element_release_request_pad (camera->view_in_sel, camera->pad_view_src);
-    /* don't unref, we have not requested it */
-    camera->pad_view_src = NULL;
-  }
   if (camera->pad_src_view) {
-    gst_element_release_request_pad (camera->src_out_sel, camera->pad_src_view);
     gst_object_unref (camera->pad_src_view);
     camera->pad_src_view = NULL;
   }
@@ -861,18 +633,14 @@ camerabin_destroy_elements (GstCameraBin * camera)
   }
 
   /* view finder elements */
-  camera->view_in_sel = NULL;
   camera->view_scale = NULL;
   camera->aspect_filter = NULL;
   camera->view_sink = NULL;
 
   /* source elements */
-  camera->src_vid_src = NULL;
-  camera->src_filter = NULL;
-  camera->src_zoom_crop = NULL;
-  camera->src_zoom_scale = NULL;
-  camera->src_zoom_filter = NULL;
-  camera->src_out_sel = NULL;
+  /* XXX do I need to unref, or does gst_camerabin_remove_elements_from_bin
+   * do this for me? */
+  camera->srcbin = NULL;
 
   camera->active_bin = NULL;
 
@@ -908,25 +676,12 @@ camerabin_dispose_elements (GstCameraBin * camera)
     gst_object_unref (camera->app_vf_sink);
     camera->app_vf_sink = NULL;
   }
-  if (camera->app_vid_src) {
-    gst_object_unref (camera->app_vid_src);
-    camera->app_vid_src = NULL;
-  }
-
-  if (camera->app_video_filter) {
-    gst_object_unref (camera->app_video_filter);
-    camera->app_video_filter = NULL;
-  }
-
   if (camera->app_viewfinder_filter) {
     gst_object_unref (camera->app_viewfinder_filter);
     camera->app_viewfinder_filter = NULL;
   }
 
   /* Free caps */
-  gst_caps_replace (&camera->image_capture_caps, NULL);
-  gst_caps_replace (&camera->view_finder_caps, NULL);
-  gst_caps_replace (&camera->allowed_caps, NULL);
   gst_caps_replace (&camera->preview_caps, NULL);
   gst_caps_replace (&camera->video_preview_caps, NULL);
   gst_buffer_replace (&camera->video_preview_buffer, NULL);
@@ -984,6 +739,11 @@ gst_camerabin_change_mode (GstCameraBin * camera, gint mode)
         mode, camera->mode);
     /* Interrupt ongoing capture */
     gst_camerabin_do_stop (camera);
+    // XXX need to re-think this a bit.. originally camerabin
+    // had mode seperate from capturing state.. ie. either
+    // img or vid mode, but not capturing, is preview mode..
+    // but camsrcbin has img/vid/preview modes..  need to
+    // align concept of modes..
     camera->mode = mode;
     gst_element_get_state (GST_ELEMENT (camera), &state, NULL, 0);
     if (state == GST_STATE_PAUSED || state == GST_STATE_PLAYING) {
@@ -1053,172 +813,6 @@ gst_camerabin_change_filename (GstCameraBin * camera, const gchar * name)
   }
 }
 
-static gboolean
-gst_camerabin_set_videosrc_zoom (GstCameraBin * camera, gint zoom)
-{
-  gboolean ret = FALSE;
-
-  if (g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src_vid_src),
-          "zoom")) {
-    g_object_set (G_OBJECT (camera->src_vid_src), "zoom",
-        (gfloat) zoom / 100, NULL);
-    ret = TRUE;
-  }
-  return ret;
-}
-
-
-static gboolean
-gst_camerabin_set_element_zoom (GstCameraBin * camera, gint zoom)
-{
-  gint w2_crop = 0, h2_crop = 0;
-  GstPad *pad_zoom_sink = NULL;
-  gboolean ret = FALSE;
-  gint left = camera->base_crop_left;
-  gint right = camera->base_crop_right;
-  gint top = camera->base_crop_top;
-  gint bottom = camera->base_crop_bottom;
-
-  if (camera->src_zoom_crop) {
-    /* Update capsfilters to apply the zoom */
-    GST_INFO_OBJECT (camera, "zoom: %d, orig size: %dx%d", zoom,
-        camera->width, camera->height);
-
-    if (zoom != ZOOM_1X) {
-      w2_crop = (camera->width - (camera->width * ZOOM_1X / zoom)) / 2;
-      h2_crop = (camera->height - (camera->height * ZOOM_1X / zoom)) / 2;
-
-      left += w2_crop;
-      right += w2_crop;
-      top += h2_crop;
-      bottom += h2_crop;
-
-      /* force number of pixels cropped from left to be even, to avoid slow code
-       * path on videoscale */
-      left &= 0xFFFE;
-    }
-
-    pad_zoom_sink = gst_element_get_static_pad (camera->src_zoom_crop, "sink");
-
-    GST_INFO_OBJECT (camera,
-        "sw cropping: left:%d, right:%d, top:%d, bottom:%d", left, right, top,
-        bottom);
-
-    GST_PAD_STREAM_LOCK (pad_zoom_sink);
-    g_object_set (camera->src_zoom_crop, "left", left, "right", right, "top",
-        top, "bottom", bottom, NULL);
-    GST_PAD_STREAM_UNLOCK (pad_zoom_sink);
-    gst_object_unref (pad_zoom_sink);
-    ret = TRUE;
-  }
-  return ret;
-}
-
-/*
- * gst_camerabin_setup_zoom:
- * @camera: camerabin object
- *
- * Apply zoom configured to camerabin to capture.
- */
-static void
-gst_camerabin_setup_zoom (GstCameraBin * camera)
-{
-  gint zoom;
-
-  g_return_if_fail (camera != NULL);
-
-  zoom = g_atomic_int_get (&camera->zoom);
-
-  g_return_if_fail (zoom);
-
-  GST_INFO_OBJECT (camera, "setting zoom %d", zoom);
-
-  if (gst_camerabin_set_videosrc_zoom (camera, zoom)) {
-    gst_camerabin_set_element_zoom (camera, ZOOM_1X);
-    GST_INFO_OBJECT (camera, "zoom set using videosrc");
-  } else if (gst_camerabin_set_element_zoom (camera, zoom)) {
-    GST_INFO_OBJECT (camera, "zoom set using gst elements");
-  } else {
-    GST_INFO_OBJECT (camera, "setting zoom failed");
-  }
-}
-
-/*
- * gst_camerabin_get_allowed_input_caps:
- * @camera: camerabin object
- *
- * Retrieve caps from videosrc describing formats it supports
- *
- * Returns: caps object from videosrc
- */
-static GstCaps *
-gst_camerabin_get_allowed_input_caps (GstCameraBin * camera)
-{
-  GstCaps *caps = NULL;
-  GstPad *pad = NULL, *peer_pad = NULL;
-  GstState state;
-  GstElement *videosrc;
-
-  g_return_val_if_fail (camera != NULL, NULL);
-
-  videosrc = camera->src_vid_src ? camera->src_vid_src : camera->app_vid_src;
-
-  if (!videosrc) {
-    GST_WARNING_OBJECT (camera, "no videosrc, can't get allowed caps");
-    goto failed;
-  }
-
-  if (camera->allowed_caps) {
-    GST_DEBUG_OBJECT (camera, "returning cached caps");
-    goto done;
-  }
-
-  pad = gst_element_get_static_pad (videosrc, "src");
-
-  if (!pad) {
-    GST_WARNING_OBJECT (camera, "no srcpad in videosrc");
-    goto failed;
-  }
-
-  state = GST_STATE (videosrc);
-
-  /* Make this function work also in NULL state */
-  if (state == GST_STATE_NULL) {
-    GST_DEBUG_OBJECT (camera, "setting videosrc to ready temporarily");
-    peer_pad = gst_pad_get_peer (pad);
-    if (peer_pad) {
-      gst_pad_unlink (pad, peer_pad);
-    }
-    /* Set videosrc to READY to open video device */
-    gst_element_set_locked_state (videosrc, TRUE);
-    gst_element_set_state (videosrc, GST_STATE_READY);
-  }
-
-  camera->allowed_caps = gst_pad_get_caps (pad);
-
-  /* Restore state and re-link if necessary */
-  if (state == GST_STATE_NULL) {
-    GST_DEBUG_OBJECT (camera, "restoring videosrc state %d", state);
-    /* Reset videosrc to NULL state, some drivers seem to need this */
-    gst_element_set_state (videosrc, GST_STATE_NULL);
-    if (peer_pad) {
-      gst_pad_link (pad, peer_pad);
-      gst_object_unref (peer_pad);
-    }
-    gst_element_set_locked_state (videosrc, FALSE);
-  }
-
-  gst_object_unref (pad);
-
-done:
-  if (camera->allowed_caps) {
-    caps = gst_caps_copy (camera->allowed_caps);
-  }
-  GST_DEBUG_OBJECT (camera, "allowed caps:%" GST_PTR_FORMAT, caps);
-failed:
-  return caps;
-}
-
 /*
  * gst_camerabin_send_img_queue_event:
  * @camera: camerabin object
@@ -1328,17 +922,21 @@ gst_camerabin_get_internal_tags (GstCameraBin * camera)
   const GList *controls = NULL, *item;
   GstColorBalanceChannel *channel;
   gint min_value, max_value, mid_value, cur_value;
+  gint width, height, zoom;
 
   if (camera->active_bin == camera->vidbin) {
     /* FIXME: check if internal video tag setting is needed */
     goto done;
   }
 
+  g_object_get (camera->srcbin, "width", &width, "height", &height,
+      "zoom", &zoom, NULL);
+
   gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
-      "image-width", camera->width, "image-height", camera->height, NULL);
+      "image-width", width, "image-height", height, NULL);
 
   gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
-      "capture-digital-zoom", camera->zoom, 100, NULL);
+      "capture-digital-zoom", zoom, 100, NULL);
 
   if (gst_element_implements_interface (GST_ELEMENT (camera),
           GST_TYPE_COLOR_BALANCE)) {
@@ -1432,56 +1030,6 @@ gst_camerabin_rewrite_tags (GstCameraBin * camera)
 }
 
 /*
- * gst_camerabin_set_capsfilter_caps:
- * @camera: camerabin object
- * @new_caps: pointer to caps object to set
- *
- * Set given caps to camerabin capsfilters.
- */
-static void
-gst_camerabin_set_capsfilter_caps (GstCameraBin * camera, GstCaps * new_caps)
-{
-  GST_INFO_OBJECT (camera, "new_caps:%" GST_PTR_FORMAT, new_caps);
-
-  gst_camerabin_configure_format (camera, new_caps);
-
-  /* Update zoom */
-  gst_camerabin_setup_zoom (camera);
-
-  /* Update capsfilters */
-  g_object_set (G_OBJECT (camera->src_filter), "caps", new_caps, NULL);
-  if (camera->src_zoom_filter)
-    g_object_set (G_OBJECT (camera->src_zoom_filter), "caps", new_caps, NULL);
-  gst_camerabin_update_aspect_filter (camera, new_caps);
-  GST_INFO_OBJECT (camera, "udpated");
-}
-
-/*
- * img_capture_prepared:
- * @data: camerabin object
- * @caps: caps describing the prepared image format
- *
- * Callback which is called after image capture has been prepared.
- */
-static void
-img_capture_prepared (gpointer data, GstCaps * caps)
-{
-  GstCameraBin *camera = GST_CAMERABIN (data);
-
-  GST_INFO_OBJECT (camera, "image capture prepared");
-
-  /* It is possible we are about to get something else that we requested */
-  if (!gst_caps_is_equal (camera->image_capture_caps, caps)) {
-    gst_camerabin_adapt_image_capture (camera, caps);
-  } else {
-    gst_camerabin_set_capsfilter_caps (camera, camera->image_capture_caps);
-  }
-
-  g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", FALSE,
-      "active-pad", camera->pad_src_img, NULL);
-}
-
-/*
  * gst_camerabin_start_image_capture:
  * @camera: camerabin object
  *
@@ -1490,54 +1038,19 @@ img_capture_prepared (gpointer data, GstCaps * caps)
 static void
 gst_camerabin_start_image_capture (GstCameraBin * camera)
 {
-  gboolean wait_for_prepare = FALSE, ret = FALSE;
+  gboolean ret = FALSE;
 
   GST_INFO_OBJECT (camera, "starting image capture");
 
-  if (GST_IS_ELEMENT (camera->src_vid_src) &&
-      gst_element_implements_interface (camera->src_vid_src,
-          GST_TYPE_PHOTOGRAPHY)) {
-    /* Start image capture preparations using photography iface */
-    wait_for_prepare = TRUE;
-    g_mutex_lock (camera->capture_mutex);
+  g_mutex_lock (camera->capture_mutex);
 
-    /* Enable still image capture mode in v4l2camsrc */
-    if (g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src_vid_src),
-            "capture-mode")) {
-      g_object_set (G_OBJECT (camera->src_vid_src), "capture-mode", 1, NULL);
-    }
+  /* Enable still image capture mode in v4l2camsrc */
+  ret = gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (camera->srcbin),
+      MODE_IMAGE);
 
-    if (!camera->image_capture_caps || camera->image_capture_caps_update) {
-      if (camera->image_capture_width && camera->image_capture_height) {
-        /* Resolution is set, but it isn't in use yet */
-        gst_camerabin_set_image_capture_caps (camera,
-            camera->image_capture_width, camera->image_capture_height);
-      } else {
-        /* Capture resolution not set. Use viewfinder resolution */
-        camera->image_capture_caps = gst_caps_copy (camera->view_finder_caps);
-        camera->image_capture_caps_update = FALSE;
-      }
-    }
+  camera->capturing = TRUE;
 
-    /* Start preparations for image capture */
-    GST_DEBUG_OBJECT (camera, "prepare image capture caps %" GST_PTR_FORMAT,
-        camera->image_capture_caps);
-    ret =
-        gst_photography_prepare_for_capture (GST_PHOTOGRAPHY
-        (camera->src_vid_src), (GstPhotoCapturePrepared) img_capture_prepared,
-        camera->image_capture_caps, camera);
-    camera->capturing = TRUE;
-    g_mutex_unlock (camera->capture_mutex);
-  }
-
-  if (!wait_for_prepare) {
-    g_mutex_lock (camera->capture_mutex);
-    g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", TRUE,
-        "active-pad", camera->pad_src_img, NULL);
-    camera->capturing = TRUE;
-    ret = TRUE;
-    g_mutex_unlock (camera->capture_mutex);
-  }
+  g_mutex_unlock (camera->capture_mutex);
 
   if (!ret) {
     GST_WARNING_OBJECT (camera, "starting image capture failed");
@@ -1551,10 +1064,9 @@ static void
 reset_video_capture_caps (GstCameraBin * camera)
 {
   GstState state, pending;
-  GstPad *activepad = NULL;
 
-  GST_INFO_OBJECT (camera, "switching resolution to %dx%d and fps to %d/%d",
-      camera->width, camera->height, camera->fps_n, camera->fps_d);
+//XXX  GST_INFO_OBJECT (camera, "switching resolution to %dx%d and fps to %d/%d",
+//XXX      camera->width, camera->height, camera->fps_n, camera->fps_d);
 
   /* Interrupt ongoing capture */
   gst_camerabin_do_stop (camera);
@@ -1563,8 +1075,6 @@ reset_video_capture_caps (GstCameraBin * camera)
   if (state == GST_STATE_PAUSED || state == GST_STATE_PLAYING) {
     GST_INFO_OBJECT (camera,
         "changing to READY to initialize videosrc with new format");
-    g_object_get (G_OBJECT (camera->src_out_sel), "active-pad", &activepad,
-        NULL);
     gst_element_set_state (GST_ELEMENT (camera), GST_STATE_READY);
   }
   if (pending != GST_STATE_VOID_PENDING) {
@@ -1573,15 +1083,6 @@ reset_video_capture_caps (GstCameraBin * camera)
     state = pending;
   }
 
-  /* Re-set the active pad since switching camerabin to READY state clears this
-   * setting in output-selector */
-  if (activepad) {
-    GST_INFO_OBJECT (camera, "re-setting active pad in output-selector");
-
-    g_object_set (G_OBJECT (camera->src_out_sel), "active-pad", activepad,
-        NULL);
-  }
-
   gst_element_set_state (GST_ELEMENT (camera), state);
 }
 
@@ -1617,14 +1118,8 @@ gst_camerabin_start_video_recording (GstCameraBin * camera)
     gst_element_set_locked_state (camera->vidbin, FALSE);
     /* ensure elements activated before feeding data into it */
     state_ret = gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PAUSED);
-    g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", FALSE,
-        "active-pad", camera->pad_src_vid, NULL);
-
-    /* Enable video mode in v4l2camsrc */
-    if (g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src_vid_src),
-            "capture-mode")) {
-      g_object_set (G_OBJECT (camera->src_vid_src), "capture-mode", 2, NULL);
-    }
+    gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (camera->srcbin),
+        MODE_VIDEO);
     gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING);
     gst_element_set_locked_state (camera->vidbin, TRUE);
   } else {
@@ -1773,7 +1268,7 @@ gst_camerabin_have_img_buffer (GstPad * pad, GstBuffer * buffer,
 
   /* Add buffer probe to outputselector's sink pad. It sends
      EOS event to image queue. */
-  os_sink = gst_element_get_static_pad (camera->src_out_sel, "sink");
+  os_sink = gst_element_get_static_pad (camera->srcbin, "imgsrc");      // XXX ok to have on srcpad instead of sinkpad??
   camera->image_captured_id = gst_pad_add_buffer_probe (os_sink,
       G_CALLBACK (gst_camerabin_have_src_buffer), camera);
   gst_object_unref (os_sink);
@@ -1782,7 +1277,8 @@ done:
 
   /* HACK: v4l2camsrc changes to view finder resolution automatically
      after one captured still image */
-  gst_camerabin_finish_image_capture (camera);
+  gst_base_camera_src_finish_image_capture (GST_BASE_CAMERA_SRC
+      (camera->srcbin));
 
   GST_DEBUG_OBJECT (camera, "image captured, switching to viewfinder");
 
@@ -1960,12 +1456,6 @@ gst_camerabin_reset_to_view_finder (GstCameraBin * camera)
   GstStateChangeReturn state_ret;
   GST_DEBUG_OBJECT (camera, "resetting");
 
-  if (camera->src_out_sel) {
-    /* Set selector to forward data to view finder */
-    g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", FALSE,
-        "active-pad", camera->pad_src_view, NULL);
-  }
-
   /* Set video bin to READY state */
   if (camera->active_bin == camera->vidbin) {
     state_ret = gst_element_set_state (camera->active_bin, GST_STATE_READY);
@@ -1982,11 +1472,8 @@ gst_camerabin_reset_to_view_finder (GstCameraBin * camera)
   camera->eos_handled = FALSE;
 
   /* Enable view finder mode in v4l2camsrc */
-  if (camera->src_vid_src &&
-      g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src_vid_src),
-          "capture-mode")) {
-    g_object_set (G_OBJECT (camera->src_vid_src), "capture-mode", 0, NULL);
-  }
+  gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (camera->srcbin),
+      MODE_PREVIEW);
 
   GST_DEBUG_OBJECT (camera, "reset done");
 }
@@ -2047,392 +1534,6 @@ gst_camerabin_default_signal_img_done (GstCameraBin * camera,
   return FALSE;
 }
 
-/*
- * gst_camerabin_set_allowed_framerate:
- * @camera: camerabin object
- * @filter_caps: update allowed framerate to these caps
- *
- * Find allowed frame rate from video source that matches with
- * resolution in @filter_caps. Set found frame rate to @filter_caps.
- */
-static void
-gst_camerabin_set_allowed_framerate (GstCameraBin * camera,
-    GstCaps * filter_caps)
-{
-  GstStructure *structure;
-  GstCaps *allowed_caps = NULL, *intersect = NULL, *tmp_caps = NULL;
-  const GValue *framerate = NULL;
-  guint caps_size, i;
-  guint32 format = 0;
-
-  GST_INFO_OBJECT (camera, "filter caps:%" GST_PTR_FORMAT, filter_caps);
-
-  structure = gst_structure_copy (gst_caps_get_structure (filter_caps, 0));
-
-  /* Set fourcc format according to current videosrc format */
-  format = get_srcpad_current_format (camera->src_vid_src);
-  if (format) {
-    GST_DEBUG_OBJECT (camera,
-        "using format %" GST_FOURCC_FORMAT " for matching",
-        GST_FOURCC_ARGS (format));
-    gst_structure_set (structure, "format", GST_TYPE_FOURCC, format, NULL);
-  } else {
-    GST_DEBUG_OBJECT (camera, "not matching against fourcc format");
-    gst_structure_remove_field (structure, "format");
-  }
-
-  tmp_caps = gst_caps_new_full (structure, NULL);
-
-  /* Get supported caps from video src that matches with new filter caps */
-  allowed_caps = gst_camerabin_get_allowed_input_caps (camera);
-  intersect = gst_caps_intersect (allowed_caps, tmp_caps);
-  GST_INFO_OBJECT (camera, "intersect caps:%" GST_PTR_FORMAT, intersect);
-
-  /* Find the best framerate from the caps */
-  caps_size = gst_caps_get_size (intersect);
-  for (i = 0; i < caps_size; i++) {
-    structure = gst_caps_get_structure (intersect, i);
-    framerate =
-        gst_camerabin_find_better_framerate (camera, structure, framerate);
-  }
-
-  /* Set found frame rate to original caps */
-  if (GST_VALUE_HOLDS_FRACTION (framerate)) {
-    gst_caps_set_simple (filter_caps,
-        "framerate", GST_TYPE_FRACTION,
-        gst_value_get_fraction_numerator (framerate),
-        gst_value_get_fraction_denominator (framerate), NULL);
-  }
-
-  /* Unref helper caps */
-  if (allowed_caps) {
-    gst_caps_unref (allowed_caps);
-  }
-  if (intersect) {
-    gst_caps_unref (intersect);
-  }
-  if (tmp_caps) {
-    gst_caps_unref (tmp_caps);
-  }
-}
-
-
-/**
- * get_srcpad_current_format:
- * @element: element to get the format from
- *
- * Helper function to get the negotiated fourcc
- * format from @element src pad.
- *
- * Returns: negotiated format (fourcc), 0 if not found
- */
-static guint32
-get_srcpad_current_format (GstElement * element)
-{
-  GstPad *srcpad = NULL;
-  GstCaps *srccaps = NULL;
-  GstStructure *structure;
-  guint32 format = 0;
-
-  g_return_val_if_fail (element != NULL, 0);
-
-  if ((srcpad = gst_element_get_static_pad (element, "src")) == NULL) {
-    goto no_pad;
-  }
-
-  if ((srccaps = gst_pad_get_negotiated_caps (srcpad)) == NULL) {
-    goto no_caps;
-  }
-
-  GST_LOG ("negotiated caps %" GST_PTR_FORMAT, srccaps);
-
-  structure = gst_caps_get_structure (srccaps, 0);
-  if (gst_structure_has_field (structure, "format")) {
-    gst_structure_get_fourcc (structure, "format", &format);
-  }
-
-  gst_caps_unref (srccaps);
-no_caps:
-  gst_object_unref (srcpad);
-no_pad:
-  GST_DEBUG ("current format for %" GST_PTR_FORMAT ": %" GST_FOURCC_FORMAT,
-      element, GST_FOURCC_ARGS (format));
-  return format;
-}
-
-/*
- * gst_camerabin_find_better_framerate:
- * @camera: camerabin object
- * @st: structure that contains framerate candidates
- * @orig_framerate: best framerate so far
- *
- * Looks for framerate better than @orig_framerate from @st structure.
- * In night mode lowest framerate is considered best, otherwise highest is
- * best.
- *
- * Returns: @orig_framerate or better if found
- */
-static const GValue *
-gst_camerabin_find_better_framerate (GstCameraBin * camera, GstStructure * st,
-    const GValue * orig_framerate)
-{
-  const GValue *framerate = NULL;
-  guint i, i_best, list_size;
-  gint res, comparison;
-
-  if (camera->night_mode) {
-    GST_LOG_OBJECT (camera, "finding min framerate in %" GST_PTR_FORMAT, st);
-    comparison = GST_VALUE_LESS_THAN;
-  } else {
-    GST_LOG_OBJECT (camera, "finding max framerate in %" GST_PTR_FORMAT, st);
-    comparison = GST_VALUE_GREATER_THAN;
-  }
-
-  if (gst_structure_has_field (st, "framerate")) {
-    framerate = gst_structure_get_value (st, "framerate");
-    /* Handle framerate lists */
-    if (GST_VALUE_HOLDS_LIST (framerate)) {
-      list_size = gst_value_list_get_size (framerate);
-      GST_LOG_OBJECT (camera, "finding framerate from list");
-      for (i = 0, i_best = 0; i < list_size; i++) {
-        res = gst_value_compare (gst_value_list_get_value (framerate, i),
-            gst_value_list_get_value (framerate, i_best));
-        if (comparison == res) {
-          i_best = i;
-        }
-      }
-      GST_LOG_OBJECT (camera, "found best framerate from index %d", i_best);
-      framerate = gst_value_list_get_value (framerate, i_best);
-    }
-    /* Handle framerate ranges */
-    if (GST_VALUE_HOLDS_FRACTION_RANGE (framerate)) {
-      if (camera->night_mode) {
-        GST_LOG_OBJECT (camera, "getting min framerate from range");
-        framerate = gst_value_get_fraction_range_min (framerate);
-      } else {
-        GST_LOG_OBJECT (camera, "getting max framerate from range");
-        framerate = gst_value_get_fraction_range_max (framerate);
-      }
-    }
-  }
-
-  /* Check if we found better framerate */
-  if (orig_framerate && framerate) {
-    res = gst_value_compare (orig_framerate, framerate);
-    if (comparison == res) {
-      GST_LOG_OBJECT (camera, "original framerate was the best");
-      framerate = orig_framerate;
-    }
-  }
-
-  return framerate;
-}
-
-/*
- * gst_camerabin_update_aspect_filter:
- * @camera: camerabin object
- * @new_caps: new caps of next buffers arriving to view finder sink element
- *
- * Updates aspect ratio capsfilter to maintain aspect ratio, if we need to
- * scale frames for showing them in view finder.
- */
-static void
-gst_camerabin_update_aspect_filter (GstCameraBin * camera, GstCaps * new_caps)
-{
-  if (camera->flags & GST_CAMERABIN_FLAG_VIEWFINDER_SCALE) {
-    GstCaps *sink_caps, *ar_caps;
-    GstStructure *st;
-    gint in_w = 0, in_h = 0, sink_w = 0, sink_h = 0, target_w = 0, target_h = 0;
-    gdouble ratio_w, ratio_h;
-    GstPad *sink_pad;
-    const GValue *range;
-
-    sink_pad = gst_element_get_static_pad (camera->view_sink, "sink");
-
-    if (sink_pad) {
-      sink_caps = gst_pad_get_caps (sink_pad);
-      gst_object_unref (sink_pad);
-      if (sink_caps) {
-        if (!gst_caps_is_any (sink_caps)) {
-          GST_DEBUG_OBJECT (camera, "sink element caps %" GST_PTR_FORMAT,
-              sink_caps);
-          /* Get maximum resolution that view finder sink accepts */
-          st = gst_caps_get_structure (sink_caps, 0);
-          if (gst_structure_has_field_typed (st, "width", GST_TYPE_INT_RANGE)) {
-            range = gst_structure_get_value (st, "width");
-            sink_w = gst_value_get_int_range_max (range);
-          }
-          if (gst_structure_has_field_typed (st, "height", GST_TYPE_INT_RANGE)) {
-            range = gst_structure_get_value (st, "height");
-            sink_h = gst_value_get_int_range_max (range);
-          }
-          GST_DEBUG_OBJECT (camera, "sink element accepts max %dx%d", sink_w,
-              sink_h);
-
-          /* Get incoming frames' resolution */
-          if (sink_h && sink_w) {
-            st = gst_caps_get_structure (new_caps, 0);
-            gst_structure_get_int (st, "width", &in_w);
-            gst_structure_get_int (st, "height", &in_h);
-            GST_DEBUG_OBJECT (camera, "new caps with %dx%d", in_w, in_h);
-          }
-        }
-        gst_caps_unref (sink_caps);
-      }
-    }
-
-    /* If we get bigger frames than view finder sink accepts, then we scale.
-       If we scale we need to adjust aspect ratio capsfilter caps in order
-       to maintain aspect ratio while scaling. */
-    if (in_w && in_h && (in_w > sink_w || in_h > sink_h)) {
-      ratio_w = (gdouble) sink_w / in_w;
-      ratio_h = (gdouble) sink_h / in_h;
-
-      if (ratio_w < ratio_h) {
-        target_w = sink_w;
-        target_h = (gint) (ratio_w * in_h);
-      } else {
-        target_w = (gint) (ratio_h * in_w);
-        target_h = sink_h;
-      }
-
-      GST_DEBUG_OBJECT (camera, "setting %dx%d filter to maintain aspect ratio",
-          target_w, target_h);
-      ar_caps = gst_caps_copy (new_caps);
-      gst_caps_set_simple (ar_caps, "width", G_TYPE_INT, target_w, "height",
-          G_TYPE_INT, target_h, NULL);
-    } else {
-      GST_DEBUG_OBJECT (camera, "no scaling");
-      ar_caps = new_caps;
-    }
-
-    GST_DEBUG_OBJECT (camera, "aspect ratio filter caps %" GST_PTR_FORMAT,
-        ar_caps);
-    g_object_set (G_OBJECT (camera->aspect_filter), "caps", ar_caps, NULL);
-    if (ar_caps != new_caps)
-      gst_caps_unref (ar_caps);
-  }
-}
-
-/*
- * gst_camerabin_finish_image_capture:
- * @camera: camerabin object
- *
- * Perform finishing operations after image capture is done and
- * returning back to view finder mode.
- */
-static void
-gst_camerabin_finish_image_capture (GstCameraBin * camera)
-{
-  if (camera->image_capture_caps) {
-    /* If we used specific caps for image capture we need to 
-       restore the caps and zoom/crop for view finder mode */
-    if (camera->src_zoom_crop) {
-      GST_DEBUG_OBJECT (camera, "resetting crop in camerabin");
-      g_object_set (camera->src_zoom_crop, "left", 0, "right", 0,
-          "top", 0, "bottom", 0, NULL);
-    }
-    camera->base_crop_left = 0;
-    camera->base_crop_right = 0;
-    camera->base_crop_top = 0;
-    camera->base_crop_bottom = 0;
-    gst_camerabin_set_capsfilter_caps (camera, camera->view_finder_caps);
-  }
-}
-
-/*
- * gst_camerabin_adapt_image_capture:
- * @camera: camerabin object
- * @in_caps: caps object that describes incoming image format
- *
- * Adjust capsfilters and crop according image capture caps if necessary.
- * The captured image format from video source might be different from
- * what application requested, so we can try to fix that in camerabin.
- *
- */
-static void
-gst_camerabin_adapt_image_capture (GstCameraBin * camera, GstCaps * in_caps)
-{
-  GstStructure *in_st, *new_st, *req_st;
-  gint in_width = 0, in_height = 0, req_width = 0, req_height = 0, crop = 0;
-  gdouble ratio_w, ratio_h;
-  GstCaps *filter_caps = NULL;
-
-  GST_LOG_OBJECT (camera, "in caps: %" GST_PTR_FORMAT, in_caps);
-  GST_LOG_OBJECT (camera, "requested caps: %" GST_PTR_FORMAT,
-      camera->image_capture_caps);
-
-  in_st = gst_caps_get_structure (in_caps, 0);
-  gst_structure_get_int (in_st, "width", &in_width);
-  gst_structure_get_int (in_st, "height", &in_height);
-
-  req_st = gst_caps_get_structure (camera->image_capture_caps, 0);
-  gst_structure_get_int (req_st, "width", &req_width);
-  gst_structure_get_int (req_st, "height", &req_height);
-
-  GST_INFO_OBJECT (camera, "we requested %dx%d, and got %dx%d", req_width,
-      req_height, in_width, in_height);
-
-  new_st = gst_structure_copy (req_st);
-  /* If new fields have been added, we need to copy them */
-  gst_structure_foreach (in_st, copy_missing_fields, new_st);
-
-  if (!(camera->flags & GST_CAMERABIN_FLAG_SOURCE_RESIZE)) {
-    GST_DEBUG_OBJECT (camera,
-        "source-resize flag disabled, unable to adapt resolution");
-    gst_structure_set (new_st, "width", G_TYPE_INT, in_width, "height",
-        G_TYPE_INT, in_height, NULL);
-  }
-
-  GST_LOG_OBJECT (camera, "new image capture caps: %" GST_PTR_FORMAT, new_st);
-
-  /* Crop if requested aspect ratio differs from incoming frame aspect ratio */
-  if (camera->src_zoom_crop) {
-
-    ratio_w = (gdouble) in_width / req_width;
-    ratio_h = (gdouble) in_height / req_height;
-
-    if (ratio_w < ratio_h) {
-      crop = in_height - (req_height * ratio_w);
-      camera->base_crop_top = crop / 2;
-      camera->base_crop_bottom = crop / 2;
-    } else {
-      crop = in_width - (req_width * ratio_h);
-      camera->base_crop_left = crop / 2;
-      camera->base_crop_right += crop / 2;
-    }
-
-    GST_INFO_OBJECT (camera,
-        "setting base crop: left:%d, right:%d, top:%d, bottom:%d",
-        camera->base_crop_left, camera->base_crop_right, camera->base_crop_top,
-        camera->base_crop_bottom);
-    g_object_set (G_OBJECT (camera->src_zoom_crop), "top",
-        camera->base_crop_top, "bottom", camera->base_crop_bottom, "left",
-        camera->base_crop_left, "right", camera->base_crop_right, NULL);
-  }
-
-  /* Update capsfilters */
-  gst_caps_replace (&camera->image_capture_caps,
-      gst_caps_new_full (new_st, NULL));
-  gst_camerabin_set_capsfilter_caps (camera, camera->image_capture_caps);
-
-  /* Adjust the capsfilter before crop and videoscale elements if necessary */
-  if (in_width == camera->width && in_height == camera->height) {
-    GST_DEBUG_OBJECT (camera, "no adaptation with resolution needed");
-  } else {
-    GST_DEBUG_OBJECT (camera,
-        "changing %" GST_PTR_FORMAT " from %dx%d to %dx%d", camera->src_filter,
-        camera->width, camera->height, in_width, in_height);
-    /* Apply the width and height to filter caps */
-    g_object_get (G_OBJECT (camera->src_filter), "caps", &filter_caps, NULL);
-    filter_caps = gst_caps_make_writable (filter_caps);
-    gst_caps_set_simple (filter_caps, "width", G_TYPE_INT, in_width, "height",
-        G_TYPE_INT, in_height, NULL);
-    g_object_set (G_OBJECT (camera->src_filter), "caps", filter_caps, NULL);
-    gst_caps_unref (filter_caps);
-  }
-}
-
 static void
 gst_camerabin_proxy_notify_cb (GObject * video_source, GParamSpec * pspec,
     gpointer user_data)
@@ -2457,18 +1558,19 @@ gst_camerabin_proxy_notify_cb (GObject * video_source, GParamSpec * pspec,
 static void
 gst_camerabin_monitor_video_source_properties (GstCameraBin * camera)
 {
+  GstPhotography *photography;
   GParamSpec **properties;
   gchar *notify_string;
   gpointer photo_iface;
   guint i, n_properties = 0;
 
   GST_DEBUG_OBJECT (camera, "checking for photography interface support");
-  if (GST_IS_ELEMENT (camera->src_vid_src) &&
-      gst_element_implements_interface (camera->src_vid_src,
-          GST_TYPE_PHOTOGRAPHY)) {
+  photography =
+      gst_base_camera_src_get_photography (GST_BASE_CAMERA_SRC
+      (camera->srcbin));
+  if (photography) {
     GST_DEBUG_OBJECT (camera,
-        "start monitoring property changes in %" GST_PTR_FORMAT,
-        camera->src_vid_src);
+        "start monitoring property changes in %" GST_PTR_FORMAT, photography);
     photo_iface = g_type_default_interface_ref (GST_TYPE_PHOTOGRAPHY);
     properties =
         g_object_interface_list_properties (photo_iface, &n_properties);
@@ -2478,8 +1580,8 @@ gst_camerabin_monitor_video_source_properties (GstCameraBin * camera)
             g_strconcat ("notify::", g_param_spec_get_name (properties[i]),
             NULL);
         GST_DEBUG_OBJECT (camera, "connecting to %" GST_PTR_FORMAT " - %s",
-            camera->src_vid_src, notify_string);
-        g_signal_connect (G_OBJECT (camera->src_vid_src), notify_string,
+            photography, notify_string);
+        g_signal_connect (G_OBJECT (photography), notify_string,
             (GCallback) gst_camerabin_proxy_notify_cb, camera);
         g_free (notify_string);
       }
@@ -2489,43 +1591,6 @@ gst_camerabin_monitor_video_source_properties (GstCameraBin * camera)
 }
 
 /*
- * gst_camerabin_configure_format:
- * @camera: camerabin object
- * @caps: caps describing new format
- *
- * Configure internal video format for camerabin.
- *
- */
-static void
-gst_camerabin_configure_format (GstCameraBin * camera, GstCaps * caps)
-{
-  GstStructure *st;
-
-  st = gst_caps_get_structure (caps, 0);
-
-  gst_structure_get_int (st, "width", &camera->width);
-  gst_structure_get_int (st, "height", &camera->height);
-
-  if (gst_structure_has_field_typed (st, "framerate", GST_TYPE_FRACTION)) {
-    gst_structure_get_fraction (st, "framerate", &camera->fps_n,
-        &camera->fps_d);
-  }
-}
-
-static gboolean
-copy_missing_fields (GQuark field_id, const GValue * value, gpointer user_data)
-{
-  GstStructure *st = (GstStructure *) user_data;
-  const GValue *val = gst_structure_id_get_value (st, field_id);
-
-  if (G_UNLIKELY (val == NULL)) {
-    gst_structure_id_set_value (st, field_id, value);
-  }
-
-  return TRUE;
-}
-
-/*
 * gst_camerabin_change_viewfinder_blocking:
 * @camera: camerabin object
 * @blocked: new viewfinder blocking state
@@ -3076,41 +2141,25 @@ gst_camerabin_init (GstCameraBin * camera, GstCameraBinClass * gclass)
   camera->stop_requested = FALSE;
   camera->paused = FALSE;
   camera->capturing = FALSE;
-  camera->night_mode = FALSE;
   camera->eos_handled = FALSE;
 
-  camera->width = DEFAULT_WIDTH;
-  camera->height = DEFAULT_HEIGHT;
-  camera->fps_n = DEFAULT_FPS_N;
-  camera->fps_d = DEFAULT_FPS_D;
-  camera->image_capture_width = 0;
-  camera->image_capture_height = 0;
-  camera->base_crop_left = 0;
-  camera->base_crop_right = 0;
-  camera->base_crop_top = 0;
-  camera->base_crop_bottom = 0;
-
   camera->event_tags = gst_tag_list_new ();
 
-  camera->image_capture_caps = NULL;
-  camera->view_finder_caps = NULL;
-  camera->allowed_caps = NULL;
-
-  camera->zoom = DEFAULT_ZOOM;
-
   /* concurrency control */
   camera->capture_mutex = g_mutex_new ();
   camera->cond = g_cond_new ();
 
   /* pad names for output and input selectors */
   camera->pad_src_view = NULL;
-  camera->pad_view_src = NULL;
   camera->pad_src_img = NULL;
   camera->pad_src_vid = NULL;
-  camera->pad_view_vid = NULL;
 
   camera->video_preview_buffer = NULL;
 
+  /* camera src bin */
+  camera->srcbin = g_object_new (GST_TYPE_V4L2_CAMERA_SRC, NULL);
+  gst_object_ref (camera->srcbin);      /* XXX why is this? */
+
   /* image capture bin */
   camera->imgbin = g_object_new (GST_TYPE_CAMERABIN_IMAGE, NULL);
   gst_object_ref (camera->imgbin);
@@ -3120,7 +2169,6 @@ gst_camerabin_init (GstCameraBin * camera, GstCameraBinClass * gclass)
   gst_object_ref (camera->vidbin);
 
   /* view finder elements */
-  camera->view_in_sel = NULL;
   camera->view_scale = NULL;
   camera->aspect_filter = NULL;
   camera->view_sink = NULL;
@@ -3128,16 +2176,6 @@ gst_camerabin_init (GstCameraBin * camera, GstCameraBinClass * gclass)
   camera->app_vf_sink = NULL;
   camera->app_viewfinder_filter = NULL;
 
-  /* source elements */
-  camera->src_vid_src = NULL;
-  camera->src_filter = NULL;
-  camera->src_zoom_crop = NULL;
-  camera->src_zoom_scale = NULL;
-  camera->src_zoom_filter = NULL;
-  camera->src_out_sel = NULL;
-
-  camera->app_video_filter = NULL;
-
   camera->active_bin = NULL;
 
   memset (&camera->photo_settings, 0, sizeof (GstPhotoSettings));
@@ -3235,12 +2273,6 @@ gst_camerabin_set_property (GObject * object, guint prop_id,
       gst_camerabin_video_set_mute (GST_CAMERABIN_VIDEO (camera->vidbin),
           g_value_get_boolean (value));
       break;
-    case ARG_ZOOM:
-      g_atomic_int_set (&camera->zoom, g_value_get_int (value));
-      /* does not set it if in NULL, the src is not created yet */
-      if (GST_STATE (camera) != GST_STATE_NULL)
-        gst_camerabin_setup_zoom (camera);
-      break;
     case ARG_MODE:
       gst_camerabin_change_mode (camera, g_value_get_enum (value));
       break;
@@ -3311,19 +2343,6 @@ gst_camerabin_set_property (GObject * object, guint prop_id,
           gst_object_ref (camera->app_vf_sink);
       }
       break;
-    case ARG_VIDEO_SRC:
-      if (GST_STATE (camera) != GST_STATE_NULL) {
-        GST_ELEMENT_ERROR (camera, CORE, FAILED,
-            ("camerabin must be in NULL state when setting the video source element"),
-            (NULL));
-      } else {
-        if (camera->app_vid_src)
-          gst_object_unref (camera->app_vid_src);
-        camera->app_vid_src = g_value_get_object (value);
-        if (camera->app_vid_src)
-          gst_object_ref (camera->app_vid_src);
-      }
-      break;
     case ARG_AUDIO_SRC:
       if (GST_STATE (camera->vidbin) != GST_STATE_NULL) {
         GST_WARNING_OBJECT (camera,
@@ -3332,27 +2351,6 @@ gst_camerabin_set_property (GObject * object, guint prop_id,
       gst_camerabin_video_set_audio_src (GST_CAMERABIN_VIDEO (camera->vidbin),
           g_value_get_object (value));
       break;
-    case ARG_VIDEO_SOURCE_FILTER:
-      if (GST_STATE (camera) != GST_STATE_NULL) {
-        GST_ELEMENT_ERROR (camera, CORE, FAILED,
-            ("camerabin must be in NULL state when setting the video filter element"),
-            (NULL));
-      } else {
-        if (camera->app_video_filter)
-          gst_object_unref (camera->app_video_filter);
-        camera->app_video_filter = g_value_dup_object (value);
-      }
-      break;
-    case ARG_FILTER_CAPS:
-      GST_OBJECT_LOCK (camera);
-      gst_caps_replace (&camera->view_finder_caps,
-          (GstCaps *) gst_value_get_caps (value));
-      GST_OBJECT_UNLOCK (camera);
-      if (!camera->view_finder_caps)
-        camera->view_finder_caps =
-            gst_caps_from_string (CAMERABIN_DEFAULT_VF_CAPS);
-      gst_camerabin_configure_format (camera, camera->view_finder_caps);
-      break;
     case ARG_PREVIEW_CAPS:
     {
       GstElement **prev_pipe = NULL;
@@ -3402,59 +2400,18 @@ gst_camerabin_set_property (GObject * object, guint prop_id,
       gst_camerabin_change_viewfinder_blocking (camera,
           g_value_get_boolean (value));
       break;
+    case ARG_ZOOM:
+    case ARG_FILTER_CAPS:
+    case ARG_VIDEO_SOURCE_FILTER:
+    case ARG_VIDEO_SRC:
     case ARG_IMAGE_CAPTURE_WIDTH:
-    {
-      gint width = g_value_get_int (value);
-
-      if (width != camera->image_capture_width) {
-        camera->image_capture_width = width;
-        camera->image_capture_caps_update = TRUE;
-      }
-    }
-      break;
     case ARG_IMAGE_CAPTURE_HEIGHT:
-    {
-      gint height = g_value_get_int (value);
-
-      if (height != camera->image_capture_height) {
-        camera->image_capture_height = height;
-        camera->image_capture_caps_update = TRUE;
-      }
-    }
-      break;
     case ARG_VIDEO_CAPTURE_WIDTH:
-    {
-      gint width = g_value_get_int (value);
-
-      if (width != camera->width) {
-        camera->width = width;
-        camera->video_capture_caps_update = TRUE;
-      }
-    }
-      break;
     case ARG_VIDEO_CAPTURE_HEIGHT:
-    {
-      gint height = g_value_get_int (value);
-
-      if (height != camera->height) {
-        camera->height = height;
-        camera->video_capture_caps_update = TRUE;
-      }
-    }
-      break;
     case ARG_VIDEO_CAPTURE_FRAMERATE:
-    {
-      gint fps_n, fps_d;
-
-      fps_n = gst_value_get_fraction_numerator (value);
-      fps_d = gst_value_get_fraction_denominator (value);
-
-      if (fps_n != camera->fps_n || fps_d != camera->fps_d) {
-        camera->fps_n = fps_n;
-        camera->fps_d = fps_d;
-        camera->video_capture_caps_update = TRUE;
-      }
-    }
+      /* delegate these to camera srcbin */
+      g_object_set_property (G_OBJECT (camera->srcbin),
+          g_param_spec_get_name (pspec), value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -3485,9 +2442,6 @@ gst_camerabin_get_property (GObject * object, guint prop_id,
       g_value_set_boolean (value,
           gst_camerabin_video_get_mute (GST_CAMERABIN_VIDEO (camera->vidbin)));
       break;
-    case ARG_ZOOM:
-      g_value_set_int (value, g_atomic_int_get (&camera->zoom));
-      break;
     case ARG_IMAGE_POST:
       g_value_set_object (value,
           gst_camerabin_image_get_postproc (GST_CAMERABIN_IMAGE
@@ -3522,25 +2476,15 @@ gst_camerabin_get_property (GObject * object, guint prop_id,
       else
         g_value_set_object (value, camera->app_vf_sink);
       break;
-    case ARG_VIDEO_SRC:
-      if (camera->src_vid_src)
-        g_value_set_object (value, camera->src_vid_src);
-      else
-        g_value_set_object (value, camera->app_vid_src);
-      break;
     case ARG_AUDIO_SRC:
       g_value_set_object (value,
           gst_camerabin_video_get_audio_src (GST_CAMERABIN_VIDEO
               (camera->vidbin)));
       break;
-    case ARG_VIDEO_SOURCE_FILTER:
-      g_value_set_object (value, camera->app_video_filter);
-      break;
     case ARG_INPUT_CAPS:
-      gst_value_set_caps (value, gst_camerabin_get_allowed_input_caps (camera));
-      break;
-    case ARG_FILTER_CAPS:
-      gst_value_set_caps (value, camera->view_finder_caps);
+      gst_value_set_caps (value,
+          gst_base_camera_src_get_allowed_input_caps (GST_BASE_CAMERA_SRC
+              (camera->srcbin)));
       break;
     case ARG_PREVIEW_CAPS:
       if (camera->mode == MODE_IMAGE)
@@ -3554,20 +2498,18 @@ gst_camerabin_get_property (GObject * object, guint prop_id,
     case ARG_BLOCK_VIEWFINDER:
       g_value_set_boolean (value, camera->block_viewfinder);
       break;
+    case ARG_ZOOM:
+    case ARG_FILTER_CAPS:
+    case ARG_VIDEO_SOURCE_FILTER:
+    case ARG_VIDEO_SRC:
     case ARG_IMAGE_CAPTURE_WIDTH:
-      g_value_set_int (value, camera->image_capture_width);
-      break;
     case ARG_IMAGE_CAPTURE_HEIGHT:
-      g_value_set_int (value, camera->image_capture_height);
-      break;
     case ARG_VIDEO_CAPTURE_WIDTH:
-      g_value_set_int (value, camera->width);
-      break;
     case ARG_VIDEO_CAPTURE_HEIGHT:
-      g_value_set_int (value, camera->height);
-      break;
     case ARG_VIDEO_CAPTURE_FRAMERATE:
-      gst_value_set_fraction (value, camera->fps_n, camera->fps_d);
+      /* delegate these to camera srcbin */
+      g_object_get_property (G_OBJECT (camera->srcbin),
+          g_param_spec_get_name (pspec), value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -3624,7 +2566,8 @@ gst_camerabin_change_state (GstElement * element, GstStateChange transition)
       gst_element_state_change_return_get_name (ret));
 
   switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
+    case GST_STATE_CHANGE_PAUSED_TO_READY:{
+      GstPhotography *photography;
       g_mutex_lock (camera->capture_mutex);
       if (camera->capturing) {
         GST_WARNING_OBJECT (camera, "was capturing when changing to READY");
@@ -3635,9 +2578,15 @@ gst_camerabin_change_state (GstElement * element, GstStateChange transition)
         g_cond_signal (camera->cond);
       }
       g_mutex_unlock (camera->capture_mutex);
-      g_signal_handlers_disconnect_by_func (camera->src_vid_src,
-          gst_camerabin_proxy_notify_cb, camera);
+      photography =
+          gst_base_camera_src_get_photography (GST_BASE_CAMERA_SRC
+          (camera->srcbin));
+      if (photography) {
+        g_signal_handlers_disconnect_by_func (photography,
+            gst_camerabin_proxy_notify_cb, camera);
+      }
       break;
+    }
     case GST_STATE_CHANGE_READY_TO_NULL:
       camerabin_destroy_elements (camera);
       break;
@@ -3814,8 +2763,8 @@ gst_camerabin_capture_pause (GstCameraBin * camera)
       gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PAUSED);
 
       /* Switch to view finder mode */
-      g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", FALSE,
-          "active-pad", camera->pad_src_view, NULL);
+      gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (camera->srcbin),
+          MODE_PREVIEW);
 
       /* Set view finder to PLAYING and leave videobin PAUSED */
       gst_element_set_locked_state (camera->vidbin, TRUE);
@@ -3829,8 +2778,8 @@ gst_camerabin_capture_pause (GstCameraBin * camera)
       gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PAUSED);
 
       /* Switch to video recording mode */
-      g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", TRUE,
-          "active-pad", camera->pad_src_vid, NULL);
+      gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (camera->srcbin),
+          MODE_VIDEO);
 
       /* Bring all camerabin elements to PLAYING */
       gst_element_set_locked_state (camera->vidbin, FALSE);
@@ -3856,33 +2805,6 @@ gst_camerabin_set_video_resolution_fps (GstCameraBin * camera, gint width,
 }
 
 static void
-gst_camerabin_set_image_capture_caps (GstCameraBin * camera, gint width,
-    gint height)
-{
-  GstStructure *structure;
-  GstCaps *new_caps = NULL;
-
-  g_return_if_fail (camera != NULL);
-
-  if (width && height && camera->view_finder_caps) {
-    /* Use view finder mode caps as a basis */
-    structure = gst_caps_get_structure (camera->view_finder_caps, 0);
-
-    /* Set new resolution for image capture */
-    new_caps = gst_caps_new_simple (gst_structure_get_name (structure),
-        "width", G_TYPE_INT, width, "height", G_TYPE_INT, height, NULL);
-
-    /* Set allowed framerate for the resolution. */
-    gst_camerabin_set_allowed_framerate (camera, new_caps);
-  }
-
-  GST_INFO_OBJECT (camera,
-      "init filter caps for image capture %" GST_PTR_FORMAT, new_caps);
-  gst_caps_replace (&camera->image_capture_caps, new_caps);
-  camera->image_capture_caps_update = FALSE;
-}
-
-static void
 gst_camerabin_set_image_resolution (GstCameraBin * camera, gint width,
     gint height)
 {
@@ -3901,7 +2823,9 @@ plugin_init (GstPlugin * plugin)
   GST_DEBUG_CATEGORY_INIT (gst_camerabin_debug, "camerabin", 0, "CameraBin");
 
   return gst_element_register (plugin, "camerabin",
-      GST_RANK_NONE, GST_TYPE_CAMERABIN);
+      GST_RANK_NONE, GST_TYPE_CAMERABIN) &&
+      gst_element_register (plugin, "v4l2camerasrc",
+      GST_RANK_NONE, GST_TYPE_V4L2_CAMERA_SRC);
 }
 
 /* this is the structure that gstreamer looks for to register plugins
diff --git a/gst/camerabin/gstcamerabin.h b/gst/camerabin/gstcamerabin.h
index bd4a8e9..3257002 100644
--- a/gst/camerabin/gstcamerabin.h
+++ b/gst/camerabin/gstcamerabin.h
@@ -28,7 +28,7 @@
 #include <gst/gstbin.h>
 #include <gst/interfaces/photography.h>
 
-#include "gstcamerabin-enum.h"
+#include <gst/camerasrc/gstcamerabin-enum.h>
 #include "camerabinimage.h"
 #include "camerabinvideo.h"
 
@@ -59,47 +59,23 @@ struct _GstCameraBin
 
   /* private */
   GString *filename;
-  gint mode;                      /* MODE_IMAGE or MODE_VIDEO */
+  GstCameraBinMode mode;
   GstCameraBinFlags flags;
   gboolean stop_requested;        /* TRUE if capturing stop needed */
   gboolean paused;                /* TRUE if capturing paused */
   gboolean block_viewfinder;      /* TRUE if viewfinder blocks after capture */
 
-  /* Resolution of the buffers configured to camerabin */
-  gint width;
-  gint height;
-  /* Frames per second configured to camerabin */
-  gint fps_n;
-  gint fps_d;
-
   gboolean video_capture_caps_update;
 
-  /* Image capture resolution */
-  gint image_capture_width;
-  gint image_capture_height;
-
   /* Image tags are collected here first before sending to imgbin */
   GstTagList *event_tags;
 
-  /* Caps applied to capsfilters when taking still image */
-  GstCaps *image_capture_caps;
-  gboolean image_capture_caps_update;
-
-  /* Caps applied to capsfilters when in view finder mode */
-  GstCaps *view_finder_caps;
-
-  /* Caps that videosrc supports */
-  GstCaps *allowed_caps;
-
   /* Caps used to create preview image */
   GstCaps *preview_caps;
 
   /* Caps used to create video preview image */
   GstCaps *video_preview_caps;
 
-  /* The digital zoom (from 100% to 1000%) */
-  gint zoom;
-
   /* concurrency control */
   GMutex *capture_mutex;
   GCond *cond;
@@ -108,14 +84,17 @@ struct _GstCameraBin
 
   /* pad names for output and input selectors */
   GstPad *pad_src_view;
-  GstPad *pad_view_src;
   GstPad *pad_src_img;
   GstPad *pad_src_vid;
-  GstPad *pad_view_vid;
   GstPad *pad_src_queue;
 
+  /* note:  maybe img_queue moves into srcbin..
+   */
   GstElement *img_queue;        /* queue for decoupling capture from
                                    image-postprocessing and saving */
+
+
+  GstElement *srcbin;           /* bin that holds camera src elements */
   GstElement *imgbin;           /* bin that holds image capturing elements */
   GstElement *vidbin;           /*  bin that holds video capturing elements */
   GstElement *active_bin;       /* image or video bin that is currently in use */
@@ -124,43 +103,20 @@ struct _GstCameraBin
 
   GstBuffer *video_preview_buffer;      /* buffer for storing video preview */
 
-  /* source elements */
-  GstElement *src_vid_src;
-  GstElement *src_filter;
-  GstElement *src_zoom_crop;
-  GstElement *src_zoom_scale;
-  GstElement *src_zoom_filter;
-  GstElement *src_out_sel;
-
   /* view finder elements */
-  GstElement *view_in_sel;
   GstElement *aspect_filter;
   GstElement *view_scale;
   GstElement *view_sink;
 
   /* Application configurable elements */
-  GstElement *app_vid_src;
   GstElement *app_vf_sink;
-  GstElement *app_video_filter;
   GstElement *app_viewfinder_filter;
 
-  /* Night mode handling */
-  gboolean night_mode;
-  gint pre_night_fps_n;
-  gint pre_night_fps_d;
-
   /* Cache the photography interface settings */
   GstPhotoSettings photo_settings;
 
   /* Buffer probe id for captured image handling */
   gulong image_captured_id;
-
-  /* Optional base crop for frames. Used to crop frames e.g.
-     due to wrong aspect ratio, before the crop related to zooming. */
-  gint base_crop_top;
-  gint base_crop_bottom;
-  gint base_crop_left;
-  gint base_crop_right;
 };
 
 /**
@@ -186,19 +142,6 @@ struct _GstCameraBinClass
     gboolean (*img_done) (GstCameraBin * camera, const gchar * filename);
 };
 
-/**
- * GstCameraBinMode:
- * @MODE_IMAGE: image capture
- * @MODE_VIDEO: video capture
- *
- * Capture mode to use.
- */
-typedef enum
-{
-  MODE_IMAGE = 0,
-  MODE_VIDEO
-} GstCameraBinMode;
-
 GType gst_camerabin_get_type (void);
 
 G_END_DECLS
diff --git a/gst/camerabin/gstcamerabincolorbalance.c b/gst/camerabin/gstcamerabincolorbalance.c
index 73a325d..d69ad1d 100644
--- a/gst/camerabin/gstcamerabincolorbalance.c
+++ b/gst/camerabin/gstcamerabincolorbalance.c
@@ -26,6 +26,7 @@
 #include <config.h>
 #endif
 
+#include <gst/camerasrc/gstbasecamerasrc.h>
 #include "gstcamerabincolorbalance.h"
 #include "gstcamerabin.h"
 
@@ -36,8 +37,10 @@
 static const GList *
 gst_camerabin_color_balance_list_channels (GstColorBalance * cb)
 {
-  if (cb && GST_CAMERABIN (cb)->src_vid_src) {
-    GstColorBalance *cbl = GST_COLOR_BALANCE (GST_CAMERABIN (cb)->src_vid_src);
+  if (cb) {
+    GstColorBalance *cbl =
+        gst_base_camera_src_get_color_balance (GST_BASE_CAMERA_SRC
+        (GST_CAMERABIN (cb)->srcbin));
     return gst_color_balance_list_channels (cbl);
   } else {
     return NULL;
@@ -48,8 +51,10 @@ static void
 gst_camerabin_color_balance_set_value (GstColorBalance * cb,
     GstColorBalanceChannel * channel, gint value)
 {
-  if (cb && GST_CAMERABIN (cb)->src_vid_src) {
-    GstColorBalance *cbl = GST_COLOR_BALANCE (GST_CAMERABIN (cb)->src_vid_src);
+  if (cb) {
+    GstColorBalance *cbl =
+        gst_base_camera_src_get_color_balance (GST_BASE_CAMERA_SRC
+        (GST_CAMERABIN (cb)->srcbin));
     gst_color_balance_set_value (cbl, channel, value);
   }
 }
@@ -58,8 +63,10 @@ static gint
 gst_camerabin_color_balance_get_value (GstColorBalance * cb,
     GstColorBalanceChannel * channel)
 {
-  if (cb && GST_CAMERABIN (cb)->src_vid_src) {
-    GstColorBalance *cbl = GST_COLOR_BALANCE (GST_CAMERABIN (cb)->src_vid_src);
+  if (cb) {
+    GstColorBalance *cbl =
+        gst_base_camera_src_get_color_balance (GST_BASE_CAMERA_SRC
+        (GST_CAMERABIN (cb)->srcbin));
     return gst_color_balance_get_value (cbl, channel);
   } else {
     return 0;
diff --git a/gst/camerabin/gstcamerabinphotography.c b/gst/camerabin/gstcamerabinphotography.c
index 4780909..d616656 100644
--- a/gst/camerabin/gstcamerabinphotography.c
+++ b/gst/camerabin/gstcamerabinphotography.c
@@ -25,15 +25,17 @@
 #endif
 
 #include <string.h>
+#include <gst/camerasrc/gstbasecamerasrc.h>
 #include "gstcamerabinphotography.h"
 #include "gstcamerabin.h"
-#include "gstcamerabin-enum.h"
+#include <gst/camerasrc/gstcamerabin-enum.h>
 
 GST_DEBUG_CATEGORY_STATIC (camerabinphoto_debug);
 #define GST_CAT_DEFAULT camerabinphoto_debug
 
-#define PHOTOGRAPHY_IS_OK(photo_elem) (GST_IS_ELEMENT (photo_elem) && \
-                                       gst_element_implements_interface (photo_elem, GST_TYPE_PHOTOGRAPHY))
+#define GET_PHOTOGRAPHY(cam) \
+		gst_base_camera_src_get_photography (GST_BASE_CAMERA_SRC ((cam)->srcbin));
+
 static void
 gst_camerabin_handle_scene_mode (GstCameraBin * camera,
     GstSceneMode scene_mode);
@@ -43,6 +45,7 @@ gst_camerabin_set_ev_compensation (GstPhotography * photo,
     gfloat ev_compensation)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -52,10 +55,10 @@ gst_camerabin_set_ev_compensation (GstPhotography * photo,
   /* Cache the setting */
   camera->photo_settings.ev_compensation = ev_compensation;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_set_ev_compensation (GST_PHOTOGRAPHY
-        (camera->src_vid_src), ev_compensation);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_ev_compensation (photography, ev_compensation);
   }
   return ret;
 }
@@ -65,16 +68,17 @@ gst_camerabin_get_ev_compensation (GstPhotography * photo,
     gfloat * ev_compensation)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_get_ev_compensation (GST_PHOTOGRAPHY
-        (camera->src_vid_src), ev_compensation);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_ev_compensation (photography, ev_compensation);
   }
   return ret;
 }
@@ -83,6 +87,7 @@ static gboolean
 gst_camerabin_set_iso_speed (GstPhotography * photo, guint iso_speed)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -92,9 +97,10 @@ gst_camerabin_set_iso_speed (GstPhotography * photo, guint iso_speed)
   /* Cache the setting */
   camera->photo_settings.iso_speed = iso_speed;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_set_iso_speed (GST_PHOTOGRAPHY (camera->src_vid_src),
-        iso_speed);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_iso_speed (photography, iso_speed);
   }
   return ret;
 }
@@ -103,15 +109,17 @@ static gboolean
 gst_camerabin_get_iso_speed (GstPhotography * photo, guint * iso_speed)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_get_iso_speed (GST_PHOTOGRAPHY (camera->src_vid_src),
-        iso_speed);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_iso_speed (photography, iso_speed);
   }
   return ret;
 }
@@ -121,6 +129,7 @@ gst_camerabin_set_white_balance_mode (GstPhotography * photo,
     GstWhiteBalanceMode white_balance_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -130,10 +139,11 @@ gst_camerabin_set_white_balance_mode (GstPhotography * photo,
   /* Cache the setting */
   camera->photo_settings.wb_mode = white_balance_mode;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_set_white_balance_mode (GST_PHOTOGRAPHY
-        (camera->src_vid_src), white_balance_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_white_balance_mode (photography,
+        white_balance_mode);
   }
   return ret;
 }
@@ -143,16 +153,18 @@ gst_camerabin_get_white_balance_mode (GstPhotography * photo,
     GstWhiteBalanceMode * white_balance_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_get_white_balance_mode (GST_PHOTOGRAPHY
-        (camera->src_vid_src), white_balance_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_white_balance_mode (photography,
+        white_balance_mode);
   }
   return ret;
 }
@@ -162,6 +174,7 @@ gst_camerabin_set_colour_tone_mode (GstPhotography * photo,
     GstColourToneMode colour_tone_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -171,10 +184,10 @@ gst_camerabin_set_colour_tone_mode (GstPhotography * photo,
   /* Cache the setting */
   camera->photo_settings.tone_mode = colour_tone_mode;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_set_colour_tone_mode (GST_PHOTOGRAPHY
-        (camera->src_vid_src), colour_tone_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_colour_tone_mode (photography, colour_tone_mode);
   }
   return ret;
 }
@@ -184,16 +197,17 @@ gst_camerabin_get_colour_tone_mode (GstPhotography * photo,
     GstColourToneMode * colour_tone_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_get_colour_tone_mode (GST_PHOTOGRAPHY
-        (camera->src_vid_src), colour_tone_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_colour_tone_mode (photography, colour_tone_mode);
   }
   return ret;
 }
@@ -202,6 +216,7 @@ static gboolean
 gst_camerabin_set_flash_mode (GstPhotography * photo, GstFlashMode flash_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -211,9 +226,10 @@ gst_camerabin_set_flash_mode (GstPhotography * photo, GstFlashMode flash_mode)
   /* Cache the setting */
   camera->photo_settings.flash_mode = flash_mode;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_set_flash_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        flash_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_flash_mode (photography, flash_mode);
   }
   return ret;
 }
@@ -222,15 +238,17 @@ static gboolean
 gst_camerabin_get_flash_mode (GstPhotography * photo, GstFlashMode * flash_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_get_flash_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        flash_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_flash_mode (photography, flash_mode);
   }
   return ret;
 }
@@ -239,6 +257,7 @@ static gboolean
 gst_camerabin_set_scene_mode (GstPhotography * photo, GstSceneMode scene_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -250,12 +269,12 @@ gst_camerabin_set_scene_mode (GstPhotography * photo, GstSceneMode scene_mode)
 
   gst_camerabin_handle_scene_mode (camera, scene_mode);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_set_scene_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        scene_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_scene_mode (photography, scene_mode);
     if (ret) {
-      gst_photography_get_config (GST_PHOTOGRAPHY (camera->src_vid_src),
-          &camera->photo_settings);
+      gst_photography_get_config (photography, &camera->photo_settings);
     }
   }
   return ret;
@@ -265,15 +284,17 @@ static gboolean
 gst_camerabin_get_scene_mode (GstPhotography * photo, GstSceneMode * scene_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_get_scene_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        scene_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_scene_mode (photography, scene_mode);
   }
   return ret;
 }
@@ -282,6 +303,7 @@ static GstPhotoCaps
 gst_camerabin_get_capabilities (GstPhotography * photo)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   /* camerabin can zoom by itself */
   GstPhotoCaps pcaps = GST_PHOTOGRAPHY_CAPS_ZOOM;
 
@@ -289,11 +311,10 @@ gst_camerabin_get_capabilities (GstPhotography * photo)
 
   camera = GST_CAMERABIN (photo);
 
-  if (GST_IS_ELEMENT (camera->src_vid_src) &&
-      gst_element_implements_interface (camera->src_vid_src,
-          GST_TYPE_PHOTOGRAPHY)) {
-    GstPhotography *p2 = GST_PHOTOGRAPHY (camera->src_vid_src);
-    pcaps |= gst_photography_get_capabilities (p2);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    pcaps |= gst_photography_get_capabilities (photography);
   }
 
   return pcaps;
@@ -303,6 +324,7 @@ static void
 gst_camerabin_set_autofocus (GstPhotography * photo, gboolean on)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
 
   g_return_if_fail (photo != NULL);
 
@@ -310,8 +332,10 @@ gst_camerabin_set_autofocus (GstPhotography * photo, gboolean on)
 
   GST_DEBUG_OBJECT (camera, "setting autofocus %s", on ? "ON" : "OFF");
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    gst_photography_set_autofocus (GST_PHOTOGRAPHY (camera->src_vid_src), on);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    gst_photography_set_autofocus (photography, on);
   }
 }
 
@@ -319,15 +343,17 @@ static gboolean
 gst_camerabin_get_aperture (GstPhotography * photo, guint * aperture)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_get_aperture (GST_PHOTOGRAPHY (camera->src_vid_src),
-        aperture);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_aperture (photography, aperture);
   }
   return ret;
 }
@@ -336,14 +362,16 @@ static void
 gst_camerabin_set_aperture (GstPhotography * photo, guint aperture)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
 
   g_return_if_fail (photo != NULL);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    gst_photography_set_aperture (GST_PHOTOGRAPHY (camera->src_vid_src),
-        aperture);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    gst_photography_set_aperture (photography, aperture);
   }
 }
 
@@ -351,15 +379,17 @@ static gboolean
 gst_camerabin_get_exposure (GstPhotography * photo, guint32 * exposure)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret = gst_photography_get_exposure (GST_PHOTOGRAPHY (camera->src_vid_src),
-        exposure);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_exposure (photography, exposure);
   }
   return ret;
 }
@@ -368,14 +398,16 @@ static void
 gst_camerabin_set_exposure (GstPhotography * photo, guint32 exposure)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
 
   g_return_if_fail (photo != NULL);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    gst_photography_set_exposure (GST_PHOTOGRAPHY (camera->src_vid_src),
-        exposure);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    gst_photography_set_exposure (photography, exposure);
   }
 }
 
@@ -383,6 +415,7 @@ static gboolean
 gst_camerabin_set_config (GstPhotography * photo, GstPhotoSettings * config)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
   g_return_val_if_fail (photo != NULL, FALSE);
   camera = GST_CAMERABIN (photo);
@@ -393,10 +426,10 @@ gst_camerabin_set_config (GstPhotography * photo, GstPhotoSettings * config)
   /* Handle night mode */
   gst_camerabin_handle_scene_mode (camera, config->scene_mode);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_set_config (GST_PHOTOGRAPHY (camera->src_vid_src),
-        config);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_config (photography, config);
   }
   return ret;
 }
@@ -405,13 +438,13 @@ static gboolean
 gst_camerabin_get_config (GstPhotography * photo, GstPhotoSettings * config)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
   g_return_val_if_fail (photo != NULL, FALSE);
   camera = GST_CAMERABIN (photo);
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_get_config (GST_PHOTOGRAPHY (camera->src_vid_src),
-        config);
+  photography = GET_PHOTOGRAPHY (camera);
+  if (photography) {
+    ret = gst_photography_get_config (photography, config);
   }
   return ret;
 }
@@ -419,6 +452,9 @@ gst_camerabin_get_config (GstPhotography * photo, GstPhotoSettings * config)
 static void
 gst_camerabin_handle_scene_mode (GstCameraBin * camera, GstSceneMode scene_mode)
 {
+  // XXX maybe handle this inside night_mode propery in srcbin?  But
+  // what about the set-video-resolution-fps?  Where is that handled?
+#if 0
   if (scene_mode == GST_PHOTOGRAPHY_SCENE_MODE_NIGHT) {
     if (!camera->night_mode) {
       GST_DEBUG ("enabling night mode, lowering fps");
@@ -441,6 +477,7 @@ gst_camerabin_handle_scene_mode (GstCameraBin * camera, GstSceneMode scene_mode)
           camera->height, camera->pre_night_fps_n, camera->pre_night_fps_d, 0);
     }
   }
+#endif
 }
 
 static gboolean
@@ -448,6 +485,7 @@ gst_camerabin_set_flicker_mode (GstPhotography * photo,
     GstFlickerReductionMode flicker_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -457,10 +495,10 @@ gst_camerabin_set_flicker_mode (GstPhotography * photo,
   /* Cache the setting */
   camera->photo_settings.flicker_mode = flicker_mode;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_set_flicker_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        flicker_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_flicker_mode (photography, flicker_mode);
   }
   return ret;
 }
@@ -470,16 +508,17 @@ gst_camerabin_get_flicker_mode (GstPhotography * photo,
     GstFlickerReductionMode * flicker_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_get_flicker_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        flicker_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_flicker_mode (photography, flicker_mode);
   }
   return ret;
 }
@@ -488,6 +527,7 @@ static gboolean
 gst_camerabin_set_focus_mode (GstPhotography * photo, GstFocusMode focus_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = TRUE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
@@ -497,10 +537,10 @@ gst_camerabin_set_focus_mode (GstPhotography * photo, GstFocusMode focus_mode)
   /* Cache the setting */
   camera->photo_settings.focus_mode = focus_mode;
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_set_focus_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        focus_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_set_focus_mode (photography, focus_mode);
   }
   return ret;
 }
@@ -509,16 +549,17 @@ static gboolean
 gst_camerabin_get_focus_mode (GstPhotography * photo, GstFocusMode * focus_mode)
 {
   GstCameraBin *camera;
+  GstPhotography *photography;
   gboolean ret = FALSE;
 
   g_return_val_if_fail (photo != NULL, FALSE);
 
   camera = GST_CAMERABIN (photo);
 
-  if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-    ret =
-        gst_photography_get_focus_mode (GST_PHOTOGRAPHY (camera->src_vid_src),
-        focus_mode);
+  photography = GET_PHOTOGRAPHY (camera);
+
+  if (photography) {
+    ret = gst_photography_get_focus_mode (photography, focus_mode);
   }
   return ret;
 }
@@ -626,9 +667,11 @@ gst_camerabin_photography_get_property (GstCameraBin * camera, guint prop_id,
     }
     case ARG_IMAGE_CAPTURE_SUPPORTED_CAPS:
     {
+      GstPhotography *photography = photography = GET_PHOTOGRAPHY (camera);
+
       GST_DEBUG_OBJECT (camera, "==== GETTING PROP_IMAGE_CAPTURE_CAPS ====");
-      if (PHOTOGRAPHY_IS_OK (camera->src_vid_src)) {
-        g_object_get_property (G_OBJECT (camera->src_vid_src),
+      if (photography) {
+        g_object_get_property (G_OBJECT (camera->srcbin),
             "image-capture-supported-caps", value);
       } else {
         g_object_get_property (G_OBJECT (camera), "video-source-caps", value);
diff --git a/gst/camerabin/gstv4l2camerasrc.c b/gst/camerabin/gstv4l2camerasrc.c
new file mode 100644
index 0000000..b7b911a
--- /dev/null
+++ b/gst/camerabin/gstv4l2camerasrc.c
@@ -0,0 +1,1073 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+/**
+ * SECTION:element-v4l2camerasrc
+ *
+ * A camera src element for camerabin.. currently uses v4l2 directly.
+ * It could be worthwhile to make this subclassable, so that other
+ * camera elements with a single src pad could re-use this..
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include "gstv4l2camerasrc.h"
+#include "camerabingeneral.h"
+#include <gst/camerasrc/gstcamerabin-enum.h>
+
+
+#define DEFAULT_VF_CAPS "video/x-raw-yuv,format=(fourcc)I420"
+//#define CAMERABIN_MAX_VF_WIDTH 848
+//#define CAMERABIN_MAX_VF_HEIGHT 848
+
+/* Using "bilinear" as default zoom method */
+#define CAMERABIN_DEFAULT_ZOOM_METHOD 1
+
+/* FIXME: this is v4l2camsrc specific */
+#define DEFAULT_V4L2CAMSRC_DRIVER_NAME "omap3cam"
+
+//GST_DEBUG_CATEGORY (v4l2_camera_src_debug);
+//#define GST_CAT_DEFAULT v4l2_camera_src_debug
+
+GST_BOILERPLATE (GstV4l2CameraSrc, gst_v4l2_camera_src, GstBaseCameraSrc,
+    GST_TYPE_BASE_CAMERA_SRC);
+
+static void configure_format (GstV4l2CameraSrc * self, GstCaps * caps);
+static void set_capsfilter_caps (GstV4l2CameraSrc * self, GstCaps * new_caps);
+
+static void
+gst_v4l2_camera_src_dispose (GObject * object)
+{
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gst_v4l2_camera_src_finalize (GstV4l2CameraSrc * self)
+{
+  G_OBJECT_CLASS (parent_class)->finalize ((GObject *) (self));
+}
+
+static void
+gst_v4l2_camera_src_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (object);
+
+  switch (prop_id) {
+    case ARG_FILTER_CAPS:
+      GST_OBJECT_LOCK (self);
+      gst_caps_replace (&self->view_finder_caps,
+          (GstCaps *) gst_value_get_caps (value));
+      GST_OBJECT_UNLOCK (self);
+      if (!self->view_finder_caps)
+        self->view_finder_caps = gst_caps_from_string (DEFAULT_VF_CAPS);
+      configure_format (self, self->view_finder_caps);
+      break;
+    case ARG_VIDEO_SOURCE_FILTER:
+      if (GST_STATE (self) != GST_STATE_NULL) {
+        GST_ELEMENT_ERROR (self, CORE, FAILED,
+            ("camerasrc must be in NULL state when setting the video filter element"),
+            (NULL));
+      } else {
+        if (self->app_video_filter)
+          gst_object_unref (self->app_video_filter);
+        self->app_video_filter = g_value_dup_object (value);
+      }
+      break;
+    case ARG_VIDEO_SRC:
+      if (GST_STATE (self) != GST_STATE_NULL) {
+        GST_ELEMENT_ERROR (self, CORE, FAILED,
+            ("camerasrc must be in NULL state when setting the video source element"),
+            (NULL));
+      } else {
+        if (self->app_vid_src)
+          gst_object_unref (self->app_vid_src);
+        self->app_vid_src = g_value_get_object (value);
+        if (self->app_vid_src)
+          gst_object_ref (self->app_vid_src);
+      }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_v4l2_camera_src_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (object);
+
+  switch (prop_id) {
+    case ARG_FILTER_CAPS:
+      gst_value_set_caps (value, self->view_finder_caps);
+      break;
+    case ARG_VIDEO_SOURCE_FILTER:
+      g_value_set_object (value, self->app_video_filter);
+      break;
+    case ARG_VIDEO_SRC:
+      if (self->src_vid_src)
+        g_value_set_object (value, self->src_vid_src);
+      else
+        g_value_set_object (value, self->app_vid_src);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+/**
+ * gst_v4l2_camera_src_imgsrc_probe:
+ *
+ * Buffer probe called before sending each buffer to image queue.
+ */
+static gboolean
+gst_v4l2_camera_src_imgsrc_probe (GstPad * pad, GstBuffer * buffer,
+    gpointer data)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (data);
+  GST_DEBUG_OBJECT (self, "pass buffer: %d", self->mode == MODE_IMAGE);
+  return self->mode == MODE_IMAGE;
+}
+
+/**
+ * gst_v4l2_camera_src_vidsrc_probe:
+ *
+ * Buffer probe called before sending each buffer to image queue.
+ */
+static gboolean
+gst_v4l2_camera_src_vidsrc_probe (GstPad * pad, GstBuffer * buffer,
+    gpointer data)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (data);
+  GST_DEBUG_OBJECT (self, "pass buffer: %d", self->mode == MODE_VIDEO);
+  return self->mode == MODE_VIDEO;
+}
+
+/**
+ * gst_v4l2_camera_src_construct_pipeline:
+ * @bcamsrc: camerasrc object
+ * @vfsrc: viewfinder src element (returned by reference)
+ * @imgsrc: image src element (returned by reference)
+ * @vidsrc: video src element (returned by reference)
+ *
+ * This function creates and links the elements of the camerasrc bin
+ * videosrc ! cspconv ! capsfilter ! crop ! scale ! capsfilter ! tee ! ..
+ *
+ * Returns: TRUE, if elements were successfully created, FALSE otherwise
+ */
+static gboolean
+gst_v4l2_camera_src_construct_pipeline (GstBaseCameraSrc * bcamsrc,
+    GstPad ** vfsrc, GstPad ** imgsrc, GstPad ** vidsrc)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (bcamsrc);
+  GstBin *cbin = GST_BIN (bcamsrc);
+  GstElement *tee;
+  gboolean ret = FALSE;
+
+  GST_DEBUG_OBJECT (self, "constructing pipeline");
+
+  /* Add application set or default video src element */
+  if (!(self->src_vid_src = gst_camerabin_setup_default_element (cbin,
+              self->app_vid_src, "autovideosrc", DEFAULT_VIDEOSRC))) {
+    self->src_vid_src = NULL;
+    goto done;
+  } else {
+    if (!gst_camerabin_add_element (cbin, self->src_vid_src)) {
+      goto done;
+    }
+  }
+
+#if 0
+  /* XXX srcbin needs to know of some flags, perhaps?? */
+  if (camera->flags & GST_CAMERABIN_FLAG_SOURCE_COLOR_CONVERSION) {
+#else
+  if (1) {
+#endif
+    if (!gst_camerabin_create_and_add_element (cbin, "ffmpegcolorspace"))
+      goto done;
+  }
+
+  if (!(self->src_filter =
+          gst_camerabin_create_and_add_element (cbin, "capsfilter")))
+    goto done;
+
+#if 0
+  /* XXX srcbin needs to know of some flags, perhaps?? */
+  if (camera->flags & GST_CAMERABIN_FLAG_SOURCE_RESIZE) {
+#else
+  if (1) {
+#endif
+    if (!(self->src_zoom_crop =
+            gst_camerabin_create_and_add_element (cbin, "videocrop")))
+      goto done;
+    if (!(self->src_zoom_scale =
+            gst_camerabin_create_and_add_element (cbin, "videoscale")))
+      goto done;
+    if (!(self->src_zoom_filter =
+            gst_camerabin_create_and_add_element (cbin, "capsfilter")))
+      goto done;
+  }
+
+  if (self->app_video_filter) {
+    if (!gst_camerabin_add_element (cbin, self->app_video_filter)) {
+      goto done;
+    }
+  }
+
+  if (!(tee = gst_camerabin_create_and_add_element (cbin, "tee")))
+    goto done;
+
+  self->tee_vf_srcpad = gst_element_get_request_pad (tee, "src%d");
+  self->tee_image_srcpad = gst_element_get_request_pad (tee, "src%d");
+  self->tee_video_srcpad = gst_element_get_request_pad (tee, "src%d");
+
+  gst_pad_add_buffer_probe (self->tee_image_srcpad,
+      G_CALLBACK (gst_v4l2_camera_src_imgsrc_probe), self);
+  gst_pad_add_buffer_probe (self->tee_video_srcpad,
+      G_CALLBACK (gst_v4l2_camera_src_vidsrc_probe), self);
+
+  *vfsrc = self->tee_vf_srcpad;
+  *imgsrc = self->tee_image_srcpad;
+  *vidsrc = self->tee_video_srcpad;
+
+#if 0
+  /* XXX another idea... put common parts in GstBaseCameraSrc.. perhaps
+   * derived class could use some flags, or something like this, to
+   * indicate which pads in needs vscale and queue on.. (but I think it
+   * doesn't hurt ot have on all..)
+   */
+  /* XXX perhaps we should keep queues and vscale's in camerabin itself,
+   * because GstOmxCameraSrc would also probably need the queues.. and
+   * maybe some OMX camera implementations would want the vscale's (and
+   * at least the vscale's should become pass-through if OMX camera can
+   * negotiate the requested sizes..
+   */
+  queue = gst_element_factory_make ("queue", "viewfinder-queue");
+  if (!gst_camerabin_add_element (cbin, queue)) {
+    goto error;
+  }
+  /* Set queue leaky, we don't want to block video encoder feed, but
+   * prefer leaking view finder buffers instead. */
+  g_object_set (G_OBJECT (queue), "leaky", 2, "max-size-buffers", 1, NULL);
+#endif
+
+  /* Set default "driver-name" for v4l2camsrc if not set */
+  /* FIXME: v4l2camsrc specific */
+  {
+    gchar *driver_name = NULL;
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (self->src_vid_src),
+            "driver-name")) {
+      g_object_get (G_OBJECT (self->src_vid_src), "driver-name",
+          &driver_name, NULL);
+      if (!driver_name) {
+        g_object_set (G_OBJECT (self->src_vid_src), "driver-name",
+            DEFAULT_V4L2CAMSRC_DRIVER_NAME, NULL);
+      }
+    }
+  }
+
+  ret = TRUE;
+done:
+  return ret;
+}
+
+/**
+ * get_srcpad_current_format:
+ * @element: element to get the format from
+ *
+ * Helper function to get the negotiated fourcc
+ * format from @element src pad.
+ *
+ * Returns: negotiated format (fourcc), 0 if not found
+ */
+static guint32
+get_srcpad_current_format (GstElement * element)
+{
+  GstPad *srcpad = NULL;
+  GstCaps *srccaps = NULL;
+  GstStructure *structure;
+  guint32 format = 0;
+
+  g_return_val_if_fail (element != NULL, 0);
+
+  if ((srcpad = gst_element_get_static_pad (element, "src")) == NULL) {
+    goto no_pad;
+  }
+
+  if ((srccaps = gst_pad_get_negotiated_caps (srcpad)) == NULL) {
+    goto no_caps;
+  }
+
+  GST_LOG ("negotiated caps %" GST_PTR_FORMAT, srccaps);
+
+  structure = gst_caps_get_structure (srccaps, 0);
+  if (gst_structure_has_field (structure, "format")) {
+    gst_structure_get_fourcc (structure, "format", &format);
+  }
+
+  gst_caps_unref (srccaps);
+no_caps:
+  gst_object_unref (srcpad);
+no_pad:
+  GST_DEBUG ("current format for %" GST_PTR_FORMAT ": %" GST_FOURCC_FORMAT,
+      element, GST_FOURCC_ARGS (format));
+  return format;
+}
+
+/**
+ * set_allowed_framerate:
+ * @self: camerasrc object
+ * @filter_caps: update allowed framerate to these caps
+ *
+ * Find allowed frame rate from video source that matches with
+ * resolution in @filter_caps. Set found frame rate to @filter_caps.
+ */
+static void
+set_allowed_framerate (GstV4l2CameraSrc * self, GstCaps * filter_caps)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  GstStructure *structure;
+  GstCaps *allowed_caps = NULL, *intersect = NULL, *tmp_caps = NULL;
+  const GValue *framerate = NULL;
+  guint caps_size, i;
+  guint32 format = 0;
+
+  GST_INFO_OBJECT (self, "filter caps:%" GST_PTR_FORMAT, filter_caps);
+
+  structure = gst_structure_copy (gst_caps_get_structure (filter_caps, 0));
+
+  /* Set fourcc format according to current videosrc format */
+  format = get_srcpad_current_format (self->src_vid_src);
+  if (format) {
+    GST_DEBUG_OBJECT (self,
+        "using format %" GST_FOURCC_FORMAT " for matching",
+        GST_FOURCC_ARGS (format));
+    gst_structure_set (structure, "format", GST_TYPE_FOURCC, format, NULL);
+  } else {
+    GST_DEBUG_OBJECT (self, "not matching against fourcc format");
+    gst_structure_remove_field (structure, "format");
+  }
+
+  tmp_caps = gst_caps_new_full (structure, NULL);
+
+  /* Get supported caps from video src that matches with new filter caps */
+  allowed_caps = gst_base_camera_src_get_allowed_input_caps (bcamsrc);
+  intersect = gst_caps_intersect (allowed_caps, tmp_caps);
+  GST_INFO_OBJECT (self, "intersect caps:%" GST_PTR_FORMAT, intersect);
+
+  /* Find the best framerate from the caps */
+  caps_size = gst_caps_get_size (intersect);
+  for (i = 0; i < caps_size; i++) {
+    structure = gst_caps_get_structure (intersect, i);
+    framerate = gst_base_camera_src_find_better_framerate (bcamsrc,
+        structure, framerate);
+  }
+
+  /* Set found frame rate to original caps */
+  if (GST_VALUE_HOLDS_FRACTION (framerate)) {
+    gst_caps_set_simple (filter_caps,
+        "framerate", GST_TYPE_FRACTION,
+        gst_value_get_fraction_numerator (framerate),
+        gst_value_get_fraction_denominator (framerate), NULL);
+  }
+
+  /* Unref helper caps */
+  if (allowed_caps) {
+    gst_caps_unref (allowed_caps);
+  }
+  if (intersect) {
+    gst_caps_unref (intersect);
+  }
+  if (tmp_caps) {
+    gst_caps_unref (tmp_caps);
+  }
+}
+
+/**
+ * gst_v4l2_camera_src_setup_pipeline:
+ * @bcamsrc: camerasrc object
+ *
+ * This function updates camerabin capsfilters according
+ * to fps, resolution and zoom that have been configured
+ * to camerabin.
+ */
+static gboolean
+gst_v4l2_camera_src_setup_pipeline (GstBaseCameraSrc * bcamsrc)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (bcamsrc);
+  GstStructure *st;
+  GstCaps *new_caps;
+  gboolean detect_framerate = FALSE;
+
+  /* clear video update status */
+//XXX  self->video_capture_caps_update = FALSE;
+
+  if (!self->view_finder_caps) {
+    st = gst_structure_from_string (DEFAULT_VF_CAPS, NULL);
+  } else {
+    st = gst_structure_copy (gst_caps_get_structure (self->view_finder_caps,
+            0));
+  }
+
+  if (bcamsrc->width > 0 && bcamsrc->height > 0) {
+    gst_structure_set (st,
+        "width", G_TYPE_INT, bcamsrc->width,
+        "height", G_TYPE_INT, bcamsrc->height, NULL);
+  }
+
+  if (bcamsrc->fps_n > 0 && bcamsrc->fps_d > 0) {
+    if (bcamsrc->night_mode) {
+      GST_INFO_OBJECT (self, "night mode, lowest allowed fps will be forced");
+      bcamsrc->pre_night_fps_n = bcamsrc->fps_n;
+      bcamsrc->pre_night_fps_d = bcamsrc->fps_d;
+      detect_framerate = TRUE;
+    } else {
+      gst_structure_set (st,
+          "framerate", GST_TYPE_FRACTION, bcamsrc->fps_n, bcamsrc->fps_d, NULL);
+      new_caps = gst_caps_new_full (st, NULL);
+    }
+  } else {
+    GST_DEBUG_OBJECT (self, "no framerate specified");
+    detect_framerate = TRUE;
+  }
+
+  if (detect_framerate) {
+    GST_DEBUG_OBJECT (self, "detecting allowed framerate");
+    /* Remove old framerate if any */
+    if (gst_structure_has_field (st, "framerate")) {
+      gst_structure_remove_field (st, "framerate");
+    }
+    new_caps = gst_caps_new_full (st, NULL);
+
+    /* Set allowed framerate for the resolution */
+    set_allowed_framerate (self, new_caps);
+  }
+
+  /* Set default zoom method */
+  if (self->src_zoom_scale) {
+    g_object_set (self->src_zoom_scale, "method",
+        CAMERABIN_DEFAULT_ZOOM_METHOD, NULL);
+  }
+
+  /* we create new caps in any way and they take ownership of the structure st */
+  gst_caps_replace (&self->view_finder_caps, new_caps);
+  gst_caps_unref (new_caps);
+
+  /* Set caps for view finder mode */
+  /* This also sets zoom */
+  set_capsfilter_caps (self, self->view_finder_caps);
+
+  return TRUE;
+}
+
+static gboolean
+copy_missing_fields (GQuark field_id, const GValue * value, gpointer user_data)
+{
+  GstStructure *st = (GstStructure *) user_data;
+  const GValue *val = gst_structure_id_get_value (st, field_id);
+
+  if (G_UNLIKELY (val == NULL)) {
+    gst_structure_id_set_value (st, field_id, value);
+  }
+
+  return TRUE;
+}
+
+/**
+ * adapt_image_capture:
+ * @self: camerasrc object
+ * @in_caps: caps object that describes incoming image format
+ *
+ * Adjust capsfilters and crop according image capture caps if necessary.
+ * The captured image format from video source might be different from
+ * what application requested, so we can try to fix that in camerabin.
+ *
+ */
+static void
+adapt_image_capture (GstV4l2CameraSrc * self, GstCaps * in_caps)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  GstStructure *in_st, *new_st, *req_st;
+  gint in_width = 0, in_height = 0, req_width = 0, req_height = 0, crop = 0;
+  gdouble ratio_w, ratio_h;
+  GstCaps *filter_caps = NULL;
+
+  GST_LOG_OBJECT (self, "in caps: %" GST_PTR_FORMAT, in_caps);
+  GST_LOG_OBJECT (self, "requested caps: %" GST_PTR_FORMAT,
+      self->image_capture_caps);
+
+  in_st = gst_caps_get_structure (in_caps, 0);
+  gst_structure_get_int (in_st, "width", &in_width);
+  gst_structure_get_int (in_st, "height", &in_height);
+
+  req_st = gst_caps_get_structure (self->image_capture_caps, 0);
+  gst_structure_get_int (req_st, "width", &req_width);
+  gst_structure_get_int (req_st, "height", &req_height);
+
+  GST_INFO_OBJECT (self, "we requested %dx%d, and got %dx%d", req_width,
+      req_height, in_width, in_height);
+
+  new_st = gst_structure_copy (req_st);
+  /* If new fields have been added, we need to copy them */
+  gst_structure_foreach (in_st, copy_missing_fields, new_st);
+
+#if 0
+  /* XXX srcbin needs to know of some flags, perhaps?? */
+  if (!(camera->flags & GST_CAMERABIN_FLAG_SOURCE_RESIZE)) {
+#else
+  if (1) {
+#endif
+    GST_DEBUG_OBJECT (self,
+        "source-resize flag disabled, unable to adapt resolution");
+    gst_structure_set (new_st, "width", G_TYPE_INT, in_width, "height",
+        G_TYPE_INT, in_height, NULL);
+  }
+
+  GST_LOG_OBJECT (self, "new image capture caps: %" GST_PTR_FORMAT, new_st);
+
+  /* Crop if requested aspect ratio differs from incoming frame aspect ratio */
+  if (self->src_zoom_crop) {
+
+    ratio_w = (gdouble) in_width / req_width;
+    ratio_h = (gdouble) in_height / req_height;
+
+    if (ratio_w < ratio_h) {
+      crop = in_height - (req_height * ratio_w);
+      self->base_crop_top = crop / 2;
+      self->base_crop_bottom = crop / 2;
+    } else {
+      crop = in_width - (req_width * ratio_h);
+      self->base_crop_left = crop / 2;
+      self->base_crop_right += crop / 2;
+    }
+
+    GST_INFO_OBJECT (self,
+        "setting base crop: left:%d, right:%d, top:%d, bottom:%d",
+        self->base_crop_left, self->base_crop_right, self->base_crop_top,
+        self->base_crop_bottom);
+    g_object_set (G_OBJECT (self->src_zoom_crop),
+        "top", self->base_crop_top,
+        "bottom", self->base_crop_bottom,
+        "left", self->base_crop_left, "right", self->base_crop_right, NULL);
+  }
+
+  /* Update capsfilters */
+  gst_caps_replace (&self->image_capture_caps,
+      gst_caps_new_full (new_st, NULL));
+  set_capsfilter_caps (self, self->image_capture_caps);
+
+  /* Adjust the capsfilter before crop and videoscale elements if necessary */
+  if (in_width == bcamsrc->width && in_height == bcamsrc->height) {
+    GST_DEBUG_OBJECT (self, "no adaptation with resolution needed");
+  } else {
+    GST_DEBUG_OBJECT (self,
+        "changing %" GST_PTR_FORMAT " from %dx%d to %dx%d", self->src_filter,
+        bcamsrc->width, bcamsrc->height, in_width, in_height);
+    /* Apply the width and height to filter caps */
+    g_object_get (G_OBJECT (self->src_filter), "caps", &filter_caps, NULL);
+    filter_caps = gst_caps_make_writable (filter_caps);
+    gst_caps_set_simple (filter_caps, "width", G_TYPE_INT, in_width, "height",
+        G_TYPE_INT, in_height, NULL);
+    g_object_set (G_OBJECT (self->src_filter), "caps", filter_caps, NULL);
+    gst_caps_unref (filter_caps);
+  }
+}
+
+/**
+ * img_capture_prepared:
+ * @data: camerasrc object
+ * @caps: caps describing the prepared image format
+ *
+ * Callback which is called after image capture has been prepared.
+ */
+static void
+img_capture_prepared (gpointer data, GstCaps * caps)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (data);
+
+  GST_INFO_OBJECT (self, "image capture prepared");
+
+  /* It is possible we are about to get something else that we requested */
+  if (!gst_caps_is_equal (self->image_capture_caps, caps)) {
+    adapt_image_capture (self, caps);
+  } else {
+    set_capsfilter_caps (self, self->image_capture_caps);
+  }
+
+//XXX  g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", FALSE,
+//XXX      "active-pad", camera->pad_src_img, NULL);
+}
+
+static void
+set_image_capture_caps (GstV4l2CameraSrc * self, gint width, gint height)
+{
+  GstStructure *structure;
+  GstCaps *new_caps = NULL;
+
+  if (width && height && self->view_finder_caps) {
+    /* Use view finder mode caps as a basis */
+    structure = gst_caps_get_structure (self->view_finder_caps, 0);
+
+    /* Set new resolution for image capture */
+    new_caps = gst_caps_new_simple (gst_structure_get_name (structure),
+        "width", G_TYPE_INT, width, "height", G_TYPE_INT, height, NULL);
+
+    /* Set allowed framerate for the resolution. */
+    set_allowed_framerate (self, new_caps);
+  }
+
+  GST_INFO_OBJECT (self,
+      "init filter caps for image capture %" GST_PTR_FORMAT, new_caps);
+  gst_caps_replace (&self->image_capture_caps, new_caps);
+  self->image_capture_caps_update = FALSE;
+}
+
+/**
+ *
+ */
+static gboolean
+start_image_capture (GstV4l2CameraSrc * self)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  GstPhotography *photography = gst_base_camera_src_get_photography (bcamsrc);
+  gboolean wait_for_prepare = FALSE, ret = FALSE;
+
+  if (photography) {
+    wait_for_prepare = TRUE;
+
+    if (!self->image_capture_caps || self->image_capture_caps_update) {
+      if (bcamsrc->image_capture_width && bcamsrc->image_capture_height) {
+        /* Resolution is set, but it isn't in use yet */
+        set_image_capture_caps (self, bcamsrc->image_capture_width,
+            bcamsrc->image_capture_height);
+      } else {
+        /* Capture resolution not set. Use viewfinder resolution */
+        self->image_capture_caps = gst_caps_copy (self->view_finder_caps);
+        self->image_capture_caps_update = FALSE;
+      }
+    }
+
+    /* Start preparations for image capture */
+    GST_DEBUG_OBJECT (self, "prepare image capture caps %" GST_PTR_FORMAT,
+        self->image_capture_caps);
+
+    ret = gst_photography_prepare_for_capture (photography,
+        (GstPhotoCapturePrepared) img_capture_prepared,
+        self->image_capture_caps, self);
+
+  } else {
+//XXX    g_object_set (G_OBJECT (camera->src_out_sel), "resend-latest", TRUE,
+//XXX        "active-pad", camera->pad_src_img, NULL);
+    ret = TRUE;
+  }
+
+  return ret;
+}
+
+static gboolean
+gst_v4l2_camera_src_set_mode (GstBaseCameraSrc * bcamsrc, GstCameraBinMode mode)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (bcamsrc);
+  GstPhotography *photography = gst_base_camera_src_get_photography (bcamsrc);
+
+  if (photography) {
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (photography),
+            "capture-mode")) {
+      g_object_set (G_OBJECT (photography), "capture-mode", mode, NULL);
+    }
+  }
+
+  self->mode = mode;
+
+  switch (mode) {
+    case MODE_PREVIEW:
+      return TRUE;              // XXX
+    case MODE_IMAGE:
+      return start_image_capture (GST_V4L2_CAMERA_SRC (bcamsrc));
+    case MODE_VIDEO:
+      return TRUE;              // XXX
+  }
+
+  g_assert_not_reached ();
+
+  return FALSE;
+}
+
+static gboolean
+set_videosrc_zoom (GstV4l2CameraSrc * self, gint zoom)
+{
+  gboolean ret = FALSE;
+
+  if (g_object_class_find_property (G_OBJECT_GET_CLASS (self->src_vid_src),
+          "zoom")) {
+    g_object_set (G_OBJECT (self->src_vid_src), "zoom",
+        (gfloat) zoom / 100, NULL);
+    ret = TRUE;
+  }
+  return ret;
+}
+
+static gboolean
+set_element_zoom (GstV4l2CameraSrc * self, gint zoom)
+{
+  gboolean ret = FALSE;
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  gint w2_crop = 0, h2_crop = 0;
+  GstPad *pad_zoom_sink = NULL;
+  gint left = self->base_crop_left;
+  gint right = self->base_crop_right;
+  gint top = self->base_crop_top;
+  gint bottom = self->base_crop_bottom;
+
+  if (self->src_zoom_crop) {
+    /* Update capsfilters to apply the zoom */
+    GST_INFO_OBJECT (self, "zoom: %d, orig size: %dx%d", zoom,
+        bcamsrc->width, bcamsrc->height);
+
+    if (zoom != ZOOM_1X) {
+      w2_crop = (bcamsrc->width - (bcamsrc->width * ZOOM_1X / zoom)) / 2;
+      h2_crop = (bcamsrc->height - (bcamsrc->height * ZOOM_1X / zoom)) / 2;
+
+      left += w2_crop;
+      right += w2_crop;
+      top += h2_crop;
+      bottom += h2_crop;
+
+      /* force number of pixels cropped from left to be even, to avoid slow code
+       * path on videoscale */
+      left &= 0xFFFE;
+    }
+
+    pad_zoom_sink = gst_element_get_static_pad (self->src_zoom_crop, "sink");
+
+    GST_INFO_OBJECT (self,
+        "sw cropping: left:%d, right:%d, top:%d, bottom:%d", left, right, top,
+        bottom);
+
+    GST_PAD_STREAM_LOCK (pad_zoom_sink);
+    g_object_set (self->src_zoom_crop, "left", left, "right", right, "top",
+        top, "bottom", bottom, NULL);
+    GST_PAD_STREAM_UNLOCK (pad_zoom_sink);
+    gst_object_unref (pad_zoom_sink);
+    ret = TRUE;
+  }
+  return ret;
+}
+
+static void
+gst_v4l2_camera_src_set_zoom (GstBaseCameraSrc * bcamsrc, gint zoom)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (bcamsrc);
+
+  GST_INFO_OBJECT (self, "setting zoom %d", zoom);
+
+  if (set_videosrc_zoom (self, zoom)) {
+    set_element_zoom (self, ZOOM_1X);
+    GST_INFO_OBJECT (self, "zoom set using videosrc");
+  } else if (set_element_zoom (self, zoom)) {
+    GST_INFO_OBJECT (self, "zoom set using gst elements");
+  } else {
+    GST_INFO_OBJECT (self, "setting zoom failed");
+  }
+}
+
+static GstCaps *
+gst_v4l2_camera_src_get_allowed_input_caps (GstBaseCameraSrc * bcamsrc)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (bcamsrc);
+  GstCaps *caps = NULL;
+  GstPad *pad = NULL, *peer_pad = NULL;
+  GstState state;
+  GstElement *videosrc;
+
+  videosrc = self->src_vid_src ? self->src_vid_src : self->app_vid_src;
+
+  if (!videosrc) {
+    GST_WARNING_OBJECT (self, "no videosrc, can't get allowed caps");
+    goto failed;
+  }
+
+  if (self->allowed_caps) {
+    GST_DEBUG_OBJECT (self, "returning cached caps");
+    goto done;
+  }
+
+  pad = gst_element_get_static_pad (videosrc, "src");
+
+  if (!pad) {
+    GST_WARNING_OBJECT (self, "no srcpad in videosrc");
+    goto failed;
+  }
+
+  state = GST_STATE (videosrc);
+
+  /* Make this function work also in NULL state */
+  if (state == GST_STATE_NULL) {
+    GST_DEBUG_OBJECT (self, "setting videosrc to ready temporarily");
+    peer_pad = gst_pad_get_peer (pad);
+    if (peer_pad) {
+      gst_pad_unlink (pad, peer_pad);
+    }
+    /* Set videosrc to READY to open video device */
+    gst_element_set_locked_state (videosrc, TRUE);
+    gst_element_set_state (videosrc, GST_STATE_READY);
+  }
+
+  self->allowed_caps = gst_pad_get_caps (pad);
+
+  /* Restore state and re-link if necessary */
+  if (state == GST_STATE_NULL) {
+    GST_DEBUG_OBJECT (self, "restoring videosrc state %d", state);
+    /* Reset videosrc to NULL state, some drivers seem to need this */
+    gst_element_set_state (videosrc, GST_STATE_NULL);
+    if (peer_pad) {
+      gst_pad_link (pad, peer_pad);
+      gst_object_unref (peer_pad);
+    }
+    gst_element_set_locked_state (videosrc, FALSE);
+  }
+
+  gst_object_unref (pad);
+
+done:
+  if (self->allowed_caps) {
+    caps = gst_caps_copy (self->allowed_caps);
+  }
+  GST_DEBUG_OBJECT (self, "allowed caps:%" GST_PTR_FORMAT, caps);
+failed:
+  return caps;
+}
+
+/**
+ * configure_format:
+ * @self: camerasrc object
+ * @caps: caps describing new format
+ *
+ * Configure internal video format for camerabin.
+ */
+static void
+configure_format (GstV4l2CameraSrc * self, GstCaps * caps)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  GstStructure *st;
+  gint width, height;
+
+  st = gst_caps_get_structure (caps, 0);
+
+  gst_structure_get_int (st, "width", &width);
+  gst_structure_get_int (st, "height", &height);
+
+  g_object_set (self, "width", width, "height", height, NULL);
+
+  if (gst_structure_has_field_typed (st, "framerate", GST_TYPE_FRACTION)) {
+    gst_structure_get_fraction (st, "framerate", &bcamsrc->fps_n,
+        &bcamsrc->fps_d);
+  }
+}
+
+
+/**
+ * update_aspect_filter:
+ * @self: camerasrc object
+ * @new_caps: new caps of next buffers arriving to view finder sink element
+ *
+ * Updates aspect ratio capsfilter to maintain aspect ratio, if we need to
+ * scale frames for showing them in view finder.
+ */
+static void
+update_aspect_filter (GstV4l2CameraSrc * self, GstCaps * new_caps)
+{
+  // XXX why not instead add a preserve-aspect-ratio property to videoscale?
+#if 0
+  if (camera->flags & GST_CAMERABIN_FLAG_VIEWFINDER_SCALE) {
+    GstCaps *sink_caps, *ar_caps;
+    GstStructure *st;
+    gint in_w = 0, in_h = 0, sink_w = 0, sink_h = 0, target_w = 0, target_h = 0;
+    gdouble ratio_w, ratio_h;
+    GstPad *sink_pad;
+    const GValue *range;
+
+    sink_pad = gst_element_get_static_pad (camera->view_sink, "sink");
+
+    if (sink_pad) {
+      sink_caps = gst_pad_get_caps (sink_pad);
+      gst_object_unref (sink_pad);
+      if (sink_caps) {
+        if (!gst_caps_is_any (sink_caps)) {
+          GST_DEBUG_OBJECT (camera, "sink element caps %" GST_PTR_FORMAT,
+              sink_caps);
+          /* Get maximum resolution that view finder sink accepts */
+          st = gst_caps_get_structure (sink_caps, 0);
+          if (gst_structure_has_field_typed (st, "width", GST_TYPE_INT_RANGE)) {
+            range = gst_structure_get_value (st, "width");
+            sink_w = gst_value_get_int_range_max (range);
+          }
+          if (gst_structure_has_field_typed (st, "height", GST_TYPE_INT_RANGE)) {
+            range = gst_structure_get_value (st, "height");
+            sink_h = gst_value_get_int_range_max (range);
+          }
+          GST_DEBUG_OBJECT (camera, "sink element accepts max %dx%d", sink_w,
+              sink_h);
+
+          /* Get incoming frames' resolution */
+          if (sink_h && sink_w) {
+            st = gst_caps_get_structure (new_caps, 0);
+            gst_structure_get_int (st, "width", &in_w);
+            gst_structure_get_int (st, "height", &in_h);
+            GST_DEBUG_OBJECT (camera, "new caps with %dx%d", in_w, in_h);
+          }
+        }
+        gst_caps_unref (sink_caps);
+      }
+    }
+
+    /* If we get bigger frames than view finder sink accepts, then we scale.
+       If we scale we need to adjust aspect ratio capsfilter caps in order
+       to maintain aspect ratio while scaling. */
+    if (in_w && in_h && (in_w > sink_w || in_h > sink_h)) {
+      ratio_w = (gdouble) sink_w / in_w;
+      ratio_h = (gdouble) sink_h / in_h;
+
+      if (ratio_w < ratio_h) {
+        target_w = sink_w;
+        target_h = (gint) (ratio_w * in_h);
+      } else {
+        target_w = (gint) (ratio_h * in_w);
+        target_h = sink_h;
+      }
+
+      GST_DEBUG_OBJECT (camera, "setting %dx%d filter to maintain aspect ratio",
+          target_w, target_h);
+      ar_caps = gst_caps_copy (new_caps);
+      gst_caps_set_simple (ar_caps, "width", G_TYPE_INT, target_w, "height",
+          G_TYPE_INT, target_h, NULL);
+    } else {
+      GST_DEBUG_OBJECT (camera, "no scaling");
+      ar_caps = new_caps;
+    }
+
+    GST_DEBUG_OBJECT (camera, "aspect ratio filter caps %" GST_PTR_FORMAT,
+        ar_caps);
+    g_object_set (G_OBJECT (camera->aspect_filter), "caps", ar_caps, NULL);
+    if (ar_caps != new_caps)
+      gst_caps_unref (ar_caps);
+  }
+#endif
+}
+
+
+/**
+ * set_capsfilter_caps:
+ * @self: camerasrc object
+ * @new_caps: pointer to caps object to set
+ *
+ * Set given caps to camerabin capsfilters.
+ */
+static void
+set_capsfilter_caps (GstV4l2CameraSrc * self, GstCaps * new_caps)
+{
+  GST_INFO_OBJECT (self, "new_caps:%" GST_PTR_FORMAT, new_caps);
+
+  configure_format (self, new_caps);
+
+  /* Update zoom */
+  gst_base_camera_src_setup_zoom (GST_BASE_CAMERA_SRC (self));
+
+  /* Update capsfilters */
+  g_object_set (G_OBJECT (self->src_filter), "caps", new_caps, NULL);
+  if (self->src_zoom_filter)
+    g_object_set (G_OBJECT (self->src_zoom_filter), "caps", new_caps, NULL);
+  update_aspect_filter (self, new_caps);
+  GST_INFO_OBJECT (self, "udpated");
+}
+
+static void
+gst_v4l2_camera_src_finish_image_capture (GstBaseCameraSrc * bcamsrc)
+{
+  GstV4l2CameraSrc *self = GST_V4L2_CAMERA_SRC (bcamsrc);
+
+  if (self->image_capture_caps) {
+    /* If we used specific caps for image capture we need to
+       restore the caps and zoom/crop for view finder mode */
+    if (self->src_zoom_crop) {
+      GST_DEBUG_OBJECT (self, "resetting crop in camerabin");
+      g_object_set (self->src_zoom_crop, "left", 0, "right", 0,
+          "top", 0, "bottom", 0, NULL);
+    }
+    self->base_crop_left = 0;
+    self->base_crop_right = 0;
+    self->base_crop_top = 0;
+    self->base_crop_bottom = 0;
+    set_capsfilter_caps (self, self->view_finder_caps);
+  }
+}
+
+static void
+gst_v4l2_camera_src_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+//  GST_DEBUG_CATEGORY_INIT (v4l2_camera_src_debug, "v4l2_camera_src", 0,
+//      "V4l2 camera src");
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "V4l2 camera src element for camerabin", "Source/Video",
+      "V4l2 camera src element for camerabin", "Rob Clark <rob@ti.com>");
+}
+
+static void
+gst_v4l2_camera_src_class_init (GstV4l2CameraSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstBaseCameraSrcClass *gstbasecamerasrc_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstbasecamerasrc_class = GST_BASE_CAMERA_SRC_CLASS (klass);
+
+  gobject_class->dispose = gst_v4l2_camera_src_dispose;
+  gobject_class->finalize = (GObjectFinalizeFunc) gst_v4l2_camera_src_finalize;
+  gobject_class->set_property = gst_v4l2_camera_src_set_property;
+  gobject_class->get_property = gst_v4l2_camera_src_get_property;
+
+  // g_object_class_install_property ....
+
+  gstbasecamerasrc_class->construct_pipeline =
+      gst_v4l2_camera_src_construct_pipeline;
+  gstbasecamerasrc_class->setup_pipeline = gst_v4l2_camera_src_setup_pipeline;
+  gstbasecamerasrc_class->set_zoom = gst_v4l2_camera_src_set_zoom;
+  gstbasecamerasrc_class->set_mode = gst_v4l2_camera_src_set_mode;
+  gstbasecamerasrc_class->get_allowed_input_caps =
+      gst_v4l2_camera_src_get_allowed_input_caps;
+  gstbasecamerasrc_class->finish_image_capture =
+      gst_v4l2_camera_src_finish_image_capture;
+}
+
+static void
+gst_v4l2_camera_src_init (GstV4l2CameraSrc * self,
+    GstV4l2CameraSrcClass * klass)
+{
+  self->mode = MODE_PREVIEW;
+}
diff --git a/gst/camerabin/gstv4l2camerasrc.h b/gst/camerabin/gstv4l2camerasrc.h
new file mode 100644
index 0000000..be852c3
--- /dev/null
+++ b/gst/camerabin/gstv4l2camerasrc.h
@@ -0,0 +1,113 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef __GST_V4L2_CAMERA_SRC_H__
+#define __GST_V4L2_CAMERA_SRC_H__
+
+#include <gst/gst.h>
+#include <gst/camerasrc/gstbasecamerasrc.h>
+
+G_BEGIN_DECLS
+#define GST_TYPE_V4L2_CAMERA_SRC \
+  (gst_v4l2_camera_src_get_type())
+#define GST_V4L2_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_V4L2_CAMERA_SRC,GstV4l2CameraSrc))
+#define GST_V4L2_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_V4L2_CAMERA_SRC,GstV4l2CameraSrcClass))
+#define GST_IS_V4L2_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_V4L2_CAMERA_SRC))
+#define GST_IS_V4L2_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_V4L2_CAMERA_SRC))
+    GType gst_v4l2_camera_src_get_type (void);
+
+typedef struct _GstV4l2CameraSrc GstV4l2CameraSrc;
+typedef struct _GstV4l2CameraSrcClass GstV4l2CameraSrcClass;
+
+
+/**
+ * GstV4l2CameraSrc:
+ *
+ */
+struct _GstV4l2CameraSrc
+{
+  GstBaseCameraSrc parent;
+
+  GstCameraBinMode mode;
+
+  /* source elements */
+  GstElement *src_vid_src;
+  GstElement *src_filter;
+  GstElement *src_zoom_crop;
+  GstElement *src_zoom_scale;
+  GstElement *src_zoom_filter;
+  GstElement *src_out_sel;
+
+  /* srcpads of tee */
+  GstPad *tee_vf_srcpad;
+  GstPad *tee_image_srcpad;
+  GstPad *tee_video_srcpad;
+
+  /* Application configurable elements */
+  GstElement *app_vid_src;
+  GstElement *app_video_filter;
+
+  /* Caps that videosrc supports */
+  GstCaps *allowed_caps;
+
+  /* Optional base crop for frames. Used to crop frames e.g.
+     due to wrong aspect ratio, before the crop related to zooming. */
+  gint base_crop_top;
+  gint base_crop_bottom;
+  gint base_crop_left;
+  gint base_crop_right;
+
+  /* Caps applied to capsfilters when in view finder mode */
+  GstCaps *view_finder_caps;
+
+  /* Caps applied to capsfilters when taking still image */
+  GstCaps *image_capture_caps;
+  gboolean image_capture_caps_update; // XXX where does this get set..
+
+  /* if GstV4l2CameraSrc is moved into camerabin plugin, then this isn't
+   * needed:
+   */
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+
+/**
+ * GstV4l2CameraSrcClass:
+ *
+ */
+struct _GstV4l2CameraSrcClass
+{
+  GstBaseCameraSrcClass parent;
+
+  /* if GstV4l2CameraSrc is moved into camerabin plugin, then this isn't
+   * needed:
+   */
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+
+
+
+#endif /* __GST_V4L2_CAMERA_SRC_H__ */
-- 
1.7.1

