From 87cbb8ed986cb73cff5ad40506c7aff19f9fc37c Mon Sep 17 00:00:00 2001
From: huceke <gimli@i7.(none)>
Date: Tue, 20 Mar 2012 18:56:26 +0100
Subject: [PATCH 03/17] [dove] added dove overlay render.

---
 xbmc/cores/VideoRenderers/DoveOverlayRenderer.cpp |  610 +++++++++++++++++++++
 xbmc/cores/VideoRenderers/DoveOverlayRenderer.h   |  206 +++++++
 xbmc/cores/VideoRenderers/dovefb.h                |  517 +++++++++++++++++
 3 files changed, 1333 insertions(+), 0 deletions(-)
 create mode 100644 xbmc/cores/VideoRenderers/DoveOverlayRenderer.cpp
 create mode 100644 xbmc/cores/VideoRenderers/DoveOverlayRenderer.h
 create mode 100644 xbmc/cores/VideoRenderers/dovefb.h

diff --git a/xbmc/cores/VideoRenderers/DoveOverlayRenderer.cpp b/xbmc/cores/VideoRenderers/DoveOverlayRenderer.cpp
new file mode 100644
index 0000000..82502d5
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/DoveOverlayRenderer.cpp
@@ -0,0 +1,610 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.solid-run.com
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ * Original Dove Overlay Rendere written by Rabeeh Khoury from Solid-Run <support@solid-run.com>
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+#include "config.h"
+#endif
+
+#if defined(HAS_MARVELL_DOVE)
+
+#undef COLOR_KEY_BLACK
+#define COLOR_KEY_ALPHA
+#include "DoveOverlayRenderer.h"
+#include "dovefb.h"
+#include "utils/log.h"
+#include <stdlib.h>
+#include <malloc.h>
+#include "utils/fastmemcpy.h"
+#include "guilib/GraphicContext.h"
+
+#if defined(CLASSNAME)
+#undef CLASSNAME
+#endif
+
+#define CLASSNAME "CDoveOverlayRenderer"
+
+CDoveOverlayRenderer::CDoveOverlayRenderer()
+{
+  memset(m_SoftPicture, 0, sizeof(OutputBuffer) * NUM_BUFFERS);
+
+  for(int i = 0; i < NUM_BUFFERS; i++)
+  {
+    m_yuvBuffers[i].plane[0]  = NULL;
+    m_yuvBuffers[i].plane[1]  = NULL;
+    m_yuvBuffers[i].plane[2]  = NULL;
+
+    m_SoftPicture[i].pPicture = (IppVmetaPicture *)malloc(sizeof(IppVmetaPicture));
+    if(m_SoftPicture[i].pPicture)
+      memset(m_SoftPicture[i].pPicture, 0, sizeof(IppVmetaPicture));
+  }
+
+  m_DllMiscGen        = new DllLibMiscGen();
+  m_DllVMETA          = new DllLibVMETA();
+
+  UnInit();
+}
+
+CDoveOverlayRenderer::~CDoveOverlayRenderer()
+{
+  UnInit();
+
+  for(int i = 0; i < NUM_BUFFERS; i++)
+  {
+    if(m_SoftPicture[i].pPicture)
+      free(m_SoftPicture[i].pPicture);
+    m_SoftPicture[i].pPicture = NULL;
+  }
+
+  m_DllVMETA->Unload();
+  m_DllMiscGen->Unload();
+
+  delete m_DllMiscGen;
+  delete m_DllVMETA;
+}
+
+
+void CDoveOverlayRenderer::ManageDisplay()
+{
+  CRect view;
+
+  view.x1 = (float)g_settings.m_ResInfo[m_resolution].Overscan.left;
+  view.y1 = (float)g_settings.m_ResInfo[m_resolution].Overscan.top;
+  view.x2 = (float)g_settings.m_ResInfo[m_resolution].Overscan.right;
+  view.y2 = (float)g_settings.m_ResInfo[m_resolution].Overscan.bottom;
+
+  m_sourceRect.x1 = (float)g_settings.m_currentVideoSettings.m_CropLeft;
+  m_sourceRect.y1 = (float)g_settings.m_currentVideoSettings.m_CropTop;
+  m_sourceRect.x2 = (float)m_sourceWidth - g_settings.m_currentVideoSettings.m_CropRight;
+  m_sourceRect.y2 = (float)m_sourceHeight - g_settings.m_currentVideoSettings.m_CropBottom;
+
+  CalcNormalDisplayRect(view.x1, view.y1, view.Width(), view.Height(), GetAspectRatio() * g_settings.m_fPixelRatio, g_settings.m_fZoomAmount, g_settings.m_fVerticalShift);
+
+  if (CONF_FLAGS_FORMAT_MASK(m_iFlags) == CONF_FLAGS_FORMAT_UYVY)
+  {
+    m_overlaySurface.videoMode = DOVEFB_VMODE_YUV422PACKED_SWAPYUorV;
+    m_overlaySurface.viewPortInfo.ycPitch = (m_sourceRect.x2 - m_sourceRect.x1) * 2;
+    m_overlaySurface.viewPortInfo.uvPitch = 0;
+  } 
+  else if (CONF_FLAGS_FORMAT_MASK(m_iFlags) == CONF_FLAGS_FORMAT_YV12)
+  {
+    m_overlaySurface.videoMode = DOVEFB_VMODE_YUV420PLANAR;
+    m_overlaySurface.viewPortInfo.ycPitch = m_sourceRect.x2 - m_sourceRect.x1;
+    m_overlaySurface.viewPortInfo.uvPitch = (m_sourceRect.x2 - m_sourceRect.x1) / 2;
+  } 
+
+  m_overlaySurface.viewPortInfo.srcWidth  = m_sourceRect.x2 - m_sourceRect.x1;
+  m_overlaySurface.viewPortInfo.srcHeight = m_sourceRect.y2 - m_sourceRect.y1;
+  m_overlaySurface.viewPortInfo.zoomXSize = m_destRect.x2 - m_destRect.x1;
+  m_overlaySurface.viewPortInfo.zoomYSize = m_destRect.y2 - m_destRect.y1;
+
+  m_overlaySurface.viewPortOffset.xOffset = m_destRect.x1;
+  m_overlaySurface.viewPortOffset.yOffset = m_destRect.y1;
+
+}
+
+bool CDoveOverlayRenderer::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, 
+                                     float fps, unsigned int flags, unsigned int format)
+{
+  if (CONF_FLAGS_FORMAT_MASK(flags) == CONF_FLAGS_FORMAT_NV12)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Bad format\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (CONF_FLAGS_FORMAT_MASK(flags) != CONF_FLAGS_FORMAT_UYVY && CONF_FLAGS_FORMAT_MASK(flags) != CONF_FLAGS_FORMAT_YV12)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Unkown format 0x%x", CLASSNAME, __func__, CONF_FLAGS_FORMAT_MASK(flags));
+    return false;
+  }
+
+  memset (&m_overlaySurface, 0, sizeof(m_overlaySurface));
+  m_overlaySurface.videoBufferAddr.startAddr = 0;
+  m_overlaySurface.videoBufferAddr.length = 0;//frameSize;
+  m_overlaySurface.videoBufferAddr.inputData = 0;
+  m_overlaySurface.videoBufferAddr.frameID = 0;
+
+  m_sourceWidth   = width;
+  m_sourceHeight  = height;
+  m_iFlags        = flags;
+
+  // Calculate the input frame aspect ratio.
+  CalculateFrameAspectRatio(d_width, d_height);
+  ChooseBestResolution(fps);
+  SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
+  ManageDisplay();
+
+  CLog::Log(LOGDEBUG, "%s::%s - Setting ycPitch to %d, uvPitch to %d\n", CLASSNAME, __func__,
+      m_overlaySurface.viewPortInfo.ycPitch ,m_overlaySurface.viewPortInfo.uvPitch);
+
+  CLog::Log(LOGDEBUG, "m_sourceRect.x1 %f m_sourceRect.x2 %f m_sourceRect.y1 %f m_sourceRect.y2 %f m_sourceFrameRatio %f\n",
+      m_sourceRect.x1, m_sourceRect.x2, m_sourceRect.y1, m_sourceRect.y2, m_sourceFrameRatio);
+  CLog::Log(LOGDEBUG, "m_destRect.x1 %f m_destRect.x2 %f m_destRect.y1 %f m_destRect.y2 %f\n",
+      m_destRect.x1, m_destRect.x2, m_destRect.y1, m_destRect.y2);
+
+  m_enabled = 0;
+
+  // Open the framebuffer
+  m_overlayfd = open("/dev/fb1", O_RDWR);
+  if (m_overlayfd == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to open framebuffer", CLASSNAME, __func__);
+    return false;
+  }
+
+  int srcMode = SHM_NORMAL;
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_SET_SRC_MODE, &srcMode) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to enable video overlay\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_SET_VIDEO_MODE, &m_overlaySurface.videoMode) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to setup video mode\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_SET_VIEWPORT_INFO, &m_overlaySurface.viewPortInfo) != 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to setup video port\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_SET_VID_OFFSET, &m_overlaySurface.viewPortOffset) != 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to setup video port offset\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  int interpolation = 3; // bi-linear interpolation
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_SET_INTERPOLATION_MODE, &interpolation) != 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to setup video interpolation mode\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  struct _sColorKeyNAlpha alpha;
+
+  memset (&alpha, 0, sizeof(alpha));
+
+  alpha.mode = DOVEFB_ENABLE_RGB_COLORKEY_MODE;
+  alpha.alphapath = DOVEFB_GRA_PATH_ALPHA;
+  alpha.config = 0xff;//c0;
+#ifdef COLOR_KEY_ALPHA
+  alpha.Y_ColorAlpha = 0x02020200;
+  alpha.U_ColorAlpha = 0x05050500;
+  alpha.V_ColorAlpha = 0x07070700;
+#endif
+#ifdef COLOR_KEY_BLACK
+  alpha.Y_ColorAlpha = 0x0;
+  alpha.U_ColorAlpha = 0x0;
+  alpha.V_ColorAlpha = 0x0;
+#endif
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_SET_COLORKEYnALPHA, &alpha) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Failed to configure alpha\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  for (unsigned int i = 0; i < NUM_BUFFERS; i++)
+  {
+    FreeYV12Image(i);
+    CreateYV12Image(i, m_sourceWidth, m_sourceHeight);
+  }
+
+  m_currentBuffer = 0;
+  m_bConfigured   = true;
+
+  CLog::Log(LOGDEBUG, "%s::%s - Proper format, continuing\n", CLASSNAME, __func__);
+
+  return m_bConfigured;
+}
+
+unsigned int CDoveOverlayRenderer::PreInit()
+{
+  if(!m_DllVMETA->Load() || !m_DllMiscGen->Load())
+    return false;
+
+  UnInit();
+
+  m_currentBuffer = 0;
+
+  m_resolution = g_guiSettings.m_LookAndFeelResolution;
+  if ( m_resolution == RES_WINDOW )
+    m_resolution = RES_DESKTOP;
+
+  return true;
+}
+
+int CDoveOverlayRenderer::GetImage(YV12Image *image, int source, bool readonly)
+{
+  if(!image)
+    return -1;
+
+  /* take next available buffer */
+  if( source == AUTOSOURCE)
+    source = NextYV12Image();
+
+  YV12Image &im = m_yuvBuffers[source];
+
+  for(int p = 0; p < MAX_PLANES; p++)
+  {
+    image->plane[p]  = im.plane[p];
+    image->stride[p] = im.stride[p];
+  }
+
+  image->width    = im.width;
+  image->height   = im.height;
+  image->flags    = im.flags;
+  image->cshift_x = im.cshift_x;
+  image->cshift_y = im.cshift_y;
+
+  return source;
+}
+
+void CDoveOverlayRenderer::ReleaseImage(int source, bool preserve)
+{
+}
+
+void CDoveOverlayRenderer::FlipPage(int source)
+{
+  if (!m_bConfigured)
+    return;
+
+  ManageDisplay();
+
+  IppVmetaPicture *pPicture = m_SoftPicture[m_currentBuffer].pPicture;
+
+  struct shm_private_info info;
+  info.method = SHM_VMETA;
+  ioctl(m_overlayfd, DOVEFB_IOCTL_SET_SRC_MODE, &info.method);
+
+  m_overlaySurface.videoBufferAddr.frameID = 0;
+
+  if(pPicture && pPicture->nPhyAddr)
+  {
+    m_overlaySurface.videoBufferAddr.startAddr = (unsigned char *)pPicture->nPhyAddr;
+    m_overlaySurface.videoBufferAddr.length    = pPicture->nBufSize;
+  } 
+  else 
+  {
+    m_overlaySurface.videoBufferAddr.startAddr = NULL;
+    m_overlaySurface.videoBufferAddr.length    = 0;
+  }
+
+  //ioctl by Solid-Run not in marvel kernel
+  //if(ioctl(m_overlayfd, DOVEFB_IOCTL_NEXT_FRAME_PRESENT, &m_SoftPicture[m_currentBuffer].buf) != 0)
+
+  if(ioctl(m_overlayfd, DOVEFB_IOCTL_FLIP_VID_BUFFER, &m_overlaySurface) != 0) 
+    CLog::Log(LOGERROR, "%s::%s - Error flipping\n", CLASSNAME, __func__);
+
+  if (m_enabled == 0) 
+  {
+    m_enabled = 1;
+
+    if (ioctl(m_overlayfd, DOVEFB_IOCTL_SWITCH_VID_OVLY, &m_enabled) == -1)
+      CLog::Log(LOGERROR, "%s::%s - Failed to enable video overlay\n", CLASSNAME, __func__);
+
+  }
+
+  if (ioctl(m_overlayfd, DOVEFB_IOCTL_WAIT_VSYNC, 0) != 0)
+    CLog::Log(LOGERROR, "%s::%s - Error waiting for vsync\n", CLASSNAME, __func__);
+
+  if( source >= 0 && source < NUM_BUFFERS )
+    m_currentBuffer = source;
+  else
+    m_currentBuffer = NextYV12Image();
+}
+
+void CDoveOverlayRenderer::Reset()
+{
+}
+
+void CDoveOverlayRenderer::Update(bool bPauseDrawing)
+{
+}
+
+void CDoveOverlayRenderer::AddProcessor(YV12Image *image, DVDVideoPicture *pDvdVideoPicture)
+{
+  if (!m_bConfigured)
+    return;
+
+  DrawSlice(pDvdVideoPicture);
+}
+
+void CDoveOverlayRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
+{
+  if (!m_bConfigured)
+    return;
+
+#ifdef COLOR_KEY_ALPHA
+  glEnable(GL_SCISSOR_TEST);
+  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+  glClear(GL_COLOR_BUFFER_BIT);
+#endif
+}
+
+bool CDoveOverlayRenderer::RenderCapture(CRenderCapture* capture)
+{
+  CLog::Log(LOGERROR, "%s::%s - Not implemented\n", CLASSNAME, __func__);
+  return true;
+}
+
+
+unsigned int CDoveOverlayRenderer::DrawSlice(DVDVideoPicture *pDvdVideoPicture)
+{
+  Ipp32u nPhyAddr = 0;
+  Ipp32u nBufSize = 0;
+
+  if(pDvdVideoPicture->vmeta)
+  {
+    IppVmetaPicture *pPicture = (IppVmetaPicture *)pDvdVideoPicture->vmeta;
+    nPhyAddr = pPicture->nPhyAddr;
+    nBufSize = pPicture->nBufSize;
+  }
+
+  IppVmetaPicture *pPicture = m_SoftPicture[m_currentBuffer].pPicture;
+
+  m_SoftPicture[m_currentBuffer].buf[0] = NULL;
+  m_SoftPicture[m_currentBuffer].buf[1] = NULL;
+  m_SoftPicture[m_currentBuffer].buf[2] = NULL;
+
+  if(!pPicture)
+    return false;
+
+  if(nPhyAddr)
+  {
+    // Decoder allocated buffer
+    pPicture->nPhyAddr = nPhyAddr;
+    pPicture->nBufSize = nBufSize;
+    m_SoftPicture[m_currentBuffer].bFree = false;
+    m_SoftPicture[m_currentBuffer].buf[0] = (unsigned char *)pPicture->nPhyAddr;
+    m_SoftPicture[m_currentBuffer].buf[1] = (unsigned char *)pPicture->nPhyAddr + 
+      (pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight);
+    m_SoftPicture[m_currentBuffer].buf[2] = (unsigned char *)pPicture->nPhyAddr + 
+      (pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight) +
+      (pDvdVideoPicture->iLineSize[1] * pDvdVideoPicture->iHeight / 2);
+  } 
+  else
+  {
+    // Software decoding. Allocate buffer for ouput
+    if(CONF_FLAGS_FORMAT_MASK(m_iFlags) != CONF_FLAGS_FORMAT_YV12)
+      return false;
+
+    unsigned int memSize = (pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight) +
+      (pDvdVideoPicture->iLineSize[1] * pDvdVideoPicture->iHeight / 2) +
+      (pDvdVideoPicture->iLineSize[2] * pDvdVideoPicture->iHeight / 2);
+
+    if(!pPicture->pBuf)
+      pPicture->pBuf = (Ipp8u*)m_DllVMETA->vdec_os_api_dma_alloc(memSize, VMETA_DIS_BUF_ALIGN, &(pPicture->nPhyAddr));
+
+    if(!pPicture->pBuf)
+    {
+      CLog::Log(LOGERROR, "%s::%s - Failed to alloc memory\n", CLASSNAME, __func__);
+      return false;
+    }
+
+    m_SoftPicture[m_currentBuffer].bFree = true;
+    m_SoftPicture[m_currentBuffer].buf[0] = (unsigned char *)pPicture->nPhyAddr;
+    m_SoftPicture[m_currentBuffer].buf[1] = (unsigned char *)pPicture->nPhyAddr + 
+      (pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight);
+    m_SoftPicture[m_currentBuffer].buf[2] = (unsigned char *)pPicture->nPhyAddr + 
+      (pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight) +
+      (pDvdVideoPicture->iLineSize[1] * pDvdVideoPicture->iHeight / 2);
+
+    unsigned char *dst = (unsigned char *)pPicture->pBuf;
+
+    memset(dst, 0, memSize);
+
+    /*
+    int i;
+
+    unsigned char *src = pDvdVideoPicture->data[0];
+    for(i = 0; i < pDvdVideoPicture->iHeight; i++)
+    {
+      fast_memcpy(dst, src, pDvdVideoPicture->iLineSize[0]);
+      src += pDvdVideoPicture->iLineSize[0];
+      dst += pDvdVideoPicture->iLineSize[0];
+    }
+
+    src = pDvdVideoPicture->data[1];
+    for(i = 0; i < pDvdVideoPicture->iHeight / 2; i++)
+    {
+      fast_memcpy(dst, src, pDvdVideoPicture->iLineSize[1]);
+      src += pDvdVideoPicture->iLineSize[1];
+      dst += pDvdVideoPicture->iLineSize[1];
+    }
+
+    src = pDvdVideoPicture->data[2];
+    for(i = 0; i < pDvdVideoPicture->iHeight / 2; i++)
+    {
+      fast_memcpy(dst, src, pDvdVideoPicture->iLineSize[2]);
+      src += pDvdVideoPicture->iLineSize[2];
+      dst += pDvdVideoPicture->iLineSize[2];
+    }
+    */
+
+    fast_memcpy( dst, (unsigned char *)pDvdVideoPicture->data[0], pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight );
+    dst += pDvdVideoPicture->iLineSize[0] * pDvdVideoPicture->iHeight;
+    fast_memcpy( dst, (unsigned char *)pDvdVideoPicture->data[1], pDvdVideoPicture->iLineSize[1] * pDvdVideoPicture->iHeight / 2 );
+    dst += pDvdVideoPicture->iLineSize[1] * pDvdVideoPicture->iHeight / 2;
+    fast_memcpy( dst, (unsigned char *)pDvdVideoPicture->data[2], pDvdVideoPicture->iLineSize[2] * pDvdVideoPicture->iHeight / 2 );
+  }
+  return 0;
+}
+
+void CDoveOverlayRenderer::UnInit()
+{
+  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+
+  memset(m_FreeBufAddr, 0, MAX_QUEUE_NUM * sizeof(unsigned char*));
+  if(m_overlayfd)
+    ioctl(m_overlayfd, DOVEFB_IOCTL_GET_FREELIST, &m_FreeBufAddr);
+
+  if(m_enabled)
+  {
+    m_enabled                 = 0;
+
+    if (ioctl(m_overlayfd, DOVEFB_IOCTL_WAIT_VSYNC, 0) != 0)
+      CLog::Log(LOGERROR, "%s::%s - Error waiting for vsync\n", CLASSNAME, __func__);
+
+    if(ioctl(m_overlayfd, DOVEFB_IOCTL_SWITCH_VID_OVLY, &m_enabled) == -1)
+      CLog::Log(LOGERROR, "%s::%s Failed to disable video overlay\n", CLASSNAME, __func__);
+  }
+
+  if (m_overlayfd > 0)
+    close(m_overlayfd);
+
+  for(int i = 0; i < NUM_BUFFERS; i++)
+  {
+    FreeYV12Image(i);
+    if(m_SoftPicture[i].bFree)
+    {
+      if(m_SoftPicture[i].pPicture && m_SoftPicture[i].pPicture->pBuf)
+        m_DllVMETA->vdec_os_api_dma_free(m_SoftPicture[i].pPicture->pBuf);
+      m_SoftPicture[i].pPicture->pBuf = NULL;
+      m_SoftPicture[i].bFree = false;
+    }
+  }
+
+  m_currentBuffer           = 0;
+  m_iFlags                  = 0;
+  m_bConfigured             = false;
+  m_overlayfd               = -1;
+  m_sourceWidth             = 0;
+  m_sourceHeight            = 0;
+
+  memset(&m_overlaySurface, 0, sizeof(struct _sOvlySurface));
+  memset(&m_overlayPlaneInfo, 0, sizeof(struct _sViewPortInfo));
+}
+
+void CDoveOverlayRenderer::CreateThumbnail(CBaseTexture* texture, unsigned int width, unsigned int height)
+{
+  CLog::Log(LOGDEBUG, "%s::%s Was asked to create thumbnail (width = %d, height = %d\n", 
+      CLASSNAME, __func__, width, height);
+}
+
+bool CDoveOverlayRenderer::Supports(EDEINTERLACEMODE mode)
+{
+  return false;
+}
+
+bool CDoveOverlayRenderer::Supports(ERENDERFEATURE feature)
+{
+  return false;
+}
+
+bool CDoveOverlayRenderer::SupportsMultiPassRendering()
+{
+  return false;
+}
+
+bool CDoveOverlayRenderer::Supports(EINTERLACEMETHOD method)
+{
+  return false;
+}
+
+bool CDoveOverlayRenderer::Supports(ESCALINGMETHOD method)
+{
+  if(method == VS_SCALINGMETHOD_NEAREST || method == VS_SCALINGMETHOD_LINEAR)
+    return true;
+
+  return false;
+}
+
+EINTERLACEMETHOD CDoveOverlayRenderer::AutoInterlaceMethod()
+{
+  return VS_INTERLACEMETHOD_NONE;
+}
+
+unsigned int CDoveOverlayRenderer::NextYV12Image()
+{
+  return (m_currentBuffer + 1) % NUM_BUFFERS;
+}
+
+bool CDoveOverlayRenderer::CreateYV12Image(unsigned int index, unsigned int width, unsigned int height)
+{
+  YV12Image &im = m_yuvBuffers[index];
+
+  im.width  = width;
+  im.height = height;
+  im.cshift_x = 1;
+  im.cshift_y = 1;
+
+  unsigned paddedWidth = (im.width + 15) & ~15;
+
+  im.stride[0] = paddedWidth;
+  im.stride[1] = paddedWidth >> im.cshift_x;
+  im.stride[2] = paddedWidth >> im.cshift_x;
+
+  im.planesize[0] = im.stride[0] * im.height;
+  im.planesize[1] = im.stride[1] * ( im.height >> im.cshift_y );
+  im.planesize[2] = im.stride[2] * ( im.height >> im.cshift_y );
+
+  /*
+  for (int i = 0; i < MAX_PLANES; i++)
+    im.plane[i] = new BYTE[im.planesize[i]];
+  */
+
+  return true;
+}
+
+bool CDoveOverlayRenderer::FreeYV12Image(unsigned int index)
+{
+  YV12Image &im = m_yuvBuffers[index];
+
+  for (int i = 0; i < MAX_PLANES; i++)
+  {
+    //delete[] im.plane[i];
+    im.plane[i] = NULL;
+  }
+
+  memset(&im , 0, sizeof(YV12Image));
+
+  return true;
+}
+#endif
diff --git a/xbmc/cores/VideoRenderers/DoveOverlayRenderer.h b/xbmc/cores/VideoRenderers/DoveOverlayRenderer.h
new file mode 100644
index 0000000..320cc1c
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/DoveOverlayRenderer.h
@@ -0,0 +1,206 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#pragma once
+
+#if defined(HAS_MARVELL_DOVE)
+
+#undef __u8
+#undef byte
+
+#include "../../settings/VideoSettings.h"
+#include "../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "../dvdplayer/DVDCodecs/Video/DllVMETA.h"
+#include "RenderFlags.h"
+#include "BaseRenderer.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+
+class CRenderCapture;
+class CBaseTexture;
+
+#undef ALIGN
+#define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
+
+#define AUTOSOURCE -1
+
+#define IMAGE_FLAG_WRITING   0x01 /* image is in use after a call to GetImage, caller may be reading or writing */
+#define IMAGE_FLAG_READING   0x02 /* image is in use after a call to GetImage, caller is only reading */
+#define IMAGE_FLAG_DYNAMIC   0x04 /* image was allocated due to a call to GetImage */
+#define IMAGE_FLAG_RESERVED  0x08 /* image is reserved, must be asked for specifically used to preserve images */
+#define IMAGE_FLAG_READY     0x16 /* image is ready to be uploaded to texture memory */
+#define IMAGE_FLAG_INUSE (IMAGE_FLAG_WRITING | IMAGE_FLAG_READING | IMAGE_FLAG_RESERVED)
+
+extern "C"
+{
+#include <sys/ioctl.h>
+#include <linux/fb.h>
+#include "dovefb.h"
+}
+
+struct DRAWRECT
+{
+  float left;
+  float top;
+  float right;
+  float bottom;
+};
+
+enum EFIELDSYNC
+{
+  FS_NONE,
+  FS_TOP, // FS_ODD,
+  FS_BOT  // FS_EVEN
+};
+
+struct YUVRANGE
+{
+  int y_min, y_max;
+  int u_min, u_max;
+  int v_min, v_max;
+};
+
+struct YUVCOEF
+{
+  float r_up, r_vp;
+  float g_up, g_vp;
+  float b_up, b_vp;
+};
+
+/*
+enum RenderMethod
+{
+  RENDER_GLSL=0x01,
+  RENDER_SW=0x04,
+  RENDER_POT=0x10
+};
+
+enum RenderQuality
+{
+  RQ_LOW=1,
+  RQ_SINGLEPASS,
+  RQ_MULTIPASS,
+  RQ_SOFTWARE
+};
+*/
+
+#define PLANE_Y 0
+#define PLANE_U 1
+#define PLANE_V 2
+
+#define FIELD_FULL 0
+#define FIELD_ODD 1
+#define FIELD_EVEN 2
+
+#define NUM_BUFFERS 3
+
+#define MAX_QUEUE_NUM 60
+
+extern YUVRANGE yuv_range_lim;
+extern YUVRANGE yuv_range_full;
+extern YUVCOEF yuv_coef_bt601;
+extern YUVCOEF yuv_coef_bt709;
+extern YUVCOEF yuv_coef_ebu;
+extern YUVCOEF yuv_coef_smtp240m;
+
+typedef struct _OutputBuffer
+{
+  IppVmetaPicture *pPicture;
+  bool            bFree;
+  unsigned char   *buf[3];
+} OutputBuffer;
+
+class CDoveOverlayRenderer : public CBaseRenderer
+{
+  public:
+    CDoveOverlayRenderer();
+    virtual ~CDoveOverlayRenderer();
+
+    virtual void Update(bool bPauseDrawing);
+    virtual void SetupScreenshot() {};
+
+    bool RenderCapture(CRenderCapture* capture); 
+
+    void CreateThumbnail(CBaseTexture *texture, unsigned int width, unsigned int height);
+
+    // Player functions
+    virtual void ManageDisplay();
+    virtual bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, 
+                           float fps, unsigned int flags, unsigned int format);
+    virtual bool IsConfigured() { return m_bConfigured; }
+    virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
+    virtual void         ReleaseImage(int source, bool preserve = false);
+    virtual unsigned int DrawSlice(DVDVideoPicture *pDvdVideoPicture);
+    virtual void         FlipPage(int source);
+    virtual unsigned int PreInit();
+    virtual void         UnInit();
+    virtual void         Reset(); /* resets renderer after seek for example */
+
+    virtual void         AddProcessor(YV12Image *image, DVDVideoPicture *pDvdVideoPicture);
+
+    virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
+
+    // Feature support
+    virtual bool SupportsMultiPassRendering();
+    virtual bool Supports(ERENDERFEATURE feature);
+    virtual bool Supports(EDEINTERLACEMODE mode);
+    virtual bool Supports(EINTERLACEMETHOD method);
+    virtual bool Supports(ESCALINGMETHOD method);
+
+    virtual EINTERLACEMETHOD AutoInterlaceMethod();
+
+  private:
+    unsigned int NextYV12Image();
+    bool CreateYV12Image(unsigned int index, unsigned int width, unsigned int height);
+    bool FreeYV12Image(unsigned int index);
+
+    bool          m_bConfigured;
+    unsigned int  m_iFlags;
+
+    YV12Image     m_yuvBuffers[NUM_BUFFERS];
+    unsigned int  m_currentBuffer;
+
+    // The Overlay handlers
+    int           m_overlayfd;
+
+    int                       m_enabled;
+    struct _sOvlySurface      m_overlaySurface;
+    struct _sViewPortInfo     m_overlayPlaneInfo;
+
+    DllLibMiscGen             *m_DllMiscGen;
+    DllLibVMETA               *m_DllVMETA;
+
+    OutputBuffer              m_SoftPicture[NUM_BUFFERS];
+
+    unsigned char             *m_FreeBufAddr[MAX_QUEUE_NUM];
+};
+
+inline int NP2( unsigned x )
+{
+  --x;
+  x |= x >> 1;
+  x |= x >> 2;
+  x |= x >> 4;
+  x |= x >> 8;
+  x |= x >> 16;
+  return ++x;
+}
+#endif
diff --git a/xbmc/cores/VideoRenderers/dovefb.h b/xbmc/cores/VideoRenderers/dovefb.h
new file mode 100644
index 0000000..4a4a562
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/dovefb.h
@@ -0,0 +1,517 @@
+/*
+ * linux/include/video/dovefb.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _DOVEFB_H_
+#define _DOVEFB_H_
+
+/* ---------------------------------------------- */
+/*              Header Files                      */
+/* ---------------------------------------------- */
+#include <linux/fb.h>
+
+/* ---------------------------------------------- */
+/*              IOCTL Definition                  */
+/* ---------------------------------------------- */
+#define DOVEFB_IOC_MAGIC			'm'
+#define DOVEFB_IOCTL_CONFIG_CURSOR		_IO(DOVEFB_IOC_MAGIC, 0)
+#define DOVEFB_IOCTL_DUMP_REGS			_IO(DOVEFB_IOC_MAGIC, 1)
+#define DOVEFB_IOCTL_CLEAR_IRQ			_IO(DOVEFB_IOC_MAGIC, 2)
+
+/*
+ * There are many video mode supported.
+ */
+#define DOVEFB_IOCTL_SET_VIDEO_MODE		_IO(DOVEFB_IOC_MAGIC, 3)
+#define DOVEFB_IOCTL_GET_VIDEO_MODE		_IO(DOVEFB_IOC_MAGIC, 4)
+/* Request a new video buffer from driver. User program needs to free
+ * this memory.
+ */
+#define DOVEFB_IOCTL_CREATE_VID_BUFFER		_IO(DOVEFB_IOC_MAGIC, 5)
+
+/* Configure viewport in driver. */
+#define DOVEFB_IOCTL_SET_VIEWPORT_INFO		_IO(DOVEFB_IOC_MAGIC, 6)
+#define DOVEFB_IOCTL_GET_VIEWPORT_INFO		_IO(DOVEFB_IOC_MAGIC, 7)
+
+/* Flip the video buffer from user mode. Vide buffer can be separated into:
+ * a. Current-used buffer - user program put any data into it. It will be
+ *    displayed immediately.
+ * b. Requested from driver but not current-used - user programe can put any
+ *    data into it. It will be displayed after calling
+ *    DOVEFB_IOCTL_FLIP_VID_BUFFER.
+ *    User program should free this memory when they don't use it any more.
+ * c. User program alloated - user program can allocated a contiguos DMA
+ *    buffer to store its video data. And flip it to driver. Notices that
+ *    this momory should be free by user programs. Driver won't take care of
+ *    this.
+ */
+#define DOVEFB_IOCTL_FLIP_VID_BUFFER		_IO(DOVEFB_IOC_MAGIC, 8)
+
+/* Get the current buffer information. User program could use it to display
+ * anything directly. If developer wants to allocate multiple video layers,
+ * try to use DOVEFB_IOCTL_CREATE_VID_BUFFER  to request a brand new video
+ * buffer.
+ */
+#define DOVEFB_IOCTL_GET_BUFF_ADDR		_IO(DOVEFB_IOC_MAGIC, 9)
+
+/* Get/Set offset position of screen */
+#define DOVEFB_IOCTL_SET_VID_OFFSET		_IO(DOVEFB_IOC_MAGIC, 10)
+#define DOVEFB_IOCTL_GET_VID_OFFSET		_IO(DOVEFB_IOC_MAGIC, 11)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define DOVEFB_IOCTL_SET_MEMORY_TOGGLE		_IO(DOVEFB_IOC_MAGIC, 12)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define DOVEFB_IOCTL_SET_COLORKEYnALPHA		_IO(DOVEFB_IOC_MAGIC, 13)
+#define DOVEFB_IOCTL_GET_COLORKEYnALPHA		_IO(DOVEFB_IOC_MAGIC, 14)
+#define DOVEFB_IOCTL_SWITCH_GRA_OVLY		_IO(DOVEFB_IOC_MAGIC, 15)
+#define DOVEFB_IOCTL_SWITCH_VID_OVLY		_IO(DOVEFB_IOC_MAGIC, 16)
+
+/* For Vmeta integration */
+#define DOVEFB_IOCTL_GET_FREELIST		_IO(DOVEFB_IOC_MAGIC, 17)
+
+/* Wait for vsync happen. */
+#define DOVEFB_IOCTL_WAIT_VSYNC			_IO(DOVEFB_IOC_MAGIC, 18)
+
+/* for xv+vmeta/sw decoder w/o memory move. */
+#define DOVEFB_IOCTL_GET_FBPA			_IO(DOVEFB_IOC_MAGIC, 19)
+#define DOVEFB_IOCTL_GET_FBID			_IO(DOVEFB_IOC_MAGIC, 20)
+#define DOVEFB_IOCTL_SET_SRC_MODE		_IO(DOVEFB_IOC_MAGIC, 21)
+#define DOVEFB_IOCTL_GET_SRC_MODE		_IO(DOVEFB_IOC_MAGIC, 22)
+
+/* Dynamic get EDID data */
+#define DOVEFB_IOCTL_GET_EDID_INFO		_IO(DOVEFB_IOC_MAGIC, 23)
+#define DOVEFB_IOCTL_GET_EDID_DATA		_IO(DOVEFB_IOC_MAGIC, 24)
+#define DOVEFB_IOCTL_SET_EDID_INTERVAL		_IO(DOVEFB_IOC_MAGIC, 25)
+
+/* Video overlay ioctls */
+#define DOVEFB_IOCTL_NEXT_FRAME_PRESENT		_IO(DOVEFB_IOC_MAGIC, 26)
+#define DOVEFB_IOCTL_SET_INTERPOLATION_MODE	_IO(DOVEFB_IOC_MAGIC, 27)
+
+/* clear framebuffer: Makes resolution or color space changes look nicer */
+#define FBIO_CLEAR_FRAMEBUFFER			_IO(FB_IOC_MAGIC, 19)
+
+/* Global alpha blend controls - Maintaining compatibility with existing
+   user programs. */
+#define FBIOPUT_VIDEO_ALPHABLEND            0xeb
+#define FBIOPUT_GLOBAL_ALPHABLEND           0xe1
+#define FBIOPUT_GRAPHIC_ALPHABLEND          0xe2
+
+/* color swapping */
+#define FBIOPUT_SWAP_GRAPHIC_RED_BLUE       0xe3
+#define FBIOPUT_SWAP_GRAPHIC_U_V            0xe4
+#define FBIOPUT_SWAP_GRAPHIC_Y_UV           0xe5
+#define FBIOPUT_SWAP_VIDEO_RED_BLUE         0xe6
+#define FBIOPUT_SWAP_VIDEO_U_V              0xe7
+#define FBIOPUT_SWAP_VIDEO_Y_UV             0xe8
+
+/* colorkey compatibility */
+#define FBIOGET_CHROMAKEYS                  0xe9
+#define FBIOPUT_CHROMAKEYS                  0xea
+
+#define DOVEFB_VMODE_RGB565			0x100
+#define DOVEFB_VMODE_BGR565			0x101
+#define DOVEFB_VMODE_RGB1555			0x102
+#define DOVEFB_VMODE_BGR1555			0x103
+#define DOVEFB_VMODE_RGB888PACK			0x104
+#define DOVEFB_VMODE_BGR888PACK			0x105
+#define DOVEFB_VMODE_RGB888UNPACK		0x106
+#define DOVEFB_VMODE_BGR888UNPACK		0x107
+#define DOVEFB_VMODE_RGBA888			0x108
+#define DOVEFB_VMODE_BGRA888			0x109
+
+#define	DOVEFB_VMODE_YUV422PACKED		0x0
+#define	DOVEFB_VMODE_YUV422PACKED_SWAPUV	0x1
+#define	DOVEFB_VMODE_YUV422PACKED_SWAPYUorV	0x2
+#define	DOVEFB_VMODE_YUV422PLANAR		0x3
+#define	DOVEFB_VMODE_YUV422PLANAR_SWAPUV	0x4
+#define	DOVEFB_VMODE_YUV422PLANAR_SWAPYUorV	0x5
+#define	DOVEFB_VMODE_YUV420PLANAR		0x6
+#define	DOVEFB_VMODE_YUV420PLANAR_SWAPUV	0x7
+#define	DOVEFB_VMODE_YUV420PLANAR_SWAPYUorV	0x8
+
+#define	DOVEFB_HWCMODE_1BITMODE			0x0
+#define	DOVEFB_HWCMODE_2BITMODE			0x1
+
+#define	DOVEFB_DISABLE_COLORKEY_MODE		0x0
+#define	DOVEFB_ENABLE_Y_COLORKEY_MODE		0x1
+#define	DOVEFB_ENABLE_U_COLORKEY_MODE		0x2
+#define	DOVEFB_ENABLE_V_COLORKEY_MODE		0x4
+#define	DOVEFB_ENABLE_RGB_COLORKEY_MODE		0x3
+#define	DOVEFB_ENABLE_R_COLORKEY_MODE		0x5
+#define	DOVEFB_ENABLE_G_COLORKEY_MODE		0x6
+#define	DOVEFB_ENABLE_B_COLORKEY_MODE		0x7
+
+#define DOVEFB_VID_PATH_ALPHA               0x0
+#define DOVEFB_GRA_PATH_ALPHA               0x1
+#define DOVEFB_CONFIG_ALPHA                 0x2
+
+#define DOVEFB_SYNC_COLORKEY_TO_CHROMA          1
+#define DOVEFB_SYNC_CHROMA_TO_COLORKEY          2
+
+/* Compatible to pxa168. */
+#define FB_IOCTL_SET_COLORKEYnALPHA            _IO(FB_IOC_MAGIC, 13)
+#define FB_IOCTL_GET_COLORKEYnALPHA            _IO(FB_IOC_MAGIC, 14)
+#define FB_VID_PATH_ALPHA               0x0
+#define FB_GRA_PATH_ALPHA               0x1
+#define FB_CONFIG_ALPHA                 0x2
+
+#define FB_SYNC_COLORKEY_TO_CHROMA          1
+#define FB_SYNC_CHROMA_TO_COLORKEY          2
+
+#define DOVEFB_FB_NUM		2
+
+/* ---------------------------------------------- */
+/*              Data Structure                    */
+/* ---------------------------------------------- */
+struct _sEdidInfo {
+	int connect;		/* is monitor connected */
+				/* =0, monitor is disconnected.
+				   =1, monitor is connected and EDID is ready.
+				   =2, return fake EDID.
+				   =3, monitor is connected, but EDID failed. */
+	int change;		/* is edid data changed */
+	int extension;		/* the number of extension edid block */
+	int interval;		/* the interval to check edid */
+};
+/*
+ * The follow structures are used to pass data from
+ * user space into the kernel for the creation of
+ * overlay surfaces and setting the video mode.
+ */
+
+#define DOVEFBVideoMode signed int
+
+struct _sViewPortInfo {
+	unsigned short srcWidth;	/* video source size */
+	unsigned short srcHeight;
+	unsigned short zoomXSize;	/* size after zooming */
+	unsigned short zoomYSize;
+	unsigned short ycPitch;
+	unsigned short uvPitch;
+};
+
+struct _sViewPortOffset {
+	unsigned short xOffset;		/* position on screen */
+	unsigned short yOffset;
+};
+
+struct _sVideoBufferAddr {
+	unsigned char	frameID;	/* which frame wants */
+	unsigned char *startAddr;	/* new buffer (PA) */
+	unsigned char *inputData;	/* input buf address (VA) */
+	unsigned int length;		/* input data's length */
+};
+
+struct dovefb_chroma {
+        u_char     mode;
+        u_char     y_alpha;
+        u_char     y;
+        u_char     y1;
+        u_char     y2;
+        u_char     u_alpha;
+        u_char     u;
+        u_char     u1;
+        u_char     u2;
+        u_char     v_alpha;
+        u_char     v;
+        u_char     v1;
+        u_char     v2;
+};
+
+struct _sColorKeyNAlpha {
+        unsigned int mode;
+        unsigned int alphapath;
+        unsigned int config;
+        unsigned int Y_ColorAlpha;
+        unsigned int U_ColorAlpha;
+        unsigned int V_ColorAlpha;
+};
+
+struct _sOvlySurface {
+	DOVEFBVideoMode videoMode;
+	struct _sViewPortInfo viewPortInfo;
+	struct _sViewPortOffset viewPortOffset;
+	struct _sVideoBufferAddr videoBufferAddr;
+};
+
+struct _sCursorConfig {
+	unsigned char	enable;		/* enable cursor or not */
+	unsigned char	mode;		/* 1bit or 2bit mode */
+	unsigned int color1;		/* foreground color */
+	unsigned int color2;		/* background color */
+	unsigned short xoffset;
+	unsigned short yoffset;
+	unsigned short	width;
+	unsigned short height;
+	unsigned char *pBuffer;		/* cursor data */
+};
+
+#define SHM_NORMAL		0x01
+#define SHM_VMETA		0x02
+#define SHM_SOFTWARE_MAP	0x04
+
+struct shm_private_info {
+	unsigned int method;
+	unsigned int fbid;
+	unsigned int format;
+	unsigned int width;
+	unsigned int height;
+	unsigned long fb_pa;
+};
+
+/* MAX bytes per yuv pixel. */
+#define MAX_YUV_PIXEL	2
+
+/* Dumb interface */
+#define DOVEFB_PINS_DUMB_24		0
+#define DOVEFB_PINS_DUMB_18_SPI		1
+#define DOVEFB_PINS_DUMB_18_GPIO	2
+#define DOVEFB_PINS_DUMB_16_SPI		3
+#define DOVEFB_PINS_DUMB_16_GPIO	4
+#define DOVEFB_PINS_DUMB_12_SPI_GPIO	5
+#define DOVEFB_PINS_SMART_18_SPI	6
+#define DOVEFB_PINS_SMART_16_SPI	7
+#define DOVEFB_PINS_SMART_8_SPI_GPIO	8
+
+/* Dumb interface pin allocation */
+#define DOVEFB_DUMB_PANEL_RGB565	0
+#define DOVEFB_DUMB_PANEL_RGB565_UPPER	1
+#define DOVEFB_DUMB_PANEL_RGB666	2
+#define DOVEFB_DUMB_PANEL_RGB666_UPPER	3
+#define DOVEFB_DUMB_PANEL_RGB444	4
+#define DOVEFB_DUMB_PANEL_RGB444_UPPER	5
+#define DOVEFB_DUMB_PANEL_RGB888	6
+
+/* Max fb buffer. 2048x2048-32bits */
+#define DEFAULT_FB_SIZE	(2048 * 2048 * 4)
+
+/*
+ * Buffer pixel format
+ * bit0 is for rb swap.
+ * bit12 is for Y UorV swap
+ */
+/*
+#define PIX_FMT_RGB565		0
+#define PIX_FMT_BGR565		1
+#define PIX_FMT_RGB1555		2
+#define PIX_FMT_BGR1555		3
+#define PIX_FMT_RGB888PACK	4
+#define PIX_FMT_BGR888PACK	5
+#define PIX_FMT_RGB888UNPACK	6
+#define PIX_FMT_BGR888UNPACK	7
+#define PIX_FMT_RGBA888		8
+#define PIX_FMT_BGRA888		9
+#define PIX_FMT_YUV422PACK	10
+#define PIX_FMT_YVU422PACK	11
+#define PIX_FMT_YUV422PLANAR	12
+#define PIX_FMT_YVU422PLANAR	13
+#define PIX_FMT_YUV420PLANAR	14
+#define PIX_FMT_YVU420PLANAR	15
+#define PIX_FMT_PSEUDOCOLOR	20
+#define PIX_FMT_UYVY422PACK	(0x1000|PIX_FMT_YUV422PACK)
+*/
+
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+
+enum dovefb_type {
+	DOVEFB_GFX_PLANE,
+	DOVEFB_OVLY_PLANE
+};
+
+#define MRVL_AXI_CLK		0
+#define MRVL_EXT_CLK0	1
+#define MRVL_PLL_CLK		2
+#define MRVL_EXT_CLK1	3
+
+struct dovefb_layer_info {
+	struct device		*dev;
+	enum dovefb_type	type;
+	struct dovefb_info	*info;
+	struct fb_info		*fb_info;
+
+	void			*reg_base;
+
+	unsigned long		new_addr;
+	dma_addr_t		fb_start_dma;
+	void			*fb_start;
+	int			fb_size;
+	atomic_t		w_intr;
+	wait_queue_head_t	w_intr_wq;
+	struct mutex		access_ok;
+	struct _sOvlySurface	surface;
+	struct _sColorKeyNAlpha ckey_alpha;
+	/* Following used to bypass vide frame queuing */
+	unsigned int		vid_ovly_phys_addr_y;
+	unsigned int		vid_ovly_phys_addr_u;
+	unsigned int		vid_ovly_phys_addr_v;
+
+	unsigned char		*hwc_buf;
+	unsigned int		pseudo_palette[16];
+	struct tasklet_struct	tasklet;
+	char			*mode_option;
+
+	int			ddc_polling_disable;
+	struct timer_list	get_edid_timer;
+	unsigned char*		raw_edid;
+	struct _sEdidInfo	edid_info;
+	struct work_struct      work_queue;
+
+	int			pix_fmt;
+	unsigned		is_blanked:1;
+	unsigned		cursor_enabled:1;
+	unsigned		cursor_cfg:1;
+	unsigned		active:1;
+	unsigned		enabled:1;
+	unsigned                checkbuf_timer_exist:1;
+
+	/*
+	 * 0: DMA mem is from DMA region.
+	 * 1: DMA mem is from normal region.
+	 */
+	unsigned		mem_status:1;
+
+	/*
+	 * current frame id for mapping to user.
+	 */
+	int			cur_fbid;
+	int			src_mode;
+
+	unsigned int		reserved;
+};
+
+/*
+ * Dove LCD controller private state.
+ */
+struct dovefb_info {
+	struct device			*dev;
+	int				id;
+
+	void				*reg_base;
+	struct dovefb_layer_info	*gfx_plane;
+	struct dovefb_layer_info	*vid_plane;
+
+	struct fb_videomode		dft_vmode;
+	struct fb_videomode		out_vmode;
+	int				fixed_output;
+
+	char				*mode_option;
+	struct clk			*clk;
+	int				clk_src;
+	int				io_pin_allocation;
+
+	int			pix_fmt;
+	unsigned		edid:1;
+	unsigned		panel_rbswap:1;
+	unsigned		edid_en:1;
+
+        /* Hardware cursor related registers */
+	unsigned int LCD_SPU_HWC_HPXL_VLN_saved_value;
+	unsigned int LCD_SPU_ALPHA_COLOR1_saved_value;
+	unsigned int LCD_SPU_ALPHA_COLOR2_saved_value;
+
+	/* Colorkey related registers */
+	unsigned int LCD_SPU_COLORKEY_Y_saved_value;
+	unsigned int LCD_SPU_COLORKEY_U_saved_value;
+	unsigned int LCD_SPU_COLORKEY_V_saved_value;
+	unsigned int LCD_SPU_DMA_CTRL1_saved_value;
+	unsigned int LCD_SPU_ADV_REG_saved_value;
+};
+
+/*
+ * Dove fb machine information
+ */
+struct dovefb_mach_info {
+	char		id_gfx[16];
+	char		id_ovly[16];
+	int		clk_src;
+	int		accurate_clk;
+	char		*clk_name;
+	int		num_modes;
+	struct fb_videomode *modes;
+
+	/*
+	 * Pix_fmt
+	 */
+	unsigned	pix_fmt;
+
+	/*
+	 * I/O pin allocation.
+	 */
+	unsigned	io_pin_allocation:4;
+
+	/* 
+	 * auto poll EDID data periodically
+	 */
+	unsigned ddc_polling_disable:1;
+
+	/*
+	 * Monitor sense
+	 */
+	int (*mon_sense)(int *connect_status);
+
+	/*
+	 * I2C bus and address to read DDC data through. -1 not available
+	 */
+	int		ddc_i2c_adapter;
+	int		ddc_i2c_address;
+
+	/*
+	 * secondary i2c pair for two display on same LCD.
+	 */
+	int		secondary_ddc_mode;
+	int		ddc_i2c_adapter_2nd;
+	int		ddc_i2c_address_2nd;
+
+	/*
+	 * Dumb panel -- assignment of R/G/B component info to the 24
+	 * available external data lanes.
+	 */
+	unsigned	panel_rgb_type:4;
+	unsigned	panel_rgb_reverse_lanes:1;
+
+	/*
+	 * Dumb panel -- GPIO output data.
+	 */
+	unsigned	gpio_output_mask:8;
+	unsigned	gpio_output_data:8;
+
+	/*
+	 * Dumb panel -- configurable output signal polarity.
+	 */
+	unsigned	invert_composite_blank:1;
+	unsigned	invert_pix_val_ena:1;
+	unsigned	invert_pixclock:1;
+	unsigned	invert_vsync:1;
+	unsigned	invert_hsync:1;
+	unsigned	panel_rbswap:1;
+	unsigned	active:1;
+	unsigned	enable_lcd0:1;
+};
+
+struct dovebl_platform_data;
+
+int clcd_platform_init(struct dovefb_mach_info *lcd0_dmi_data,
+		       struct dovefb_mach_info *lcd0_vid_dmi_data,
+		       struct dovefb_mach_info *lcd1_dmi_data,
+		       struct dovefb_mach_info *lcd1_vid_dmi_data,
+		       struct dovebl_platform_data *backlight_data);
+
+
+#endif /* _KERNEL_ */
+#endif /* _DOVEFB_H_ */
-- 
1.7.4.1

