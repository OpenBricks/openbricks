diff --git a/xbmc/windowing/gbm/CMakeLists.txt b/xbmc/windowing/gbm/CMakeLists.txt
index 800e2927b9b8..12655e7cc268 100644
--- a/xbmc/windowing/gbm/CMakeLists.txt
+++ b/xbmc/windowing/gbm/CMakeLists.txt
@@ -3,6 +3,7 @@ set(SOURCES GLContextEGL.cpp
             GBMUtils.cpp
             DRMUtils.cpp
             DRMLegacy.cpp
+            DRMAtomic.cpp
             DRM.cpp)
 
 set(HEADERS GLContextEGL.h
@@ -10,6 +11,7 @@ set(HEADERS GLContextEGL.h
             GBMUtils.h
             DRMUtils.h
             DRMLegacy.h
+            DRMAtomic.h
             DRM.h)
 
 if(OPENGLES_FOUND)
diff --git a/xbmc/windowing/gbm/DRM.cpp b/xbmc/windowing/gbm/DRM.cpp
index 0cfc08d10868..c334b833a100 100644
--- a/xbmc/windowing/gbm/DRM.cpp
+++ b/xbmc/windowing/gbm/DRM.cpp
@@ -21,21 +21,47 @@
 #include "utils/log.h"
 
 #include "DRM.h"
+#include "DRMAtomic.h"
 #include "DRMLegacy.h"
 
+CDRM::CDRM()
+  : m_hasAtomic(false)
+{
+}
+
 void CDRM::FlipPage(CGLContextEGL *pGLContext)
 {
-  CDRMLegacy::FlipPage(pGLContext);
+  if (m_hasAtomic)
+  {
+    CDRMAtomic::FlipPage(pGLContext);
+  }
+  else
+  {
+    CDRMLegacy::FlipPage(pGLContext);
+  }
 }
 
 bool CDRM::SetVideoMode(RESOLUTION_INFO res)
 {
-  return CDRMLegacy::SetVideoMode(res);
+  if (m_hasAtomic)
+  {
+    return CDRMAtomic::SetVideoMode(res);
+  }
+  else
+  {
+    return CDRMLegacy::SetVideoMode(res);
+  }
 }
 
 bool CDRM::InitDrm(drm *drm, gbm *gbm)
 {
-  if (CDRMLegacy::InitDrmLegacy(drm, gbm))
+  if (CDRMAtomic::InitDrmAtomic(drm, gbm))
+  {
+    m_hasAtomic = true;
+    CLog::Log(LOGNOTICE, "CDRM::%s - initialized Atomic DRM", __FUNCTION__);
+    return true;
+  }
+  else if (CDRMLegacy::InitDrmLegacy(drm, gbm))
   {
     CLog::Log(LOGNOTICE, "CDRM::%s - initialized Legacy DRM", __FUNCTION__);
     return true;
@@ -46,5 +72,12 @@ bool CDRM::InitDrm(drm *drm, gbm *gbm)
 
 void CDRM::DestroyDrm()
 {
-  CDRMLegacy::DestroyDrmLegacy();
+  if (m_hasAtomic)
+  {
+    CDRMAtomic::DestroyDrmAtomic();
+  }
+  else
+  {
+    CDRMLegacy::DestroyDrmLegacy();
+  }
 }
diff --git a/xbmc/windowing/gbm/DRM.h b/xbmc/windowing/gbm/DRM.h
index 870a6fe2b93e..08de82bd0cb8 100644
--- a/xbmc/windowing/gbm/DRM.h
+++ b/xbmc/windowing/gbm/DRM.h
@@ -26,9 +26,13 @@
 class CDRM
 {
 public:
+  CDRM();
   ~CDRM() = default;
   void FlipPage(CGLContextEGL *pGLContext);
   bool SetVideoMode(RESOLUTION_INFO res);
   bool InitDrm(drm *drm, gbm *gbm);
   void DestroyDrm();
+
+private:
+  bool m_hasAtomic;
 };
diff --git a/xbmc/windowing/gbm/DRMAtomic.cpp b/xbmc/windowing/gbm/DRMAtomic.cpp
new file mode 100644
index 000000000000..059d3bd6dcf5
--- /dev/null
+++ b/xbmc/windowing/gbm/DRMAtomic.cpp
@@ -0,0 +1,449 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <errno.h>
+#include <drm/drm_mode.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+#include "DRMAtomic.h"
+#include "WinSystemGbmGLESContext.h"
+
+static struct drm *m_drm = nullptr;
+static struct gbm *m_gbm = nullptr;
+
+static struct drm_fb *m_drm_fb = new drm_fb;
+
+static struct gbm_bo *m_bo = nullptr;
+static struct gbm_bo *m_next_bo = nullptr;
+
+bool CDRMAtomic::AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct connector *obj = m_drm->connector;
+  int prop_id = 0;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no connector property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct crtc *obj = m_drm->crtc;
+  int prop_id = -1;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no crtc property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct plane *obj = m_drm->plane;
+  int prop_id = -1;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no plane property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::DrmAtomicCommit(int fb_id, int flags)
+{
+  drmModeAtomicReq *req;
+  int plane_id = m_drm->plane->plane->plane_id;
+  uint32_t blob_id;
+
+  req = drmModeAtomicAlloc();
+
+  if (flags & DRM_MODE_ATOMIC_ALLOW_MODESET)
+  {
+    if (!AddConnectorProperty(req, m_drm->connector_id, "CRTC_ID", m_drm->crtc_id))
+    {
+      return false;
+    }
+
+    if (drmModeCreatePropertyBlob(m_drm->fd, m_drm->mode, sizeof(*m_drm->mode), &blob_id) != 0)
+    {
+      return false;
+    }
+
+    if (!AddCrtcProperty(req, m_drm->crtc_id, "MODE_ID", blob_id))
+    {
+      return false;
+    }
+
+    if (!AddCrtcProperty(req, m_drm->crtc_id, "ACTIVE", 1))
+    {
+      return false;
+    }
+  }
+
+  AddPlaneProperty(req, plane_id, "FB_ID", fb_id);
+  AddPlaneProperty(req, plane_id, "CRTC_ID", m_drm->crtc_id);
+  AddPlaneProperty(req, plane_id, "SRC_X", 0);
+  AddPlaneProperty(req, plane_id, "SRC_Y", 0);
+  AddPlaneProperty(req, plane_id, "SRC_W", m_drm->mode->hdisplay << 16);
+  AddPlaneProperty(req, plane_id, "SRC_H", m_drm->mode->vdisplay << 16);
+  AddPlaneProperty(req, plane_id, "CRTC_X", 0);
+  AddPlaneProperty(req, plane_id, "CRTC_Y", 0);
+  AddPlaneProperty(req, plane_id, "CRTC_W", m_drm->mode->hdisplay);
+  AddPlaneProperty(req, plane_id, "CRTC_H", m_drm->mode->vdisplay);
+
+  if (m_drm->kms_in_fence_fd != -1)
+  {
+    AddCrtcProperty(req, m_drm->crtc_id, "OUT_FENCE_PTR", (uint64_t)(unsigned long)&m_drm->kms_out_fence_fd);
+    AddPlaneProperty(req, plane_id, "IN_FENCE_FD", m_drm->kms_in_fence_fd);
+  }
+
+  auto ret = drmModeAtomicCommit(m_drm->fd, req, flags, nullptr);
+  if (ret)
+  {
+    return false;
+  }
+
+  if (m_drm->kms_in_fence_fd != -1)
+  {
+    close(m_drm->kms_in_fence_fd);
+    m_drm->kms_in_fence_fd = -1;
+  }
+
+  return true;
+}
+
+void CDRMAtomic::FlipPage(CGLContextEGL *pGLContext)
+{
+  int flags = DRM_MODE_ATOMIC_NONBLOCK;
+
+  pGLContext->CreateGPUFence();
+  m_drm->kms_in_fence_fd = pGLContext->FlushFence();
+  pGLContext->WaitSyncCPU();
+
+  gbm_surface_release_buffer(m_gbm->surface, m_bo);
+  m_bo = m_next_bo;
+
+  m_next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
+  if (!m_next_bo)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to lock frontbuffer", __FUNCTION__);
+    return;
+  }
+
+  m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_next_bo);
+  if (!m_drm_fb)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to get a new FBO", __FUNCTION__);
+    return;
+  }
+
+  auto ret = DrmAtomicCommit(m_drm_fb->fb_id, flags);
+  if (!ret) {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - failed to commit: %s", __FUNCTION__, strerror(errno));
+    return;
+  }
+
+  pGLContext->CreateKMSFence(m_drm->kms_out_fence_fd);
+  pGLContext->WaitSyncGPU();
+  m_drm->kms_out_fence_fd = -1;
+
+  if(g_Windowing.NoOfBuffers() > 2 && gbm_surface_has_free_buffers(m_gbm->surface))
+  {
+    return;
+  }
+
+  gbm_surface_release_buffer(m_gbm->surface, m_bo);
+  m_bo = m_next_bo;
+}
+
+int CDRMAtomic::GetPlaneId()
+{
+  drmModePlaneResPtr plane_resources;
+  int ret = -EINVAL;
+  int found_primary = 0;
+
+  plane_resources = drmModeGetPlaneResources(m_drm->fd);
+  if (!plane_resources)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - drmModeGetPlaneResources failed: %s", __FUNCTION__, strerror(errno));
+    return -1;
+  }
+
+  for (uint32_t i = 0; (i < plane_resources->count_planes) && !found_primary; i++)
+  {
+    uint32_t id = plane_resources->planes[i];
+    drmModePlanePtr plane = drmModeGetPlane(m_drm->fd, id);
+    if (!plane)
+    {
+      CLog::Log(LOGERROR, "CDRMAtomic::%s - drmModeGetPlane(%u) failed: %s", __FUNCTION__, id, strerror(errno));
+      continue;
+    }
+
+    if (plane->possible_crtcs & (1 << m_drm->crtc_index))
+    {
+      drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(m_drm->fd, id, DRM_MODE_OBJECT_PLANE);
+
+      /* primary or not, this plane is good enough to use: */
+      ret = id;
+
+      for (uint32_t j = 0; j < props->count_props; j++)
+      {
+        drmModePropertyPtr p = drmModeGetProperty(m_drm->fd, props->props[j]);
+
+        if ((strcmp(p->name, "type") == 0) && (props->prop_values[j] == DRM_PLANE_TYPE_PRIMARY))
+        {
+          /* found our primary plane, lets use that: */
+          found_primary = 1;
+        }
+
+        drmModeFreeProperty(p);
+      }
+
+      drmModeFreeObjectProperties(props);
+    }
+
+    drmModeFreePlane(plane);
+  }
+
+  drmModeFreePlaneResources(plane_resources);
+
+  return ret;
+}
+
+bool CDRMAtomic::InitDrmAtomic(drm *drm, gbm *gbm)
+{
+  int plane_id;
+  int ret;
+
+  m_drm = drm;
+  m_gbm = gbm;
+
+  m_drm->kms_out_fence_fd = -1;
+
+  if (!CDRMUtils::InitDrm(m_drm))
+  {
+    return false;
+  }
+
+  ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_ATOMIC, 1);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no atomic modesetting support: %s", __FUNCTION__, strerror(errno));
+    return false;
+  }
+
+  ret = GetPlaneId();
+  if (!ret)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not find a suitable plane", __FUNCTION__);
+    return false;
+  }
+  else
+  {
+    plane_id = ret;
+  }
+
+  /* We only do single plane to single crtc to single connector, no
+     * fancy multi-monitor or multi-plane stuff.  So just grab the
+     * plane/crtc/connector property info for one of each:
+     */
+  m_drm->plane = new plane;
+  m_drm->crtc = new crtc;
+  m_drm->connector = new connector;
+
+  // plane
+  m_drm->plane->plane = drmModeGetPlane(m_drm->fd, plane_id);
+  if (!m_drm->plane->plane)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %i: %s", __FUNCTION__, plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->plane->props = drmModeObjectGetProperties(m_drm->fd, plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_drm->plane->props)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %u properties: %s", __FUNCTION__, plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->plane->props->count_props; i++)
+  {
+    m_drm->plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->plane->props->props[i]);             \
+  }
+
+  // crtc
+  m_drm->crtc->crtc = drmModeGetCrtc(m_drm->fd, m_drm->crtc_id);
+  if (!m_drm->crtc->crtc)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get crtc %i: %s", __FUNCTION__, m_drm->crtc_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->crtc->props = drmModeObjectGetProperties(m_drm->fd, m_drm->crtc_id, DRM_MODE_OBJECT_CRTC);
+  if (!m_drm->crtc->props)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get crtc %u properties: %s", __FUNCTION__, m_drm->crtc_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->crtc->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->crtc->props->count_props; i++)
+  {
+    m_drm->crtc->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->crtc->props->props[i]);             \
+  }
+
+  // connector
+  m_drm->connector->connector = drmModeGetConnector(m_drm->fd, m_drm->connector_id);
+  if (!m_drm->connector->connector)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %i: %s", __FUNCTION__, m_drm->connector_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->connector->props = drmModeObjectGetProperties(m_drm->fd, m_drm->connector_id, DRM_MODE_OBJECT_CONNECTOR);
+  if (!m_drm->connector->props)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get connector %u properties: %s", __FUNCTION__, m_drm->connector_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->connector->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->connector->props->count_props; i++)
+  {
+    m_drm->connector->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->connector->props->props[i]);             \
+  }
+
+  //
+  m_gbm->dev = gbm_create_device(m_drm->fd);
+
+  if (!CGBMUtils::InitGbm(m_gbm, m_drm->mode->hdisplay, m_drm->mode->vdisplay))
+  {
+    return false;
+  }
+
+  return true;
+}
+
+void CDRMAtomic::DestroyDrmAtomic()
+{
+  CDRMUtils::DestroyDrm();
+
+  if(m_gbm->surface)
+  {
+    gbm_surface_destroy(m_gbm->surface);
+  }
+
+  if(m_gbm->dev)
+  {
+    gbm_device_destroy(m_gbm->dev);
+  }
+}
+
+bool CDRMAtomic::SetVideoMode(RESOLUTION_INFO res)
+{
+  CDRMUtils::GetMode(res);
+
+  gbm_surface_release_buffer(m_gbm->surface, m_bo);
+  m_bo = m_next_bo;
+
+  m_next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
+  if (!m_next_bo)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to lock frontbuffer", __FUNCTION__);
+    return false;
+  }
+
+  m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_next_bo);
+  if (!m_drm_fb)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to get a new FBO", __FUNCTION__);
+    return false;
+  }
+
+  auto ret = DrmAtomicCommit(m_drm_fb->fb_id, DRM_MODE_ATOMIC_ALLOW_MODESET);
+  if (!ret)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - failed to commit modeset: %s", __FUNCTION__, strerror(errno));
+    return false;
+  }
+
+  return true;
+}
diff --git a/xbmc/windowing/gbm/DRMAtomic.h b/xbmc/windowing/gbm/DRMAtomic.h
new file mode 100644
index 000000000000..5b6495a5641a
--- /dev/null
+++ b/xbmc/windowing/gbm/DRMAtomic.h
@@ -0,0 +1,40 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "DRMUtils.h"
+#include "GLContextEGL.h"
+
+class CDRMAtomic : public CDRMUtils
+{
+public:
+  static void FlipPage(CGLContextEGL *pGLContext);
+  static bool SetVideoMode(RESOLUTION_INFO res);
+  static bool InitDrmAtomic(drm *drm, gbm *gbm);
+  static void DestroyDrmAtomic();
+
+private:
+  static bool AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  static bool AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  static bool AddPlaneProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  static bool DrmAtomicCommit(int fb_id, int flags);
+  static int GetPlaneId();
+};
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 25eb2d02fa84..f95754587bb6 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -28,6 +28,13 @@
 #include "guilib/Resolution.h"
 #include "GBMUtils.h"
 
+struct plane
+{
+  drmModePlane *plane;
+  drmModeObjectProperties *props;
+  drmModePropertyRes **props_info;
+};
+
 struct crtc
 {
   drmModeCrtc *crtc;
@@ -46,9 +53,13 @@ struct drm
 {
   int fd;
 
+  /* only used for atomic: */
+  struct plane *plane;
   struct crtc *crtc;
   struct connector *connector;
   int crtc_index;
+  int kms_in_fence_fd;
+  int kms_out_fence_fd;
 
   drmModeModeInfo *mode;
   uint32_t crtc_id;
diff --git a/xbmc/windowing/gbm/GLContextEGL.cpp b/xbmc/windowing/gbm/GLContextEGL.cpp
index 392080ba830f..41ff1de79546 100644
--- a/xbmc/windowing/gbm/GLContextEGL.cpp
+++ b/xbmc/windowing/gbm/GLContextEGL.cpp
@@ -24,14 +24,15 @@
 #include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
-#include <EGL/eglext.h>
 #include <string.h>
 
 CGLContextEGL::CGLContextEGL() :
   m_eglDisplay(EGL_NO_DISPLAY),
   m_eglSurface(EGL_NO_SURFACE),
   m_eglContext(EGL_NO_CONTEXT),
-  m_eglConfig(0)
+  m_eglConfig(0),
+  m_gpuFence(nullptr),
+  m_kmsFence(nullptr)
 {
 }
 
@@ -250,3 +251,87 @@ void CGLContextEGL::SwapBuffers()
 
   eglSwapBuffers(m_eglDisplay, m_eglSurface);
 }
+
+EGLSyncKHR CGLContextEGL::CreateFence(int fd)
+{
+  EGLint attrib_list[] =
+  {
+    EGL_SYNC_NATIVE_FENCE_FD_ANDROID, fd,
+    EGL_NONE,
+  };
+
+  PFNEGLCREATESYNCKHRPROC eglCreateSyncKHR = (PFNEGLCREATESYNCKHRPROC)eglGetProcAddress("eglCreateSyncKHR");
+
+  EGLSyncKHR fence = eglCreateSyncKHR(m_eglDisplay, EGL_SYNC_NATIVE_FENCE_ANDROID, attrib_list);
+
+  return fence;
+}
+
+void CGLContextEGL::CreateGPUFence()
+{
+  m_gpuFence = CreateFence(EGL_NO_NATIVE_FENCE_FD_ANDROID);
+}
+
+void CGLContextEGL::CreateKMSFence(int kms_out_fence_fd)
+{
+  m_kmsFence = CreateFence(kms_out_fence_fd);
+}
+
+EGLint CGLContextEGL::FlushFence()
+{
+  PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID = (PFNEGLDUPNATIVEFENCEFDANDROIDPROC)eglGetProcAddress("eglDupNativeFenceFDANDROID");
+  PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR = (PFNEGLDESTROYSYNCKHRPROC)eglGetProcAddress("eglDestroySyncKHR");
+
+  auto fd = eglDupNativeFenceFDANDROID(m_eglDisplay, m_gpuFence);
+
+  if (fd < 0)
+  {
+    return -1;
+  }
+
+  eglDestroySyncKHR(m_eglDisplay, m_gpuFence);
+
+  return fd;
+}
+
+void CGLContextEGL::WaitSyncGPU()
+{
+  if (m_kmsFence == 0)
+  {
+    return;
+  }
+
+  PFNEGLWAITSYNCKHRPROC eglWaitSyncKHR = (PFNEGLWAITSYNCKHRPROC)eglGetProcAddress("eglWaitSyncKHR");
+
+  /* wait "on the gpu" (ie. this won't necessarily block, but
+   * will block the rendering until fence is signaled), until
+   * the previous pageflip completes so we don't render into
+   * the buffer that is still on screen.
+   */
+  eglWaitSyncKHR(m_eglDisplay, m_kmsFence, 0);
+}
+
+void CGLContextEGL::WaitSyncCPU()
+{
+  if (m_kmsFence)
+  {
+    EGLint status;
+    PFNEGLCLIENTWAITSYNCKHRPROC eglClientWaitSyncKHR = (PFNEGLCLIENTWAITSYNCKHRPROC)eglGetProcAddress("eglClientWaitSyncKHR");
+    PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR = (PFNEGLDESTROYSYNCKHRPROC)eglGetProcAddress("eglDestroySyncKHR");
+
+    /* Wait on the CPU side for the _previous_ commit to
+     * complete before we post the flip through KMS, as
+     * atomic will reject the commit if we post a new one
+     * whilst the previous one is still pending.
+     */
+    do
+    {
+      status = eglClientWaitSyncKHR(m_eglDisplay,
+                                    m_kmsFence,
+                                    0,
+                                    EGL_FOREVER_KHR);
+    } while (status != EGL_CONDITION_SATISFIED_KHR);
+
+    eglDestroySyncKHR(m_eglDisplay, m_kmsFence);
+  }
+}
diff --git a/xbmc/windowing/gbm/GLContextEGL.h b/xbmc/windowing/gbm/GLContextEGL.h
index afea42950e87..0dd2427aad95 100644
--- a/xbmc/windowing/gbm/GLContextEGL.h
+++ b/xbmc/windowing/gbm/GLContextEGL.h
@@ -20,7 +20,8 @@
 
 #pragma once
 
-#include "EGL/egl.h"
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
 
 class CGLContextEGL
 {
@@ -40,9 +41,18 @@ class CGLContextEGL
   void Detach();
   bool SetVSync(bool enable);
   void SwapBuffers();
+  EGLSyncKHR CreateFence(int fd);
+  void CreateGPUFence();
+  void CreateKMSFence(int kms_out_fence_fd);
+  EGLint FlushFence();
+  void WaitSyncGPU();
+  void WaitSyncCPU();
 
   EGLDisplay m_eglDisplay;
   EGLSurface m_eglSurface;
   EGLContext m_eglContext;
   EGLConfig m_eglConfig;
+
+  EGLSyncKHR m_gpuFence;
+  EGLSyncKHR m_kmsFence;
 };
