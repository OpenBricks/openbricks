#!/bin/sh

. config/path

KCONFIG=build/config/Kconfig.packages

# process a package and write its configuration stanza to Kconfig.packages
do_package() {
  package=$1
  [ -f packages/$package/install ] || continue

  get_meta $package

  KCONFIG_NAME="$PKG_NAME"
  [ -n "$PKG_SHORTDESC" ] && KCONFIG_NAME="$KCONFIG_NAME - $PKG_SHORTDESC"
  cat >> $KCONFIG <<EOF
config PKG_$PKG_NAME
  tristate "$KCONFIG_NAME"
EOF
  if [ "$PKG_ARCH" != any -a "$PKG_ARCH" != all ]; then
    archlist=""
    for a in $PKG_ARCH; do
      if [ -z "$archlist" ]; then
        archlist="TARGET_ARCH_$a"
      else
        archlist="$archlist || TARGET_ARCH_$a"
      fi
    done
    echo "  depends on ( $archlist )" >> $KCONFIG
  fi
  [ "$PKG_LICENSE" = "non-free" ] && echo "  depends on TAINT" >> $KCONFIG
  for use in $PKG_PARENT_USE; do
    echo "  depends on OPT_`echo ${PKG_PARENT} | sed 's/-//g'`_${use}" >> $KCONFIG
  done

  for d in $PKG_RUN_DEPENDS; do
    [ "$d" != "$PKG_PARENT" ] && echo "  select PKG_$d" >> $KCONFIG
  done

  for use in $PKG_USE; do
    if [ "$use" = "cxx" ]; then
      echo "  select OPT_TOOLCHAIN_CXX" >> $KCONFIG
      continue
    fi
    type=`get_use_type $use`
    if [ -n "$type" ]; then
      for p in `valueof PKG_RUN_DEPENDS_$use`; do
        echo "  select PKG_$p if TARGET_${type}_${use}" >> $KCONFIG
      done
      for p in `valueof PKG_DEPENDS_$use`; do
        echo "  select PKG_$p if TARGET_${type}_${use}" >> $KCONFIG
      done
    fi
  done

  for req in $PKG_REQUIRES_USE; do
    pkg=`echo $req | cut -f1 -d:`
    use=`echo $req | cut -f2 -d:`
    if [ -n "$pkg" ]; then
      echo "  select OPT_`echo $pkg | sed 's/-//g'`_${use}" >> $KCONFIG
    else
      echo "  USE_${use}" >> $KCONFIG
    fi
  done

  [ -n "$PKG_KCONFIG_DEPENDS" ] && echo "$PKG_KCONFIG_DEPENDS" >> $KCONFIG
  [ -n "$PKG_LONGDESC" ] && cat >> $KCONFIG <<EOF
  help
`echo "$PKG_LONGDESC" | fmt | sed 's/^/    /g'`
EOF
  echo >> $KCONFIG
  for use in $PKG_USE; do
    [ -n "`get_use_type $use`" -o "$use" = "cxx" ] && continue

    use_name=`valueof "PKG_USE_NAME_${use}"`
    [ -z "$use_name" ] && use_name=$use
    use_desc=`valueof "PKG_USE_DESC_${use}"`
    [ -z "$use_desc" ] && use_desc="Enable $use_name support"
    use_help=`valueof "PKG_USE_HELP_${use}"`
    [ -z "$use_help" ] && use_help="${use_desc}."
    use_default=`valueof "PKG_USE_DEFAULT_${use}"`
    [ "$use_default" = yes ] && use_default=y || use_default=n
    use_arch=`valueof "PKG_USE_ARCH_${use}"`
    use_platform=`valueof "PKG_USE_PLATFORM_${use}"`

    # strip dashes from the package name, as they are illegal in environment
    # variable names; cf. pkg_uses in config/path
    name=`echo $PKG_NAME | sed 's/-//g'`

    cat >> $KCONFIG <<EOF
config OPT_${name}_${use}
  bool "$use_desc"
  default y if USE_$use
  default $use_default
  depends on PKG_${PKG_NAME}
EOF
    if [ -n "$use_arch" ]; then
      archlist=""
      for arch in $use_arch; do
        [ -n "$archlist" ] && archlist="$archlist || "
        archlist="${archlist}TARGET_ARCH_${arch}"
        if [ -n "$use_platform" ]; then
          platformlist=""
          for platform in $use_platform; do
            [ -n "$platformlist" ] && platformlist="$platformlist || "
            platformlist="${platformlist}TARGET_PLATFORM_${arch}_${platform}"
          done
          echo "  depends on ( $platformlist )" >> $KCONFIG
        fi
      done
      echo "  depends on ( $archlist )" >> $KCONFIG
    fi
    for p in `valueof "PKG_RUN_DEPENDS_${use}"`; do
      echo "  select PKG_$p" >> $KCONFIG
    done
    for p in `valueof "PKG_DEPENDS_${use}"`; do
      echo "  select PKG_$p" >> $KCONFIG
    done
    cat >> $KCONFIG <<EOF
  help
    $use_help
EOF
    echo >> $KCONFIG
  done
  if [ -n "$PKG_KCONFIG_EXTRA" ]; then
    echo "$PKG_KCONFIG_EXTRA" >> $KCONFIG
    echo >> $KCONFIG
  fi
}

echo -n "Building $KCONFIG."

# Kconfig.packages generation starts here
rm -f $KCONFIG

# populate SEC_$section variables with list of packages per section
for package in packages/*; do
  package=`echo $package | sed s:packages/::`
  [ -f packages/$package/meta ] || continue
  # source the package meta to populate PKG_SECTION
  PKG_SECTION=
  . packages/$package/meta
  old=
  cmd=
  var="SEC_$PKG_SECTION"
  old="`valueof $var`"
  cmd="$var=\"$old $package\""
  eval $cmd
done

echo -n .

cat >> $KCONFIG <<EOF
############################################
# This file is autogenerated, do not edit! #
############################################

EOF

SECTIONS="admin drivers filesystem firmware fonts games libs misc multimedia net perl python sound system utils x11"

# check for packages with invalid section name
for package in packages/*; do
  package=`echo $package | sed s:packages/::`
  [ -f packages/$package/meta ] || continue
  . packages/$package/meta
  if [ "$(echo "$SECTIONS" | grep $PKG_SECTION)" != "$SECTIONS" ]; then
    echo ""
    echo "Error: $PKG_NAME has an invalid section name"
    echo " Either fix packages/$package/meta file"
    echo " or add new section name in scripts/meta2config file."
    exit 1
  fi
done

# generate Kconfig menus for the various sections
for section in $SECTIONS; do
  echo "menu \"$section\"" >> $KCONFIG
  for package in `valueof "SEC_$section"`; do
    do_package $package
  done
  echo endmenu >> $KCONFIG
  echo -n .
done

echo "done!"

exit 0

